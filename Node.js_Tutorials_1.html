<html>
	<head>
		<title>JS Tutorials :: Part 2</title>
		<style>
		@font-face {
    font-family: 'pt_sansregular';
    src: url('fonts/PTS55F-webfont.eot');
    src: url('fonts/PTS55F-webfont.eot?#iefix') format('embedded-opentype'),
         url('fonts/PTS55F-webfont.woff') format('woff'),
         url('fonts/PTS55F-webfont.ttf') format('truetype'),
         url('fonts/PTS55F-webfont.svg#pt_sansregular') format('svg');
    font-weight: normal;
    font-style: normal;
}
body { font-family: 'pt_sansregular', Arial, Tahoma, Helvetica, FreeSans, sans-serif; line-height: 1.7; font-size: 14px; }
pre {
	border: 1px dashed #888;
	padding: 15px;
    word-break: normal;
    word-break: break-all;
    word-wrap: break-word;
	    font-size: 13px;
    line-height: 1.42857143;
	white-space: pre-wrap;       /* css-3 */
 white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
 white-space: -pre-wrap;      /* Opera 4-6 */
 white-space: -o-pre-wrap;    /* Opera 7 */
 word-wrap: break-word;       /* Internet Explorer 5.5+ */
 position: relative;
}
pre:after {
content: "CODE";
position: absolute;
right: 0;
top: 0;
padding: 5px 10px;
border-left: 1px dashed #888;
border-bottom: 1px dashed #888;
}
h1{ border-top: 1px solid #666; border-bottom: 2px solid #888; padding: 10px 0; font-size: 20px; text-align: center; }
h2, h3 { font-size: 16px; border-left: 6px solid #666; padding: 5px 15px; }
code, kbd, pre, samp {
    font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
}
code {
    padding: 2px 4px;
    font-size: 90%;
    background-color: #f9f2f4;
    border-radius: 4px;
}
blockquote {
    letter-spacing: .01rem;
    font-weight: 400;
    font-style: italic;
    border-left: 3px solid rgba(0,0,0,0.8);
    padding-left: 20px;
    margin-left: -0;
    margin-bottom: 30px;
    padding-bottom: 3px;
}
@media print {
    img {
        display: block;
        page-break-inside: avoid;
		-webkit-column-break-inside : avoid;
    }
	pre, code, pre code, pre span, code span, pre code span {
		page-break-inside: avoid;
		-webkit-column-break-inside : avoid;
	}
}
		</style>
	</head>
	<body>
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>How does NodeJS work?</h1>
		<div class="section-inner layoutSingleColumn"><h3 name="89f4" id="89f4" class="graf--h3 graf--first">How does NodeJS work?</h3><p name="1899" id="1899" class="graf--p">Hi everyone! My name is Eugene Obrezkov and today I want to talk about one of the "scariest" platforms - NodeJS. I'm going to answer one of the most complicated questions about NodeJS - "<strong class="markup--strong markup--p-strong">How does NodeJS work?</strong>".</p><p name="2a0b" id="2a0b" class="graf--p">I'm going to present this article as if NodeJS didn't exist at all. This way, it should be easier for you to understand what's going on under the hood.</p><p name="5f0b" id="5f0b" class="graf--p">Code found in this post is taken from existing NodeJS sources, so after reading this article, you should be more comfortable with NodeJS.</p><h4 name="ecf9" id="ecf9" class="graf--h4">What do we need this for?</h4><p name="380c" id="380c" class="graf--p">The first question that may come to your mind - <strong class="markup--strong markup--p-strong">"What do we need this for?"</strong>.</p><p name="de53" id="de53" class="graf--p">Here, I'd like to quote Vyacheslav Egorov: <em class="markup--em markup--p-em">"The more people stop seeing JS VM as a mysterious black box that converts JavaScript source into some zeros-and-ones the better"</em>. The same idea applies to NodeJS: <em class="markup--em markup--p-em">"The more people stop seeing NodeJS as a mysterious black box that runs JavaScript with low-level API the better"</em>.</p><h4 name="8710" id="8710" class="graf--h4">Just Do It!</h4><p name="58fd" id="58fd" class="graf--p">Let's go back to 2009, when NodeJS started its way.</p><p name="8519" id="8519" class="graf--p">We'd like to run JavaScript on backend and get access to low-level API. We also want to run our JavaScript from CLI and REPL. Basically, we want <strong class="markup--strong markup--p-strong">JavaScript to do everything</strong>!</p><p name="d0cf" id="d0cf" class="graf--p">How would we do this? The first thing that comes to my mind isâ€¦</p><h4 name="8c05" id="8c05" class="graf--h4">Browser</h4><p name="b526" id="b526" class="graf--p">Browser can execute JavaScript. So we can take a browser, integrate it into our application and that's it.</p><p name="723f" id="723f" class="graf--p">Not really! Here are the questions that need to be answered.</p><p name="c8f8" id="c8f8" class="graf--p">Does browser expose low-level API to JavaScript? - No!</p><p name="49c0" id="49c0" class="graf--p">Does it allow to run JavaScript from somewhere else? - Both yes and no, it's complicated!</p><p name="1df1" id="1df1" class="graf--p">Do we need all the DOM stuff that browser gives us? - No! It's overhead.</p><p name="3294" id="3294" class="graf--p">Do we need browser at all? - No!</p><p name="c8b8" id="c8b8" class="graf--p">We don't need that. <strong class="markup--strong markup--p-strong">JavaScript is executed without browser</strong>.</p><p name="4aa7" id="4aa7" class="graf--p">If browser is not a requirement for executing JavaScript, <strong class="markup--strong markup--p-strong">what does execute JavaScript then?</strong></p><h4 name="b210" id="b210" class="graf--h4">Virtual Machine (VM)</h4><p name="3cbf" id="3cbf" class="graf--p"><strong class="markup--strong markup--p-strong">Virtual Machine executes JavaScript!</strong></p><p name="4c99" id="4c99" class="graf--p">VM provides a high-level abstraction - that of a high-level programming language (compared to the low-level ISA abstraction of the system).</p><p name="2b04" id="2b04" class="graf--p">VM is designed to execute a single computer program by providing an abstracted and platform-independent program execution environment.</p><p name="d1fb" id="d1fb" class="graf--p">There are lots of virtual machines that can execute JavaScript including <strong class="markup--strong markup--p-strong">V8</strong> from Google, <strong class="markup--strong markup--p-strong">Chakra</strong> from Microsoft, <strong class="markup--strong markup--p-strong">SpiderMonkey</strong> from Mozilla, <strong class="markup--strong markup--p-strong">JavaScriptCore</strong> from Apple and more. Choose wisely, because it may be a decision you may regret for the rest of your life&nbsp;:)</p><p name="478f" id="478f" class="graf--p">I suggest that we choose Google's V8, why? Because it's faster than other VMs. I think you'll agree that execution speed is important for backend.</p><p name="636f" id="636f" class="graf--p">Let's take a look at V8 and how it can help to build NodeJS.</p><h4 name="4881" id="4881" class="graf--h4">V8 VM</h4><p name="4092" id="4092" class="graf--p"><strong class="markup--strong markup--p-strong">V8 can be integrated in any C++ project</strong>. Just take V8 sources and include them as a simple library. You are now able to use V8 API that allows you to compile and run JavaScript code.</p><p name="8c98" id="8c98" class="graf--p"><strong class="markup--strong markup--p-strong">V8 can expose C++ to JavaScript</strong>. It's very important as we want to make low-level API available within JavaScript.</p><p name="2c82" id="2c82" class="graf--p">Those 2 points are enough to imagine rough implementation of our idea - "How we can run JavaScript with access to low-level API".</p><p name="2a07" id="2a07" class="graf--p">Let's draw a line here about all this stuff above, because in the next chapter we will start with C++ code. You can take Virtual Machine, in our case V8 -&gt; integrate it in our C++ project -&gt; expose C++ to JavaScript with V8 help.</p><p name="0e7b" id="0e7b" class="graf--p">But <strong class="markup--strong markup--p-strong">how can we write C++ code and make it available within JavaScript</strong>?</p><h4 name="ca0f" id="ca0f" class="graf--h4">V8 Templates</h4><p name="625b" id="625b" class="graf--p"><strong class="markup--strong markup--p-strong">Via V8 Templates!</strong></p><p name="4a4f" id="4a4f" class="graf--p">A template is a blueprint for JavaScript functions and objects. You can use a template to wrap C++ functions and data structures within JavaScript objects.</p><p name="09d9" id="09d9" class="graf--p">For example, Google Chrome uses templates to wrap C++ DOM nodes as JavaScript objects and to install functions in the global scope.</p><p name="1d53" id="1d53" class="graf--p">You can create a set of templates and then use them. Accordingly you have as many templates as you want.</p><p name="2ba4" id="2ba4" class="graf--p">And V8 has two types of templates: <em class="markup--em markup--p-em">Function Templates</em> and <em class="markup--em markup--p-em">Object Templates</em>.</p><p name="302c" id="302c" class="graf--p"><strong class="markup--strong markup--p-strong">Function Template</strong> is the blueprint for a single function. You create a JavaScript instance of template by calling the template's <em class="markup--em markup--p-em">GetFunction</em> method from within the context in which you wish to instantiate the JavaScript function. You can also associate a C++ callback with a function template which is called when the JavaScript function instance is invoked.</p><p name="866c" id="866c" class="graf--p"><strong class="markup--strong markup--p-strong">Object Template</strong> is used to configure objects created with function template as their constructor. You can associate two types of C++ callbacks with object templates: <em class="markup--em markup--p-em">accessor callback</em> and <em class="markup--em markup--p-em">interceptor callback</em>. <em class="markup--em markup--p-em">Accessor callback</em> is invoked when a specific object property is accessed by a script. <em class="markup--em markup--p-em">Interceptor callback</em> is invoked when any object property is accessed by a script. In a nutshell, you can wrap C++ objects\structures within JavaScript objects.</p><p name="0c29" id="0c29" class="graf--p">Take a look at this simple example. All this does is expose C++ method <em class="markup--em markup--p-em">LogCallback </em>into global JavaScript context.</p><figure name="f5a4" id="f5a4" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/01c8246f7fdbee1da8b9ce619ec00cce?maxWidth=700" data-media-id="01c8246f7fdbee1da8b9ce619ec00cce" frameborder="0" style="height: 219px;"></iframe></div><figcaption class="imageCaption">V8 Function\Object Templates</figcaption></figure><p name="a9ff" id="a9ff" class="graf--p">At line #2 we are creating new <em class="markup--em markup--p-em">ObjectTemplate</em>. Then at line #3 we are creating new <em class="markup--em markup--p-em">FunctionTemplate</em> and associate C++ method <em class="markup--em markup--p-em">LogCallback</em> with it. Then we are setting this <em class="markup--em markup--p-em">FunctionTemplate</em> instance to <em class="markup--em markup--p-em">ObjectTemplate</em> instance. At line #9 we are just passing our <em class="markup--em markup--p-em">ObjectTemplate</em> instance to new JavaScript context, so that when you run JavaScript in this context, you'll be able to call method <em class="markup--em markup--p-em">log</em> from global scope. As a result, C++ method, associated with our <em class="markup--em markup--p-em">FunctionTemplate</em> instance, <em class="markup--em markup--p-em">LogCallback,</em> will be triggered.</p><p name="2e18" id="2e18" class="graf--p">As you see, it's similar to defining objects in JavaScript, only in C++.</p><p name="b7fb" id="b7fb" class="graf--p"><strong class="markup--strong markup--p-strong">By now, we learned how to expose C++ methods\structures to JavaScript</strong>. We will now learn how to run JavaScript code in those modified contexts. It's simple. Just compile and run principle.</p><h4 name="eaa9" id="eaa9" class="graf--h4">V8 Compile &amp;&amp; Run JavaScript</h4><p name="2e7c" id="2e7c" class="graf--p">If you want to <strong class="markup--strong markup--p-strong">run your JavaScript in created context</strong>, you can make just 2 simple API calls to V8 - <em class="markup--em markup--p-em">Compile</em> and <em class="markup--em markup--p-em">Run</em>.</p><p name="e226" id="e226" class="graf--p">Let's take a look at this example, where we are creating new <em class="markup--em markup--p-em">Context</em> and running JavaScript inside.</p><figure name="64e2" id="64e2" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/1dc80844bd140098b282f7ebd73d0eef?maxWidth=700" data-media-id="1dc80844bd140098b282f7ebd73d0eef" frameborder="0" style="height: 399px;"></iframe></div><figcaption class="imageCaption">V8 Compile &amp;&amp; Run JavaScript</figcaption></figure><p name="b782" id="b782" class="graf--p">At line #2 we are creating JavaScript context (<em class="markup--em markup--p-em">we can modify it with templates described above</em>). At line #5 we are making this context active for compiling and running JavaScript code. At line #8 we are creating new string from JavaScript source. It can be hardcoded, read from file or any other way. At line #11 we are compiling our JavaScript source. At line #14 we are running it and expecting results. That's all.</p><p name="80b9" id="80b9" class="graf--p">Finally, <strong class="markup--strong markup--p-strong">we can create simple NodeJS</strong>, combining all the techniques described above&nbsp;:)</p><h4 name="010c" id="010c" class="graf--h4">C++ -&gt; V8 Templates -&gt; Run JavaScript -&gt;&nbsp;?</h4><p name="c42c" id="c42c" class="graf--p">You can create VM instance (<em class="markup--em markup--p-em">also known as Isolate in V8</em>) -&gt; create as much <em class="markup--em markup--p-em">FunctionTemplate</em> instances, with assigned C++ callbacks, as you want -&gt; create <em class="markup--em markup--p-em">ObjectTemplate</em> instance and assign all created <em class="markup--em markup--p-em">FunctionTemplate</em> instances to it -&gt; create JavaScript context with global object as our <em class="markup--em markup--p-em">ObjectTemplate</em> instance -&gt; run JavaScript in this context and voila -&gt; NodeJS. Sweet!</p><p name="e87b" id="e87b" class="graf--p">But what is the question mark after "<em class="markup--em markup--p-em">Run JavaScript</em>" in chapter's title? <strong class="markup--strong markup--p-strong">There is a little problem with implementation above</strong>. We missed one very important thing.</p><p name="e7f3" id="e7f3" class="graf--p">Imagine, that you wrote a lot of C++ methods (<em class="markup--em markup--p-em">around 10k SLOC</em>) which can work with <em class="markup--em markup--p-em">fs</em>, <em class="markup--em markup--p-em">http</em>, <em class="markup--em markup--p-em">crypto</em>, etcâ€¦ We have assigned them <em class="markup--em markup--p-em">[C++ callbacks]</em> to <em class="markup--em markup--p-em">FunctionTemplate </em>instances and import them <em class="markup--em markup--p-em">[FunctionTemplate]</em> in <em class="markup--em markup--p-em">ObjectTemplate</em>. After getting JavaScript instance of this <em class="markup--em markup--p-em">ObjectTemplate</em> we have access to all of the <em class="markup--em markup--p-em">FunctionTemplate</em> instances from JavaScript via global scope. Looks like everything works great, butâ€¦</p><p name="0715" id="0715" class="graf--p">What if we don't need <em class="markup--em markup--p-em">fs</em> right now? What if we don't need <em class="markup--em markup--p-em">crypto</em> features at all? What about not getting modules from global scope, but requiring them on demand? What about not writing C++ code in one big file with all the C++ callbacks in there? So question mark meansâ€¦</p><p name="4190" id="4190" class="graf--p"><strong class="markup--strong markup--p-strong">Modularity!</strong></p><p name="acc4" id="acc4" class="graf--p">All those C++ methods should be split in modules and located in different files (<em class="markup--em markup--p-em">it simplifies the development</em>) so that each C++ module corresponds to each <em class="markup--em markup--p-em">fs,</em> <em class="markup--em markup--p-em">http</em> or any other feature. The same logic is in JavaScript context. All the JavaScript modules must not be accessible from global scope, but accessible on demand.</p><p name="2c37" id="2c37" class="graf--p">Based on these best practices we need to implement our own module loader. That module loader should handle loading C++ modules and JavaScript modules so that we can grab C++ module on demand from C++ code and the same for JavaScript context - grab JavaScript module on demand from JavaScript code.</p><p name="51f4" id="51f4" class="graf--p"><strong class="markup--strong markup--p-strong">Let's start with C++ Module Loader first</strong>.</p><h4 name="8445" id="8445" class="graf--h4">C++ Module Loader</h4><p name="1579" id="1579" class="graf--p"><em class="markup--em markup--p-em">There will be a lot of C++ code here, so try not to lose your mind&nbsp;:)</em></p><p name="2541" id="2541" class="graf--p">Let's start with basics of all module loaders. Each module loader must have a variable that contains all modules (<em class="markup--em markup--p-em">or information on how to get them</em>). Let's declare C++ structure to store information about C++ modules and name it <em class="markup--em markup--p-em">node_module</em>.</p><figure name="cc18" id="cc18" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/af4c1aa61b0cb3600970b270d61d6b64?maxWidth=700" data-media-id="af4c1aa61b0cb3600970b270d61d6b64" frameborder="0" style="height: 259px;"></iframe></div><figcaption class="imageCaption">node_module structure in NodeJS</figcaption></figure><p name="8176" id="8176" class="graf--p">We can store information about existing modules in this structure. As a result we have a simple dictionary of all available C++ modules.</p><p name="0e7a" id="0e7a" class="graf--p">I'm not going to explain all the fields from the structure above, but I want you to pay attention to one of them. In <em class="markup--em markup--p-em">nm_filename</em> we can store filename of our module, so we know where to load it from. In <em class="markup--em markup--p-em">nm_register_func</em> and <em class="markup--em markup--p-em">nm_context_register_func</em> we can store functions that we need to call when module is required. These functions will be responsible for instantiating <em class="markup--em markup--p-em">Template</em> instance. And <em class="markup--em markup--p-em">nm_modname</em> can store module name (<em class="markup--em markup--p-em">not filename</em>).</p><p name="c6ce" id="c6ce" class="graf--p">Next, we need to implement helper methods that work with this structure. We can write a simple method that can save information to our <em class="markup--em markup--p-em">node_module</em> structure and then use this method in our module definitions. Let's call it <em class="markup--em markup--p-em">node_module_register</em>.</p><figure name="5336" id="5336" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/677d82a433161b58d22adfa82384556e?maxWidth=700" data-media-id="677d82a433161b58d22adfa82384556e" frameborder="0" style="height: 359px;"></iframe></div><figcaption class="imageCaption">NodeJS Native Module register method</figcaption></figure><p name="e773" id="e773" class="graf--p">As you can see, all we are doing here is just saving new information about module into our structure <em class="markup--em markup--p-em">node_module</em>.</p><p name="9f5f" id="9f5f" class="graf--p">Now we can simplify registering process using a macro. Let's declare a macro that you can use in your C++ module. This macro is just a wrapper for <em class="markup--em markup--p-em">node_module_register</em> method.</p><figure name="74ed" id="74ed" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/ffa324bc8b15c97f92f997a85891b52e?maxWidth=700" data-media-id="ffa324bc8b15c97f92f997a85891b52e" frameborder="0" style="height: 459px;"></iframe></div><figcaption class="imageCaption">NodeJS Native Module register macros</figcaption></figure><p name="2cb5" id="2cb5" class="graf--p">First macro is a wrapper for <em class="markup--em markup--p-em">node_module_register</em> method. The other one is just a wrapper for previous macro with some predefined arguments. As a result we have a macro that accepts two arguments: <em class="markup--em markup--p-em">modname</em> and <em class="markup--em markup--p-em">regfunc</em>. When it's called, we are saving new module information in our <em class="markup--em markup--p-em">node_module</em> structure. What do <em class="markup--em markup--p-em">modname</em> and <em class="markup--em markup--p-em">regfunc</em> mean? Wellâ€¦ <em class="markup--em markup--p-em">modname</em> is just our module name, like <em class="markup--em markup--p-em">fs</em>, for instance. <em class="markup--em markup--p-em">regfunc</em> is a module method that we talked about earlier. This method should be responsible for <em class="markup--em markup--p-em">V8 Template</em> initialization and assigning it to <em class="markup--em markup--p-em">ObjectTemplate</em>.</p><p name="63a8" id="63a8" class="graf--p">As you can see, each C++ module can be declared within a macro that accepts module name (<em class="markup--em markup--p-em">modname</em>) and initialization function (<em class="markup--em markup--p-em">regfunc</em>) that will be called when module is required. All we need to do is just create C++ methods that can read that information from <em class="markup--em markup--p-em">node_module</em> structure and call <em class="markup--em markup--p-em">regfunc</em> method.</p><p name="2826" id="2826" class="graf--p">Let's write a simple method that will search for module in <em class="markup--em markup--p-em">node_module</em> structure by its name. We'll call it <em class="markup--em markup--p-em">get_builtin_module</em>.</p><figure name="7056" id="7056" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/dcad81673f4c6e3207a39b631bfad2b5?maxWidth=700" data-media-id="dcad81673f4c6e3207a39b631bfad2b5" frameborder="0" style="height: 259px;"></iframe></div><figcaption class="imageCaption">Lookup for registered native module</figcaption></figure><p name="c7db" id="c7db" class="graf--p">This will return previously declared module if name matches the <em class="markup--em markup--p-em">nm_modname</em> from <em class="markup--em markup--p-em">node_module</em> structure.</p><p name="00ab" id="00ab" class="graf--p">Based on information from <em class="markup--em markup--p-em">node_module</em> structure, we can write a simple method<em class="markup--em markup--p-em"> </em>that will load the C++ module and assign <em class="markup--em markup--p-em">V8 Template</em> instance to our <em class="markup--em markup--p-em">ObjectTemplate</em>. As a result, this <em class="markup--em markup--p-em">ObjectTemplate</em> will be sent as a JavaScript instance to JavaScript context.</p><figure name="ec5c" id="ec5c" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/4f47f6adcd0dfffc1affcb908a1c6a61?maxWidth=700" data-media-id="4f47f6adcd0dfffc1affcb908a1c6a61" frameborder="0" style="height: 1119px;"></iframe></div><figcaption class="imageCaption">Load bindings and send it to JavaScript context</figcaption></figure><p name="0552" id="0552" class="graf--p">A few notes regarding the code above. <em class="markup--em markup--p-em">Binding</em> takes module name as an argument. This argument is a module name that was given by you via macro. We are looking for information about this module via <em class="markup--em markup--p-em">get_builtin_module </em>method. If we find it, we call initialization function from this module, sending some useful arguments like <em class="markup--em markup--p-em">exports</em>. <em class="markup--em markup--p-em">exports</em> is an <em class="markup--em markup--p-em">ObjectTemplate</em> instance, so we can use <em class="markup--em markup--p-em">V8 Template</em> API on it. After all these operations, we get the <em class="markup--em markup--p-em">exports</em> object that we get as a result from <em class="markup--em markup--p-em">Binding</em> method. As you remember, <em class="markup--em markup--p-em">ObjectTemplate</em> instance can return JavaScript instance and that's what <em class="markup--em markup--p-em">Binding</em> does.</p><p name="8d2c" id="8d2c" class="graf--p">The last thing we should do is make this method available from JavaScript context. This is done at the last line by wrapping <em class="markup--em markup--p-em">Binding</em> method in <em class="markup--em markup--p-em">FunctionTemplate</em> and assigning it to global variable <em class="markup--em markup--p-em">process</em>.</p><p name="1bda" id="1bda" class="graf--p">At this stage, you are able to call <em class="markup--em markup--p-em">process.binding(â€˜fs')</em> for instance, and get native bindings for it.</p><p name="190d" id="190d" class="graf--p">Here is an example of a built-in module with omitted logic for simplicity<em class="markup--em markup--p-em">.</em></p><figure name="742c" id="742c" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/80624ea7c88334524b0d194f852fc834?maxWidth=700" data-media-id="80624ea7c88334524b0d194f852fc834" frameborder="0" style="height: 556px;"></iframe></div><figcaption class="imageCaption">NodeJS V8 Native Module example</figcaption></figure><p name="89ca" id="89ca" class="graf--p">The code above will create a binding with a name "<em class="markup--em markup--p-em">v8"</em> that exports JavaScript object, so that calling <em class="markup--em markup--p-em">process.binding(â€˜v8')</em> from JavaScript context gets this object.</p><p name="91d9" id="91d9" class="graf--p">Hopefully you are still following along.</p><p name="faf7" id="faf7" class="graf--p">Now <strong class="markup--strong markup--p-strong">we should make JavaScript Module Loader</strong> that will help us do all the neat stuff like <em class="markup--em markup--p-em">require(â€˜fs')</em>.</p><h4 name="7868" id="7868" class="graf--h4">JavaScript Module Loader</h4><p name="53a4" id="53a4" class="graf--p">Great, thanks to our latest improvements, we can call <em class="markup--em markup--p-em">process.binding()</em> and get access to C++ bindings from JavaScript context. But this still does not resolve the issue with JavaScript modules. How can we write JavaScript modules and require them on demand?</p><p name="318b" id="318b" class="graf--p">First of all, we need to understand that there are two different types of modules. One of them is JavaScript modules that we write alongside with C++ callbacks. In a nutshell, these are NodeJS built-in modules, like <em class="markup--em markup--p-em">fs</em>, <em class="markup--em markup--p-em">http</em>, etcâ€¦ Let's call these modules <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">NativeModule</em></strong>. The other type are modules in your working directory. Let's call them just <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Module</em></strong>.</p><p name="4e8b" id="4e8b" class="graf--p">We need to be able to require both types. That means we need to know how to grab <em class="markup--em markup--p-em">NativeModule</em> from NodeJS and <em class="markup--em markup--p-em">Module</em> from your working directory.</p><p name="99c3" id="99c3" class="graf--p"><strong class="markup--strong markup--p-strong">Let's start with <em class="markup--em markup--p-em">NativeModule</em> first.</strong></p><p name="7c5b" id="7c5b" class="graf--p">All JavaScript native modules are located within our C++ project in another folder. That means that all of JavaScript sources are accessible at compile-time. This allows us to wrap JavaScript sources into a C++ header file, that we can use in the future.</p><p name="d427" id="d427" class="graf--p">There's a Python tool called <em class="markup--em markup--p-em">js2c.py</em> for this (<em class="markup--em markup--p-em">located under tools/js2c.py</em>). It generates <em class="markup--em markup--p-em">node_natives.h</em> header file with wrapped JavaScript code. <em class="markup--em markup--p-em">node_natives.h</em> can be included in any C++ code to get JavaScript sources within C++.</p><p name="6580" id="6580" class="graf--p">Now that we can use JavaScript sources in C++ context - let's try it out. We can implement a simple method <em class="markup--em markup--p-em">DefineJavaScript</em> that gets JavaScript sources from <em class="markup--em markup--p-em">node_natives.h</em> and assigns them to <em class="markup--em markup--p-em">ObjectTemplate</em> instance.</p><figure name="258f" id="258f" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/a32c07aa7ff4b2df05c1c6318bd67573?maxWidth=700" data-media-id="a32c07aa7ff4b2df05c1c6318bd67573" frameborder="0" style="height: 276px;"></iframe></div><figcaption class="imageCaption">NodeJS DefineJavaScript for Native Module</figcaption></figure><p name="0fff" id="0fff" class="graf--p">In the code above, we are iterating through each native JavaScript module and setting them into <em class="markup--em markup--p-em">ObjectTemplate</em> instance with module name as a key and module itself as a value. The last thing we need to do is call <em class="markup--em markup--p-em">DefineJavaScript</em> with <em class="markup--em markup--p-em">ObjectTemplate</em> instance as <em class="markup--em markup--p-em">target</em>.</p><p name="3726" id="3726" class="graf--p"><em class="markup--em markup--p-em">Binding</em> method comes in handy here. If you look at our <em class="markup--em markup--p-em">Binding</em> C++ implementation (<em class="markup--em markup--p-em">C++ Module Loader</em> section), you'll see that we hardcoded two bindings: <em class="markup--em markup--p-em">constants</em> and <em class="markup--em markup--p-em">natives</em>. Thus, if binding's name is <em class="markup--em markup--p-em">natives</em> then <em class="markup--em markup--p-em">DefineJavaScript</em> method is called with <em class="markup--em markup--p-em">environment</em> and <em class="markup--em markup--p-em">exports</em> objects. As a result, JavaScript native modules will be returned when calling <em class="markup--em markup--p-em">process.binding(â€˜natives')</em>.</p><p name="2549" id="2549" class="graf--p">So, that's cool. But another improvement can be made here by defining GYP task in <em class="markup--em markup--p-em">node.gyp</em> file and calling <em class="markup--em markup--p-em">js2c.py</em> tool from it. This will make it so that when NodeJS is compiling, JavaScript sources will also be wrapped into <em class="markup--em markup--p-em">node_natives.h</em> header file.</p><p name="82cb" id="82cb" class="graf--p">By now, we have JavaScript sources of our native modules available as <em class="markup--em markup--p-em">process.binding(â€˜natives')</em>. Let's write simple JavaScript wrapper for <em class="markup--em markup--p-em">NativeModule</em> now.</p><figure name="52cf" id="52cf" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/75e52dbe47f79e5511db6e52d7625bed?maxWidth=700" data-media-id="75e52dbe47f79e5511db6e52d7625bed" frameborder="0" style="height: 1399px;"></iframe></div><figcaption class="imageCaption">NodeJS JavaScript Native Module</figcaption></figure><p name="1808" id="1808" class="graf--p">Now, to load a module, you call <em class="markup--em markup--p-em">NativeModule.require()</em> method with module name that you want to load. This will first check if module already exists in cache, if so - gets it from cache, otherwise the module is compiled, cached and returned as <em class="markup--em markup--p-em">exports</em> object.</p><p name="b03b" id="b03b" class="graf--p">Let's take a closer look at <em class="markup--em markup--p-em">cache</em> and <em class="markup--em markup--p-em">compile</em> methods now.</p><p name="ecdf" id="ecdf" class="graf--p">All <em class="markup--em markup--p-em">cache</em> does is just setting <em class="markup--em markup--p-em">NativeModule</em> instance to static object <em class="markup--em markup--p-em">_cache</em> located in <em class="markup--em markup--p-em">NativeModule</em>.</p><p name="027d" id="027d" class="graf--p">More interesting is the <em class="markup--em markup--p-em">compile</em> method. First, we are getting sources of required module from <em class="markup--em markup--p-em">_source</em> (<em class="markup--em markup--p-em">we set this static property with process.binding(â€˜natives')</em>). We are then wrapping them in a function with <em class="markup--em markup--p-em">wrap</em> method. As you can see, resulting function accepts <em class="markup--em markup--p-em">exports</em>, <em class="markup--em markup--p-em">require</em>, <em class="markup--em markup--p-em">module</em>, <em class="markup--em markup--p-em">__filename</em> and <em class="markup--em markup--p-em">__dirname</em> arguments. Afterwards, we call this function with required arguments. As a result, our JavaScript module is wrapped in scope that has <em class="markup--em markup--p-em">exports</em> as pointer to <em class="markup--em markup--p-em">NativeModule.exports</em>, <em class="markup--em markup--p-em">require</em> as pointer to <em class="markup--em markup--p-em">NativeModule.require</em>, <em class="markup--em markup--p-em">module</em> as pointer to <em class="markup--em markup--p-em">NativeModule</em> instance itself and <em class="markup--em markup--p-em">__filename</em> as a string with current file name. Now you know where all the stuff like <em class="markup--em markup--p-em">module</em> and <em class="markup--em markup--p-em">require</em> is coming from in your JavaScript code. They are just pointers to <em class="markup--em markup--p-em">NativeModule</em> instance&nbsp;:)</p><p name="d6c2" id="d6c2" class="graf--p"><strong class="markup--strong markup--p-strong">Another thing is <em class="markup--em markup--p-em">Module</em> loader implementation.</strong></p><p name="567e" id="567e" class="graf--p"><em class="markup--em markup--p-em">Module</em> loader implementation is basically the same as with <em class="markup--em markup--p-em">NativeModule</em>, the difference is that sources are not taken from <em class="markup--em markup--p-em">node_natives.h</em> header file, but from files that we can read with <em class="markup--em markup--p-em">fs</em> native module. So we are doing all the same stuff as <em class="markup--em markup--p-em">wrap</em>, <em class="markup--em markup--p-em">cache</em> and <em class="markup--em markup--p-em">compile</em>, only with sources read from file.</p><p name="4481" id="4481" class="graf--p">Great, now we know how to require native modules or modules from your working directory.</p><p name="4990" id="4990" class="graf--p">Finally, we can write a simple JavaScript module that will run each time NodeJS is run and prepare the NodeJS environment using all of the stuff above.</p><h4 name="f8c9" id="f8c9" class="graf--h4">NodeJS Runtime Library?</h4><p name="b6ac" id="b6ac" class="graf--p">What is a runtime library? It's a library that prepares the environment, setting global variables <em class="markup--em markup--p-em">process</em>, <em class="markup--em markup--p-em">console</em>, <em class="markup--em markup--p-em">Buffer</em>, etc, and runs the main script that you send to NodeJS CLI as an argument. It can be achieved with a simple JavaScript file that will be executing at NodeJS runtime before all other JavaScript code.</p><p name="0115" id="0115" class="graf--p">We can start with proxying all our native modules to global scope and setting up other global variables. It's just a lot of JavaScript code that does something like <em class="markup--em markup--p-em">global.Buffer = NativeModule.require(â€˜buffer')</em> or <em class="markup--em markup--p-em">global.process = process</em>.</p><p name="514c" id="514c" class="graf--p">Second step is running the main script which you send in NodeJS CLI as an argument. Logic is simple here as well. It just parses <em class="markup--em markup--p-em">process.argv[1]</em> and creates <em class="markup--em markup--p-em">Module</em> instance with its value as a constructor value. So, <em class="markup--em markup--p-em">Module</em> is able to read sources from file -&gt; cache and compile it as <em class="markup--em markup--p-em">NativeModule</em> does with precompiled JavaScript sources.</p><p name="0274" id="0274" class="graf--p">There's not much I can add here, it's really very simple, if you want more details though, you can take a look at <em class="markup--em markup--p-em">src/node.js</em> file in node repository. This file is executing at NodeJS runtime and uses all the techniques, described in this article.</p><p name="2baa" id="2baa" class="graf--p"><strong class="markup--strong markup--p-strong">This is how NodeJS is able to run your JavaScript code with access to low-level API</strong>. Cool, isn't it?</p><p name="73be" id="73be" class="graf--p">But all of the above can't do any asynchronous stuff yet. All the operations like <em class="markup--em markup--p-em">fs.readFile()</em> are fully synchronous at this point.</p><p name="13e7" id="13e7" class="graf--p">What do we need for asynchronous operations? An <strong class="markup--strong markup--p-strong">event loopâ€¦</strong></p><h4 name="97d0" id="97d0" class="graf--h4">Event Loop</h4><p name="ce77" id="ce77" class="graf--p">Event loop is message dispatcher that waits for and dispatches events or messages in a program. It works by making a request to some internal or external event provider (which generally blocks the request until an event has arrived), and then it calls the relevant event handler (dispatches the event). The event loop may be used in conjunction with a reactor if the event provider follows the file interface which can be selected or polled. The event loop almost always operates asynchronously with the message originator.</p><p name="5bf7" id="5bf7" class="graf--p">V8 can accept event loop as an argument when you are creating V8 Environment. But before setting up an event loop to V8 we need to implement it firstâ€¦</p><p name="46fd" id="46fd" class="graf--p">Finally, we already have that implementation which is called <em class="markup--em markup--p-em">libuv</em>. It's responsible for all the asynchronous operations like read file and others. Without <em class="markup--em markup--p-em">libuv</em> NodeJS is just a synchronous JavaScript\C++ execution.</p><p name="2e84" id="2e84" class="graf--p">So, basically, we can include <em class="markup--em markup--p-em">libuv</em> sources into NodeJS and create V8 Environment with <em class="markup--em markup--p-em">libuv</em> default event loop in there. Here is an implementation of it.</p><figure name="7bec" id="7bec" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/b82528c1b3eb3a2851149ab96c1f8417?maxWidth=700" data-media-id="b82528c1b3eb3a2851149ab96c1f8417" frameborder="0" style="height: 796px;"></iframe></div><figcaption class="imageCaption">NodeJS Create Environment</figcaption></figure><p name="640e" id="640e" class="graf--p"><em class="markup--em markup--p-em">CreateEnvironment</em> method accepts <em class="markup--em markup--p-em">libuv</em> event loop as a <em class="markup--em markup--p-em">loop</em> argument. We are able to call <em class="markup--em markup--p-em">Environment::New</em> from V8 namespace and send there <em class="markup--em markup--p-em">libuv</em> event loop, and then configure it in V8 Environment. That's how NodeJS became asynchronous.</p><p name="bbc0" id="bbc0" class="graf--p">I'd like to talk about <em class="markup--em markup--p-em">libuv</em> more and tell you how it works, but that's another story for another time&nbsp;:)</p><h4 name="c4c1" id="c4c1" class="graf--h4">Thanks!</h4><p name="7cf8" id="7cf8" class="graf--p">Thanks to everyone who has read this post to the end. I hope you enjoyed it and learned something new. If you found any issues or something, feel free to comment and I'll reply as soon as possible.</p><p name="de31" id="de31" class="graf--p graf--last"><em class="markup--em markup--p-em">Eugene Obrezkov aka ghaiklor, Technical Leader at Onix-Systems, Kirovohrad, Ukraine.</em></p></div>
			</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>The Incomplete Collection of Node.js Performance Tips</h1>
		<div class="section-inner layoutSingleColumn"><h3 name="2c54" id="2c54" data-align="center" class="graf--h3 graf--first">The Incomplete Collection of<br>Node.js Performance Tips</h3><p name="3162" id="3162" class="graf--p graf--empty"><br></p><h4 name="d7c5" id="d7c5" data-align="center" class="graf--h4"><strong class="markup--strong markup--h4-strong">Bookmark and â™¥ for later reading&nbsp;:)</strong></h4><p name="83c6" id="83c6" class="graf--p graf--empty"><br></p><p name="c8b4" id="c8b4" class="graf--p">This is a (non-comprehensive) collection of practical advice on how to get more performance out of your Node.js application. While the points I am making below are just some of the more obvious<strong class="markup--strong markup--p-strong"> </strong>performance boosting tips, I will try to keep a more detailed list maintained on GitHub (if people like it). But let's jump right into it:</p><h3 name="c2b0" id="c2b0" class="graf--h3 is-withNotes">Take Advantage of Multi-Core CPUs with Node Clusters</h3><p name="cd76" id="cd76" class="graf--p">Node.js is single threaded (duh). So an instance of Node runs in a single thread, not taking any advantage of modern multi-core CPUs. Luckily, Node's cluster module allows you to easily launch a whole cluster of Node child processes to better handle the load. (And child processes share the same server ports.)</p><p name="7022" id="7022" class="graf--p">Node's documentation gives an excellent and easy to read starting point on how to get started with clusters: <a href="https://nodejs.org/api/cluster.html" data-href="https://nodejs.org/api/cluster.html" class="markup--anchor markup--p-anchor" rel="nofollow">https://nodejs.org/api/cluster.html</a></p><p name="050c" id="050c" class="graf--p"><em class="markup--em markup--p-em">Beyond better performance, clusters will have the added benefit of improving the resilience of your application. The â€˜master' process knows when a child processes crashes, and routes traffic to other child processes until the crashed process gets restarted.</em></p><h3 name="9ddb" id="9ddb" class="graf--h3">Express Optimizations</h3><h4 name="f499" id="f499" class="graf--h4">Use compression</h4><p name="6dd3" id="6dd3" class="graf--p">An often overlooked or forgotten middleware you can use with express is compression. It uses <strong class="markup--strong markup--p-strong">gzip</strong> to compress your http payload sent to the client.</p><pre name="a1ce" id="a1ce" class="graf--pre">var app = require('express')();<br>var compression = require('compression');<br>app.use(compression());</pre><p name="5772" id="5772" class="graf--p is-withNotes"><em class="markup--em markup--p-em">Make sure that you load compression </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">before</em></strong><em class="markup--em markup--p-em"> any other middleware.</em></p><h4 name="94f4" id="94f4" class="graf--h4">Use cache</h4><p name="7211" id="7211" class="graf--p graf--empty"><br></p><p name="b0f9" id="b0f9" class="graf--p">Unlike most server-based applications, Node.js apps will often be designed to run permanently. If that is the case for you, consider setting your most used variables &amp; objects just once at initialization and keep reusing them for any incoming requests down the line. Think of something like "the top 5 articles of the week" your users will see on your frontpage.<br>Do you really need to update that content <em class="markup--em markup--p-em">every</em> time a user visits your page? If not, you can cache it:</p><pre name="7f91" id="7f91" class="graf--pre">app.set('view cache', true);</pre><h4 name="3ed3" id="3ed3" class="graf--h4">Remove unused middleware</h4><p name="2c6d" id="2c6d" class="graf--p">Do you make use of http PUT/DELETE requests? If not, disable <em class="markup--em markup--p-em">methodOverride</em>. If you don't even use POST requests (maybe your app does everything via sockets) you can even get rid of the <em class="markup--em markup--p-em">bodyParser </em>too.</p><p name="4f95" id="4f95" class="graf--p">Take a close look which middleware you actually need, and which you can work without of.</p><p name="545e" id="545e" class="graf--p">And some middleware might only be needed in a specific environment mode. For those cases you can do something like this:</p><pre name="364c" id="364c" class="graf--pre">if (app.get('env') !== 'production') {<br>  app.use(morgan);<br>}</pre><h4 name="575d" id="575d" class="graf--h4">Let's talk sessions</h4><p name="877c" id="877c" class="graf--p">Express sessions are saved in memory. Your memory footprint grows with every additional user connected. This can add quite a bit of overhead to your application.</p><p name="d490" id="d490" class="graf--p">Try to limit your use of session variables. Better to use hashed tokens and fetch user data from an alternative session store such as MongoDB or Redis.</p><p name="b84b" id="b84b" class="graf--p"><em class="markup--em markup--p-em">But if you are brave enough you might even want to consider to not store any state server-side at all, but dive into client side sessions. For that, take a look at this: </em><a href="https://github.com/mozilla/node-client-sessions" data-href="https://github.com/mozilla/node-client-sessions" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">https://github.com/mozilla/node-client-sessions</em></a></p><h3 name="1cb0" id="1cb0" class="graf--h3">Go Asynchronous</h3><h4 name="d97a" id="d97a" class="graf--h4">Async code execution</h4><p name="4327" id="4327" class="graf--p">Probably the single biggest advantage of Node.js (besides server side javascript execution itself of course) is it's asynchronous nature.</p><p name="245d" id="245d" class="graf--p">Being single-threaded, your Node.js application can easily get blocked by synchronous code execution taking too long to return. If incoming requests can't get processed anymore, your application is rendered de-facto useless.</p><p name="41b5" id="41b5" class="graf--p is-withNotes">Think about some especially time, memory, or CPU intensive tasks. For instance accessing, reading or writing large files. If there is no absolutely, critical, unavoidable reason, you should <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">always</em></strong> use async over sync.</p><p name="0e07" id="0e07" class="graf--p">But keep asynchronous support also in mind when choosing external libraries and components. Make sure they are not potentially blocking your application.</p><h4 name="d389" id="d389" class="graf--h4">Parallel code execution</h4><p name="f60f" id="f60f" class="graf--p">Revisit your codebase and find chained async callbacks and think if you can run those functions parallel. For instance: You need to read 2 files before executing a callback. This can be done way better than chaining callbacks.</p><p name="73cd" id="73cd" class="graf--p"><strong class="markup--strong markup--p-strong">The <em class="markup--em markup--p-em">async</em> module</strong> allows you to run functions parallel without the need of chaining them in callbacks. Here the code example for async.parallel:</p><pre name="b4c6" id="b4c6" class="graf--pre is-withNotes">async.parallel([<br>    function(){ ... },<br>    function(){ ... }<br>], callback);</pre><p name="3c07" id="3c07" class="graf--p is-withNotes">Awesome, right? You get one callback executed after all parallel running functions finished. Take a look at the documentation for more details: <a href="https://github.com/caolan/async" data-href="https://github.com/caolan/async" class="markup--anchor markup--p-anchor" rel="nofollow">https://github.com/caolan/async</a></p><p name="684e" id="684e" class="graf--p"><strong class="markup--strong markup--p-strong">Bluebird and Q</strong> are known first and foremost for giving us promises. But they also let us execute code parallel returning a promise (um.. callback-ish) after all promises (um&nbsp;.. promisified functions) returned.<br>Let's look at an example for bluebird:</p><pre name="6343" id="6343" class="graf--pre">Bluebird.all([promiseFunction1,promiseFunction2]) <br>        .then(function(data) {<br>           // will execute after all promisified functions returned<br>        });</pre><p name="3740" id="3740" class="graf--p is-withNotes"><strong class="markup--strong markup--p-strong">ES 6</strong> has a native support for promises and likewise provide a&nbsp;<em class="markup--em markup--p-em">.all()</em> method. Depending on your Node version, you might have already support for it.</p><pre name="5a18" id="5a18" class="graf--pre">Promise.all([promiseFunction1, promiseFunction1])<br>       .then(function(data) {<br>           // will execute after all promisified functions returned<br>        });</pre><p name="1c3c" id="1c3c" class="graf--p"><em class="markup--em markup--p-em">If for whatever reason you do not want to use any of the options above, you could also use following approach. But this does not scale well for obvious reasons. Really, you shouldn't do that.</em></p><figure name="0dc8" id="0dc8" class="graf--figure graf--iframe"><div class="iframeContainer"><iframe width="700" height="250" src="/media/fb1b5910990f7b86cd5720a6362296d7?maxWidth=700" data-media-id="fb1b5910990f7b86cd5720a6362296d7" frameborder="0" style="height: 679px;"></iframe></div></figure><h3 name="dbd8" id="dbd8" class="graf--h3">Use V8 native functions instead of adding external libraries</h3><p name="a94b" id="a94b" class="graf--p">If you come from a traditional web development side to Node.js, you are probably used to working with libraries such as <a href="http://underscorejs.org/" data-href="http://underscorejs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">underscore</a> or <a href="https://lodash.com/" data-href="https://lodash.com/" class="markup--anchor markup--p-anchor" rel="nofollow">lodash</a> to take advantage of higher order functions (think of <em class="markup--em markup--p-em">_.each</em>,<em class="markup--em markup--p-em"> _.map</em>, etc..)</p><p name="335f" id="335f" class="graf--p">Those libraries are written with the <strong class="markup--strong markup--p-strong">front-end</strong> in mind, and that means they include a sizable chunk of code that makes sure everything works as it should in a variety of browser environment: From Chrome to Safari, from Firefox to IE, plus&nbsp;.. polyfills (Yeah, we are looking at you IE).</p><p name="9494" id="9494" class="graf--p">Which is <strong class="markup--strong markup--p-strong">great</strong>, but also means those libraries contain a lot of additional code that you do not need - not server-side anyways. So before adding yet another module and adding to your resource footprint, try taking advantage of V8 native functions instead, such as <em class="markup--em markup--p-em">forEach</em>, <em class="markup--em markup--p-em">map</em>, etc.</p><h3 name="7048" id="7048" class="graf--h3">Database Optimizations: Limit query scope and index your collections</h3><p name="fe8e" id="fe8e" class="graf--p graf--empty"><br></p><p name="6c8c" id="6c8c" class="graf--p">If you are working with MongoDB as your database of choice, I have two easy recommendations that could improve your performance quite a bit. (And you should be able to fairly easy retrofit your already existing apps)</p><ol class="postList"><li name="c15d" id="c15d" class="graf--li">limit queries in â€˜scope' whenever possible, and</li><li name="a0b9" id="a0b9" class="graf--li">add indices to collections which are queried often</li></ol><p name="a8cc" id="a8cc" class="graf--p">Imagine you want to display the last 10 posts of a user whenever the user visits your site. First, it is obvious that will want to index your collections accordingly, but you should also make sure to limit your MongoDB queries in â€˜scope'. This can mean 2 things: First, to limit the fields you want returned, and secondly (maybe more importantly) to limit the number of documents returned. Take a look at these example snippets from the MongoDB documentation:</p><pre name="9bec" id="9bec" class="graf--pre">db.user.find({ type: 'customer' }, { item: 10, qty: 1 } );</pre><pre name="33e4" id="33e4" class="graf--pre">db.user.find({ type: 'customer' }).limit(10);</pre><p name="182c" id="182c" class="graf--p">Makes sense? Also dig into the MongoDB's documentation on creating and working with indices in Node: <a href="http://docs.mongodb.org/getting-started/node/indexes/" data-href="http://docs.mongodb.org/getting-started/node/indexes/" class="markup--anchor markup--p-anchor" rel="nofollow">http://docs.mongodb.org/getting-started/node/indexes/</a></p><p name="5cd1" id="5cd1" class="graf--p"><em class="markup--em markup--p-em">Btw: I highly recommend Mongo University's course: "</em><a href="https://university.mongodb.com/courses/M101JS/about" data-href="https://university.mongodb.com/courses/M101JS/about" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">MongoDB for Node.js Developers</em></a><em class="markup--em markup--p-em">" Believe me, it's </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">super</em></strong><em class="markup--em markup--p-em"> </em><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">awesome</em></strong><em class="markup--em markup--p-em">!</em></p><h3 name="0c82" id="0c82" class="graf--h3">Client side rendering!</h3><p name="80f1" id="80f1" class="graf--p">Instead of using server side rendering such Express' Jade templating, move to client side rendering using <a href="http://facebook.github.io/react/" data-href="http://facebook.github.io/react/" class="markup--anchor markup--p-anchor" rel="nofollow">React</a>, <a href="https://angularjs.org/" data-href="https://angularjs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">AngularJS</a> or <a href="http://backbonejs.org/" data-href="http://backbonejs.org/" class="markup--anchor markup--p-anchor" rel="nofollow">Backbone.js</a> and have the server provide only the dynamic content really needed. â€˜Outsourcing' rendering to the client can <strong class="markup--strong markup--p-strong">seriously</strong> improve your application's performance.</p><h3 name="bc6f" id="bc6f" class="graf--h3">Don't use Node.js for static assets</h3><p name="70b1" id="70b1" class="graf--p">Wherever possible you should avoid using Node.js for serving your static assets. Those include anything from Images, Videos or CSS files.</p><p name="5073" id="5073" class="graf--p">To improve both, performance of your application and client latency, I recommend a combination of a separate standard web server, such as Nginx, plus taking advantage of Content Delivery Networks (CDNs) to cache and provide those static assets as close to the user as possible.</p><p name="ed46" id="ed46" class="graf--p"><em class="markup--em markup--p-em">Personally I have had excellent experiences with Rackspace for both.<br>Check them out: </em><a href="http://www.rackspace.com" data-href="http://www.rackspace.com" class="markup--anchor markup--p-anchor" rel="nofollow"><em class="markup--em markup--p-em">www.rackspace.com</em></a></p><h3 name="a84e" id="a84e" class="graf--h3">Make it ugly!</h3><p name="0d9b" id="0d9b" class="graf--p is-withNotes">There is a lot to be said for the beauty of clean code following <a href="https://github.com/airbnb/javascript" data-href="https://github.com/airbnb/javascript" class="markup--anchor markup--p-anchor" rel="nofollow">fancy style guides</a>. But there is more to be said for reducing load and latency - at least in production.</p><p name="4f3f" id="4f3f" class="graf--p is-withNotes">Make it a habit to use <a href="http://gulpjs.com" data-href="http://gulpjs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Gulp</a> or <a href="http://gruntjs.com" data-href="http://gruntjs.com" class="markup--anchor markup--p-anchor" rel="nofollow">Grunt</a> to run tasks to <a href="https://github.com/mishoo/UglifyJS2/" data-href="https://github.com/mishoo/UglifyJS2/" class="markup--anchor markup--p-anchor" rel="nofollow">uglify your javascript</a> and <a href="https://github.com/purifycss" data-href="https://github.com/purifycss" class="markup--anchor markup--p-anchor" rel="nofollow">purify your CSS</a> for your client side code. I personally am becoming a bit of a fan of webpack to bundle everything together as well: <a href="http://webpack.github.io/" data-href="http://webpack.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow">http://webpack.github.io/</a></p><h3 name="1740" id="1740" class="graf--h3">Use performance monitoring tools to identify bottle necks</h3><p name="03ee" id="03ee" class="graf--p">This is quite new territory for me, but it is probably fair to say that it's a good idea to keep close look at your application's performance during development. I haven't tested them all, (though I made good experiences with New Relic) but here the recommendations I got from others:</p><ul class="postList"><li name="8334" id="8334" class="graf--li"><a href="https://www.npmjs.com/package/node-siege" data-href="https://www.npmjs.com/package/node-siege" class="markup--anchor markup--li-anchor" rel="nofollow">Siege</a></li><li name="fb58" id="fb58" class="graf--li"><a href="http://www.monitis.com/application-monitoring" data-href="http://www.monitis.com/application-monitoring" class="markup--anchor markup--li-anchor" rel="nofollow">Monitis</a></li><li name="0f6b" id="0f6b" class="graf--li"><a href="http://newrelic.com/nodejs" data-href="http://newrelic.com/nodejs" class="markup--anchor markup--li-anchor" rel="nofollow">New Relic</a></li></ul><p name="090c" id="090c" class="graf--p graf--last"><em class="markup--em markup--p-em">Sidenote: Node.js applications in production mode run with higher performance than in development. You can run your app in production mode to get a sense of the performance once your application is deployed.</em></p></div>
			</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
			</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
			</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
			</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
			</div>
		<!--=========================
			END : POST
		=============================-->
	</body>
</html>