<html><head>
		<meta charset="utf-8">
		<title>5 - Javascript Book :: Part 5</title>
		<meta name="t-itle" content="">
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!--<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
		<link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i|PT+Serif:400,700" rel="stylesheet">-->
		<style>
			* { box-sizing: border-box; }
			body { 
			font-family: 'Open Sans', Arial, sans-serif;
			font-size: 14px;
			line-height: 1.8;
			padding: 0.5em;
			font-family: 'PT Sans', Arial, sans-serif;
			
			}
			img { display: block; margin: 0 auto; max-width: 100%; }
			pre { 
			border: 1px dashed #333; 
			padding: 1em 2em; 
			font-family: Consolas,monospace; 
			background-color: #EEE; 
			overflow-x: scroll; 
			font-size: 14px;  
			white-space: pre-wrap; 
			word-wrap: break-word; 
			}
			pre {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    margin: 1em auto;
    border: 1px dashed #333;
    width: 100%;
    padding: 1em 1.5em;
    font-family: Inconsolata, Consolas, monospace, sans-serif;
    font-size: 1em;
    overflow: auto;
    background: #F7FAFB;
    border-radius: 3px;
	position:relative;
}
			code { background-color: #EEE; padding: 3px; font-family: Consolas,monospace; }
			pre code { background-color: transparent; padding: 0; display: block; }
			
			pre:after {
				content: "<CODE>";
				position: absolute;
				top:0;
				right: 0;
				padding: 5px 15px;
				background: #999;
				color: #FFF;
			}
			.tutorial-index {
			counter-reset: section;
			}
			.tutorial-index h1:before {
    /*counter-increment: section;
    content: counter(section) " : ";*/
}
.tutorial-index h1 {font-size: 1.2em; padding: 5px 0;}
.tutorial-index a { display: block; float: left; width: 50%;}
			.tutorial-index a { text-decoration: none; }
			h1 { font-size: 1.6em; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			
			.main { counter-reset: mainsection; }
			.main h1 { font-size: 1.6em; border-bottom: 2px solid #000; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			/*.main h1:before {
    counter-increment: mainsection;
    content: counter(mainsection) " : ";
}*/
			
			
			
			h2, h3, h6 { 
			font-size: 1.2em;
			font-family: 'PT Serif', Arial, serif;
			padding-left: 1em;
			border-left: 2px solid #868686; 
			}
			.cf:before,
.cf:after {
    content: " ";
    display: table;
}
.cf:after {
    clear: both;
}
table { border-collapse: collapse;}
table td { border: 1px solid #999; padding: 5px;}

@media print {
    .main h1 {page-break-before: always;}
}
.tc { text-align: center}
.home-screen { border: 1px solid #777; padding: 4em 0; }
.home-screen * {    font-family: 'PT Sans', Arial, sans-serif;
    font-size: 3em;
    font-weight: normal;}
	
		</style>
	</head>
	<body>
		<div class="home-screen tc">
			<h1>JavaScript Tutorials</h1>
			<h4>- Part 5-</h4>
		</div>
		<!--================= START :: Tutorial Index =================-->
<div class="tutorial-index cf">
	<a href="#t-01"><h1>01 : ECMAScript 6 equivalents in ES5</h1></a>
	<a href="#t-02"><h1>02 : JavaScript Inheritance Done Right</h1></a>
	<a href="#t-03"><h1>03 : Javascript Inheritance Done Right</h1></a>
	<a href="#t-04"><h1>04 : Basic Inheritance with JavaScript Constructors</h1></a>
	<a href="#t-05"><h1>05 : Call and Apply for Beginners</h1></a>
	<a href="#t-06"><h1>06 : Understanding JavaScript Constructors</h1></a>
	<a href="#t-07"><h1>07 : Functions as First Class Citizens in Javascript</h1></a>
	<a href="#t-08"><h1>08 : Quick Tip: How JavaScript References Work</h1></a>
	<a href="#t-09"><h1>Index</h1></a>
	<a href="#t-10"><h1>Index</h1></a>
</div>
		<!--================= END :: Tutorial Index =================-->
		
		<main class="main">
			
			<section class="section__one">
			
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-01" name="t-01"></a><h1>01 : ECMAScript 6 equivalents in ES5</h1>
					<span class="ref-site">https://github.com/addyosmani/es6-equivalents-in-es5</span>
					<div class="tutorial__content">
<article class="markdown-body entry-content" itemprop="text">
<p><strong>Table of contents:</strong></p>
<ol>
<li><a href="#arrow-functions">Arrow Functions</a></li>
<li><a href="#block-scoping-functions">Block Scoping Functions</a></li>
<li><a href="#t-emplate-literals">Template Literals</a></li>
<li><a href="#computed-property-names">Computed Property Names</a></li>
<li><a href="#destructuring-assignment">Destructuring Assignment</a></li>
<li><a href="#default-parameters">Default Parameters</a></li>
<li><a href="#iterators-and-for-of">Iterators and For-Of</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#numeric-literals">Numeric Literals</a></li>
<li><a href="#property-method-assignment">Property Method Assignment</a></li>
<li><a href="#object-initializer-shorthand">Object Initializer Shorthand</a></li>
<li><a href="#rest-parameters">Rest Parameters</a></li>
<li><a href="#spread-operator">Spread Operator</a></li>
<li><a href="#proxying-a-function-object">Proxying a function object</a></li>
<li><a href="#array-like-object-to-array">Array-like object to array</a></li>
<li><a href="#about">About</a></li>
<li><a href="#license">License</a></li>
</ol>
<h2><a id="user-content-arrow-functions" class="anchor" href="#arrow-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arrow Functions</h2>
<p>An arrow function expression (also known as fat arrow function) has a shorter syntax compared to function expressions and lexically binds the this value. Arrow functions are always anonymous.</p>
<p>ES6:</p>
<pre><code>[1, 2, 3].map(n =&gt; n * 2);
// -&gt; [ 2, 4, 6 ]
</code></pre>
<p>ES5 equivalent:</p>
<pre><code>[1, 2, 3].map(function(n) { return n * 2; }, this);
// -&gt; [ 2, 4, 6 ]
</code></pre>
<p>ES6:</p>
<pre><code>var evens = [2, 4, 6, 8, 10];

// Expression bodies
var odds = evens.map(v =&gt; v + 1);
var nums = evens.map((v, i) =&gt; v + i);

console.log(odds);
// -&gt; [3, 5, 7, 9, 11]

console.log(nums);
// -&gt; [2, 5, 8, 11, 14]

// Statement bodies
var fives = [];
nums = [1, 2, 5, 15, 25, 32];
nums.forEach(v =&gt; {
  if (v % 5 === 0)
    fives.push(v);
});

console.log(fives);
// -&gt; [5, 15, 25]

// Lexical this
var bob = {
  _name: 'Bob',
  _friends: [],
  printFriends() {
    this._friends.forEach(f =&gt;
      console.log(this._name + ' knows ' + f));
  }
}
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var evens = [2, 4, 6, 8, 10];

// Expression bodies
var odds = evens.map(function (v) {
  return v + 1;
}, this);
var nums = evens.map(function (v, i) {
  return v + i;
}, this);

console.log(odds);
// -&gt; [3, 5, 7, 9, 11]

console.log(nums);
// -&gt; [2, 5, 8, 11, 14]

var fives = [];
nums = [1, 2, 5, 15, 25, 32];

// Statement bodies
nums.forEach(function (v) {
  if (v % 5 === 0) {
    fives.push(v);
  }
}, this);

console.log(fives);
// -&gt; [5, 15, 25]

// Lexical this
var bob = {
  _name: 'Bob',
  _friends: [],
  printFriends: function printFriends() {
    this._friends.forEach(function (f) {
      return console.log(this._name + ' knows ' + f);
    }, this);
  }
};
</code></pre>
<h2><a id="user-content-block-scoping-functions" class="anchor" href="#block-scoping-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Block Scoping Functions</h2>
<p>Block scoped bindings provide scopes other than the function and top level scope. This ensures your variables don't leak out of the scope they're defined:</p>
<p>ES6:</p>
<pre><code>// let declares a block scope local variable,
// optionally initializing it to a value in ES6

'use strict';

var a = 5;
var b = 10;

if (a === 5) {
  let a = 4; // The scope is inside the if-block
  var b = 1; // The scope is inside the function

  console.log(a);  // 4
  console.log(b);  // 1
}

console.log(a); // 5
console.log(b); // 1
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var a = 5;
var b = 10;

if (a === 5) {
  // technically is more like the following
  (function () {
    var a = 4;
    b = 1;

    console.log(a); // 4
    console.log(b); // 1
  })();
}

console.log(a); // 5
console.log(b); // 1
</code></pre>
<p>ES6:</p>
<pre><code>// const creates a read-only named constant in ES6.
'use strict';
// define favorite as a constant and give it the value 7
const favorite = 7;
// Attempt to overwrite the constant
try {
  favorite = 15;
} catch (err) {
  console.log('my favorite number is still: ' + favorite);
  // will still print 7
}
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';
// define favorite as a non-writable `constant` and give it the value 7
Object.defineProperties(window, {
  favorite: {
    value: 7,
    enumerable: true
  }
});
// ^ descriptors are by default false and const are enumerable
var favorite = 7;
// Attempt to overwrite the constant
favorite = 15;
// will still print 7
console.log('my favorite number is still: ' + favorite);
</code></pre>
<h2><a id="user-content-template-literals" class="anchor" href="#t-emplate-literals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Template Literals</h2>
<p>ES6 Template Literals are strings that can include <strong>embedded expressions</strong>. This is sometimes referred to as string interpolation.</p>
<p>ES6:</p>
<pre><code>// Basic usage with an expression placeholder
var person = 'Addy Osmani';
console.log(`Yo! My name is ${person}!`);

// Expressions work just as well with object literals
var user = {name: 'Caitlin Potter'};
console.log(`Thanks for getting this into V8, ${user.name}.`);

// Expression interpolation. One use is readable inline math.
var a = 50;
var b = 100;
console.log(`The number of JS frameworks is ${a + b} and not ${2 * a + b}.`);

// Multi-line strings without needing \n\
console.log(`string text line 1
string text line 2`);

// Functions inside expressions
function fn() { return 'result'; }
console.log(`foo ${fn()} bar`);
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

// Basic usage with an expression placeholder
var person = 'Addy Osmani';
console.log('Yo! My name is ' + person + '!');

// Expressions work just as well with object literals
var user = { name: 'Caitlin Potter' };
console.log('Thanks for getting this into V8, ' + user.name + '.');

// Expression interpolation. One use is readable inline math.
var a = 50;
var b = 100;
console.log('The number of JS frameworks is ' + (a + b) + ' and not ' + (2 * a + b) + '.');

// Multi-line strings:
console.log('string text line 1\nstring text line 2');
// Or, alternatively:
console.log('string text line 1\n\
string text line 2');

// Functions inside expressions
function fn() {
  return 'result';
}
console.log('foo ' + fn() + ' bar');
</code></pre>
<h2><a id="user-content-computed-property-names" class="anchor" href="#computed-property-names" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Computed Property Names</h2>
<p>Computed property names allow you to specify properties in object literals based on expressions:</p>
<p>ES6:</p>
<pre><code>var prefix = 'foo';
var myObject = {
  [prefix + 'bar']: 'hello',
  [prefix + 'baz']: 'world'
};

console.log(myObject['foobar']);
// -&gt; hello
console.log(myObject['foobaz']);
// -&gt; world
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var prefix = 'foo';
var myObject = {};

myObject[prefix + 'bar'] = 'hello';
myObject[prefix + 'baz'] = 'world';

console.log(myObject['foobar']);
// -&gt; hello
console.log(myObject['foobaz']);
// -&gt; world
</code></pre>
<h2><a id="user-content-destructuring-assignment" class="anchor" href="#destructuring-assignment" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Destructuring Assignment</h2>
<p>The destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals.</p>
<p>ES6:</p>
<pre><code>var {foo, bar} = {foo: 'lorem', bar: 'ipsum'};
// foo =&gt; lorem and bar =&gt; ipsum
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var _ref = { foo: 'lorem', bar: 'ipsum' };

// foo =&gt; lorem and bar =&gt; ipsum
var foo = _ref.foo;
var bar = _ref.bar;
</code></pre>
<p>ES3:</p>
<pre><code>with({foo: 'lorem', bar: 'ipsum'}) {
  // foo =&gt; lorem and bar =&gt; ipsum
}
</code></pre>
<p>ES6:</p>
<pre><code>var [a, , b] = [1,2,3];
</code></pre>
<p>ES6 (shimming using <code>Symbol.iterator</code>):</p>
<pre><code>'use strict';

var _slicedToArray = function (arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i &amp;&amp; _arr.length === i) {
        break;
      }
    }

    return _arr;
  }
};

var _ref = [1, 2, 3];

var _ref2 = _slicedToArray(_ref, 3);

var a = _ref2[0];
var b = _ref2[2];
</code></pre>
<p>ES5:</p>
<pre><code>String.prototype.asNamedList = function () {
  return this.split(/\s*,\s*/).map(function (name, i) {
    return name ? ('var ' + name + '=slice(' + i + ', ' + (i + 1) + ')[0]') : '';
  }).join(';');
};

with([1,2,3]) {
  eval('a, , b'.asNamedList());
}
</code></pre>
<h2><a id="user-content-default-parameters" class="anchor" href="#default-parameters" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Parameters</h2>
<p>Default parameters allow your functions to have optional arguments without needing to check arguments.length or check for undefined.</p>
<p>ES6:</p>
<pre><code>function greet(msg='hello', name='world') {
  console.log(msg,name);
}

greet();
// -&gt; hello world
greet('hey');
// -&gt; hey world
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function greet() {
  // unfair ... if you access arguments[0] like this you can simply
  // access the msg variable name instead
  var msg = arguments[0] === undefined ? 'hello' : arguments[0];
  var name = arguments[1] === undefined ? 'world' : arguments[1];
  console.log(msg, name);
}

function greet(msg, name) {
  (msg === undefined) &amp;&amp; (msg = 'hello');
  (name === undefined) &amp;&amp; (name = 'world');
  console.log(msg,name);
}

// using basic utility that check against undefined
function greet(msg, name) {
  console.log(
    defaults(msg, 'hello'),
    defaults(name, 'world')
  );
}

greet();
// -&gt; hello world
greet('hey');
// -&gt; hey world
</code></pre>
<p>ES6:</p>
<pre><code>function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}

f(3) === 15;
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x, y) {
  if (y === undefined) {
    y = 12;
  }

  return x + y;
}

f(3) === 15;
</code></pre>
<h2><a id="user-content-iterators-and-for-of" class="anchor" href="#iterators-and-for-of" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterators And For-Of</h2>
<p>Iterators are objects that can traverse a container. It's a useful way to make a class work inside a for of loop.
The interface is similar to the iterators-interface. Iterating with a <code>for..of</code> loop looks like:</p>
<p>ES6:</p>
<pre><code>// Behind the scenes, this will get an iterator from the array and loop through it, getting values from it.
for (let element of [1, 2, 3]) {
  console.log(element);
}
// =&gt; 1 2 3
</code></pre>
<p>ES6 (without using <code>for-of</code>, if <code>Symbol</code> is supported):</p>
<pre><code>'use strict';

for (var _iterator = [1, 2, 3][Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
  var element = _step.value;
  console.log(element);
}

// =&gt; 1 2 3
</code></pre>
<p>ES5 (approximates):</p>
<pre><code>// Using forEach()
// Doesn't require declaring indexing and element variables in your containing
// scope. They get supplied as arguments to the iterator and are scoped to just
// that iteration.
var a = [1,2,3];
a.forEach(function (element) {
    console.log(element);
});

// =&gt; 1 2 3

// Using a for loop
var a = [1,2,3];
for (var i = 0; i &lt; a.length; ++i) {
    console.log(a[i]);
}
// =&gt; 1 2 3
</code></pre>
<p>Note the use of <code>Symbol</code>. The ES5 equivalent would require a Symbol polyfill in order to correctly function.</p>
<h2><a id="user-content-classes" class="anchor" href="#classes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Classes</h2>
<p>This implements class syntax and semantics as described in the ES6 draft spec. Classes are a great way to reuse code.
Several JS libraries provide classes and inheritance, but they aren't mutually compatible.</p>
<p>ES6:</p>
<pre><code>class Hello {
  constructor(name) {
    this.name = name;
  }

  hello() {
    return 'Hello ' + this.name + '!';
  }

  static sayHelloAll() {
    return 'Hello everyone!';
  }
}

class HelloWorld extends Hello {
  constructor() {
    super('World');
  }

  echo() {
    alert(super.hello());
  }
}

var hw = new HelloWorld();
hw.echo();

alert(Hello.sayHelloAll());
</code></pre>
<p>ES5 (approximate):</p>
<pre><code>function Hello(name) {
  this.name = name;
}

Hello.prototype.hello = function hello() {
  return 'Hello ' + this.name + '!';
};

Hello.sayHelloAll = function () {
  return 'Hello everyone!';
};

function HelloWorld() {
  Hello.call(this, 'World');
}

HelloWorld.prototype = Object.create(Hello.prototype);
HelloWorld.prototype.constructor = HelloWorld;
HelloWorld.sayHelloAll = Hello.sayHelloAll;

HelloWorld.prototype.echo = function echo() {
  alert(Hello.prototype.hello.call(this));
};

var hw = new HelloWorld();
hw.echo();

alert(Hello.sayHelloAll());
</code></pre>
<p>A more faithful (albeit, slightly verbose) interpretation can be found in this <a href="https://goo.gl/ZvEQDq">Babel</a> output.</p>
<h2><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules</h2>
<p>Modules are mostly implemented, with some parts of the Loader API still to be corrected. Modules try to solve many issues in dependencies and deployment, allowing users to create modules with explicit exports, import specific exported names from those modules, and keep these names separate.</p>
<p><em>Assumes an environment using CommonJS</em></p>
<p>app.js - ES6</p>
<pre><code>import math from 'lib/math';
console.log('2π = ' + math.sum(math.pi, math.pi));
</code></pre>
<p>app.js - ES5</p>
<pre><code>var math = require('lib/math');
console.log('2π = ' + math.sum(math.pi, math.pi));
</code></pre>
<p>lib/math.js - ES6</p>
<pre><code>export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
</code></pre>
<p>lib/math.js - ES5</p>
<pre><code>exports.sum = sum;
function sum(x, y) {
  return x + y;
}
var pi = exports.pi = 3.141593;
</code></pre>
<p>lib/mathplusplus.js - ES6</p>
<pre><code>export * from 'lib/math';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
</code></pre>
<p>lib/mathplusplus.js - ES5</p>
<pre><code>var Math = require('lib/math');

var _extends = function (target) {
  for (var i = 1; i &lt; arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }

  return target;
};

var e = exports.e = 2.71828182846;
exports['default'] = function (x) {
  return Math.exp(x);
};

module.exports = _extends(exports['default'], exports);
</code></pre>
<h2><a id="user-content-numeric-literals" class="anchor" href="#numeric-literals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Numeric Literals</h2>
<p>ES6:</p>
<pre><code>var binary = [
  0b0,
  0b1,
  0b11
];
console.assert(binary === [0, 1, 3]);

var octal = [
  0o0,
  0o1,
  0o10,
  0o77
];
console.assert(octal === [0, 1, 8, 63]);
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var binary = [0, 1, 3];
console.assert(binary === [0, 1, 3]);

var octal = [0, 1, 8, 63];
console.assert(octal === [0, 1, 8, 63]);
</code></pre>
<h2><a id="user-content-property-method-assignment" class="anchor" href="#property-method-assignment" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Property Method Assignment</h2>
<p>Method syntax is supported in object initializers, for example see toString():</p>
<p>ES6:</p>
<pre><code>var object = {
  value: 42,
  toString() {
    return this.value;
  }
};

console.log(object.toString() === 42);
// -&gt; true
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var object = {
  value: 42,
  toString: function toString() {
    return this.value;
  }
};

console.log(object.toString() === 42);
// -&gt; true
</code></pre>
<h2><a id="user-content-object-initializer-shorthand" class="anchor" href="#object-initializer-shorthand" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object Initializer Shorthand</h2>
<p>This allows you to skip repeating yourself when the property name and property value are the same in an object literal.</p>
<p>ES6:</p>
<pre><code>function getPoint() {
  var x = 1;
  var y = 10;

  return {x, y};
}

console.log(getPoint() === {
  x: 1,
  y: 10
});
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function getPoint() {
  var x = 1;
  var y = 10;

  return { x: x, y: y };
}

console.log(getPoint() === {
  x: 1,
  y: 10
});
</code></pre>
<h2><a id="user-content-rest-parameters" class="anchor" href="#rest-parameters" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rest Parameters</h2>
<p>Rest parameters allows your functions to have variable number of arguments without using the arguments object.
The rest parameter is an instance of Array so all the array methods just work.</p>
<p>ES6:</p>
<pre><code>function f(x, ...y) {
  // y is an Array
  return x * y.length;
}

console.log(f(3, 'hello', true) === 6);
// -&gt; true
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x) {
  var y = [];
  y.push.apply(y, arguments) &amp;&amp; y.shift();

  // y is an Array
  return x * y.length;
}

console.log(f(3, 'hello', true) === 6);
// -&gt; true
</code></pre>
<h2><a id="user-content-spread-operator" class="anchor" href="#spread-operator" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spread Operator</h2>
<p>The spread operator is like the reverse of rest parameters. It allows you to expand an array into multiple formal parameters.</p>
<p>ES6:</p>
<pre><code>function add(a, b) {
  return a + b;
}

let nums = [5, 4];

console.log(add(...nums));
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var _toArray = function (arr) {
  return Array.isArray(arr) ? arr : [].slice.call(arr);
};

function add(a, b) {
  return a + b;
}

var nums = [5, 4];
console.log(add.apply(null, _toArray(nums)));
</code></pre>
<p>ES6:</p>
<pre><code>function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) === 6;
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f.apply(null, [1, 2, 3]) === 6;
</code></pre>
<h2><a id="user-content-proxying-a-function-object" class="anchor" href="#proxying-a-function-object" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proxying a function object</h2>
<p>ES6:</p>
<pre><code>var target = function () {
  return 'I am the target';
};

var handler = {
  apply: function (receiver, ...args) {
    return 'I am the proxy';
  }
};

var p = new Proxy(target, handler);
console.log(p() === 'I am the proxy');
// -&gt; true
</code></pre>
<p>ES5:</p>
<p>No proxy in ES5, hard to intercept <strong>noSuchMethod</strong> and others.</p>
<h2><a id="user-content-array-like-object-to-array" class="anchor" href="#array-like-object-to-array" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array-like object to array</h2>
<p><strong>Array.from</strong> converts a single argument that is an array-like object or list (eg. <code>arguments</code>, <code>NodeList</code>, <code>DOMTokenList</code> (used by <code>classList</code>), <code>NamedNodeMap</code> (used by attributes property) into a new Array() and returns it.</p>
<p>ES6:</p>
<pre><code>var listFriends = function() {
  var friends = Array.from(arguments);
  friends.forEach(friend =&gt; {
    console.log(friend);
  });
};
listFriends('ann', 'bob');
// -&gt; 'ann'
// -&gt; 'bob'


var divs = document.querySelectorAll('div');
Array.from(divs).forEach(node =&gt; {
    console.log(node);
});
// -&gt; &lt;div&gt;...&lt;/div&gt;
// -&gt; &lt;div&gt;...&lt;/div&gt;
</code></pre>
<p>ES5:</p>
<pre><code>var listFriends = function() {
  var friends = [].slice.call(arguments)
  friends.forEach(function(friend) {
    console.log(friend);
  });
};
listFriends('ann', 'bob');
// -&gt; 'ann'
// -&gt; 'bob'


var divsArray = [].slice.call(document.querySelectorAll('div'));
divsArray.forEach(function(node) {
    console.log(node);
});
// -&gt; &lt;div&gt;...&lt;/div&gt;
// -&gt; &lt;div&gt;...&lt;/div&gt;
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-02" name="t-02"></a><h1>02 : JavaScript Inheritance Done Right</h1>
					<span class="ref-site">https://ncombo.wordpress.com/2013/07/11/javascript-inheritance-done-right/</span>
					<div class="tutorial__content">
<div class="entry-content">
					<p>One of the worst (and possibly also one of the best) things about JavaScript is that it offers you many ways to do anything. Some tricks are simple and neat while others can be complex and confusing.</p>
<p>If you have done some research, you will likely have come across many ways of implementing inheritance in JavaScript. I have personally used a lot of variations over time in various projects but it's not until recently that I have settled on a particular technique.</p>
<p>I have chosen this particular technique because I feel that it most closely resembles how most OO programming languages implement inheritance. To get it to work properly, you should use the prototype-based method of class definition. Here is an example of the technique in action:</p>
<blockquote><p>
function BaseClass(name) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="skimlinks-unlinked">this.name</span> = name;<br>
}</p>
<p><span class="skimlinks-unlinked">BaseClass.prototype.foo</span> = function (arg) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ‘This is the foo method with argument: ‘ + arg;<br>
};</p>
<p>function SubClass(name) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Call the base class' constructor.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="skimlinks-unlinked">BaseClass.call(this</span>, name);<br>
}</p>
<p>// SubClass' prototype is based on BaseClass' prototype<br>
SubClass.prototype = Object.create(BaseClass.prototype);</p>
<p><span class="skimlinks-unlinked">SubClass.prototype.sub</span> = function () {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ‘This is the sub method.'<br>
}</p>
<p><span class="skimlinks-unlinked">SubClass.prototype.foo</span> = function (arg) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Call the base class foo method on the current instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;return <span class="skimlinks-unlinked">BaseClass.prototype.foo.call(this</span>, arg) + ‘ SUB';<br>
}</p></blockquote>
<p>Ok, so what stands out the most in this code is this line:</p>
<blockquote><p>SubClass.prototype = Object.create(BaseClass.prototype);</p></blockquote>
<p>When you define a function in JavaScript, initially, its prototype will be an empty object. What we're doing here is setting the SubClass' prototype to be a new instance which shares the BaseClass' prototype. Effectively, this allows us to freely modify the SubClass' extended prototype without messing with the BaseClass' prototype – The advantage of this technique over simply cloning the prototype is that changes in the BaseClass prototype will still be reflected in the SubClass (but not the other way around). The best way to think about the Object.create() method is that it instantiates a class based on a prototype without actually going through its constructor. The Object.create() function may not be supported by older browsers, but thankfully there is a simple polyfill which you can get from this page:<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>
<p>The second weird thing about the code above is this line:</p>
<p><span class="skimlinks-unlinked">BaseClass.call(this</span>, name);</p>
<p>Now if you don't know what call or apply do, you should check this:<br>
<a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply">http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply</a></p>
<p>OO languages usually offer a way to explicitly call a super class' constructor or method, JavaScript is no exception. With JavaScript, you just call the constructor/method using either call() or apply() and pass a reference to the current instance as the first argument. This is a neat feature of JavaScript which allows you to effectively borrow methods from any other class to use on the current instance.</p>
<p>If you're used to languages like Java, C# and Python, you might find the class definitions above unusual – In these languages you have an explicit ‘class' keyword and you define the methods INSIDE the class block. If however, you have written C++ before, this might seem a little less confusing because C++ allows you to define methods of a class outside of the class definition block.&nbsp;While JavaScript does let you define methods inside the constructor's function block, this makes inheritance more difficult to achieve and I would strongly recommend that you follow the technique above (I swear you won't regret it).</p>
										</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-03" name="t-03"></a><h1>03 : Javascript Inheritance Done Right</h1>
					<span class="ref-site">http://js-bits.blogspot.com/2010/08/javascript-inheritance-done-right.html</span>
					<div class="tutorial__content">
<div class="post-body entry-content" id="post-body-578868776986553481" itemprop="description articleBody">
I've seen a number of different ways of implementing Javascript inheritance. The real test to see if inheritance is working correctly is that the instanceof operator works correctly. So all the approaches that <a href="http://www.sitepoint.com/blogs/2006/01/17/javascript-inheritance/">copy methods</a> from the base to the subclass are out of the question because they do not correctly setup the prototype chain. Another consequence of inheritance by copying is that if you change the prototype after the object has been instantiated, the object does not magically inherit the added property. <br>
<br>
This leads me to the most common approach which does correctly set up prototype chain but has a few problems:<br>
<br>
<div><pre><code>function Animal(name) {
&nbsp;&nbsp;this.name = name;
}
&nbsp;
// This style of setting the prototype to an object
// works for classes that inherit from Object.
Animal.prototype = {
&nbsp;&nbsp;sayMyName: function() {
&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.getWordsToSay() + " " + this.name);
&nbsp;&nbsp;},
&nbsp;&nbsp;getWordsToSay: function() {
&nbsp;&nbsp;&nbsp;&nbsp;// Abstract
&nbsp;&nbsp;}
}
&nbsp;
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor
&nbsp;&nbsp;Animal.call(this, name);
}
&nbsp;
// Setup the prototype chain mmm... calling
// the Animal without the required params?
Dog.prototype = new Animal();
&nbsp;
Dog.prototype.getWordsToSay = function(){
&nbsp;&nbsp;return "Ruff Ruff";
}
&nbsp;
var dog = new Dog("Lassie");
dog.sayMyName(); // Outputs Ruff Ruff Lassie
console.log(dog instanceof Animal); // true
console.log(dog.constructor); // Animal ???? That's not right
console.log("name" in Dog.prototype)// true, but undefined
</code></pre></div><br>
Alright, what's going on?<br>
<ul><li>Dog.prototype now has a property called "name" that is set to undefined. <br>
That wasn't intentional. I knew that call to Animal's constructor was funny. Though that won't cause a problem, because we add a "name" to the object in the constructor, it's not very elegant</li>
<li>dog (the instance) has a constructor property but it points to Animal,<br>
that's just wrong</li>
</ul><br>
How can we fix that? Here's a first try<br>
<br>
<div><pre><code>// This is a constructor that is used to setup inheritance without
// invoking the base's constructor. It does nothing, so it doesn't
// create properties on the prototype like our previous example did
function surrogateCtor() {}
&nbsp;
function extend(base, sub) {
&nbsp;&nbsp;// Copy the prototype from the base to setup inheritance
&nbsp;&nbsp;surrogateCtor.prototype = base.prototype;
&nbsp;&nbsp;// Tricky huh?
&nbsp;&nbsp;sub.prototype = new surrogateCtor();
&nbsp;&nbsp;// Remember the constructor property was set wrong, let's fix it
&nbsp;&nbsp;sub.prototype.constructor = sub;
}
&nbsp;
// Let's try this
function Animal(name) {
&nbsp;&nbsp;this.name = name;
}
&nbsp;
Animal.prototype = {
&nbsp;&nbsp;sayMyName: function() {
&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.getWordsToSay() + " " + this.name);
&nbsp;&nbsp;},
&nbsp;&nbsp;getWordsToSay: function() {
&nbsp;&nbsp;&nbsp;&nbsp;// Abstract
&nbsp;&nbsp;}
}
&nbsp;
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor
&nbsp;&nbsp;Animal.call(this, name);
}
&nbsp;
// Setup the prototype chain the right way
extend(Animal, Dog);
&nbsp;
Dog.prototype.getWordsToSay = function(){
&nbsp;&nbsp;return "Ruff Ruff";
}
&nbsp;
var dog = new Dog("Lassie");
dog.sayMyName(); // Outputs Ruff Ruff Lassie
console.log(dog instanceof Animal); // true
console.log(dog.constructor); // Dog
console.log("name" in Dog.prototype)// false
</code></pre></div><br>
Nice isn't it? Let's add some syntactic sugar to make it more user friendly.<br>
<ul><li>Add a reference to the base class so we don't have to hard code it</li>
<li>Pass the object's prototype methods into the call</li>
</ul><br>
<br>
<div><pre><code>function surrogateCtor() {}
&nbsp;
function extend(base, sub, methods) {
&nbsp;&nbsp;surrogateCtor.prototype = base.prototype;
&nbsp;&nbsp;sub.prototype = new surrogateCtor();
&nbsp;&nbsp;sub.prototype.constructor = sub;
&nbsp;&nbsp;// Add a reference to the parent's prototype
&nbsp;&nbsp;sub.base = base.prototype;
&nbsp;
&nbsp;&nbsp;// Copy the methods passed in to the prototype
&nbsp;&nbsp;for (var name in methods) {
&nbsp;&nbsp;&nbsp;&nbsp;sub.prototype[name] = methods[name];
&nbsp;&nbsp;}
&nbsp;&nbsp;// so we can define the constructor inline
&nbsp;&nbsp;return sub;
}
&nbsp;
// Use the same animal from above
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor without hard coding the parent
&nbsp;&nbsp;Dog.base.constructor.call(this, name);
}
&nbsp;
extend(Animal, Dog, {
&nbsp;&nbsp;getWordsToSay: function(){
&nbsp;&nbsp;&nbsp;&nbsp;return "Ruff Ruff";
&nbsp;&nbsp;}
});
</code></pre></div><br>
One more step, I don't even like hard coding the name of the class in the methods in case I rename it, how can we fix that?<br>
<br>
The solution is to wrap everything in a self executing function and create a reference to the constructor<br>
<br>
<div><pre><code>Dog = (function(){
&nbsp;&nbsp;// $this refers to the constructor
&nbsp;&nbsp;var $this = function (name) {
&nbsp;&nbsp;&nbsp;&nbsp;// Look, no hardcoded reference to this class's name
&nbsp;&nbsp;&nbsp;&nbsp;$this.base.constructor.call(this, name);
&nbsp;&nbsp;};
&nbsp;
&nbsp;&nbsp;extend(Animal, $this, {
&nbsp;&nbsp;&nbsp;&nbsp;getWordsToSay: function(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Ruff Ruff";
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;});
&nbsp;
&nbsp;&nbsp;return $this;
})();
</code></pre></div><br>
With this final approach, renaming the class or changing its parent requires changing a single place (for each change).

<h3>Update</h3>
<p>This article was written a while ago, when <a href="">Object.create</a> wasn't as well supported. The extend function could be simplified to be</p>
<div><pre><code>function extend(base, sub, methods) {
&nbsp;&nbsp;sub.prototype = Object.create(base.prototype);
&nbsp;&nbsp;sub.prototype.constructor = sub;
&nbsp;&nbsp;sub.base = base.prototype;
&nbsp;
&nbsp;&nbsp;// Copy the methods passed in to the prototype
&nbsp;&nbsp;for (var name in methods) {
&nbsp;&nbsp;&nbsp;&nbsp;sub.prototype[name] = methods[name];
&nbsp;&nbsp;}
&nbsp;&nbsp;// so we can define the constructor inline
&nbsp;&nbsp;return sub;
}
</code></pre></div><br>

</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-04" name="t-04"></a><h1>04 : Basic Inheritance with JavaScript Constructors</h1>
					<span class="ref-site">http://adripofjavascript.com/blog/drips/basic-inheritance-with-javascript-constructors.html</span>
					<div class="tutorial__content">
<div class="post">
<p>We've looked before at using JavaScript's constructors to create our own custom object types. But what we didn't look at was how we can create an inheritance hierarchy.</p>

<p>It's important to note that even though constructors are often referred to as "classes," they really aren't the same thing as classes in other languages. In JavaScript, a constructor is just a function invoked by the <code>new</code> operator which builds a new object.</p>

<p>Here's a little refresher:</p>
<pre><code>function SuperHuman (name, superPower) {
    this.name = name;
    this.superPower = superPower;
}

SuperHuman.prototype.usePower = function () {
    console.log(this.superPower + "!");
};

var banshee = new SuperHuman("Silver Banshee", "sonic wail");

// Outputs: "sonic wail!"
banshee.usePower();
</code></pre>
<p>The <code>SuperHuman</code> constructor contains our initialization logic, while <code>SuperHuman.prototype</code> contains the methods that are shared across all <code>SuperHuman</code> instances.</p>

<p>But suppose that we want to create a new type which inherits from <code>SuperHuman</code> while adding its own functionality? What would that look like?</p>
<pre><code>function SuperHero (name, superPower) {
    this.name = name;
    this.superPower = superPower;
    this.allegiance = "Good";
}

SuperHero.prototype.saveTheDay = function () {
    console.log(this.name + " saved the day!");
};

var marvel = new SuperHero("Captain Marvel", "magic");

// Outputs: "Captain Marvel saved the day!"
marvel.saveTheDay();
</code></pre>
<p>While this gets us started, there are a couple of problems. First of all, the <code>SuperHero</code> constructor is repeating some of the logic of the <code>SuperHuman</code> constructor. And more importantly, at this point instances of <code>SuperHero</code> don't have access to <code>SuperHuman</code> methods. For example:</p>
<pre><code>// TypeError: Object &lt;#SuperHero&gt; has no method 'usePower'
marvel.usePower();
</code></pre>
<p>Let's fix those couple of issues.</p>
<pre><code>function SuperHero (name, superPower) {
    // Reuse SuperHuman initialization
    SuperHuman.call(this, name, superPower);

    this.allegiance = "Good";
}

SuperHero.prototype = new SuperHuman();

SuperHero.prototype.saveTheDay = function () {
    console.log(this.name + " saved the day!");
};

var marvel = new SuperHero("Captain Marvel", "magic");

// Outputs: "Captain Marvel saved the day!"
marvel.saveTheDay();

// Outputs: "magic!"
marvel.usePower();
</code></pre>
<p>We've managed to eliminate the repeated constructor logic by calling <code>SuperHuman</code> with <code>SuperHero</code>'s <code>this</code> object and passing along the necessary arguments. That ensures that <code>SuperHuman</code>'s initialization logic will act on the new <code>SuperHero</code> object. And then we tack on the additional logic that is specific to <code>SuperHero</code>.</p>

<p>But where the inheritance comes in is on <code>SuperHero.prototype</code>. In order to ensure that it inherits the methods from <code>SuperHuman.prototype</code>, we actually make it an instance of <code>SuperHuman</code> with <code>new SuperHuman()</code>.</p>

<p>This basic inheritance pattern won't always work, particularly if the parent constructor is complex, but it will handle simple situations quite well.</p>

<p>In future issues we'll take a look at more sophisticated ways of doing inheritance.</p>

    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-05" name="t-05"></a><h1>05 : Call and Apply for Beginners</h1>
					<span class="ref-site">http://ryanchristiani.com/call-and-apply-for-beginners/</span>
					<div class="tutorial__content">
<div class="entry">
	<p>As you advance as a junior front-end developer you will see Javascript code that looks more and more like this.</p>
<pre><code>$.when.apply(null, promiseArray)
 .then(function() {
    var data = arguments;
    ...
 });</code></pre>
<p><span id="more-885"></span></p>
<p>The <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> methods are powerful tools in Javascript, however they can be hard to understand for a young developer, or even for a seasoned developer! The call and apply methods that people will always ask about in interviews, but when you are writing your own Javascript you can never really think of a good reason to use them, or see a need to use them. Lets break down the difference between them, and look at some practical uses for them. We will also look at some new features from ECMAScript2015 (ES6) that can help us simplify the use of these!</p>
<h3 id="i-have-already-read-this-article">I have already read this article!?</h3>
<p>There are a lot of articles out there about this concept. However recently teaching some students, there have been a few cases where <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> has been used to really simplify things. So I wanted to write an article that has some simple break downs and examples of how to use these methods.</p>
<h2 id="scope">Scope</h2>
<p>You can't really talk about <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> without first talking about scope in Javascript. Hopefully the concept of global and local scope is something that you understand, if it is not lets do a quick run down about how that works.</p>
<p>In Javascript if you define anything that is not inside of a function, or something without the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword. This variable is considered to be global, meaning it can be accessed anywhere in your program.</p>
<pre><code>var name = "Ryan";

function sayName() {
    console.log('Hi ' + name + '!');
}
console.log(name); //Ryan
sayName(); //Hi Ryan!</code></pre>
<p>Here we created a variable outside of the function <code class=" language-javascript">sayName</code> so it is accessible inside the function as well as outside of it. If we had done something like this however:</p>
<pre><code>function sayName() {
    name = "Ryan";
    console.log('Hi ' + name + '!');
}
console.log(name); //Ryan
sayName(); //Hi Ryan!</code></pre>
<p>This would still work. Because we have created a variable without the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword, it is by default a global variable. However, when you use the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword and create a variable inside of a function, that is considered to be a local variable. And only accessible inside that function.</p>
<pre><code>function sayName() {
    var name = "Ryan";
    console.log('Hi ' + name + '!');
}
console.log(name); //undefined
sayName(); //Hi Ryan!</code></pre>
<p>So now <code class=" language-javascript">name</code> is scoped locally to just the <code class=" language-javascript">sayName</code> function.</p>
<p>In Javascript we have have the <code class=" language-javascript">this</code> keyword. The context that <code class=" language-javascript">this</code> refers too changes based on a few things. By default if you just open the console in your browser, <code class=" language-javascript">this</code> will refer to the global object. In the case of the browser this is the <code class=" language-javascript">window</code> object, in node it refers to a different global. </p>
<p>When we use the <code class=" language-javascript">this</code> keyword inside of an object, <code class=" language-javascript">this</code> will refer to the object itself.</p>
<pre><code>var person = {
    name: "Ryan Christiani",
    sayName: function() {
        console.log("Hi " + this.name + "!");
    }
}
person.sayName(); //Hi Ryan!</code></pre>
<p>So it is scoped just to that object. Let's see how using <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> can help us change <code class=" language-javascript">this</code>.</p>
<h2 id="call"><code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code></h2>
<p>Functions in JavaScript have a method named <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank"><code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code></a>. It is used to call a function or method, but you are able to determine the context in which it is being called. For example. Assume we have a <code class=" language-javascript">person</code> object that just has a single property on it.</p>
<pre><code>var person = {
    name: "Ryan"
};</code></pre>
<p>Also assume we have a function called <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> that simply prints out a name property from <code class=" language-javascript">this</code>.</p>
<pre><code>function sayName() {
    console.log(this.name);
}</code></pre>
<p>Running <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> like this will not work. It will try to grab a property from the <code class=" language-javascript">window</code> object first. However if we use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can pass in and specify what context we want <code class=" language-javascript">this</code> to be in our function.</p>
<pre><code>sayName.call(person); //Ryan</code></pre>
<p>Great! Now we have the power to call functions and alter the context in which they are executed on the fly!</p>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can also apply our arguments to a function. For example, lets change the <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> function to accept a parameter.</p>
<pre><code>function sayName(greetings) {
    console.log(greetings +  ' ' + this.name);
}</code></pre>
<p>Normally we could just call this function like <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span></code>. However our function has no property <code class=" language-javascript">name</code>. So we have to use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> to tell this function to use <code class=" language-javascript">person</code> as the <code class=" language-javascript">this</code> in the function, and with <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can tell it what arguments call uses!</p>
<pre><code>sayName.call(person,'Hello'); //Hello Ryan</code></pre>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we are able to specify the context of <code class=" language-javascript">this</code> in our function, as well as the arguments we want to supply to the function. If you have more than one argument, we just add them to the <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span>context<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span>arg3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code>.</p>
<h2 id="apply"><code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code></h2>
<p>The <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> method is similar to <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> however it allows us to pass an array of arguments instead of one at a time. This is very useful. Lets look at a simple, but very common, example. <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code> only takes a list of arguments, but maybe you are provided with an array of arguments.</p>
<pre><code>var numbers = [12,34,62,54,12];</code></pre>
<p>You could, assuming you know that the length of the array will always be the same, do something like this.</p>
<pre><code>Math.max(numbers[0],numbers[1],numbers[2],numbers[3],numbers[4]);</code></pre>
<p>However there are two things wrong with this code. One is that we are <strong>very</strong> dependent on the length of the array always being the same, what if we have one more or one less? Also we are doing a lot of writing here. And that is just no good.</p>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can simplify this a bit more!</p>
<pre><code>Math.max.apply(null,numbers) // 62</code></pre>
<p>Using the same pattern as with <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we specify a context to call <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code> and supply the arguments. In the case of our arguments it is just our array <code class=" language-javascript">numbers</code>. Our context for this will just be <code class=" language-javascript"><span class="token keyword">null</span></code>, since we do no really care about that from <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code>. Internally the JS engine will do something like this.</p>
<pre><code>Math.max(12,34,62,54,12);</code></pre>
<p>Not that exactly, but something like it. Hopefully this gives you an idea of what it is doing!</p>
<p>Lets write our own function that expects an array of arguments. It will be very simple, just to get the point across. </p>
<pre><code>function printNames() {
    for(var i = 0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    }
}</code></pre>
<p>Here is a simple function that prints out a list of names. But WAIT! What is <code class=" language-javascript">arguments</code>?! Just like the <code class=" language-javascript">this</code> keyword every function has a special key word called <code class=" language-javascript">arguments</code>. This is an <strong>array like</strong>(more on this later) list of the arguments used to call this function. For example.</p>
<pre><code>function printArgs() {
    console.log(arguments);
}
printArgs('hey',32,'Neat'); //['hey',32,'Neat']</code></pre>
<p>Notice how in our function definition we never define parameters for our function to accept. The function we wrote earlier, <code class=" language-javascript">printNames</code> uses the same principle. Lets assume you get an array of names, again you do not know what the length will be. Using <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can call this function with this array!</p>
<pre><code>printNames.apply(null,['Ryan','Kristen','Drew']);</code></pre>
<p>This will print out the names! </p>
<h3 id="agruments"><code>agruments</code></h3>
<p>Above I mentioned that <code class=" language-javascript">arguments</code> is an <strong>array like</strong> list, meaning is it not actually an array. What does that mean? Well it means we don't get all the methods you are used to from arrays. Methods like <code class=" language-javascript"><span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>, or <code class=" language-javascript"><span class="token punctuation">.</span>splice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. If you try to call <code class=" language-javascript">arguments<span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code>, you will get <code class=" language-markup">TypeError: arguments.slice is not a function</code>. </p>
<p>However, we have learned how to fix this already! We can use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. These methods from the array live on the <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype</code> so in order for us to use something like slice, we need to use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code>.</p>
<pre><code>function printArgs() {
    var slicedArgs = Array.prototype.slice.call(arguments,1);
    console.log(slicedArgs);
}

printsArgs(['Ryan','Kristen','Drew']) // ['Kristen', 'Drew']</code></pre>
<p>We use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> on <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice</code>, we set <code class=" language-javascript">arguments</code> as the context of the method and provide our argument to use for <code class=" language-javascript"><span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>! Using <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> to manipulate <code class=" language-javascript">arguments</code> is a very common pattern you will see. But let's now look at a different way of doing this!</p>
<h1 id="a-different-way"><a name="user-content-a-different-way" href="#a-different-way" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>A Different way</h1>
<p><code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript">arguments</code> are great, but what if there was a better way to do this? A way that was less verbose? In ECMAScript 2015 (ES6) we get two new features. The Spread Operator and Rest Parameters. Lets look at how we can use these to do something similar to using <code class=" language-javascript"><span class="token punctuation">.</span>apply</code> and <code class=" language-javascript">arguments</code>.</p>
<h2 id="spread-operator"><a name="user-content-spread-operator" href="#spread-operator" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Spread Operator</h2>
<p>The Spread Operator is a new feature that we can use to, well, spread our arguments. The syntax for the Spread Operator is <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arrayName</code>, consider the function below.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print() {
    for(var i = 0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    } 
}

print(...names);</code></pre>
<p>What the Spread Operator is doing, is something similar to <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. </p>
<pre><code>print('Ryan','Drew','Kristen','Wes');</code></pre>
<p>You can actually mix and match the use of the Spread Operator.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print() {
    var nameList = Array.prototype.slice.call(arguments,1);
    for(var i = 0; i &lt; nameList.length; i++) {
        console.log(arguments[0] +  ' ' + nameList[i]);
    } 
}

print('Hello',...names);</code></pre>
<p>In this new addition to the function we use a pattern we saw earlier to store a version <code class=" language-javascript">arguments</code> into a new variable called <code class=" language-javascript">nameList</code>. We also use <code class=" language-javascript">arguments</code> to access the string <code class=" language-javascript">Hello</code> from the function call. This is getting a little out there however, there is a lot going on. We are utilizing what we learned earlier, but this can get better! </p>
<p>Before we move on I just want to point out that the Spread Operator is not a replacement for <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> in all cases, it does not allow us to control the context of a function call, rather it helps us with arrays of values we need to supply to functions.</p>
<h2 id="rest-parameters"><a name="user-content-rest-parameters" href="#rest-parameters" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Rest Parameters</h2>
<p>The flip side of the Spread Operator is Rest Parameters. We can use this as a solution to the array like nature of <code class=" language-javascript">arguments</code>. The syntax looks like this <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args</code>, pretty much exactly like the Spread Operator! The difference here is where you use the syntax. Let's change our function above to work with Rest Parameters.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print(greetings, ...nameList) {
    for(var i = 0; i &lt; nameList.length; i++) {
        console.log(greetings +  ' ' + nameList[i]);
    } 
}

print('Hello',...names);</code></pre>
<p>Here we add the <code class=" language-javascript">greetings</code> parameter as well as this new <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>nameList</code>. We now get access to an actual array in the form on <code class=" language-javascript">nameList</code>. Because of this we can change the <code class=" language-javascript"><span class="token keyword">for</span></code> loop to be an <code class=" language-javascript"><span class="token punctuation">.</span>forEach<span class="token punctuation">(</span><span class="token punctuation">)</span></code> loop, since that is an Array method!</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print(greetings, ...nameList) {
    nameList.forEach(function(name) {
        console.log(greetings +  ' ' + name);
    })
}

print('Hello',...names);</code></pre>
<p>That looks a little nicer!</p>
<p>For more information about these check out <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank">Rest Parameters</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">Spread Operator</a> on MDN. Note that these features are very new and only available in browsers that support ECMASCript 2015. However check out my post on <a href="http://ryanchristiani.com/es6es2015-easy-wins/">ES6 easy wins</a> to find out about some new features and also how you can use them today! (hint, it's <a href="https://babeljs.io" target="_blank">Babel</a>).</p>
<p>Hope that helps!</p>
				</div>
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-06" name="t-06"></a><h1>06 : Understanding JavaScript Constructors</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
<div class="article-content">

                
      
      <p><em class="explanation">The following is a guest post by <a href="http://eloux.com/">Faraz Kelhini</a>. Some of this stuff is out of my comfort zone, so I asked <a href="http://getify.me/">Kyle Simpson</a> to tech check it for me. Kyle's answer (which we did during an <a href="https://css-tricks.com/lodge/office-hours/">Office Hours</a> session) was very interesting. It was: 1) This article is technically sound. JavaScript doesn't really have classes in a traditional sense and this is the way most people shoehorn them in. 2) We may want to stop shoehorning them in. JavaScript has objects and we can use them in the way they are intended to do the same kinds of things. Kyle calls it OLOO (Objects Linked to Other Objects). <a href="http://stackoverflow.com/questions/29788181/kyle-simpsons-oloo-pattern-vs-prototype-design-pattern">Here's an intro.</a> I'd think there is value in learning about both.</em></p>
<p><span id="more-208618"></span></p>
<p>Having a good understanding of constructors is crucial to truly understand the JavaScript language. Unlike many other languages, JavaScript doesn't support classes, but it has constructors to bring similar functionality to JavaScript. In this tutorial, we will explore constructors in detail and see how JavaScript utilizes them to make objects.<br>
Constructors are like regular functions, but we use them with the "new" keyword. There are two types of constructors: native (aka built-in) constructors like <code>Array</code> and <code>Object</code>, which are available automatically in the execution environment at runtime; and custom constructors, which define properties and methods for your own type of object.</p>
<p>A constructor is useful when you want to create multiple similar objects with the same properties and methods. It’s a convention to capitalize the name of constructors to distinguish them from regular functions. Consider the following code:</p>
<pre><code>function Book() { 
  // unfinished code
} 
var myBook = new Book();</code></pre>
<p>The last line of the code creates an instance of Book and assigns it to a variable; even though the Book constructor doesn't do anything, myBook is still an instance of it. As you can see there is no difference between this function and regular functions except that we call it with the <code>new</code> keyword and the function name is capitalized.</p><div class="launchbit-ad-wrapper"><div id="bsa-ad-1" class="launchbit-ad"><a class="launchbit-in-article" href="//srv.buysellads.com/ads/click/x/GTND4237C67I62J7CTSLYKQWF6YI623UCABDPZ3JCEAI4KQUCKSI627KC6BDLKQIC6BDVK3EHJNCLSIZ" target="_blank"><img src="//assets.servedby-buysellads.com/p/manage/asset/id/37874" alt="" class="launchbit-img">See The 3 Use Cases of How Our DevOp Teams Automate Development<img src="https://www.launchbit.com/taz-pixel/11315-6651-111" border="0" height="1" width="1" style="display: none;"></a></div></div>
<h3 id="article-header-id-0" class="has-header-link"><a class="article-headline-link" href="#article-header-id-0">#</a>Determining the Type of an Instance</h3>
<p>To find out whether an object is an instance of another one, we use the instanceof operator:</p>
<pre><code>myBook instanceof Book    // true
myBook instanceof String  // false</code></pre>
<p>Note that if the right side of the instanceof operator isn’t a function, it will throw an error:</p>
<pre><code>myBook instanceof {};
// TypeError: invalid 'instanceof' operand ({})</code></pre>
<p>Another way to find the type of an instance is using the constructor property. All object instances have a constructor property that point to the constructor function that created it.</p>
<p>Consider the following code fragment:</p>
<pre><code>myBook.constructor == Book;   // true</code></pre>
<p>Since the constructor property of myBook points to Book the result is true. All objects inherit a constructor property from their prototype:</p>
<pre><code>var s = new String("text");
s.constructor === String;      // true

"text".constructor === String; // true

var o = new Object();
o.constructor === Object;      // true

var o = {};
o.constructor === Object;      // true

var a = new Array();
a.constructor === Array;       // true

[].constructor === Array;      // true</code></pre>
<p>Although checking constructor property can be used to check the type of an instance, it is recommended to only use the instanceof operator for this purpose, because the constructor property might be overwritten, so it cannot be a reliable method for checking the type of an instance.</p>
<h3 id="article-header-id-1" class="has-header-link"><a class="article-headline-link" href="#article-header-id-1">#</a>Custom Constructor Functions</h3>
<p>A constructor is like a cookie cutter to make more than one object with similar features. In other words, the benefit of using a constructor is that it makes it easy to create multiple objects with the same properties and methods.</p>
<p>Consider the following code:</p>
<pre><code>function Book(name, year) {
  this.name = name;
  this.year = '(' + year + ')';
}</code></pre>
<p>The book constructor expects two parameters: <code>name</code> and <code>year</code>; when it is called with the <code>new</code> keyword it assigns the received parameters to the name and year property of the current instance so the constructor can be used to create objects with initialized <code>name</code> and <code>year</code> properties: </p>
<pre><code>var firstBook = new Book("Pro AngularJS", 2014);
var secondBook = new Book("Secrets Of The JavaScript Ninja", 2013); 
var thirdBook = new Book("JavaScript Patterns", 2010);
 
console.log(firstBook.name, firstBook.year);           
console.log(secondBook.name, secondBook.year);           
console.log(thirdBook.name, thirdBook.year);  </code></pre>
<p>This code logs the following in the console:</p>
<figure id="post-208619" class="align-right media-208619"><img sizes="(min-width: 1850px) calc( (100vw - 555px) / 3 )
       (min-width: 1251px) calc( (100vw - 530px) / 2 )
       (min-width: 1086px) calc(100vw - 480px)
       (min-width: 626px)  calc(100vw - 335px)
                           calc(100vw - 30px)" srcset="https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log.png 744w, https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-300x68.png 300w" src="//cdn.css-tricks.com/wp-content/uploads/2015/09/console-log.png" alt=""></figure>
<p>As you can see, we can quickly build a large number of different book objects by invoking the Book constructor with different arguments. This is exactly the same pattern that JavaScript uses in its built-in constructors like <code>Array()</code> and <code>Date()</code>.</p>
<h3 id="article-header-id-2" class="has-header-link"><a class="article-headline-link" href="#article-header-id-2">#</a>Object.defineProperty Function</h3>
<p>The <code>Object.defineProperty()</code> can be used inside of a constructor to help perform all necessary property setup. Consider the following constructor:</p>
<pre><code>function Book(name) { 
  Object.defineProperty(this, "name", { 
      get: function() { 
        return "Book: " + name;       
      },        
      set: function(newName) {            
        name = newName;        
      },               
      configurable: false     
   }); 
}

var myBook = new Book("Single Page Web Applications");
console.log(myBook.name);    // Book: Single Page Web Applications

// we cannot delete the name property because "configurable" is set to false
delete myBook.name;    
console.log(myBook.name);    // Book: Single Page Web Applications

// but we can change the value of the name property
myBook.name = "Testable JavaScript";
console.log(myBook.name);    // Book: Testable JavaScript</code></pre>
<p>In this code we used accessor properties inside the <code>Object.defineProperty()</code>. Accessor properties don’t include any properties or methods, but they define a getter to call when the property is read, and a setter to call when the property is written to.</p>
<p>A getter is expected to return a value, while a setter receives the value being assigned to the property as an argument. This constructor allows us to set or change the name property of instances, but we are not allowed to delete it, and when we get the value of name, the getter prepends the string "Book: " to the name and returns it.</p>
<h3 id="article-header-id-3" class="has-header-link"><a class="article-headline-link" href="#article-header-id-3">#</a>Object Literal Notations are Preferred to Constructors</h3>
<p>The JavaScript language has nine built-in constructors: <code>Object()</code>, <code>Array()</code>, <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>, <code>Date()</code>, <code>Function()</code>, <code>Error()</code> and <code>RegExp()</code>. When creating values we are free to use either object literals or constructors, but object literals are not only easier to read but also faster to run because they can be optimize at parse time. Whenever we need simple objects it's best to stick with literals:</p>
<pre><code>// a number object
// numbers have a toFixed() method
var obj = new Object(5);
obj.toFixed(2);     // 5.00

// we can achieve the same result using literals
var num = 5;
num.toFixed(2);     // 5.00

// a string object
// strings have a slice() method 
var obj = new String("text");
obj.slice(0,2);     // "te"

// same as above
var string = "text";
string.slice(0,2);  // "te"</code></pre>
<p>As you can see there's hardly any difference between these object literals and constructors and we can still call methods on literals. It's because when we call a method on a literal, behind the scene JavaScript converts the literal to a temporary object so that it's possible to use object methods for primitive values, then JavaScript discards the temporary object. </p>
<h3 id="article-header-id-4" class="has-header-link"><a class="article-headline-link" href="#article-header-id-4">#</a>Using the "new" Keyword is Essential</h3>
<p>It's important to remember to use the <code>new</code> keyword before all constructors, if we accidentally forget "new" we will be modifying the global object instead of the newly created object. Consider the following example:</p>
<pre><code>function Book(name, year) {
  console.log(this);
  this.name = name;
  this.year = year;
}

var myBook = Book("js book", 2014);  
console.log(myBook instanceof Book);  
console.log(window.name, window.year);

var myBook = new Book("js book", 2014);  
console.log(myBook instanceof Book);  
console.log(myBook.name, myBook.year);</code></pre>
<p>When we call the Book constructor without <code>new</code> keyword, in fact we are just calling a function without a return statement and "this" inside the Book constructor will be equal to Window (instead of myBook), in other words we have unintentionally created two global variables which causes the code to produce unintended results, but when we call the function with the "new" keyword the context is switched from global (window) to the instance, therefore "this" points to myBook. Here is what the above code logs in browser console:</p>
<figure id="post-208621" class="align-right media-208621"><img sizes="(min-width: 1850px) calc( (100vw - 555px) / 3 )
       (min-width: 1251px) calc( (100vw - 530px) / 2 )
       (min-width: 1086px) calc(100vw - 480px)
       (min-width: 626px)  calc(100vw - 335px)
                           calc(100vw - 30px)" srcset="https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2.png 766w, https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2-300x91.png 300w" src="//cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2.png" alt=""></figure>
<p>Note that in strict mode this code throws an error because strict mode protects us from accidentally calling a constructor without the <code>new</code> keyword.</p>
<h3 id="article-header-id-5" class="has-header-link"><a class="article-headline-link" href="#article-header-id-5">#</a>Scope-Safe Constructors</h3>
<p>Since a constructor is just a function, it can be called without the <code>new</code> keyword, but this leads to unexpected results and errors especially for inexperienced programmers. The solution to this problem is scope-safe constructors.  We can call Scope-safe constructors with or without new keyword and they return the same result in either form.</p>
<p>Most of built-in constructors, such as Object, Regex and Array, are scope-safe. They use a pattern to determine whether the constructor is called with <code>new</code> or not.</p>
<p>If new isn't used, a proper instance of the object is created by calling the constructor again with <code>new</code> keyword. Consider the following code:</p>
<pre><code>function Book(name) { 
  if (!(this instanceof Book)) { 
    
    // the constructor was called without "new".
    return new Book(name);
  } 
}</code></pre>
<p>So using this pattern we can easily rewrite a scope-safe version of our constructor:</p>
<pre><code>function Book(name, year) { 
  if (!(this instanceof Book)) { 
    return new Book(name, year);
  }
  this.name = name;
  this.year = year;
}

var person1 = new Book("js book", 2014);
var person2 = Book("js book", 2014);
console.log(person1 instanceof Book);    // true
console.log(person2 instanceof Book);    // true</code></pre>
<p>The fact that "this" is an instance of the custom type allows us to determine if <code>new</code> is not used as soon as the constructor begins to execute and run the constructor again with <code>new</code> keyword.</p>
<h3 id="article-header-id-6" class="has-header-link"><a class="article-headline-link" href="#article-header-id-6">#</a>Conclusion</h3>
<p>JavaScript has no class statement, which is baffling for coders who are used to languages with a class statement; However, JavaScript has constructors to bring similar functionality. Constructors are just regular functions which are used with <code>new</code> keyword. They come in handy when we need to make multiple similar objects with the same properties and methods.</p>
     
    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-07" name="t-07"></a><h1>07 : Functions as First Class Citizens in Javascript</h1>
					<span class="ref-site">http://ryanchristiani.com/functions-as-first-class-citizens-in-javascript/</span>
					<div class="tutorial__content">
<div class="entry">
					<p>In Javascript we are lucky. We get the ability to pass functions around, our functions can even return functions. And this is great. As a teacher, one thing I find is that this idea confuses people learning the language. Functions are a bit of an abstract concept. So I wanted to go over a few things we can do with functions in regards to passing them around and playing with them! </p>
<p>This is focused for people just learning the language. Yet if you have been writing JS for a while, you might learn a thing of two as well!</p>
<p><span id="more-855"></span></p>
<h2 id="first-class-citizens"><a name="user-content-first-class-citizens" href="#first-class-citizens" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>First Class Citizens?!</h2>
<p>In programming languages, when you are able to pass, return and assign a type, that type is considered to be a first class citizen <cite><a href="https://en.wikipedia.org/wiki/First-class_citizen" target="_blank">[source]</a></cite>. This is one reason Javascript is becoming a popular destination for functional programming. Since we are able to create functions that can accept functions as well as return functions. This allows us to create Higher Order Functions. Higher Order Functions are functions that accept a function, and/or return a function <cite><a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank">[source]</a></cite>.</p>
<p>Types inside of Javascript are first class citizens, we are able to assign, pass and return all the different types in JS.</p>
<h2 id="assigning-functions"><a name="user-content-assigning-functions" href="#assigning-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Assigning functions.</h2>
<p>In Javascript we can assign a function to a variable in many ways.</p>
<h3 id="using-var"><a name="user-content-using-var" href="#using-var" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Using var</h3>
<pre><code>var myFunction = function() {
    //...function body here 
};</code></pre>
<p>A common pattern is to define a function using the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword to store a function in a variable. We use an anonymous function here, but you could also use a named function if you desired.</p>
<pre><code>var myFunction = function functionName() {
    //...function body here 
};</code></pre>
<p>This will give you a reference to the function inside of the function, useful for recursion. It allows you to call the function inside of itself!</p>
<pre><code>var myFunction = function functionName(n) {
    if(n &lt; 10)   {
        n++;
        ...some code
        functionName(n);
    }
};</code></pre>
<h3 id="methods"><a name="user-content-methods" href="#methods" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Methods</h3>
<p>Assigning a method in Javascript is super easy as well. Similar to how we can assign a function to a variable we can assign a function as a value to a key in an object.</p>
<pre><code>var warrior = {
    hp: 100,
    strength: 20,
    attack: function(target) {
        target.hp -= this.strength;
    }
}</code></pre>
<p>One thing to remember here is that when we create a function like:</p>
<pre><code>var add = function(a,b) {
    return a + b;
}</code></pre>
<p>The value stored inside the <code class=" language-javascript">add</code> variable is a function, so we can pass that value around without calling the function.</p>
<pre><code>var newAdd = add;
newAdd(2,3) //5</code></pre>
<h2 id="passing-functions"><a name="user-content-passing-functions" href="#passing-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Passing functions.</h2>
<p>Since functions are first class citizens in Javascript, we are able to pass them. A common use case as a beginner might be something like this. Lets assume we have some sort of analytics we need to preform on various types of events.</p>
<p>You could do something like this.</p>
<pre><code>$('form').on('submit',function() {
    //perform some analytics.
});

$('a[href$=".pdf"]').on('click', function() {
    //perform same analytics.
});</code></pre>
<p>There is a bit of repetition here, and we want to prevent that as much as possible. With the ability to pass functions, we can reduce repetition, and pass one function to be run when the user interacts with those elements.</p>
<pre><code>function analyticsHandler(e) {
    ...//perform some analytics.
}

$('form').on('submit',analyticsHandler);

$('a[href$=".pdf"]').on('click',analyticsHandler);</code></pre>
<p>This way, jQuery will just see the function as a value and call it when the event is fired. Which, if you think about it, is all you are doing when you provide a callback function.</p>
<pre><code>$('a').on('click', function() {
    //...
});</code></pre>
<p>Internally jQuery will call the callback function when it sees that the <code class="language-html">&lt;a&gt;</code> tag is clicked. In our <code class=" language-javascript">analyticsHandler</code> example, we are simply storing the function in an easy to use variable for later use. And it is helping us keep things DRY.</p>
<h2 id="returning-functions"><a name="user-content-returning-functions" href="#returning-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Returning functions.</h2>
<p>Something else we will look at is returning functions from functions. This can be a powerful concept if you master it, and this is a key concept when it comes to functional programming. </p>
<p>Consider the process of writing a gulp file. We use the <code class="langauge-javascript">require</code> statement from Node.js to get scripts into our file. </p>
<pre><code>var cssNext = require('gulp-cssnext');</code></pre>
<p>When you write module in Node you are able to return multiple things, however it is fairly common to simply return a function. That is why when you require something, especially a gulp plug in, you have to able to call that function later, the value returned from the <code class=" language-javascript">require</code> call is a function.</p>
<p>Here is an example from the <a href="https://github.com/cssnext/gulp-cssnext">gulp-cssnext</a> plug-in.</p>
<pre><code>module.exports = function(options) {
  return through.obj(transform(options))
}</code></pre>
<p>
This is a line from <a href="https://github.com/cssnext/gulp-cssnext/blob/master/index.js#L39-L41">index.js</a> in gulp-cssnext. They use <code class="langauge-javascript">module.exports</code> to return a function, which itself returns the results of a function call. This way we can use the returned function in our gulp files like this.</p>
<pre><code>gulp.task('css',function() {
    gulp.src('*.css')
        .pipe(cssnext())
        .pipe(dist.);
});</code></pre>
<p>A common pattern you will see when working with a Node app, especially an <a href="http://expressjs.com/">express</a> app is a line similar to this.</p>
<pre><code>var app = require('express')();</code></pre>
<p>In express you need to require it and then execute the function to create your express application. It is very common to shorten this process down to one line.</p>
<p>Another place you will see this is when using postcss. In postcss you require all of your packs in the postcss module, like this:</p>
<pre><code>postcss([ require('cssnext')(), require('cssnano')() ])</code></pre>
<p>Note the cssnext referred to here is not the gulp-cssnext plugin, but to original <a href="http://cssnext.io/" target="_blank">cssnext</a> package. In this implementation the cssnext package returns a function, that when run, sets itself up to work with postcss.</p>
<h3 id="partial-application"><a name="user-content-partial-application" href="#partial-application" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Partial application</h3>
<p>Another common use for returning a function, is for partial application. Partial application is used to set up a function that returns a function. Calling the first function saves the first argument or arguments that were passed in. What?! Let’s look at a simple example.</p>
<p>Example:</p>
<pre><code>function add(a) {
    return function(b) {
        return a + b;
    }   
}</code></pre>
<p>This function takes an <code class=" language-javascript">a</code> parameter and returns a function that will then take the second parameter <code class=" language-javascript">b</code>. The <code class=" language-javascript">a</code> is remembered inside of the second function because of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank">closure</a> that the returned function created. Lets look at an example of how to use it.</p>
<pre><code>var add5 = add(5);</code></pre>
<p>The value now saved in <code>add5</code> is the function. Inside of that function it references <code class=" language-javascript">a</code> and it remembers that because when it was created, <code class=" language-javascript">a</code> was available to it.</p>
<pre><code>function(b) {
    return a + b;
}</code></pre>
<p>What way we can go ahead and call it with new values that will always add 5 to the new value.</p>
<pre><code>add5(5); // 10
add5(8); // 13</code></pre>
<p>For a more in depth article on partial application and currying check out this article by <a href="http://www.datchley.name/currying-vs-partial-application/" target="_blank">Dave Atchley</a> and this one by <a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8" target="_blank">Eric Elliott</a>.</p>
<p>Javascript is a powerful fun language to learn and work with, and with functions as first class citizens we are very lucky! I hope this helped with your understanding of functions, learning a language like Javascript can be draughting to a beginner, but with practice you can start to chip away at it! </p>
				</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-08" name="t-08"></a><h1>08 : Quick Tip: How JavaScript References Work</h1>
					<span class="ref-site">https://www.sitepoint.com/how-javascript-references-work/</span>
					<div class="tutorial__content">
<div class="ArticleCopy language-javascript">
      

<p><strong>TL;DR:</strong> There are NO pointers in JavaScript and references work differently from what we would normally see in most other popular programming languages. In JavaScript, it’s just NOT possible to have a reference from one variable to another variable. And, only compound values (e.g.. Object or Array) can be assigned by reference.</p>

<blockquote>
<p>The following terms are used throughout the article:</p>
<ul>
<li>scalar –  a singe value or unit of data (e.g. integer, boolean, string)</li>
<li>compound – comprised of multiple values (e.g. array, object, set)</li>
<li>primitive – a direct value, as opposed to a reference to something that contains the real value. </li>
</ul>
<p>JavaScript’s scalar types are primitives, but some languages, such as Ruby, have scalar reference types. Note that in JavaScript, the scalar primitive values are immutable while compound values are mutable.</p>
</blockquote>
<h2 id="bottomline">Bottom Line:</h2>
<ol>
<li>The <code class=" language-javascript"><span class="token keyword">typeof</span></code> value assigned to a variable decides whether the value is stored with assign-by-value or assign-by-reference.</li>
<li>On variable assignment, the scalar primitive values (Number, String, Boolean, undefined, null, Symbol) are assigned-by-value and compound values are assigned-by-reference.</li>
<li>The references in JavaScript only point at contained values and NOT at other variables, or references.</li>
<li>In JavaScript, scalar primitive values  are immutable and compound values are mutable.</li>
</ol>
<h2 id="quickexampleofassignbyvalue">Quick Example of Assign-by-Value:</h2>
<p>In the code snippet below, we are assigning a scalar primitive value (a number) to a variable and thus assign-by-value applies here. Firstly, the variable <code class=" language-javascript">batman</code> is initialized and when the variable <code class=" language-javascript">superman</code> is assigned with the value stored in <code class=" language-javascript">batman</code>, it creates a new copy of the value and stores it. When the variable <code class=" language-javascript">superman</code> is modified, <code class=" language-javascript">batman</code> is left unaffected, as they point to distinct values.</p>
<pre><code>var batman = 7;
var superman = batman;   //assign-by-value
superman++;
console.log(batman);     //7
console.log(superman);   //8
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365230diagram1.png" alt="Assign-by-value example"></p>
<h2 id="quickexampleofassignbyreference">Quick Example of Assign-by-Reference:</h2>
<p>In the code snippet below, we are assigning a compound value (an array) to a variable and thus assign-by-reference applies here. The variables <code class=" language-javascript">flash</code> and <code class=" language-javascript">quicksilver</code> are references to the same value (aka shared value). The references will point to the updated value when the shared value is modified .</p>
<pre><code>var flash = [8,8,8];
var quicksilver = flash;   //assign-by-reference
quicksilver.push(0);
console.log(flash);        //[8,8,8,0]
console.log(quicksilver);  //[8,8,8,0]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365235diagram2.png" alt="Assign-by-reference example"></p>
<h2 id="howtocreateanewreference">How to Create a New Reference</h2>
<p>When the compound value in a variable is reassigned, a new reference is created. In JavaScript, unlike in most other popular programming languages, the references are pointers to values stored in variables and NOT pointers to other variables, or references.</p>
<pre><code>var firestorm = [3,6,3];
var atom = firestorm;   //assign-by-reference
console.log(firestorm); //[3,6,3]
console.log(atom);      //[3,6,3]
atom = [9,0,9];         //value is reassigned (create new reference)
console.log(firestorm); //[3,6,3]
console.log(atom);      //[9,0,9]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365240diagram3.png" alt="Creating a new reference"></p>
<h2 id="howreferencesworkwhenvaluesarepassedasfunctionparameters">How References Work When Values Are Passed as Function Parameters</h2>
<p>In the code snippet below, the variable <code class=" language-javascript">magneto</code> is a compound value (an Array), thus it is assigned to variable (function argument) <code class=" language-javascript">x</code> as a reference. </p>
<p>The <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push</code> method invoked inside the IIFE mutates the value in the variable <code class=" language-javascript">magneto</code> via a JavaScript reference. But, the reassignment of variable <code class=" language-javascript">x</code> creates a new reference and further modifications to it do NOT affect the reference to the variable <code class=" language-javascript">magneto</code>.</p>
<pre><code>var magneto = [8,4,8];
(function(x) {        //IIFE
    x.push(99);
    console.log(x);   //[8,4,8,99]
    x = [1,4,1];      //reassign variable (create new reference)
    x.push(88);
    console.log(x);   //[1,4,1,88]
})(magneto);
console.log(magneto); //[8,4,8,99]
</code></pre>
<h2 id="howtochangetheoriginalvalueinacompoundvariablepassedasafunctionargumentviaajavascriptreference">How to Change the Original Value in a Compound Variable, Passed as a Function Argument via a JavaScript Reference</h2>
<p>The solution here would be to modify the existing compound value that the reference is pointing to. In the code snippet below, variable <code class=" language-javascript">wolverine</code> is a compound value (an Array) and, on IIFE invocation, the variable (function argument) <code class=" language-javascript">x</code> is assigned by reference. </p>
<p>The <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>length</code> property can be used to create an empty array by setting its value to <code class=" language-javascript"><span class="token number">0</span></code>. Thus, the variable wolverine is changed to the new value set in variable <code class=" language-javascript">x</code> via a JavaScript reference.</p>
<pre><code>var wolverine = [8,7,8];
(function(x) {              //IIFE
    x.length = 0;           //make empty array object
    x.push(1,4,7,2);
    console.log(x);         //[1,4,7,2]
})(wolverine);
console.log(wolverine);     //[1,4,7,2]
</code></pre>
<h2 id="howtostoreacompoundvaluethroughassignbyvalue">How to Store a Compound Value through Assign-by-Value</h2>
<p>The solution here would be to make a manual copy of the compound value and then assign the copied value to a variable. Therefore, the reference of assigned value does NOT point back to the original value. </p>
<p>The recommended approach to create a (shallow) copy of the compound value (Array object) is to invoke <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice</code> method on it with no arguments passed.</p>
<pre><code>var cisco = [7,4,7];
var zoom = cisco.slice();  //create shallow copy
cisco.push(77,33);
console.log(zoom);         //[7,4,7]
console.log(cisco);        //[7,4,7,77,33]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365242diagram4.png" alt="Diagram4"></p>
<h2 id="howtostoreascalarprimitivevaluethroughassignbyreference">How to Store a Scalar Primitive Value Through Assign-by-Reference?</h2>
<p>The solution here would be to wrap scalar primitive value in a compound value (i.e. an Object or Array) as its property value. Thus, it can be assigned-by-reference. In the code snippet below, scalar primitive value in variable <code class=" language-javascript">speed</code> is set as a property on object <code class=" language-javascript">flash</code>. Therefore, it is assigned-by-reference on IIFE invocation to variable (function argument) <code class=" language-javascript">x</code>.</p>
<pre><code>var flash = { speed: 88 };
(function (x) {             //IIFE
    x.speed = 55;
})(flash);
console.log(flash.speed);   //55
</code></pre>
<h2 id="summary">Summary</h2>

<p>A good understanding of references in JavaScript can help developers to avoid many common mistakes and write better code.</p>

    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article style="display:none;">
					<a id="t-10" name="t-10"></a><h1>10 : Index</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
						
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
			</section>
			
		</main>
	
			</body></html>