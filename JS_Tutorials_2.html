<html>
	<head>
		<title>JS Tutorials :: Part 2</title>
		<style>
			@font-face {
			font-family: 'pt_sansregular';
			src: url('fonts/PTS55F-webfont.eot');
			src: url('fonts/PTS55F-webfont.eot?#iefix') format('embedded-opentype'),
			url('fonts/PTS55F-webfont.woff') format('woff'),
			url('fonts/PTS55F-webfont.ttf') format('truetype'),
			url('fonts/PTS55F-webfont.svg#pt_sansregular') format('svg');
			font-weight: normal;
			font-style: normal;
			}
			body { font-family: 'pt_sansregular', Arial, Tahoma, Helvetica, FreeSans, sans-serif; line-height: 1.7; font-size: 14px; }
			pre {
			border: 1px dashed #888;
			padding: 15px;
			word-break: normal;
			word-break: break-all;
			word-wrap: break-word;
			font-size: 13px;
			line-height: 1.42857143;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
			position: relative;
			}
			pre:after {
			content: "CODE";
			position: absolute;
			right: 0;
			top: 0;
			padding: 5px 10px;
			border-left: 1px dashed #888;
			border-bottom: 1px dashed #888;
			}
			h1{ border-top: 1px solid #666; border-bottom: 2px solid #888; padding: 10px 0; font-size: 20px; text-align: center; }
			h2, h3 { font-size: 16px; border-left: 6px solid #666; padding: 5px 15px; }
			code, kbd, pre, samp {
			font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
			}
			code {
			padding: 2px 4px;
			font-size: 90%;
			background-color: #f9f2f4;
			border-radius: 4px;
			}
			blockquote {
			letter-spacing: .01rem;
			font-weight: 400;
			font-style: italic;
			border-left: 3px solid rgba(0,0,0,0.8);
			padding-left: 20px;
			margin-left: -0;
			margin-bottom: 30px;
			padding-bottom: 3px;
			}
			@media print {
			img {
			display: block;
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			pre, code, pre code, pre span, code span, pre code span {
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			}
		</style>
	</head>
	<body>
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-up--going" class="anchor" href="#you-dont-know-js-up--going" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Up &amp; Going</h1>

<h1><a id="user-content-chapter-2-into-javascript" class="anchor" href="#chapter-2-into-javascript" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: Into JavaScript</h1>

<p>In the previous chapter, I introduced the basic building blocks of programming, such as variables, loops, conditionals, and functions. Of course, all the code shown has been in JavaScript. But in this chapter, we want to focus specifically on things you need to know about JavaScript to get up and going as a JS developer.</p>

<p>We will introduce quite a few concepts in this chapter that will not be fully explored until subsequent <em>YDKJS</em> books. You can think of this chapter as an overview of the topics covered in detail throughout the rest of this series.</p>

<p>Especially if you're new to JavaScript, you should expect to spend quite a bit of time reviewing the concepts and code examples here multiple times. Any good foundation is laid brick by brick, so don't expect that you'll immediately understand it all the first pass through.</p>

<p>Your journey to deeply learn JavaScript starts here.</p>

<p><strong>Note:</strong> As I said in Chapter 1, you should definitely try all this code yourself as you read and work through this chapter. Be aware that some of the code here assumes capabilities introduced in the newest version of JavaScript at the time of this writing (commonly referred to as "ES6" for the 6th edition of ECMAScript -- the official name of the JS specification). If you happen to be using an older, pre-ES6 browser, the code may not work. A recent update of a modern browser (like Chrome, Firefox, or IE) should be used.</p>

<h2><a id="user-content-values--types" class="anchor" href="#values--types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Values &amp; Types</h2>

<p>As we asserted in Chapter 1, JavaScript has typed values, not typed variables. The following built-in types are available:</p>

<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code> and <code>undefined</code></li>
<li><code>object</code></li>
<li><code>symbol</code> (new to ES6)</li>
</ul>

<p>JavaScript provides a <code>typeof</code> operator that can examine a value and tell you what type it is:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "undefined"</span>

a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "string"</span>

a <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "number"</span>

a <span class="pl-k">=</span> <span class="pl-c1">true</span>;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "boolean"</span>

a <span class="pl-k">=</span> <span class="pl-c1">null</span>;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "object" -- weird, bug</span>

a <span class="pl-k">=</span> <span class="pl-c1">undefined</span>;
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "undefined"</span>

a <span class="pl-k">=</span> { b<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> };
<span class="pl-k">typeof</span> a;               <span class="pl-c">// "object"</span></pre></div>

<p>The return value from the <code>typeof</code> operator is always one of six (seven as of ES6!) string values. That is, <code>typeof "abc"</code> returns <code>"string"</code>, not <code>string</code>.</p>

<p>Notice how in this snippet the <code>a</code> variable holds every different type of value, and that despite appearances, <code>typeof a</code> is not asking for the "type of <code>a</code>", but rather for the "type of the value currently in <code>a</code>." Only values have types in JavaScript; variables are just simple containers for those values.</p>

<p><code>typeof null</code> is an interesting case, because it errantly returns <code>"object"</code>, when you'd expect it to return <code>"null"</code>.</p>

<p><strong>Warning:</strong> This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!</p>

<p>Also, note <code>a = undefined</code>. We're explicitly setting <code>a</code> to the <code>undefined</code> value, but that is behaviorally no different from a variable that has no value set yet, like with the <code>var a;</code> line at the top of the snippet. A variable can get to this "undefined" value state in several different ways, including functions that return no values and usage of the <code>void</code> operator.</p>

<h3><a id="user-content-objects" class="anchor" href="#objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objects</h3>

<p>The <code>object</code> type refers to a compound value where you can set properties (named locations) that each hold their own values of any type. This is perhaps one of the most useful value types in all of JavaScript.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    b<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    c<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

obj.a;      <span class="pl-c">// "hello world"</span>
obj.b;      <span class="pl-c">// 42</span>
obj.c;      <span class="pl-c">// true</span>

obj[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>];   <span class="pl-c">// "hello world"</span>
obj[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>];   <span class="pl-c">// 42</span>
obj[<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>];   <span class="pl-c">// true</span></pre></div>

<p>It may be helpful to think of this <code>obj</code> value visually:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig4.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig4.png" style="max-width:100%;"></a></p>

<p>Properties can either be accessed with <em>dot notation</em> (i.e., <code>obj.a</code>) or <em>bracket notation</em> (i.e., <code>obj["a"]</code>). Dot notation is shorter and generally easier to read, and is thus preferred when possible.</p>

<p>Bracket notation is useful if you have a property name that has special characters in it, like <code>obj["hello world!"]</code> -- such properties are often referred to as <em>keys</em> when accessed via bracket notation. The <code>[ ]</code> notation requires either a variable (explained next) or a <code>string</code> <em>literal</em> (which needs to be wrapped in <code>" .. "</code> or <code>' .. '</code>).</p>

<p>Of course, bracket notation is also useful if you want to access a property/key but the name is stored in another variable, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    b<span class="pl-k">:</span> <span class="pl-c1">42</span>
};

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>;

obj[b];         <span class="pl-c">// "hello world"</span>
obj[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>];       <span class="pl-c">// 42</span></pre></div>

<p><strong>Note:</strong> For more information on JavaScript <code>object</code>s, see the <em>this &amp; Object Prototypes</em> title of this series, specifically Chapter 3.</p>

<p>There are a couple of other value types that you will commonly interact with in JavaScript programs: <em>array</em> and <em>function</em>. But rather than being proper built-in types, these should be thought of more like subtypes -- specialized versions of the <code>object</code> type.</p>

<h4><a id="user-content-arrays" class="anchor" href="#arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arrays</h4>

<p>An array is an <code>object</code> that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [
    <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    <span class="pl-c1">42</span>,
    <span class="pl-c1">true</span>
];

arr[<span class="pl-c1">0</span>];         <span class="pl-c">// "hello world"</span>
arr[<span class="pl-c1">1</span>];         <span class="pl-c">// 42</span>
arr[<span class="pl-c1">2</span>];         <span class="pl-c">// true</span>
arr.<span class="pl-c1">length</span>;     <span class="pl-c">// 3</span>

<span class="pl-k">typeof</span> arr;     <span class="pl-c">// "object"</span></pre></div>

<p><strong>Note:</strong> Languages that start counting at zero, like JS does, use <code>0</code> as the index of the first element in the array.</p>

<p>It may be helpful to think of <code>arr</code> visually:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig5.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig5.png" style="max-width:100%;"></a></p>

<p>Because arrays are special objects (as <code>typeof</code> implies), they can also have properties, including the automatically updated <code>length</code> property.</p>

<p>You theoretically could use an array as a normal object with your own named properties, or you could use an <code>object</code> but only give it numeric properties (<code>0</code>, <code>1</code>, etc.) similar to an array. However, this would generally be considered improper usage of the respective types.</p>

<p>The best and most natural approach is to use arrays for numerically positioned values and use <code>object</code>s for named properties.</p>

<h4><a id="user-content-functions" class="anchor" href="#functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions</h4>

<p>The other <code>object</code> subtype you'll use all over your JS programs is a function:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">return</span> <span class="pl-c1">42</span>;
}

foo.bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

<span class="pl-k">typeof</span> foo;         <span class="pl-c">// "function"</span>
<span class="pl-k">typeof</span> foo();       <span class="pl-c">// "number"</span>
<span class="pl-k">typeof</span> foo.bar;     <span class="pl-c">// "string"</span></pre></div>

<p>Again, functions are a subtype of <code>objects</code> -- <code>typeof</code> returns <code>"function"</code>, which implies that a <code>function</code> is a main type -- and can thus have properties, but you typically will only use function object properties (like <code>foo.bar</code>) in limited cases.</p>

<p><strong>Note:</strong> For more information on JS values and their types, see the first two chapters of the <em>Types &amp; Grammar</em> title of this series.</p>

<h3><a id="user-content-built-in-type-methods" class="anchor" href="#built-in-type-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Built-In Type Methods</h3>

<p>The built-in types and subtypes we've just discussed have behaviors exposed as properties and methods that are quite powerful and useful.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">3.14159</span>;

a.<span class="pl-c1">length</span>;               <span class="pl-c">// 11</span>
a.<span class="pl-c1">toUpperCase</span>();        <span class="pl-c">// "HELLO WORLD"</span>
b.toFixed(<span class="pl-c1">4</span>);           <span class="pl-c">// "3.1416"</span></pre></div>

<p>The "how" behind being able to call <code>a.toUpperCase()</code> is more complicated than just that method existing on the value.</p>

<p>Briefly, there is a <code>String</code> (capital <code>S</code>) object wrapper form, typically called a "native," that pairs with the primitive <code>string</code> type; it's this object wrapper that defines the <code>toUpperCase()</code> method on its prototype.</p>

<p>When you use a primitive value like <code>"hello world"</code> as an <code>object</code> by referencing a property or method (e.g., <code>a.toUpperCase()</code> in the previous snippet), JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers).</p>

<p>A <code>string</code> value can be wrapped by a <code>String</code> object, a <code>number</code> can be wrapped by a <code>Number</code> object, and a <code>boolean</code> can be wrapped by a <code>Boolean</code> object. For the most part, you don't need to worry about or directly use these object wrapper forms of the values -- prefer the primitive value forms in practically all cases and JavaScript will take care of the rest for you.</p>

<p><strong>Note:</strong> For more information on JS natives and "boxing," see Chapter 3 of the <em>Types &amp; Grammar</em> title of this series. To better understand the prototype of an object, see Chapter 5 of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<h3><a id="user-content-comparing-values" class="anchor" href="#comparing-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparing Values</h3>

<p>There are two main types of value comparison that you will need to make in your JS programs: <em>equality</em> and <em>inequality</em>. The result of any comparison is a strictly <code>boolean</code> value (<code>true</code> or <code>false</code>), regardless of what value types are compared.</p>

<h4><a id="user-content-coercion" class="anchor" href="#coercion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coercion</h4>

<p>We talked briefly about coercion in Chapter 1, but let's revisit it here.</p>

<p>Coercion comes in two forms in JavaScript: <em>explicit</em> and <em>implicit</em>. Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.</p>

<p>You've probably heard sentiments like "coercion is evil" drawn from the fact that there are clearly places where coercion can produce some surprising results. Perhaps nothing evokes frustration from developers more than when the language surprises them.</p>

<p>Coercion is not evil, nor does it have to be surprising. In fact, the majority of cases you can construct with type coercion are quite sensible and understandable, and can even be used to <em>improve</em> the readability of your code. But we won't go much further into that debate -- Chapter 4 of the <em>Types &amp; Grammar</em> title of this series covers all sides.</p>

<p>Here's an example of <em>explicit</em> coercion:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Number</span>( a );

a;              <span class="pl-c">// "42"</span>
b;              <span class="pl-c">// 42 -- the number!</span></pre></div>

<p>And here's an example of <em>implicit</em> coercion:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">1</span>;  <span class="pl-c">// "42" implicitly coerced to 42 here</span>

a;              <span class="pl-c">// "42"</span>
b;              <span class="pl-c">// 42 -- the number!</span></pre></div>

<h4><a id="user-content-truthy--falsy" class="anchor" href="#truthy--falsy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Truthy &amp; Falsy</h4>

<p>In Chapter 1, we briefly mentioned the "truthy" and "falsy" nature of values: when a non-<code>boolean</code> value is coerced to a <code>boolean</code>, does it become <code>true</code> or <code>false</code>, respectively?</p>

<p>The specific list of "falsy" values in JavaScript is as follows:</p>

<ul>
<li><code>""</code> (empty string)</li>
<li><code>0</code>, <code>-0</code>, <code>NaN</code> (invalid <code>number</code>)</li>
<li><code>null</code>, <code>undefined</code></li>
<li><code>false</code></li>
</ul>

<p>Any value that's not on this "falsy" list is "truthy." Here are some examples of those:</p>

<ul>
<li><code>"hello"</code></li>
<li><code>42</code></li>
<li><code>true</code></li>
<li><code>[ ]</code>, <code>[ 1, "2", 3 ]</code> (arrays)</li>
<li><code>{ }</code>, <code>{ a: 42 }</code> (objects)</li>
<li><code>function foo() { .. }</code> (functions)</li>
</ul>

<p>It's important to remember that a non-<code>boolean</code> value only follows this "truthy"/"falsy" coercion if it's actually coerced to a <code>boolean</code>. It's not all that difficult to confuse yourself with a situation that seems like it's coercing a value to a <code>boolean</code> when it's not.</p>

<h4><a id="user-content-equality" class="anchor" href="#equality" aria-hidden="true"><span class="octicon octicon-link"></span></a>Equality</h4>

<p>There are four equality operators: <code>==</code>, <code>===</code>, <code>!=</code>, and <code>!==</code>. The <code>!</code> forms are of course the symmetric "not equal" versions of their counterparts; <em>non-equality</em> should not be confused with <em>inequality</em>.</p>

<p>The difference between <code>==</code> and <code>===</code> is usually characterized that <code>==</code> checks for value equality and <code>===</code> checks for both value and type equality. However, this is inaccurate. The proper way to characterize them is that <code>==</code> checks for value equality with coercion allowed, and <code>===</code> checks for value equality without allowing coercion; <code>===</code> is often called "strict equality" for this reason.</p>

<p>Consider the implicit coercion that's allowed by the <code>==</code> loose-equality comparison and not allowed with the <code>===</code> strict-equality:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">42</span>;

a <span class="pl-k">==</span> b;         <span class="pl-c">// true</span>
a <span class="pl-k">===</span> b;        <span class="pl-c">// false</span></pre></div>

<p>In the <code>a == b</code> comparison, JS notices that the types do not match, so it goes through an ordered series of steps to coerce one or both values to a different type until the types match, where then a simple value equality can be checked.</p>

<p>If you think about it, there's two possible ways <code>a == b</code> could give <code>true</code> via coercion. Either the comparison could end up as <code>42 == 42</code> or it could be <code>"42" == "42"</code>. So which is it?</p>

<p>The answer: <code>"42"</code> becomes <code>42</code>, to make the comparison <code>42 == 42</code>. In such a simple example, it doesn't really seem to matter which way that process goes, as the end result is the same. There are more complex cases where it matters not just what the end result of the comparison is, but <em>how</em> you get there.</p>

<p>The <code>a === b</code> produces <code>false</code>, because the coercion is not allowed, so the simple value comparison obviously fails. Many developers feel that <code>===</code> is more predictable, so they advocate always using that form and staying away from <code>==</code>. I think this view is very shortsighted. I believe <code>==</code> is a powerful tool that helps your program, <em>if you take the time to learn how it works.</em></p>

<p>We're not going to cover all the nitty-gritty details of how the coercion in <code>==</code> comparisons works here. Much of it is pretty sensible, but there are some important corner cases to be careful of. You can read section 11.9.3 of the ES5 specification (<a href="http://www.ecma-international.org/ecma-262/5.1/">http://www.ecma-international.org/ecma-262/5.1/</a>) to see the exact rules, and you'll be surprised at just how straightforward this mechanism is, compared to all the negative hype surrounding it.</p>

<p>To boil down a whole lot of details to a few simple takeaways, and help you know whether to use <code>==</code> or <code>===</code> in various situations, here are my simple rules:</p>

<ul>
<li>If either value (aka side) in a comparison could be the <code>true</code> or <code>false</code> value, avoid <code>==</code> and use <code>===</code>.</li>
<li>If either value in a comparison could be of these specific values (<code>0</code>, <code>""</code>, or <code>[]</code> -- empty array), avoid <code>==</code> and use <code>===</code>.</li>
<li>In <em>all</em> other cases, you're safe to use <code>==</code>. Not only is it safe, but in many cases it simplifies your code in a way that improves readability.</li>
</ul>

<p>What these rules boil down to is requiring you to think critically about your code and about what kinds of values can come through variables that get compared for equality. If you can be certain about the values, and <code>==</code> is safe, use it! If you can't be certain about the values, use <code>===</code>. It's that simple.</p>

<p>The <code>!=</code> non-equality form pairs with <code>==</code>, and the <code>!==</code> form pairs with <code>===</code>. All the rules and observations we just discussed hold symmetrically for these non-equality comparisons.</p>

<p>You should take special note of the <code>==</code> and <code>===</code> comparison rules if you're comparing two non-primitive values, like <code>object</code>s (including <code>function</code> and <code>array</code>). Because those values are actually held by reference, both <code>==</code> and <code>===</code> comparisons will simply check whether the references match, not anything about the underlying values.</p>

<p>For example, <code>array</code>s are by default coerced to <code>string</code>s by simply joining all the values with commas (<code>,</code>) in between. You might think that two <code>array</code>s with the same contents would be <code>==</code> equal, but they're not:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
<span class="pl-k">var</span> b <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1,2,3<span class="pl-pds">"</span></span>;

a <span class="pl-k">==</span> c;     <span class="pl-c">// true</span>
b <span class="pl-k">==</span> c;     <span class="pl-c">// true</span>
a <span class="pl-k">==</span> b;     <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> For more information about the <code>==</code> equality comparison rules, see the ES5 specification (section 11.9.3) and also consult Chapter 4 of the <em>Types &amp; Grammar</em> title of this series; see Chapter 2 for more information about values versus references.</p>

<h4><a id="user-content-inequality" class="anchor" href="#inequality" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inequality</h4>

<p>The <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators are used for inequality, referred to in the specification as "relational comparison." Typically they will be used with ordinally comparable values like <code>number</code>s. It's easy to understand that <code>3 &lt; 4</code>.</p>

<p>But JavaScript <code>string</code> values can also be compared for inequality, using typical alphabetic rules (<code>"bar" &lt; "foo"</code>).</p>

<p>What about coercion? Similar rules as <code>==</code> comparison (though not exactly identical!) apply to the inequality operators. Notably, there are no "strict inequality" operators that would disallow coercion the same way <code>===</code> "strict equality" does.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">41</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>43<span class="pl-pds">"</span></span>;

a <span class="pl-k">&lt;</span> b;      <span class="pl-c">// true</span>
b <span class="pl-k">&lt;</span> c;      <span class="pl-c">// true</span></pre></div>

<p>What happens here? In section 11.8.5 of the ES5 specification, it says that if both values in the <code>&lt;</code> comparison are <code>string</code>s, as it is with <code>b &lt; c</code>, the comparison is made lexicographically (aka alphabetically like a dictionary). But if one or both is not a <code>string</code>, as it is with <code>a &lt; b</code>, then both values are coerced to be <code>number</code>s, and a typical numeric comparison occurs.</p>

<p>The biggest gotcha you may run into here with comparisons between potentially different value types -- remember, there are no "strict inequality" forms to use -- is when one of the values cannot be made into a valid number, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

a <span class="pl-k">&lt;</span> b;      <span class="pl-c">// false</span>
a <span class="pl-k">&gt;</span> b;      <span class="pl-c">// false</span>
a <span class="pl-k">==</span> b;     <span class="pl-c">// false</span></pre></div>

<p>Wait, how can all three of those comparisons be <code>false</code>? Because the <code>b</code> value is being coerced to the "invalid number value" <code>NaN</code> in the <code>&lt;</code> and <code>&gt;</code> comparisons, and the specification says that <code>NaN</code> is neither greater-than nor less-than any other value.</p>

<p>The <code>==</code> comparison fails for a different reason. <code>a == b</code> could fail if it's interpreted either as <code>42 == NaN</code> or <code>"42" == "foo"</code> -- as we explained earlier, the former is the case.</p>

<p><strong>Note:</strong> For more information about the inequality comparison rules, see section 11.8.5 of the ES5 specification and also consult Chapter 4 of the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-variables" class="anchor" href="#variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variables</h2>

<p>In JavaScript, variable names (including function names) must be valid <em>identifiers</em>. The strict and complete rules for valid characters in identifiers are a little complex when you consider nontraditional characters such as Unicode. If you only consider typical ASCII alphanumeric characters, though, the rules are simple.</p>

<p>An identifier must start with <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>$</code>, or <code>_</code>. It can then contain any of those characters plus the numerals <code>0</code>-<code>9</code>.</p>

<p>Generally, the same rules apply to a property name as to a variable identifier. However, certain words cannot be used as variables, but are OK as property names. These words are called "reserved words," and include the JS keywords (<code>for</code>, <code>in</code>, <code>if</code>, etc.) as well as <code>null</code>, <code>true</code>, and <code>false</code>.</p>

<p><strong>Note:</strong> For more information about reserved words, see Appendix A of the <em>Types &amp; Grammar</em> title of this series.</p>

<h3><a id="user-content-function-scopes" class="anchor" href="#function-scopes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Scopes</h3>

<p>You use the <code>var</code> keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function.</p>

<h4><a id="user-content-hoisting" class="anchor" href="#hoisting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hoisting</h4>

<p>Wherever a <code>var</code> appears inside a scope, that declaration is taken to belong to the entire scope and accessible everywhere throughout.</p>

<p>Metaphorically, this behavior is called <em>hoisting</em>, when a <code>var</code> declaration is conceptually "moved" to the top of its enclosing scope. Technically, this process is more accurately explained by how code is compiled, but we can skip over those details for now.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo();                  <span class="pl-c">// works because `foo()`</span>
                        <span class="pl-c">// declaration is "hoisted"</span>

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    a <span class="pl-k">=</span> <span class="pl-c1">3</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 3</span>

    <span class="pl-k">var</span> a;              <span class="pl-c">// declaration is "hoisted"</span>
                        <span class="pl-c">// to the top of `foo()`</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 2</span></pre></div>

<p><strong>Warning:</strong> It's not common or a good idea to rely on variable <em>hoisting</em> to use a variable earlier in its scope than its <code>var</code> declaration appears; it can be quite confusing. It's much more common and accepted to use <em>hoisted</em> function declarations, as we do with the <code>foo()</code> call appearing before its formal declaration.</p>

<h4><a id="user-content-nested-scopes" class="anchor" href="#nested-scopes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Scopes</h4>

<p>When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

        <span class="pl-k">function</span> <span class="pl-en">baz</span>() {
            <span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">3</span>;

            <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c ); <span class="pl-c">// 1 2 3</span>
        }

        baz();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b );        <span class="pl-c">// 1 2</span>
    }

    bar();
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );               <span class="pl-c">// 1</span>
}

foo();</pre></div>

<p>Notice that <code>c</code> is not available inside of <code>bar()</code>, because it's declared only inside the inner <code>baz()</code> scope, and that <code>b</code> is not available to <code>foo()</code> for the same reason.</p>

<p>If you try to access a variable's value in a scope where it's not available, you'll get a <code>ReferenceError</code> thrown. If you try to set a variable that hasn't been declared, you'll either end up creating a variable in the top-level global scope (bad!) or getting an error, depending on "strict mode" (see "Strict Mode"). Let's take a look:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    a <span class="pl-k">=</span> <span class="pl-c1">1</span>;  <span class="pl-c">// `a` not formally declared</span>
}

foo();
a;          <span class="pl-c">// 1 -- oops, auto global variable :(</span></pre></div>

<p>This is a very bad practice. Don't do it! Always formally declare your variables.</p>

<p>In addition to creating declarations for variables at the function level, ES6 <em>lets</em> you declare variables to belong to individual blocks (pairs of <code>{ .. }</code>), using the <code>let</code> keyword. Besides some nuanced details, the scoping rules will behave roughly the same as we just saw with functions:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;

    <span class="pl-k">if</span> (a <span class="pl-k">&gt;=</span> <span class="pl-c1">1</span>) {
        <span class="pl-k">let</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

        <span class="pl-k">while</span> (b <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>) {
            <span class="pl-k">let</span> c <span class="pl-k">=</span> b <span class="pl-k">*</span> <span class="pl-c1">2</span>;
            b<span class="pl-k">++</span>;

            <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> c );
        }
    }
}

foo();
<span class="pl-c">// 5 7 9</span></pre></div>

<p>Because of using <code>let</code> instead of <code>var</code>, <code>b</code> will belong only to the <code>if</code> statement and thus not to the whole <code>foo()</code> function's scope. Similarly, <code>c</code> belongs only to the <code>while</code> loop. Block scoping is very useful for managing your variable scopes in a more fine-grained fashion, which can make your code much easier to maintain over time.</p>

<p><strong>Note:</strong> For more information about scope, see the <em>Scope &amp; Closures</em> title of this series. See the <em>ES6 &amp; Beyond</em> title of this series for more information about <code>let</code> block scoping.</p>

<h2><a id="user-content-conditionals" class="anchor" href="#conditionals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conditionals</h2>

<p>In addition to the <code>if</code> statement we introduced briefly in Chapter 1, JavaScript provides a few other conditionals mechanisms that we should take a look at.</p>

<p>Sometimes you may find yourself writing a series of <code>if..else..if</code> statements like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">2</span>) {
    <span class="pl-c">// do something</span>
}
<span class="pl-k">else</span> <span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">10</span>) {
    <span class="pl-c">// do another thing</span>
}
<span class="pl-k">else</span> <span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">42</span>) {
    <span class="pl-c">// do yet another thing</span>
}
<span class="pl-k">else</span> {
    <span class="pl-c">// fallback to here</span>
}</pre></div>

<p>This structure works, but it's a little verbose because you need to specify the <code>a</code> test for each case. Here's another option, the <code>switch</code> statement:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">switch</span> (a) {
    <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span>
        <span class="pl-c">// do something</span>
        <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">10</span><span class="pl-k">:</span>
        <span class="pl-c">// do another thing</span>
        <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">42</span><span class="pl-k">:</span>
        <span class="pl-c">// do yet another thing</span>
        <span class="pl-k">break</span>;
    <span class="pl-k">default</span><span class="pl-k">:</span>
        <span class="pl-c">// fallback to here</span>
}</pre></div>

<p>The <code>break</code> is important if you want only the statement(s) in one <code>case</code> to run. If you omit <code>break</code> from a <code>case</code>, and that <code>case</code> matches or runs, execution will continue with the next <code>case</code>'s statements regardless of that <code>case</code> matching. This so called "fall through" is sometimes useful/desired:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">switch</span> (a) {
    <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span>
    <span class="pl-k">case</span> <span class="pl-c1">10</span><span class="pl-k">:</span>
        <span class="pl-c">// some cool stuff</span>
        <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">42</span><span class="pl-k">:</span>
        <span class="pl-c">// other stuff</span>
        <span class="pl-k">break</span>;
    <span class="pl-k">default</span><span class="pl-k">:</span>
        <span class="pl-c">// fallback</span>
}</pre></div>

<p>Here, if <code>a</code> is either <code>2</code> or <code>10</code>, it will execute the "some cool stuff" code statements.</p>

<p>Another form of conditional in JavaScript is the "conditional operator," often called the "ternary operator." It's like a more concise form of a single <code>if..else</code> statement, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> (a <span class="pl-k">&gt;</span> <span class="pl-c1">41</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>;

<span class="pl-c">// similar to:</span>

<span class="pl-c">// if (a &gt; 41) {</span>
<span class="pl-c">//    b = "hello";</span>
<span class="pl-c">// }</span>
<span class="pl-c">// else {</span>
<span class="pl-c">//    b = "world";</span>
<span class="pl-c">// }</span></pre></div>

<p>If the test expression (<code>a &gt; 41</code> here) evaluates as <code>true</code>, the first clause (<code>"hello"</code>) results, otherwise the second clause (<code>"world"</code>) results, and whatever the result is then gets assigned to <code>b</code>.</p>

<p>The conditional operator doesn't have to be used in an assignment, but that's definitely the most common usage.</p>

<p><strong>Note:</strong> For more information about testing conditions and other patterns for <code>switch</code> and <code>? :</code>, see the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-strict-mode" class="anchor" href="#strict-mode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strict Mode</h2>

<p>ES5 added a "strict mode" to the language, which tightens the rules for certain behaviors. Generally, these restrictions are seen as keeping the code to a safer and more appropriate set of guidelines. Also, adhering to strict mode makes your code generally more optimizable by the engine. Strict mode is a big win for code, and you should use it for all your programs.</p>

<p>You can opt in to strict mode for an individual function, or an entire file, depending on where you put the strict mode pragma:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

    <span class="pl-c">// this code is strict mode</span>

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-c">// this code is strict mode</span>
    }
}

<span class="pl-c">// this code is not strict mode</span></pre></div>

<p>Compare that to:</p>

<div class="highlight highlight-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// this code is strict mode</span>

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-c">// this code is strict mode</span>
    }
}

<span class="pl-c">// this code is strict mode</span></pre></div>

<p>One key difference (improvement!) with strict mode is disallowing the implicit auto-global variable declaration from omitting the <code>var</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;   <span class="pl-c">// turn on strict mode</span>
    a <span class="pl-k">=</span> <span class="pl-c1">1</span>;          <span class="pl-c">// `var` missing, ReferenceError</span>
}

foo();</pre></div>

<p>If you turn on strict mode in your code, and you get errors, or code starts behaving buggy, your temptation might be to avoid strict mode. But that instinct would be a bad idea to indulge. If strict mode causes issues in your program, almost certainly it's a sign that you have things in your program you should fix.</p>

<p>Not only will strict mode keep your code to a safer path, and not only will it make your code more optimizable, but it also represents the future direction of the language. It'd be easier on you to get used to strict mode now than to keep putting it off -- it'll only get harder to convert later!</p>

<p><strong>Note:</strong> For more information about strict mode, see the Chapter 5 of the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-functions-as-values" class="anchor" href="#functions-as-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions As Values</h2>

<p>So far, we've discussed functions as the primary mechanism of <em>scope</em> in JavaScript. You recall typical <code>function</code> declaration syntax as follows:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>
}</pre></div>

<p>Though it may not seem obvious from that syntax, <code>foo</code> is basically just a variable in the outer enclosing scope that's given a reference to the <code>function</code> being declared. That is, the <code>function</code> itself is a value, just like <code>42</code> or <code>[1,2,3]</code> would be.</p>

<p>This may sound like a strange concept at first, so take a moment to ponder it. Not only can you pass a value (argument) <em>to</em> a function, but <em>a function itself can be a value</em> that's assigned to variables, or passed to or returned from other functions.</p>

<p>As such, a function value should be thought of as an expression, much like any other value or expression.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c">// ..</span>
};

<span class="pl-k">var</span> <span class="pl-en">x</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>(){
    <span class="pl-c">// ..</span>
};</pre></div>

<p>The first function expression assigned to the <code>foo</code> variable is called <em>anonymous</em> because it has no <code>name</code>.</p>

<p>The second function expression is <em>named</em> (<code>bar</code>), even as a reference to it is also assigned to the <code>x</code> variable. <em>Named function expressions</em> are generally more preferable, though <em>anonymous function expressions</em> are still extremely common.</p>

<p>For more information, see the <em>Scope &amp; Closures</em> title of this series.</p>

<h3><a id="user-content-immediately-invoked-function-expressions-iifes" class="anchor" href="#immediately-invoked-function-expressions-iifes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Immediately Invoked Function Expressions (IIFEs)</h3>

<p>In the previous snippet, neither of the function expressions are executed -- we could if we had included <code>foo()</code> or <code>x()</code>, for instance.</p>

<p>There's another way to execute a function expression, which is typically referred to as an <em>immediately invoked function expression</em> (IIFE):</p>

<div class="highlight highlight-js"><pre>(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span> );
})();
<span class="pl-c">// "Hello!"</span></pre></div>

<p>The outer <code>( .. )</code> that surrounds the <code>(function IIFE(){ .. })</code> function expression is just a nuance of JS grammar needed to prevent it from being treated as a normal function declaration.</p>

<p>The final <code>()</code> on the end of the expression -- the <code>})();</code> line -- is what actually executes the function expression referenced immediately before it.</p>

<p>That may seem strange, but it's not as foreign as first glance. Consider the similarities between <code>foo</code> and <code>IIFE</code> here:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-c">// `foo` function reference expression,</span>
<span class="pl-c">// then `()` executes it</span>
foo();

<span class="pl-c">// `IIFE` function expression,</span>
<span class="pl-c">// then `()` executes it</span>
(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){ .. })();</pre></div>

<p>As you can see, listing the <code>(function IIFE(){ .. })</code> before its executing <code>()</code> is essentially the same as including <code>foo</code> before its executing <code>()</code>; in both cases, the function reference is executed with <code>()</code> immediately after it.</p>

<p>Because an IIFE is just a function, and functions create variable <em>scope</em>, using an IIFE in this fashion is often used to declare variables that won't affect the surrounding code outside the IIFE:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 10</span>
})();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// 42</span></pre></div>

<p>IIFEs can also have return values:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-k">return</span> <span class="pl-c1">42</span>;
})();

x;  <span class="pl-c">// 42</span></pre></div>

<p>The <code>42</code> value gets <code>return</code>ed from the <code>IIFE</code>-named function being executed, and is then assigned to <code>x</code>.</p>

<h3><a id="user-content-closure" class="anchor" href="#closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Closure</h3>

<p><em>Closure</em> is one of the most important, and often least understood, concepts in JavaScript. I won't cover it in deep detail here, and instead refer you to the <em>Scope &amp; Closures</em> title of this series. But I want to say a few things about it so you understand the general concept. It will be one of the most important techniques in your JS skillset.</p>

<p>You can think of closure as a way to "remember" and continue to access a function's scope (its variables) even once the function has finished running.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">makeAdder</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// parameter `x` is an inner variable</span>

    <span class="pl-c">// inner function `add()` uses `x`, so</span>
    <span class="pl-c">// it has a "closure" over it</span>
    <span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">y</span>) {
        <span class="pl-k">return</span> y <span class="pl-k">+</span> x;
    };

    <span class="pl-k">return</span> add;
}</pre></div>

<p>The reference to the inner <code>add(..)</code> function that gets returned with each call to the outer <code>makeAdder(..)</code> is able to remember whatever <code>x</code> value was passed in to <code>makeAdder(..)</code>. Now, let's use <code>makeAdder(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `plusOne` gets a reference to the inner `add(..)`</span>
<span class="pl-c">// function with closure over the `x` parameter of</span>
<span class="pl-c">// the outer `makeAdder(..)`</span>
<span class="pl-k">var</span> plusOne <span class="pl-k">=</span> makeAdder( <span class="pl-c1">1</span> );

<span class="pl-c">// `plusTen` gets a reference to the inner `add(..)`</span>
<span class="pl-c">// function with closure over the `x` parameter of</span>
<span class="pl-c">// the outer `makeAdder(..)`</span>
<span class="pl-k">var</span> plusTen <span class="pl-k">=</span> makeAdder( <span class="pl-c1">10</span> );

plusOne( <span class="pl-c1">3</span> );       <span class="pl-c">// 4  &lt;-- 1 + 3</span>
plusOne( <span class="pl-c1">41</span> );      <span class="pl-c">// 42 &lt;-- 1 + 41</span>

plusTen( <span class="pl-c1">13</span> );      <span class="pl-c">// 23 &lt;-- 10 + 13</span></pre></div>

<p>More on how this code works:</p>

<ol>
<li>When we call <code>makeAdder(1)</code>, we get back a reference to its inner <code>add(..)</code> that remembers <code>x</code> as <code>1</code>. We call this function reference <code>plusOne(..)</code>.</li>
<li>When we call <code>makeAdder(10)</code>, we get back another reference to its inner <code>add(..)</code> that remembers <code>x</code> as <code>10</code>. We call this function reference <code>plusTen(..)</code>.</li>
<li>When we call <code>plusOne(3)</code>, it adds <code>3</code> (its inner <code>y</code>) to the <code>1</code> (remembered by <code>x</code>), and we get <code>4</code> as the result.</li>
<li>When we call <code>plusTen(13)</code>, it adds <code>13</code> (its inner <code>y</code>) to the <code>10</code> (remembered by <code>x</code>), and we get <code>23</code> as the result.</li>
</ol>

<p>Don't worry if this seems strange and confusing at first -- it can be! It'll take lots of practice to understand it fully.</p>

<p>But trust me, once you do, it's one of the most powerful and useful techniques in all of programming. It's definitely worth the effort to let your brain simmer on closures for a bit. In the next section, we'll get a little more practice with closure.</p>

<h4><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h4>

<p>The most common usage of closure in JavaScript is the module pattern. Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that <em>is</em> accessible from the outside.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">User</span>(){
    <span class="pl-k">var</span> username, password;

    <span class="pl-k">function</span> <span class="pl-en">doLogin</span>(<span class="pl-smi">user</span>,<span class="pl-smi">pw</span>) {
        username <span class="pl-k">=</span> user;
        password <span class="pl-k">=</span> pw;

        <span class="pl-c">// do the rest of the login work</span>
    }

    <span class="pl-k">var</span> publicAPI <span class="pl-k">=</span> {
        login<span class="pl-k">:</span> doLogin
    };

    <span class="pl-k">return</span> publicAPI;
}

<span class="pl-c">// create a `User` module instance</span>
<span class="pl-k">var</span> fred <span class="pl-k">=</span> User();

fred.login( <span class="pl-s"><span class="pl-pds">"</span>fred<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>12Battery34!<span class="pl-pds">"</span></span> );</pre></div>

<p>The <code>User()</code> function serves as an outer scope that holds the variables <code>username</code> and <code>password</code>, as well as the inner <code>doLogin()</code> function; these are all private inner details of this <code>User</code> module that cannot be accessed from the outside world.</p>

<p><strong>Warning:</strong> We are not calling <code>new User()</code> here, on purpose, despite the fact that probably seems more common to most readers. <code>User()</code> is just a function, not a class to be instantiated, so it's just called normally. Using <code>new</code> would be inappropriate and actually waste resources.</p>

<p>Executing <code>User()</code> creates an <em>instance</em> of the <code>User</code> module -- a whole new scope is created, and thus a whole new copy of each of these inner variables/functions. We assign this instance to <code>fred</code>. If we run <code>User()</code> again, we'd get a new instance entirely separate from <code>fred</code>.</p>

<p>The inner <code>doLogin()</code> function has a closure over <code>username</code> and <code>password</code>, meaning it will retain its access to them even after the <code>User()</code> function finishes running.</p>

<p><code>publicAPI</code> is an object with one property/method on it, <code>login</code>, which is a reference to the inner <code>doLogin()</code> function. When we return <code>publicAPI</code> from <code>User()</code>, it becomes the instance we call <code>fred</code>.</p>

<p>At this point, the outer <code>User()</code> function has finished executing. Normally, you'd think the inner variables like <code>username</code> and <code>password</code> have gone away. But here they have not, because there's a closure in the <code>login()</code> function keeping them alive.</p>

<p>That's why we can call <code>fred.login(..)</code> -- the same as calling the inner <code>doLogin(..)</code> -- and it can still access <code>username</code> and <code>password</code> inner variables.</p>

<p>There's a good chance that with just this brief glimpse at closure and the module pattern, some of it is still a bit confusing. That's OK! It takes some work to wrap your brain around it.</p>

<p>From here, go read the <em>Scope &amp; Closures</em> title of this series for a much more in-depth exploration.</p>

<h2><a id="user-content-this-identifier" class="anchor" href="#this-identifier" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>this</code> Identifier</h2>

<p>Another very commonly misunderstood concept in JavaScript is the <code>this</code> identifier. Again, there's a couple of chapters on it in the <em>this &amp; Object Prototypes</em> title of this series, so here we'll just briefly introduce the concept.</p>

<p>While it may often seem that <code>this</code> is related to "object-oriented patterns," in JS <code>this</code> is a different mechanism.</p>

<p>If a function has a <code>this</code> reference inside it, that <code>this</code> reference usually points to an <code>object</code>. But which <code>object</code> it points to depends on how the function was called.</p>

<p>It's important to realize that <code>this</code> <em>does not</em> refer to the function itself, as is the most common misconception.</p>

<p>Here's a quick illustration:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.bar );
}

<span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>global<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
    bar<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj1<span class="pl-pds">"</span></span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {
    bar<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj2<span class="pl-pds">"</span></span>
};

<span class="pl-c">// --------</span>

foo();              <span class="pl-c">// "global"</span>
obj1.foo();         <span class="pl-c">// "obj1"</span>
foo.<span class="pl-c1">call</span>( obj2 );   <span class="pl-c">// "obj2"</span>
<span class="pl-k">new</span> <span class="pl-en">foo</span>();          <span class="pl-c">// undefined</span></pre></div>

<p>There are four rules for how <code>this</code> gets set, and they're shown in those last four lines of that snippet.</p>

<ol>
<li><code>foo()</code> ends up setting <code>this</code> to the global object in non-strict mode -- in strict mode, <code>this</code> would be <code>undefined</code> and you'd get an error in accessing the <code>bar</code> property -- so <code>"global"</code> is the value found for <code>this.bar</code>.</li>
<li><code>obj1.foo()</code> sets <code>this</code> to the <code>obj1</code> object.</li>
<li><code>foo.call(obj2)</code> sets <code>this</code> to the <code>obj2</code> object.</li>
<li><code>new foo()</code> sets <code>this</code> to a brand new empty object.</li>
</ol>

<p>Bottom line: to understand what <code>this</code> points to, you have to examine how the function in question was called. It will be one of those four ways just shown, and that will then answer what <code>this</code> is.</p>

<p><strong>Note:</strong> For more information about <code>this</code>, see Chapters 1 and 2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<h2><a id="user-content-prototypes" class="anchor" href="#prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prototypes</h2>

<p>The prototype mechanism in JavaScript is quite complicated. We will only glance at it here. You will want to spend plenty of time reviewing Chapters 4-6 of the <em>this &amp; Object Prototypes</em> title of this series for all the details.</p>

<p>When you reference a property on an object, if that property doesn't exist, JavaScript will automatically use that object's internal prototype reference to find another object to look for the property on. You could think of this almost as a fallback if the property is missing.</p>

<p>The internal prototype reference linkage from one object to its fallback happens at the time the object is created. The simplest way to illustrate it is with a built-in utility called <code>Object.create(..)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">42</span>
};

<span class="pl-c">// create `bar` and link it to `foo`</span>
<span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( foo );

bar.b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

bar.b;      <span class="pl-c">// "hello world"</span>
bar.a;      <span class="pl-c">// 42 &lt;-- delegated to `foo`</span></pre></div>

<p>It may help to visualize the <code>foo</code> and <code>bar</code> objects and their relationship:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig6.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig6.png" style="max-width:100%;"></a></p>

<p>The <code>a</code> property doesn't actually exist on the <code>bar</code> object, but because <code>bar</code> is prototype-linked to <code>foo</code>, JavaScript automatically falls back to looking for <code>a</code> on the <code>foo</code> object, where it's found.</p>

<p>This linkage may seem like a strange feature of the language. The most common way this feature is used -- and I would argue, abused -- is to try to emulate/fake a "class" mechanism with "inheritance."</p>

<p>But a more natural way of applying prototypes is a pattern called "behavior delegation," where you intentionally design your linked objects to be able to <em>delegate</em> from one to the other for parts of the needed behavior.</p>

<p><strong>Note:</strong> For more information about prototypes and behavior delegation, see Chapters 4-6 of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<h2><a id="user-content-old--new" class="anchor" href="#old--new" aria-hidden="true"><span class="octicon octicon-link"></span></a>Old &amp; New</h2>

<p>Some of the JS features we've already covered, and certainly many of the features covered in the rest of this series, are newer additions and will not necessarily be available in older browsers. In fact, some of the newest features in the specification aren't even implemented in any stable browsers yet.</p>

<p>So, what do you do with the new stuff? Do you just have to wait around for years or decades for all the old browsers to fade into obscurity?</p>

<p>That's how many people think about the situation, but it's really not a healthy approach to JS.</p>

<p>There are two main techniques you can use to "bring" the newer JavaScript stuff to the older browsers: polyfilling and transpiling.</p>

<h3><a id="user-content-polyfilling" class="anchor" href="#polyfilling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polyfilling</h3>

<p>The word "polyfill" is an invented term (by Remy Sharp) (<a href="https://remysharp.com/2010/10/08/what-is-a-polyfill">https://remysharp.com/2010/10/08/what-is-a-polyfill</a>) used to refer to taking the definition of a newer feature and producing a piece of code that's equivalent to the behavior, but is able to run in older JS environments.</p>

<p>For example, ES6 defines a utility called <code>Number.isNaN(..)</code> to provide an accurate non-buggy check for <code>NaN</code> values, deprecating the original <code>isNaN(..)</code> utility. But it's easy to polyfill that utility so that you can start using it in your code regardless of whether the end user is in an ES6 browser or not.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Number</span>.isNaN) {
    <span class="pl-c1">Number</span>.<span class="pl-en">isNaN</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">isNaN</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> x <span class="pl-k">!==</span> x;
    };
}</pre></div>

<p>The <code>if</code> statement guards against applying the polyfill definition in ES6 browsers where it will already exist. If it's not already present, we define <code>Number.isNaN(..)</code>.</p>

<p><strong>Note:</strong> The check we do here takes advantage of a quirk with <code>NaN</code> values, which is that they're the only value in the whole language that is not equal to itself. So the <code>NaN</code> value is the only one that would make <code>x !== x</code> be <code>true</code>.</p>

<p>Not all new features are fully polyfillable. Sometimes most of the behavior can be polyfilled, but there are still small deviations. You should be really, really careful in implementing a polyfill yourself, to make sure you are adhering to the specification as strictly as possible.</p>

<p>Or better yet, use an already vetted set of polyfills that you can trust, such as those provided by ES5-Shim (<a href="https://github.com/es-shims/es5-shim">https://github.com/es-shims/es5-shim</a>) and ES6-Shim (<a href="https://github.com/es-shims/es6-shim">https://github.com/es-shims/es6-shim</a>).</p>

<h3><a id="user-content-transpiling" class="anchor" href="#transpiling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transpiling</h3>

<p>There's no way to polyfill new syntax that has been added to the language. The new syntax would throw an error in the old JS engine as unrecognized/invalid.</p>

<p>So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called "transpiling," a term for transforming + compiling.</p>

<p>Essentially, your source code is authored in the new syntax form, but what you deploy to the browser is the transpiled code in old syntax form. You typically insert the transpiler into your build process, similar to your code linter or your minifier.</p>

<p>You might wonder why you'd go to the trouble to write new syntax only to have it transpiled away to older code -- why not just write the older code directly?</p>

<p>There are several important reasons you should care about transpiling:</p>

<ul>
<li>The new syntax added to the language is designed to make your code more readable and maintainable. The older equivalents are often much more convoluted. You should prefer writing newer and cleaner syntax, not only for yourself but for all other members of the development team.</li>
<li>If you transpile only for older browsers, but serve the new syntax to the newest browsers, you get to take advantage of browser performance optimizations with the new syntax. This also lets browser makers have more real-world code to test their implementations and optimizations on.</li>
<li>Using the new syntax earlier allows it to be tested more robustly in the real world, which provides earlier feedback to the JavaScript committee (TC39). If issues are found early enough, they can be changed/fixed before those language design mistakes become permanent.</li>
</ul>

<p>Here's a quick example of transpiling. ES6 adds a feature called "default parameter values." It looks like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

foo();      <span class="pl-c">// 2</span>
foo( <span class="pl-c1">42</span> );  <span class="pl-c">// 42</span></pre></div>

<p>Simple, right? Helpful, too! But it's new syntax that's invalid in pre-ES6 engines. So what will a transpiler do with that code to make it run in older environments?</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> arguments[<span class="pl-c1">0</span>] <span class="pl-k">!==</span> (<span class="pl-k">void</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> arguments[<span class="pl-c1">0</span>] <span class="pl-k">:</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}</pre></div>

<p>As you can see, it checks to see if the <code>arguments[0]</code> value is <code>void 0</code> (aka <code>undefined</code>), and if so provides the <code>2</code> default value; otherwise, it assigns whatever was passed.</p>

<p>In addition to being able to now use the nicer syntax even in older browsers, looking at the transpiled code actually explains the intended behavior more clearly.</p>

<p>You may not have realized just from looking at the ES6 version that <code>undefined</code> is the only value that can't get explicitly passed in for a default-value parameter, but the transpiled code makes that much more clear.</p>

<p>The last important detail to emphasize about transpilers is that they should now be thought of as a standard part of the JS development ecosystem and process. JS is going to continue to evolve, much more quickly than before, so every few months new syntax and new features will be added.</p>

<p>If you use a transpiler by default, you'll always be able to make that switch to newer syntax whenever you find it useful, rather than always waiting for years for today's browsers to phase out.</p>

<p>There are quite a few great transpilers for you to choose from. Here are some good options at the time of this writing:</p>

<ul>
<li>Babel (<a href="https://babeljs.io">https://babeljs.io</a>) (formerly 6to5): Transpiles ES6+ into ES5</li>
<li>Traceur (<a href="https://github.com/google/traceur-compiler">https://github.com/google/traceur-compiler</a>): Transpiles ES6, ES7, and beyond into ES5</li>
</ul>

<h2><a id="user-content-non-javascript" class="anchor" href="#non-javascript" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-JavaScript</h2>

<p>So far, the only things we've covered are in the JS language itself. The reality is that most JS is written to run in and interact with environments like browsers. A good chunk of the stuff that you write in your code is, strictly speaking, not directly controlled by JavaScript. That probably sounds a little strange.</p>

<p>The most common non-JavaScript JavaScript you'll encounter is the DOM API. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> el <span class="pl-k">=</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );</pre></div>

<p>The <code>document</code> variable exists as a global variable when your code is running in a browser. It's not provided by the JS engine, nor is it particularly controlled by the JavaScript specification. It takes the form of something that looks an awful lot like a normal JS <code>object</code>, but it's not really exactly that. It's a special <code>object,</code> often called a "host object."</p>

<p>Moreover, the <code>getElementById(..)</code> method on <code>document</code> looks like a normal JS function, but it's just a thinly exposed interface to a built-in method provided by the DOM from your browser. In some (newer-generation) browsers, this layer may also be in JS, but traditionally the DOM and its behavior is implemented in something more like C/C++.</p>

<p>Another example is with input/output (I/O).</p>

<p>Everyone's favorite <code>alert(..)</code> pops up a message box in the user's browser window. <code>alert(..)</code> is provided to your JS program by the browser, not by the JS engine itself. The call you make sends the message to the browser internals and it handles drawing and displaying the message box.</p>

<p>The same goes with <code>console.log(..)</code>; your browser provides such mechanisms and hooks them up to the developer tools.</p>

<p>This book, and this whole series, focuses on JavaScript the language. That's why you don't see any substantial coverage of these non-JavaScript JavaScript mechanisms. Nevertheless, you need to be aware of them, as they'll be in every JS program you write!</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>The first step to learning JavaScript's flavor of programming is to get a basic understanding of its core mechanisms like values, types, function closures, <code>this</code>, and prototypes.</p>

<p>Of course, each of these topics deserves much greater coverage than you've seen here, but that's why they have chapters and books dedicated to them throughout the rest of this series. After you feel pretty comfortable with the concepts and code samples in this chapter, the rest of the series awaits you to really dig in and get to know the language deeply.</p>

<p>The final chapter of this book will briefly summarize each of the other titles in the series and the other concepts they cover besides what we've already explored.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-up--going" class="anchor" href="#you-dont-know-js-up--going" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Up &amp; Going</h1>

<h1><a id="user-content-chapter-1-into-programming" class="anchor" href="#chapter-1-into-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: Into Programming</h1>

<p>Welcome to the <em>You Don't Know JS</em> (<em>YDKJS</em>) series.</p>

<p><em>Up &amp; Going</em> is an introduction to several basic concepts of programming -- of course we lean toward JavaScript (often abbreviated JS) specifically -- and how to approach and understand the rest of the titles in this series. Especially if you're just getting into programming and/or JavaScript, this book will briefly explore what you need to get <em>up and going</em>.</p>

<p>This book starts off explaining the basic principles of programming at a very high level. It's mostly intended if you are starting <em>YDKJS</em> with little to no prior programming experience, and are looking to these books to help get you started along a path to understanding programming through the lens of JavaScript.</p>

<p>Chapter 1 should be approached as a quick overview of the things you'll want to learn more about and practice to get <em>into programming</em>. There are also many other fantastic programming introduction resources that can help you dig into these topics further, and I encourage you to learn from them in addition to this chapter.</p>

<p>Once you feel comfortable with general programming basics, Chapter 2 will help guide you to a familiarity with JavaScript's flavor of programming. Chapter 2 introduces what JavaScript is about, but again, it's not a comprehensive guide -- that's what the rest of the <em>YDKJS</em> books are for!</p>

<p>If you're already fairly comfortable with JavaScript, first check out Chapter 3 as a brief glimpse of what to expect from <em>YDKJS</em>, then jump right in!</p>

<h2><a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code</h2>

<p>Let's start from the beginning.</p>

<p>A program, often referred to as <em>source code</em> or just <em>code</em>, is a set of special instructions to tell the computer what tasks to perform. Usually code is saved in a text file, although with JavaScript you can also type code directly into a developer console in a browser, which we'll cover shortly.</p>

<p>The rules for valid format and combinations of instructions is called a <em>computer language</em>, sometimes referred to as its <em>syntax</em>, much the same as English tells you how to spell words and how to create valid sentences using words and punctuation.</p>

<h3><a id="user-content-statements" class="anchor" href="#statements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Statements</h3>

<p>In a computer language, a group of words, numbers, and operators that performs a specific task is a <em>statement</em>. In JavaScript, a statement might look as follows:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> b <span class="pl-k">*</span> <span class="pl-c1">2</span>;</pre></div>

<p>The characters <code>a</code> and <code>b</code> are called <em>variables</em> (see "Variables"), which are like simple boxes you can store any of your stuff in. In programs, variables hold values (like the number <code>42</code>) to be used by the program. Think of them as symbolic placeholders for the values themselves.</p>

<p>By contrast, the <code>2</code> is just a value itself, called a <em>literal value</em>, because it stands alone without being stored in a variable.</p>

<p>The <code>=</code> and <code>*</code> characters are <em>operators</em> (see "Operators") -- they perform actions with the values and variables such as assignment and mathematic multiplication.</p>

<p>Most statements in JavaScript conclude with a semicolon (<code>;</code>) at the end.</p>

<p>The statement <code>a = b * 2;</code> tells the computer, roughly, to get the current value stored in the variable <code>b</code>, multiply that value by <code>2</code>, then store the result back into another variable we call <code>a</code>.</p>

<p>Programs are just collections of many such statements, which together describe all the steps that it takes to perform your program's purpose.</p>

<h3><a id="user-content-expressions" class="anchor" href="#expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expressions</h3>

<p>Statements are made up of one or more <em>expressions</em>. An expression is any reference to a variable or value, or a set of variable(s) and value(s) combined with operators.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> b <span class="pl-k">*</span> <span class="pl-c1">2</span>;</pre></div>

<p>This statement has four expressions in it:</p>

<ul>
<li><code>2</code> is a <em>literal value expression</em></li>
<li><code>b</code> is a <em>variable expression</em>, which means to retrieve its current value</li>
<li><code>b * 2</code> is an <em>arithmetic expression</em>, which means to do the multiplication</li>
<li><code>a = b * 2</code> is an <em>assignment expression</em>, which means to assign the result of the <code>b * 2</code> expression to the variable <code>a</code> (more on assignments later)</li>
</ul>

<p>A general expression that stands alone is also called an <em>expression statement</em>, such as the following:</p>

<div class="highlight highlight-js"><pre>b <span class="pl-k">*</span> <span class="pl-c1">2</span>;</pre></div>

<p>This flavor of expression statement is not very common or useful, as generally it wouldn't have any effect on the running of the program -- it would retrieve the value of <code>b</code> and multiply it by <code>2</code>, but then wouldn't do anything with that result.</p>

<p>A more common expression statement is a <em>call expression</em> statement (see "Functions"), as the entire statement is the function call expression itself:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">alert</span>( a );</pre></div>

<h3><a id="user-content-executing-a-program" class="anchor" href="#executing-a-program" aria-hidden="true"><span class="octicon octicon-link"></span></a>Executing a Program</h3>

<p>How do those collections of programming statements tell the computer what to do? The program needs to be <em>executed</em>, also referred to as <em>running the program</em>.</p>

<p>Statements like <code>a = b * 2</code> are helpful for developers when reading and writing, but are not actually in a form the computer can directly understand. So a special utility on the computer (either an <em>interpreter</em> or a <em>compiler</em>) is used to translate the code you write into commands a computer can understand.</p>

<p>For some computer languages, this translation of commands is typically done from top to bottom, line by line, every time the program is run, which is usually called <em>interpreting</em> the code.</p>

<p>For other languages, the translation is done ahead of time, called <em>compiling</em> the code, so when the program <em>runs</em> later, what's running is actually the already compiled computer instructions ready to go.</p>

<p>It's typically asserted that JavaScript is <em>interpreted</em>, because your JavaScript source code is processed each time it's run. But that's not entirely accurate. The JavaScript engine actually <em>compiles</em> the program on the fly and then immediately runs the compiled code.</p>

<p><strong>Note:</strong> For more information on JavaScript compiling, see the first two chapters of the <em>Scope &amp; Closures</em> title of this series.</p>

<h2><a id="user-content-try-it-yourself" class="anchor" href="#try-it-yourself" aria-hidden="true"><span class="octicon octicon-link"></span></a>Try It Yourself</h2>

<p>This chapter is going to introduce each programming concept with simple snippets of code, all written in JavaScript (obviously!).</p>

<p>It cannot be emphasized enough: while you go through this chapter -- and you may need to spend the time to go over it several times -- you should practice each of these concepts by typing the code yourself. The easiest way to do that is to open up the developer tools console in your nearest browser (Firefox, Chrome, IE, etc.).</p>

<p><strong>Tip:</strong> Typically, you can launch the developer console with a keyboard shortcut or from a menu item. For more detailed information about launching and using the console in your favorite browser, see "Mastering The Developer Tools Console" (<a href="http://blog.teamtreehouse.com/mastering-developer-tools-console">http://blog.teamtreehouse.com/mastering-developer-tools-console</a>). To type multiple lines into the console at once, use <code>&lt;shift&gt; + &lt;enter&gt;</code> to move to the next new line. Once you hit <code>&lt;enter&gt;</code> by itself, the console will run everything you've just typed.</p>

<p>Let's get familiar with the process of running code in the console. First, I suggest opening up an empty tab in your browser. I prefer to do this by typing <code>about:blank</code> into the address bar. Then, make sure your developer console is open, as we just mentioned.</p>

<p>Now, type this code and see how it runs:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> <span class="pl-c1">21</span>;

b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );</pre></div>

<p>Typing the preceding code into the console in Chrome should produce something like the following:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig1.png" width="500" style="max-width:100%;"></a></p>

<p>Go on, try it. The best way to learn programming is to start coding!</p>

<h3><a id="user-content-output" class="anchor" href="#output" aria-hidden="true"><span class="octicon octicon-link"></span></a>Output</h3>

<p>In the previous code snippet, we used <code>console.log(..)</code>. Briefly, let's look at what that line of code is all about.</p>

<p>You may have guessed, but that's exactly how we print text (aka <em>output</em> to the user) in the developer console. There are two characteristics of that statement that we should explain.</p>

<p>First, the <code>log( b )</code> part is referred to as a function call (see "Functions"). What's happening is we're handing the <code>b</code> variable to that function, which asks it to take the value of <code>b</code> and print it to the console.</p>

<p>Second, the <code>console.</code> part is an object reference where the <code>log(..)</code> function is located. We cover objects and their properties in more detail in Chapter 2.</p>

<p>Another way of creating output that you can see is to run an <code>alert(..)</code> statement. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">alert</span>( b );</pre></div>

<p>If you run that, you'll notice that instead of printing the output to the console, it shows a popup "OK" box with the contents of the <code>b</code> variable. However, using <code>console.log(..)</code> is generally going to make learning about coding and running your programs in the console easier than using <code>alert(..)</code>, because you can output many values at once without interrupting the browser interface.</p>

<p>For this book, we'll use <code>console.log(..)</code> for output.</p>

<h3><a id="user-content-input" class="anchor" href="#input" aria-hidden="true"><span class="octicon octicon-link"></span></a>Input</h3>

<p>While we're discussing output, you may also wonder about <em>input</em> (i.e., receiving information from the user).</p>

<p>The most common way that happens is for the HTML page to show form elements (like text boxes) to a user that they can type into, and then using JS to read those values into your program's variables.</p>

<p>But there's an easier way to get input for simple learning and demonstration purposes such as what you'll be doing throughout this book. Use the <code>prompt(..)</code> function:</p>

<div class="highlight highlight-js"><pre>age <span class="pl-k">=</span> <span class="pl-c1">prompt</span>( <span class="pl-s"><span class="pl-pds">"</span>Please tell me your age:<span class="pl-pds">"</span></span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( age );</pre></div>

<p>As you may have guessed, the message you pass to <code>prompt(..)</code> -- in this case, <code>"Please tell me your age:"</code> -- is printed into the popup.</p>

<p>This should look similar to the following:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig2.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig2.png" width="500" style="max-width:100%;"></a></p>

<p>Once you submit the input text by clicking "OK," you'll observe that the value you typed is stored in the <code>age</code> variable, which we then <em>output</em> with <code>console.log(..)</code>:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/up &amp; going/fig3.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/up &amp; going/fig3.png" width="500" style="max-width:100%;"></a></p>

<p>To keep things simple while we're learning basic programming concepts, the examples in this book will not require input. But now that you've seen how to use <code>prompt(..)</code>, if you want to challenge yourself you can try to use input in your explorations of the examples.</p>

<h2><a id="user-content-operators" class="anchor" href="#operators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Operators</h2>

<p>Operators are how we perform actions on variables and values. We've already seen two JavaScript operators, the <code>=</code> and the <code>*</code>.</p>

<p>The <code>*</code> operator performs mathematic multiplication. Simple enough, right?</p>

<p>The <code>=</code> equals operator is used for <em>assignment</em> -- we first calculate the value on the <em>right-hand side</em> (source value) of the <code>=</code> and then put it into the variable that we specify on the <em>left-hand side</em> (target variable).</p>

<p><strong>Warning:</strong> This may seem like a strange reverse order to specify assignment. Instead of <code>a = 42</code>, some might prefer to flip the order so the source value is on the left and the target variable is on the right, like <code>42 -&gt; a</code> (this is not valid JavaScript!). Unfortunately, the <code>a = 42</code> ordered form, and similar variations, is quite prevalent in modern programming languages. If it feels unnatural, just spend some time rehearsing that ordering in your mind to get accustomed to it.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
b <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-c1">1</span>;</pre></div>

<p>Here, we assign the <code>2</code> value to the <code>a</code> variable. Then, we get the value of the <code>a</code> variable (still <code>2</code>), add <code>1</code> to it resulting in the value <code>3</code>, then store that value in the <code>b</code> variable.</p>

<p>While not technically an operator, you'll need the keyword <code>var</code> in every program, as it's the primary way you <em>declare</em> (aka <em>create</em>) <em>var</em>iables (see "Variables").</p>

<p>You should always declare the variable by name before you use it. But you only need to declare a variable once for each <em>scope</em> (see "Scope"); it can be used as many times after that as needed. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">20</span>;

a <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-c1">1</span>;
a <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 42</span></pre></div>

<p>Here are some of the most common operators in JavaScript:</p>

<ul>
<li>Assignment: <code>=</code> as in <code>a = 2</code>.</li>
<li>Math: <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), and <code>/</code> (division), as in <code>a * 3</code>.</li>
<li>Compound Assignment: <code>+=</code>, <code>-=</code>, <code>*=</code>, and <code>/=</code> are compound operators that combine a math operation with assignment, as in <code>a += 2</code> (same as <code>a = a + 2</code>).</li>
<li>Increment/Decrement: <code>++</code> (increment), <code>--</code> (decrement), as in <code>a++</code> (similar to <code>a = a + 1</code>).</li>
<li><p>Object Property Access: <code>.</code> as in <code>console.log()</code>.</p>

<p>Objects are values that hold other values at specific named locations called properties. <code>obj.a</code> means an object value called <code>obj</code> with a property of the name <code>a</code>. Properties can alternatively be accessed as <code>obj["a"]</code>. See Chapter 2.</p></li>
<li><p>Equality: <code>==</code> (loose-equals), <code>===</code> (strict-equals), <code>!=</code> (loose not-equals), <code>!==</code> (strict not-equals), as in <code>a == b</code>.</p>

<p>See "Values &amp; Types" and Chapter 2.</p></li>
<li><p>Comparison: <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or loose-equals), <code>&gt;=</code> (greater than or loose-equals), as in <code>a &lt;= b</code>.</p>

<p>See "Values &amp; Types" and Chapter 2.</p></li>
<li><p>Logical: <code>&amp;&amp;</code> (and), <code>||</code> (or), as in <code>a || b</code> that selects either <code>a</code> <em>or</em> <code>b</code>.</p>

<p>These operators are used to express compound conditionals (see "Conditionals"), like if either <code>a</code> <em>or</em> <code>b</code> is true.</p></li>
</ul>

<p><strong>Note:</strong> For much more detail, and coverage of operators not mentioned here, see the Mozilla Developer Network (MDN)'s "Expressions and Operators" (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators</a>).</p>

<h2><a id="user-content-values--types" class="anchor" href="#values--types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Values &amp; Types</h2>

<p>If you ask an employee at a phone store how much a certain phone costs, and they say "ninety-nine, ninety-nine" (i.e., $99.99), they're giving you an actual numeric dollar figure that represents what you'll need to pay (plus taxes) to buy it. If you want to buy two of those phones, you can easily do the mental math to double that value to get $199.98 for your base cost.</p>

<p>If that same employee picks up another similar phone but says it's "free" (perhaps with air quotes), they're not giving you a number, but instead another kind of representation of your expected cost ($0.00) -- the word "free."</p>

<p>When you later ask if the phone includes a charger, that answer could only have been either "yes" or "no."</p>

<p>In very similar ways, when you express values in a program, you choose different representations for those values based on what you plan to do with them.</p>

<p>These different representations for values are called <em>types</em> in programming terminology. JavaScript has built-in types for each of these so called <em>primitive</em> values:</p>

<ul>
<li>When you need to do math, you want a <code>number</code>.</li>
<li>When you need to print a value on the screen, you need a <code>string</code> (one or more characters, words, sentences).</li>
<li>When you need to make a decision in your program, you need a <code>boolean</code> (<code>true</code> or <code>false</code>).</li>
</ul>

<p>Values that are included directly in the source code are called <em>literals</em>. <code>string</code> literals are surrounded by double quotes <code>"..."</code> or single quotes (<code>'...'</code>) -- the only difference is stylistic preference. <code>number</code> and <code>boolean</code> literals are just presented as is (i.e., <code>42</code>, <code>true</code>, etc.).</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-s"><span class="pl-pds">"</span>I am a string<span class="pl-pds">"</span></span>;
<span class="pl-s"><span class="pl-pds">'</span>I am also a string<span class="pl-pds">'</span></span>;

<span class="pl-c1">42</span>;

<span class="pl-c1">true</span>;
<span class="pl-c1">false</span>;</pre></div>

<p>Beyond <code>string</code>/<code>number</code>/<code>boolean</code> value types, it's common for programming languages to provide <em>arrays</em>, <em>objects</em>, <em>functions</em>, and more. We'll cover much more about values and types throughout this chapter and the next.</p>

<h3><a id="user-content-converting-between-types" class="anchor" href="#converting-between-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Converting Between Types</h3>

<p>If you have a <code>number</code> but need to print it on the screen, you need to convert the value to a <code>string</code>, and in JavaScript this conversion is called "coercion." Similarly, if someone enters a series of numeric characters into a form on an ecommerce page, that's a <code>string</code>, but if you need to then use that value to do math operations, you need to <em>coerce</em> it to a <code>number</code>.</p>

<p>JavaScript provides several different facilities for forcibly coercing between <em>types</em>. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Number</span>( a );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// "42"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );   <span class="pl-c">// 42</span></pre></div>

<p>Using <code>Number(..)</code> (a built-in function) as shown is an <em>explicit</em> coercion from any other type to the <code>number</code> type. That should be pretty straightforward.</p>

<p>But a controversial topic is what happens when you try to compare two values that are not already of the same type, which would require <em>implicit</em> coercion.</p>

<p>When comparing the string <code>"99.99"</code> to the number <code>99.99</code>, most people would agree they are equivalent. But they're not exactly the same, are they? It's the same value in two different representations, two different <em>types</em>. You could say they're "loosely equal," couldn't you?</p>

<p>To help you out in these common situations, JavaScript will sometimes kick in and <em>implicitly</em> coerce values to the matching types.</p>

<p>So if you use the <code>==</code> loose equals operator to make the comparison <code>"99.99" == 99.99</code>, JavaScript will convert the left-hand side <code>"99.99"</code> to its <code>number</code> equivalent <code>99.99</code>. The comparison then becomes <code>99.99 == 99.99</code>, which is of course <code>true</code>.</p>

<p>While designed to help you, implicit coercion can create confusion if you haven't taken the time to learn the rules that govern its behavior. Most JS developers never have, so the common feeling is that implicit coercion is confusing and harms programs with unexpected bugs, and should thus be avoided. It's even sometimes called a flaw in the design of the language.</p>

<p>However, implicit coercion is a mechanism that <em>can be learned</em>, and moreover <em>should be learned</em> by anyone wishing to take JavaScript programming seriously. Not only is it not confusing once you learn the rules, it can actually make your programs better! The effort is well worth it.</p>

<p><strong>Note:</strong> For more information on coercion, see Chapter 2 of this title and Chapter 4 of the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-code-comments" class="anchor" href="#code-comments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code Comments</h2>

<p>The phone store employee might jot down some notes on the features of a newly released phone or on the new plans her company offers. These notes are only for the employee -- they're not for customers to read. Nevertheless, these notes help the employee do her job better by documenting the hows and whys of what she should tell customers.</p>

<p>One of the most important lessons you can learn about writing code is that it's not just for the computer. Code is every bit as much, if not more, for the developer as it is for the compiler.</p>

<p>Your computer only cares about machine code, a series of binary 0s and 1s, that comes from <em>compilation</em>. There's a nearly infinite number of programs you could write that yield the same series of 0s and 1s. The choices you make about how to write your program matter -- not only to you, but to your other team members and even to your future self.</p>

<p>You should strive not just to write programs that work correctly, but programs that make sense when examined. You can go a long way in that effort by choosing good names for your variables (see "Variables") and functions (see "Functions").</p>

<p>But another important part is code comments. These are bits of text in your program that are inserted purely to explain things to a human. The interpreter/compiler will always ignore these comments.</p>

<p>There are lots of opinions on what makes well-commented code; we can't really define absolute universal rules. But some observations and guidelines are quite useful:</p>

<ul>
<li>Code without comments is suboptimal.</li>
<li>Too many comments (one per line, for example) is probably a sign of poorly written code.</li>
<li>Comments should explain <em>why</em>, not <em>what</em>. They can optionally explain <em>how</em> if that's particularly confusing.</li>
</ul>

<p>In JavaScript, there are two types of comments possible: a single-line comment and a multiline comment.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// This is a single-line comment</span>

<span class="pl-c">/* But this is</span>
<span class="pl-c">       a multiline</span>
<span class="pl-c">             comment.</span>
<span class="pl-c">                      */</span></pre></div>

<p>The <code>//</code> single-line comment is appropriate if you're going to put a comment right above a single statement, or even at the end of a line. Everything on the line after the <code>//</code> is treated as the comment (and thus ignored by the compiler), all the way to the end of the line. There's no restriction to what can appear inside a single-line comment.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;     <span class="pl-c">// 42 is the meaning of life</span></pre></div>

<p>The <code>/* .. */</code> multiline comment is appropriate if you have several lines worth of explanation to make in your comment.</p>

<p>Here's a common usage of multiline comments:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">/* The following value is used because</span>
<span class="pl-c">   it has been shown that it answers</span>
<span class="pl-c">   every question in the universe. */</span>
<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;</pre></div>

<p>It can also appear anywhere on a line, even in the middle of a line, because the <code>*/</code> ends it. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c">/* arbitrary value */</span> <span class="pl-c1">42</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 42</span></pre></div>

<p>The only thing that cannot appear inside a multiline comment is a <code>*/</code>, because that would be interpreted to end the comment.</p>

<p>You will definitely want to begin your learning of programming by starting off with the habit of commenting code. Throughout the rest of this chapter, you'll see I use comments to explain things, so do the same in your own practice. Trust me, everyone who reads your code will thank you!</p>

<h2><a id="user-content-variables" class="anchor" href="#variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variables</h2>

<p>Most useful programs need to track a value as it changes over the course of the program, undergoing different operations as called for by your program's intended tasks.</p>

<p>The easiest way to go about that in your program is to assign a value to a symbolic container, called a <em>variable</em> -- so called because the value in this container can <em>vary</em> over time as needed.</p>

<p>In some programming languages, you declare a variable (container) to hold a specific type of value, such as <code>number</code> or <code>string</code>. <em>Static typing</em>, otherwise known as <em>type enforcement</em>, is typically cited as a benefit for program correctness by preventing unintended value conversions.</p>

<p>Other languages emphasize types for values instead of variables. <em>Weak typing</em>, otherwise known as <em>dynamic typing</em>, allows a variable to hold any type of value at any time. It's typically cited as a benefit for program flexibility by allowing a single variable to represent a value no matter what type form that value may take at any given moment in the program's logic flow.</p>

<p>JavaScript uses the latter approach, <em>dynamic typing</em>, meaning variables can hold values of any <em>type</em> without any <em>type</em> enforcement.</p>

<p>As mentioned earlier, we declare a variable using the <code>var</code> statement -- notice there's no other <em>type</em> information in the declaration. Consider this simple program:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );      <span class="pl-c">// 199.98</span>

<span class="pl-c">// convert `amount` to a string, and</span>
<span class="pl-c">// add "$" on the beginning</span>
amount <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-c1">String</span>( amount );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );      <span class="pl-c">// "$199.98"</span></pre></div>

<p>The <code>amount</code> variable starts out holding the number <code>99.99</code>, and then holds the <code>number</code> result of <code>amount * 2</code>, which is <code>199.98</code>.</p>

<p>The first <code>console.log(..)</code> command has to <em>implicitly</em> coerce that <code>number</code> value to a <code>string</code> to print it out.</p>

<p>Then the statement <code>amount = "$" + String(amount)</code> <em>explicitly</em> coerces the <code>199.98</code> value to a <code>string</code> and adds a <code>"$"</code> character to the beginning. At this point, <code>amount</code> now holds the <code>string</code> value <code>"$199.98"</code>, so the second <code>console.log(..)</code> statement doesn't need to do any coercion to print it out.</p>

<p>JavaScript developers will note the flexibility of using the <code>amount</code> variable for each of the <code>99.99</code>, <code>199.98</code>, and the <code>"$199.98"</code> values. Static-typing enthusiasts would prefer a separate variable like <code>amountStr</code> to hold the final <code>"$199.98"</code> representation of the value, because it's a different type.</p>

<p>Either way, you'll note that <code>amount</code> holds a running value that changes over the course of the program, illustrating the primary purpose of variables: managing program <em>state</em>.</p>

<p>In other words, <em>state</em> is tracking the changes to values as your program runs.</p>

<p>Another common usage of variables is for centralizing value setting. This is more typically called <em>constants</em>, when you declare a variable with a value and intend for that value to <em>not change</em> throughout the program.</p>

<p>You declare these <em>constants</em>, often at the top of a program, so that it's convenient for you to have one place to go to alter a value if you need to. By convention, JavaScript variables as constants are usually capitalized, with underscores <code>_</code> between multiple words.</p>

<p>Here's a silly example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-c1">TAX_RATE</span> <span class="pl-k">=</span> <span class="pl-c1">0.08</span>;    <span class="pl-c">// 8% sales tax</span>

<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;

amount <span class="pl-k">=</span> amount <span class="pl-k">+</span> (amount <span class="pl-k">*</span> <span class="pl-c1">TAX_RATE</span>);

<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );              <span class="pl-c">// 215.9784</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount.toFixed( <span class="pl-c1">2</span> ) ); <span class="pl-c">// "215.98"</span></pre></div>

<p><strong>Note:</strong> Similar to how <code>console.log(..)</code> is a function <code>log(..)</code> accessed as an object property on the <code>console</code> value, <code>toFixed(..)</code> here is a function that can be accessed on <code>number</code> values. JavaScript <code>number</code>s aren't automatically formatted for dollars -- the engine doesn't know what your intent is and there's no type for currency. <code>toFixed(..)</code> lets us specify how many decimal places we'd like the <code>number</code> rounded to, and it produces the <code>string</code> as necessary.</p>

<p>The <code>TAX_RATE</code> variable is only <em>constant</em> by convention -- there's nothing special in this program that prevents it from being changed. But if the city raises the sales tax rate to 9%, we can still easily update our program by setting the <code>TAX_RATE</code> assigned value to <code>0.09</code> in one place, instead of finding many occurrences of the value <code>0.08</code> strewn throughout the program and updating all of them.</p>

<p>The newest version of JavaScript at the time of this writing (commonly called "ES6") includes a new way to declare <em>constants</em>, by using <code>const</code> instead of <code>var</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// as of ES6:</span>
<span class="pl-k">const</span> <span class="pl-c1">TAX_RATE</span> <span class="pl-k">=</span> <span class="pl-c1">0.08</span>;

<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

<span class="pl-c">// ..</span></pre></div>

<p>Constants are useful just like variables with unchanged values, except that constants also prevent accidentally changing value somewhere else after the initial setting. If you tried to assign any different value to <code>TAX_RATE</code> after that first declaration, your program would reject the change (and in strict mode, fail with an error -- see "Strict Mode" in Chapter 2).</p>

<p>By the way, that kind of "protection" against mistakes is similar to the static-typing type enforcement, so you can see why static types in other languages can be attractive!</p>

<p><strong>Note:</strong> For more information about how different values in variables can be used in your programs, see the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-blocks" class="anchor" href="#blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blocks</h2>

<p>The phone store employee must go through a series of steps to complete the checkout as you buy your new phone.</p>

<p>Similarly, in code we often need to group a series of statements together, which we often call a <em>block</em>. In JavaScript, a block is defined by wrapping one or more statements inside a curly-brace pair <code>{ .. }</code>. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

<span class="pl-c">// a general block</span>
{
    amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );  <span class="pl-c">// 199.98</span>
}</pre></div>

<p>This kind of standalone <code>{ .. }</code> general block is valid, but isn't as commonly seen in JS programs. Typically, blocks are attached to some other control statement, such as an <code>if</code> statement (see "Conditionals") or a loop (see "Loops"). For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

<span class="pl-c">// is amount big enough?</span>
<span class="pl-k">if</span> (amount <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>) {          <span class="pl-c">// &lt;-- block attached to `if`</span>
    amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );  <span class="pl-c">// 199.98</span>
}</pre></div>

<p>We'll explain <code>if</code> statements in the next section, but as you can see, the <code>{ .. }</code> block with its two statements is attached to <code>if (amount &gt; 10)</code>; the statements inside the block will only be processed if the conditional passes.</p>

<p><strong>Note:</strong> Unlike most other statements like <code>console.log(amount);</code>, a block statement does not need a semicolon (<code>;</code>) to conclude it.</p>

<h2><a id="user-content-conditionals" class="anchor" href="#conditionals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conditionals</h2>

<p>"Do you want to add on the extra screen protectors to your purchase, for $9.99?" The helpful phone store employee has asked you to make a decision. And you may need to first consult the current <em>state</em> of your wallet or bank account to answer that question. But obviously, this is just a simple "yes or no" question.</p>

<p>There are quite a few ways we can express <em>conditionals</em> (aka decisions) in our programs.</p>

<p>The most common one is the <code>if</code> statement. Essentially, you're saying, "<em>If</em> this condition is true, do the following...". For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> bank_balance <span class="pl-k">=</span> <span class="pl-c1">302.13</span>;
<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

<span class="pl-k">if</span> (amount <span class="pl-k">&lt;</span> bank_balance) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>I want to buy this phone!<span class="pl-pds">"</span></span> );
}</pre></div>

<p>The <code>if</code> statement requires an expression in between the parentheses <code>( )</code> that can be treated as either <code>true</code> or <code>false</code>. In this program, we provided the expression <code>amount &lt; bank_balance</code>, which indeed will either evaluate to <code>true</code> or <code>false</code> depending on the amount in the <code>bank_balance</code> variable.</p>

<p>You can even provide an alternative if the condition isn't true, called an <code>else</code> clause. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">const</span> <span class="pl-c1">ACCESSORY_PRICE</span> <span class="pl-k">=</span> <span class="pl-c1">9.99</span>;

<span class="pl-k">var</span> bank_balance <span class="pl-k">=</span> <span class="pl-c1">302.13</span>;
<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;

<span class="pl-c">// can we afford the extra purchase?</span>
<span class="pl-k">if</span> ( amount <span class="pl-k">&lt;</span> bank_balance ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>I'll take the accessory!<span class="pl-pds">"</span></span> );
    amount <span class="pl-k">=</span> amount <span class="pl-k">+</span> <span class="pl-c1">ACCESSORY_PRICE</span>;
}
<span class="pl-c">// otherwise:</span>
<span class="pl-k">else</span> {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>No, thanks.<span class="pl-pds">"</span></span> );
}</pre></div>

<p>Here, if <code>amount &lt; bank_balance</code> is <code>true</code>, we'll print out <code>"I'll take the accessory!"</code> and add the <code>9.99</code> to our <code>amount</code> variable. Otherwise, the <code>else</code> clause says we'll just politely respond with <code>"No, thanks."</code> and leave <code>amount</code> unchanged.</p>

<p>As we discussed in "Values &amp; Types" earlier, values that aren't already of an expected type are often coerced to that type. The <code>if</code> statement expects a <code>boolean</code>, but if you pass it something that's not already <code>boolean</code>, coercion will occur.</p>

<p>JavaScript defines a list of specific values that are considered "falsy" because when coerced to a <code>boolean</code>, they become <code>false</code> -- these include values like <code>0</code> and <code>""</code>. Any other value not on the "falsy" list is automatically "truthy" -- when coerced to a <code>boolean</code> they become <code>true</code>. Truthy values include things like <code>99.99</code> and <code>"free"</code>. See "Truthy &amp; Falsy" in Chapter 2 for more information.</p>

<p><em>Conditionals</em> exist in other forms besides the <code>if</code>. For example, the <code>switch</code> statement can be used as a shorthand for a series of <code>if..else</code> statements (see Chapter 2). Loops (see "Loops") use a <em>conditional</em> to determine if the loop should keep going or stop.</p>

<p><strong>Note:</strong> For deeper information about the coercions that can occur implicitly in the test expressions of <em>conditionals</em>, see Chapter 4 of the <em>Types &amp; Grammar</em> title of this series.</p>

<h2><a id="user-content-loops" class="anchor" href="#loops" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loops</h2>

<p>During busy times, there's a waiting list for customers who need to speak to the phone store employee. While there's still people on that list, she just needs to keep serving the next customer.</p>

<p>Repeating a set of actions until a certain condition fails -- in other words, repeating only while the condition holds -- is the job of programming loops; loops can take different forms, but they all satisfy this basic behavior.</p>

<p>A loop includes the test condition as well as a block (typically as <code>{ .. }</code>). Each time the loop block executes, that's called an <em>iteration</em>.</p>

<p>For example, the <code>while</code> loop and the <code>do..while</code> loop forms illustrate the concept of repeating a block of statements until a condition no longer evaluates to <code>true</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">while</span> (numOfCustomers <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>How may I help you?<span class="pl-pds">"</span></span> );

    <span class="pl-c">// help the customer...</span>

    numOfCustomers <span class="pl-k">=</span> numOfCustomers <span class="pl-k">-</span> <span class="pl-c1">1</span>;
}

<span class="pl-c">// versus:</span>

<span class="pl-k">do</span> {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>How may I help you?<span class="pl-pds">"</span></span> );

    <span class="pl-c">// help the customer...</span>

    numOfCustomers <span class="pl-k">=</span> numOfCustomers <span class="pl-k">-</span> <span class="pl-c1">1</span>;
} <span class="pl-k">while</span> (numOfCustomers <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>);</pre></div>

<p>The only practical difference between these loops is whether the conditional is tested before the first iteration (<code>while</code>) or after the first iteration (<code>do..while</code>).</p>

<p>In either form, if the conditional tests as <code>false</code>, the next iteration will not run. That means if the condition is initially <code>false</code>, a <code>while</code> loop will never run, but a <code>do..while</code> loop will run just the first time.</p>

<p>Sometimes you are looping for the intended purpose of counting a certain set of numbers, like from <code>0</code> to <code>9</code> (ten numbers). You can do that by setting a loop iteration variable like <code>i</code> at value <code>0</code> and incrementing it by <code>1</code> each iteration.</p>

<p><strong>Warning:</strong> For a variety of historical reasons, programming languages almost always count things in a zero-based fashion, meaning starting with <code>0</code> instead of <code>1</code>. If you're not familiar with that mode of thinking, it can be quite confusing at first. Take some time to practice counting starting with <code>0</code> to become more comfortable with it!</p>

<p>The conditional is tested on each iteration, much as if there is an implied <code>if</code> statement inside the loop.</p>

<p>We can use JavaScript's <code>break</code> statement to stop a loop. Also, we can observe that it's awfully easy to create a loop that would otherwise run forever without a <code>break</code>ing mechanism.</p>

<p>Let's illustrate:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-c">// a `while..true` loop would run forever, right?</span>
<span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
    <span class="pl-c">// stop the loop?</span>
    <span class="pl-k">if</span> ((i <span class="pl-k">&lt;=</span> <span class="pl-c1">9</span>) <span class="pl-k">===</span> <span class="pl-c1">false</span>) {
        <span class="pl-k">break</span>;
    }

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    i <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}
<span class="pl-c">// 0 1 2 3 4 5 6 7 8 9</span></pre></div>

<p><strong>Warning:</strong> This is not necessarily a practical form you'd want to use for your loops. It's presented here for illustration purposes only.</p>

<p>While a <code>while</code> (or <code>do..while</code>) can accomplish the task manually, there's another syntactic form called a <code>for</code> loop for just that purpose:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;=</span> <span class="pl-c1">9</span>; i <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}
<span class="pl-c">// 0 1 2 3 4 5 6 7 8 9</span></pre></div>

<p>As you can see, in both cases the conditional <code>i &lt;= 9</code> is <code>true</code> for the first 10 iterations (<code>i</code> of values <code>0</code> through <code>9</code>) of either loop form, but becomes <code>false</code> once <code>i</code> is value <code>10</code>.</p>

<p>The <code>for</code> loop has three clauses: the initialization clause (<code>var i=0</code>), the conditional test clause (<code>i &lt;= 9</code>), and the update clause (<code>i = i + 1</code>). So if you're going to do counting with your loop iterations, <code>for</code> is a more compact and often easier form to understand and write.</p>

<p>There are other specialized loop forms that are intended to iterate over specific values, such as the properties of an object (see Chapter 2) where the implied conditional test is just whether all the properties have been processed. The "loop until a condition fails" concept holds no matter what the form of the loop.</p>

<h2><a id="user-content-functions" class="anchor" href="#functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions</h2>

<p>The phone store employee probably doesn't carry around a calculator to figure out the taxes and final purchase amount. That's a task she needs to define once and reuse over and over again. Odds are, the company has a checkout register (computer, tablet, etc.) with those "functions" built in.</p>

<p>Similarly, your program will almost certainly want to break up the code's tasks into reusable pieces, instead of repeatedly repeating yourself repetitiously (pun intended!). The way to do this is to define a <code>function</code>.</p>

<p>A function is generally a named section of code that can be "called" by name, and the code inside it will be run each time. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">printAmount</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( amount.toFixed( <span class="pl-c1">2</span> ) );
}

<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

printAmount(); <span class="pl-c">// "99.99"</span>

amount <span class="pl-k">=</span> amount <span class="pl-k">*</span> <span class="pl-c1">2</span>;

printAmount(); <span class="pl-c">// "199.98"</span></pre></div>

<p>Functions can optionally take arguments (aka parameters) -- values you pass in. And they can also optionally return a value back.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">printAmount</span>(<span class="pl-smi">amt</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( amt.toFixed( <span class="pl-c1">2</span> ) );
}

<span class="pl-k">function</span> <span class="pl-en">formatAmount</span>() {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span> <span class="pl-k">+</span> amount.toFixed( <span class="pl-c1">2</span> );
}

<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

printAmount( amount <span class="pl-k">*</span> <span class="pl-c1">2</span> );      <span class="pl-c">// "199.98"</span>

amount <span class="pl-k">=</span> formatAmount();
<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount );          <span class="pl-c">// "$99.99"</span></pre></div>

<p>The function <code>printAmount(..)</code> takes a parameter that we call <code>amt</code>. The function <code>formatAmount()</code> returns a value. Of course, you can also combine those two techniques in the same function.</p>

<p>Functions are often used for code that you plan to call multiple times, but they can also be useful just to organize related bits of code into named collections, even if you only plan to call them once.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">const</span> <span class="pl-c1">TAX_RATE</span> <span class="pl-k">=</span> <span class="pl-c1">0.08</span>;

<span class="pl-k">function</span> <span class="pl-en">calculateFinalPurchaseAmount</span>(<span class="pl-smi">amt</span>) {
    <span class="pl-c">// calculate the new amount with the tax</span>
    amt <span class="pl-k">=</span> amt <span class="pl-k">+</span> (amt <span class="pl-k">*</span> <span class="pl-c1">TAX_RATE</span>);

    <span class="pl-c">// return the new amount</span>
    <span class="pl-k">return</span> amt;
}

<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;

amount <span class="pl-k">=</span> calculateFinalPurchaseAmount( amount );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( amount.toFixed( <span class="pl-c1">2</span> ) );     <span class="pl-c">// "107.99"</span></pre></div>

<p>Although <code>calculateFinalPurchaseAmount(..)</code> is only called once, organizing its behavior into a separate named function makes the code that uses its logic (the <code>amount = calculateFinal...</code> statement) cleaner. If the function had more statements in it, the benefits would be even more pronounced.</p>

<h3><a id="user-content-scope" class="anchor" href="#scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope</h3>

<p>If you ask the phone store employee for a phone model that her store doesn't carry, she will not be able to sell you the phone you want. She only has access to the phones in her store's inventory. You'll have to try another store to see if you can find the phone you're looking for.</p>

<p>Programming has a term for this concept: <em>scope</em> (technically called <em>lexical scope</em>). In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. Only code inside that function can access that function's <em>scoped</em> variables.</p>

<p>A variable name has to be unique within the same scope -- there can't be two different <code>a</code> variables sitting right next to each other. But the same variable name <code>a</code> could appear in different scopes.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">one</span>() {
    <span class="pl-c">// this `a` only belongs to the `one()` function</span>
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-k">function</span> <span class="pl-en">two</span>() {
    <span class="pl-c">// this `a` only belongs to the `two()` function</span>
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

one();      <span class="pl-c">// 1</span>
two();      <span class="pl-c">// 2</span></pre></div>

<p>Also, a scope can be nested inside another scope, just like if a clown at a birthday party blows up one balloon inside another balloon. If one scope is nested inside another, code inside the innermost scope can access variables from either scope.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">outer</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;

    <span class="pl-k">function</span> <span class="pl-en">inner</span>() {
        <span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

        <span class="pl-c">// we can access both `a` and `b` here</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b );   <span class="pl-c">// 3</span>
    }

    inner();

    <span class="pl-c">// we can only access `a` here</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );           <span class="pl-c">// 1</span>
}

outer();</pre></div>

<p>Lexical scope rules say that code in one scope can access variables of either that scope or any scope outside of it.</p>

<p>So, code inside the <code>inner()</code> function has access to both variables <code>a</code> and <code>b</code>, but code only in <code>outer()</code> has access only to <code>a</code> -- it cannot access <code>b</code> because that variable is only inside <code>inner()</code>.</p>

<p>Recall this code snippet from earlier:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">const</span> <span class="pl-c1">TAX_RATE</span> <span class="pl-k">=</span> <span class="pl-c1">0.08</span>;

<span class="pl-k">function</span> <span class="pl-en">calculateFinalPurchaseAmount</span>(<span class="pl-smi">amt</span>) {
    <span class="pl-c">// calculate the new amount with the tax</span>
    amt <span class="pl-k">=</span> amt <span class="pl-k">+</span> (amt <span class="pl-k">*</span> <span class="pl-c1">TAX_RATE</span>);

    <span class="pl-c">// return the new amount</span>
    <span class="pl-k">return</span> amt;
}</pre></div>

<p>The <code>TAX_RATE</code> constant (variable) is accessible from inside the <code>calculateFinalPurchaseAmount(..)</code> function, even though we didn't pass it in, because of lexical scope.</p>

<p><strong>Note:</strong> For more information about lexical scope, see the first three chapters of the <em>Scope &amp; Closures</em> title of this series.</p>

<h2><a id="user-content-practice" class="anchor" href="#practice" aria-hidden="true"><span class="octicon octicon-link"></span></a>Practice</h2>

<p>There is absolutely no substitute for practice in learning programming. No amount of articulate writing on my part is alone going to make you a programmer.</p>

<p>With that in mind, let's try practicing some of the concepts we learned here in this chapter. I'll give the "requirements," and you try it first. Then consult the code listing below to see how I approached it.</p>

<ul>
<li>Write a program to calculate the total price of your phone purchase. You will keep purchasing phones (hint: loop!) until you run out of money in your bank account. You'll also buy accessories for each phone as long as your purchase amount is below your mental spending threshold.</li>
<li>After you've calculated your purchase amount, add in the tax, then print out the calculated purchase amount, properly formatted.</li>
<li>Finally, check the amount against your bank account balance to see if you can afford it or not.</li>
<li>You should set up some constants for the "tax rate," "phone price," "accessory price," and "spending threshold," as well as a variable for your "bank account balance.""</li>
<li>You should define functions for calculating the tax and for formatting the price with a "$" and rounding to two decimal places.</li>
<li><strong>Bonus Challenge:</strong> Try to incorporate input into this program, perhaps with the <code>prompt(..)</code> covered in "Input" earlier. You may prompt the user for their bank account balance, for example. Have fun and be creative!</li>
</ul>

<p>OK, go ahead. Try it. Don't peek at my code listing until you've given it a shot yourself!</p>

<p><strong>Note:</strong> Because this is a JavaScript book, I'm obviously going to solve the practice exercise in JavaScript. But you can do it in another language for now if you feel more comfortable.</p>

<p>Here's my JavaScript solution for this exercise:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">const</span> <span class="pl-c1">SPENDING_THRESHOLD</span> <span class="pl-k">=</span> <span class="pl-c1">200</span>;
<span class="pl-k">const</span> <span class="pl-c1">TAX_RATE</span> <span class="pl-k">=</span> <span class="pl-c1">0.08</span>;
<span class="pl-k">const</span> <span class="pl-c1">PHONE_PRICE</span> <span class="pl-k">=</span> <span class="pl-c1">99.99</span>;
<span class="pl-k">const</span> <span class="pl-c1">ACCESSORY_PRICE</span> <span class="pl-k">=</span> <span class="pl-c1">9.99</span>;

<span class="pl-k">var</span> bank_balance <span class="pl-k">=</span> <span class="pl-c1">303.91</span>;
<span class="pl-k">var</span> amount <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">function</span> <span class="pl-en">calculateTax</span>(<span class="pl-smi">amount</span>) {
    <span class="pl-k">return</span> amount <span class="pl-k">*</span> <span class="pl-c1">TAX_RATE</span>;
}

<span class="pl-k">function</span> <span class="pl-en">formatAmount</span>(<span class="pl-smi">amount</span>) {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>$<span class="pl-pds">"</span></span> <span class="pl-k">+</span> amount.toFixed( <span class="pl-c1">2</span> );
}

<span class="pl-c">// keep buying phones while you still have money</span>
<span class="pl-k">while</span> (amount <span class="pl-k">&lt;</span> bank_balance) {
    <span class="pl-c">// buy a new phone!</span>
    amount <span class="pl-k">=</span> amount <span class="pl-k">+</span> <span class="pl-c1">PHONE_PRICE</span>;

    <span class="pl-c">// can we afford the accessory?</span>
    <span class="pl-k">if</span> (amount <span class="pl-k">&lt;</span> <span class="pl-c1">SPENDING_THRESHOLD</span>) {
        amount <span class="pl-k">=</span> amount <span class="pl-k">+</span> <span class="pl-c1">ACCESSORY_PRICE</span>;
    }
}

<span class="pl-c">// don't forget to pay the government, too</span>
amount <span class="pl-k">=</span> amount <span class="pl-k">+</span> calculateTax( amount );

<span class="pl-en">console</span><span class="pl-c1">.log</span>(
    <span class="pl-s"><span class="pl-pds">"</span>Your purchase: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> formatAmount( amount )
);
<span class="pl-c">// Your purchase: $334.76</span>

<span class="pl-c">// can you actually afford this purchase?</span>
<span class="pl-k">if</span> (amount <span class="pl-k">&gt;</span> bank_balance) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(
        <span class="pl-s"><span class="pl-pds">"</span>You can't afford this purchase. :(<span class="pl-pds">"</span></span>
    );
}
<span class="pl-c">// You can't afford this purchase. :(</span></pre></div>

<p><strong>Note:</strong> The simplest way to run this JavaScript program is to type it into the developer console of your nearest browser.</p>

<p>How did you do? It wouldn't hurt to try it again now that you've seen my code. And play around with changing some of the constants to see how the program runs with different values.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Learning programming doesn't have to be a complex and overwhelming process. There are just a few basic concepts you need to wrap your head around.</p>

<p>These act like building blocks. To build a tall tower, you start first by putting block on top of block on top of block. The same goes with programming. Here are some of the essential programming building blocks:</p>

<ul>
<li>You need <em>operators</em> to perform actions on values.</li>
<li>You need values and <em>types</em> to perform different kinds of actions like math on <code>number</code>s or output with <code>string</code>s.</li>
<li>You need <em>variables</em> to store data (aka <em>state</em>) during your program's execution.</li>
<li>You need <em>conditionals</em> like <code>if</code> statements to make decisions.</li>
<li>You need <em>loops</em> to repeat tasks until a condition stops being true.</li>
<li>You need <em>functions</em> to organize your code into logical and reusable chunks.</li>
</ul>

<p>Code comments are one effective way to write more readable code, which makes your program easier to understand, maintain, and fix later if there are problems.</p>

<p>Finally, don't neglect the power of practice. The best way to learn how to write code is to write code.</p>

<p>I'm excited you're well on your way to learning how to code, now! Keep it up. Don't forget to check out other beginner programming resources (books, blogs, online training, etc.). This chapter and this book are a great start, but they're just a brief introduction.</p>

<p>The next chapter will review many of the concepts from this chapter, but from a more JavaScript-specific perspective, which will highlight most of the major topics that are addressed in deeper detail throughout the rest of the series.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-chapter-1-what-is-scope" class="anchor" href="#chapter-1-what-is-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: What is Scope?</h1>

<p>One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the ability to store values and pull values out of variables is what gives a program <em>state</em>.</p>

<p>Without such a concept, a program could perform some tasks, but they would be extremely limited and not terribly interesting.</p>

<p>But the inclusion of variables into our program begets the most interesting questions we will now address: where do those variables <em>live</em>? In other words, where are they stored? And, most importantly, how does our program find them when it needs them?</p>

<p>These questions speak to the need for a well-defined set of rules for storing variables in some location, and for finding those variables at a later time. We'll call that set of rules: <em>Scope</em>.</p>

<p>But, where and how do these <em>Scope</em> rules get set?</p>

<h2><a id="user-content-compiler-theory" class="anchor" href="#compiler-theory" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiler Theory</h2>

<p>It may be self-evident, or it may be surprising, depending on your level of interaction with various languages, but despite the fact that JavaScript falls under the general category of "dynamic" or "interpreted" languages, it is in fact a compiled language. It is <em>not</em> compiled well in advance, as are many traditionally-compiled languages, nor are the results of compilation portable among various distributed systems.</p>

<p>But, nevertheless, the JavaScript engine performs many of the same steps, albeit in more sophisticated ways than we may commonly be aware, of any traditional language-compiler.</p>

<p>In traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps <em>before</em> it is executed, roughly called "compilation":</p>

<ol>
<li><p><strong>Tokenizing/Lexing:</strong> breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code>var a = 2;</code>. This program would likely be broken up into the following tokens: <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, and <code>;</code>. Whitespace may or may not be persisted as a token, depending on whether it's meaningful or not.</p>

<p><strong>Note:</strong> The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a <em>stateless</em> or <em>stateful</em> way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code>a</code> should be considered a distinct token or just part of another token, <em>that</em> would be <strong>lexing</strong>.</p></li>
<li><p><strong>Parsing:</strong> taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This tree is called an "AST" (<b>A</b>bstract <b>S</b>yntax <b>T</b>ree).</p>

<p>The tree for <code>var a = 2;</code> might start with a top-level node called <code>VariableDeclaration</code>, with a child node called <code>Identifier</code> (whose value is <code>a</code>), and another child called <code>AssignmentExpression</code> which itself has a child called <code>NumericLiteral</code> (whose value is <code>2</code>).</p></li>
<li><p><strong>Code-Generation:</strong> the process of taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it's targeting, etc.</p>

<p>So, rather than get mired in details, we'll just handwave and say that there's a way to take our above described AST for <code>var a = 2;</code> and turn it into a set of machine instructions to actually <em>create</em> a variable called <code>a</code> (including reserving memory, etc.), and then store a value into <code>a</code>.</p>

<p><strong>Note:</strong> The details of how the engine manages system resources are deeper than we will dig, so we'll just take it for granted that the engine is able to create and store variables as needed.</p></li>
</ol>

<p>The JavaScript engine is vastly more complex than <em>just</em> those three steps, as are most other language compilers. For instance, in the process of parsing and code-generation, there are certainly steps to optimize the performance of the execution, including collapsing redundant elements, etc.</p>

<p>So, I'm painting only with broad strokes here. But I think you'll see shortly why <em>these</em> details we <em>do</em> cover, even at a high level, are relevant.</p>

<p>For one thing, JavaScript engines don't get the luxury (like other language compilers) of having plenty of time to optimize, because JavaScript compilation doesn't happen in a build step ahead of time, as with other languages.</p>

<p>For JavaScript, the compilation that occurs happens, in many cases, mere microseconds (or less!) before the code is executed. To ensure the fastest performance, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile, etc.) which are well beyond the "scope" of our discussion here.</p>

<p>Let's just say, for simplicity's sake, that any snippet of JavaScript has to be compiled before (usually <em>right</em> before!) it's executed. So, the JS compiler will take the program <code>var a = 2;</code> and compile it <em>first</em>, and then be ready to execute it, usually right away.</p>

<h2><a id="user-content-understanding-scope" class="anchor" href="#understanding-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Understanding Scope</h2>

<p>The way we will approach learning about scope is to think of the process in terms of a conversation. But, <em>who</em> is having the conversation?</p>

<h3><a id="user-content-the-cast" class="anchor" href="#the-cast" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Cast</h3>

<p>Let's meet the cast of characters that interact to process the program <code>var a = 2;</code>, so we understand their conversations that we'll listen in on shortly:</p>

<ol>
<li><p><em>Engine</em>: responsible for start-to-finish compilation and execution of our JavaScript program.</p></li>
<li><p><em>Compiler</em>: one of <em>Engine</em>'s friends; handles all the dirty work of parsing and code-generation (see previous section).</p></li>
<li><p><em>Scope</em>: another friend of <em>Engine</em>; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.</p></li>
</ol>

<p>For you to <em>fully understand</em> how JavaScript works, you need to begin to <em>think</em> like <em>Engine</em> (and friends) think, ask the questions they ask, and answer those questions the same.</p>

<h3><a id="user-content-back--forth" class="anchor" href="#back--forth" aria-hidden="true"><span class="octicon octicon-link"></span></a>Back &amp; Forth</h3>

<p>When you see the program <code>var a = 2;</code>, you most likely think of that as one statement. But that's not how our new friend <em>Engine</em> sees it. In fact, <em>Engine</em> sees two distinct statements, one which <em>Compiler</em> will handle during compilation, and one which <em>Engine</em> will handle during execution.</p>

<p>So, let's break down how <em>Engine</em> and friends will approach the program <code>var a = 2;</code>.</p>

<p>The first thing <em>Compiler</em> will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree. But when <em>Compiler</em> gets to code-generation, it will treat this program somewhat differently than perhaps assumed.</p>

<p>A reasonable assumption would be that <em>Compiler</em> will produce code that could be summed up by this pseudo-code: "Allocate memory for a variable, label it <code>a</code>, then stick the value <code>2</code> into that variable." Unfortunately, that's not quite accurate.</p>

<p><em>Compiler</em> will instead proceed as:</p>

<ol>
<li><p>Encountering <code>var a</code>, <em>Compiler</em> asks <em>Scope</em> to see if a variable <code>a</code> already exists for that particular scope collection. If so, <em>Compiler</em> ignores this declaration and moves on. Otherwise, <em>Compiler</em> asks <em>Scope</em> to declare a new variable called <code>a</code> for that scope collection.</p></li>
<li><p><em>Compiler</em> then produces code for <em>Engine</em> to later execute, to handle the <code>a = 2</code> assignment. The code <em>Engine</em> runs will first ask <em>Scope</em> if there is a variable called <code>a</code> accessible in the current scope collection. If so, <em>Engine</em> uses that variable. If not, <em>Engine</em> looks <em>elsewhere</em> (see nested <em>Scope</em> section below).</p></li>
</ol>

<p>If <em>Engine</em> eventually finds a variable, it assigns the value <code>2</code> to it. If not, <em>Engine</em> will raise its hand and yell out an error!</p>

<p>To summarize: two distinct actions are taken for a variable assignment: First, <em>Compiler</em> declares a variable (if not previously declared in the current scope), and second, when executing, <em>Engine</em> looks up the variable in <em>Scope</em> and assigns to it, if found.</p>

<h3><a id="user-content-compiler-speak" class="anchor" href="#compiler-speak" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiler Speak</h3>

<p>We need a little bit more compiler terminology to proceed further with understanding.</p>

<p>When <em>Engine</em> executes the code that <em>Compiler</em> produced for step (2), it has to look-up the variable <code>a</code> to see if it has been declared, and this look-up is consulting <em>Scope</em>. But the type of look-up <em>Engine</em> performs affects the outcome of the look-up.</p>

<p>In our case, it is said that <em>Engine</em> would be performing an "LHS" look-up for the variable <code>a</code>. The other type of look-up is called "RHS".</p>

<p>I bet you can guess what the "L" and "R" mean. These terms stand for "Left-hand Side" and "Right-hand Side".</p>

<p>Side... of what? <strong>Of an assignment operation.</strong></p>

<p>In other words, an LHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation.</p>

<p>Actually, let's be a little more precise. An RHS look-up is indistinguishable, for our purposes, from simply a look-up of the value of some variable, whereas the LHS look-up is trying to find the variable container itself, so that it can assign. In this way, RHS doesn't <em>really</em> mean "right-hand side of an assignment" per se, it just, more accurately, means "not left-hand side".</p>

<p>Being slightly glib for a moment, you could also think "RHS" instead means "retrieve his/her source (value)", implying that RHS means "go get the value of...".</p>

<p>Let's dig into that deeper.</p>

<p>When I say:</p>

<div class="highlight highlight-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( a );</pre></div>

<p>The reference to <code>a</code> is an RHS reference, because nothing is being assigned to <code>a</code> here. Instead, we're looking-up to retrieve the value of <code>a</code>, so that the value can be passed to <code>console.log(..)</code>.</p>

<p>By contrast:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> <span class="pl-c1">2</span>;</pre></div>

<p>The reference to <code>a</code> here is an LHS reference, because we don't actually care what the current value is, we simply want to find the variable as a target for the <code>= 2</code> assignment operation.</p>

<p><strong>Note:</strong> LHS and RHS meaning "left/right-hand side of an assignment" doesn't necessarily literally mean "left/right side of the <code>=</code> assignment operator". There are several other ways that assignments happen, and so it's better to conceptually think about it as: "who's the target of the assignment (LHS)" and "who's the source of the assignment (RHS)".</p>

<p>Consider this program, which has both LHS and RHS references:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

foo( <span class="pl-c1">2</span> );</pre></div>

<p>The last line that invokes <code>foo(..)</code> as a function call requires an RHS reference to <code>foo</code>, meaning, "go look-up the value of <code>foo</code>, and give it to me." Moreover, <code>(..)</code> means the value of <code>foo</code> should be executed, so it'd better actually be a function!</p>

<p>There's a subtle but important assignment here. <strong>Did you spot it?</strong></p>

<p>You may have missed the implied <code>a = 2</code> in this code snippet. It happens when the value <code>2</code> is passed as an argument to the <code>foo(..)</code> function, in which case the <code>2</code> value is <strong>assigned</strong> to the parameter <code>a</code>. To (implicitly) assign to parameter <code>a</code>, an LHS look-up is performed.</p>

<p>There's also an RHS reference for the value of <code>a</code>, and that resulting value is passed to <code>console.log(..)</code>. <code>console.log(..)</code> needs a reference to execute. It's an RHS look-up for the <code>console</code> object, then a property-resolution occurs to see if it has a method called <code>log</code>.</p>

<p>Finally, we can conceptualize that there's an LHS/RHS exchange of passing the value <code>2</code> (by way of variable <code>a</code>'s RHS look-up) into <code>log(..)</code>. Inside of the native implementation of <code>log(..)</code>, we can assume it has parameters, the first of which (perhaps called <code>arg1</code>) has an LHS reference look-up, before assigning <code>2</code> to it.</p>

<p><strong>Note:</strong> You might be tempted to conceptualize the function declaration <code>function foo(a) {...</code> as a normal variable declaration and assignment, such as <code>var foo</code> and <code>foo = function(a){...</code>. In so doing, it would be tempting to think of this function declaration as involving an LHS look-up.</p>

<p>However, the subtle but important difference is that <em>Compiler</em> handles both the declaration and the value definition during code-generation, such that when <em>Engine</em> is executing code, there's no processing necessary to "assign" a function value to <code>foo</code>. Thus, it's not really appropriate to think of a function declaration as an LHS look-up assignment in the way we're discussing them here.</p>

<h3><a id="user-content-enginescope-conversation" class="anchor" href="#enginescope-conversation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Engine/Scope Conversation</h3>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

foo( <span class="pl-c1">2</span> );</pre></div>

<p>Let's imagine the above exchange (which processes this code snippet) as a conversation. The conversation would go a little something like this:</p>

<blockquote>
<p><strong><em>Engine</em></strong>: Hey <em>Scope</em>, I have an RHS reference for <code>foo</code>. Ever heard of it?</p>

<p><strong><em>Scope</em></strong>: Why yes, I have. <em>Compiler</em> declared it just a second ago. He's a function. Here you go.</p>

<p><strong><em>Engine</em></strong>: Great, thanks! OK, I'm executing <code>foo</code>.</p>

<p><strong><em>Engine</em></strong>: Hey, <em>Scope</em>, I've got an LHS reference for <code>a</code>, ever heard of it?</p>

<p><strong><em>Scope</em></strong>: Why yes, I have. <em>Compiler</em> declared it as a formal parameter to <code>foo</code> just recently. Here you go.</p>

<p><strong><em>Engine</em></strong>: Helpful as always, <em>Scope</em>. Thanks again. Now, time to assign <code>2</code> to <code>a</code>.</p>

<p><strong><em>Engine</em></strong>: Hey, <em>Scope</em>, sorry to bother you again. I need an RHS look-up for <code>console</code>. Ever heard of it?</p>

<p><strong><em>Scope</em></strong>: No problem, <em>Engine</em>, this is what I do all day. Yes, I've got <code>console</code>. He's built-in. Here ya go.</p>

<p><strong><em>Engine</em></strong>: Perfect. Looking up <code>log(..)</code>. OK, great, it's a function.</p>

<p><strong><em>Engine</em></strong>: Yo, <em>Scope</em>. Can you help me out with an RHS reference to <code>a</code>. I think I remember it, but just want to double-check.</p>

<p><strong><em>Scope</em></strong>: You're right, <em>Engine</em>. Same guy, hasn't changed. Here ya go.</p>

<p><strong><em>Engine</em></strong>: Cool. Passing the value of <code>a</code>, which is <code>2</code>, into <code>log(..)</code>.</p>

<p>...</p>
</blockquote>

<h3><a id="user-content-quiz" class="anchor" href="#quiz" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quiz</h3>

<p>Check your understanding so far. Make sure to play the part of <em>Engine</em> and have a "conversation" with the <em>Scope</em>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-k">var</span> b <span class="pl-k">=</span> a;
    <span class="pl-k">return</span> a <span class="pl-k">+</span> b;
}

<span class="pl-k">var</span> c <span class="pl-k">=</span> foo( <span class="pl-c1">2</span> );</pre></div>

<ol>
<li><p>Identify all the LHS look-ups (there are 3!).</p></li>
<li><p>Identify all the RHS look-ups (there are 4!).</p></li>
</ol>

<p><strong>Note:</strong> See the chapter review for the quiz answers!</p>

<h2><a id="user-content-nested-scope" class="anchor" href="#nested-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Scope</h2>

<p>We said that <em>Scope</em> is a set of rules for looking up variables by their identifier name. There's usually more than one <em>Scope</em> to consider, however.</p>

<p>Just as a block or function is nested inside another block or function, scopes are nested inside other scopes. So, if a variable cannot be found in the immediate scope, <em>Engine</em> consults the next outer containing scope, continuing until found or until the outermost (aka, global) scope has been reached.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b );
}

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo( <span class="pl-c1">2</span> ); <span class="pl-c">// 4</span></pre></div>

<p>The RHS reference for <code>b</code> cannot be resolved inside the function <code>foo</code>, but it can be resolved in the <em>Scope</em> surrounding it (in this case, the global).</p>

<p>So, revisiting the conversations between <em>Engine</em> and <em>Scope</em>, we'd overhear:</p>

<blockquote>
<p><strong><em>Engine</em></strong>: "Hey, <em>Scope</em> of <code>foo</code>, ever heard of <code>b</code>? Got an RHS reference for it."</p>

<p><strong><em>Scope</em></strong>: "Nope, never heard of it. Go fish."</p>

<p><strong><em>Engine</em></strong>: "Hey, <em>Scope</em> outside of <code>foo</code>, oh you're the global <em>Scope</em>, ok cool. Ever heard of <code>b</code>? Got an RHS reference for it."</p>

<p><strong><em>Scope</em></strong>: "Yep, sure have. Here ya go."</p>
</blockquote>

<p>The simple rules for traversing nested <em>Scope</em>: <em>Engine</em> starts at the currently executing <em>Scope</em>, looks for the variable there, then if not found, keeps going up one level, and so on. If the outermost global scope is reached, the search stops, whether it finds the variable or not.</p>

<h3><a id="user-content-building-on-metaphors" class="anchor" href="#building-on-metaphors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building on Metaphors</h3>

<p>To visualize the process of nested <em>Scope</em> resolution, I want you to think of this tall building.</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/scope &amp; closures/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/scope &amp; closures/fig1.png" width="250" style="max-width:100%;"></a></p>

<p>The building represents our program's nested <em>Scope</em> rule set. The first floor of the building represents your currently executing <em>Scope</em>, wherever you are. The top level of the building is the global <em>Scope</em>.</p>

<p>You resolve LHS and RHS references by looking on your current floor, and if you don't find it, taking the elevator to the next floor, looking there, then the next, and so on. Once you get to the top floor (the global <em>Scope</em>), you either find what you're looking for, or you don't. But you have to stop regardless.</p>

<h2><a id="user-content-errors" class="anchor" href="#errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Errors</h2>

<p>Why does it matter whether we call it LHS or RHS?</p>

<p>Because these two types of look-ups behave differently in the circumstance where the variable has not yet been declared (is not found in any consulted <em>Scope</em>).</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b );
    b <span class="pl-k">=</span> a;
}

foo( <span class="pl-c1">2</span> );</pre></div>

<p>When the RHS look-up occurs for <code>b</code> the first time, it will not be found. This is said to be an "undeclared" variable, because it is not found in the scope.</p>

<p>If an RHS look-up fails to ever find a variable, anywhere in the nested <em>Scope</em>s, this results in a <code>ReferenceError</code> being thrown by the <em>Engine</em>. It's important to note that the error is of the type <code>ReferenceError</code>.</p>

<p>By contrast, if the <em>Engine</em> is performing an LHS look-up, and it arrives at the top floor (global <em>Scope</em>) without finding it, if the program is not running in "Strict Mode" [^note-strictmode], then the global <em>Scope</em> will create a new variable of that name <strong>in the global scope</strong>, and hand it back to <em>Engine</em>.</p>

<p><em>"No, there wasn't one before, but I was helpful and created one for you."</em></p>

<p>"Strict Mode" [^note-strictmode], which was added in ES5, has a number of different behaviors from normal/relaxed/lazy mode. One such behavior is that it disallows the automatic/implicit global variable creation. In that case, there would be no global <em>Scope</em>'d variable to hand back from an LHS look-up, and <em>Engine</em> would throw a <code>ReferenceError</code> similarly to the RHS case.</p>

<p>Now, if a variable is found for an RHS look-up, but you try to do something with its value that is impossible, such as trying to execute-as-function a non-function value, or reference a property on a <code>null</code> or <code>undefined</code> value, then <em>Engine</em> throws a different kind of error, called a <code>TypeError</code>.</p>

<p><code>ReferenceError</code> is <em>Scope</em> resolution-failure related, whereas <code>TypeError</code> implies that <em>Scope</em> resolution was successful, but that there was an illegal/impossible action attempted against the result.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Scope is the set of rules that determines where and how a variable (identifier) can be looked-up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (right-hand-side) reference.</p>

<p>LHS references result from assignment operations. <em>Scope</em>-related assignments can occur either with the <code>=</code> operator or by passing arguments to (assign to) function parameters.</p>

<p>The JavaScript <em>Engine</em> first compiles code before it executes, and in so doing, it splits up statements like <code>var a = 2;</code> into two separate steps:</p>

<ol>
<li><p>First, <code>var a</code> to declare it in that <em>Scope</em>. This is performed at the beginning, before code execution.</p></li>
<li><p>Later, <code>a = 2</code> to look up the variable (LHS reference) and assign to it if found.</p></li>
</ol>

<p>Both LHS and RHS reference look-ups start at the currently executing <em>Scope</em>, and if need be (that is, they don't find what they're looking for there), they work their way up the nested <em>Scope</em>, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or don't.</p>

<p>Unfulfilled RHS references result in <code>ReferenceError</code>s being thrown. Unfulfilled LHS references result in an automatic, implicitly-created global of that name (if not in "Strict Mode" [^note-strictmode]), or a <code>ReferenceError</code> (if in "Strict Mode" [^note-strictmode]).</p>

<h3><a id="user-content-quiz-answers" class="anchor" href="#quiz-answers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quiz Answers</h3>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-k">var</span> b <span class="pl-k">=</span> a;
    <span class="pl-k">return</span> a <span class="pl-k">+</span> b;
}

<span class="pl-k">var</span> c <span class="pl-k">=</span> foo( <span class="pl-c1">2</span> );</pre></div>

<ol>
<li><p>Identify all the LHS look-ups (there are 3!).</p>

<p><strong><code>c = ..</code>, <code>a = 2</code> (implicit param assignment) and <code>b = ..</code></strong></p></li>
<li><p>Identify all the RHS look-ups (there are 4!).</p>

<p><strong><code>foo(2..</code>, <code>= a;</code>, <code>a + ..</code> and <code>.. + b</code></strong></p></li>
</ol>

<p>[^note-strictmode]: MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict Mode</a></p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-chapter-2-lexical-scope" class="anchor" href="#chapter-2-lexical-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: Lexical Scope</h1>

<p>In Chapter 1, we defined "scope" as the set of rules that govern how the <em>Engine</em> can look up a variable by its identifier name and find it, either in the current <em>Scope</em>, or in any of the <em>Nested Scopes</em> it's contained within.</p>

<p>There are two predominant models for how scope works. The first of these is by far the most common, used by the vast majority of programming languages. It's called <strong>Lexical Scope</strong>, and we will examine it in-depth. The other model, which is still used by some languages (such as Bash scripting, some modes in Perl, etc.) is called <strong>Dynamic Scope</strong>.</p>

<p>Dynamic Scope is covered in Appendix A. I mention it here only to provide a contrast with Lexical Scope, which is the scope model that JavaScript employs.</p>

<h2><a id="user-content-lex-time" class="anchor" href="#lex-time" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lex-time</h2>

<p>As we discussed in Chapter 1, the first traditional phase of a standard language compiler is called lexing (aka, tokenizing). If you recall, the lexing process examines a string of source code characters and assigns semantic meaning to the tokens as a result of some stateful parsing.</p>

<p>It is this concept which provides the foundation to understand what lexical scope is and where the name comes from.</p>

<p>To define it somewhat circularly, lexical scope is scope that is defined at lexing time. In other words, lexical scope is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.</p>

<p><strong>Note:</strong> We will see in a little bit there are some ways to cheat lexical scope, thereby modifying it after the lexer has passed by, but these are frowned upon. It is considered best practice to treat lexical scope as, in fact, lexical-only, and thus entirely author-time in nature.</p>

<p>Let's consider this block of code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {

    <span class="pl-k">var</span> b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;

    <span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">c</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );
    }

    bar(b <span class="pl-k">*</span> <span class="pl-c1">3</span>);
}

foo( <span class="pl-c1">2</span> ); <span class="pl-c">// 2 4 12</span></pre></div>

<p>There are three nested scopes inherent in this code example. It may be helpful to think about these scopes as bubbles inside of each other.</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/scope &amp; closures/fig2.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/scope &amp; closures/fig2.png" width="500" style="max-width:100%;"></a></p>

<p><strong>Bubble 1</strong> encompasses the global scope, and has just one identifier in it: <code>foo</code>.</p>

<p><strong>Bubble 2</strong> encompasses the scope of <code>foo</code>, which includes the three identifiers: <code>a</code>, <code>bar</code> and <code>b</code>.</p>

<p><strong>Bubble 3</strong> encompasses the scope of <code>bar</code>, and it includes just one identifier: <code>c</code>.</p>

<p>Scope bubbles are defined by where the blocks of scope are written, which one is nested inside the other, etc. In the next chapter, we'll discuss different units of scope, but for now, let's just assume that each function creates a new bubble of scope.</p>

<p>The bubble for <code>bar</code> is entirely contained within the bubble for <code>foo</code>, because (and only because) that's where we chose to define the function <code>bar</code>.</p>

<p>Notice that these nested bubbles are strictly nested. We're not talking about Venn diagrams where the bubbles can cross boundaries. In other words, no bubble for some function can simultaneously exist (partially) inside two other outer scope bubbles, just as no function can partially be inside each of two parent functions.</p>

<h3><a id="user-content-look-ups" class="anchor" href="#look-ups" aria-hidden="true"><span class="octicon octicon-link"></span></a>Look-ups</h3>

<p>The structure and relative placement of these scope bubbles fully explains to the <em>Engine</em> all the places it needs to look to find an identifier.</p>

<p>In the above code snippet, the <em>Engine</em> executes the <code>console.log(..)</code> statement and goes looking for the three referenced variables <code>a</code>, <code>b</code>, and <code>c</code>. It first starts with the innermost scope bubble, the scope of the <code>bar(..)</code> function. It won't find <code>a</code> there, so it goes up one level, out to the next nearest scope bubble, the scope of <code>foo(..)</code>. It finds <code>a</code> there, and so it uses that <code>a</code>. Same thing for <code>b</code>. But <code>c</code>, it does find inside of <code>bar(..)</code>.</p>

<p>Had there been a <code>c</code> both inside of <code>bar(..)</code> and inside of <code>foo(..)</code>, the <code>console.log(..)</code> statement would have found and used the one in <code>bar(..)</code>, never getting to the one in <code>foo(..)</code>.</p>

<p><strong>Scope look-up stops once it finds the first match</strong>. The same identifier name can be specified at multiple layers of nested scope, which is called "shadowing" (the inner identifier "shadows" the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and works its way outward/upward until the first match, and stops.</p>

<p><strong>Note:</strong> Global variables are also automatically properties of the global object (<code>window</code> in browsers, etc.), so it <em>is</em> possible to reference a global variable not directly by its lexical name, but instead indirectly as a property reference of the global object.</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">window</span>.a</pre></div>

<p>This technique gives access to a global variable which would otherwise be inaccessible due to it being shadowed. However, non-global shadowed variables cannot be accessed.</p>

<p>No matter <em>where</em> a function is invoked from, or even <em>how</em> it is invoked, its lexical scope is <strong>only</strong> defined by where the function was declared.</p>

<p>The lexical scope look-up process <em>only</em> applies to first-class identifiers, such as the <code>a</code>, <code>b</code>, and <code>c</code>. If you had a reference to <code>foo.bar.baz</code> in a piece of code, the lexical scope look-up would apply to finding the <code>foo</code> identifier, but once it locates that variable, object property-access rules take over to resolve the <code>bar</code> and <code>baz</code> properties, respectively.</p>

<h2><a id="user-content-cheating-lexical" class="anchor" href="#cheating-lexical" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cheating Lexical</h2>

<p>If lexical scope is defined only by where a function is declared, which is entirely an author-time decision, how could there possibly be a way to "modify" (aka, cheat) lexical scope at run-time?</p>

<p>JavaScript has two such mechanisms. Both of them are equally frowned-upon in the wider community as bad practices to use in your code. But the typical arguments against them are often missing the most important point: <strong>cheating lexical scope leads to poorer performance.</strong></p>

<p>Before I explain the performance issue, though, let's look at how these two mechanisms work.</p>

<h3><a id="user-content-eval" class="anchor" href="#eval" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>eval</code></h3>

<p>The <code>eval(..)</code> function in JavaScript takes a string as an argument, and treats the contents of the string as if it had actually been authored code at that point in the program. In other words, you can programmatically generate code inside of your authored code, and run the generated code as if it had been there at author time.</p>

<p>Evaluating <code>eval(..)</code> (pun intended) in that light, it should be clear how <code>eval(..)</code> allows you to modify the lexical scope environment by cheating and pretending that author-time (aka, lexical) code was there all along.</p>

<p>On subsequent lines of code after an <code>eval(..)</code> has executed, the <em>Engine</em> will not "know" or "care" that the previous code in question was dynamically interpreted and thus modified the lexical scope environment. The <em>Engine</em> will simply perform its lexical scope look-ups as it always does.</p>

<p>Consider the following code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">str</span>, <span class="pl-smi">a</span>) {
    <span class="pl-c1">eval</span>( str ); <span class="pl-c">// cheating!</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b );
}

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo( <span class="pl-s"><span class="pl-pds">"</span>var b = 3;<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span> ); <span class="pl-c">// 1, 3</span></pre></div>

<p>The string <code>"var b = 3;"</code> is treated, at the point of the <code>eval(..)</code> call, as code that was there all along. Because that code happens to declare a new variable <code>b</code>, it modifies the existing lexical scope of <code>foo(..)</code>. In fact, as mentioned above, this code actually creates variable <code>b</code> inside of <code>foo(..)</code> that shadows the <code>b</code> that was declared in the outer (global) scope.</p>

<p>When the <code>console.log(..)</code> call occurs, it finds both <code>a</code> and <code>b</code> in the scope of <code>foo(..)</code>, and never finds the outer <code>b</code>. Thus, we print out "1, 3" instead of "1, 2" as would have normally been the case.</p>

<p><strong>Note:</strong> In this example, for simplicity's sake, the string of "code" we pass in was a fixed literal. But it could easily have been programmatically created by adding characters together based on your program's logic. <code>eval(..)</code> is usually used to execute dynamically created code, as dynamically evaluating essentially static code from a string literal would provide no real benefit to just authoring the code directly.</p>

<p>By default, if a string of code that <code>eval(..)</code> executes contains one or more declarations (either variables or functions), this action modifies the existing lexical scope in which the <code>eval(..)</code> resides. Technically, <code>eval(..)</code> can be invoked "indirectly", through various tricks (beyond our discussion here), which causes it to instead execute in the context of the global scope, thus modifying it. But in either case, <code>eval(..)</code> can at runtime modify an author-time lexical scope.</p>

<p><strong>Note:</strong> <code>eval(..)</code> when used in a strict-mode program operates in its own lexical scope, which means declarations made inside of the <code>eval()</code> do not actually modify the enclosing scope.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">str</span>) {
   <span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;
   <span class="pl-c1">eval</span>( str );
   <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError: a is not defined</span>
}

foo( <span class="pl-s"><span class="pl-pds">"</span>var a = 2<span class="pl-pds">"</span></span> );</pre></div>

<p>There are other facilities in JavaScript which amount to a very similar effect to <code>eval(..)</code>. <code>setTimeout(..)</code> and <code>setInterval(..)</code> <em>can</em> take a string for their respective first argument, the contents of which are <code>eval</code>uated as the code of a dynamically-generated function. This is old, legacy behavior and long-since deprecated. Don't do it!</p>

<p>The <code>new Function(..)</code> function constructor similarly takes a string of code in its <strong>last</strong> argument to turn into a dynamically-generated function (the first argument(s), if any, are the named parameters for the new function). This function-constructor syntax is slightly safer than <code>eval(..)</code>, but it should still be avoided in your code.</p>

<p>The use-cases for dynamically generating code inside your program are incredibly rare, as the performance degradations are almost never worth the capability.</p>

<h3><a id="user-content-with" class="anchor" href="#with" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>with</code></h3>

<p>The other frowned-upon (and now deprecated!) feature in JavaScript which cheats lexical scope is the <code>with</code> keyword. There are multiple valid ways that <code>with</code> can be explained, but I will choose here to explain it from the perspective of how it interacts with and affects lexical scope.</p>

<p><code>with</code> is typically explained as a short-hand for making multiple property references against an object <em>without</em> repeating the object reference itself each time.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">1</span>,
    b<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    c<span class="pl-k">:</span> <span class="pl-c1">3</span>
};

<span class="pl-c">// more "tedious" to repeat "obj"</span>
obj.a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
obj.b <span class="pl-k">=</span> <span class="pl-c1">3</span>;
obj.c <span class="pl-k">=</span> <span class="pl-c1">4</span>;

<span class="pl-c">// "easier" short-hand</span>
<span class="pl-k">with</span> (obj) {
    a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    b <span class="pl-k">=</span> <span class="pl-c1">4</span>;
    c <span class="pl-k">=</span> <span class="pl-c1">5</span>;
}</pre></div>

<p>However, there's much more going on here than just a convenient short-hand for object property access. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">obj</span>) {
    <span class="pl-k">with</span> (obj) {
        a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    }
}

<span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">3</span>
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    b<span class="pl-k">:</span> <span class="pl-c1">3</span>
};

foo( o1 );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( o1.a ); <span class="pl-c">// 2</span>

foo( o2 );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( o2.a ); <span class="pl-c">// undefined</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2 -- Oops, leaked global!</span></pre></div>

<p>In this code example, two objects <code>o1</code> and <code>o2</code> are created. One has an <code>a</code> property, and the other does not. The <code>foo(..)</code> function takes an object reference <code>obj</code> as an argument, and calls <code>with (obj) { .. }</code> on the reference. Inside the <code>with</code> block, we make what appears to be a normal lexical reference to a variable <code>a</code>, an LHS reference in fact (see Chapter 1), to assign to it the value of <code>2</code>.</p>

<p>When we pass in <code>o1</code>, the <code>a = 2</code> assignment finds the property <code>o1.a</code> and assigns it the value <code>2</code>, as reflected in the subsequent <code>console.log(o1.a)</code> statement. However, when we pass in <code>o2</code>, since it does not have an <code>a</code> property, no such property is created, and <code>o2.a</code> remains <code>undefined</code>.</p>

<p>But then we note a peculiar side-effect, the fact that a global variable <code>a</code> was created by the <code>a = 2</code> assignment. How can this be?</p>

<p>The <code>with</code> statement takes an object, one which has zero or more properties, and <strong>treats that object as if <em>it</em> is a wholly separate lexical scope</strong>, and thus the object's properties are treated as lexically defined identifiers in that "scope".</p>

<p><strong>Note:</strong> Even though a <code>with</code> block treats an object like a lexical scope, a normal <code>var</code> declaration inside that <code>with</code> block will not be scoped to that <code>with</code> block, but instead the containing function scope.</p>

<p>While the <code>eval(..)</code> function can modify existing lexical scope if it takes a string of code with one or more declarations in it, the <code>with</code> statement actually creates a <strong>whole new lexical scope</strong> out of thin air, from the object you pass to it.</p>

<p>Understood in this way, the "scope" declared by the <code>with</code> statement when we passed in <code>o1</code> was <code>o1</code>, and that "scope" had an "identifier" in it which corresponds to the <code>o1.a</code> property. But when we used <code>o2</code> as the "scope", it had no such <code>a</code> "identifier" in it, and so the normal rules of LHS identifier look-up (see Chapter 1) occurred.</p>

<p>Neither the "scope" of <code>o2</code>, nor the scope of <code>foo(..)</code>, nor the global scope even, has an <code>a</code> identifier to be found, so when <code>a = 2</code> is executed, it results in the automatic-global being created (since we're in non-strict mode).</p>

<p>It is a strange sort of mind-bending thought to see <code>with</code> turning, at runtime, an object and its properties into a "scope" <em>with</em> "identifiers". But that is the clearest explanation I can give for the results we see.</p>

<p><strong>Note:</strong> In addition to being a bad idea to use, both <code>eval(..)</code> and <code>with</code> are affected (restricted) by Strict Mode. <code>with</code> is outright disallowed, whereas various forms of indirect or unsafe <code>eval(..)</code> are disallowed while retaining the core functionality.</p>

<h3><a id="user-content-performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h3>

<p>Both <code>eval(..)</code> and <code>with</code> cheat the otherwise author-time defined lexical scope by modifying or creating new lexical scope at runtime.</p>

<p>So, what's the big deal, you ask? If they offer more sophisticated functionality and coding flexibility, aren't these <em>good</em> features? <strong>No.</strong></p>

<p>The JavaScript <em>Engine</em> has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>

<p>But if the <em>Engine</em> finds an <code>eval(..)</code> or <code>with</code> in the code, it essentially has to <em>assume</em> that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to <code>eval(..)</code> to modify the lexical scope, or the contents of the object you may pass to <code>with</code> to create a new lexical scope to be consulted.</p>

<p>In other words, in the pessimistic sense, most of those optimizations it <em>would</em> make are pointless if <code>eval(..)</code> or <code>with</code> are present, so it simply doesn't perform the optimizations <em>at all</em>.</p>

<p>Your code will almost certainly tend to run slower simply by the fact that you include an <code>eval(..)</code> or <code>with</code> anywhere in the code. No matter how smart the <em>Engine</em> may be about trying to limit the side-effects of these pessimistic assumptions, <strong>there's no getting around the fact that without the optimizations, code runs slower.</strong></p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Lexical scope means that scope is defined by author-time decisions of where functions are declared. The lexing phase of compilation is essentially able to know where and how all identifiers are declared, and thus predict how they will be looked-up during execution.</p>

<p>Two mechanisms in JavaScript can "cheat" lexical scope: <code>eval(..)</code> and <code>with</code>. The former can modify existing lexical scope (at runtime) by evaluating a string of "code" which has one or more declarations in it. The latter essentially creates a whole new lexical scope (again, at runtime) by treating an object reference <em>as</em> a "scope" and that object's properties as scoped identifiers.</p>

<p>The downside to these mechanisms is that it defeats the <em>Engine</em>'s ability to perform compile-time optimizations regarding scope look-up, because the <em>Engine</em> has to assume pessimistically that such optimizations will be invalid. Code <em>will</em> run slower as a result of using either feature. <strong>Don't use them.</strong></p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-chapter-3-function-vs-block-scope" class="anchor" href="#chapter-3-function-vs-block-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3: Function vs. Block Scope</h1>

<p>As we explored in Chapter 2, scope consists of a series of "bubbles" that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author-time.</p>

<p>But what exactly makes a new bubble? Is it only the function? Can other structures in JavaScript create bubbles of scope?</p>

<h2><a id="user-content-scope-from-functions" class="anchor" href="#scope-from-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope From Functions</h2>

<p>The most common answer to those questions is that JavaScript has function-based scope. That is, each function you declare creates a bubble for itself, but no other structures create their own scope bubbles. As we'll see in just a little bit, this is not quite true.</p>

<p>But first, let's explore function scope and its implications.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

    <span class="pl-c">// some code</span>

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-c">// ...</span>
    }

    <span class="pl-c">// more code</span>

    <span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">3</span>;
}</pre></div>

<p>In this snippet, the scope bubble for <code>foo(..)</code> includes identifiers <code>a</code>, <code>b</code>, <code>c</code> and <code>bar</code>. <strong>It doesn't matter</strong> <em>where</em> in the scope a declaration appears, the variable or function belongs to the containing scope bubble, regardless. We'll explore how exactly <em>that</em> works in the next chapter.</p>

<p><code>bar(..)</code> has its own scope bubble. So does the global scope, which has just one identifier attached to it: <code>foo</code>.</p>

<p>Because <code>a</code>, <code>b</code>, <code>c</code>, and <code>bar</code> all belong to the scope bubble of <code>foo(..)</code>, they are not accessible outside of <code>foo(..)</code>. That is, the following code would all result in <code>ReferenceError</code> errors, as the identifiers are not available to the global scope:</p>

<div class="highlight highlight-js"><pre>bar(); <span class="pl-c">// fails</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c ); <span class="pl-c">// all 3 fail</span></pre></div>

<p>However, all these identifiers (<code>a</code>, <code>b</code>, <code>c</code>, <code>foo</code>, and <code>bar</code>) are accessible <em>inside</em> of <code>foo(..)</code>, and indeed also available inside of <code>bar(..)</code> (assuming there are no shadow identifier declarations inside <code>bar(..)</code>).</p>

<p>Function scope encourages the idea that all variables belong to the function, and can be used and re-used throughout the entirety of the function (and indeed, accessible even to nested scopes). This design approach can be quite useful, and certainly can make full use of the "dynamic" nature of JavaScript variables to take on values of different types as needed.</p>

<p>On the other hand, if you don't take careful precautions, variables existing across the entirety of a scope can lead to some unexpected pitfalls.</p>

<h2><a id="user-content-hiding-in-plain-scope" class="anchor" href="#hiding-in-plain-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hiding In Plain Scope</h2>

<p>The traditional way of thinking about functions is that you declare a function, and then add code inside it. But the inverse thinking is equally powerful and useful: take any arbitrary section of code you've written, and wrap a function declaration around it, which in effect "hides" the code.</p>

<p>The practical result is to create a scope bubble around the code in question, which means that any declarations (variable or function) in that code will now be tied to the scope of the new wrapping function, rather than the previously enclosing scope. In other words, you can "hide" variables and functions by enclosing them in the scope of a function.</p>

<p>Why would "hiding" variables and functions be a useful technique?</p>

<p>There's a variety of reasons motivating this scope-based hiding. They tend to arise from the software design principle "Principle of Least Privilege" [^note-leastprivilege], also sometimes called "Least Authority" or "Least Exposure". This principle states that in the design of software, such as the API for a module/object, you should expose only what is minimally necessary, and "hide" everything else.</p>

<p>This principle extends to the choice of which scope to contain variables and functions. If all variables and functions were in the global scope, they would of course be accessible to any nested scope. But this would violate the "Least..." principle in that you are (likely) exposing many variables or functions which you should otherwise keep private, as proper use of the code would discourage access to those variables/functions.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">doSomething</span>(<span class="pl-smi">a</span>) {
    b <span class="pl-k">=</span> a <span class="pl-k">+</span> doSomethingElse( a <span class="pl-k">*</span> <span class="pl-c1">2</span> );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b <span class="pl-k">*</span> <span class="pl-c1">3</span> );
}

<span class="pl-k">function</span> <span class="pl-en">doSomethingElse</span>(<span class="pl-smi">a</span>) {
    <span class="pl-k">return</span> a <span class="pl-k">-</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">var</span> b;

doSomething( <span class="pl-c1">2</span> ); <span class="pl-c">// 15</span></pre></div>

<p>In this snippet, the <code>b</code> variable and the <code>doSomethingElse(..)</code> function are likely "private" details of how <code>doSomething(..)</code> does its job. Giving the enclosing scope "access" to <code>b</code> and <code>doSomethingElse(..)</code> is not only unnecessary but also possibly "dangerous", in that they may be used in unexpected ways, intentionally or not, and this may violate pre-condition assumptions of <code>doSomething(..)</code>.</p>

<p>A more "proper" design would hide these private details inside the scope of <code>doSomething(..)</code>, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">doSomething</span>(<span class="pl-smi">a</span>) {
    <span class="pl-k">function</span> <span class="pl-en">doSomethingElse</span>(<span class="pl-smi">a</span>) {
        <span class="pl-k">return</span> a <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    }

    <span class="pl-k">var</span> b;

    b <span class="pl-k">=</span> a <span class="pl-k">+</span> doSomethingElse( a <span class="pl-k">*</span> <span class="pl-c1">2</span> );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( (b <span class="pl-k">*</span> <span class="pl-c1">3</span>) );
}

doSomething( <span class="pl-c1">2</span> ); <span class="pl-c">// 15</span></pre></div>

<p>Now, <code>b</code> and <code>doSomethingElse(..)</code> are not accessible to any outside influence, instead controlled only by <code>doSomething(..)</code>. The functionality and end-result has not been affected, but the design keeps private details private, which is usually considered better software.</p>

<h3><a id="user-content-collision-avoidance" class="anchor" href="#collision-avoidance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collision Avoidance</h3>

<p>Another benefit of "hiding" variables and functions inside a scope is to avoid unintended collision between two different identifiers with the same name but different intended usages. Collision results often in unexpected overwriting of values.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">a</span>) {
        i <span class="pl-k">=</span> <span class="pl-c1">3</span>; <span class="pl-c">// changing the `i` in the enclosing scope's for-loop</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> i );
    }

    <span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
        bar( i <span class="pl-k">*</span> <span class="pl-c1">2</span> ); <span class="pl-c">// oops, infinite loop ahead!</span>
    }
}

foo();</pre></div>

<p>The <code>i = 3</code> assignment inside of <code>bar(..)</code> overwrites, unexpectedly, the <code>i</code> that was declared in <code>foo(..)</code> at the for-loop. In this case, it will result in an infinite loop, because <code>i</code> is set to a fixed value of <code>3</code> and that will forever remain <code>&lt; 10</code>.</p>

<p>The assignment inside <code>bar(..)</code> needs to declare a local variable to use, regardless of what identifier name is chosen. <code>var i = 3;</code> would fix the problem (and would create the previously mentioned "shadowed variable" declaration for <code>i</code>). An <em>additional</em>, not alternate, option is to pick another identifier name entirely, such as <code>var j = 3;</code>. But your software design may naturally call for the same identifier name, so utilizing scope to "hide" your inner declaration is your best/only option in that case.</p>

<h4><a id="user-content-global-namespaces" class="anchor" href="#global-namespaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Global "Namespaces"</h4>

<p>A particularly strong example of (likely) variable collision occurs in the global scope. Multiple libraries loaded into your program can quite easily collide with each other if they don't properly hide their internal/private functions and variables.</p>

<p>Such libraries typically will create a single variable declaration, often an object, with a sufficiently unique name, in the global scope. This object is then used as a "namespace" for that library, where all specific exposures of functionality are made as properties off that object (namespace), rather than as top-level lexically scoped identifiers themselves.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> MyReallyCoolLibrary <span class="pl-k">=</span> {
    awesome<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>stuff<span class="pl-pds">"</span></span>,
    <span class="pl-en">doSomething</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// ...</span>
    },
    <span class="pl-en">doAnotherThing</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// ...</span>
    }
};</pre></div>

<h4><a id="user-content-module-management" class="anchor" href="#module-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Module Management</h4>

<p>Another option for collision avoidance is the more modern "module" approach, using any of various dependency managers. Using these tools, no libraries ever add any identifiers to the global scope, but are instead required to have their identifier(s) be explicitly imported into another specific scope through usage of the dependency manager's various mechanisms.</p>

<p>It should be observed that these tools do not possess "magic" functionality that is exempt from lexical scoping rules. They simply use the rules of scoping as explained here to enforce that no identifiers are injected into any shared scope, and are instead kept in private, non-collision-susceptible scopes, which prevents any accidental scope collisions.</p>

<p>As such, you can code defensively and achieve the same results as the dependency managers do without actually needing to use them, if you so choose. See the Chapter 5 for more information about the module pattern.</p>

<h2><a id="user-content-functions-as-scopes" class="anchor" href="#functions-as-scopes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions As Scopes</h2>

<p>We've seen that we can take any snippet of code and wrap a function around it, and that effectively "hides" any enclosed variable or function declarations from the outside scope inside that function's inner scope.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() { <span class="pl-c">// &lt;-- insert this</span>

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>

} <span class="pl-c">// &lt;-- and this</span>
foo(); <span class="pl-c">// &lt;-- and this</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span></pre></div>

<p>While this technique "works", it is not necessarily very ideal. There are a few problems it introduces. The first is that we have to declare a named-function <code>foo()</code>, which means that the identifier name <code>foo</code> itself "pollutes" the enclosing scope (global, in this case). We also have to explicitly call the function by name (<code>foo()</code>) so that the wrapped code actually executes.</p>

<p>It would be more ideal if the function didn't need a name (or, rather, the name didn't pollute the enclosing scope), and if the function could automatically be executed.</p>

<p>Fortunately, JavaScript offers a solution to both problems.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">foo</span>(){ <span class="pl-c">// &lt;-- insert this</span>

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>

})(); <span class="pl-c">// &lt;-- and this</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span></pre></div>

<p>Let's break down what's happening here.</p>

<p>First, notice that the wrapping function statement starts with <code>(function...</code> as opposed to just <code>function...</code>. While this may seem like a minor detail, it's actually a major change. Instead of treating the function as a standard declaration, the function is treated as a function-expression.</p>

<p><strong>Note:</strong> The easiest way to distinguish declaration vs. expression is the position of the word "function" in the statement (not just a line, but a distinct statement). If "function" is the very first thing in the statement, then it's a function declaration. Otherwise, it's a function expression.</p>

<p>The key difference we can observe here between a function declaration and a function expression relates to where its name is bound as an identifier.</p>

<p>Compare the previous two snippets. In the first snippet, the name <code>foo</code> is bound in the enclosing scope, and we call it directly with <code>foo()</code>. In the second snippet, the name <code>foo</code> is not bound in the enclosing scope, but instead is bound only inside of its own function.</p>

<p>In other words, <code>(function foo(){ .. })</code> as an expression means the identifier <code>foo</code> is found <em>only</em> in the scope where the <code>..</code> indicates, not in the outer scope. Hiding the name <code>foo</code> inside itself means it does not pollute the enclosing scope unnecessarily.</p>

<h3><a id="user-content-anonymous-vs-named" class="anchor" href="#anonymous-vs-named" aria-hidden="true"><span class="octicon octicon-link"></span></a>Anonymous vs. Named</h3>

<p>You are probably most familiar with function expressions as callback parameters, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>I waited 1 second!<span class="pl-pds">"</span></span>);
}, <span class="pl-c1">1000</span> );</pre></div>

<p>This is called an "anonymous function expression", because <code>function()...</code> has no name identifier on it. Function expressions can be anonymous, but function declarations cannot omit the name -- that would be illegal JS grammar.</p>

<p>Anonymous function expressions are quick and easy to type, and many libraries and tools tend to encourage this idiomatic style of code. However, they have several draw-backs to consider:</p>

<ol>
<li><p>Anonymous functions have no useful name to display in stack traces, which can make debugging more difficult.</p></li>
<li><p>Without a name, if the function needs to refer to itself, for recursion, etc., the <strong>deprecated</strong> <code>arguments.callee</code> reference is unfortunately required. Another example of needing to self-reference is when an event handler function wants to unbind itself after it fires.</p></li>
<li><p>Anonymous functions omit a name which is often helpful in providing more readable/understandable code. A descriptive name helps self-document the code in question.</p></li>
</ol>

<p><strong>Inline function expressions</strong> are powerful and useful -- the question of anonymous vs. named doesn't detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timeoutHandler</span>(){ <span class="pl-c">// &lt;-- Look, I have a name!</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>I waited 1 second!<span class="pl-pds">"</span></span> );
}, <span class="pl-c1">1000</span> );</pre></div>

<h3><a id="user-content-invoking-function-expressions-immediately" class="anchor" href="#invoking-function-expressions-immediately" aria-hidden="true"><span class="octicon octicon-link"></span></a>Invoking Function Expressions Immediately</h3>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">foo</span>(){

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>

})();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span></pre></div>

<p>Now that we have a function as an expression by virtue of wrapping it in a <code>( )</code> pair, we can execute that function by adding another <code>()</code> on the end, like <code>(function foo(){ .. })()</code>. The first enclosing <code>( )</code> pair makes the function an expression, and the second <code>()</code> executes the function.</p>

<p>This pattern is so common, a few years ago the community agreed on a term for it: <strong>IIFE</strong>, which stands for <strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong>xpression.</p>

<p>Of course, IIFE's don't need names, necessarily -- the most common form of IIFE is to use an anonymous function expression. While certainly less common, naming an IIFE has all the aforementioned benefits over anonymous function expressions, so it's a good practice to adopt.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>

})();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span></pre></div>

<p>There's a slight variation on the traditional IIFE form, which some prefer: <code>(function(){ .. }())</code>. Look closely to see the difference. In the first form, the function expression is wrapped in <code>( )</code>, and then the invoking <code>()</code> pair is on the outside right after it. In the second form, the invoking <code>()</code> pair is moved to the inside of the outer <code>( )</code> wrapping pair.</p>

<p>These two forms are identical in functionality. <strong>It's purely a stylistic choice which you prefer.</strong></p>

<p>Another variation on IIFE's which is quite common is to use the fact that they are, in fact, just function calls, and pass in argument(s).</p>

<p>For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>( <span class="pl-smi">global</span> ){

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">global</span>.a ); <span class="pl-c">// 2</span>

})( <span class="pl-c1">window</span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span></pre></div>

<p>We pass in the <code>window</code> object reference, but we name the parameter <code>global</code>, so that we have a clear stylistic delineation for global vs. non-global references. Of course, you can pass in anything from an enclosing scope you want, and you can name the parameter(s) anything that suits you. This is mostly just stylistic choice.</p>

<p>Another application of this pattern addresses the (minor niche) concern that the default <code>undefined</code> identifier might have its value incorrectly overwritten, causing unexpected results. By naming a parameter <code>undefined</code>, but not passing any value for that argument, we can guarantee that the <code>undefined</code> identifier is in fact the undefined value in a block of code:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">undefined</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>; <span class="pl-c">// setting a land-mine for other code! avoid!</span>

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>( <span class="pl-smi">undefined</span> ){

    <span class="pl-k">var</span> a;
    <span class="pl-k">if</span> (a <span class="pl-k">===</span> <span class="pl-c1">undefined</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Undefined is safe here!<span class="pl-pds">"</span></span> );
    }

})();</pre></div>

<p>Still another variation of the IIFE inverts the order of things, where the function to execute is given second, <em>after</em> the invocation and parameters to pass to it. This pattern is used in the UMD (Universal Module Definition) project. Some people find it a little cleaner to understand, though it is slightly more verbose.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>( <span class="pl-smi">def</span> ){
    def( <span class="pl-c1">window</span> );
})(<span class="pl-k">function</span> <span class="pl-en">def</span>( <span class="pl-smi">global</span> ){

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">global</span>.a ); <span class="pl-c">// 2</span>

});</pre></div>

<p>The <code>def</code> function expression is defined in the second-half of the snippet, and then passed as a parameter (also called <code>def</code>) to the <code>IIFE</code> function defined in the first half of the snippet. Finally, the parameter <code>def</code> (the function) is invoked, passing <code>window</code> in as the <code>global</code> parameter.</p>

<h2><a id="user-content-blocks-as-scopes" class="anchor" href="#blocks-as-scopes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blocks As Scopes</h2>

<p>While functions are the most common unit of scope, and certainly the most wide-spread of the design approaches in the majority of JS in circulation, other units of scope are possible, and the usage of these other scope units can lead to even better, cleaner to maintain code.</p>

<p>Many languages other than JavaScript support Block Scope, and so developers from those languages are accustomed to the mindset, whereas those who've primarily only worked in JavaScript may find the concept slightly foreign.</p>

<p>But even if you've never written a single line of code in block-scoped fashion, you are still probably familiar with this extremely common idiom in JavaScript:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}</pre></div>

<p>We declare the variable <code>i</code> directly inside the for-loop head, most likely because our <em>intent</em> is to use <code>i</code> only within the context of that for-loop, and essentially ignore the fact that the variable actually scopes itself to the enclosing scope (function or global).</p>

<p>That's what block-scoping is all about. Declaring variables as close as possible, as local as possible, to where they will be used. Another example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">var</span> bar <span class="pl-k">=</span> foo <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    bar <span class="pl-k">=</span> something( bar );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( bar );
}</pre></div>

<p>We are using a <code>bar</code> variable only in the context of the if-statement, so it makes a kind of sense that we would declare it inside the if-block. However, where we declare variables is not relevant when using <code>var</code>, because they will always belong to the enclosing scope. This snippet is essentially "fake" block-scoping, for stylistic reasons, and relying on self-enforcement not to accidentally use <code>bar</code> in another place in that scope.</p>

<p>Block scope is a tool to extend the earlier "Principle of Least <del>Privilege</del> Exposure" [^note-leastprivilege] from hiding information in functions to hiding information in blocks of our code.</p>

<p>Consider the for-loop example again:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}</pre></div>

<p>Why pollute the entire scope of a function with the <code>i</code> variable that is only going to be (or only <em>should be</em>, at least) used for the for-loop?</p>

<p>But more importantly, developers may prefer to <em>check</em> themselves against accidentally (re)using variables outside of their intended purpose, such as being issued an error about an unknown variable if you try to use it in the wrong place. Block-scoping (if it were possible) for the <code>i</code> variable would make <code>i</code> available only for the for-loop, causing an error if <code>i</code> is accessed elsewhere in the function. This helps ensure variables are not re-used in confusing or hard-to-maintain ways.</p>

<p>But, the sad reality is that, on the surface, JavaScript has no facility for block scope.</p>

<p>That is, until you dig a little further.</p>

<h3><a id="user-content-with" class="anchor" href="#with" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>with</code></h3>

<p>We learned about <code>with</code> in Chapter 2. While it is a frowned upon construct, it <em>is</em> an example of (a form of) block scope, in that the scope that is created from the object only exists for the lifetime of that <code>with</code> statement, and not in the enclosing scope.</p>

<h3><a id="user-content-trycatch" class="anchor" href="#trycatch" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>try/catch</code></h3>

<p>It's a <em>very</em> little known fact that JavaScript in ES3 specified the variable declaration in the <code>catch</code> clause of a <code>try/catch</code> to be block-scoped to the <code>catch</code> block.</p>

<p>For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">try</span> {
    <span class="pl-c1">undefined</span>(); <span class="pl-c">// illegal operation to force an exception!</span>
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// works!</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// ReferenceError: `err` not found</span></pre></div>

<p>As you can see, <code>err</code> exists only in the <code>catch</code> clause, and throws an error when you try to reference it elsewhere.</p>

<p><strong>Note:</strong> While this behavior has been specified and true of practically all standard JS environments (except perhaps old IE), many linters seem to still complain if you have two or more <code>catch</code> clauses in the same scope which each declare their error variable with the same identifier name. This is not actually a re-definition, since the variables are safely block-scoped, but the linters still seem to, annoyingly, complain about this fact.</p>

<p>To avoid these unnecessary warnings, some devs will name their <code>catch</code> variables <code>err1</code>, <code>err2</code>, etc. Other devs will simply turn off the linting check for duplicate variable names.</p>

<p>The block-scoping nature of <code>catch</code> may seem like a useless academic fact, but see Appendix B for more information on just how useful it might be.</p>

<h3><a id="user-content-let" class="anchor" href="#let" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code></h3>

<p>Thus far, we've seen that JavaScript only has some strange niche behaviors which expose block scope functionality. If that were all we had, and <em>it was</em> for many, many years, then block scoping would not be terribly useful to the JavaScript developer.</p>

<p>Fortunately, ES6 changes that, and introduces a new keyword <code>let</code> which sits alongside <code>var</code> as another way to declare variables.</p>

<p>The <code>let</code> keyword attaches the variable declaration to the scope of whatever block (commonly a <code>{ .. }</code> pair) it's contained in. In other words, <code>let</code> implicitly hijacks any block's scope for its variable declaration.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    bar <span class="pl-k">=</span> something( bar );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( bar );
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( bar ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>Using <code>let</code> to attach a variable to an existing block is somewhat implicit. It can confuse if you're not paying close attention to which blocks have variables scoped to them, and are in the habit of moving blocks around, wrapping them in other blocks, etc., as you develop and evolve code.</p>

<p>Creating explicit blocks for block-scoping can address some of these concerns, making it more obvious where variables are attached and not. Usually, explicit code is preferable over implicit or subtle code. This explicit block-scoping style is easy to achieve, and fits more naturally with how block-scoping works in other languages:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>;

<span class="pl-k">if</span> (foo) {
    { <span class="pl-c">// &lt;-- explicit block</span>
        <span class="pl-k">let</span> bar <span class="pl-k">=</span> foo <span class="pl-k">*</span> <span class="pl-c1">2</span>;
        bar <span class="pl-k">=</span> something( bar );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( bar );
    }
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( bar ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>We can create an arbitrary block for <code>let</code> to bind to by simply including a <code>{ .. }</code> pair anywhere a statement is valid grammar. In this case, we've made an explicit block <em>inside</em> the if-statement, which may be easier as a whole block to move around later in refactoring, without affecting the position and semantics of the enclosing if-statement.</p>

<p><strong>Note:</strong> For another way to express explicit block scopes, see Appendix B.</p>

<p>In Chapter 4, we will address hoisting, which talks about declarations being taken as existing for the entire scope in which they occur.</p>

<p>However, declarations made with <code>let</code> will <em>not</em> hoist to the entire scope of the block they appear in. Such declarations will not observably "exist" in the block until the declaration statement.</p>

<div class="highlight highlight-js"><pre>{
   <span class="pl-en">console</span><span class="pl-c1">.log</span>( bar ); <span class="pl-c">// ReferenceError!</span>
   <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-c1">2</span>;
}</pre></div>

<h4><a id="user-content-garbage-collection" class="anchor" href="#garbage-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Garbage Collection</h4>

<p>Another reason block-scoping is useful relates to closures and garbage collection to reclaim memory. We'll briefly illustrate here, but the closure mechanism is explained in detail in Chapter 5.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">process</span>(<span class="pl-smi">data</span>) {
    <span class="pl-c">// do something interesting</span>
}

<span class="pl-k">var</span> someReallyBigData <span class="pl-k">=</span> { .. };

<span class="pl-c1">process</span>( someReallyBigData );

<span class="pl-k">var</span> btn <span class="pl-k">=</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>my_button<span class="pl-pds">"</span></span> );

btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">click</span>(<span class="pl-smi">evt</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>button clicked<span class="pl-pds">"</span></span>);
}, <span class="pl-c">/*capturingPhase=*/</span><span class="pl-c1">false</span> );</pre></div>

<p>The <code>click</code> function click handler callback doesn't <em>need</em> the <code>someReallyBigData</code> variable at all. That means, theoretically, after <code>process(..)</code> runs, the big memory-heavy data structure could be garbage collected. However, it's quite likely (though implementation dependent) that the JS engine will still have to keep the structure around, since the <code>click</code> function has a closure over the entire scope.</p>

<p>Block-scoping can address this concern, making it clearer to the engine that it does not need to keep <code>someReallyBigData</code> around:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">process</span>(<span class="pl-smi">data</span>) {
    <span class="pl-c">// do something interesting</span>
}

<span class="pl-c">// anything declared inside this block can go away after!</span>
{
    <span class="pl-k">let</span> someReallyBigData <span class="pl-k">=</span> { .. };

    <span class="pl-c1">process</span>( someReallyBigData );
}

<span class="pl-k">var</span> btn <span class="pl-k">=</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>my_button<span class="pl-pds">"</span></span> );

btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">click</span>(<span class="pl-smi">evt</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>button clicked<span class="pl-pds">"</span></span>);
}, <span class="pl-c">/*capturingPhase=*/</span><span class="pl-c1">false</span> );</pre></div>

<p>Declaring explicit blocks for variables to locally bind to is a powerful tool that you can add to your code toolbox.</p>

<h4><a id="user-content-let-loops" class="anchor" href="#let-loops" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code> Loops</h4>

<p>A particular case where <code>let</code> shines is in the for-loop case as we discussed previously.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">let</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( i ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>Not only does <code>let</code> in the for-loop header bind the <code>i</code> to the for-loop body, but in fact, it <strong>re-binds it</strong> to each <em>iteration</em> of the loop, making sure to re-assign it the value from the end of the previous loop iteration.</p>

<p>Here's another way of illustrating the per-iteration binding behavior that occurs:</p>

<div class="highlight highlight-js"><pre>{
    <span class="pl-k">let</span> j;
    <span class="pl-k">for</span> (j<span class="pl-k">=</span><span class="pl-c1">0</span>; j<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; j<span class="pl-k">++</span>) {
        <span class="pl-k">let</span> i <span class="pl-k">=</span> j; <span class="pl-c">// re-bound for each iteration!</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    }
}</pre></div>

<p>The reason why this per-iteration binding is interesting will become clear in Chapter 5 when we discuss closures.</p>

<p>Because <code>let</code> declarations attach to arbitrary blocks rather than to the enclosing function's scope (or global), there can be gotchas where existing code has a hidden reliance on function-scoped <code>var</code> declarations, and replacing the <code>var</code> with <code>let</code> may require additional care when refactoring code.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>, baz <span class="pl-k">=</span> <span class="pl-c1">10</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-c1">3</span>;

    <span class="pl-k">if</span> (baz <span class="pl-k">&gt;</span> bar) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( baz );
    }

    <span class="pl-c">// ...</span>
}</pre></div>

<p>This code is fairly easily re-factored as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>, baz <span class="pl-k">=</span> <span class="pl-c1">10</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-c1">3</span>;

    <span class="pl-c">// ...</span>
}

<span class="pl-k">if</span> (baz <span class="pl-k">&gt;</span> bar) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( baz );
}</pre></div>

<p>But, be careful of such changes when using block-scoped variables:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>, baz <span class="pl-k">=</span> <span class="pl-c1">10</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">let</span> bar <span class="pl-k">=</span> <span class="pl-c1">3</span>;

    <span class="pl-k">if</span> (baz <span class="pl-k">&gt;</span> bar) { <span class="pl-c">// &lt;-- don't forget `bar` when moving!</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( baz );
    }
}</pre></div>

<p>See Appendix B for an alternate (more explicit) style of block-scoping which may provide easier to maintain/refactor code that's more robust to these scenarios.</p>

<h3><a id="user-content-const" class="anchor" href="#const" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>const</code></h3>

<p>In addition to <code>let</code>, ES6 introduces <code>const</code>, which also creates a block-scoped variable, but whose value is fixed (constant). Any attempt to change that value at a later time results in an error.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">true</span>;

<span class="pl-k">if</span> (foo) {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-k">const</span> <span class="pl-c1">b</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>; <span class="pl-c">// block-scoped to the containing `if`</span>

    a <span class="pl-k">=</span> <span class="pl-c1">3</span>; <span class="pl-c">// just fine!</span>
    b <span class="pl-k">=</span> <span class="pl-c1">4</span>; <span class="pl-c">// error!</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( b ); <span class="pl-c">// ReferenceError!</span></pre></div>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Functions are the most common unit of scope in JavaScript. Variables and functions that are declared inside another function are essentially "hidden" from any of the enclosing "scopes", which is an intentional design principle of good software.</p>

<p>But functions are by no means the only unit of scope. Block-scope refers to the idea that variables and functions can belong to an arbitrary block (generally, any <code>{ .. }</code> pair) of code, rather than only to the enclosing function.</p>

<p>Starting with ES3, the <code>try/catch</code> structure has block-scope in the <code>catch</code> clause.</p>

<p>In ES6, the <code>let</code> keyword (a cousin to the <code>var</code> keyword) is introduced to allow declarations of variables in any arbitrary block of code. <code>if (..) { let a = 2; }</code> will declare a variable <code>a</code> that essentially hijacks the scope of the <code>if</code>'s <code>{ .. }</code> block and attaches itself there.</p>

<p>Though some seem to believe so, block scope should not be taken as an outright replacement of <code>var</code> function scope. Both functionalities co-exist, and developers can and should use both function-scope and block-scope techniques where respectively appropriate to produce better, more readable/maintainable code.</p>

<p>[^note-leastprivilege]: <a href="http://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of Least Privilege</a></p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-chapter-4-hoisting" class="anchor" href="#chapter-4-hoisting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4: Hoisting</h1>

<p>By now, you should be fairly comfortable with the idea of scope, and how variables are attached to different levels of scope depending on where and how they are declared. Both function scope and block scope behave by the same rules in this regard: any variable declared within a scope is attached to that scope.</p>

<p>But there's a subtle detail of how scope attachment works with declarations that appear in various locations within a scope, and that detail is what we will examine here.</p>

<h2><a id="user-content-chicken-or-the-egg" class="anchor" href="#chicken-or-the-egg" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chicken Or The Egg?</h2>

<p>There's a temptation to think that all of the code you see in a JavaScript program is interpreted line-by-line, top-down in order, as the program executes. While that is substantially true, there's one part of that assumption which can lead to incorrect thinking about your program.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">var</span> a;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );</pre></div>

<p>What do you expect to be printed in the <code>console.log(..)</code> statement?</p>

<p>Many developers would expect <code>undefined</code>, since the <code>var a</code> statement comes after the <code>a = 2</code>, and it would seem natural to assume that the variable is re-defined, and thus assigned the default <code>undefined</code>. However, the output will be <code>2</code>.</p>

<p>Consider another piece of code:</p>

<div class="highlight highlight-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( a );

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;</pre></div>

<p>You might be tempted to assume that, since the previous snippet exhibited some less-than-top-down looking behavior, perhaps in this snippet, <code>2</code> will also be printed. Others may think that since the <code>a</code> variable is used before it is declared, this must result in a <code>ReferenceError</code> being thrown.</p>

<p>Unfortunately, both guesses are incorrect. <code>undefined</code> is the output.</p>

<p><strong>So, what's going on here?</strong> It would appear we have a chicken-and-the-egg question. Which comes first, the declaration ("egg"), or the assignment ("chicken")?</p>

<h2><a id="user-content-the-compiler-strikes-again" class="anchor" href="#the-compiler-strikes-again" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Compiler Strikes Again</h2>

<p>To answer this question, we need to refer back to Chapter 1, and our discussion of compilers. Recall that the <em>Engine</em> actually will compile your JavaScript code before it interprets it. Part of the compilation phase was to find and associate all declarations with their appropriate scopes. Chapter 2 showed us that this is the heart of Lexical Scope.</p>

<p>So, the best way to think about things is that all declarations, both variables and functions, are processed first, before any part of your code is executed.</p>

<p>When you see <code>var a = 2;</code>, you probably think of that as one statement. But JavaScript actually thinks of it as two statements: <code>var a;</code> and <code>a = 2;</code>. The first statement, the declaration, is processed during the compilation phase. The second statement, the assignment, is left <strong>in place</strong> for the execution phase.</p>

<p>Our first snippet then should be thought of as being handled like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a;</pre></div>

<div class="highlight highlight-js"><pre>a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );</pre></div>

<p>...where the first part is the compilation and the second part is the execution.</p>

<p>Similarly, our second snippet is actually processed as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a;</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( a );

a <span class="pl-k">=</span> <span class="pl-c1">2</span>;</pre></div>

<p>So, one way of thinking, sort of metaphorically, about this process, is that variable and function declarations are "moved" from where they appear in the flow of the code to the top of the code. This gives rise to the name "Hoisting".</p>

<p>In other words, <strong>the egg (declaration) comes before the chicken (assignment)</strong>.</p>

<p><strong>Note:</strong> Only the declarations themselves are hoisted, while any assignments or other executable logic are left <em>in place</em>. If hoisting were to re-arrange the executable logic of our code, that could wreak havoc.</p>

<div class="highlight highlight-js"><pre>foo();

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// undefined</span>

    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
}</pre></div>

<p>The function <code>foo</code>'s declaration (which in this case <em>includes</em> the implied value of it as an actual function) is hoisted, such that the call on the first line is able to execute.</p>

<p>It's also important to note that hoisting is <strong>per-scope</strong>. So while our previous snippets were simplified in that they only included global scope, the <code>foo(..)</code> function we are now examining itself exhibits that <code>var a</code> is hoisted to the top of <code>foo(..)</code> (not, obviously, to the top of the program). So the program can perhaps be more accurately interpreted like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// undefined</span>

    a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
}

foo();</pre></div>

<p>Function declarations are hoisted, as we just saw. But function expressions are not.</p>

<div class="highlight highlight-js"><pre>foo(); <span class="pl-c">// not ReferenceError, but TypeError!</span>

<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// ...</span>
};</pre></div>

<p>The variable identifier <code>foo</code> is hoisted and attached to the enclosing scope (global) of this program, so <code>foo()</code> doesn't fail as a <code>ReferenceError</code>. But <code>foo</code> has no value yet (as it would if it had been a true function declaration instead of expression). So, <code>foo()</code> is attempting to invoke the <code>undefined</code> value, which is a <code>TypeError</code> illegal operation.</p>

<p>Also recall that even though it's a named function expression, the name identifier is not available in the enclosing scope:</p>

<div class="highlight highlight-js"><pre>foo(); <span class="pl-c">// TypeError</span>
bar(); <span class="pl-c">// ReferenceError</span>

<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// ...</span>
};</pre></div>

<p>This snippet is more accurately interpreted (with hoisting) as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo;

foo(); <span class="pl-c">// TypeError</span>
bar(); <span class="pl-c">// ReferenceError</span>

<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">var</span> bar <span class="pl-k">=</span> ...<span class="pl-c1">self</span>...
    <span class="pl-c">// ...</span>
}</pre></div>

<h2><a id="user-content-functions-first" class="anchor" href="#functions-first" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions First</h2>

<p>Both function declarations and variable declarations are hoisted. But a subtle detail (that <em>can</em> show up in code with multiple "duplicate" declarations) is that functions are hoisted first, and then variables.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre>foo(); <span class="pl-c">// 1</span>

<span class="pl-k">var</span> foo;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">1</span> );
}

<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">2</span> );
};</pre></div>

<p><code>1</code> is printed instead of <code>2</code>! This snippet is interpreted by the <em>Engine</em> as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">1</span> );
}

foo(); <span class="pl-c">// 1</span>

<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">2</span> );
};</pre></div>

<p>Notice that <code>var foo</code> was the duplicate (and thus ignored) declaration, even though it came before the <code>function foo()...</code> declaration, because function declarations are hoisted before normal variables.</p>

<p>While multiple/duplicate <code>var</code> declarations are effectively ignored, subsequent function declarations <em>do</em> override previous ones.</p>

<div class="highlight highlight-js"><pre>foo(); <span class="pl-c">// 3</span>

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">1</span> );
}

<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">2</span> );
};

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">3</span> );
}</pre></div>

<p>While this all may sound like nothing more than interesting academic trivia, it highlights the fact that duplicate definitions in the same scope are a really bad idea and will often lead to confusing results.</p>

<p>Function declarations that appear inside of normal blocks typically hoist to the enclosing scope, rather than being conditional as this code implies:</p>

<div class="highlight highlight-js"><pre>foo(); <span class="pl-c">// "b"</span>

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">true</span>;
<span class="pl-k">if</span> (a) {
   <span class="pl-k">function</span> <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); }
}
<span class="pl-k">else</span> {
   <span class="pl-k">function</span> <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> ); }
}</pre></div>

<p>However, it's important to note that this behavior is not reliable and is subject to change in future versions of JavaScript, so it's probably best to avoid declaring functions in blocks.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>We can be tempted to look at <code>var a = 2;</code> as one statement, but the JavaScript <em>Engine</em> does not see it that way. It sees <code>var a</code> and <code>a = 2</code> as two separate statements, the first one a compiler-phase task, and the second one an execution-phase task.</p>

<p>What this leads to is that all declarations in a scope, regardless of where they appear, are processed <em>first</em> before the code itself is executed. You can visualize this as declarations (variables and functions) being "moved" to the top of their respective scopes, which we call "hoisting".</p>

<p>Declarations themselves are hoisted, but assignments, even assignments of function expressions, are <em>not</em> hoisted.</p>

<p>Be careful about duplicate declarations, especially mixed between normal var declarations and function declarations -- peril awaits if you do!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-chapter-5-scope-closure" class="anchor" href="#chapter-5-scope-closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 5: Scope Closure</h1>

<p>We arrive at this point with hopefully a very healthy, solid understanding of how scope works.</p>

<p>We turn our attention to an incredibly important, but persistently elusive, <em>almost mythological</em>, part of the language: <strong>closure</strong>. If you have followed our discussion of lexical scope thus far, the payoff is that closure is going to be, largely, anti-climatic, almost self-obvious. <em>There's a man behind the wizard's curtain, and we're about to see him</em>. No, his name is not Crockford!</p>

<p>If however you have nagging questions about lexical scope, now would be a good time to go back and review Chapter 2 before proceeding.</p>

<h2><a id="user-content-enlightenment" class="anchor" href="#enlightenment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enlightenment</h2>

<p>For those who are somewhat experienced in JavaScript, but have perhaps never fully grasped the concept of closures, <em>understanding closure</em> can seem like a special nirvana that one must strive and sacrifice to attain.</p>

<p>I recall years back when I had a firm grasp on JavaScript, but had no idea what closure was. The hint that there was <em>this other side</em> to the language, one which promised even more capability than I already possessed, teased and taunted me. I remember reading through the source code of early frameworks trying to understand how it actually worked. I remember the first time something of the "module pattern" began to emerge in my mind. I remember the <em>a-ha!</em> moments quite vividly.</p>

<p>What I didn't know back then, what took me years to understand, and what I hope to impart to you presently, is this secret: <strong>closure is all around you in JavaScript, you just have to recognize and embrace it.</strong> Closures are not a special opt-in tool that you must learn new syntax and patterns for. No, closures are not even a weapon that you must learn to wield and master as Luke trained in The Force.</p>

<p>Closures happen as a result of writing code that relies on lexical scope. They just happen. You do not even really have to intentionally create closures to take advantage of them. Closures are created and used for you all over your code. What you are <em>missing</em> is the proper mental context to recognize, embrace, and leverage closures for your own will.</p>

<p>The enlightenment moment should be: <strong>oh, closures are already occurring all over my code, I can finally <em>see</em> them now.</strong> Understanding closures is like when Neo sees the Matrix for the first time.</p>

<h2><a id="user-content-nitty-gritty" class="anchor" href="#nitty-gritty" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nitty Gritty</h2>

<p>OK, enough hyperbole and shameless movie references.</p>

<p>Here's a down-n-dirty definition of what you need to know to understand and recognize closures:</p>

<blockquote>
<p>Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.</p>
</blockquote>

<p>Let's jump into some code to illustrate that definition.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
    }

    bar();
}

foo();</pre></div>

<p>This code should look familiar from our discussions of Nested Scope. Function <code>bar()</code> has <em>access</em> to the variable <code>a</code> in the outer enclosing scope because of lexical scope look-up rules (in this case, it's an RHS reference look-up).</p>

<p>Is this "closure"?</p>

<p>Well, technically... <em>perhaps</em>. But by our what-you-need-to-know definition above... <em>not exactly</em>. I think the most accurate way to explain <code>bar()</code> referencing <code>a</code> is via lexical scope look-up rules, and those rules are <em>only</em> (an important!) <strong>part</strong> of what closure is.</p>

<p>From a purely academic perspective, what is said of the above snippet is that the function <code>bar()</code> has a <em>closure</em> over the scope of <code>foo()</code> (and indeed, even over the rest of the scopes it has access to, such as the global scope in our case). Put slightly differently, it's said that <code>bar()</code> closes over the scope of <code>foo()</code>. Why? Because <code>bar()</code> appears nested inside of <code>foo()</code>. Plain and simple.</p>

<p>But, closure defined in this way is not directly <em>observable</em>, nor do we see closure <em>exercised</em> in that snippet. We clearly see lexical scope, but closure remains sort of a mysterious shifting shadow behind the code.</p>

<p>Let us then consider code which brings closure into full light:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

    <span class="pl-k">function</span> <span class="pl-en">bar</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
    }

    <span class="pl-k">return</span> bar;
}

<span class="pl-k">var</span> baz <span class="pl-k">=</span> foo();

baz(); <span class="pl-c">// 2 -- Whoa, closure was just observed, man.</span></pre></div>

<p>The function <code>bar()</code> has lexical scope access to the inner scope of <code>foo()</code>. But then, we take <code>bar()</code>, the function itself, and pass it <em>as</em> a value. In this case, we <code>return</code> the function object itself that <code>bar</code> references.</p>

<p>After we execute <code>foo()</code>, we assign the value it returned (our inner <code>bar()</code> function) to a variable called <code>baz</code>, and then we actually invoke <code>baz()</code>, which of course is invoking our inner function <code>bar()</code>, just by a different identifier reference.</p>

<p><code>bar()</code> is executed, for sure. But in this case, it's executed <em>outside</em> of its declared lexical scope.</p>

<p>After <code>foo()</code> executed, normally we would expect that the entirety of the inner scope of <code>foo()</code> would go away, because we know that the <em>Engine</em> employs a <em>Garbage Collector</em> that comes along and frees up memory once it's no longer in use. Since it would appear that the contents of <code>foo()</code> are no longer in use, it would seem natural that they should be considered <em>gone</em>.</p>

<p>But the "magic" of closures does not let this happen. That inner scope is in fact <em>still</em> "in use", and thus does not go away. Who's using it? <strong>The function <code>bar()</code> itself</strong>.</p>

<p>By virtue of where it was declared, <code>bar()</code> has a lexical scope closure over that inner scope of <code>foo()</code>, which keeps that scope alive for <code>bar()</code> to reference at any later time.</p>

<p><strong><code>bar()</code> still has a reference to that scope, and that reference is called closure.</strong></p>

<p>So, a few microseconds later, when the variable <code>baz</code> is invoked (invoking the inner function we initially labeled <code>bar</code>), it duly has <em>access</em> to author-time lexical scope, so it can access the variable <code>a</code> just as we'd expect.</p>

<p>The function is being invoked well outside of its author-time lexical scope. <strong>Closure</strong> lets the function continue to access the lexical scope it was defined in at author-time.</p>

<p>Of course, any of the various ways that functions can be <em>passed around</em> as values, and indeed invoked in other locations, are all examples of observing/exercising closure.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

    <span class="pl-k">function</span> <span class="pl-en">baz</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
    }

    bar( baz );
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">fn</span>) {
    fn(); <span class="pl-c">// look ma, I saw closure!</span>
}</pre></div>

<p>We pass the inner function <code>baz</code> over to <code>bar</code>, and call that inner function (labeled <code>fn</code> now), and when we do, its closure over the inner scope of <code>foo()</code> is observed, by accessing <code>a</code>.</p>

<p>These passings-around of functions can be indirect, too.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> fn;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

    <span class="pl-k">function</span> <span class="pl-en">baz</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
    }

    fn <span class="pl-k">=</span> baz; <span class="pl-c">// assign `baz` to global variable</span>
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    fn(); <span class="pl-c">// look ma, I saw closure!</span>
}

foo();

bar(); <span class="pl-c">// 2</span></pre></div>

<p>Whatever facility we use to <em>transport</em> an inner function outside of its lexical scope, it will maintain a scope reference to where it was originally declared, and wherever we execute it, that closure will be exercised.</p>

<h2><a id="user-content-now-i-can-see" class="anchor" href="#now-i-can-see" aria-hidden="true"><span class="octicon octicon-link"></span></a>Now I Can See</h2>

<p>The previous code snippets are somewhat academic and artificially constructed to illustrate <em>using closure</em>. But I promised you something more than just a cool new toy. I promised that closure was something all around you in your existing code. Let us now <em>see</em> that truth.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">wait</span>(<span class="pl-smi">message</span>) {

    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( message );
    }, <span class="pl-c1">1000</span> );

}

wait( <span class="pl-s"><span class="pl-pds">"</span>Hello, closure!<span class="pl-pds">"</span></span> );</pre></div>

<p>We take an inner function (named <code>timer</code>) and pass it to <code>setTimeout(..)</code>. But <code>timer</code> has a scope closure over the scope of <code>wait(..)</code>, indeed keeping and using a reference to the variable <code>message</code>.</p>

<p>A thousand milliseconds after we have executed <code>wait(..)</code>, and its inner scope should otherwise be long gone, that anonymous function still has closure over that scope.</p>

<p>Deep down in the guts of the <em>Engine</em>, the built-in utility <code>setTimeout(..)</code> has reference to some parameter, probably called <code>fn</code> or <code>func</code> or something like that. <em>Engine</em> goes to invoke that function, which is invoking our inner <code>timer</code> function, and the lexical scope reference is still intact.</p>

<p><strong>Closure.</strong></p>

<p>Or, if you're of the jQuery persuasion (or any JS framework, for that matter):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">setupBot</span>(<span class="pl-smi">name</span>,<span class="pl-smi">selector</span>) {
    $( selector ).<span class="pl-c1">click</span>( <span class="pl-k">function</span> <span class="pl-en">activator</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Activating: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name );
    } );
}

setupBot( <span class="pl-s"><span class="pl-pds">"</span>Closure Bot 1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>#bot_1<span class="pl-pds">"</span></span> );
setupBot( <span class="pl-s"><span class="pl-pds">"</span>Closure Bot 2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>#bot_2<span class="pl-pds">"</span></span> );</pre></div>

<p>I am not sure what kind of code you write, but I regularly write code which is responsible for controlling an entire global drone army of closure bots, so this is totally realistic!</p>

<p>(Some) joking aside, essentially <em>whenever</em> and <em>wherever</em> you treat functions (which access their own respective lexical scopes) as first-class values and pass them around, you are likely to see those functions exercising closure. Be that timers, event handlers, Ajax requests, cross-window messaging, web workers, or any of the other asynchronous (or synchronous!) tasks, when you pass in a <em>callback function</em>, get ready to sling some closure around!</p>

<p><strong>Note:</strong> Chapter 3 introduced the IIFE pattern. While it is often said that IIFE (alone) is an example of observed closure, I would somewhat disagree, by our definition above.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
})();</pre></div>

<p>This code "works", but it's not strictly an observation of closure. Why? Because the function (which we named "IIFE" here) is not executed outside its lexical scope. It's still invoked right there in the same scope as it was declared (the enclosing/global scope that also holds <code>a</code>). <code>a</code> is found via normal lexical scope look-up, not really via closure.</p>

<p>While closure might technically be happening at declaration time, it is <em>not</em> strictly observable, and so, as they say, <em>it's a tree falling in the forest with no one around to hear it.</em></p>

<p>Though an IIFE is not <em>itself</em> an example of closure, it absolutely creates scope, and it's one of the most common tools we use to create scope which can be closed over. So IIFEs are indeed heavily related to closure, even if not exercising closure themselves.</p>

<p>Put this book down right now, dear reader. I have a task for you. Go open up some of your recent JavaScript code. Look for your functions-as-values and identify where you are already using closure and maybe didn't even know it before.</p>

<p>I'll wait.</p>

<p>Now... you see!</p>

<h2><a id="user-content-loops--closure" class="anchor" href="#loops--closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loops + Closure</h2>

<p>The most common canonical example used to illustrate closure involves the humble for-loop.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    }, i<span class="pl-k">*</span><span class="pl-c1">1000</span> );
}</pre></div>

<p><strong>Note:</strong> Linters often complain when you put functions inside of loops, because the mistakes of not understanding closure are <strong>so common among developers</strong>. We explain how to do so properly here, leveraging the full power of closure. But that subtlety is often lost on linters and they will complain regardless, assuming you don't <em>actually</em> know what you're doing.</p>

<p>The spirit of this code snippet is that we would normally <em>expect</em> for the behavior to be that the numbers "1", "2", .. "5" would be printed out, one at a time, one per second, respectively.</p>

<p>In fact, if you run this code, you get "6" printed out 5 times, at the one-second intervals.</p>

<p><strong>Huh?</strong></p>

<p>Firstly, let's explain where <code>6</code> comes from. The terminating condition of the loop is when <code>i</code> is <em>not</em> <code>&lt;=5</code>. The first time that's the case is when <code>i</code> is 6. So, the output is reflecting the final value of the <code>i</code> after the loop terminates.</p>

<p>This actually seems obvious on second glance. The timeout function callbacks are all running well after the completion of the loop. In fact, as timers go, even if it was <code>setTimeout(.., 0)</code> on each iteration, all those function callbacks would still run strictly after the completion of the loop, and thus print <code>6</code> each time.</p>

<p>But there's a deeper question at play here. What's <em>missing</em> from our code to actually have it behave as we semantically have implied?</p>

<p>What's missing is that we are trying to <em>imply</em> that each iteration of the loop "captures" its own copy of <code>i</code>, at the time of the iteration. But, the way scope works, all 5 of those functions, though they are defined separately in each loop iteration, all <strong>are closed over the same shared global scope</strong>, which has, in fact, only one <code>i</code> in it.</p>

<p>Put that way, <em>of course</em> all functions share a reference to the same <code>i</code>. Something about the loop structure tends to confuse us into thinking there's something else more sophisticated at work. There is not. There's no difference than if each of the 5 timeout callbacks were just declared one right after the other, with no loop at all.</p>

<p>OK, so, back to our burning question. What's missing? We need more <del>cowbell</del> closured scope. Specifically, we need a new closured scope for each iteration of the loop.</p>

<p>We learned in Chapter 3 that the IIFE creates scope by declaring a function and immediately executing it.</p>

<p>Let's try:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    (<span class="pl-k">function</span>(){
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
        }, i<span class="pl-k">*</span><span class="pl-c1">1000</span> );
    })();
}</pre></div>

<p>Does that work? Try it. Again, I'll wait.</p>

<p>I'll end the suspense for you. <strong>Nope.</strong> But why? We now obviously have more lexical scope. Each timeout function callback is indeed closing over its own per-iteration scope created respectively by each IIFE.</p>

<p>It's not enough to have a scope to close over <strong>if that scope is empty</strong>. Look closely. Our IIFE is just an empty do-nothing scope. It needs <em>something</em> in it to be useful to us.</p>

<p>It needs its own variable, with a copy of the <code>i</code> value at each iteration.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    (<span class="pl-k">function</span>(){
        <span class="pl-k">var</span> j <span class="pl-k">=</span> i;
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
        }, j<span class="pl-k">*</span><span class="pl-c1">1000</span> );
    })();
}</pre></div>

<p><strong>Eureka! It works!</strong></p>

<p>A slight variation some prefer is:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    (<span class="pl-k">function</span>(<span class="pl-smi">j</span>){
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
        }, j<span class="pl-k">*</span><span class="pl-c1">1000</span> );
    })( i );
}</pre></div>

<p>Of course, since these IIFEs are just functions, we can pass in <code>i</code>, and we can call it <code>j</code> if we prefer, or we can even call it <code>i</code> again. Either way, the code works now.</p>

<p>The use of an IIFE inside each iteration created a new scope for each iteration, which gave our timeout function callbacks the opportunity to close over a new scope for each iteration, one which had a variable with the right per-iteration value in it for us to access.</p>

<p>Problem solved!</p>

<h3><a id="user-content-block-scoping-revisited" class="anchor" href="#block-scoping-revisited" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block Scoping Revisited</h3>

<p>Look carefully at our analysis of the previous solution. We used an IIFE to create new scope per-iteration. In other words, we actually <em>needed</em> a per-iteration <strong>block scope</strong>. Chapter 3 showed us the <code>let</code> declaration, which hijacks a block and declares a variable right there in the block.</p>

<p><strong>It essentially turns a block into a scope that we can close over.</strong> So, the following awesome code "just works":</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">let</span> j <span class="pl-k">=</span> i; <span class="pl-c">// yay, block-scope for closure!</span>
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
    }, j<span class="pl-k">*</span><span class="pl-c1">1000</span> );
}</pre></div>

<p><em>But, that's not all!</em> (in my best Bob Barker voice). There's a special behavior defined for <code>let</code> declarations used in the head of a for-loop. This behavior says that the variable will be declared not just once for the loop, <strong>but each iteration</strong>. And, it will, helpfully, be initialized at each subsequent iteration with the value from the end of the previous iteration.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">let</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>; i<span class="pl-k">&lt;=</span><span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    }, i<span class="pl-k">*</span><span class="pl-c1">1000</span> );
}</pre></div>

<p>How cool is that? Block scoping and closure working hand-in-hand, solving all the world's problems. I don't know about you, but that makes me a happy JavaScripter.</p>

<h2><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h2>

<p>There are other code patterns which leverage the power of closure but which do not on the surface appear to be about callbacks. Let's examine the most powerful of them: <em>the module</em>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> something <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;
    <span class="pl-k">var</span> another <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>];

    <span class="pl-k">function</span> <span class="pl-en">doSomething</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( something );
    }

    <span class="pl-k">function</span> <span class="pl-en">doAnother</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( another.<span class="pl-c1">join</span>( <span class="pl-s"><span class="pl-pds">"</span> ! <span class="pl-pds">"</span></span> ) );
    }
}</pre></div>

<p>As this code stands right now, there's no observable closure going on. We simply have some private data variables <code>something</code> and <code>another</code>, and a couple of inner functions <code>doSomething()</code> and <code>doAnother()</code>, which both have lexical scope (and thus closure!) over the inner scope of <code>foo()</code>.</p>

<p>But now consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">CoolModule</span>() {
    <span class="pl-k">var</span> something <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;
    <span class="pl-k">var</span> another <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>];

    <span class="pl-k">function</span> <span class="pl-en">doSomething</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( something );
    }

    <span class="pl-k">function</span> <span class="pl-en">doAnother</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( another.<span class="pl-c1">join</span>( <span class="pl-s"><span class="pl-pds">"</span> ! <span class="pl-pds">"</span></span> ) );
    }

    <span class="pl-k">return</span> {
        doSomething<span class="pl-k">:</span> doSomething,
        doAnother<span class="pl-k">:</span> doAnother
    };
}

<span class="pl-k">var</span> foo <span class="pl-k">=</span> CoolModule();

foo.doSomething(); <span class="pl-c">// cool</span>
foo.doAnother(); <span class="pl-c">// 1 ! 2 ! 3</span></pre></div>

<p>This is the pattern in JavaScript we call <em>module</em>. The most common way of implementing the module pattern is often called "Revealing Module", and it's the variation we present here.</p>

<p>Let's examine some things about this code.</p>

<p>Firstly, <code>CoolModule()</code> is just a function, but it <em>has to be invoked</em> for there to be a module instance created. Without the execution of the outer function, the creation of the inner scope and the closures would not occur.</p>

<p>Secondly, the <code>CoolModule()</code> function returns an object, denoted by the object-literal syntax <code>{ key: value, ... }</code>. The object we return has references on it to our inner functions, but <em>not</em> to our inner data variables. We keep those hidden and private. It's appropriate to think of this object return value as essentially a <strong>public API for our module</strong>.</p>

<p>This object return value is ultimately assigned to the outer variable <code>foo</code>, and then we can access those property methods on the API, like <code>foo.doSomething()</code>.</p>

<p><strong>Note:</strong> It is not required that we return an actual object (literal) from our module. We could just return back an inner function directly. jQuery is actually a good example of this. The <code>jQuery</code> and <code>$</code> identifiers are the public API for the jQuery "module", but they are, themselves, just a function (which can itself have properties, since all functions are objects).</p>

<p>The <code>doSomething()</code> and <code>doAnother()</code> functions have closure over the inner scope of the module "instance" (arrived at by actually invoking <code>CoolModule()</code>). When we transport those functions outside of the lexical scope, by way of property references on the object we return, we have now set up a condition by which closure can be observed and exercised.</p>

<p>To state it more simply, there are two "requirements" for the module pattern to be exercised:</p>

<ol>
<li><p>There must be an outer enclosing function, and it must be invoked at least once (each time creates a new module instance).</p></li>
<li><p>The enclosing function must return back at least one inner function, so that this inner function has closure over the private scope, and can access and/or modify that private state.</p></li>
</ol>

<p>An object with a function property on it alone is not <em>really</em> a module. An object which is returned from a function invocation which only has data properties on it and no closured functions is not <em>really</em> a module, in the observable sense.</p>

<p>The code snippet above shows a standalone module creator called <code>CoolModule()</code> which can be invoked any number of times, each time creating a new module instance. A slight variation on this pattern is when you only care to have one instance, a "singleton" of sorts:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">CoolModule</span>() {
    <span class="pl-k">var</span> something <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;
    <span class="pl-k">var</span> another <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>];

    <span class="pl-k">function</span> <span class="pl-en">doSomething</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( something );
    }

    <span class="pl-k">function</span> <span class="pl-en">doAnother</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( another.<span class="pl-c1">join</span>( <span class="pl-s"><span class="pl-pds">"</span> ! <span class="pl-pds">"</span></span> ) );
    }

    <span class="pl-k">return</span> {
        doSomething<span class="pl-k">:</span> doSomething,
        doAnother<span class="pl-k">:</span> doAnother
    };
})();

foo.doSomething(); <span class="pl-c">// cool</span>
foo.doAnother(); <span class="pl-c">// 1 ! 2 ! 3</span></pre></div>

<p>Here, we turned our module function into an IIFE (see Chapter 3), and we <em>immediately</em> invoked it and assigned its return value directly to our single module instance identifier <code>foo</code>.</p>

<p>Modules are just functions, so they can receive parameters:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">CoolModule</span>(<span class="pl-smi">id</span>) {
    <span class="pl-k">function</span> <span class="pl-en">identify</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( id );
    }

    <span class="pl-k">return</span> {
        identify<span class="pl-k">:</span> identify
    };
}

<span class="pl-k">var</span> foo1 <span class="pl-k">=</span> CoolModule( <span class="pl-s"><span class="pl-pds">"</span>foo 1<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> foo2 <span class="pl-k">=</span> CoolModule( <span class="pl-s"><span class="pl-pds">"</span>foo 2<span class="pl-pds">"</span></span> );

foo1.identify(); <span class="pl-c">// "foo 1"</span>
foo2.identify(); <span class="pl-c">// "foo 2"</span></pre></div>

<p>Another slight but powerful variation on the module pattern is to name the object you are returning as your public API:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">CoolModule</span>(<span class="pl-smi">id</span>) {
    <span class="pl-k">function</span> <span class="pl-en">change</span>() {
        <span class="pl-c">// modifying the public API</span>
        publicAPI.identify <span class="pl-k">=</span> identify2;
    }

    <span class="pl-k">function</span> <span class="pl-en">identify1</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( id );
    }

    <span class="pl-k">function</span> <span class="pl-en">identify2</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( id.<span class="pl-c1">toUpperCase</span>() );
    }

    <span class="pl-k">var</span> publicAPI <span class="pl-k">=</span> {
        change<span class="pl-k">:</span> change,
        identify<span class="pl-k">:</span> identify1
    };

    <span class="pl-k">return</span> publicAPI;
})( <span class="pl-s"><span class="pl-pds">"</span>foo module<span class="pl-pds">"</span></span> );

foo.identify(); <span class="pl-c">// foo module</span>
foo.change();
foo.identify(); <span class="pl-c">// FOO MODULE</span></pre></div>

<p>By retaining an inner reference to the public API object inside your module instance, you can modify that module instance <strong>from the inside</strong>, including adding and removing methods, properties, <em>and</em> changing their values.</p>

<h3><a id="user-content-modern-modules" class="anchor" href="#modern-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modern Modules</h3>

<p>Various module dependency loaders/managers essentially wrap up this pattern of module definition into a friendly API. Rather than examine any one particular library, let me present a <em>very simple</em> proof of concept <strong>for illustration purposes (only)</strong>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> MyModules <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">Manager</span>() {
    <span class="pl-k">var</span> modules <span class="pl-k">=</span> {};

    <span class="pl-k">function</span> <span class="pl-en">define</span>(<span class="pl-smi">name</span>, <span class="pl-smi">deps</span>, <span class="pl-smi">impl</span>) {
        <span class="pl-k">for</span> (<span class="pl-k">var</span> i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span>deps.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            deps[i] <span class="pl-k">=</span> modules[deps[i]];
        }
        modules[name] <span class="pl-k">=</span> impl.<span class="pl-c1">apply</span>( impl, deps );
    }

    <span class="pl-k">function</span> <span class="pl-en">get</span>(<span class="pl-smi">name</span>) {
        <span class="pl-k">return</span> modules[name];
    }

    <span class="pl-k">return</span> {
        define<span class="pl-k">:</span> define,
        get<span class="pl-k">:</span> get
    };
})();</pre></div>

<p>The key part of this code is <code>modules[name] = impl.apply(impl, deps)</code>. This is invoking the definition wrapper function for a module (passing in any dependencies), and storing the return value, the module's API, into an internal list of modules tracked by name.</p>

<p>And here's how I might use it to define some modules:</p>

<div class="highlight highlight-js"><pre>MyModules.define( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, [], <span class="pl-k">function</span>(){
    <span class="pl-k">function</span> <span class="pl-en">hello</span>(<span class="pl-smi">who</span>) {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Let me introduce: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> who;
    }

    <span class="pl-k">return</span> {
        hello<span class="pl-k">:</span> hello
    };
} );

MyModules.define( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, [<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>], <span class="pl-k">function</span>(<span class="pl-smi">bar</span>){
    <span class="pl-k">var</span> hungry <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hippo<span class="pl-pds">"</span></span>;

    <span class="pl-k">function</span> <span class="pl-en">awesome</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( bar.hello( hungry ).<span class="pl-c1">toUpperCase</span>() );
    }

    <span class="pl-k">return</span> {
        awesome<span class="pl-k">:</span> awesome
    };
} );

<span class="pl-k">var</span> bar <span class="pl-k">=</span> MyModules.get( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> foo <span class="pl-k">=</span> MyModules.get( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>(
    bar.hello( <span class="pl-s"><span class="pl-pds">"</span>hippo<span class="pl-pds">"</span></span> )
); <span class="pl-c">// Let me introduce: hippo</span>

foo.awesome(); <span class="pl-c">// LET ME INTRODUCE: HIPPO</span></pre></div>

<p>Both the "foo" and "bar" modules are defined with a function that returns a public API. "foo" even receives the instance of "bar" as a dependency parameter, and can use it accordingly.</p>

<p>Spend some time examining these code snippets to fully understand the power of closures put to use for our own good purposes. The key take-away is that there's not really any particular "magic" to module managers. They fulfill both characteristics of the module pattern I listed above: invoking a function definition wrapper, and keeping its return value as the API for that module.</p>

<p>In other words, modules are just modules, even if you put a friendly wrapper tool on top of them.</p>

<h3><a id="user-content-future-modules" class="anchor" href="#future-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Modules</h3>

<p>ES6 adds first-class syntax support for the concept of modules. When loaded via the module system, ES6 treats a file as a separate module. Each module can both import other modules or specific API members, as well export their own public API members.</p>

<p><strong>Note:</strong> Function-based modules aren't a statically recognized pattern (something the compiler knows about), so their API semantics aren't considered until run-time. That is, you can actually modify a module's API during the run-time (see earlier <code>publicAPI</code> discussion).</p>

<p>By contrast, ES6 Module APIs are static (the APIs don't change at run-time). Since the compiler knows <em>that</em>, it can (and does!) check during (file loading and) compilation that a reference to a member of an imported module's API <em>actually exists</em>. If the API reference doesn't exist, the compiler throws an "early" error at compile-time, rather than waiting for traditional dynamic run-time resolution (and errors, if any).</p>

<p>ES6 modules <strong>do not</strong> have an "inline" format, they must be defined in separate files (one per module). The browsers/engines have a default "module loader" (which is overridable, but that's well-beyond our discussion here) which synchronously loads a module file when it's imported.</p>

<p>Consider:</p>

<p><strong>bar.js</strong></p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">hello</span>(<span class="pl-smi">who</span>) {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Let me introduce: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> who;
}

<span class="pl-k">export</span> hello;</pre></div>

<p><strong>foo.js</strong></p>

<div class="highlight highlight-js"><pre><span class="pl-c">// import only `hello()` from the "bar" module</span>
<span class="pl-k">import</span> hello <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> hungry <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hippo<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">awesome</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(
        hello( hungry ).<span class="pl-c1">toUpperCase</span>()
    );
}

<span class="pl-k">export</span> awesome;</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-c">// import the entire "foo" and "bar" modules</span>
<span class="pl-c1">module</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
<span class="pl-c1">module</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>(
    bar.hello( <span class="pl-s"><span class="pl-pds">"</span>rhino<span class="pl-pds">"</span></span> )
); <span class="pl-c">// Let me introduce: rhino</span>

foo.awesome(); <span class="pl-c">// LET ME INTRODUCE: HIPPO</span></pre></div>

<p><strong>Note:</strong> Separate files <strong>"foo.js"</strong> and <strong>"bar.js"</strong> would need to be created, with the contents as shown in the first two snippets, respectively. Then, your program would load/import those modules to use them, as shown in the third snippet.</p>

<p><code>import</code> imports one or more members from a module's API into the current scope, each to a bound variable (<code>hello</code> in our case). <code>module</code> imports an entire module API to a bound variable (<code>foo</code>, <code>bar</code> in our case). <code>export</code> exports an identifier (variable, function) to the public API for the current module. These operators can be used as many times in a module's definition as is necessary.</p>

<p>The contents inside the <em>module file</em> are treated as if enclosed in a scope closure, just like with the function-closure modules seen earlier.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Closure seems to the un-enlightened like a mystical world set apart inside of JavaScript which only the few bravest souls can reach. But it's actually just a standard and almost obvious fact of how we write code in a lexically scoped environment, where functions are values and can be passed around at will.</p>

<p><strong>Closure is when a function can remember and access its lexical scope even when it's invoked outside its lexical scope.</strong></p>

<p>Closures can trip us up, for instance with loops, if we're not careful to recognize them and how they work. But they are also an immensely powerful tool, enabling patterns like <em>modules</em> in their various forms.</p>

<p>Modules require two key characteristics: 1) an outer wrapping function being invoked, to create the enclosing scope 2) the return value of the wrapping function must include reference to at least one inner function that then has closure over the private inner scope of the wrapper.</p>

<p>Now we can see closures all around our existing code, and we have the ability to recognize and leverage them to our own benefit!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-appendix-a-dynamic-scope" class="anchor" href="#appendix-a-dynamic-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix A: Dynamic Scope</h1>

<p>In Chapter 2, we talked about "Dynamic Scope" as a contrast to the "Lexical Scope" model, which is how scope works in JavaScript (and in fact, most other languages).</p>

<p>We will briefly examine dynamic scope, to hammer home the contrast. But, more importantly, dynamic scope actually is a near cousin to another mechanism (<code>this</code>) in JavaScript, which we covered in the "<em>this &amp; Object Prototypes</em>" title of this book series.</p>

<p>As we saw in Chapter 2, lexical scope is the set of rules about how the <em>Engine</em> can look-up a variable and where it will find it. The key characteristic of lexical scope is that it is defined at author-time, when the code is written (assuming you don't cheat with <code>eval()</code> or <code>with</code>).</p>

<p>Dynamic scope seems to imply, and for good reason, that there's a model whereby scope can be determined dynamically at runtime, rather than statically at author-time. That is in fact the case. Let's illustrate via code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    foo();
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

bar();</pre></div>

<p>Lexical scope holds that the RHS reference to <code>a</code> in <code>foo()</code> will be resolved to the global variable <code>a</code>, which will result in value <code>2</code> being output.</p>

<p>Dynamic scope, by contrast, doesn't concern itself with how and where functions and scopes are declared, but rather <strong>where they are called from</strong>. In other words, the scope chain is based on the call-stack, not the nesting of scopes in code.</p>

<p>So, if JavaScript had dynamic scope, when <code>foo()</code> is executed, <strong>theoretically</strong> the code below would instead result in <code>3</code> as the output.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 3  (not 2!)</span>
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    foo();
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

bar();</pre></div>

<p>How can this be? Because when <code>foo()</code> cannot resolve the variable reference for <code>a</code>, instead of stepping up the nested (lexical) scope chain, it walks up the call-stack, to find where <code>foo()</code> was <em>called from</em>. Since <code>foo()</code> was called from <code>bar()</code>, it checks the variables in scope for <code>bar()</code>, and finds an <code>a</code> there with value <code>3</code>.</p>

<p>Strange? You're probably thinking so, at the moment.</p>

<p>But that's just because you've probably only ever worked on (or at least deeply considered) code which is lexically scoped. So dynamic scoping seems foreign. If you had only ever written code in a dynamically scoped language, it would seem natural, and lexical scope would be the odd-ball.</p>

<p>To be clear, JavaScript <strong>does not, in fact, have dynamic scope</strong>. It has lexical scope. Plain and simple. But the <code>this</code> mechanism is kind of like dynamic scope.</p>

<p>The key contrast: <strong>lexical scope is write-time, whereas dynamic scope (and <code>this</code>!) are runtime</strong>. Lexical scope cares <em>where a function was declared</em>, but dynamic scope cares where a function was <em>called from</em>.</p>

<p>Finally: <code>this</code> cares <em>how a function was called</em>, which shows how closely related the <code>this</code> mechanism is to the idea of dynamic scoping. To dig more into <code>this</code>, read the title "<em>this &amp; Object Prototypes</em>".</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-appendix-b-polyfilling-block-scope" class="anchor" href="#appendix-b-polyfilling-block-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix B: Polyfilling Block Scope</h1>

<p>In Chapter 3, we explored Block Scope. We saw that <code>with</code> and the <code>catch</code> clause are both tiny examples of block scope that have existed in JavaScript since at least the introduction of ES3.</p>

<p>But it's ES6's introduction of <code>let</code> that finally gives full, unfettered block-scoping capability to our code. There are many exciting things, both functionally and code-stylistically, that block scope will enable.</p>

<p>But what if we wanted to use block scope in pre-ES6 environments?</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre>{
    <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>This will work great in ES6 environments. But can we do so pre-ES6? <code>catch</code> is the answer.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">try</span>{<span class="pl-k">throw</span> <span class="pl-c1">2</span>}<span class="pl-k">catch</span>(a){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>Whoa! That's some ugly, weird looking code. We see a <code>try/catch</code> that appears to forcibly throw an error, but the "error" it throws is just a value <code>2</code>, and then the variable declaration that receives it is in the <code>catch(a)</code> clause. Mind: blown.</p>

<p>That's right, the <code>catch</code> clause has block-scoping to it, which means it can be used as a polyfill for block scope in pre-ES6 environments.</p>

<p>"But...", you say. "...no one wants to write ugly code like that!" That's true. No one writes (some of) the code output by the CoffeeScript compiler, either. That's not the point.</p>

<p>The point is that tools can transpile ES6 code to work in pre-ES6 environments. You can write code using block-scoping, and benefit from such functionality, and let a build-step tool take care of producing code that will actually <em>work</em> when deployed.</p>

<p>This is actually the preferred migration path for all (ahem, most) of ES6: to use a code transpiler to take ES6 code and produce ES5-compatible code during the transition from pre-ES6 to ES6.</p>

<h2><a id="user-content-traceur" class="anchor" href="#traceur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Traceur</h2>

<p>Google maintains a project called "Traceur" [^note-traceur], which is exactly tasked with transpiling ES6 features into pre-ES6 (mostly ES5, but not all!) for general usage. The TC39 committee relies on this tool (and others) to test out the semantics of the features they specify.</p>

<p>What does Traceur produce from our snippet? You guessed it!</p>

<div class="highlight highlight-js"><pre>{
    <span class="pl-k">try</span> {
        <span class="pl-k">throw</span> <span class="pl-c1">undefined</span>;
    } <span class="pl-k">catch</span> (a) {
        a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
    }
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );</pre></div>

<p>So, with the use of such tools, we can start taking advantage of block scope regardless of if we are targeting ES6 or not, because <code>try/catch</code> has been around (and worked this way) from ES3 days.</p>

<h2><a id="user-content-implicit-vs-explicit-blocks" class="anchor" href="#implicit-vs-explicit-blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implicit vs. Explicit Blocks</h2>

<p>In Chapter 3, we identified some potential pitfalls to code maintainability/refactorability when we introduce block-scoping. Is there another way to take advantage of block scope but to reduce this downside?</p>

<p>Consider this alternate form of <code>let</code>, called the "let block" or "let statement" (contrasted with "let declarations" from before).</p>

<div class="highlight highlight-js"><pre><span class="pl-en">let</span> (<span class="pl-smi">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// 2</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>Instead of implicitly hijacking an existing block, the let-statement creates an explicit block for its scope binding. Not only does the explicit block stand out more, and perhaps fare more robustly in code refactoring, it produces somewhat cleaner code by, grammatically, forcing all the declarations to the top of the block. This makes it easier to look at any block and know what's scoped to it and not.</p>

<p>As a pattern, it mirrors the approach many people take in function-scoping when they manually move/hoist all their <code>var</code> declarations to the top of the function. The let-statement puts them there at the top of the block by intent, and if you don't use <code>let</code> declarations strewn throughout, your block-scoping declarations are somewhat easier to identify and maintain.</p>

<p>But, there's a problem. The let-statement form is not included in ES6. Neither does the official Traceur compiler accept that form of code.</p>

<p>We have two options. We can format using ES6-valid syntax and a little sprinkle of code discipline:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">/*let*/</span> { <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>But, tools are meant to solve our problems. So the other option is to write explicit let statement blocks, and let a tool convert them to valid, working code.</p>

<p>So, I built a tool called "let-er" ^note-let_er to address just this issue. <em>let-er</em> is a build-step code transpiler, but its only task is to find let-statement forms and transpile them. It will leave alone any of the rest of your code, including any let-declarations. You can safely use <em>let-er</em> as the first ES6 transpiler step, and then pass your code through something like Traceur if necessary.</p>

<p>Moreover, <em>let-er</em> has a configuration flag <code>--es6</code>, which when turned on (off by default), changes the kind of code produced. Instead of the <code>try/catch</code> ES3 polyfill hack, <em>let-er</em> would take our snippet and produce the fully ES6-compliant, non-hacky:</p>

<div class="highlight highlight-js"><pre>{
    <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ReferenceError</span></pre></div>

<p>So, you can start using <em>let-er</em> right away, and target all pre-ES6 environments, and when you only care about ES6, you can add the flag and instantly target only ES6.</p>

<p>And most importantly, <strong>you can use the more preferable and more explicit let-statement form</strong> even though it is not an official part of any ES version (yet).</p>

<h2><a id="user-content-performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h2>

<p>Let me add one last quick note on the performance of <code>try/catch</code>, and/or to address the question, "why not just use an IIFE to create the scope?"</p>

<p>Firstly, the performance of <code>try/catch</code> <em>is</em> slower, but there's no reasonable assumption that it <em>has</em> to be that way, or even that it <em>always will be</em> that way. Since the official TC39-approved ES6 transpiler uses <code>try/catch</code>, the Traceur team has asked Chrome to improve the performance of <code>try/catch</code>, and they are obviously motivated to do so.</p>

<p>Secondly, IIFE is not a fair apples-to-apples comparison with <code>try/catch</code>, because a function wrapped around any arbitrary code changes the meaning, inside of that code, of <code>this</code>, <code>return</code>, <code>break</code>, and <code>continue</code>. IIFE is not a suitable general substitute. It could only be used manually in certain cases.</p>

<p>The question really becomes: do you want block-scoping, or not. If you do, these tools provide you that option. If not, keep using <code>var</code> and go on about your coding!</p>

<p>[^note-traceur]: <a href="http://traceur-compiler.googlecode.com/git/demo/repl.html">Google Traceur</a></p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-scope--closures" class="anchor" href="#you-dont-know-js-scope--closures" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Scope &amp; Closures</h1>

<h1><a id="user-content-appendix-c-lexical-this" class="anchor" href="#appendix-c-lexical-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix C: Lexical-this</h1>

<p>Though this title does not address the <code>this</code> mechanism in any detail, there's one ES6 topic which relates <code>this</code> to lexical scope in an important way, which we will quickly examine.</p>

<p>ES6 adds a special syntactic form of function declaration called the "arrow function". It looks like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> a <span class="pl-k">=&gt;</span> {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
};

foo( <span class="pl-c1">2</span> ); <span class="pl-c">// 2</span></pre></div>

<p>The so-called "fat arrow" is often mentioned as a short-hand for the <em>tediously verbose</em> (sarcasm) <code>function</code> keyword.</p>

<p>But there's something much more important going on with arrow-functions that has nothing to do with saving keystrokes in your declaration.</p>

<p>Briefly, this code suffers a problem:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>,
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">coolFn</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
    }
};

<span class="pl-k">var</span> id <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>not awesome<span class="pl-pds">"</span></span>;

obj.cool(); <span class="pl-c">// awesome</span>

<span class="pl-c1">setTimeout</span>( obj.cool, <span class="pl-c1">100</span> ); <span class="pl-c">// not awesome</span></pre></div>

<p>The problem is the loss of <code>this</code> binding on the <code>cool()</code> function. There are various ways to address that problem, but one often-repeated solution is <code>var self = this;</code>.</p>

<p>That might look like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    count<span class="pl-k">:</span> <span class="pl-c1">0</span>,
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">coolFn</span>() {
        <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;

        <span class="pl-k">if</span> (self.count <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
                self.count<span class="pl-k">++</span>;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>awesome?<span class="pl-pds">"</span></span> );
            }, <span class="pl-c1">100</span> );
        }
    }
};

obj.cool(); <span class="pl-c">// awesome?</span></pre></div>

<p>Without getting too much into the weeds here, the <code>var self = this</code> "solution" just dispenses with the whole problem of understanding and properly using <code>this</code> binding, and instead falls back to something we're perhaps more comfortable with: lexical scope. <code>self</code> becomes just an identifier that can be resolved via lexical scope and closure, and cares not what happened to the <code>this</code> binding along the way.</p>

<p>People don't like writing verbose stuff, especially when they do it over and over again. So, a motivation of ES6 is to help alleviate these scenarios, and indeed, <em>fix</em> common idiom problems, such as this one.</p>

<p>The ES6 solution, the arrow-function, introduces a behavior called "lexical this".</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    count<span class="pl-k">:</span> <span class="pl-c1">0</span>,
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">coolFn</span>() {
        <span class="pl-k">if</span> (<span class="pl-v">this</span>.count <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-c1">setTimeout</span>( ()<span class="pl-k"> =&gt;</span> { <span class="pl-c">// arrow-function ftw?</span>
                <span class="pl-v">this</span>.count<span class="pl-k">++</span>;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>awesome?<span class="pl-pds">"</span></span> );
            }, <span class="pl-c1">100</span> );
        }
    }
};

obj.cool(); <span class="pl-c">// awesome?</span></pre></div>

<p>The short explanation is that arrow-functions do not behave at all like normal functions when it comes to their <code>this</code> binding. They discard all the normal rules for <code>this</code> binding, and instead take on the <code>this</code> value of their immediate lexical enclosing scope, whatever it is.</p>

<p>So, in that snippet, the arrow-function doesn't get its <code>this</code> unbound in some unpredictable way, it just "inherits" the <code>this</code> binding of the <code>cool()</code> function (which is correct if we invoke it as shown!).</p>

<p>While this makes for shorter code, my perspective is that arrow-functions are really just codifying into the language syntax a common <em>mistake</em> of developers, which is to confuse and conflate "this binding" rules with "lexical scope" rules.</p>

<p>Put another way: why go to the trouble and verbosity of using the <code>this</code> style coding paradigm, only to cut it off at the knees by mixing it with lexical references. It seems natural to embrace one approach or the other for any given piece of code, and not mix them in the same piece of code.</p>

<p><strong>Note:</strong> one other detraction from arrow-functions is that they are anonymous, not named. See Chapter 3 for the reasons why anonymous functions are less desirable than named functions.</p>

<p>A more appropriate approach, in my perspective, to this "problem", is to use and embrace the <code>this</code> mechanism correctly.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    count<span class="pl-k">:</span> <span class="pl-c1">0</span>,
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">coolFn</span>() {
        <span class="pl-k">if</span> (<span class="pl-v">this</span>.count <span class="pl-k">&lt;</span> <span class="pl-c1">1</span>) {
            <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">timer</span>(){
                <span class="pl-v">this</span>.count<span class="pl-k">++</span>; <span class="pl-c">// `this` is safe because of `bind(..)`</span>
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>more awesome<span class="pl-pds">"</span></span> );
            }.bind( <span class="pl-v">this</span> ), <span class="pl-c1">100</span> ); <span class="pl-c">// look, `bind()`!</span>
        }
    }
};

obj.cool(); <span class="pl-c">// more awesome</span></pre></div>

<p>Whether you prefer the new lexical-this behavior of arrow-functions, or you prefer the tried-and-true <code>bind()</code>, it's important to note that arrow-functions are <strong>not</strong> just about less typing of "function".</p>

<p>They have an <em>intentional behavioral difference</em> that we should learn and understand, and if we so choose, leverage.</p>

<p>Now that we fully understand lexical scoping (and closure!), understanding lexical-this should be a breeze!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-1-this-or-that" class="anchor" href="#chapter-1-this-or-that" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: <code>this</code> Or That?</h1>

<p>One of the most confused mechanisms in JavaScript is the <code>this</code> keyword. It's a special identifier keyword that's automatically defined in the scope of every function, but what exactly it refers to bedevils even seasoned JavaScript developers.</p>

<blockquote>
<p>Any sufficiently <em>advanced</em> technology is indistinguishable from magic. -- Arthur C. Clarke</p>
</blockquote>

<p>JavaScript's <code>this</code> mechanism isn't actually <em>that</em> advanced, but developers often paraphrase that quote in their own mind by inserting "complex" or "confusing", and there's no question that without lack of clear understanding, <code>this</code> can seem downright magical in <em>your</em> confusion.</p>

<p><strong>Note:</strong> The word "this" is a terribly common pronoun in general discourse. So, it can be very difficult, especially verbally, to determine whether we are using "this" as a pronoun or using it to refer to the actual keyword identifier. For clarity, I will always use <code>this</code> to refer to the special keyword, and "this" or <em>this</em> or this otherwise.</p>

<h2><a id="user-content-why-this" class="anchor" href="#why-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why <code>this</code>?</h2>

<p>If the <code>this</code> mechanism is so confusing, even to seasoned JavaScript developers, one may wonder why it's even useful? Is it more trouble than it's worth? Before we jump into the <em>how</em>, we should examine the <em>why</em>.</p>

<p>Let's try to illustrate the motivation and utility of <code>this</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">identify</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>.<span class="pl-c1">toUpperCase</span>();
}

<span class="pl-k">function</span> <span class="pl-en">speak</span>() {
    <span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, I'm <span class="pl-pds">"</span></span> <span class="pl-k">+</span> identify.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );
}

<span class="pl-k">var</span> me <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>
};

<span class="pl-k">var</span> you <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Reader<span class="pl-pds">"</span></span>
};

identify.<span class="pl-c1">call</span>( me ); <span class="pl-c">// KYLE</span>
identify.<span class="pl-c1">call</span>( you ); <span class="pl-c">// READER</span>

speak.<span class="pl-c1">call</span>( me ); <span class="pl-c">// Hello, I'm KYLE</span>
speak.<span class="pl-c1">call</span>( you ); <span class="pl-c">// Hello, I'm READER</span></pre></div>

<p>If the <em>how</em> of this snippet confuses you, don't worry! We'll get to that shortly. Just set those questions aside briefly so we can look into the <em>why</em> more clearly.</p>

<p>This code snippet allows the <code>identify()</code> and <code>speak()</code> functions to be re-used against multiple <em>context</em> (<code>me</code> and <code>you</code>) objects, rather than needing a separate version of the function for each object.</p>

<p>Instead of relying on <code>this</code>, you could have explicitly passed in a context object to both <code>identify()</code> and <code>speak()</code>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">identify</span>(<span class="pl-smi">context</span>) {
    <span class="pl-k">return</span> context.<span class="pl-c1">name</span>.<span class="pl-c1">toUpperCase</span>();
}

<span class="pl-k">function</span> <span class="pl-en">speak</span>(<span class="pl-smi">context</span>) {
    <span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello, I'm <span class="pl-pds">"</span></span> <span class="pl-k">+</span> identify( context );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );
}

identify( you ); <span class="pl-c">// READER</span>
speak( me ); <span class="pl-c">// Hello, I'm KYLE</span></pre></div>

<p>However, the <code>this</code> mechanism provides a more elegant way of implicitly "passing along" an object reference, leading to cleaner API design and easier re-use.</p>

<p>The more complex your usage pattern is, the more clearly you'll see that passing context around as an explicit parameter is often messier than passing around a <code>this</code> context. When we explore objects and prototypes, you will see the helpfulness of a collection of functions being able to automatically reference the proper context object.</p>

<h2><a id="user-content-confusions" class="anchor" href="#confusions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Confusions</h2>

<p>We'll soon begin to explain how <code>this</code> <em>actually</em> works, but first we must  dispel some misconceptions about how it <em>doesn't</em> actually work.</p>

<p>The name "this" creates confusion when developers try to think about it too literally. There are two meanings often assumed, but both are incorrect.</p>

<h3><a id="user-content-itself" class="anchor" href="#itself" aria-hidden="true"><span class="octicon octicon-link"></span></a>Itself</h3>

<p>The first common temptation is to assume <code>this</code> refers to the function itself. That's a reasonable grammatical inference, at least.</p>

<p>Why would you want to refer to a function from inside itself? The most common reasons would be things like recursion (calling a function from inside itself) or having an event handler that can unbind itself when it's first called.</p>

<p>Developers new to JS's mechanisms often think that referencing the function as an object (all functions in JavaScript are objects!) lets you store <em>state</em> (values in properties) between function calls. While this is certainly possible and has some limited uses, the rest of the book will expound on many other patterns for <em>better</em> places to store state besides the function object.</p>

<p>But for just a moment, we'll explore that pattern, to illustrate how <code>this</code> doesn't let a function get a reference to itself like we might have assumed.</p>

<p>Consider the following code, where we attempt to track how many times a function (<code>foo</code>) was called:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">num</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> num );

    <span class="pl-c">// keep track of how many times `foo` is called</span>
    <span class="pl-v">this</span>.count<span class="pl-k">++</span>;
}

foo.count <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">var</span> i;

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) {
        foo( i );
    }
}
<span class="pl-c">// foo: 6</span>
<span class="pl-c">// foo: 7</span>
<span class="pl-c">// foo: 8</span>
<span class="pl-c">// foo: 9</span>

<span class="pl-c">// how many times was `foo` called?</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( foo.count ); <span class="pl-c">// 0 -- WTF?</span></pre></div>

<p><code>foo.count</code> is <em>still</em> <code>0</code>, even though the four <code>console.log</code> statements clearly indicate <code>foo(..)</code> was in fact called four times. The frustration stems from a <em>too literal</em> interpretation of what <code>this</code> (in <code>this.count++</code>) means.</p>

<p>When the code executes <code>foo.count = 0</code>, indeed it's adding a property <code>count</code> to the function object <code>foo</code>. But for the <code>this.count</code> reference inside of the function, <code>this</code> is not in fact pointing <em>at all</em> to that function object, and so even though the property names are the same, the root objects are different, and confusion ensues.</p>

<p><strong>Note:</strong> A responsible developer <em>should</em> ask at this point, "If I was incrementing a <code>count</code> property but it wasn't the one I expected, which <code>count</code> <em>was</em> I incrementing?" In fact, were she to dig deeper, she would find that she had accidentally created a global variable <code>count</code> (see Chapter 2 for <em>how</em> that happened!), and it currently has the value <code>NaN</code>. Of course, once she identifies this peculiar outcome, she then has a whole other set of questions: "How was it global, and why did it end up <code>NaN</code> instead of some proper count value?" (see Chapter 2).</p>

<p>Instead of stopping at this point and digging into why the <code>this</code> reference doesn't seem to be behaving as <em>expected</em>, and answering those tough but important questions, many developers simply avoid the issue altogether, and hack toward some other solution, such as creating another object to hold the <code>count</code> property:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">num</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> num );

    <span class="pl-c">// keep track of how many times `foo` is called</span>
    data.count<span class="pl-k">++</span>;
}

<span class="pl-k">var</span> data <span class="pl-k">=</span> {
    count<span class="pl-k">:</span> <span class="pl-c1">0</span>
};

<span class="pl-k">var</span> i;

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) {
        foo( i );
    }
}
<span class="pl-c">// foo: 6</span>
<span class="pl-c">// foo: 7</span>
<span class="pl-c">// foo: 8</span>
<span class="pl-c">// foo: 9</span>

<span class="pl-c">// how many times was `foo` called?</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( data.count ); <span class="pl-c">// 4</span></pre></div>

<p>While it is true that this approach "solves" the problem, unfortunately it simply ignores the real problem -- lack of understanding what <code>this</code> means and how it works -- and instead falls back to the comfort zone of a more familiar mechanism: lexical scope.</p>

<p><strong>Note:</strong> Lexical scope is a perfectly fine and useful mechanism; I am not belittling the use of it, by any means (see <em>"Scope &amp; Closures"</em> title of this book series). But constantly <em>guessing</em> at how to use <code>this</code>, and usually being <em>wrong</em>, is not a good reason to retreat back to lexical scope and never learn <em>why</em> <code>this</code> eludes you.</p>

<p>To reference a function object from inside itself, <code>this</code> by itself will typically be insufficient. You generally need a reference to the function object via a lexical identifier (variable) that points at it.</p>

<p>Consider these two functions:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    foo.count <span class="pl-k">=</span> <span class="pl-c1">4</span>; <span class="pl-c">// `foo` refers to itself</span>
}

<span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
    <span class="pl-c">// anonymous function (no name), cannot</span>
    <span class="pl-c">// refer to itself</span>
}, <span class="pl-c1">10</span> );</pre></div>

<p>In the first function, called a "named function", <code>foo</code> is a reference that can be used to refer to the function from inside itself.</p>

<p>But in the second example, the function callback passed to <code>setTimeout(..)</code> has no name identifier (so called an "anonymous function"), so there's no proper way to refer to the function object itself.</p>

<p><strong>Note:</strong> The old-school but now deprecated and frowned-upon <code>arguments.callee</code> reference inside a function <em>also</em> points to the function object of the currently executing function. This reference is typically the only way to access an anonymous function's object from inside itself. The best approach, however, is to avoid the use of anonymous functions altogether, at least for those which require a self-reference, and instead use a named function (expression). <code>arguments.callee</code> is deprecated and should not be used.</p>

<p>So another solution to our running example would have been to use the <code>foo</code> identifier as a function object reference in each place, and not use <code>this</code> at all, which <em>works</em>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">num</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> num );

    <span class="pl-c">// keep track of how many times `foo` is called</span>
    foo.count<span class="pl-k">++</span>;
}

foo.count <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">var</span> i;

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) {
        foo( i );
    }
}
<span class="pl-c">// foo: 6</span>
<span class="pl-c">// foo: 7</span>
<span class="pl-c">// foo: 8</span>
<span class="pl-c">// foo: 9</span>

<span class="pl-c">// how many times was `foo` called?</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( foo.count ); <span class="pl-c">// 4</span></pre></div>

<p>However, that approach similarly side-steps <em>actual</em> understanding of <code>this</code> and relies entirely on the lexical scoping of variable <code>foo</code>.</p>

<p>Yet another way of approaching the issue is to force <code>this</code> to actually point at the <code>foo</code> function object:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">num</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> num );

    <span class="pl-c">// keep track of how many times `foo` is called</span>
    <span class="pl-c">// Note: `this` IS actually `foo` now, based on</span>
    <span class="pl-c">// how `foo` is called (see below)</span>
    <span class="pl-v">this</span>.count<span class="pl-k">++</span>;
}

foo.count <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">var</span> i;

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">0</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) {
        <span class="pl-c">// using `call(..)`, we ensure the `this`</span>
        <span class="pl-c">// points at the function object (`foo`) itself</span>
        foo.<span class="pl-c1">call</span>( foo, i );
    }
}
<span class="pl-c">// foo: 6</span>
<span class="pl-c">// foo: 7</span>
<span class="pl-c">// foo: 8</span>
<span class="pl-c">// foo: 9</span>

<span class="pl-c">// how many times was `foo` called?</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( foo.count ); <span class="pl-c">// 4</span></pre></div>

<p><strong>Instead of avoiding <code>this</code>, we embrace it.</strong> We'll explain in a little bit <em>how</em> such techniques work much more completely, so don't worry if you're still a bit confused!</p>

<h3><a id="user-content-its-scope" class="anchor" href="#its-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Its Scope</h3>

<p>The next most common misconception about the meaning of <code>this</code> is that it somehow refers to the function's scope. It's a tricky question, because in one sense there is some truth, but in the other sense, it's quite misguided.</p>

<p>To be clear, <code>this</code> does not, in any way, refer to a function's <strong>lexical scope</strong>. It is true that internally, scope is kind of like an object with properties for each of the available identifiers. But the scope "object" is not accessible to JavaScript code. It's an inner part of the <em>Engine</em>'s implementation.</p>

<p>Consider code which attempts (and fails!) to cross over the boundary and use <code>this</code> to implicitly refer to a function's lexical scope:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-v">this</span>.bar();
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

foo(); <span class="pl-c">//undefined</span></pre></div>

<p>There's more than one mistake in this snippet. While it may seem contrived, the code you see is a distillation of actual real-world code that has been exchanged in public community help forums. It's a wonderful (if not sad) illustration of just how misguided <code>this</code> assumptions can be.</p>

<p>Firstly, an attempt is made to reference the <code>bar()</code> function via <code>this.bar()</code>. It is almost certainly an <em>accident</em> that it works, but we'll explain the <em>how</em> of that shortly. The most natural way to have invoked <code>bar()</code> would have been to omit the leading <code>this.</code> and just make a lexical reference to the identifier.</p>

<p>However, the developer who writes such code is attempting to use <code>this</code> to create a bridge between the lexical scopes of <code>foo()</code> and <code>bar()</code>, so that <code>bar()</code> has access to the variable <code>a</code> in the inner scope of <code>foo()</code>. <strong>No such bridge is possible.</strong> You cannot use a <code>this</code> reference to look something up in a lexical scope. It is not possible.</p>

<p>Every time you feel yourself trying to mix lexical scope look-ups with <code>this</code>, remind yourself: <em>there is no bridge</em>.</p>

<h2><a id="user-content-whats-this" class="anchor" href="#whats-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's <code>this</code>?</h2>

<p>Having set aside various incorrect assumptions, let us now turn our attention to how the <code>this</code> mechanism really works.</p>

<p>We said earlier that <code>this</code> is not an author-time binding but a runtime binding. It is contextual based on the conditions of the function's invocation. <code>this</code> binding has nothing to do with where a function is declared, but has instead everything to do with the manner in which the function is called.</p>

<p>When a function is invoked, an activation record, otherwise known as an execution context, is created. This record contains information about where the function was called from (the call-stack), <em>how</em> the function was invoked, what parameters were passed, etc. One of the properties of this record is the <code>this</code> reference which will be used for the duration of that function's execution.</p>

<p>In the next chapter, we will learn to find a function's <strong>call-site</strong> to determine how its execution will bind <code>this</code>.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p><code>this</code> binding is a constant source of confusion for the JavaScript developer who does not take the time to learn how the mechanism actually works. Guesses, trial-and-error, and blind copy-n-paste from Stack Overflow answers is not an effective or proper way to leverage <em>this</em> important <code>this</code> mechanism.</p>

<p>To learn <code>this</code>, you first have to learn what <code>this</code> is <em>not</em>, despite any assumptions or misconceptions that may lead you down those paths. <code>this</code> is neither a reference to the function itself, nor is it a reference to the function's <em>lexical</em> scope.</p>

<p><code>this</code> is actually a binding that is made when a function is invoked, and <em>what</em> it references is determined entirely by the call-site where the function is called.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-2-this-all-makes-sense-now" class="anchor" href="#chapter-2-this-all-makes-sense-now" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: <code>this</code> All Makes Sense Now!</h1>

<p>In Chapter 1, we discarded various misconceptions about <code>this</code> and learned instead that <code>this</code> is a binding made for each function invocation, based entirely on its <strong>call-site</strong> (how the function is called).</p>

<h2><a id="user-content-call-site" class="anchor" href="#call-site" aria-hidden="true"><span class="octicon octicon-link"></span></a>Call-site</h2>

<p>To understand <code>this</code> binding, we have to understand the call-site: the location in code where a function is called (<strong>not where it's declared</strong>). We must inspect the call-site to answer the question: what's <em>this</em> <code>this</code> a reference to?</p>

<p>Finding the call-site is generally: "go locate where a function is called from", but it's not always that easy, as certain coding patterns can obscure the <em>true</em> call-site.</p>

<p>What's important is to think about the <strong>call-stack</strong> (the stack of functions that have been called to get us to the current moment in execution). The call-site we care about is <em>in</em> the invocation <em>before</em> the currently executing function.</p>

<p>Let's demonstrate call-stack and call-site:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">baz</span>() {
    <span class="pl-c">// call-stack is: `baz`</span>
    <span class="pl-c">// so, our call-site is in the global scope</span>

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> );
    bar(); <span class="pl-c">// &lt;-- call-site for `bar`</span>
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// call-stack is: `baz` -&gt; `bar`</span>
    <span class="pl-c">// so, our call-site is in `baz`</span>

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );
    foo(); <span class="pl-c">// &lt;-- call-site for `foo`</span>
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// call-stack is: `baz` -&gt; `bar` -&gt; `foo`</span>
    <span class="pl-c">// so, our call-site is in `bar`</span>

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
}

baz(); <span class="pl-c">// &lt;-- call-site for `baz`</span></pre></div>

<p>Take care when analyzing code to find the actual call-site (from the call-stack), because it's the only thing that matters for <code>this</code> binding.</p>

<p><strong>Note:</strong> You can visualize a call-stack in your mind by looking at the chain of function calls in order, as we did with the comments in the above snippet. But this is painstaking and error-prone. Another way of seeing the call-stack is using a debugger tool in your browser. Most modern desktop browsers have built-in developer tools, which includes a JS debugger. In the above snippet, you could have set a breakpoint in the tools for the first line of the <code>foo()</code> function, or simply inserted the <code>debugger;</code> statement on that first line. When you run the page, the debugger will pause at this location, and will show you a list of the functions that have been called to get to that line, which will be your call stack. So, if you're trying to diagnose <code>this</code> binding, use the developer tools to get the call-stack, then find the second item from the top, and that will show you the real call-site.</p>

<h2><a id="user-content-nothing-but-rules" class="anchor" href="#nothing-but-rules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nothing But Rules</h2>

<p>We turn our attention now to <em>how</em> the call-site determines where <code>this</code> will point during the execution of a function.</p>

<p>You must inspect the call-site and determine which of 4 rules applies. We will first explain each of these 4 rules independently, and then we will illustrate their order of precedence, if multiple rules <em>could</em> apply to the call-site.</p>

<h3><a id="user-content-default-binding" class="anchor" href="#default-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Binding</h3>

<p>The first rule we will examine comes from the most common case of function calls: standalone function invocation. Think of <em>this</em> <code>this</code> rule as the default catch-all rule when none of the other rules apply.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo(); <span class="pl-c">// 2</span></pre></div>

<p>The first thing to note, if you were not already aware, is that variables declared in the global scope, as <code>var a = 2</code> is, are synonymous with global-object properties of the same name. They're not copies of each other, they <em>are</em> each other. Think of it as two sides of the same coin.</p>

<p>Secondly, we see that when <code>foo()</code> is called, <code>this.a</code> resolves to our global variable <code>a</code>. Why? Because in this case, the <em>default binding</em> for <code>this</code> applies to the function call, and so points <code>this</code> at the global object.</p>

<p>How do we know that the <em>default binding</em> rule applies here? We examine the call-site to see how <code>foo()</code> is called. In our snippet, <code>foo()</code> is called with a plain, un-decorated function reference. None of the other rules we will demonstrate will apply here, so the <em>default binding</em> applies instead.</p>

<p>If <code>strict mode</code> is in effect, the global object is not eligible for the <em>default binding</em>, so the <code>this</code> is instead set to <code>undefined</code>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo(); <span class="pl-c">// TypeError: `this` is `undefined`</span></pre></div>

<p>A subtle but important detail is: even though the overall <code>this</code> binding rules are entirely based on the call-site, the global object is <strong>only</strong> eligible for the <em>default binding</em> if the <strong>contents</strong> of <code>foo()</code> are <strong>not</strong> running in <code>strict mode</code>; the <code>strict mode</code> state of the call-site of <code>foo()</code> is irrelevant.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span>(){
    <span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

    foo(); <span class="pl-c">// 2</span>
})();</pre></div>

<p><strong>Note:</strong> Intentionally mixing <code>strict mode</code> and non-<code>strict mode</code> together in your own code is generally frowned upon. Your entire program should probably either be <strong>Strict</strong> or <strong>non-Strict</strong>. However, sometimes you include a third-party library that has different <strong>Strict</strong>'ness than your own code, so care must be taken over these subtle compatibility details.</p>

<h3><a id="user-content-implicit-binding" class="anchor" href="#implicit-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implicit Binding</h3>

<p>Another rule to consider is: does the call-site have a context object, also referred to as an owning or containing object, though <em>these</em> alternate terms could be slightly misleading.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    foo<span class="pl-k">:</span> foo
};

obj.foo(); <span class="pl-c">// 2</span></pre></div>

<p>Firstly, notice the manner in which <code>foo()</code> is declared and then later added as a reference property onto <code>obj</code>. Regardless of whether <code>foo()</code> is initially declared <em>on</em> <code>obj</code>, or is added as a reference later (as this snippet shows), in neither case is the <strong>function</strong> really "owned" or "contained" by the <code>obj</code> object.</p>

<p>However, the call-site <em>uses</em> the <code>obj</code> context to <strong>reference</strong> the function, so you <em>could</em> say that the <code>obj</code> object "owns" or "contains" the <strong>function reference</strong> at the time the function is called.</p>

<p>Whatever you choose to call this pattern, at the point that <code>foo()</code> is called, it's preceded by an object reference to <code>obj</code>. When there is a context object for a function reference, the <em>implicit binding</em> rule says that it's <em>that</em> object which should be used for the function call's <code>this</code> binding.</p>

<p>Because <code>obj</code> is the <code>this</code> for the <code>foo()</code> call, <code>this.a</code> is synonymous with <code>obj.a</code>.</p>

<p>Only the top/last level of an object property reference chain matters to the call-site. For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    obj2<span class="pl-k">:</span> obj2
};

obj1.obj2.foo(); <span class="pl-c">// 42</span></pre></div>

<h4><a id="user-content-implicitly-lost" class="anchor" href="#implicitly-lost" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implicitly Lost</h4>

<p>One of the most common frustrations that <code>this</code> binding creates is when an <em>implicitly bound</em> function loses that binding, which usually means it falls back to the <em>default binding</em>, of either the global object or <code>undefined</code>, depending on <code>strict mode</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> obj.foo; <span class="pl-c">// function reference/alias!</span>

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>oops, global<span class="pl-pds">"</span></span>; <span class="pl-c">// `a` also property on global object</span>

bar(); <span class="pl-c">// "oops, global"</span></pre></div>

<p>Even though <code>bar</code> appears to be a reference to <code>obj.foo</code>, in fact, it's really just another reference to <code>foo</code> itself. Moreover, the call-site is what matters, and the call-site is <code>bar()</code>, which is a plain, un-decorated call and thus the <em>default binding</em> applies.</p>

<p>The more subtle, more common, and more unexpected way this occurs is when we consider passing a callback function:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">function</span> <span class="pl-en">doFoo</span>(<span class="pl-smi">fn</span>) {
    <span class="pl-c">// `fn` is just another reference to `foo`</span>

    fn(); <span class="pl-c">// &lt;-- call-site!</span>
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>oops, global<span class="pl-pds">"</span></span>; <span class="pl-c">// `a` also property on global object</span>

doFoo( obj.foo ); <span class="pl-c">// "oops, global"</span></pre></div>

<p>Parameter passing is just an implicit assignment, and since we're passing a function, it's an implicit reference assignment, so the end result is the same as the previous snippet.</p>

<p>What if the function you're passing your callback to is not your own, but built-in to the language? No difference, same outcome.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>oops, global<span class="pl-pds">"</span></span>; <span class="pl-c">// `a` also property on global object</span>

<span class="pl-c1">setTimeout</span>( obj.foo, <span class="pl-c1">100</span> ); <span class="pl-c">// "oops, global"</span></pre></div>

<p>Think about this crude theoretical pseudo-implementation of <code>setTimeout()</code> provided as a built-in from the JavaScript environment:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">setTimeout</span>(<span class="pl-smi">fn</span>,<span class="pl-smi">delay</span>) {
    <span class="pl-c">// wait (somehow) for `delay` milliseconds</span>
    fn(); <span class="pl-c">// &lt;-- call-site!</span>
}</pre></div>

<p>It's quite common that our function callbacks <em>lose</em> their <code>this</code> binding, as we've just seen. But another way that <code>this</code> can surprise us is when the function we've passed our callback to intentionally changes the <code>this</code> for the call. Event handlers in popular JavaScript libraries are quite fond of forcing your callback to have a <code>this</code> which points to, for instance, the DOM element that triggered the event. While that may sometimes be useful, other times it can be downright infuriating. Unfortunately, these tools rarely let you choose.</p>

<p>Either way the <code>this</code> is changed unexpectedly, you are not really in control of how your callback function reference will be executed, so you have no way (yet) of controlling the call-site to give your intended binding. We'll see shortly a way of "fixing" that problem by <em>fixing</em> the <code>this</code>.</p>

<h3><a id="user-content-explicit-binding" class="anchor" href="#explicit-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explicit Binding</h3>

<p>With <em>implicit binding</em> as we just saw, we had to mutate the object in question to include a reference on itself to the function, and use this property function reference to indirectly (implicitly) bind <code>this</code> to the object.</p>

<p>But, what if you want to force a function call to use a particular object for the <code>this</code> binding, without putting a property function reference on the object?</p>

<p>"All" functions in the language have some utilities available to them (via their <code>[[Prototype]]</code> -- more on that later) which can be useful for this task. Specifically, functions have <code>call(..)</code> and <code>apply(..)</code> methods. Technically, JavaScript host environments sometimes provide functions which are special enough (a kind way of putting it!) that they do not have such functionality. But those are few. The vast majority of functions provided, and certainly all functions you will create, do have access to <code>call(..)</code> and <code>apply(..)</code>.</p>

<p>How do these utilities work? They both take, as their first parameter, an object to use for the <code>this</code>, and then invoke the function with that <code>this</code> specified. Since you are directly stating what you want the <code>this</code> to be, we call it <em>explicit binding</em>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

foo.<span class="pl-c1">call</span>( obj ); <span class="pl-c">// 2</span></pre></div>

<p>Invoking <code>foo</code> with <em>explicit binding</em> by <code>foo.call(..)</code> allows us to force its <code>this</code> to be <code>obj</code>.</p>

<p>If you pass a simple primitive value (of type <code>string</code>, <code>boolean</code>, or <code>number</code>) as the <code>this</code> binding, the primitive value is wrapped in its object-form (<code>new String(..)</code>, <code>new Boolean(..)</code>, or <code>new Number(..)</code>, respectively). This is often referred to as "boxing".</p>

<p><strong>Note:</strong> With respect to <code>this</code> binding, <code>call(..)</code> and <code>apply(..)</code> are identical. They <em>do</em> behave differently with their additional parameters, but that's not something we care about presently.</p>

<p>Unfortunately, <em>explicit binding</em> alone still doesn't offer any solution to the issue mentioned previously, of a function "losing" its intended <code>this</code> binding, or just having it paved over by a framework, etc.</p>

<h4><a id="user-content-hard-binding" class="anchor" href="#hard-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hard Binding</h4>

<p>But a variation pattern around <em>explicit binding</em> actually does the trick. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    foo.<span class="pl-c1">call</span>( obj );
};

bar(); <span class="pl-c">// 2</span>
<span class="pl-c1">setTimeout</span>( bar, <span class="pl-c1">100</span> ); <span class="pl-c">// 2</span>

<span class="pl-c">// `bar` hard binds `foo`'s `this` to `obj`</span>
<span class="pl-c">// so that it cannot be overriden</span>
bar.<span class="pl-c1">call</span>( <span class="pl-c1">window</span> ); <span class="pl-c">// 2</span></pre></div>

<p>Let's examine how this variation works. We create a function <code>bar()</code> which, internally, manually calls <code>foo.call(obj)</code>, thereby forcibly invoking <code>foo</code> with <code>obj</code> binding for <code>this</code>. No matter how you later invoke the function <code>bar</code>, it will always manually invoke <code>foo</code> with <code>obj</code>. This binding is both explicit and strong, so we call it <em>hard binding</em>.</p>

<p>The most typical way to wrap a function with a <em>hard binding</em> creates a pass-thru of any arguments passed and any return value received:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">something</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a, something );
    <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">+</span> something;
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> foo.<span class="pl-c1">apply</span>( obj, arguments );
};

<span class="pl-k">var</span> b <span class="pl-k">=</span> bar( <span class="pl-c1">3</span> ); <span class="pl-c">// 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( b ); <span class="pl-c">// 5</span></pre></div>

<p>Another way to express this pattern is to create a re-usable helper:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">something</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a, something );
    <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">+</span> something;
}

<span class="pl-c">// simple `bind` helper</span>
<span class="pl-k">function</span> <span class="pl-en">bind</span>(<span class="pl-smi">fn</span>, <span class="pl-smi">obj</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> fn.<span class="pl-c1">apply</span>( obj, arguments );
    };
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> bind( foo, obj );

<span class="pl-k">var</span> b <span class="pl-k">=</span> bar( <span class="pl-c1">3</span> ); <span class="pl-c">// 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( b ); <span class="pl-c">// 5</span></pre></div>

<p>Since <em>hard binding</em> is such a common pattern, it's provided with a built-in utility as of ES5: <code>Function.prototype.bind</code>, and it's used like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">something</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a, something );
    <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">+</span> something;
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.bind( obj );

<span class="pl-k">var</span> b <span class="pl-k">=</span> bar( <span class="pl-c1">3</span> ); <span class="pl-c">// 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( b ); <span class="pl-c">// 5</span></pre></div>

<p><code>bind(..)</code> returns a new function that is hard-coded to call the original function with the <code>this</code> context set as you specified.</p>

<p><strong>Note:</strong> As of ES6, the hard-bound function produced by <code>bind(..)</code> has a <code>.name</code> property that derives from the original <em>target function</em>. For example: <code>bar = foo.bind(..)</code> should have a <code>bar.name</code> value of <code>"bound foo"</code>, which is the function call name that should show up in a stack trace.</p>

<h4><a id="user-content-api-call-contexts" class="anchor" href="#api-call-contexts" aria-hidden="true"><span class="octicon octicon-link"></span></a>API Call "Contexts"</h4>

<p>Many libraries' functions, and indeed many new built-in functions in the JavaScript language and host environment, provide an optional parameter, usually called "context", which is designed as a work-around for you not having to use <code>bind(..)</code> to ensure your callback function uses a particular <code>this</code>.</p>

<p>For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">el</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( el, <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>
};

<span class="pl-c">// use `obj` as `this` for `foo(..)` calls</span>
[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>].forEach( foo, obj ); <span class="pl-c">// 1 awesome  2 awesome  3 awesome</span></pre></div>

<p>Internally, these various functions almost certainly use <em>explicit binding</em> via <code>call(..)</code> or <code>apply(..)</code>, saving you the trouble.</p>

<h3><a id="user-content-new-binding" class="anchor" href="#new-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>new</code> Binding</h3>

<p>The fourth and final rule for <code>this</code> binding requires us to re-think a very common misconception about functions and objects in JavaScript.</p>

<p>In traditional class-oriented languages, "constructors" are special methods attached to classes, that when the class is instantiated with a <code>new</code> operator, the constructor of that class is called. This usually looks something like:</p>

<div class="highlight highlight-js"><pre>something <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyClass</span>(..);</pre></div>

<p>JavaScript has a <code>new</code> operator, and the code pattern to use it looks basically identical to what we see in those class-oriented languages; most developers assume that JavaScript's mechanism is doing something similar. However, there really is <em>no connection</em> to class-oriented functionality implied by <code>new</code> usage in JS.</p>

<p>First, let's re-define what a "constructor" in JavaScript is. In JS, constructors are <strong>just functions</strong> that happen to be called with the <code>new</code> operator in front of them. They are not attached to classes, nor are they instantiating a class. They are not even special types of functions. They're just regular functions that are, in essence, hijacked by the use of <code>new</code> in their invocation.</p>

<p>For example, the <code>Number(..)</code> function acting as a constructor, quoting from the ES5.1 spec:</p>

<blockquote>
<p>15.7.2 The Number Constructor</p>

<p>When Number is called as part of a new expression it is a constructor: it initialises the newly created object.</p>
</blockquote>

<p>So, pretty much any ol' function, including the built-in object functions like <code>Number(..)</code> (see Chapter 3) can be called with <code>new</code> in front of it, and that makes that function call a <em>constructor call</em>. This is an important but subtle distinction: there's really no such thing as "constructor functions", but rather construction calls <em>of</em> functions.</p>

<p>When a function is invoked with <code>new</code> in front of it, otherwise known as a constructor call, the following things are done automatically:</p>

<ol>
<li>a brand new object is created (aka, constructed) out of thin air</li>
<li><em>the newly constructed object is <code>[[Prototype]]</code>-linked</em></li>
<li>the newly constructed object is set as the <code>this</code> binding for that function call</li>
<li>unless the function returns its own alternate <strong>object</strong>, the <code>new</code>-invoked function call will <em>automatically</em> return the newly constructed object.</li>
</ol>

<p>Steps 1, 3, and 4 apply to our current discussion. We'll skip over step 2 for now and come back to it in Chapter 5.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>) {
    <span class="pl-v">this</span>.a <span class="pl-k">=</span> a;
}

<span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">foo</span>( <span class="pl-c1">2</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( bar.a ); <span class="pl-c">// 2</span></pre></div>

<p>By calling <code>foo(..)</code> with <code>new</code> in front of it, we've constructed a new object and set that new object as the <code>this</code> for the call of <code>foo(..)</code>. <strong>So <code>new</code> is the final way that a function call's <code>this</code> can be bound.</strong> We'll call this <em>new binding</em>.</p>

<h2><a id="user-content-everything-in-order" class="anchor" href="#everything-in-order" aria-hidden="true"><span class="octicon octicon-link"></span></a>Everything In Order</h2>

<p>So, now we've uncovered the 4 rules for binding <code>this</code> in function calls. <em>All</em> you need to do is find the call-site and inspect it to see which rule applies. But, what if the call-site has multiple eligible rules? There must be an order of precedence to these rules, and so we will next demonstrate what order to apply the rules.</p>

<p>It should be clear that the <em>default binding</em> is the lowest priority rule of the 4. So we'll just set that one aside.</p>

<p>Which is more precedent, <em>implicit binding</em> or <em>explicit binding</em>? Let's test it:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">3</span>,
    foo<span class="pl-k">:</span> foo
};

obj1.foo(); <span class="pl-c">// 2</span>
obj2.foo(); <span class="pl-c">// 3</span>

obj1.foo.<span class="pl-c1">call</span>( obj2 ); <span class="pl-c">// 3</span>
obj2.foo.<span class="pl-c1">call</span>( obj1 ); <span class="pl-c">// 2</span></pre></div>

<p>So, <em>explicit binding</em> takes precedence over <em>implicit binding</em>, which means you should ask <strong>first</strong> if <em>explicit binding</em> applies before checking for <em>implicit binding</em>.</p>

<p>Now, we just need to figure out where <em>new binding</em> fits in the precedence.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">something</span>) {
    <span class="pl-v">this</span>.a <span class="pl-k">=</span> something;
}

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> foo
};

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {};

obj1.foo( <span class="pl-c1">2</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( obj1.a ); <span class="pl-c">// 2</span>

obj1.foo.<span class="pl-c1">call</span>( obj2, <span class="pl-c1">3</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( obj2.a ); <span class="pl-c">// 3</span>

<span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">obj1.foo</span>( <span class="pl-c1">4</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( obj1.a ); <span class="pl-c">// 2</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( bar.a ); <span class="pl-c">// 4</span></pre></div>

<p>OK, <em>new binding</em> is more precedent than <em>implicit binding</em>. But do you think <em>new binding</em> is more or less precedent than <em>explicit binding</em>?</p>

<p><strong>Note:</strong> <code>new</code> and <code>call</code>/<code>apply</code> cannot be used together, so <code>new foo.call(obj1)</code> is not allowed, to test <em>new binding</em> directly against <em>explicit binding</em>. But we can still use a <em>hard binding</em> to test the precedence of the two rules.</p>

<p>Before we explore that in a code listing, think back to how <em>hard binding</em> physically works, which is that <code>Function.prototype.bind(..)</code> creates a new wrapper function that is hard-coded to ignore its own <code>this</code> binding (whatever it may be), and use a manual one we provide.</p>

<p>By that reasoning, it would seem obvious to assume that <em>hard binding</em> (which is a form of <em>explicit binding</em>) is more precedent than <em>new binding</em>, and thus cannot be overridden with <code>new</code>.</p>

<p>Let's check:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">something</span>) {
    <span class="pl-v">this</span>.a <span class="pl-k">=</span> something;
}

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.bind( obj1 );
bar( <span class="pl-c1">2</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( obj1.a ); <span class="pl-c">// 2</span>

<span class="pl-k">var</span> baz <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">bar</span>( <span class="pl-c1">3</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( obj1.a ); <span class="pl-c">// 2</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( baz.a ); <span class="pl-c">// 3</span></pre></div>

<p>Whoa! <code>bar</code> is hard-bound against <code>obj1</code>, but <code>new bar(3)</code> did <strong>not</strong> change <code>obj1.a</code> to be <code>3</code> as we would have expected. Instead, the <em>hard bound</em> (to <code>obj1</code>) call to <code>bar(..)</code> <strong><em>is</em></strong> able to be overridden with <code>new</code>. Since <code>new</code> was applied, we got the newly created object back, which we named <code>baz</code>, and we see in fact that  <code>baz.a</code> has the value <code>3</code>.</p>

<p>This should be surprising if you go back to our "fake" bind helper:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">bind</span>(<span class="pl-smi">fn</span>, <span class="pl-smi">obj</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        fn.<span class="pl-c1">apply</span>( obj, arguments );
    };
}</pre></div>

<p>If you reason about how the helper's code works, it does not have a way for a <code>new</code> operator call to override the hard-binding to <code>obj</code> as we just observed.</p>

<p>But the built-in <code>Function.prototype.bind(..)</code> as of ES5 is more sophisticated, quite a bit so in fact. Here is the (slightly reformatted) polyfill provided by the MDN page for <code>bind(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.bind) {
    <span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">bind</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">oThis</span>) {
        <span class="pl-k">if</span> (<span class="pl-k">typeof</span> <span class="pl-v">this</span> <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>) {
            <span class="pl-c">// closest thing possible to the ECMAScript 5</span>
            <span class="pl-c">// internal IsCallable function</span>
            <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">TypeError</span>( <span class="pl-s"><span class="pl-pds">"</span>Function.prototype.bind - what <span class="pl-pds">"</span></span> <span class="pl-k">+</span>
                <span class="pl-s"><span class="pl-pds">"</span>is trying to be bound is not callable<span class="pl-pds">"</span></span>
            );
        }

        <span class="pl-k">var</span> aArgs <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span> ),
            fToBind <span class="pl-k">=</span> <span class="pl-v">this</span>,
            <span class="pl-en">fNOP</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){},
            <span class="pl-en">fBound</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
                <span class="pl-k">return</span> fToBind.<span class="pl-c1">apply</span>(
                    (
                        <span class="pl-v">this</span> <span class="pl-k">instanceof</span> fNOP <span class="pl-k">&amp;&amp;</span>
                        oThis <span class="pl-k">?</span> this <span class="pl-k">:</span> oThis
                    ),
                    aArgs.<span class="pl-c1">concat</span>( <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arguments ) )
                );
            }
        ;

        <span class="pl-c1">fNOP</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-v">this</span>.<span class="pl-c1">prototype</span>;
        <span class="pl-c1">fBound</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">fNOP</span>();

        <span class="pl-k">return</span> fBound;
    };
}</pre></div>

<p><strong>Note:</strong> The <code>bind(..)</code> polyfill shown above differs from the built-in <code>bind(..)</code> in ES5 with respect to hard-bound functions that will be used with <code>new</code> (see below for why that's useful). Because the polyfill cannot create a function without a <code>.prototype</code> as the built-in utility does, there's some nuanced indirection to approximate the same behavior. Tread carefully if you plan to use <code>new</code> with a hard-bound function and you rely on this polyfill.</p>

<p>The part that's allowing <code>new</code> overriding is:</p>

<div class="highlight highlight-js"><pre><span class="pl-v">this</span> <span class="pl-k">instanceof</span> fNOP <span class="pl-k">&amp;&amp;</span>
oThis <span class="pl-k">?</span> this <span class="pl-k">:</span> oThis

<span class="pl-c">// ... and:</span>

<span class="pl-c1">fNOP</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-v">this</span>.<span class="pl-c1">prototype</span>;
<span class="pl-c1">fBound</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">fNOP</span>();</pre></div>

<p>We won't actually dive into explaining how this trickery works (it's complicated and beyond our scope here), but essentially the utility determines whether or not the hard-bound function has been called with <code>new</code> (resulting in a newly constructed object being its <code>this</code>), and if so, it uses <em>that</em> newly created <code>this</code> rather than the previously specified <em>hard binding</em> for <code>this</code>.</p>

<p>Why is <code>new</code> being able to override <em>hard binding</em> useful?</p>

<p>The primary reason for this behavior is to create a function (that can be used with <code>new</code> for constructing objects) that essentially ignores the <code>this</code> <em>hard binding</em> but which presets some or all of the function's arguments. One of the capabilities of <code>bind(..)</code> is that any arguments passed after the first <code>this</code> binding argument are defaulted as standard arguments to the underlying function (technically called "partial application", which is a subset of "currying").</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">p1</span>,<span class="pl-smi">p2</span>) {
    <span class="pl-v">this</span>.val <span class="pl-k">=</span> p1 <span class="pl-k">+</span> p2;
}

<span class="pl-c">// using `null` here because we don't care about</span>
<span class="pl-c">// the `this` hard-binding in this scenario, and</span>
<span class="pl-c">// it will be overridden by the `new` call anyway!</span>
<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.bind( <span class="pl-c1">null</span>, <span class="pl-s"><span class="pl-pds">"</span>p1<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> baz <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">bar</span>( <span class="pl-s"><span class="pl-pds">"</span>p2<span class="pl-pds">"</span></span> );

baz.val; <span class="pl-c">// p1p2</span></pre></div>

<h3><a id="user-content-determining-this" class="anchor" href="#determining-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Determining <code>this</code></h3>

<p>Now, we can summarize the rules for determining <code>this</code> from a function call's call-site, in their order of precedence. Ask these questions in this order, and stop when the first rule applies.</p>

<ol>
<li><p>Is the function called with <code>new</code> (<strong>new binding</strong>)? If so, <code>this</code> is the newly constructed object.</p>

<p><code>var bar = new foo()</code></p></li>
<li><p>Is the function called with <code>call</code> or <code>apply</code> (<strong>explicit binding</strong>), even hidden inside a <code>bind</code> <em>hard binding</em>? If so, <code>this</code> is the explicitly specified object.</p>

<p><code>var bar = foo.call( obj2 )</code></p></li>
<li><p>Is the function called with a context (<strong>implicit binding</strong>), otherwise known as an owning or containing object? If so, <code>this</code> is <em>that</em> context object.</p>

<p><code>var bar = obj1.foo()</code></p></li>
<li><p>Otherwise, default the <code>this</code> (<strong>default binding</strong>). If in <code>strict mode</code>, pick <code>undefined</code>, otherwise pick the <code>global</code> object.</p>

<p><code>var bar = foo()</code></p></li>
</ol>

<p>That's it. That's <em>all it takes</em> to understand the rules of <code>this</code> binding for normal function calls. Well... almost.</p>

<h2><a id="user-content-binding-exceptions" class="anchor" href="#binding-exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Binding Exceptions</h2>

<p>As usual, there are some <em>exceptions</em> to the "rules".</p>

<p>The <code>this</code>-binding behavior can in some scenarios be surprising, where you intended a different binding but you end up with binding behavior from the <em>default binding</em> rule (see previous).</p>

<h3><a id="user-content-ignored-this" class="anchor" href="#ignored-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ignored <code>this</code></h3>

<p>If you pass <code>null</code> or <code>undefined</code> as a <code>this</code> binding parameter to <code>call</code>, <code>apply</code>, or <code>bind</code>, those values are effectively ignored, and instead the <em>default binding</em> rule applies to the invocation.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

foo.<span class="pl-c1">call</span>( <span class="pl-c1">null</span> ); <span class="pl-c">// 2</span></pre></div>

<p>Why would you intentionally pass something like <code>null</code> for a <code>this</code> binding?</p>

<p>It's quite common to use <code>apply(..)</code> for spreading out arrays of values as parameters to a function call. Similarly, <code>bind(..)</code> can curry parameters (pre-set values), which can be very helpful.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span> <span class="pl-k">+</span> a <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>, b:<span class="pl-pds">"</span></span> <span class="pl-k">+</span> b );
}

<span class="pl-c">// spreading out array as parameters</span>
foo.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ); <span class="pl-c">// a:2, b:3</span>

<span class="pl-c">// currying with `bind(..)`</span>
<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.bind( <span class="pl-c1">null</span>, <span class="pl-c1">2</span> );
bar( <span class="pl-c1">3</span> ); <span class="pl-c">// a:2, b:3</span></pre></div>

<p>Both these utilities require a <code>this</code> binding for the first parameter. If the functions in question don't care about <code>this</code>, you need a placeholder value, and <code>null</code> might seem like a reasonable choice as shown in this snippet.</p>

<p><strong>Note:</strong> We don't cover it in this book, but ES6 has the <code>...</code> spread operator which will let you syntactically "spread out" an array as parameters without needing <code>apply(..)</code>, such as <code>foo(...[1,2])</code>, which amounts to <code>foo(1,2)</code> -- syntactically avoiding a <code>this</code> binding if it's unnecessary. Unfortunately, there's no ES6 syntactic substitute for currying, so the <code>this</code> parameter of the <code>bind(..)</code> call still needs attention.</p>

<p>However, there's a slight hidden "danger" in always using <code>null</code> when you don't care about the <code>this</code> binding. If you ever use that against a function call (for instance, a third-party library function that you don't control), and that function <em>does</em> make a <code>this</code> reference, the <em>default binding</em> rule means it might inadvertently reference (or worse, mutate!) the <code>global</code> object (<code>window</code> in the browser).</p>

<p>Obviously, such a pitfall can lead to a variety of <em>very difficult</em> to diagnose/track-down bugs.</p>

<h4><a id="user-content-safer-this" class="anchor" href="#safer-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Safer <code>this</code></h4>

<p>Perhaps a somewhat "safer" practice is to pass a specifically set up object for <code>this</code> which is guaranteed not to be an object that can create problematic side effects in your program. Borrowing terminology from networking (and the military), we can create a "DMZ" (de-militarized zone) object -- nothing more special than a completely empty, non-delegated (see Chapters 5 and 6) object.</p>

<p>If we always pass a DMZ object for ignored <code>this</code> bindings we don't think we need to care about, we're sure any hidden/unexpected usage of <code>this</code> will be restricted to the empty object, which insulates our program's <code>global</code> object from side-effects.</p>

<p>Since this object is totally empty, I personally like to give it the variable name <code></code> (the lowercase mathematical symbol for the empty set). On many keyboards (like US-layout on Mac), this symbol is easily typed with <code></code>+<code>o</code> (option+<code>o</code>). Some systems also let you set up hotkeys for specific symbols. If you don't like the <code></code> symbol, or your keyboard doesn't make that as easy to type, you can of course call it whatever you want.</p>

<p>Whatever you call it, the easiest way to set it up as <strong>totally empty</strong> is <code>Object.create(null)</code> (see Chapter 5). <code>Object.create(null)</code> is similar to <code>{ }</code>, but without the delegation to <code>Object.prototype</code>, so it's "more empty" than just <code>{ }</code>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span> <span class="pl-k">+</span> a <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>, b:<span class="pl-pds">"</span></span> <span class="pl-k">+</span> b );
}

<span class="pl-c">// our DMZ empty object</span>
<span class="pl-k">var</span>  <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( <span class="pl-c1">null</span> );

<span class="pl-c">// spreading out array as parameters</span>
foo.<span class="pl-c1">apply</span>( , [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ); <span class="pl-c">// a:2, b:3</span>

<span class="pl-c">// currying with `bind(..)`</span>
<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.bind( , <span class="pl-c1">2</span> );
bar( <span class="pl-c1">3</span> ); <span class="pl-c">// a:2, b:3</span></pre></div>

<p>Not only functionally "safer", there's a sort of stylistic benefit to <code></code>, in that it semantically conveys "I want the <code>this</code> to be empty" a little more clearly than <code>null</code> might. But again, name your DMZ object whatever you prefer.</p>

<h3><a id="user-content-indirection" class="anchor" href="#indirection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Indirection</h3>

<p>Another thing to be aware of is you can (intentionally or not!) create "indirect references" to functions, and in those cases,  when that function reference is invoked, the <em>default binding</em> rule also applies.</p>

<p>One of the most common ways that <em>indirect references</em> occur is from an assignment:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
<span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">3</span>, foo<span class="pl-k">:</span> foo };
<span class="pl-k">var</span> p <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">4</span> };

o.foo(); <span class="pl-c">// 3</span>
(p.foo <span class="pl-k">=</span> o.foo)(); <span class="pl-c">// 2</span></pre></div>

<p>The <em>result value</em> of the assignment expression <code>p.foo = o.foo</code> is a reference to just the underlying function object. As such, the effective call-site is just <code>foo()</code>, not <code>p.foo()</code> or <code>o.foo()</code> as you might expect. Per the rules above, the <em>default binding</em> rule applies.</p>

<p>Reminder: regardless of how you get to a function invocation using the <em>default binding</em> rule, the <code>strict mode</code> status of the <strong>contents</strong> of the invoked function making the <code>this</code> reference -- not the function call-site -- determines the <em>default binding</em> value: either the <code>global</code> object if in non-<code>strict mode</code> or <code>undefined</code> if in <code>strict mode</code>.</p>

<h3><a id="user-content-softening-binding" class="anchor" href="#softening-binding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Softening Binding</h3>

<p>We saw earlier that <em>hard binding</em> was one strategy for preventing a function call falling back to the <em>default binding</em> rule inadvertently, by forcing it to be bound to a specific <code>this</code> (unless you use <code>new</code> to override it!). The problem is, <em>hard-binding</em> greatly reduces the flexibility of a function, preventing manual <code>this</code> override with either the <em>implicit binding</em> or even subsequent <em>explicit binding</em> attempts.</p>

<p>It would be nice if there was a way to provide a different default for <em>default binding</em> (not <code>global</code> or <code>undefined</code>), while still leaving the function able to be manually <code>this</code> bound via <em>implicit binding</em> or <em>explicit binding</em> techniques.</p>

<p>We can construct a so-called <em>soft binding</em> utility which emulates our desired behavior.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.softBind) {
    <span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">softBind</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">obj</span>) {
        <span class="pl-k">var</span> fn <span class="pl-k">=</span> <span class="pl-v">this</span>,
            curried <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span> ),
            <span class="pl-en">bound</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">bound</span>() {
                <span class="pl-k">return</span> fn.<span class="pl-c1">apply</span>(
                    (<span class="pl-k">!</span><span class="pl-v">this</span> <span class="pl-k">||</span>
                        (<span class="pl-k">typeof</span> <span class="pl-c1">window</span> <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span>
                            <span class="pl-v">this</span> <span class="pl-k">===</span> <span class="pl-c1">window</span>) <span class="pl-k">||</span>
                        (<span class="pl-k">typeof</span> <span class="pl-c1">global</span> <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span> <span class="pl-k">&amp;&amp;</span>
                            <span class="pl-v">this</span> <span class="pl-k">===</span> <span class="pl-c1">global</span>)
                    ) <span class="pl-k">?</span> obj <span class="pl-k">:</span> <span class="pl-v">this</span>,
                    curried.concat.<span class="pl-c1">apply</span>( curried, arguments )
                );
            };
        <span class="pl-c1">bound</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( fn.<span class="pl-c1">prototype</span> );
        <span class="pl-k">return</span> bound;
    };
}</pre></div>

<p>The <code>softBind(..)</code> utility provided here works similarly to the built-in ES5 <code>bind(..)</code> utility, except with our <em>soft binding</em> behavior. It wraps the specified function in logic that checks the <code>this</code> at call-time and if it's <code>global</code> or <code>undefined</code>, uses a pre-specified alternate <em>default</em> (<code>obj</code>). Otherwise the <code>this</code> is left untouched. It also provides optional currying (see the <code>bind(..)</code> discussion earlier).</p>

<p>Let's demonstrate its usage:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
   <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>name: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>);
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> { name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj<span class="pl-pds">"</span></span> },
    obj2 <span class="pl-k">=</span> { name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj2<span class="pl-pds">"</span></span> },
    obj3 <span class="pl-k">=</span> { name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj3<span class="pl-pds">"</span></span> };

<span class="pl-k">var</span> fooOBJ <span class="pl-k">=</span> foo.softBind( obj );

fooOBJ(); <span class="pl-c">// name: obj</span>

obj2.foo <span class="pl-k">=</span> foo.softBind(obj);
obj2.foo(); <span class="pl-c">// name: obj2   &lt;---- look!!!</span>

fooOBJ.<span class="pl-c1">call</span>( obj3 ); <span class="pl-c">// name: obj3   &lt;---- look!</span>

<span class="pl-c1">setTimeout</span>( obj2.foo, <span class="pl-c1">10</span> ); <span class="pl-c">// name: obj   &lt;---- falls back to soft-binding</span></pre></div>

<p>The soft-bound version of the <code>foo()</code> function can be manually <code>this</code>-bound to <code>obj2</code> or <code>obj3</code> as shown, but it falls back to <code>obj</code> if the <em>default binding</em> would otherwise apply.</p>

<h2><a id="user-content-lexical-this" class="anchor" href="#lexical-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lexical <code>this</code></h2>

<p>Normal functions abide by the 4 rules we just covered. But ES6 introduces a special kind of function that does not use these rules: arrow-function.</p>

<p>Arrow-functions are signified not by the <code>function</code> keyword, but by the <code>=&gt;</code> so called "fat arrow" operator. Instead of using the four standard <code>this</code> rules, arrow-functions adopt the <code>this</code> binding from the enclosing (function or global) scope.</p>

<p>Let's illustrate arrow-function lexical scope:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// return an arrow function</span>
    <span class="pl-k">return</span> (<span class="pl-smi">a</span>)<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// `this` here is lexically adopted from `foo()`</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
    };
}

<span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> obj2 <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">3</span>
};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> foo.<span class="pl-c1">call</span>( obj1 );
bar.<span class="pl-c1">call</span>( obj2 ); <span class="pl-c">// 2, not 3!</span></pre></div>

<p>The arrow-function created in <code>foo()</code> lexically captures whatever <code>foo()</code>s <code>this</code> is at its call-time. Since <code>foo()</code> was <code>this</code>-bound to <code>obj1</code>, <code>bar</code> (a reference to the returned arrow-function) will also be <code>this</code>-bound to <code>obj1</code>. The lexical binding of an arrow-function cannot be overridden (even with <code>new</code>!).</p>

<p>The most common use-case will likely be in the use of callbacks, such as event handlers or timers:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c1">setTimeout</span>(()<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// `this` here is lexically adopted from `foo()`</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.a );
    },<span class="pl-c1">100</span>);
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

foo.<span class="pl-c1">call</span>( obj ); <span class="pl-c">// 2</span></pre></div>

<p>While arrow-functions provide an alternative to using <code>bind(..)</code> on a function to ensure its <code>this</code>, which can seem attractive, it's important to note that they essentially are disabling the traditional <code>this</code> mechanism in favor of more widely-understood lexical scoping. Pre-ES6, we already have a fairly common pattern for doing so, which is basically almost indistinguishable from the spirit of ES6 arrow-functions:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>; <span class="pl-c">// lexical capture of `this`</span>
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( self.a );
    }, <span class="pl-c1">100</span> );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

foo.<span class="pl-c1">call</span>( obj ); <span class="pl-c">// 2</span></pre></div>

<p>While <code>self = this</code> and arrow-functions both seem like good "solutions" to not wanting to use <code>bind(..)</code>, they are essentially fleeing from <code>this</code> instead of understanding and embracing it.</p>

<p>If you find yourself writing <code>this</code>-style code, but most or all the time, you defeat the <code>this</code> mechanism with lexical <code>self = this</code> or arrow-function "tricks", perhaps you should either:</p>

<ol>
<li><p>Use only lexical scope and forget the false pretense of <code>this</code>-style code.</p></li>
<li><p>Embrace <code>this</code>-style mechanisms completely, including using <code>bind(..)</code> where necessary, and try to avoid <code>self = this</code> and arrow-function "lexical this" tricks.</p></li>
</ol>

<p>A program can effectively use both styles of code (lexical and <code>this</code>), but inside of the same function, and indeed for the same sorts of look-ups, mixing the two mechanisms is usually asking for harder-to-maintain code, and probably working too hard to be clever.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Determining the <code>this</code> binding for an executing function requires finding the direct call-site of that function. Once examined, four rules can be applied to the call-site, in <em>this</em> order of precedence:</p>

<ol>
<li><p>Called with <code>new</code>? Use the newly constructed object.</p></li>
<li><p>Called with <code>call</code> or <code>apply</code> (or <code>bind</code>)? Use the specified object.</p></li>
<li><p>Called with a context object owning the call? Use that context object.</p></li>
<li><p>Default: <code>undefined</code> in <code>strict mode</code>, global object otherwise.</p></li>
</ol>

<p>Be careful of accidental/unintentional invoking of the <em>default binding</em> rule. In cases where you want to "safely" ignore a <code>this</code> binding, a "DMZ" object like <code> = Object.create(null)</code> is a good placeholder value that protects the <code>global</code> object from unintended side-effects.</p>

<p>Instead of the four standard binding rules, ES6 arrow-functions use lexical scoping for <code>this</code> binding, which means they adopt the <code>this</code> binding (whatever it is) from its enclosing function call. They are essentially a syntactic replacement of <code>self = this</code> in pre-ES6 coding.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-3-objects" class="anchor" href="#chapter-3-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3: Objects</h1>

<p>In Chapters 1 and 2, we explained how the <code>this</code> binding points to various objects depending on the call-site of the function invocation. But what exactly are objects, and why do we need to point to them? We will explore objects in detail in this chapter.</p>

<h2><a id="user-content-syntax" class="anchor" href="#syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax</h2>

<p>Objects come in two forms: the declarative (literal) form, and the constructed form.</p>

<p>The literal syntax for an object looks like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObj <span class="pl-k">=</span> {
    key<span class="pl-k">:</span> value
    <span class="pl-c">// ...</span>
};</pre></div>

<p>The constructed form looks like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Object</span>();
myObj.key <span class="pl-k">=</span> value;</pre></div>

<p>The constructed form and the literal form result in exactly the same sort of object. The only difference really is that you can add one or more key/value pairs to the literal declaration, whereas with constructed-form objects, you must add the properties one-by-one.</p>

<p><strong>Note:</strong> It's extremely uncommon to use the "constructed form" for creating objects as just shown. You would pretty much always want to use the literal syntax form. The same will be true of most of the built-in objects (see below).</p>

<h2><a id="user-content-type" class="anchor" href="#type" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type</h2>

<p>Objects are the general building block upon which much of JS is built. They are one of the 6 primary types (called "language types" in the specification) in JS:</p>

<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>object</code></li>
</ul>

<p>Note that the <em>simple primitives</em> (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, and <code>undefined</code>) are <strong>not</strong> themselves <code>objects</code>. <code>null</code> is sometimes referred to as an object type, but this misconception stems from a bug in the language which causes <code>typeof null</code> to return the string <code>"object"</code> incorrectly (and confusingly). In fact, <code>null</code> is its own primitive type.</p>

<p><strong>It's a common mis-statement that "everything in JavaScript is an object". This is clearly not true.</strong></p>

<p>By contrast, there <em>are</em> a few special object sub-types, which we can refer to as <em>complex primitives</em>.</p>

<p><code>function</code> is a sub-type of object (technically, a "callable object"). Functions in JS are said to be "first class" in that they are basically just normal objects (with callable behavior semantics bolted on), and so they can be handled like any other plain object.</p>

<p>Arrays are also a form of objects, with extra behavior. The organization of contents in arrays is slightly more structured than for general objects.</p>

<h3><a id="user-content-built-in-objects" class="anchor" href="#built-in-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Built-in Objects</h3>

<p>There are several other object sub-types, usually referred to as built-in objects. For some of them, their names seem to imply they are directly related to their simple primitives counter-parts, but in fact, their relationship is more complicated, which we'll explore shortly.</p>

<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code></li>
<li><code>Function</code></li>
<li><code>Array</code></li>
<li><code>Date</code></li>
<li><code>RegExp</code></li>
<li><code>Error</code></li>
</ul>

<p>These built-ins have the appearance of being actual types, even classes, if you rely on the similarity to other languages such as Java's <code>String</code> class.</p>

<p>But in JS, these are actually just built-in functions. Each of these built-in functions can be used as a constructor (that is, a function call with the <code>new</code> operator -- see Chapter 2), with the result being a newly <em>constructed</em> object of the sub-type in question. For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> strPrimitive <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>I am a string<span class="pl-pds">"</span></span>;
<span class="pl-k">typeof</span> strPrimitive;                            <span class="pl-c">// "string"</span>
strPrimitive <span class="pl-k">instanceof</span> <span class="pl-c1">String</span>;                 <span class="pl-c">// false</span>

<span class="pl-k">var</span> strObject <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">String</span>( <span class="pl-s"><span class="pl-pds">"</span>I am a string<span class="pl-pds">"</span></span> );
<span class="pl-k">typeof</span> strObject;                               <span class="pl-c">// "object"</span>
strObject <span class="pl-k">instanceof</span> <span class="pl-c1">String</span>;                    <span class="pl-c">// true</span>

<span class="pl-c">// inspect the object sub-type</span>
<span class="pl-c1">Object</span>.<span class="pl-c1">prototype</span>.toString.<span class="pl-c1">call</span>( strObject );    <span class="pl-c">// [object String]</span></pre></div>

<p>We'll see in detail in a later chapter exactly how the <code>Object.prototype.toString...</code> bit works, but briefly, we can inspect the internal sub-type by borrowing the base default <code>toString()</code> method, and you can see it reveals that <code>strObject</code> is an object that was in fact created by the <code>String</code> constructor.</p>

<p>The primitive value <code>"I am a string"</code> is not an object, it's a primitive literal and immutable value. To perform operations on it, such as checking its length, accessing its individual character contents, etc, a <code>String</code> object is required.</p>

<p>Luckily, the language automatically coerces a <code>"string"</code> primitive to a <code>String</code> object when necessary, which means you almost never need to explicitly create the Object form. It is <strong>strongly preferred</strong> by the majority of the JS community to use the literal form for a value, where possible, rather than the constructed object form.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> strPrimitive <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>I am a string<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( strPrimitive.<span class="pl-c1">length</span> );         <span class="pl-c">// 13</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( strPrimitive.<span class="pl-c1">charAt</span>( <span class="pl-c1">3</span> ) );    <span class="pl-c">// "m"</span></pre></div>

<p>In both cases, we call a property or method on a string primitive, and the engine automatically coerces it to a <code>String</code> object, so that the property/method access works.</p>

<p>The same sort of coercion happens between the number literal primitive <code>42</code> and the <code>new Number(42)</code> object wrapper, when using methods like <code>42.359.toFixed(2)</code>. Likewise for <code>Boolean</code> objects from <code>"boolean"</code> primitives.</p>

<p><code>null</code> and <code>undefined</code> have no object wrapper form, only their primitive values. By contrast, <code>Date</code> values can <em>only</em> be created with their constructed object form, as they have no literal form counter-part.</p>

<p><code>Object</code>s, <code>Array</code>s, <code>Function</code>s, and <code>RegExp</code>s (regular expressions) are all objects regardless of whether the literal or constructed form is used. The constructed form does offer, in some cases, more options in creation than the literal form counterpart. Since objects are created either way, the simpler literal form is almost universally preferred. <strong>Only use the constructed form if you need the extra options.</strong></p>

<p><code>Error</code> objects are rarely created explicitly in code, but usually created automatically when exceptions are thrown. They can be created with the constructed form <code>new Error(..)</code>, but it's often unnecessary.</p>

<h2><a id="user-content-contents" class="anchor" href="#contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contents</h2>

<p>As mentioned earlier, the contents of an object consist of values (any type) stored at specifically named <em>locations</em>, which we call properties.</p>

<p>It's important to note that while we say "contents" which implies that these values are <em>actually</em> stored inside the object, that's merely an appearance. The engine stores values in implementation-dependent ways, and may very well not store them <em>in</em> some object container. What <em>is</em> stored in the container are these property names, which act as pointers (technically, <em>references</em>) to where the values are stored.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.a;     <span class="pl-c">// 2</span>

myObject[<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>];  <span class="pl-c">// 2</span></pre></div>

<p>To access the value at the <em>location</em> <code>a</code> in <code>myObject</code>, we need to use either the <code>.</code> operator or the <code>[ ]</code> operator. The <code>.a</code> syntax is usually referred to as "property" access, whereas the <code>["a"]</code> syntax is usually referred to as "key" access. In reality, they both access the same <em>location</em>, and will pull out the same value, <code>2</code>, so the terms can be used interchangeably. We will use the most common term, "property access" from here on.</p>

<p>The main difference between the two syntaxes is that the <code>.</code> operator requires an <code>Identifier</code> compatible property name after it, whereas the <code>[".."]</code> syntax can take basically any UTF-8/unicode compatible string as the name for the property. To reference a property of the name "Super-Fun!", for instance, you would have to use the <code>["Super-Fun!"]</code> access syntax, as <code>Super-Fun!</code> is not a valid <code>Identifier</code> property name.</p>

<p>Also, since the <code>[".."]</code> syntax uses a string's <strong>value</strong> to specify the location, this means the program can programmatically build up the value of the string, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> wantA <span class="pl-k">=</span> <span class="pl-c1">true</span>;
<span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> idx;

<span class="pl-k">if</span> (wantA) {
    idx <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>;
}

<span class="pl-c">// later</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( myObject[idx] ); <span class="pl-c">// 2</span></pre></div>

<p>In objects, property names are <strong>always</strong> strings. If you use any other value besides a <code>string</code> (primitive) as the property, it will first be converted to a string. This even includes numbers, which are commonly used as array indexes, so be careful not to confuse the use of numbers between objects and arrays.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> { };

myObject[<span class="pl-c1">true</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
myObject[<span class="pl-c1">3</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;
myObject[myObject] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;

myObject[<span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>];               <span class="pl-c">// "foo"</span>
myObject[<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>];                  <span class="pl-c">// "bar"</span>
myObject[<span class="pl-s"><span class="pl-pds">"</span>[object Object]<span class="pl-pds">"</span></span>];    <span class="pl-c">// "baz"</span></pre></div>

<h3><a id="user-content-computed-property-names" class="anchor" href="#computed-property-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computed Property Names</h3>

<p>The <code>myObject[..]</code> property access syntax we just described is useful if you need to use a computed expression value <em>as</em> the key name, like <code>myObject[prefix + name]</code>. But that's not really helpful when declaring objects using the object-literal syntax.</p>

<p>ES6 adds <em>computed property names</em>, where you can specify an expression, surrounded by a <code>[ ]</code> pair, in the key-name position of an object-literal declaration:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> prefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    [prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>,
    [prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>
};

myObject[<span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span>]; <span class="pl-c">// hello</span>
myObject[<span class="pl-s"><span class="pl-pds">"</span>foobaz<span class="pl-pds">"</span></span>]; <span class="pl-c">// world</span></pre></div>

<p>The most common usage of <em>computed property names</em> will probably be for ES6 <code>Symbol</code>s, which we will not be covering in detail in this book. In short, they're a new primitive data type which has an opaque unguessable value (technically a <code>string</code> value). You will be strongly discouraged from working with the <em>actual value</em> of a <code>Symbol</code> (which can theoretically be different between different JS engines), so the name of the <code>Symbol</code>, like <code>Symbol.Something</code> (just a made up name!), will be what you use:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    [Symbol.Something]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>
};</pre></div>

<h3><a id="user-content-property-vs-method" class="anchor" href="#property-vs-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property vs. Method</h3>

<p>Some developers like to make a distinction when talking about a property access on an object, if the value being accessed happens to be a function. Because it's tempting to think of the function as <em>belonging</em> to the object, and in other languages, functions which belong to objects (aka, "classes") are referred to as "methods", it's not uncommon to hear, "method access" as opposed to "property access".</p>

<p><strong>The specification makes this same distinction</strong>, interestingly.</p>

<p>Technically, functions never "belong" to objects, so saying that a function that just happens to be accessed on an object reference is automatically a "method" seems a bit of a stretch of semantics.</p>

<p>It <em>is</em> true that some functions have <code>this</code> references in them, and that <em>sometimes</em> these <code>this</code> references refer to the object reference at the call-site. But this usage really does not make that function any more a "method" than any other function, as <code>this</code> is dynamically bound at run-time, at the call-site, and thus its relationship to the object is indirect, at best.</p>

<p>Every time you access a property on an object, that is a <strong>property access</strong>, regardless of the type of value you get back. If you <em>happen</em> to get a function from that property access, it's not magically a "method" at that point. There's nothing special (outside of possible implicit <code>this</code> binding as explained earlier) about a function that comes from a property access.</p>

<p>For instance:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> someFoo <span class="pl-k">=</span> foo;  <span class="pl-c">// variable reference to `foo`</span>

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    someFoo<span class="pl-k">:</span> foo
};

foo;                <span class="pl-c">// function foo(){..}</span>

someFoo;            <span class="pl-c">// function foo(){..}</span>

myObject.someFoo;   <span class="pl-c">// function foo(){..}</span></pre></div>

<p><code>someFoo</code> and <code>myObject.someFoo</code> are just two separate references to the same function, and neither implies anything about the function being special or "owned" by any other object. If <code>foo()</code> above was defined to have a <code>this</code> reference inside it, that <code>myObject.someFoo</code> <em>implicit binding</em> would be the <strong>only</strong> observable difference between the two references. Neither reference really makes sense to be called a "method".</p>

<p><strong>Perhaps one could argue</strong> that a function <em>becomes a method</em>, not at definition time, but during run-time just for that invocation, depending on how it's called at its call-site (with an object reference context or not -- see Chapter 2 for more details). Even this interpretation is a bit of a stretch.</p>

<p>The safest conclusion is probably that "function" and "method" are interchangeable in JavaScript.</p>

<p><strong>Note:</strong> ES6 adds a <code>super</code> reference, which is typically going to be used with <code>class</code> (see Appendix A). The way <code>super</code> behaves (static binding rather than late binding as <code>this</code>) gives further weight to the idea that a function which is <code>super</code> bound somewhere is more a "method" than "function". But again, these are just subtle semantic (and mechanical) nuances.</p>

<p>Even when you declare a function expression as part of the object-literal, that function doesn't magically <em>belong</em> more to the object -- still just multiple references to the same function object:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> someFoo <span class="pl-k">=</span> myObject.foo;

someFoo;        <span class="pl-c">// function foo(){..}</span>

myObject.foo;   <span class="pl-c">// function foo(){..}</span></pre></div>

<p><strong>Note:</strong> In Chapter 6, we will cover an ES6 short-hand for that <code>foo: function foo(){ .. }</code> declaration syntax in our object-literal.</p>

<h3><a id="user-content-arrays" class="anchor" href="#arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arrays</h3>

<p>Arrays also use the <code>[ ]</code> access form, but as mentioned above, they have slightly more structured organization for how and where values are stored (though still no restriction on what <em>type</em> of values are stored). Arrays assume <em>numeric indexing</em>, which means that values are stored in locations, usually called <em>indices</em>, at non-negative integers, such as <code>0</code> and <code>42</code>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ];

myArray.<span class="pl-c1">length</span>;     <span class="pl-c">// 3</span>

myArray[<span class="pl-c1">0</span>];         <span class="pl-c">// "foo"</span>

myArray[<span class="pl-c1">2</span>];         <span class="pl-c">// "bar"</span></pre></div>

<p>Arrays <em>are</em> objects, so even though each index is a positive integer, you can <em>also</em> add properties onto the array:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ];

myArray.baz <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;

myArray.<span class="pl-c1">length</span>; <span class="pl-c">// 3</span>

myArray.baz;    <span class="pl-c">// "baz"</span></pre></div>

<p>Notice that adding named properties (regardless of <code>.</code> or <code>[ ]</code> operator syntax) does not change the reported <code>length</code> of the array.</p>

<p>You <em>could</em> use an array as a plain key/value object, and never add any numeric indices, but this is bad idea because arrays have behavior and optimizations specific to their intended use, and likewise with plain objects. Use objects to store key/value pairs, and arrays to store values at numeric indices.</p>

<p><strong>Be careful:</strong> If you try to add a property to an array, but the property name <em>looks</em> like a number, it will end up instead as a numeric index (thus modifying the array contents):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ];

myArray[<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;

myArray.<span class="pl-c1">length</span>; <span class="pl-c">// 4</span>

myArray[<span class="pl-c1">3</span>];     <span class="pl-c">// "baz"</span></pre></div>

<h3><a id="user-content-duplicating-objects" class="anchor" href="#duplicating-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Duplicating Objects</h3>

<p>One of the most commonly requested features when developers newly take up the JavaScript language is how to duplicate an object. It would seem like there should just be a built-in <code>copy()</code> method, right? It turns out that it's a little more complicated than that, because it's not fully clear what, by default, should be the algorithm for the duplication.</p>

<p>For example, consider this object:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">anotherFunction</span>() { <span class="pl-c">/*..*/</span> }

<span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    c<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

<span class="pl-k">var</span> anotherArray <span class="pl-k">=</span> [];

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    b<span class="pl-k">:</span> anotherObject,   <span class="pl-c">// reference, not a copy!</span>
    c<span class="pl-k">:</span> anotherArray,    <span class="pl-c">// another reference!</span>
    d<span class="pl-k">:</span> anotherFunction
};

anotherArray.<span class="pl-c1">push</span>( anotherObject, myObject );</pre></div>

<p>What exactly should be the representation of a <em>copy</em> of <code>myObject</code>?</p>

<p>Firstly, we should answer if it should be a <em>shallow</em> or <em>deep</em> copy? A <em>shallow copy</em> would end up with <code>a</code> on the new object as a copy of the value <code>2</code>, but <code>b</code>, <code>c</code>, and <code>d</code> properties as just references to the same places as the references in the original object. A <em>deep copy</em> would duplicate not only <code>myObject</code>, but <code>anotherObject</code> and <code>anotherArray</code>. But then we have issues that <code>anotherArray</code> has references to <code>anotherObject</code> and <code>myObject</code> in it, so <em>those</em> should also be duplicated rather than reference-preserved. Now we have an infinite circular duplication problem because of the circular reference.</p>

<p>Should we detect a circular reference and just break the circular traversal (leaving the deep element not fully duplicated)? Should we error out completely? Something in between?</p>

<p>Moreover, it's not really clear what "duplicating" a function would mean? There are some hacks like pulling out the <code>toString()</code> serialization of a function's source code (which varies across implementations and is not even reliable in all engines depending on the type of function being inspected).</p>

<p>So how do we resolve all these tricky questions? Various JS frameworks have each picked their own interpretations and made their own decisions. But which of these (if any) should JS adopt as <em>the</em> standard? For a long time, there was no clear answer.</p>

<p>One subset solution is that objects which are JSON-safe (that is, can be serialized to a JSON string and then re-parsed to an object with the same structure and values) can easily be <em>duplicated</em> with:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> newObj <span class="pl-k">=</span> <span class="pl-c1">JSON</span>.<span class="pl-c1">parse</span>( <span class="pl-c1">JSON</span>.stringify( someObj ) );</pre></div>

<p>Of course, that requires you to ensure your object is JSON safe. For some situations, that's trivial. For others, it's insufficient.</p>

<p>At the same time, a shallow copy is fairly understandable and has far less issues, so ES6 has now defined <code>Object.assign(..)</code> for this task. <code>Object.assign(..)</code> takes a <em>target</em> object as its first parameter, and one or more <em>source</em> objects as its subsequent parameters. It iterates over all the <em>enumerable</em> (see below), <em>owned keys</em> (<strong>immediately present</strong>) on the <em>source</em> object(s) and copies them (via <code>=</code> assignment only) to <em>target</em>. It also, helpfully, returns <em>target</em>, as you can see below:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> newObj <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign( {}, myObject );

newObj.a;                       <span class="pl-c">// 2</span>
newObj.b <span class="pl-k">===</span> anotherObject;     <span class="pl-c">// true</span>
newObj.c <span class="pl-k">===</span> anotherArray;      <span class="pl-c">// true</span>
newObj.d <span class="pl-k">===</span> anotherFunction;   <span class="pl-c">// true</span></pre></div>

<p><strong>Note:</strong> In the next section, we describe "property descriptors" (property characteristics) and show the use of <code>Object.defineProperty(..)</code>. The duplication that occurs for <code>Object.assign(..)</code> however is purely <code>=</code> style assignment, so any special characteristics of a property (like <code>writable</code>) on a source object <strong>are not preserved</strong> on the target object.</p>

<h3><a id="user-content-property-descriptors" class="anchor" href="#property-descriptors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property Descriptors</h3>

<p>Prior to ES5, the JavaScript language gave no direct way for your code to inspect or draw any distinction between the characteristics of properties, such as whether the property was read-only or not.</p>

<p>But as of ES5, all properties are described in terms of a <strong>property descriptor</strong>.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-c1">Object</span>.getOwnPropertyDescriptor( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> );
<span class="pl-c">// {</span>
<span class="pl-c">//    value: 2,</span>
<span class="pl-c">//    writable: true,</span>
<span class="pl-c">//    enumerable: true,</span>
<span class="pl-c">//    configurable: true</span>
<span class="pl-c">// }</span></pre></div>

<p>As you can see, the property descriptor (called a "data descriptor" since it's only for holding a data value) for our normal object property <code>a</code> is much more than just its <code>value</code> of <code>2</code>. It includes 3 other characteristics: <code>writable</code>, <code>enumerable</code>, and <code>configurable</code>.</p>

<p>While we can see what the default values for the property descriptor characteristics are when we create a normal property, we can use <code>Object.defineProperty(..)</code> to add a new property, or modify an existing one (if it's <code>configurable</code>!), with the desired characteristics.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {};

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} );

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>Using <code>defineProperty(..)</code>, we added the plain, normal <code>a</code> property to <code>myObject</code> in a manually explicit way. However, you generally wouldn't use this manual approach unless you wanted to modify one of the descriptor characteristics from its normal behavior.</p>

<h4><a id="user-content-writable" class="anchor" href="#writable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Writable</h4>

<p>The ability for you to change the value of a property is controlled by <code>writable</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {};

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>, <span class="pl-c">// not writable!</span>
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} );

myObject.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>As you can see, our modification of the <code>value</code> silently failed. If we try in <code>strict mode</code>, we get an error:</p>

<div class="highlight highlight-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> {};

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>, <span class="pl-c">// not writable!</span>
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} );

myObject.a <span class="pl-k">=</span> <span class="pl-c1">3</span>; <span class="pl-c">// TypeError</span></pre></div>

<p>The <code>TypeError</code> tells us we cannot change a non-writable property.</p>

<p><strong>Note:</strong> We will discuss getters/setters shortly, but briefly, you can observe that <code>writable:false</code> means a value cannot be changed, which is somewhat equivalent to if you defined a no-op setter. Actually, your no-op setter would need to throw a <code>TypeError</code> when called, to be truly conformant to <code>writable:false</code>.</p>

<h4><a id="user-content-configurable" class="anchor" href="#configurable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configurable</h4>

<p>As long as a property is currently configurable, we can modify its descriptor definition, using the same <code>defineProperty(..)</code> utility.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
myObject.a;                 <span class="pl-c">// 3</span>

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">4</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>,    <span class="pl-c">// not configurable!</span>
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} );

myObject.a;                 <span class="pl-c">// 4</span>
myObject.a <span class="pl-k">=</span> <span class="pl-c1">5</span>;
myObject.a;                 <span class="pl-c">// 5</span>

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">6</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} ); <span class="pl-c">// TypeError</span></pre></div>

<p>The final <code>defineProperty(..)</code> call results in a TypeError, regardless of <code>strict mode</code>, if you attempt to change the descriptor definition of a non-configurable property. Be careful: as you can see, changing <code>configurable</code> to <code>false</code> is a <strong>one-way action, and cannot be undone!</strong></p>

<p><strong>Note:</strong> There's a nuanced exception to be aware of: even if the property is already <code>configurable:false</code>, <code>writable</code> can always be changed from <code>true</code> to <code>false</code> without error, but not back to <code>true</code> if already <code>false</code>.</p>

<p>Another thing <code>configurable:false</code> prevents is the ability to use the <code>delete</code> operator to remove an existing property.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.a;             <span class="pl-c">// 2</span>
<span class="pl-k">delete</span> myObject.a;
myObject.a;             <span class="pl-c">// undefined</span>

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
} );

myObject.a;             <span class="pl-c">// 2</span>
<span class="pl-k">delete</span> myObject.a;
myObject.a;             <span class="pl-c">// 2</span></pre></div>

<p>As you can see, the last <code>delete</code> call failed (silently) because we made the <code>a</code> property non-configurable.</p>

<p><code>delete</code> is only used to remove object properties (which can be removed) directly from the object in question. If an object property is the last remaining <em>reference</em> to some object/function, and you <code>delete</code> it, that removes the reference and now that unreferenced object/function can be garbage collected. But, it is <strong>not</strong> proper to think of <code>delete</code> as a tool to free up allocated memory as it does in other languages (like C/C++). <code>delete</code> is just an object property removal operation -- nothing more.</p>

<h4><a id="user-content-enumerable" class="anchor" href="#enumerable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enumerable</h4>

<p>The final descriptor characteristic we will mention here (there are two others, which we deal with shortly when we discuss getter/setters) is <code>enumerable</code>.</p>

<p>The name probably makes it obvious, but this characteristic controls if a property will show up in certain object-property enumerations, such as the <code>for..in</code> loop. Set to <code>false</code> to keep it from showing up in such enumerations, even though it's still completely accessible. Set to <code>true</code> to keep it present.</p>

<p>All normal user-defined properties are defaulted to <code>enumerable</code>, as this is most commonly what you want. But if you have a special property you want to hide from enumeration, set it to <code>enumerable:false</code>.</p>

<p>We'll demonstrate enumerability in much more detail shortly, so keep a mental bookmark on this topic.</p>

<h3><a id="user-content-immutability" class="anchor" href="#immutability" aria-hidden="true"><span class="octicon octicon-link"></span></a>Immutability</h3>

<p>It is sometimes desired to make properties or objects that cannot be changed (either by accident or intentionally). ES5 adds support for handling that in a variety of different nuanced ways.</p>

<p>It's important to note that <strong>all</strong> of these approaches create shallow immutability. That is, they affect only the object and its direct property characteristics. If an object has a reference to another object (array, object, function, etc), the <em>contents</em> of that object are not affected, and remain mutable.</p>

<div class="highlight highlight-js"><pre>myImmutableObject.foo; <span class="pl-c">// [1,2,3]</span>
myImmutableObject.foo.<span class="pl-c1">push</span>( <span class="pl-c1">4</span> );
myImmutableObject.foo; <span class="pl-c">// [1,2,3,4]</span></pre></div>

<p>We assume in this snippet that <code>myImmutableObject</code> is already created and protected as immutable. But, to also protect the contents of <code>myImmutableObject.foo</code> (which is its own object -- array), you would also need to make <code>foo</code> immutable, using one or more of the following functionalities.</p>

<p><strong>Note:</strong> It is not terribly common to create deeply entrenched immutable objects in JS programs. Special cases can certainly call for it, but as a general design pattern, if you find yourself wanting to <em>seal</em> or <em>freeze</em> all your objects, you may want to take a step back and reconsider your program design to be more robust to potential changes in objects' values.</p>

<h4><a id="user-content-object-constant" class="anchor" href="#object-constant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Constant</h4>

<p>By combining <code>writable:false</code> and <code>configurable:false</code>, you can essentially create a <em>constant</em> (cannot be changed, redefined or deleted) as an object property, like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {};

<span class="pl-c1">Object</span>.defineProperty( myObject, <span class="pl-s"><span class="pl-pds">"</span>FAVORITE_NUMBER<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );</pre></div>

<h4><a id="user-content-prevent-extensions" class="anchor" href="#prevent-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prevent Extensions</h4>

<p>If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call <code>Object.preventExtensions(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-c1">Object</span>.preventExtensions( myObject );

myObject.b <span class="pl-k">=</span> <span class="pl-c1">3</span>;
myObject.b; <span class="pl-c">// undefined</span></pre></div>

<p>In <code>non-strict mode</code>, the creation of <code>b</code> fails silently. In <code>strict mode</code>, it throws a <code>TypeError</code>.</p>

<h4><a id="user-content-seal" class="anchor" href="#seal" aria-hidden="true"><span class="octicon octicon-link"></span></a>Seal</h4>

<p><code>Object.seal(..)</code> creates a "sealed" object, which means it takes an existing object and essentially calls <code>Object.preventExtensions(..)</code> on it, but also marks all its existing properties as <code>configurable:false</code>.</p>

<p>So, not only can you not add anymore properties, but you also cannot reconfigure or delete any existing properties (though you <em>can</em> still modify their values).</p>

<h4><a id="user-content-freeze" class="anchor" href="#freeze" aria-hidden="true"><span class="octicon octicon-link"></span></a>Freeze</h4>

<p><code>Object.freeze(..)</code> creates a frozen object, which means it takes an existing object and essentially calls <code>Object.seal(..)</code> on it, but it also marks all "data accessor" properties as <code>writable:false</code>, so that their values cannot be changed.</p>

<p>This approach is the highest level of immutability that you can attain for an object itself, as it prevents any changes to the object or to any of its direct properties (though, as mentioned above, the contents of any referenced other objects are unaffected).</p>

<p>You could "deep freeze" an object by calling <code>Object.freeze(..)</code> on the object, and then recursively iterating over all objects it references (which would have been unaffected thus far), and calling <code>Object.freeze(..)</code> on them as well. Be careful, though, as that could affect other (shared) objects you're not intending to affect.</p>

<h3><a id="user-content-get" class="anchor" href="#get" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>[[Get]]</code></h3>

<p>There's a subtle, but important, detail about how property accesses are performed.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>The <code>myObject.a</code> is a property access, but it doesn't <em>just</em> look in <code>myObject</code> for a property of the name <code>a</code>, as it might seem.</p>

<p>According to the spec, the code above actually performs a <code>[[Get]]</code> operation (kinda like a function call: <code>[[Get]]()</code>) on the <code>myObject</code>. The default built-in <code>[[Get]]</code> operation for an object <em>first</em> inspects the object for a property of the requested name, and if it finds it, it will return the value accordingly.</p>

<p>However, the <code>[[Get]]</code> algorithm defines other important behavior if it does <em>not</em> find a property of the requested name. We will examine in Chapter 5 what happens <em>next</em> (traversal of the <code>[[Prototype]]</code> chain, if any).</p>

<p>But one important result of this <code>[[Get]]</code> operation is that if it cannot through any means come up with a value for the requested property, it instead returns the value <code>undefined</code>.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.b; <span class="pl-c">// undefined</span></pre></div>

<p>This behavior is different from when you reference <em>variables</em> by their identifier names. If you reference a variable that cannot be resolved within the applicable lexical scope look-up, the result is not <code>undefined</code> as it is for object properties, but instead a <code>ReferenceError</code> is thrown.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">undefined</span>
};

myObject.a; <span class="pl-c">// undefined</span>

myObject.b; <span class="pl-c">// undefined</span></pre></div>

<p>From a <em>value</em> perspective, there is no difference between these two references -- they both result in <code>undefined</code>. However, the <code>[[Get]]</code> operation underneath, though subtle at a glance, potentially performed a bit more "work" for the reference <code>myObject.b</code> than for the reference <code>myObject.a</code>.</p>

<p>Inspecting only the value results, you cannot distinguish whether a property exists and holds the explicit value <code>undefined</code>, or whether the property does <em>not</em> exist and <code>undefined</code> was the default return value after <code>[[Get]]</code> failed to return something explicitly. However, we will see shortly how you <em>can</em> distinguish these two scenarios.</p>

<h3><a id="user-content-put" class="anchor" href="#put" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>[[Put]]</code></h3>

<p>Since there's an internally defined <code>[[Get]]</code> operation for getting a value from a property, it should be obvious there's also a default <code>[[Put]]</code> operation.</p>

<p>It may be tempting to think that an assignment to a property on an object would just invoke <code>[[Put]]</code> to set or create that property on the object in question. But the situation is more nuanced than that.</p>

<p>When invoking <code>[[Put]]</code>, how it behaves differs based on a number of factors, including (most impactfully) whether the property is already present on the object or not.</p>

<p>If the property is present, the <code>[[Put]]</code> algorithm will roughly check:</p>

<ol>
<li>Is the property an accessor descriptor (see "Getters &amp; Setters" section below)? <strong>If so, call the setter, if any.</strong></li>
<li>Is the property a data descriptor with <code>writable</code> of <code>false</code>? <strong>If so, silently fail in <code>non-strict mode</code>, or throw <code>TypeError</code> in <code>strict mode</code>.</strong></li>
<li>Otherwise, set the value to the existing property as normal.</li>
</ol>

<p>If the property is not yet present on the object in question, the <code>[[Put]]</code> operation is even more nuanced and complex. We will revisit this scenario in Chapter 5 when we discuss <code>[[Prototype]]</code> to give it more clarity.</p>

<h3><a id="user-content-getters--setters" class="anchor" href="#getters--setters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getters &amp; Setters</h3>

<p>The default <code>[[Put]]</code> and <code>[[Get]]</code> operations for objects completely control how values are set to existing or new properties, or retrieved from existing properties, respectively.</p>

<p><strong>Note:</strong> Using future/advanced capabilities of the language, it may be possible to override the default <code>[[Get]]</code> or <code>[[Put]]</code> operations for an entire object (not just per property). This is beyond the scope of our discussion in this book, but will be covered later in the "You Don't Know JS" series.</p>

<p>ES5 introduced a way to override part of these default operations, not on an object level but a per-property level, through the use of getters and setters. Getters are properties which actually call a hidden function to retrieve a value. Setters are properties which actually call a hidden function to set a value.</p>

<p>When you define a property to have either a getter or a setter or both, its definition becomes an "accessor descriptor" (as opposed to a "data descriptor"). For accessor-descriptors, the <code>value</code> and <code>writable</code> characteristics of the descriptor are moot and ignored, and instead JS considers the <code>set</code> and <code>get</code> characteristics of the property (as well as <code>configurable</code> and <code>enumerable</code>).</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    <span class="pl-c">// define a getter for `a`</span>
    get <span class="pl-en">a</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">2</span>;
    }
};

<span class="pl-c1">Object</span>.defineProperty(
    myObject,   <span class="pl-c">// target</span>
    <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,        <span class="pl-c">// property name</span>
    {           <span class="pl-c">// descriptor</span>
        <span class="pl-c">// define a getter for `b`</span>
        <span class="pl-en">get</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){ <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">*</span> <span class="pl-c1">2</span> },

        <span class="pl-c">// make sure `b` shows up as an object property</span>
        enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>
    }
);

myObject.a; <span class="pl-c">// 2</span>

myObject.b; <span class="pl-c">// 4</span></pre></div>

<p>Either through object-literal syntax with <code>get a() { .. }</code> or through explicit definition with <code>defineProperty(..)</code>, in both cases we created a property on the object that actually doesn't hold a value, but whose access automatically results in a hidden function call to the getter function, with whatever value it returns being the result of the property access.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    <span class="pl-c">// define a getter for `a`</span>
    get <span class="pl-en">a</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">2</span>;
    }
};

myObject.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>Since we only defined a getter for <code>a</code>, if we try to set the value of <code>a</code> later, the set operation won't throw an error but will just silently throw the assignment away. Even if there was a valid setter, our custom getter is hard-coded to return only <code>2</code>, so the set operation would be moot.</p>

<p>To make this scenario more sensible, properties should also be defined with setters, which override the default <code>[[Put]]</code> operation (aka, assignment), per-property, just as you'd expect. You will almost certainly want to always declare both getter and setter (having only one or the other often leads to unexpected/surprising behavior):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    <span class="pl-c">// define a getter for `a`</span>
    get <span class="pl-en">a</span>() {
        <span class="pl-k">return</span> <span class="pl-v">this</span>._a_;
    },

    <span class="pl-c">// define a setter for `a`</span>
    set <span class="pl-en">a</span>(<span class="pl-smi">val</span>) {
        <span class="pl-v">this</span>._a_ <span class="pl-k">=</span> val <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    }
};

myObject.a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

myObject.a; <span class="pl-c">// 4</span></pre></div>

<p><strong>Note:</strong> In this example, we actually store the specified value <code>2</code> of the assignment (<code>[[Put]]</code> operation) into another variable <code>_a_</code>. The <code>_a_</code> name is purely by convention for this example and implies nothing special about its behavior -- it's a normal property like any other.</p>

<h3><a id="user-content-existence" class="anchor" href="#existence" aria-hidden="true"><span class="octicon octicon-link"></span></a>Existence</h3>

<p>We showed earlier that a property access like <code>myObject.a</code> may result in an <code>undefined</code> value if either the explicit <code>undefined</code> is stored there or the <code>a</code> property doesn't exist at all. So, if the value is the same in both cases, how else do we distinguish them?</p>

<p>We can ask an object if it has a certain property <em>without</em> asking to get that property's value:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">in</span> myObject);              <span class="pl-c">// true</span>
(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">in</span> myObject);              <span class="pl-c">// false</span>

myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> ); <span class="pl-c">// false</span></pre></div>

<p>The <code>in</code> operator will check to see if the property is <em>in</em> the object, or if it exists at any higher level of the <code>[[Prototype]]</code> chain object traversal (see Chapter 5). By contrast, <code>hasOwnProperty(..)</code> checks to see if <em>only</em> <code>myObject</code> has the property or not, and will <em>not</em> consult the <code>[[Prototype]]</code> chain. We'll come back to the important differences between these two operations in Chapter 5 when we explore <code>[[Prototype]]</code>s in detail.</p>

<p><code>hasOwnProperty(..)</code> is accessible for all normal objects via delegation to <code>Object.prototype</code> (see Chapter 5). But it's possible to create an object that does not link to <code>Object.prototype</code> (via <code>Object.create(null)</code> -- see Chapter 5). In this case, a method call like <code>myObject.hasOwnProperty(..)</code> would fail.</p>

<p>In that scenario, a more robust way of performing such a check is <code>Object.prototype.hasOwnProperty.call(myObject,"a")</code>, which borrows the base <code>hasOwnProperty(..)</code> method and uses <em>explicit <code>this</code> binding</em> (see Chapter 2) to apply it against our <code>myObject</code>.</p>

<p><strong>Note:</strong> The <code>in</code> operator has the appearance that it will check for the existence of a <em>value</em> inside a container, but it actually checks for the existence of a property name. This difference is important to note with respect to arrays, as the temptation to try a check like <code>4 in [2, 4, 6]</code> is strong, but this will not behave as expected.</p>

<h4><a id="user-content-enumeration" class="anchor" href="#enumeration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enumeration</h4>

<p>Previously, we explained briefly the idea of "enumerability" when we looked at the <code>enumerable</code> property descriptor characteristic. Let's revisit that and examine it in more close detail.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> { };

<span class="pl-c1">Object</span>.defineProperty(
    myObject,
    <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,
    <span class="pl-c">// make `a` enumerable, as normal</span>
    { enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>, value<span class="pl-k">:</span> <span class="pl-c1">2</span> }
);

<span class="pl-c1">Object</span>.defineProperty(
    myObject,
    <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,
    <span class="pl-c">// make `b` NON-enumerable</span>
    { enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>, value<span class="pl-k">:</span> <span class="pl-c1">3</span> }
);

myObject.b; <span class="pl-c">// 3</span>
(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">in</span> myObject); <span class="pl-c">// true</span>
myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>

<span class="pl-c">// .......</span>

<span class="pl-k">for</span> (<span class="pl-k">var</span> k <span class="pl-k">in</span> myObject) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( k, myObject[k] );
}
<span class="pl-c">// "a" 2</span></pre></div>

<p>You'll notice that <code>myObject.b</code> in fact <strong>exists</strong> and has an accessible value, but it doesn't show up in a <code>for..in</code> loop (though, surprisingly, it <strong>is</strong> revealed by the <code>in</code> operator existence check). That's because "enumerable" basically means "will be included if the object's properties are iterated through".</p>

<p><strong>Note:</strong> <code>for..in</code> loops applied to arrays can give somewhat unexpected results, in that the enumeration of an array will include not only all the numeric indices, but also any enumerable properties. It's a good idea to use <code>for..in</code> loops <em>only</em> on objects, and traditional <code>for</code> loops with numeric index iteration for the values stored in arrays.</p>

<p>Another way that enumerable and non-enumerable properties can be distinguished:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> { };

<span class="pl-c1">Object</span>.defineProperty(
    myObject,
    <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,
    <span class="pl-c">// make `a` enumerable, as normal</span>
    { enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>, value<span class="pl-k">:</span> <span class="pl-c1">2</span> }
);

<span class="pl-c1">Object</span>.defineProperty(
    myObject,
    <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,
    <span class="pl-c">// make `b` non-enumerable</span>
    { enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>, value<span class="pl-k">:</span> <span class="pl-c1">3</span> }
);

myObject.propertyIsEnumerable( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
myObject.propertyIsEnumerable( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> ); <span class="pl-c">// false</span>

<span class="pl-c1">Object</span>.keys( myObject ); <span class="pl-c">// ["a"]</span>
<span class="pl-c1">Object</span>.getOwnPropertyNames( myObject ); <span class="pl-c">// ["a", "b"]</span></pre></div>

<p><code>propertyIsEnumerable(..)</code> tests whether the given property name exists <em>directly</em> on the object and is also <code>enumerable:true</code>.</p>

<p><code>Object.keys(..)</code> returns an array of all enumerable properties, whereas <code>Object.getOwnPropertyNames(..)</code> returns an array of <em>all</em> properties, enumerable or not.</p>

<p>Whereas <code>in</code> vs. <code>hasOwnProperty(..)</code> differ in whether they consult the <code>[[Prototype]]</code> chain or not, <code>Object.keys(..)</code> and <code>Object.getOwnPropertyNames(..)</code> both inspect <em>only</em> the direct object specified.</p>

<p>There's (currently) no built-in way to get a list of <strong>all properties</strong> which is equivalent to what the <code>in</code> operator test would consult (traversing all properties on the entire <code>[[Prototype]]</code> chain, as explained in Chapter 5). You could approximate such a utility by recursively traversing the <code>[[Prototype]]</code> chain of an object, and for each level, capturing the list from <code>Object.keys(..)</code> -- only enumerable properties.</p>

<h2><a id="user-content-iteration" class="anchor" href="#iteration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iteration</h2>

<p>The <code>for..in</code> loop iterates over the list of enumerable properties on an object (including its <code>[[Prototype]]</code> chain). But what if you instead want to iterate over the values?</p>

<p>With numerically-indexed arrays, iterating over the values is typically done with a standard <code>for</code> loop, like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> myArray.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( myArray[i] );
}
<span class="pl-c">// 1 2 3</span></pre></div>

<p>This isn't iterating over the values, though, but iterating over the indices, where you then use the index to reference the value, as <code>myArray[i]</code>.</p>

<p>ES5 also added several iteration helpers for arrays, including <code>forEach(..)</code>, <code>every(..)</code>, and <code>some(..)</code>. Each of these helpers accepts a function callback to apply to each element in the array, differing only in they respectively respond to a return value from the callback.</p>

<p><code>forEach(..)</code> will iterate over all values in the array, and ignores any callback return values. <code>every(..)</code> keeps going until the end <em>or</em> the callback returns a <code>false</code> (or "falsy") value, whereas <code>some(..)</code> keeps going until the end <em>or</em> the callback returns a <code>true</code> (or "truthy") value.</p>

<p>These special return values inside <code>every(..)</code> and <code>some(..)</code> act somewhat like a <code>break</code> statement inside a normal <code>for</code> loop, in that they stop the iteration early before it reaches the end.</p>

<p>If you iterate on an object with a <code>for..in</code> loop, you're also only getting at the values indirectly, because it's actually iterating only over the enumerable properties of the object, leaving you to access the properties manually to get the values.</p>

<p><strong>Note:</strong> As contrasted with iterating over an array's indices in a numerically ordered way (<code>for</code> loop or other iterators), the order of iteration over an object's properties is <strong>not guaranteed</strong> and may vary between different JS engines. <strong>Do not rely</strong> on any observed ordering for anything that requires consistency among environments, as any observed agreement is unreliable.</p>

<p>But what if you want to iterate over the values directly instead of the array indices (or object properties)? Helpfully, ES6 adds a <code>for..of</code> loop syntax for iterating over arrays (and objects, if the object defines its own custom iterator):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ];

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> myArray) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1</span>
<span class="pl-c">// 2</span>
<span class="pl-c">// 3</span></pre></div>

<p>The <code>for..of</code> loop asks for an iterator object (from a default internal function known as <code>@@iterator</code> in spec-speak) of the <em>thing</em> to be iterated, and the loop then iterates over the successive return values from calling that iterator object's <code>next()</code> method, once for each loop iteration.</p>

<p>Arrays have a built-in <code>@@iterator</code>, so <code>for..of</code> works easily on them, as shown. But let's manually iterate the array, using the built-in <code>@@iterator</code>, to see how it works:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myArray <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ];
<span class="pl-k">var</span> it <span class="pl-k">=</span> myArray[Symbol.iterator]();

it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:1, done:false }</span>
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:2, done:false }</span>
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:3, done:false }</span>
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { done:true }</span></pre></div>

<p><strong>Note:</strong> We get at the <code>@@iterator</code> <em>internal property</em> of an object using an ES6 <code>Symbol</code>: <code>Symbol.iterator</code>. We briefly mentioned <code>Symbol</code> semantics earlier in the chapter (see "Computed Property Names"), so the same reasoning applies here. You'll always want to reference such special properties by <code>Symbol</code> name reference instead of by the special value it may hold. Also, despite the name's implications, <code>@@iterator</code> is <strong>not the iterator object</strong> itself, but a <strong>function that returns</strong> the iterator object -- a subtle but important detail!</p>

<p>As the above snippet reveals, the return value from an iterator's <code>next()</code> call is an object of the form <code>{ value: .. , done: .. }</code>, where <code>value</code> is the current iteration value, and <code>done</code> is a <code>boolean</code> that indicates if there's more to iterate.</p>

<p>Notice the value <code>3</code> was returned with a <code>done:false</code>, which seems strange at first glance. You have to call the <code>next()</code> a fourth time (which the <code>for..of</code> loop in the previous snippet automatically does) to get <code>done:true</code> and know you're truly done iterating. The reason for this quirk is beyond the scope of what we'll discuss here, but it comes from the semantics of ES6 generator functions.</p>

<p>While arrays do automatically iterate in <code>for..of</code> loops, regular objects <strong>do not have a built-in <code>@@iterator</code></strong>. The reasons for this intentional omission are more complex than we will examine here, but in general it was better to not include some implementation that could prove troublesome for future types of objects.</p>

<p>It <em>is</em> possible to define your own default <code>@@iterator</code> for any object that you care to iterate over. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>,
    b<span class="pl-k">:</span> <span class="pl-c1">3</span>
};

<span class="pl-c1">Object</span>.defineProperty( myObject, Symbol.iterator, {
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">var</span> o <span class="pl-k">=</span> <span class="pl-v">this</span>;
        <span class="pl-k">var</span> idx <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">var</span> ks <span class="pl-k">=</span> <span class="pl-c1">Object</span>.keys( o );
        <span class="pl-k">return</span> {
            <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
                <span class="pl-k">return</span> {
                    value<span class="pl-k">:</span> o[ks[idx<span class="pl-k">++</span>]],
                    done<span class="pl-k">:</span> (idx <span class="pl-k">&gt;</span> ks.<span class="pl-c1">length</span>)
                };
            }
        };
    }
} );

<span class="pl-c">// iterate `myObject` manually</span>
<span class="pl-k">var</span> it <span class="pl-k">=</span> myObject[Symbol.iterator]();
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:2, done:false }</span>
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:3, done:false }</span>
it.<span class="pl-c1">next</span>(); <span class="pl-c">// { value:undefined, done:true }</span>

<span class="pl-c">// iterate `myObject` with `for..of`</span>
<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> myObject) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 2</span>
<span class="pl-c">// 3</span></pre></div>

<p><strong>Note:</strong> We used <code>Object.defineProperty(..)</code> to define our custom <code>@@iterator</code> (mostly so we could make it non-enumerable), but using the <code>Symbol</code> as a <em>computed property name</em> (covered earlier in this chapter), we could have declared it directly, like <code>var myObject = { a:2, b:3, [Symbol.iterator]: function(){ /* .. */ } }</code>.</p>

<p>Each time the <code>for..of</code> loop calls <code>next()</code> on <code>myObject</code>'s iterator object, the internal pointer will advance and return back the next value from the object's properties list (see a previous note about iteration ordering on object properties/values).</p>

<p>The iteration we just demonstrated is a simple value-by-value iteration, but you can of course define arbitrarily complex iterations for your custom data structures, as you see fit. Custom iterators combined with ES6's <code>for..of</code> loop are a powerful new syntactic tool for manipulating user-defined objects.</p>

<p>For example, a list of <code>Pixel</code> objects (with <code>x</code> and <code>y</code> coordinate values) could decide to order its iteration based on the linear distance from the <code>(0,0)</code> origin, or filter out points that are "too far away", etc. As long as your iterator returns the expected <code>{ value: .. }</code> return values from <code>next()</code> calls, and a <code>{ done: true }</code> after the iteration is complete, ES6's <code>for..of</code> can iterate over it.</p>

<p>In fact, you can even generate "infinite" iterators which never "finish" and always return a new value (such as a random number, an incremented value, a unique identifier, etc), though you probably will not use such iterators with an unbounded <code>for..of</code> loop, as it would never end and would hang your program.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> randoms <span class="pl-k">=</span> {
    [Symbol.iterator]<span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> {
            <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() };
            }
        };
    }
};

<span class="pl-k">var</span> randoms_pool <span class="pl-k">=</span> [];
<span class="pl-k">for</span> (<span class="pl-k">var</span> n <span class="pl-k">of</span> randoms) {
    randoms_pool.<span class="pl-c1">push</span>( n );

    <span class="pl-c">// don't proceed unbounded!</span>
    <span class="pl-k">if</span> (randoms_pool.<span class="pl-c1">length</span> <span class="pl-k">===</span> <span class="pl-c1">100</span>) <span class="pl-k">break</span>;
}</pre></div>

<p>This iterator will generate random numbers "forever", so we're careful to only pull out 100 values so our program doesn't hang.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Objects in JS have both a literal form (such as <code>var a = { .. }</code>) and a constructed form (such as <code>var a = new Array(..)</code>). The literal form is almost always preferred, but the constructed form offers, in some cases, more creation options.</p>

<p>Many people mistakingly claim "everything in JavaScript is an object", but this is incorrect. Objects are one of the 6 (or 7, depending on your perspective) primitive types. Objects have sub-types, including <code>function</code>, and also can be behavior-specialized, like <code>[object Array]</code> as the internal label representing the array object sub-type.</p>

<p>Objects are collections of key/value pairs. The values can be accessed as properties, via <code>.propName</code> or <code>["propName"]</code> syntax. Whenever a property is accessed, the engine actually invokes the internal default <code>[[Get]]</code> operation (and <code>[[Put]]</code> for setting values), which not only looks for the property directly on the object, but which will traverse the <code>[[Prototype]]</code> chain (see Chapter 5) if not found.</p>

<p>Properties have certain characteristics that can be controlled through property descriptors, such as <code>writable</code> and <code>configurable</code>. In addition, objects can have their mutability (and that of their properties) controlled to various levels of immutability using <code>Object.preventExtensions(..)</code>, <code>Object.seal(..)</code>, and <code>Object.freeze(..)</code>.</p>

<p>Properties don't have to contain values -- they can be "accessor properties" as well, with getters/setters. They can also be either <em>enumerable</em> or not, which controls if they show up in <code>for..in</code> loop iterations, for instance.</p>

<p>You can also iterate over <strong>the values</strong> in data structures (arrays, objects, etc) using the ES6 <code>for..of</code> syntax, which looks for either a built-in or custom <code>@@iterator</code> object consisting of a <code>next()</code> method to advance through the data values one at a time.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-4-mixing-up-class-objects" class="anchor" href="#chapter-4-mixing-up-class-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4: Mixing (Up) "Class" Objects</h1>

<p>Following our exploration of objects from the previous chapter, it's natural that we now turn our attention to "object oriented (OO) programming", with "classes". We'll first look at "class orientation" as a design pattern, before examining the mechanics of "classes": "instantiation", "inheritance" and "(relative) polymorphism".</p>

<p>We'll see that these concepts don't really map very naturally to the object mechanism in JS, and the lengths (mixins, etc.) many JavaScript developers go to overcome such challenges.</p>

<p><strong>Note:</strong> This chapter spends quite a bit of time (the first half!) on heavy "objected oriented programming" theory. We eventually relate these ideas to real concrete JavaScript code in the second half, when we talk about "Mixins". But there's a lot of concept and pseudo-code to wade through first, so don't get lost -- just stick with it!</p>

<h2><a id="user-content-class-theory" class="anchor" href="#class-theory" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class Theory</h2>

<p>"Class/Inheritance" describes a certain form of code organization and architecture -- a way of modeling real world problem domains in our software.</p>

<p>OO or class oriented programming stresses that data intrinsically has associated behavior (of course, different depending on the type and nature of the data!) that operates on it, so proper design is to package up (aka, encapsulate) the data and the behavior together. This is sometimes called "data structures" in formal computer science.</p>

<p>For example, a series of characters that represents a word or phrase is usually called a "string". The characters are the data. But you almost never just care about the data, you usually want to <em>do things</em> with the data, so the behaviors that can apply <em>to</em> that data (calculating its length, appending data, searching, etc.) are all designed as methods of a <code>String</code> class.</p>

<p>Any given string is just an instance of this class, which means that it's a neatly collected packaging of both the character data and the functionality we can perform on it.</p>

<p>Classes also imply a way of <em>classifying</em> a certain data structure. The way we do this is to think about any given structure as a specific variation of a more general base definition.</p>

<p>Let's explore this classification process by looking at a commonly cited example. A <em>car</em> can be described as a specific implementation of a more general "class" of thing, called a <em>vehicle</em>.</p>

<p>We model this relationship in software with classes by defining a <code>Vehicle</code> class and a <code>Car</code> class.</p>

<p>The definition of <code>Vehicle</code> might include things like propulsion (engines, etc.), the ability to carry people, etc., which would all be the behaviors. What we define in <code>Vehicle</code> is all the stuff that is common to all (or most of) the different types of vehicles (the "planes, trains, and automobiles").</p>

<p>It might not make sense in our software to re-define the basic essence of "ability to carry people" over and over again for each different type of vehicle. Instead, we define that capability once in <code>Vehicle</code>, and then when we define <code>Car</code>, we simply indicate that it "inherits" (or "extends") the base definition from <code>Vehicle</code>. The definition of <code>Car</code> is said to specialize the general <code>Vehicle</code> definition.</p>

<p>While <code>Vehicle</code> and <code>Car</code> collectively define the behavior by way of methods, the data in an instance would be things like the unique VIN of a specific car, etc.</p>

<p><strong>And thus, classes, inheritance, and instantiation emerge.</strong></p>

<p>Another key concept with classes is "polymorphism", which describes the idea that a general behavior from a parent class can be overridden in a child class to give it more specifics. In fact, relative polymorphism lets us reference the base behavior from the overridden behavior.</p>

<p>Class theory strongly suggests that a parent class and a child class share the same method name for a certain behavior, so that the child overrides the parent (differentially). As we'll see later, doing so in your JavaScript code is opting into frustration and code brittleness.</p>

<h3><a id="user-content-class-design-pattern" class="anchor" href="#class-design-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Class" Design Pattern</h3>

<p>You may never have thought about classes as a "design pattern", since it's most common to see discussion of popular "OO Design Patterns", like "Iterator", "Observer", "Factory", "Singleton", etc. As presented this way, it's almost an assumption that OO classes are the lower-level mechanics by which we implement all (higher level) design patterns, as if OO is a given foundation for <em>all</em> (proper) code.</p>

<p>Depending on your level of formal education in programming, you may have heard of "procedural programming" as a way of describing code which only consists of procedures (aka, functions) calling other functions, without any higher abstractions. You may have been taught that classes were the <em>proper</em> way to transform procedural-style "spaghetti code" into well-formed, well-organized code.</p>

<p>Of course, if you have experience with "functional programming" (Monads, etc.), you know very well that classes are just one of several common design patterns. But for others, this may be the first time you've asked yourself if classes really are a fundamental foundation for code, or if they are an optional abstraction on top of code.</p>

<p>Some languages (like Java) don't give you the choice, so it's not very <em>optional</em> at all -- everything's a class. Other languages like C/C++ or PHP give you both procedural and class-oriented syntaxes, and it's left more to the developer's choice which style or mixture of styles is appropriate.</p>

<h3><a id="user-content-javascript-classes" class="anchor" href="#javascript-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>JavaScript "Classes"</h3>

<p>Where does JavaScript fall in this regard? JS has had <em>some</em> class-like syntactic elements (like <code>new</code> and <code>instanceof</code>) for quite awhile, and more recently in ES6, some additions, like the <code>class</code> keyword (see Appendix A).</p>

<p>But does that mean JavaScript actually <em>has</em> classes? Plain and simple: <strong>No.</strong></p>

<p>Since classes are a design pattern, you <em>can</em>, with quite a bit of effort (as we'll see throughout the rest of this chapter), implement approximations for much of classical class functionality. JS tries to satisfy the extremely pervasive <em>desire</em> to design with classes by providing seemingly class-like syntax.</p>

<p>While we may have a syntax that looks like classes, it's as if JavaScript mechanics are fighting against you using the <em>class design pattern</em>, because behind the curtain, the mechanisms that you build on are operating quite differently. Syntactic sugar and (extremely widely used) JS "Class" libraries go a long way toward hiding this reality from you, but sooner or later you will face the fact that the <em>classes</em> you have in other languages are not like the "classes" you're faking in JS.</p>

<p>What this boils down to is that classes are an optional pattern in software design, and you have the choice to use them in JavaScript or not. Since many developers have a strong affinity to class oriented software design, we'll spend the rest of this chapter exploring what it takes to maintain the illusion of classes with what JS provides, and the pain points we experience.</p>

<h2><a id="user-content-class-mechanics" class="anchor" href="#class-mechanics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class Mechanics</h2>

<p>In many class-oriented languages, the "standard library" provides a "stack" data structure (push, pop, etc.) as a <code>Stack</code> class. This class would have an internal set of variables that stores the data, and it would have a set of publicly accessible behaviors ("methods") provided by the class, which gives your code the ability to interact with the (hidden) data (adding &amp; removing data, etc.).</p>

<p>But in such languages, you don't really operate directly on <code>Stack</code> (unless making a <strong>Static</strong> class member reference, which is outside the scope of our discussion). The <code>Stack</code> class is merely an abstract explanation of what <em>any</em> "stack" should do, but it's not itself <em>a</em> "stack". You must <strong>instantiate</strong> the <code>Stack</code> class before you have a concrete data structure <em>thing</em> to operate against.</p>

<h3><a id="user-content-building" class="anchor" href="#building" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building</h3>

<p>The traditional metaphor for "class" and "instance" based thinking comes from a building construction.</p>

<p>An architect plans out all the characteristics of a building: how wide, how tall, how many windows and in what locations, even what type of material to use for the walls and roof. She doesn't necessarily care, at this point, <em>where</em> the building will be built, nor does she care <em>how many</em> copies of that building will be built.</p>

<p>She also doesn't care very much about the contents of the building -- the furniture, wall paper, ceiling fans, etc. -- only what type of structure they will be contained by.</p>

<p>The architectural blue-prints she produces are only <em>plans</em> for a building. They don't actually constitute a building we can walk into and sit down. We need a builder for that task. A builder will take those plans and follow them, exactly, as he <em>builds</em> the building. In a very real sense, he is <em>copying</em> the intended characteristics from the plans to the physical building.</p>

<p>Once complete, the building is a physical instantiation of the blue-print plans, hopefully an essentially perfect <em>copy</em>. And then the builder can move to the open lot next door and do it all over again, creating yet another <em>copy</em>.</p>

<p>The relationship between building and blue-print is indirect. You can examine a blue-print to understand how the building was structured, for any parts where direct inspection of the building itself was insufficient. But if you want to open a door, you have to go to the building itself -- the blue-print merely has lines drawn on a page that <em>represent</em> where the door should be.</p>

<p>A class is a blue-print. To actually <em>get</em> an object we can interact with, we must build (aka, "instantiate") something from the class. The end result of such "construction" is an object, typically called an "instance", which we can directly call methods on and access any public data properties from, as necessary.</p>

<p><strong>This object is a *copy</strong>* of all the characteristics described by the class.</p>

<p>You likely wouldn't expect to walk into a building and find, framed and hanging on the wall, a copy of the blue-prints used to plan the building, though the blue-prints are probably on file with a public records office. Similarly, you don't generally use an object instance to directly access and manipulate its class, but it is usually possible to at least determine <em>which class</em> an object instance comes from.</p>

<p>It's more useful to consider the direct relationship of a class to an object instance, rather than any indirect relationship between an object instance and the class it came from. <strong>A class is instantiated into object form by a copy operation.</strong></p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig1.png" style="max-width:100%;"></a></p>

<p>As you can see, the arrows move from left to right, and from top to bottom, which indicates the copy operations that occur, both conceptually and physically.</p>

<h3><a id="user-content-constructor" class="anchor" href="#constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructor</h3>

<p>Instances of classes are constructed by a special method of the class, usually of the same name as the class, called a <em>constructor</em>. This method's explicit job is to initialize any information (state) the instance will need.</p>

<p>For example, consider this loose pseudo-code (invented syntax) for classes:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">CoolGuy</span> {
    specialTrick <span class="pl-k">=</span> nothing

    <span class="pl-en">CoolGuy</span>( <span class="pl-smi">trick</span> ) {
        specialTrick <span class="pl-k">=</span> trick
    }

    <span class="pl-en">showOff</span>() {
        output( <span class="pl-s"><span class="pl-pds">"</span>Here's my trick: <span class="pl-pds">"</span></span>, specialTrick )
    }
}</pre></div>

<p>To <em>make</em> a <code>CoolGuy</code> instance, we would call the class constructor:</p>

<div class="highlight highlight-js"><pre>Joe <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CoolGuy</span>( <span class="pl-s"><span class="pl-pds">"</span>jumping rope<span class="pl-pds">"</span></span> )

Joe.showOff() <span class="pl-c">// Here's my trick: jumping rope</span></pre></div>

<p>Notice that the <code>CoolGuy</code> class has a constructor <code>CoolGuy()</code>, which is actually what we call when we say <code>new CoolGuy(..)</code>. We get an object back (an instance of our class) from the constructor, and we can call the method <code>showOff()</code>, which prints out that particular <code>CoolGuy</code>s special trick.</p>

<p><em>Obviously, jumping rope makes Joe a pretty cool guy.</em></p>

<p>The constructor of a class <em>belongs</em> to the class, almost universally with the same name as the class. Also, constructors pretty much always need to be called with <code>new</code> to let the language engine know you want to construct a <em>new</em> class instance.</p>

<h2><a id="user-content-class-inheritance" class="anchor" href="#class-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class Inheritance</h2>

<p>In class-oriented languages, not only can you define a class which can be instantiated itself, but you can define another class that <strong>inherits</strong> from the first class.</p>

<p>The second class is often said to be a "child class" whereas the first is the "parent class". These terms obviously come from the metaphor of parents and children, though the metaphors here are a bit stretched, as you'll see shortly.</p>

<p>When a parent has a biological child, the genetic characteristics of the parent are copied into the child. Obviously, in most biological reproduction systems, there are two parents who co-equally contribute genes to the mix. But for the purposes of the metaphor, we'll assume just one parent.</p>

<p>Once the child exists, he or she is separate from the parent. The child was heavily influenced by the inheritance from his or her parent, but is unique and distinct. If a child ends up with red hair, that doesn't mean the parent's hair <em>was</em> or automatically <em>becomes</em> red.</p>

<p>In a similar way, once a child class is defined, it's separate and distinct from the parent class. The child class contains an initial copy of the behavior from the parent, but can then override any inherited behavior and even define new behavior.</p>

<p>It's important to remember that we're talking about parent and child <strong>classes</strong>, which aren't physical things. This is where the metaphor of parent and child gets a little confusing, because we actually should say that a parent class is like a parent's DNA and a child class is like a child's DNA. We have to make (aka "instantiate") a person out of each set of DNA to actually have a physical person to have a conversation with.</p>

<p>Let's set aside biological parents and children, and look at inheritance through a slightly different lens: different types of vehicles. That's one of the most canonical (and often groan-worthy) metaphors to understand inheritance.</p>

<p>Let's revisit the <code>Vehicle</code> and <code>Car</code> discussion from earlier in this chapter. Consider this loose pseudo-code (invented syntax) for inherited classes:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">Vehicle</span> {
    engines <span class="pl-k">=</span> <span class="pl-c1">1</span>

    <span class="pl-en">ignition</span>() {
        output( <span class="pl-s"><span class="pl-pds">"</span>Turning on my engine.<span class="pl-pds">"</span></span> );
    }

    <span class="pl-en">drive</span>() {
        ignition();
        output( <span class="pl-s"><span class="pl-pds">"</span>Steering and moving forward!<span class="pl-pds">"</span></span> )
    }
}

<span class="pl-k">class</span> <span class="pl-en">Car</span> inherits Vehicle {
    wheels <span class="pl-k">=</span> <span class="pl-c1">4</span>

    <span class="pl-en">drive</span>() {
        inherited<span class="pl-k">:</span>drive()
        output( <span class="pl-s"><span class="pl-pds">"</span>Rolling on all <span class="pl-pds">"</span></span>, wheels, <span class="pl-s"><span class="pl-pds">"</span> wheels!<span class="pl-pds">"</span></span> )
    }
}

<span class="pl-k">class</span> <span class="pl-en">SpeedBoat</span> inherits Vehicle {
    engines <span class="pl-k">=</span> <span class="pl-c1">2</span>

    <span class="pl-en">ignition</span>() {
        output( <span class="pl-s"><span class="pl-pds">"</span>Turning on my <span class="pl-pds">"</span></span>, engines, <span class="pl-s"><span class="pl-pds">"</span> engines.<span class="pl-pds">"</span></span> )
    }

    <span class="pl-en">pilot</span>() {
        inherited<span class="pl-k">:</span>drive()
        output( <span class="pl-s"><span class="pl-pds">"</span>Speeding through the water with ease!<span class="pl-pds">"</span></span> )
    }
}</pre></div>

<p><strong>Note:</strong> For clarity and brevity, constructors for these classes have been omitted.</p>

<p>We define the <code>Vehicle</code> class to assume an engine, a way to turn on the ignition, and a way to drive around. But you wouldn't ever manufacture just a generic "vehicle", so it's really just an abstract concept at this point.</p>

<p>So then we define two specific kinds of vehicle: <code>Car</code> and <code>SpeedBoat</code>. They each inherit the general characteristics of <code>Vehicle</code>, but then they specialize the characteristics appropriately for each kind. A car needs 4 wheels, and a speed boat needs 2 engines, which means it needs extra attention to turn on the ignition of both engines.</p>

<h3><a id="user-content-polymorphism" class="anchor" href="#polymorphism" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polymorphism</h3>

<p><code>Car</code> defines its own <code>drive()</code> method, which overrides the method of the same name it inherited from <code>Vehicle</code>. But then, <code>Car</code>s <code>drive()</code> method calls <code>inherited:drive()</code>, which indicates that <code>Car</code> can reference the original pre-overridden <code>drive()</code> it inherited. <code>SpeedBoat</code>s <code>pilot()</code> method also makes a reference to its inherited copy of <code>drive()</code>.</p>

<p>This technique is called "polymorphism", or "virtual polymorphism". More specifically to our current point, we'll call it "relative polymorphism".</p>

<p>Polymorphism is a much broader topic than we will exhaust here, but our current "relative" semantics refers to one particular aspect: the idea that any method can reference another method (of the same or different name) at a higher level of the inheritance hierarchy. We say "relative" because we don't absolutely define which inheritance level (aka, class) we want to access, but rather relatively reference it by essentially saying "look one level up".</p>

<p>In many languages, the keyword <code>super</code> is used, in place of this example's <code>inherited:</code>, which leans on the idea that a "super class" is the parent/ancestor of the current class.</p>

<p>Another aspect of polymorphism is that a method name can have multiple definitions at different levels of the inheritance chain, and these definitions are automatically selected as appropriate when resolving which methods are being called.</p>

<p>We see two occurrences of that behavior in our example above: <code>drive()</code> is defined in both <code>Vehicle</code> and <code>Car</code>, and <code>ignition()</code> is defined in both <code>Vehicle</code> and <code>SpeedBoat</code>.</p>

<p><strong>Note:</strong> Another thing that traditional class-oriented languages give you via <code>super</code> is a direct way for the constructor of a child class to reference the constructor of its parent class. This is largely true because with real classes, the constructor belongs to the class. However, in JS, it's the reverse -- it's actually more appropriate to think of the "class" belonging to the constructor (the <code>Foo.prototype...</code> type references). Since in JS the relationship between child and parent exists only between the two <code>.prototype</code> objects of the respective constructors, the constructors themselves are not directly related, and thus there's no simple way to relatively reference one from the other (see Appendix A for ES6 <code>class</code> which "solves" this with <code>super</code>).</p>

<p>An interesting implication of polymorphism can be seen specifically with <code>ignition()</code>. Inside <code>pilot()</code>, a relative-polymorphic reference is made to (the inherited) <code>Vehicle</code>s version of <code>drive()</code>. But that <code>drive()</code> references an <code>ignition()</code> method just by name (no relative reference).</p>

<p>Which version of <code>ignition()</code> will the language engine use, the one from <code>Vehicle</code> or the one from <code>SpeedBoat</code>? <strong>It uses the <code>SpeedBoat</code> version of <code>ignition()</code>.</strong> If you <em>were</em> to instantiate <code>Vehicle</code> class itself, and then call its <code>drive()</code>, the language engine would instead just use <code>Vehicle</code>s <code>ignition()</code> method definition.</p>

<p>Put another way, the definition for the method <code>ignition()</code> <em>polymorphs</em> (changes) depending on which class (level of inheritance) you are referencing an instance of.</p>

<p>This may seem like overly deep academic detail. But understanding these details is necessary to properly contrast similar (but distinct) behaviors in JavaScript's <code>[[Prototype]]</code> mechanism.</p>

<p>When classes are inherited, there is a way <strong>for the classes themselves</strong> (not the object instances created from them!) to <em>relatively</em> reference the class inherited from, and this relative reference is usually called <code>super</code>.</p>

<p>Remember this figure from earlier:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig1.png" style="max-width:100%;"></a></p>

<p>Notice how for both instantiation (<code>a1</code>, <code>a2</code>, <code>b1</code>, and <code>b2</code>) <em>and</em> inheritance (<code>Bar</code>), the arrows indicate a copy operation.</p>

<p>Conceptually, it would seem a child class <code>Bar</code> can access  behavior in its parent class <code>Foo</code> using a relative polymorphic reference (aka, <code>super</code>). However, in reality, the child class is merely given a copy of the inherited behavior from its parent class. If the child "overrides" a method it inherits, both the original and overridden versions of the method are actually maintained, so that they are both accessible.</p>

<p>Don't let polymorphism confuse you into thinking a child class is linked to its parent class. A child class instead gets a copy of what it needs from the parent class. <strong>Class inheritance implies copies.</strong></p>

<h3><a id="user-content-multiple-inheritance" class="anchor" href="#multiple-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Inheritance</h3>

<p>Recall our earlier discussion of parent(s) and children and DNA? We said that the metaphor was a bit weird because biologically most offspring come from two parents. If a class could inherit from two other classes, it would more closely fit the parent/child metaphor.</p>

<p>Some class-oriented languages allow you to specify more than one "parent" class to "inherit" from. Multiple-inheritance means that each parent class definition is copied into the child class.</p>

<p>On the surface, this seems like a powerful addition to class-orientation, giving us the ability to compose more functionality together. However, there are certainly some complicating questions that arise. If both parent classes provide a method called <code>drive()</code>, which version would a <code>drive()</code> reference in the child resolve to? Would you always have to manually specify which parent's <code>drive()</code> you meant, thus losing some of the gracefulness of polymorphic inheritance?</p>

<p>There's another variation, the so called "Diamond Problem", which refers to the scenario where a child class "D" inherits from two parent classes ("B" and "C"), and each of those in turn inherits from a common "A" parent. If "A" provides a method <code>drive()</code>, and both "B" and "C" override (polymorph) that method, when <code>D</code> references <code>drive()</code>, which version should it use (<code>B:drive()</code> or <code>C:drive()</code>)?</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig2.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig2.png" style="max-width:100%;"></a></p>

<p>These complications go even much deeper than this quick glance. We address them here only so we can contrast to how JavaScript's mechanisms work.</p>

<p>JavaScript is simpler: it does not provide a native mechanism for "multiple inheritance". Many see this is a good thing, because the complexity savings more than make up for the "reduced" functionality. But this doesn't stop developers from trying to fake it in various ways, as we'll see next.</p>

<h2><a id="user-content-mixins" class="anchor" href="#mixins" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixins</h2>

<p>JavaScript's object mechanism does not <em>automatically</em> perform copy behavior when you "inherit" or "instantiate". Plainly, there's no "classes" in JavaScript to instantiate, only objects. And objects don't get copied to other objects, they get <em>linked together</em> (more on that in Chapter 5).</p>

<p>Since observed class behaviors in other languages imply copies, let's examine how JS developers <strong>fake</strong> the <em>missing</em> copy behavior of classes in JavaScript: mixins. We'll look at two types of "mixin": <strong>explicit</strong> and <strong>implicit</strong>.</p>

<h3><a id="user-content-explicit-mixins" class="anchor" href="#explicit-mixins" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explicit Mixins</h3>

<p>Let's again revisit our <code>Vehicle</code> and <code>Car</code> example from before. Since JavaScript will not automatically copy behavior from <code>Vehicle</code> to <code>Car</code>, we can instead create a utility that manually copies. Such a utility is often called <code>extend(..)</code> by many libraries/frameworks, but we will call it <code>mixin(..)</code> here for illustrative purposes.</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// vastly simplified `mixin(..)` example:</span>
<span class="pl-k">function</span> <span class="pl-en">mixin</span>( <span class="pl-smi">sourceObj</span>, <span class="pl-smi">targetObj</span> ) {
    <span class="pl-k">for</span> (<span class="pl-k">var</span> key <span class="pl-k">in</span> sourceObj) {
        <span class="pl-c">// only copy if not already present</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>(key <span class="pl-k">in</span> targetObj)) {
            targetObj[key] <span class="pl-k">=</span> sourceObj[key];
        }
    }

    <span class="pl-k">return</span> targetObj;
}

<span class="pl-k">var</span> Vehicle <span class="pl-k">=</span> {
    engines<span class="pl-k">:</span> <span class="pl-c1">1</span>,

    <span class="pl-en">ignition</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Turning on my engine.<span class="pl-pds">"</span></span> );
    },

    <span class="pl-en">drive</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-v">this</span>.ignition();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Steering and moving forward!<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> Car <span class="pl-k">=</span> mixin( Vehicle, {
    wheels<span class="pl-k">:</span> <span class="pl-c1">4</span>,

    <span class="pl-en">drive</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        Vehicle.drive.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Rolling on all <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.wheels <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> wheels!<span class="pl-pds">"</span></span> );
    }
} );</pre></div>

<p><strong>Note:</strong> Subtly but importantly, we're not dealing with classes anymore, because there are no classes in JavaScript. <code>Vehicle</code> and <code>Car</code> are just objects that we make copies from and to, respectively.</p>

<p><code>Car</code> now has a copy of the properties and functions from <code>Vehicle</code>. Technically, functions are not actually duplicated, but rather <em>references</em> to the functions are copied. So, <code>Car</code> now has a property called <code>ignition</code>, which is a copied reference to the <code>ignition()</code> function, as well as a property called <code>engines</code> with the copied value of <code>1</code> from <code>Vehicle</code>.</p>

<p><code>Car</code> <em>already</em> had a <code>drive</code> property (function), so that property reference was not overridden (see the <code>if</code> statement in <code>mixin(..)</code> above).</p>

<h4><a id="user-content-polymorphism-revisited" class="anchor" href="#polymorphism-revisited" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Polymorphism" Revisited</h4>

<p>Let's examine this statement: <code>Vehicle.drive.call( this )</code>. This is what I call "explicit pseudo-polymorphism". Recall in our previous pseudo-code this line was <code>inherited:drive()</code>, which we called "relative polymorphism".</p>

<p>JavaScript does not have (prior to ES6; see Appendix A) a facility for relative polymorphism. So, <strong>because both <code>Car</code> and <code>Vehicle</code> had a function of the same name: <code>drive()</code></strong>, to distinguish a call to one or the other, we must make an absolute (not relative) reference. We explicitly specify the <code>Vehicle</code> object by name, and call the <code>drive()</code> function on it.</p>

<p>But if we said <code>Vehicle.drive()</code>, the <code>this</code> binding for that function call would be the <code>Vehicle</code> object instead of the <code>Car</code> object (see Chapter 2), which is not what we want. So, instead we use <code>.call( this )</code> (Chapter 2) to ensure that <code>drive()</code> is executed in the context of the <code>Car</code> object.</p>

<p><strong>Note:</strong> If the function name identifier for <code>Car.drive()</code> hadn't overlapped with (aka, "shadowed"; see Chapter 5) <code>Vehicle.drive()</code>, we wouldn't have been exercising "method polymorphism". So, a reference to <code>Vehicle.drive()</code> would have been copied over by the <code>mixin(..)</code> call, and we could have accessed directly with <code>this.drive()</code>. The chosen identifier overlap <strong>shadowing</strong> is <em>why</em> we have to use the more complex <em>explicit pseudo-polymorphism</em> approach.</p>

<p>In class-oriented languages, which have relative polymorphism, the linkage between <code>Car</code> and <code>Vehicle</code> is established once, at the top of the class definition, which makes for only one place to maintain such relationships.</p>

<p>But because of JavaScript's peculiarities, explicit pseudo-polymorphism (because of shadowing!) creates brittle manual/explicit linkage <strong>in every single function where you need such a (pseudo-)polymorphic reference</strong>. This can significantly increase the maintenance cost. Moreover, while explicit pseudo-polymorphism can emulate the behavior of "multiple inheritance", it only increases the complexity and brittleness.</p>

<p>The result of such approaches is usually more complex, harder-to-read, <em>and</em> harder-to-maintain code. <strong>Explicit pseudo-polymorphism should be avoided wherever possible</strong>, because the cost outweighs the benefit in most respects.</p>

<h4><a id="user-content-mixing-copies" class="anchor" href="#mixing-copies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mixing Copies</h4>

<p>Recall the <code>mixin(..)</code> utility from above:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// vastly simplified `mixin()` example:</span>
<span class="pl-k">function</span> <span class="pl-en">mixin</span>( <span class="pl-smi">sourceObj</span>, <span class="pl-smi">targetObj</span> ) {
    <span class="pl-k">for</span> (<span class="pl-k">var</span> key <span class="pl-k">in</span> sourceObj) {
        <span class="pl-c">// only copy if not already present</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>(key <span class="pl-k">in</span> targetObj)) {
            targetObj[key] <span class="pl-k">=</span> sourceObj[key];
        }
    }

    <span class="pl-k">return</span> targetObj;
}</pre></div>

<p>Now, let's examine how <code>mixin(..)</code> works. It iterates over the properties of <code>sourceObj</code> (<code>Vehicle</code> in our example) and if there's no matching property of that name in <code>targetObj</code> (<code>Car</code> in our example), it makes a copy. Since we're making the copy after the initial object exists, we are careful to not copy over a target property.</p>

<p>If we made the copies first, before specifying the <code>Car</code> specific contents, we could omit this check against <code>targetObj</code>, but that's a little more clunky and less efficient, so it's generally less preferred:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// alternate mixin, less "safe" to overwrites</span>
<span class="pl-k">function</span> <span class="pl-en">mixin</span>( <span class="pl-smi">sourceObj</span>, <span class="pl-smi">targetObj</span> ) {
    <span class="pl-k">for</span> (<span class="pl-k">var</span> key <span class="pl-k">in</span> sourceObj) {
        targetObj[key] <span class="pl-k">=</span> sourceObj[key];
    }

    <span class="pl-k">return</span> targetObj;
}

<span class="pl-k">var</span> Vehicle <span class="pl-k">=</span> {
    <span class="pl-c">// ...</span>
};

<span class="pl-c">// first, create an empty object with</span>
<span class="pl-c">// Vehicle's stuff copied in</span>
<span class="pl-k">var</span> Car <span class="pl-k">=</span> mixin( Vehicle, { } );

<span class="pl-c">// now copy the intended contents into Car</span>
mixin( {
    wheels<span class="pl-k">:</span> <span class="pl-c1">4</span>,

    <span class="pl-en">drive</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// ...</span>
    }
}, Car );</pre></div>

<p>Either approach, we have explicitly copied the non-overlapping contents of <code>Vehicle</code> into <code>Car</code>. The name "mixin" comes from an alternate way of explaining the task: <code>Car</code> has <code>Vehicle</code>s contents <strong>mixed-in</strong>, just like you mix in chocolate chips into your favorite cookie dough.</p>

<p>As a result of the copy operation, <code>Car</code> will operate somewhat separately from <code>Vehicle</code>. If you add a property onto <code>Car</code>, it will not affect <code>Vehicle</code>, and vice versa.</p>

<p><strong>Note:</strong> A few minor details have been skimmed over here. There are still some subtle ways the two objects can "affect" each other even after copying, such as if they both share a reference to a common object (such as an array).</p>

<p>Since the two objects also share references to their common functions, that means that <strong>even manual copying of functions (aka, mixins) from one object to another doesn't <em>actually emulate</em> the real duplication from class to instance that occurs in class-oriented languages</strong>.</p>

<p>JavaScript functions can't really be duplicated (in a standard, reliable way), so what you end up with instead is a <strong>duplicated reference</strong> to the same shared function object (functions are objects; see Chapter 3). If you modified one of the shared <strong>function objects</strong> (like <code>ignition()</code>) by adding properties on top of it, for instance, both <code>Vehicle</code> and <code>Car</code> would be "affected" via the shared reference.</p>

<p>Explicit mixins are a fine mechanism in JavaScript. But they appear more powerful than they really are. Not much benefit is <em>actually</em> derived from copying a property from one object to another, <strong>as opposed to just defining the properties twice</strong>, once on each object. And that's especially true given the function-object reference nuance we just mentioned.</p>

<p>If you explicitly mix-in two or more objects into your target object, you can <strong>partially emulate</strong> the behavior of "multiple inheritance", but there's no direct way to handle collisions if the same method or property is being copied from more than one source. Some developers/libraries have come up with "late binding" techniques and other exotic work-arounds, but fundamentally these "tricks" are <em>usually</em> more effort (and lesser performance!) than the pay-off.</p>

<p>Take care only to use explicit mixins where it actually helps make more readable code, and avoid the pattern if you find it making code that's harder to trace, or if you find it creates unnecessary or unwieldy dependencies between objects.</p>

<p><strong>If it starts to get <em>harder</em> to properly use mixins than before you used them</strong>, you should probably stop using mixins. In fact, if you have to use a complex library/utility to work out all these details, it might be a sign that you're going about it the harder way, perhaps unnecessarily. In Chapter 6, we'll try to distill a simpler way that accomplishes the desired outcomes without all the fuss.</p>

<h4><a id="user-content-parasitic-inheritance" class="anchor" href="#parasitic-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parasitic Inheritance</h4>

<p>A variation on this explicit mixin pattern, which is both in some ways explicit and in other ways implicit, is called "parasitic inheritance", popularized mainly by Douglas Crockford.</p>

<p>Here's how it can work:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// "Traditional JS Class" `Vehicle`</span>
<span class="pl-k">function</span> <span class="pl-en">Vehicle</span>() {
    <span class="pl-v">this</span>.engines <span class="pl-k">=</span> <span class="pl-c1">1</span>;
}
<span class="pl-c1">Vehicle</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">ignition</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Turning on my engine.<span class="pl-pds">"</span></span> );
};
<span class="pl-c1">Vehicle</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">drive</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-v">this</span>.ignition();
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Steering and moving forward!<span class="pl-pds">"</span></span> );
};

<span class="pl-c">// "Parasitic Class" `Car`</span>
<span class="pl-k">function</span> <span class="pl-en">Car</span>() {
    <span class="pl-c">// first, `car` is a `Vehicle`</span>
    <span class="pl-k">var</span> car <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Vehicle</span>();

    <span class="pl-c">// now, let's modify our `car` to specialize it</span>
    car.wheels <span class="pl-k">=</span> <span class="pl-c1">4</span>;

    <span class="pl-c">// save a privileged reference to `Vehicle::drive()`</span>
    <span class="pl-k">var</span> vehDrive <span class="pl-k">=</span> car.drive;

    <span class="pl-c">// override `Vehicle::drive()`</span>
    <span class="pl-c1">car</span>.<span class="pl-en">drive</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
        vehDrive.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Rolling on all <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.wheels <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> wheels!<span class="pl-pds">"</span></span> );
    };

    <span class="pl-k">return</span> car;
}

<span class="pl-k">var</span> myCar <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Car</span>();

myCar.drive();
<span class="pl-c">// Turning on my engine.</span>
<span class="pl-c">// Steering and moving forward!</span>
<span class="pl-c">// Rolling on all 4 wheels!</span></pre></div>

<p>As you can see, we initially make a copy of the definition from the <code>Vehicle</code> "parent class" (object), then mixin our "child class" (object) definition (preserving privileged parent-class references as needed), and pass off this composed object <code>car</code> as our child instance.</p>

<p>**Note: when we call <code>new Car()</code>, a new object is created and referenced by <code>Car</code>s <code>this</code> reference (see Chapter 2). But since we don't use that object, and instead return our own <code>car</code> object, the initially created object is just discarded. So, <code>Car()</code> could be called without the <code>new</code> keyword, and the functionality above would be identical, but without the wasted object creation/garbage-collection.</p>

<h3><a id="user-content-implicit-mixins" class="anchor" href="#implicit-mixins" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implicit Mixins</h3>

<p>Implicit mixins are closely related to <em>explicit pseudo-polymorphism</em> as explained previously. As such, they come with the same caveats and warnings.</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Something <span class="pl-k">=</span> {
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-v">this</span>.greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>;
        <span class="pl-v">this</span>.count <span class="pl-k">=</span> <span class="pl-v">this</span>.count <span class="pl-k">?</span> <span class="pl-v">this</span>.count <span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>;
    }
};

Something.cool();
Something.greeting; <span class="pl-c">// "Hello World"</span>
Something.count; <span class="pl-c">// 1</span>

<span class="pl-k">var</span> Another <span class="pl-k">=</span> {
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// implicit mixin of `Something` to `Another`</span>
        Something.cool.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
    }
};

Another.cool();
Another.greeting; <span class="pl-c">// "Hello World"</span>
Another.count; <span class="pl-c">// 1 (not shared state with `Something`)</span></pre></div>

<p>With <code>Something.cool.call( this )</code>, which can happen either in a "constructor" call (most common) or in a method call (shown here), we essentially "borrow" the function <code>Something.cool()</code> and call it in the context of <code>Another</code> (via its <code>this</code> binding; see Chapter 2) instead of <code>Something</code>. The end result is that the assignments that <code>Something.cool()</code> makes are applied against the <code>Another</code> object rather than the <code>Something</code> object.</p>

<p>So, it is said that we "mixed in" <code>Something</code>s behavior with (or into) <code>Another</code>.</p>

<p>While this sort of technique seems to take useful advantage of <code>this</code> rebinding functionality, it is the brittle <code>Something.cool.call( this )</code> call, which cannot be made into a relative (and thus more flexible) reference, that you should <strong>heed with caution</strong>. Generally, <strong>avoid such constructs where possible</strong> to keep cleaner and more maintainable code.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Classes are a design pattern. Many languages provide syntax which enables natural class-oriented software design. JS also has a similar syntax, but it behaves <strong>very differently</strong> from what you're used to with classes in those other languages.</p>

<p><strong>Classes mean copies.</strong></p>

<p>When traditional classes are instantiated, a copy of behavior from class to instance occurs. When classes are inherited, a copy of behavior from parent to child also occurs.</p>

<p>Polymorphism (having different functions at multiple levels of an inheritance chain with the same name) may seem like it implies a referential relative link from child back to parent, but it's still just a result of copy behavior.</p>

<p>JavaScript <strong>does not automatically</strong> create copies (as classes imply) between objects.</p>

<p>The mixin pattern (both explicit and implicit) is often used to <em>sort of</em> emulate class copy behavior, but this usually leads to ugly and brittle syntax like explicit pseudo-polymorphism (<code>OtherObj.methodName.call(this, ...)</code>), which often results in harder to understand and maintain code.</p>

<p>Explicit mixins are also not exactly the same as class <em>copy</em>, since objects (and functions!) only have shared references duplicated, not the objects/functions duplicated themselves. Not paying attention to such nuance is the source of a variety of gotchas.</p>

<p>In general, faking classes in JS often sets more landmines for future coding than solving present <em>real</em> problems.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-5-prototypes" class="anchor" href="#chapter-5-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 5: Prototypes</h1>

<p>In Chapters 3 and 4, we mentioned the <code>[[Prototype]]</code> chain several times, but haven't said what exactly it is. We will now examine prototypes in detail.</p>

<p><strong>Note:</strong> All of the attempts to emulate class-copy behavior, as described previously in Chapter 4, labeled as variations of "mixins", completely circumvent the <code>[[Prototype]]</code> chain mechanism we examine here in this chapter.</p>

<h2><a id="user-content-prototype" class="anchor" href="#prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>[[Prototype]]</code></h2>

<p>Objects in JavaScript have an internal property, denoted in the specification as <code>[[Prototype]]</code>, which is simply a reference to another object. Almost all objects are given a non-<code>null</code> value for this property, at the time of their creation.</p>

<p><strong>Note:</strong> We will see shortly that it <em>is</em> possible for an object to have an empty <code>[[Prototype]]</code> linkage, though this is somewhat less common.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>What is the <code>[[Prototype]]</code> reference used for? In Chapter 3, we examined the <code>[[Get]]</code> operation that is invoked when you reference a property on an object, such as <code>myObject.a</code>. For that default <code>[[Get]]</code> operation, the first step is to check if the object itself has a property <code>a</code> on it, and if so, it's used.</p>

<p><strong>Note:</strong> ES6 Proxies are outside of our discussion scope in this book (will be covered in a later book in the series!), but everything we discuss here about normal <code>[[Get]]</code> and <code>[[Put]]</code> behavior does not apply if a <code>Proxy</code> is involved.</p>

<p>But it's what happens if <code>a</code> <strong>isn't</strong> present on <code>myObject</code> that brings our attention now to the <code>[[Prototype]]</code> link of the object.</p>

<p>The default <code>[[Get]]</code> operation proceeds to follow the <code>[[Prototype]]</code> <strong>link</strong> of the object if it cannot find the requested property on the object directly.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-c">// create an object linked to `anotherObject`</span>
<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject );

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p><strong>Note:</strong> We will explain what <code>Object.create(..)</code> does, and how it operates, shortly. For now, just assume it creates an object with the <code>[[Prototype]]</code> linkage we're examining to the object specified.</p>

<p>So, we have <code>myObject</code> that is now <code>[[Prototype]]</code> linked to <code>anotherObject</code>. Clearly <code>myObject.a</code> doesn't actually exist, but nevertheless, the property access succeeds (being found on <code>anotherObject</code> instead) and indeed finds the value <code>2</code>.</p>

<p>But, if <code>a</code> weren't found on <code>anotherObject</code> either, its <code>[[Prototype]]</code> chain, if non-empty, is again consulted and followed.</p>

<p>This process continues until either a matching property name is found, or the <code>[[Prototype]]</code> chain ends. If no matching property is <em>ever</em> found by the end of the chain, the return result from the <code>[[Get]]</code> operation is <code>undefined</code>.</p>

<p>Similar to this <code>[[Prototype]]</code> chain look-up process, if you use a <code>for..in</code> loop to iterate over an object, any property that can be reached via its chain (and is also <code>enumerable</code> -- see Chapter 3) will be enumerated. If you use the <code>in</code> operator to test for the existence of a property on an object, <code>in</code> will check the entire chain of the object (regardless of <em>enumerability</em>).</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-c">// create an object linked to `anotherObject`</span>
<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject );

<span class="pl-k">for</span> (<span class="pl-k">var</span> k <span class="pl-k">in</span> myObject) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>found: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> k);
}
<span class="pl-c">// found: a</span>

(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">in</span> myObject); <span class="pl-c">// true</span></pre></div>

<p>So, the <code>[[Prototype]]</code> chain is consulted, one link at a time, when you perform property look-ups in various fashions. The look-up stops once the property is found or the chain ends.</p>

<h3><a id="user-content-objectprototype" class="anchor" href="#objectprototype" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.prototype</code></h3>

<p>But <em>where</em> exactly does the <code>[[Prototype]]</code> chain "end"?</p>

<p>The top-end of every <em>normal</em> <code>[[Prototype]]</code> chain is the built-in <code>Object.prototype</code>. This object includes a variety of common utilities used all over JS, because all normal (built-in, not host-specific extension) objects in JavaScript "descend from" (aka, have at the top of their <code>[[Prototype]]</code> chain) the <code>Object.prototype</code> object.</p>

<p>Some utilities found here you may be familiar with include <code>.toString()</code> and <code>.valueOf()</code>. In Chapter 3, we introduced another: <code>.hasOwnProperty(..)</code>. And yet another function on <code>Object.prototype</code> you may not be familiar with, but which we'll address later in this chapter, is <code>.isPrototypeOf(..)</code>.</p>

<h3><a id="user-content-setting--shadowing-properties" class="anchor" href="#setting--shadowing-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting &amp; Shadowing Properties</h3>

<p>Back in Chapter 3, we mentioned that setting properties on an object was more nuanced than just adding a new property to the object or changing an existing property's value. We will now revisit this situation more completely.</p>

<div class="highlight highlight-js"><pre>myObject.foo <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;</pre></div>

<p>If the <code>myObject</code> object already has a normal data accessor property called <code>foo</code> directly present on it, the assignment is as simple as changing the value of the existing property.</p>

<p>If <code>foo</code> is not already present directly on <code>myObject</code>, the <code>[[Prototype]]</code> chain is traversed, just like for the <code>[[Get]]</code> operation. If <code>foo</code> is not found anywhere in the chain, the property <code>foo</code> is added directly to <code>myObject</code> with the specified value, as expected.</p>

<p>However, if <code>foo</code> is already present somewhere higher in the chain, nuanced (and perhaps surprising) behavior can occur with the <code>myObject.foo = "bar"</code> assignment. We'll examine that more in just a moment.</p>

<p>If the property name <code>foo</code> ends up both on <code>myObject</code> itself and at a higher level of the <code>[[Prototype]]</code> chain that starts at <code>myObject</code>, this is called <em>shadowing</em>. The <code>foo</code> property directly on <code>myObject</code> <em>shadows</em> any <code>foo</code> property which appears higher in the chain, because the <code>myObject.foo</code> look-up would always find the <code>foo</code> property that's lowest in the chain.</p>

<p>As we just hinted, shadowing <code>foo</code> on <code>myObject</code> is not as simple as it may seem. We will now examine three scenarios for the <code>myObject.foo = "bar"</code> assignment when <code>foo</code> is <strong>not</strong> already on <code>myObject</code> directly, but <strong>is</strong> at a higher level of <code>myObject</code>'s <code>[[Prototype]]</code> chain:</p>

<ol>
<li>If a normal data accessor (see Chapter 3) property named <code>foo</code> is found anywhere higher on the <code>[[Prototype]]</code> chain, <strong>and it's not marked as read-only (<code>writable:false</code>)</strong> then a new property called <code>foo</code> is added directly to <code>myObject</code>, resulting in a <strong>shadowed property</strong>.</li>
<li>If a <code>foo</code> is found higher on the <code>[[Prototype]]</code> chain, but it's marked as <strong>read-only (<code>writable:false</code>)</strong>, then both the setting of that existing property as well as the creation of the shadowed property on <code>myObject</code> <strong>are disallowed</strong>. If the code is running in <code>strict mode</code>, an error will be thrown. Otherwise, the setting of the property value will silently be ignored. Either way, <strong>no shadowing occurs</strong>.</li>
<li>If a <code>foo</code> is found higher on the <code>[[Prototype]]</code> chain and it's a setter (see Chapter 3), then the setter will always be called. No <code>foo</code> will be added to (aka, shadowed on) <code>myObject</code>, nor will the <code>foo</code> setter be redefined.</li>
</ol>

<p>Most developers assume that assignment of a property (<code>[[Put]]</code>) will always result in shadowing if the property already exists higher on the <code>[[Prototype]]</code> chain, but as you can see, that's only true in one (#1) of the three situations just described.</p>

<p>If you want to shadow <code>foo</code> in cases #2 and #3, you cannot use <code>=</code> assignment, but must instead use <code>Object.defineProperty(..)</code> (see Chapter 3) to add <code>foo</code> to <code>myObject</code>.</p>

<p><strong>Note:</strong> Case #2 may be the most surprising of the three. The presence of a <em>read-only</em> property prevents a property of the same name being implicitly created (shadowed) at a lower level of a <code>[[Prototype]]</code> chain. The reason for this restriction is primarily to reinforce the illusion of class-inherited properties. If you think of the <code>foo</code> at a higher level of the chain as having been inherited (copied down) to <code>myObject</code>, then it makes sense to enforce the non-writable nature of that <code>foo</code> property on <code>myObject</code>. If you however separate the illusion from the fact, and recognize that no such inheritance copying <em>actually</em> occured (see Chapters 4 and 5), it's a little unnatural that <code>myObject</code> would be prevented from having a <code>foo</code> property just because some other object had a non-writable <code>foo</code> on it. It's even stranger that this restriction only applies to <code>=</code> assignment, but is not enforced when using <code>Object.defineProperty(..)</code>.</p>

<p>Shadowing with <strong>methods</strong> leads to ugly <em>explicit pseudo-polymorphism</em> (see Chapter 4) if you need to delegate between them. Usually, shadowing is more complicated and nuanced than it's worth, <strong>so you should try to avoid it if possible</strong>. See Chapter 6 for an alternative design pattern, which among other things discourages shadowing in favor of cleaner alternatives.</p>

<p>Shadowing can even occur implicitly in subtle ways, so care must be taken if trying to avoid it. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject );

anotherObject.a; <span class="pl-c">// 2</span>
myObject.a; <span class="pl-c">// 2</span>

anotherObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// false</span>

myObject.a<span class="pl-k">++</span>; <span class="pl-c">// oops, implicit shadowing!</span>

anotherObject.a; <span class="pl-c">// 2</span>
myObject.a; <span class="pl-c">// 3</span>

myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span></pre></div>

<p>Though it may appear that <code>myObject.a++</code> should (via delegation) look-up and just increment the <code>anotherObject.a</code> property itself <em>in place</em>, instead the <code>++</code> operation corresponds to <code>myObject.a = myObject.a + 1</code>. The result is <code>[[Get]]</code> looking up <code>a</code> property via <code>[[Prototype]]</code> to get the current value <code>2</code> from <code>anotherObject.a</code>, incrementing the value by one, then <code>[[Put]]</code> assigning the <code>3</code> value to a new shadowed property <code>a</code> on <code>myObject</code>. Oops!</p>

<p>Be very careful when dealing with delegated properties that you modify. If you wanted to increment <code>anotherObject.a</code>, the only proper way is <code>anotherObject.a++</code>.</p>

<h2><a id="user-content-class" class="anchor" href="#class" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Class"</h2>

<p>At this point, you might be wondering: "<em>Why</em> does one object need to link to another object?" What's the real benefit? That is a very appropriate question to ask, but we must first understand what <code>[[Prototype]]</code> is <strong>not</strong> before we can fully understand and appreciate what it <em>is</em> and how it's useful.</p>

<p>As we explained in Chapter 4, in JavaScript, there are no abstract patterns/blueprints for objects called "classes" as there are in class-oriented languages. JavaScript <strong>just</strong> has objects.</p>

<p>In fact, JavaScript is <strong>almost unique</strong> among languages as perhaps the only language with the right to use the label "object oriented", because it's one of a very short list of languages where an object can be created directly, without a class at all.</p>

<p>In JavaScript, classes can't (being that they don't exist!) describe what an object can do. The object defines its own behavior directly. <strong>There's <em>just</em> the object.</strong></p>

<h3><a id="user-content-class-functions" class="anchor" href="#class-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Class" Functions</h3>

<p>There's a peculiar kind of behavior in JavaScript that has been shamelessly abused for years to <em>hack</em> something that <em>looks</em> like "classes". We'll examine this approach in detail.</p>

<p>The peculiar "sort-of class" behavior hinges on a strange characteristic of functions: all functions by default get a public, non-enumerable (see Chapter 3) property on them called <code>prototype</code>, which points at an otherwise arbitrary object.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}

Foo.<span class="pl-c1">prototype</span>; <span class="pl-c">// { }</span></pre></div>

<p>This object is often called "Foo's prototype", because we access it via an unfortunately-named property <code>Foo.prototype</code> property reference. However, that terminology is hopelessly destined to lead us into confusion, as we'll see shortly. Instead, I will call it "the object formerly known as Foo's prototype". Just kidding. How about: "object arbitrarily labeled 'Foo dot prototype'"?</p>

<p>Whatever we call it, what exactly is this object?</p>

<p>The most direct way to explain it is that each object created from calling <code>new Foo()</code> (see Chapter 2) will end up (somewhat arbitrarily) <code>[[Prototype]]</code>-linked to this "Foo dot prototype" object.</p>

<p>Let's illustrate:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

<span class="pl-c1">Object</span>.getPrototypeOf( a ) <span class="pl-k">===</span> Foo.<span class="pl-c1">prototype</span>; <span class="pl-c">// true</span></pre></div>

<p>When <code>a</code> is created by calling <code>new Foo()</code>, one of the things (see Chapter 2 for all <em>four</em> steps) that happens is that <code>a</code> gets an internal <code>[[Prototype]]</code> link to the object that <code>Foo.prototype</code> is pointing at.</p>

<p>Stop for a moment and ponder the implications of that statement.</p>

<p>In class-oriented languages, multiple <strong>copies</strong> (aka, "instances") of a class can be made, like stamping something out from a mold. As we saw in Chapter 4, this happens because the process of instantiating (or inheriting from) a class means, "copy the behavior plan from that class into a physical object", and this is done again for each new instance.</p>

<p>But in JavaScript, there are no such copy-actions performed. You don't create multiple instances of a class. You can create multiple objects that <code>[[Prototype]]</code> <em>link</em> to a common object. But by default, no copying occurs, and thus these objects don't end up totally separate and disconnected from each other, but rather, quite <strong><em>linked</em></strong>.</p>

<p><code>new Foo()</code> results in a new object (we called it <code>a</code>), and <strong>that</strong> new object <code>a</code> is internally <code>[[Prototype]]</code> linked to the <code>Foo.prototype</code> object.</p>

<p><strong>We end up with two objects, linked to each other.</strong> That's <em>it</em>. We didn't instantiate a class. We certainly didn't do any copying of behavior from a "class" into a concrete object. We just caused two objects to be linked to each other.</p>

<p>In fact, the secret, which eludes most JS developers, is that the <code>new Foo()</code> function calling had really almost nothing <em>direct</em> to do with the process of creating the link. <strong>It was sort of an accidental side-effect.</strong> <code>new Foo()</code> is an indirect, round-about way to end up with what we want: <strong>a new object linked to another object</strong>.</p>

<p>Can we get what we want in a more <em>direct</em> way? <strong>Yes!</strong> The hero is <code>Object.create(..)</code>. But we'll get to that in a little bit.</p>

<h4><a id="user-content-whats-in-a-name" class="anchor" href="#whats-in-a-name" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's in a name?</h4>

<p>In JavaScript, we don't make <em>copies</em> from one object ("class") to another ("instance"). We make <em>links</em> between objects. For the <code>[[Prototype]]</code> mechanism, visually, the arrows move from right to left, and from bottom to top.</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig3.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig3.png" style="max-width:100%;"></a></p>

<p>This mechanism is often called "prototypal inheritance" (we'll explore the code in detail shortly), which is commonly said to be the dynamic-language version of "classical inheritance". It's an attempt to piggy-back on the common understanding of what "inheritance" means in the class-oriented world, but <em>tweak</em> (<strong>read: pave over</strong>) the understood semantics, to fit dynamic scripting.</p>

<p>The word "inheritance" has a very strong meaning (see Chapter 4), with plenty of mental precedent. Merely adding "prototypal" in front to distinguish the <em>actually nearly opposite</em> behavior in JavaScript has left in its wake nearly two decades of miry confusion.</p>

<p>I like to say that sticking "prototypal" in front "inheritance" to drastically reverse its actual meaning is like holding an orange in one hand, an apple in the other, and insisting on calling the apple a "red orange". No matter what confusing label I put in front of it, that doesn't change the <em>fact</em> that one fruit is an apple and the other is an orange.</p>

<p>The better approach is to plainly call an apple an apple -- to use the most accurate and direct terminology. That makes it easier to understand both their similarities and their <strong>many differences</strong>, because we all have a simple, shared understanding of what "apple" means.</p>

<p>Because of the confusion and conflation of terms, I believe the label "prototypal inheritance" itself (and trying to mis-apply all its associated class-orientation terminology, like "class", "constructor", "instance", "polymorphism", etc) has done <strong>more harm than good</strong> in explaining how JavaScript's mechanism <em>really</em> works.</p>

<p>"Inheritance" implies a <em>copy</em> operation, and JavaScript doesn't copy object properties (natively, by default). Instead, JS creates a link between two objects, where one object can essentially <em>delegate</em> property/function access to another object. "Delegation" (see Chapter 6) is a much more accurate term for JavaScript's object-linking mechanism.</p>

<p>Another term which is sometimes thrown around in JavaScript is "differential inheritance". The idea here is that we describe an object's behavior in terms of what is <em>different</em> from a more general descriptor. For example, you explain that a car is a kind of vehicle, but one that has exactly 4 wheels, rather than re-describing all the specifics of what makes up a general vehicle (engine, etc).</p>

<p>If you try to think of any given object in JS as the sum total of all behavior that is <em>available</em> via delegation, and <strong>in your mind you flatten</strong> all that behavior into one tangible <em>thing</em>, then you can (sorta) see how "differential inheritance" might fit.</p>

<p>But just like with "prototypal inheritance", "differential inheritance" pretends that your mental model is more important than what is physically happening in the language. It overlooks the fact that object <code>B</code> is not actually differentially constructed, but is instead built with specific characteristics defined, alongside "holes" where nothing is defined. It is in these "holes" (gaps in, or lack of, definition) that delegation <em>can</em> take over and, on the fly, "fill them in" with delegated behavior.</p>

<p>The object is not, by native default, flattened into the single differential object, <strong>through copying</strong>, that the mental model of "differential inheritance" implies. As such, "differential inheritance" is just not as natural a fit for describing how JavaScript's <code>[[Prototype]]</code> mechanism actually works.</p>

<p>You <em>can choose</em> to prefer the "differential inheritance" terminology and mental model, as a matter of taste, but there's no denying the fact that it <em>only</em> fits the mental acrobatics in your mind, not the physical behavior in the engine.</p>

<h3><a id="user-content-constructors" class="anchor" href="#constructors" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Constructors"</h3>

<p>Let's go back to some earlier code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();</pre></div>

<p>What exactly leads us to think <code>Foo</code> is a "class"?</p>

<p>For one, we see the use of the <code>new</code> keyword, just like class-oriented languages do when they construct class instances. For another, it appears that we are in fact executing a <em>constructor</em> method of a class, because <code>Foo()</code> is actually a method that gets called, just like how a real class's constructor gets called when you instantiate that class.</p>

<p>To further the confusion of "constructor" semantics, the arbitrarily labeled <code>Foo.prototype</code> object has another trick up its sleeve. Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">constructor</span> <span class="pl-k">=</span><span class="pl-k">==</span> Foo; <span class="pl-c">// true</span>

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
a.<span class="pl-c1">constructor</span> <span class="pl-k">===</span> Foo; <span class="pl-c">// true</span></pre></div>

<p>The <code>Foo.prototype</code> object by default (at declaration time on line 1 of the snippet!) gets a public, non-enumerable (see Chapter 3) property called <code>.constructor</code>, and this property is a reference back to the function (<code>Foo</code> in this case) that the object is associated with. Moreover, we see that object <code>a</code> created by the "constructor" call <code>new Foo()</code> <em>seems</em> to also have a property on it called <code>.constructor</code> which similarly points to "the function which created it".</p>

<p><strong>Note:</strong> This is not actually true. <code>a</code> has no <code>.constructor</code> property on it, and though <code>a.constructor</code> does in fact resolve to the <code>Foo</code> function, "constructor" <strong>does not actually mean</strong> "was constructed by", as it appears. We'll explain this strangeness shortly.</p>

<p>Oh, yeah, also... by convention in the JavaScript world, "class"es are named with a capital letter, so the fact that it's <code>Foo</code> instead of <code>foo</code> is a strong clue that we intend it to be a "class". That's totally obvious to you, right!?</p>

<p><strong>Note:</strong> This convention is so strong that many JS linters actually <em>complain</em> if you call <code>new</code> on a method with a lowercase name, or if we don't call <code>new</code> on a function that happens to start with a capital letter. That sort of boggles the mind that we struggle so much to get (fake) "class-orientation" <em>right</em> in JavaScript that we create linter rules to ensure we use capital letters, even though the capital letter doesn't mean <strong><em>anything</em> at all</strong> to the JS engine.</p>

<h4><a id="user-content-constructor-or-call" class="anchor" href="#constructor-or-call" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructor Or Call?</h4>

<p>In the above snippet, it's tempting to think that <code>Foo</code> is a "constructor", because we call it with <code>new</code> and we observe that it "constructs" an object.</p>

<p>In reality, <code>Foo</code> is no more a "constructor" than any other function in your program. Functions themselves are <strong>not</strong> constructors. However, when you put the <code>new</code> keyword in front of a normal function call, that makes that function call a "constructor call". In fact, <code>new</code> sort of hijacks any normal function and calls it in a fashion that constructs an object, <strong>in addition to whatever else it was going to do</strong>.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">NothingSpecial</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Don't mind me!<span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">NothingSpecial</span>();
<span class="pl-c">// "Don't mind me!"</span>

a; <span class="pl-c">// {}</span></pre></div>

<p><code>NothingSpecial</code> is just a plain old normal function, but when called with <code>new</code>, it <em>constructs</em> an object, almost as a side-effect, which we happen to assign to <code>a</code>. The <strong>call</strong> was a <em>constructor call</em>, but <code>NothingSpecial</code> is not, in and of itself, a <em>constructor</em>.</p>

<p>In other words, in JavaScript, it's most appropriate to say that a "constructor" is <strong>any function called with the <code>new</code> keyword</strong> in front of it.</p>

<p>Functions aren't constructors, but function calls are "constructor calls" if and only if <code>new</code> is used.</p>

<h3><a id="user-content-mechanics" class="anchor" href="#mechanics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mechanics</h3>

<p>Are <em>those</em> the only common triggers for ill-fated "class" discussions in JavaScript?</p>

<p><strong>Not quite.</strong> JS developers have strived to simulate as much as they can of class-orientation:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">name</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">myName</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> );

a.myName(); <span class="pl-c">// "a"</span>
b.myName(); <span class="pl-c">// "b"</span></pre></div>

<p>This snippet shows two additional "class-orientation" tricks in play:</p>

<ol>
<li><p><code>this.name = name</code>: adds the <code>.name</code> property onto each object (<code>a</code> and <code>b</code>, respectively; see Chapter 2 about <code>this</code> binding), similar to how class instances encapsulate data values.</p></li>
<li><p><code>Foo.prototype.myName = ...</code>: perhaps the more interesting technique, this adds a property (function) to the <code>Foo.prototype</code> object. Now, <code>a.myName()</code> works, but perhaps surprisingly. How?</p></li>
</ol>

<p>In the above snippet, it's strongly tempting to think that when <code>a</code> and <code>b</code> are created, the properties/functions on the <code>Foo.prototype</code> object are <em>copied</em> over to each of <code>a</code> and <code>b</code> objects. <strong>However, that's not what happens.</strong></p>

<p>At the beginning of this chapter, we explained the <code>[[Prototype]]</code> link, and how it provides the fall-back look-up steps if a property reference isn't found directly on an object, as part of the default <code>[[Get]]</code> algorithm.</p>

<p>So, by virtue of how they are created, <code>a</code> and <code>b</code> each end up with an internal <code>[[Prototype]]</code> linkage to <code>Foo.prototype</code>. When <code>myName</code> is not found on <code>a</code> or <code>b</code>, respectively, it's instead found (through delegation, see Chapter 6) on <code>Foo.prototype</code>.</p>

<h4><a id="user-content-constructor-redux" class="anchor" href="#constructor-redux" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Constructor" Redux</h4>

<p>Recall the discussion from earlier about the <code>.constructor</code> property, and how it <em>seems</em> like <code>a.constructor === Foo</code> being true means that <code>a</code> has an actual <code>.constructor</code> property on it, pointing at <code>Foo</code>? <strong>Not correct.</strong></p>

<p>This is just unfortunate confusion. In actuality, the <code>.constructor</code> reference is also <em>delegated</em> up to <code>Foo.prototype</code>, which <strong>happens to</strong>, by default, have a <code>.constructor</code> that points at <code>Foo</code>.</p>

<p>It <em>seems</em> awfully convenient that an object <code>a</code> "constructed by" <code>Foo</code> would have access to a <code>.constructor</code> property that points to <code>Foo</code>. But that's nothing more than a false sense of security. It's a happy accident, almost tangentially, that <code>a.constructor</code> <em>happens</em> to point at <code>Foo</code> via this default <code>[[Prototype]]</code> delegation. There's actually several ways that the ill-fated assumption of <code>.constructor</code> meaning "was constructed by" can come back to bite you.</p>

<p>For one, the <code>.constructor</code> property on <code>Foo.prototype</code> is only there by default on the object created when <code>Foo</code> the function is declared. If you create a new object, and replace a function's default <code>.prototype</code> object reference, the new object will not by default magically get a <code>.constructor</code> on it.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() { <span class="pl-c">/* .. */</span> }

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> { <span class="pl-c">/* .. */</span> }; <span class="pl-c">// create a new prototype object</span>

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
a1.<span class="pl-c1">constructor</span> <span class="pl-k">===</span> Foo; <span class="pl-c">// false!</span>
a1.<span class="pl-c1">constructor</span> <span class="pl-k">===</span> <span class="pl-c1">Object</span>; <span class="pl-c">// true!</span></pre></div>

<p><code>Object(..)</code> didn't "construct" <code>a1</code> did it? It sure seems like <code>Foo()</code> "constructed" it. Many developers think of <code>Foo()</code> as doing the construction, but where everything falls apart is when you think "constructor" means "was constructed by", because by that reasoning, <code>a1.constructor</code> should be <code>Foo</code>, but it isn't!</p>

<p>What's happening? <code>a1</code> has no <code>.constructor</code> property, so it delegates up the <code>[[Prototype]]</code> chain to <code>Foo.prototype</code>. But that object doesn't have a <code>.constructor</code> either (like the default <code>Foo.prototype</code> object would have had!), so it keeps delegating, this time up to <code>Object.prototype</code>, the top of the delegation chain. <em>That</em> object indeed has a <code>.constructor</code> on it, which points to the built-in <code>Object(..)</code> function.</p>

<p><strong>Misconception, busted.</strong></p>

<p>Of course, you can add <code>.constructor</code> back to the <code>Foo.prototype</code> object, but this takes manual work, especially if you want to match native behavior and have it be non-enumerable (see Chapter 3).</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() { <span class="pl-c">/* .. */</span> }

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> { <span class="pl-c">/* .. */</span> }; <span class="pl-c">// create a new prototype object</span>

<span class="pl-c">// Need to properly "fix" the missing `.constructor`</span>
<span class="pl-c">// property on the new object serving as `Foo.prototype`.</span>
<span class="pl-c">// See Chapter 3 for `defineProperty(..)`.</span>
<span class="pl-c1">Object</span>.defineProperty( Foo.<span class="pl-c1">prototype</span>, <span class="pl-s"><span class="pl-pds">"</span>constructor<span class="pl-pds">"</span></span> , {
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    value<span class="pl-k">:</span> Foo    <span class="pl-c">// point `.constructor` at `Foo`</span>
} );</pre></div>

<p>That's a lot of manual work to fix <code>.constructor</code>. Moreover, all we're really doing is perpetuating the misconception that "constructor" means "was constructed by". That's an <em>expensive</em> illusion.</p>

<p>The fact is, <code>.constructor</code> on an object arbitrarily points, by default, at a function who, reciprocally, has a reference back to the object -- a reference which it calls <code>.prototype</code>. The words "constructor" and "prototype" only have a loose default meaning that might or might not hold true later. The best thing to do is remind yourself, "constructor does not mean constructed by".</p>

<p><code>.constructor</code> is not a magic immutable property. It <em>is</em> non-enumerable (see snippet above), but its value is writable (can be changed), and moreover, you can add or overwrite (intentionally or accidentally) a property of the name <code>constructor</code> on any object in any <code>[[Prototype]]</code> chain, with any value you see fit.</p>

<p>By virtue of how the <code>[[Get]]</code> algorithm traverses the <code>[[Prototype]]</code> chain, a <code>.constructor</code> property reference found anywhere may resolve quite differently than you'd expect.</p>

<p>See how arbitrary its meaning actually is?</p>

<p>The result? Some arbitrary object-property reference like <code>a1.constructor</code> cannot actually be <em>trusted</em> to be the assumed default function reference. Moreover, as we'll see shortly, just by simple omission, <code>a1.constructor</code> can even end up pointing somewhere quite surprising and insensible.</p>

<p><code>a1.constructor</code> is extremely unreliable, and an unsafe reference to rely upon in your code. <strong>Generally, such references should be avoided where possible.</strong></p>

<h2><a id="user-content-prototypal-inheritance" class="anchor" href="#prototypal-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>"(Prototypal) Inheritance"</h2>

<p>We've seen some approximations of "class" mechanics as typically hacked into JavaScript programs. But JavaScript "class"es would be rather hollow if we didn't have an approximation of "inheritance".</p>

<p>Actually, we've already seen the mechanism which is commonly called "prototypal inheritance" at work when <code>a</code> was able to "inherit from" <code>Foo.prototype</code>, and thus get access to the <code>myName()</code> function. But we traditionally think of "inheritance" as being a relationship between two "classes", rather than between "class" and "instance".</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig3.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig3.png" style="max-width:100%;"></a></p>

<p>Recall this figure from earlier, which shows not only delegation from an object (aka, "instance") <code>a1</code> to object <code>Foo.prototype</code>, but from <code>Bar.prototype</code> to <code>Foo.prototype</code>, which somewhat resembles the concept of Parent-Child class inheritance. <em>Resembles</em>, except of course for the direction of the arrows, which show these are delegation links rather than copy operations.</p>

<p>And, here's the typical "prototype style" code that creates such links:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">name</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> name;
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">myName</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">name</span>;
};

<span class="pl-k">function</span> <span class="pl-en">Bar</span>(<span class="pl-smi">name</span>,<span class="pl-smi">label</span>) {
    Foo.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, name );
    <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> label;
}

<span class="pl-c">// here, we make a new `Bar.prototype`</span>
<span class="pl-c">// linked to `Foo.prototype`</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );

<span class="pl-c">// Beware! Now `Bar.prototype.constructor` is gone,</span>
<span class="pl-c">// and might need to be manually "fixed" if you're</span>
<span class="pl-c">// in the habit of relying on such properties!</span>

<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">myLabel</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">label</span>;
};

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>obj a<span class="pl-pds">"</span></span> );

a.myName(); <span class="pl-c">// "a"</span>
a.myLabel(); <span class="pl-c">// "obj a"</span></pre></div>

<p><strong>Note:</strong> To understand why <code>this</code> points to <code>a</code> in the above code snippet, see Chapter 2.</p>

<p>The important part is <code>Bar.prototype = Object.create( Foo.prototype )</code>. <code>Object.create(..)</code> <em>creates</em> a "new" object out of thin air, and links that new object's internal <code>[[Prototype]]</code> to the object you specify (<code>Foo.prototype</code> in this case).</p>

<p>In other words, that line says: "make a <em>new</em> 'Bar dot prototype' object that's linked to 'Foo dot prototype'."</p>

<p>When <code>function Bar() { .. }</code> is declared, <code>Bar</code>, like any other function, has a <code>.prototype</code> link to its default object. But <em>that</em> object is not linked to <code>Foo.prototype</code> like we want. So, we create a <em>new</em> object that <em>is</em> linked as we want, effectively throwing away the original incorrectly-linked object.</p>

<p><strong>Note:</strong> A common mis-conception/confusion here is that either of the following approaches would <em>also</em> work, but they do not work as you'd expect:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// doesn't work like you want!</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> Foo.<span class="pl-c1">prototype</span>;

<span class="pl-c">// works kinda like you want, but with</span>
<span class="pl-c">// side-effects you probably don't want :(</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();</pre></div>

<p><code>Bar.prototype = Foo.prototype</code> doesn't create a new object for <code>Bar.prototype</code> to be linked to. It just makes <code>Bar.prototype</code> be another reference to <code>Foo.prototype</code>, which effectively links <code>Bar</code> directly to <strong>the same object as</strong> <code>Foo</code> links to: <code>Foo.prototype</code>. This means when you start assigning, like <code>Bar.prototype.myLabel = ...</code>, you're modifying <strong>not a separate object</strong> but <em>the</em> shared <code>Foo.prototype</code> object itself, which would affect any objects linked to <code>Foo.prototype</code>. This is almost certainly not what you want. If it <em>is</em> what you want, then you likely don't need <code>Bar</code> at all, and should just use only <code>Foo</code> and make your code simpler.</p>

<p><code>Bar.prototype = new Foo()</code> <strong>does in fact</strong> create a new object which is duly linked to <code>Foo.prototype</code> as we'd want. But, it uses the <code>Foo(..)</code> "constructor call" to do it. If that function has any side-effects (such as logging, changing state, registering against other objects, <strong>adding data properties to <code>this</code></strong>, etc.), those side-effects happen at the time of this linking (and likely against the wrong object!), rather than only when the eventual <code>Bar()</code> "descendents" are created, as would likely be expected.</p>

<p>So, we're left with using <code>Object.create(..)</code> to make a new object that's properly linked, but without having the side-effects of calling <code>Foo(..)</code>. The slight downside is that we have to create a new object, throwing the old one away, instead of modifying the existing default object we're provided.</p>

<p>It would be <em>nice</em> if there was a standard and reliable way to modify the linkage of an existing object. Prior to ES6, there's a non-standard and not fully-cross-browser way, via the <code>.__proto__</code> property, which is settable. ES6 adds a <code>Object.setPrototypeOf(..)</code> helper utility, which does the trick in a standard and predictable way.</p>

<p>Compare the pre-ES6 and ES6-standardized techniques for linking <code>Bar.prototype</code> to <code>Foo.prototype</code>, side-by-side:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// pre-ES6</span>
<span class="pl-c">// throws away default existing `Bar.prototype`</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );

<span class="pl-c">// ES6+</span>
<span class="pl-c">// modifies existing `Bar.prototype`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( Bar.<span class="pl-c1">prototype</span>, Foo.<span class="pl-c1">prototype</span> );</pre></div>

<p>Ignoring the slight performance disadvantage (throwing away an object that's later garbage collected) of the <code>Object.create(..)</code> approach, it's a little bit shorter and may be perhaps a little easier to read than the ES6+ approach. But it's probably a syntactic wash either way.</p>

<h3><a id="user-content-inspecting-class-relationships" class="anchor" href="#inspecting-class-relationships" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inspecting "Class" Relationships</h3>

<p>What if you have an object like <code>a</code> and want to find out what object (if any) it delegates to? Inspecting an instance (just an object in JS) for its inheritance ancestry (delegation linkage in JS) is often called <em>introspection</em> (or <em>reflection</em>) in traditional class-oriented environments.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">blah</span> <span class="pl-k">=</span> ...;

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();</pre></div>

<p>How do we then introspect <code>a</code> to find out its "ancestry" (delegation linkage)? The first approach embraces the "class" confusion:</p>

<div class="highlight highlight-js"><pre>a <span class="pl-k">instanceof</span> Foo; <span class="pl-c">// true</span></pre></div>

<p>The <code>instanceof</code> operator takes a plain object as its left-hand operand and a <strong>function</strong> as its right-hand operand. The question <code>instanceof</code> answers is: <strong>in the entire <code>[[Prototype]]</code> chain of <code>a</code>, does the object arbitrarily pointed to by <code>Foo.prototype</code> ever appear?</strong></p>

<p>Unfortunately, this means that you can only inquire about the "ancestry" of some object (<code>a</code>) if you have some <strong>function</strong> (<code>Foo</code>, with its attached <code>.prototype</code> reference) to test with. If you have two arbitrary objects, say <code>a</code> and <code>b</code>, and want to find out if <em>the objects</em> are related to each other through a <code>[[Prototype]]</code> chain, <code>instanceof</code> alone can't help.</p>

<p><strong>Note:</strong> If you use the built-in <code>.bind(..)</code> utility to make a hard-bound function (see Chapter 2), the function created will not have a <code>.prototype</code> property. Using <code>instanceof</code> with such a function transparently substitutes the <code>.prototype</code> of the <em>target function</em> that the hard-bound function was created from.</p>

<p>It's fairly uncommon to use hard-bound functions as "constructor calls", but if you do, it will behave as if the original <em>target function</em> was invoked instead, which means that using <code>instanceof</code> with a hard-bound function also behaves according to the original function.</p>

<p>This snippet illustrates the ridiculousness of trying to reason about relationships between <strong>two objects</strong> using "class" semantics and <code>instanceof</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// helper utility to see if `o1` is</span>
<span class="pl-c">// related to (delegates to) `o2`</span>
<span class="pl-k">function</span> <span class="pl-en">isRelatedTo</span>(<span class="pl-smi">o1</span>, <span class="pl-smi">o2</span>) {
    <span class="pl-k">function</span> <span class="pl-en">F</span>(){}
    <span class="pl-c1">F</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> o2;
    <span class="pl-k">return</span> o1 <span class="pl-k">instanceof</span> F;
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> {};
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( a );

isRelatedTo( b, a ); <span class="pl-c">// true</span></pre></div>

<p>Inside <code>isRelatedTo(..)</code>, we borrow a throw-away function <code>F</code>, reassign its <code>.prototype</code> to arbitrarily point to some object <code>o2</code>, then ask if <code>o1</code> is an "instance of" <code>F</code>. Obviously <code>o1</code> isn't <em>actually</em> inherited or descended or even constructed from <code>F</code>, so it should be clear why this kind of exercise is silly and confusing. <strong>The problem comes down to the awkwardness of class semantics forced upon JavaScript</strong>, in this case as revealed by the indirect semantics of <code>instanceof</code>.</p>

<p>The second, and much cleaner, approach to <code>[[Prototype]]</code> reflection is:</p>

<div class="highlight highlight-js"><pre>Foo.<span class="pl-c1">prototype</span>.isPrototypeOf( a ); <span class="pl-c">// true</span></pre></div>

<p>Notice that in this case, we don't really care about (or even <em>need</em>) <code>Foo</code>, we just need an <strong>object</strong> (in our case, arbitrarily labeled <code>Foo.prototype</code>) to test against another <strong>object</strong>. The question <code>isPrototypeOf(..)</code> answers is: <strong>in the entire <code>[[Prototype]]</code> chain of <code>a</code>, does <code>Foo.prototype</code> ever appear?</strong></p>

<p>Same question, and exact same answer. But in this second approach, we don't actually need the indirection of referencing a <strong>function</strong> (<code>Foo</code>) whose <code>.prototype</code> property will automatically be consulted.</p>

<p>We <em>just need</em> two <strong>objects</strong> to inspect a relationship between them. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// Simply: does `b` appear anywhere in</span>
<span class="pl-c">// `c`s [[Prototype]] chain?</span>
b.isPrototypeOf( c );</pre></div>

<p>Notice, this approach doesn't require a function ("class") at all. It just uses object references directly to <code>b</code> and <code>c</code>, and inquires about their relationship. In other words, our <code>isRelatedTo(..)</code> utility above is built-in to the language, and it's called <code>isPrototypeOf(..)</code>.</p>

<p>We can also directly retrieve the <code>[[Prototype]]</code> of an object. As of ES5, the standard way to do this is:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">Object</span>.getPrototypeOf( a );</pre></div>

<p>And you'll notice that object reference is what we'd expect:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">Object</span>.getPrototypeOf( a ) <span class="pl-k">===</span> Foo.<span class="pl-c1">prototype</span>; <span class="pl-c">// true</span></pre></div>

<p>Most browsers (not all!) have also long supported a non-standard alternate way of accessing the internal <code>[[Prototype]]</code>:</p>

<div class="highlight highlight-js"><pre>a.__proto__ <span class="pl-k">===</span> Foo.<span class="pl-c1">prototype</span>; <span class="pl-c">// true</span></pre></div>

<p>The strange <code>.__proto__</code> (not standardized until ES6!) property "magically" retrieves the internal <code>[[Prototype]]</code> of an object as a reference, which is quite helpful if you want to directly inspect (or even traverse: <code>.__proto__.__proto__...</code>) the chain.</p>

<p>Just as we saw earlier with <code>.constructor</code>, <code>.__proto__</code> doesn't actually exist on the object you're inspecting (<code>a</code> in our running example). In fact, it exists (non-enumerable; see Chapter 2) on the built-in <code>Object.prototype</code>, along with the other common utilities (<code>.toString()</code>, <code>.isPrototypeOf(..)</code>, etc).</p>

<p>Moreover, <code>.__proto__</code> looks like a property, but it's actually more appropriate to think of it as a getter/setter (see Chapter 3).</p>

<p>Roughly, we could envision <code>.__proto__</code> implemented (see Chapter 3 for object property definitions) like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">Object</span>.defineProperty( <span class="pl-c1">Object</span>.<span class="pl-c1">prototype</span>, <span class="pl-s"><span class="pl-pds">"</span>__proto__<span class="pl-pds">"</span></span>, {
    <span class="pl-en">get</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">Object</span>.getPrototypeOf( <span class="pl-v">this</span> );
    },
    <span class="pl-en">set</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">o</span>) {
        <span class="pl-c">// setPrototypeOf(..) as of ES6</span>
        <span class="pl-c1">Object</span>.setPrototypeOf( <span class="pl-v">this</span>, o );
        <span class="pl-k">return</span> o;
    }
} );</pre></div>

<p>So, when we access (retrieve the value of) <code>a.__proto__</code>, it's like calling <code>a.__proto__()</code> (calling the getter function). <em>That</em> function call has <code>a</code> as its <code>this</code> even though the getter function exists on the <code>Object.prototype</code> object (see Chapter 2 for <code>this</code> binding rules), so it's just like saying <code>Object.getPrototypeOf( a )</code>.</p>

<p><code>.__proto__</code> is also a settable property, just like using ES6's <code>Object.setPrototypeOf(..)</code> shown earlier. However, generally you <strong>should not change the <code>[[Prototype]]</code> of an existing object</strong>.</p>

<p>There are some very complex, advanced techniques used deep in some frameworks that allow tricks like "subclassing" an <code>Array</code>, but this is commonly frowned on in general programming practice, as it usually leads to <em>much</em> harder to understand/maintain code.</p>

<p><strong>Note:</strong> As of ES6, the <code>class</code> keyword will allow something that approximates "subclassing" of built-in's like <code>Array</code>. See Appendix A for discussion of the <code>class</code> syntax added in ES6.</p>

<p>The only other narrow exception (as mentioned earlier) would be setting the <code>[[Prototype]]</code> of a default function's <code>.prototype</code> object to reference some other object (besides <code>Object.prototype</code>). That would avoid replacing that default object entirely with a new linked object. Otherwise, <strong>it's best to treat object <code>[[Prototype]]</code> linkage as a read-only characteristic</strong> for ease of reading your code later.</p>

<p><strong>Note:</strong> The JavaScript community unofficially coined a term for the double-underscore, specifically the leading one in properties like <code>__proto__</code>: "dunder". So, the "cool kids" in JavaScript would generally pronounce <code>__proto__</code> as "dunder proto".</p>

<h2><a id="user-content-object-links" class="anchor" href="#object-links" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Links</h2>

<p>As we've now seen, the <code>[[Prototype]]</code> mechanism is an internal link that exists on one object which references some other object.</p>

<p>This linkage is (primarily) exercised when a property/method reference is made against the first object, and no such property/method exists. In that case, the <code>[[Prototype]]</code> linkage tells the engine to look for the property/method on the linked-to object. In turn, if that object cannot fulfill the look-up, its <code>[[Prototype]]</code> is followed, and so on. This series of links between objects forms what is called the "prototype chain".</p>

<h3><a id="user-content-createing-links" class="anchor" href="#createing-links" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Create()</code>ing Links</h3>

<p>We've thoroughly debunked why JavaScript's <code>[[Prototype]]</code> mechanism is <strong>not</strong> like <em>classes</em>, and we've seen how it instead creates <strong>links</strong> between proper objects.</p>

<p>What's the point of the <code>[[Prototype]]</code> mechanism? Why is it so common for JS developers to go to so much effort (emulating classes) in their code to wire up these linkages?</p>

<p>Remember we said much earlier in this chapter that <code>Object.create(..)</code> would be a hero? Now, we're ready to see how.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Tell me something good...<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( foo );

bar.something(); <span class="pl-c">// Tell me something good...</span></pre></div>

<p><code>Object.create(..)</code> creates a new object (<code>bar</code>) linked to the object we specified (<code>foo</code>), which gives us all the power (delegation) of the <code>[[Prototype]]</code> mechanism, but without any of the unnecessary complication of <code>new</code> functions acting as classes and constructor calls, confusing <code>.prototype</code> and <code>.constructor</code> references, or any of that extra stuff.</p>

<p><strong>Note:</strong> <code>Object.create(null)</code> creates an object that has an empty (aka, <code>null</code>) <code>[[Prototype]]</code> linkage, and thus the object can't delegate anywhere. Since such an object has no prototype chain, the <code>instanceof</code> operator (explained earlier) has nothing to check, so it will always return <code>false</code>. These special empty-<code>[[Prototype]]</code> objects are often called "dictionaries" as they are typically used purely for storing data in properties, mostly because they have no possible surprise effects from any delegated properties/functions on the <code>[[Prototype]]</code> chain, and are thus purely flat data storage.</p>

<p>We don't <em>need</em> classes to create meaningful relationships between two objects. The only thing we should <strong>really care about</strong> is objects linked together for delegation, and <code>Object.create(..)</code> gives us that linkage without all the class cruft.</p>

<h4><a id="user-content-objectcreate-polyfilled" class="anchor" href="#objectcreate-polyfilled" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.create()</code> Polyfilled</h4>

<p><code>Object.create(..)</code> was added in ES5. You may need to support pre-ES5 environments (like older IE's), so let's take a look at a simple <strong>partial</strong> polyfill for <code>Object.create(..)</code> that gives us the capability that we need even in those older JS environments:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Object</span>.create) {
    <span class="pl-c1">Object</span>.<span class="pl-en">create</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">o</span>) {
        <span class="pl-k">function</span> <span class="pl-en">F</span>(){}
        <span class="pl-c1">F</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> o;
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">F</span>();
    };
}</pre></div>

<p>This polyfill works by using a throw-away <code>F</code> function and overriding its <code>.prototype</code> property to point to the object we want to link to. Then we use <code>new F()</code> construction to make a new object that will be linked as we specified.</p>

<p>This usage of <code>Object.create(..)</code> is by far the most common usage, because it's the part that <em>can be</em> polyfilled. There's an additional set of functionality that the standard ES5 built-in <code>Object.create(..)</code> provides, which is <strong>not polyfillable</strong> for pre-ES5. As such, this capability is far-less commonly used. For completeness sake, let's look at that additional functionality:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject, {
    b<span class="pl-k">:</span> {
        enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        value<span class="pl-k">:</span> <span class="pl-c1">3</span>
    },
    c<span class="pl-k">:</span> {
        enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        value<span class="pl-k">:</span> <span class="pl-c1">4</span>
    }
} );

myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> ); <span class="pl-c">// false</span>
myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
myObject.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>

myObject.a; <span class="pl-c">// 2</span>
myObject.b; <span class="pl-c">// 3</span>
myObject.c; <span class="pl-c">// 4</span></pre></div>

<p>The second argument to <code>Object.create(..)</code> specifies property names to add to the newly created object, via declaring each new property's <em>property descriptor</em> (see Chapter 3). Because polyfilling property descriptors into pre-ES5 is not possible, this additional functionality on <code>Object.create(..)</code> also cannot be polyfilled.</p>

<p>The vast majority of usage of <code>Object.create(..)</code> uses the polyfill-safe subset of functionality, so most developers are fine with using the <strong>partial polyfill</strong> in pre-ES5 environments.</p>

<p>Some developers take a much stricter view, which is that no function should be polyfilled unless it can be <em>fully</em> polyfilled. Since <code>Object.create(..)</code> is one of those partial-polyfill'able utilities, this narrower perspective says that if you need to use any of the functionality of <code>Object.create(..)</code> in a pre-ES5 environment, instead of polyfilling, you should use a custom utility, and stay away from using the name <code>Object.create</code> entirely. You could instead define your own utility, like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">createAndLinkObject</span>(<span class="pl-smi">o</span>) {
    <span class="pl-k">function</span> <span class="pl-en">F</span>(){}
    <span class="pl-c1">F</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> o;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">F</span>();
}

<span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">2</span>
};

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> createAndLinkObject( anotherObject );

myObject.a; <span class="pl-c">// 2</span></pre></div>

<p>I do not share this strict opinion. I fully endorse the common partial-polyfill of <code>Object.create(..)</code> as shown above, and using it in your code even in pre-ES5. I'll leave it to you to make your own decision.</p>

<h3><a id="user-content-links-as-fallbacks" class="anchor" href="#links-as-fallbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Links As Fallbacks?</h3>

<p>It may be tempting to think that these links between objects <em>primarily</em> provide a sort of fallback for "missing" properties or methods. While that may be an observed outcome, I don't think it represents the right way of thinking about <code>[[Prototype]]</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool!<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject );

myObject.cool(); <span class="pl-c">// "cool!"</span></pre></div>

<p>That code will work by virtue of <code>[[Prototype]]</code>, but if you wrote it that way so that <code>anotherObject</code> was acting as a fallback <strong>just in case</strong> <code>myObject</code> couldn't handle some property/method that some developer may try to call, odds are that your software is going to be a bit more "magical" and harder to understand and maintain.</p>

<p>That's not to say there aren't cases where fallbacks are an appropriate design pattern, but it's not very common or idiomatic in JS, so if you find yourself doing so, you might want to take a step back and reconsider if that's really appropriate and sensible design.</p>

<p><strong>Note:</strong> In ES6, an advanced functionality called <code>Proxy</code> is introduced which can provide something of a "method not found" type of behavior. <code>Proxy</code> is beyond the scope of this book, but will be covered in detail in a later book in the <em>"You Don't Know JS"</em> series.</p>

<p><strong>Don't miss an important but nuanced point here.</strong></p>

<p>Designing software where you intend for a developer to, for instance, call <code>myObject.cool()</code> and have that work even though there is no <code>cool()</code> method on <code>myObject</code> introduces some "magic" into your API design that can be surprising for future developers who maintain your software.</p>

<p>You can however design your API with less "magic" to it, but still take advantage of the power of <code>[[Prototype]]</code> linkage.</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
    <span class="pl-en">cool</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool!<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> myObject <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( anotherObject );

<span class="pl-c1">myObject</span>.<span class="pl-en">doCool</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-v">this</span>.cool(); <span class="pl-c">// internal delegation!</span>
};

myObject.doCool(); <span class="pl-c">// "cool!"</span></pre></div>

<p>Here, we call <code>myObject.doCool()</code>, which is a method that <em>actually exists</em> on <code>myObject</code>, making our API design more explicit (less "magical"). <em>Internally</em>, our implementation follows the <strong>delegation design pattern</strong> (see Chapter 6), taking advantage of <code>[[Prototype]]</code> delegation to <code>anotherObject.cool()</code>.</p>

<p>In other words, delegation will tend to be less surprising/confusing if it's an internal implementation detail rather than plainly exposed in your API interface design. We will expound on <strong>delegation</strong> in great detail in the next chapter.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>When attempting a property access on an object that doesn't have that property, the object's internal <code>[[Prototype]]</code> linkage defines where the <code>[[Get]]</code> operation (see Chapter 3) should look next. This cascading linkage from object to object essentially defines a "prototype chain" (somewhat similar to a nested scope chain) of objects to traverse for property resolution.</p>

<p>All normal objects have the built-in <code>Object.prototype</code> as the top of the prototype chain (like the global scope in scope look-up), where property resolution will stop if not found anywhere prior in the chain. <code>toString()</code>, <code>valueOf()</code>, and several other common utilities exist on this <code>Object.prototype</code> object, explaining how all objects in the language are able to access them.</p>

<p>The most common way to get two objects linked to each other is using the <code>new</code> keyword with a function call, which among its four steps (see Chapter 2), it creates a new object linked to another object.</p>

<p>The "another object" that the new object is linked to happens to be the object referenced by the arbitrarily named <code>.prototype</code> property of the function called with <code>new</code>. Functions called with <code>new</code> are often called "constructors", despite the fact that they are not actually instantiating a class as <em>constructors</em> do in traditional class-oriented languages.</p>

<p>While these JavaScript mechanisms can seem to resemble "class instantiation" and "class inheritance" from traditional class-oriented languages, the key distinction is that in JavaScript, no copies are made. Rather, objects end up linked to each other via an internal <code>[[Prototype]]</code> chain.</p>

<p>For a variety of reasons, not the least of which is terminology precedent, "inheritance" (and "prototypal inheritance") and all the other OO terms just do not make sense when considering how JavaScript <em>actually</em> works (not just applied to our forced mental models).</p>

<p>Instead, "delegation" is a more appropriate term, because these relationships are not <em>copies</em> but delegation <strong>links</strong>.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-chapter-6-behavior-delegation" class="anchor" href="#chapter-6-behavior-delegation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 6: Behavior Delegation</h1>

<p>In Chapter 5, we addressed the <code>[[Prototype]]</code> mechanism  in detail, and <em>why</em> it's confusing and inappropriate (despite countless attempts for nearly two decades) to describe it as "class" or "inheritance". We trudged through not only the fairly verbose syntax (<code>.prototype</code> littering the code), but the various gotchas (like surprising <code>.constructor</code> resolution or ugly pseudo-polymorphic syntax). We explored variations of the "mixin" approach, which many people use to attempt to smooth over such rough areas.</p>

<p>It's a common reaction at this point to wonder why it has to be so complex to do something seemingly so simple. Now that we've pulled back the curtain and seen just how dirty it all gets, it's not a surprise that most JS developers never dive this deep, and instead relegate such mess to a "class" library to handle it for them.</p>

<p>I hope by now you're not content to just gloss over and leave such details to a "black box" library. Let's now dig into how we <em>could and should be</em> thinking about the object <code>[[Prototype]]</code> mechanism in JS, in a <strong>much simpler and more straightforward way</strong> than the confusion of classes.</p>

<p>As a brief review of our conclusions from Chapter 5, the <code>[[Prototype]]</code> mechanism is an internal link that exists on one object which references another object.</p>

<p>This linkage is exercised when a property/method reference is made against the first object, and no such property/method exists. In that case, the <code>[[Prototype]]</code> linkage tells the engine to look for the property/method on the linked-to object. In turn, if that object cannot fulfill the look-up, its <code>[[Prototype]]</code> is followed, and so on. This series of links between objects forms what is called the "prototype chain".</p>

<p>In other words, the actual mechanism, the essence of what's important to the functionality we can leverage in JavaScript, is <strong>all about objects being linked to other objects.</strong></p>

<p>That single observation is fundamental and critical to understanding the motivations and approaches for the rest of this chapter!</p>

<h2><a id="user-content-towards-delegation-oriented-design" class="anchor" href="#towards-delegation-oriented-design" aria-hidden="true"><span class="octicon octicon-link"></span></a>Towards Delegation-Oriented Design</h2>

<p>To properly focus our thoughts on how to use <code>[[Prototype]]</code> in the most straightforward way, we must recognize that it represents a fundamentally different design pattern from classes (see Chapter 4).</p>

<p><strong>Note:</strong> <em>Some</em> principles of class-oriented design are still very valid, so don't toss out everything you know (just most of it!). For example, <em>encapsulation</em> is quite powerful, and is compatible (though not as common) with delegation.</p>

<p>We need to try to change our thinking from the class/inheritance design pattern to the behavior delegation design pattern. If you have done most or all of your programming in your education/career thinking in classes, this may be uncomfortable or feel unnatural. You may need to try this mental exercise quite a few times to get the hang of this very different way of thinking.</p>

<p>I'm going to walk you through some theoretical exercises first, then we'll look side-by-side at a more concrete example to give you practical context for your own code.</p>

<h3><a id="user-content-class-theory" class="anchor" href="#class-theory" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class Theory</h3>

<p>Let's say we have several similar tasks ("XYZ", "ABC", etc) that we need to model in our software.</p>

<p>With classes, the way you design the scenario is: define a general parent (base) class like <code>Task</code>, defining shared behavior for all the "alike" tasks. Then, you define child classes <code>XYZ</code> and <code>ABC</code>, both of which inherit from <code>Task</code>, and each of which adds specialized behavior to handle their respective tasks.</p>

<p><strong>Importantly,</strong> the class design pattern will encourage you that to get the most out of inheritance, you will want to employ method overriding (and polymorphism), where you override the definition of some general <code>Task</code> method in your <code>XYZ</code> task, perhaps even making use of <code>super</code> to call to the base version of that method while adding more behavior to it. <strong>You'll likely find quite a few places</strong> where you can "abstract" out general behavior to the parent class and specialize (override) it in your child classes.</p>

<p>Here's some loose pseudo-code for that scenario:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">Task</span> {
    id;

    <span class="pl-c">// constructor `Task()`</span>
    <span class="pl-en">Task</span>(<span class="pl-smi">ID</span>) { id <span class="pl-k">=</span> <span class="pl-c1">ID</span>; }
    <span class="pl-en">outputTask</span>() { output( id ); }
}

<span class="pl-k">class</span> <span class="pl-en">XYZ</span> inherits Task {
    label;

    <span class="pl-c">// constructor `XYZ()`</span>
    <span class="pl-en">XYZ</span>(<span class="pl-smi">ID</span>,<span class="pl-smi">Label</span>) { <span class="pl-v">super</span>( <span class="pl-c1">ID</span> ); label <span class="pl-k">=</span> Label; }
    <span class="pl-en">outputTask</span>() { <span class="pl-v">super</span>(); output( label ); }
}

<span class="pl-k">class</span> <span class="pl-en">ABC</span> inherits Task {
    <span class="pl-c">// ...</span>
}</pre></div>

<p>Now, you can instantiate one or more <strong>copies</strong> of the <code>XYZ</code> child class, and use those instance(s) to perform task "XYZ". These instances have <strong>copies both</strong> of the general <code>Task</code> defined behavior as well as the specific <code>XYZ</code> defined behavior. Likewise, instances of the <code>ABC</code> class would have copies of the <code>Task</code> behavior and the specific <code>ABC</code> behavior. After construction, you will generally only interact with these instances (and not the classes), as the instances each have copies of all the behavior you need to do the intended task.</p>

<h3><a id="user-content-delegation-theory" class="anchor" href="#delegation-theory" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegation Theory</h3>

<p>But now let's try to think about the same problem domain, but using <em>behavior delegation</em> instead of <em>classes</em>.</p>

<p>You will first define an <strong>object</strong> (not a class, nor a <code>function</code> as most JS'rs would lead you to believe) called <code>Task</code>, and it will have concrete behavior on it that includes utility methods that various tasks can use (read: <em>delegate to</em>!). Then, for each task ("XYZ", "ABC"), you define an <strong>object</strong> to hold that task-specific data/behavior. You <strong>link</strong> your task-specific object(s) to the <code>Task</code> utility object, allowing them to delegate to it when they need to.</p>

<p>Basically, you think about performing task "XYZ" as needing behaviors from two sibling/peer objects (<code>XYZ</code> and <code>Task</code>) to accomplish it. But rather than needing to compose them together, via class copies, we can keep them in their separate objects, and we can allow <code>XYZ</code> object to <strong>delegate to</strong> <code>Task</code> when needed.</p>

<p>Here's some simple code to suggest how you accomplish that:</p>

<div class="highlight highlight-js"><pre>Task <span class="pl-k">=</span> {
    <span class="pl-en">setID</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">ID</span>) { <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-c1">ID</span>; },
    <span class="pl-en">outputID</span><span class="pl-k">:</span> <span class="pl-k">function</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.<span class="pl-c1">id</span> ); }
};

<span class="pl-c">// make `XYZ` delegate to `Task`</span>
<span class="pl-c1">XYZ</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Task );

<span class="pl-c1">XYZ</span>.<span class="pl-en">prepareTask</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">ID</span>,<span class="pl-smi">Label</span>) {
    <span class="pl-v">this</span>.setID( <span class="pl-c1">ID</span> );
    <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> Label;
};

<span class="pl-c1">XYZ</span>.<span class="pl-en">outputTaskDetails</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-v">this</span>.outputID();
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-v">this</span>.<span class="pl-c1">label</span> );
};

<span class="pl-c">// ABC = Object.create( Task );</span>
<span class="pl-c">// ABC ... = ...</span></pre></div>

<p>In this code, <code>Task</code> and <code>XYZ</code> are not classes (or functions), they're <strong>just objects</strong>. <code>XYZ</code> is set up via <code>Object.create(..)</code> to <code>[[Prototype]]</code> delegate to the <code>Task</code> object (see Chapter 5).</p>

<p>As compared to class-orientation (aka, OO -- object-oriented), I call this style of code <strong>"OLOO"</strong> (objects-linked-to-other-objects). All we <em>really</em> care about is that the <code>XYZ</code> object delegates to the <code>Task</code> object (as does the <code>ABC</code> object).</p>

<p>In JavaScript, the <code>[[Prototype]]</code> mechanism links <strong>objects</strong> to other <strong>objects</strong>. There are no abstract mechanisms like "classes", no matter how much you try to convince yourself otherwise. It's like paddling a canoe upstream: you <em>can</em> do it, but you're <em>choosing</em> to go against the natural current, so it's obviously <strong>going to be harder to get where you're going.</strong></p>

<p>Some other differences to note with <strong>OLOO style code</strong>:</p>

<ol>
<li>Both <code>id</code> and <code>label</code> data members from the previous class example are data properties directly on <code>XYZ</code> (neither is on <code>Task</code>). In general, with <code>[[Prototype]]</code> delegation involved, <strong>you want state to be on the delegators</strong> (<code>XYZ</code>, <code>ABC</code>), not on the delegate (<code>Task</code>).</li>
<li><p>With the class design pattern, we intentionally named <code>outputTask</code> the same on both parent (<code>Task</code>) and child (<code>XYZ</code>), so that we could take advantage of overriding (polymorphism). In behavior delegation, we do the opposite: <strong>we avoid if at all possible naming things the same</strong> at different levels of the <code>[[Prototype]]</code> chain (called shadowing -- see Chapter 5), because having those name collisions creates awkward/brittle syntax to disambiguate references (see Chapter 4), and we want to avoid that if we can.</p>

<p>This design pattern calls for less of general method names which are prone to overriding and instead more of descriptive method names, <em>specific</em> to the type of behavior each object is doing. <strong>This can actually create easier to understand/maintain code</strong>, because the names of methods (not only at definition location but strewn throughout other code) are more obvious (self documenting).</p></li>
<li><p><code>this.setID(ID);</code> inside of a method on the <code>XYZ</code> object first looks on <code>XYZ</code> for <code>setID(..)</code>, but since it doesn't find a method of that name on <code>XYZ</code>, <code>[[Prototype]]</code> <em>delegation</em> means it can follow the link to <code>Task</code> to look for <code>setID(..)</code>, which it of course finds. Moreover, because of implicit call-site <code>this</code> binding rules (see Chapter 2), when <code>setID(..)</code> runs, even though the method was found on <code>Task</code>, the <code>this</code> binding for that function call is <code>XYZ</code> exactly as we'd expect and want. We see the same thing with <code>this.outputID()</code> later in the code listing.</p>

<p>In other words, the general utility methods that exist on <code>Task</code> are available to us while interacting with <code>XYZ</code>, because <code>XYZ</code> can delegate to <code>Task</code>.</p></li>
</ol>

<p><strong>Behavior Delegation</strong> means: let some object (<code>XYZ</code>) provide a delegation (to <code>Task</code>) for property or method references if not found on the object (<code>XYZ</code>).</p>

<p>This is an <em>extremely powerful</em> design pattern, very distinct from the idea of parent and child classes, inheritance, polymorphism, etc. Rather than organizing the objects in your mind vertically, with Parents flowing down to Children, think of objects side-by-side, as peers, with any direction of delegation links between the objects as necessary.</p>

<p><strong>Note:</strong> Delegation is more properly used as an internal implementation detail rather than exposed directly in the API interface design. In the above example, we don't necessarily <em>intend</em> with our API design for developers to call <code>XYZ.setID()</code> (though we can, of course!). We sorta <em>hide</em> the delegation as an internal detail of our API, where <code>XYZ.prepareTask(..)</code> delegates to <code>Task.setID(..)</code>. See the "Links As Fallbacks?" discussion in Chapter 5 for more detail.</p>

<h4><a id="user-content-mutual-delegation-disallowed" class="anchor" href="#mutual-delegation-disallowed" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mutual Delegation (Disallowed)</h4>

<p>You cannot create a <em>cycle</em> where two or more objects are mutually delegated (bi-directionally) to each other. If you make <code>B</code> linked to <code>A</code>, and then try to link <code>A</code> to <code>B</code>, you will get an error.</p>

<p>It's a shame (not terribly surprising, but mildly annoying) that this is disallowed. If you made a reference to a property/method which didn't exist in either place, you'd have a infinite recursion on the <code>[[Prototype]]</code> loop. But if all references were strictly present, then <code>B</code> could delegate to <code>A</code>, and vice versa, and it <em>could</em> work. This would mean you could use either object to delegate to the other, for various tasks. There are a few niche use-cases where this might be helpful.</p>

<p>But it's disallowed because engine implementors have observed that it's more performant to check for (and reject!) the infinite circular reference once at set-time rather than needing to have the performance hit of that guard check every time you look-up a property on an object.</p>

<h4><a id="user-content-debugged" class="anchor" href="#debugged" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debugged</h4>

<p>We'll briefly cover a subtle detail that can be confusing to developers. In general, the JS specification does not control how browser developer tools should represent specific values/structures to a developer, so each browser/engine is free to interpret such things as they see fit. As such, browsers/tools <em>don't always agree</em>. Specifically, the behavior we will now examine is currently observed only in Chrome's Developer Tools.</p>

<p>Consider this traditional "class constructor" style JS code, as it would appear in the <em>console</em> of Chrome Developer Tools:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {}

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

a1; <span class="pl-c">// Foo {}</span></pre></div>

<p>Let's look at the last line of that snippet: the output of evaluating the <code>a1</code> expression, which prints <code>Foo {}</code>. If you try this same code in Firefox, you will likely see <code>Object {}</code>. Why the difference? What do these outputs mean?</p>

<p>Chrome is essentially saying "{} is an empty object that was constructed by a function with name 'Foo'". Firefox is saying "{} is an empty object of general construction from Object". The subtle difference is that Chrome is actively tracking, as an <em>internal property</em>, the name of the actual function that did the construction, whereas other browsers don't track that additional information.</p>

<p>It would be tempting to attempt to explain this with JavaScript mechanisms:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {}

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

a1.<span class="pl-c1">constructor</span>; <span class="pl-c">// Foo(){}</span>
a1.<span class="pl-c1">constructor</span>.<span class="pl-c1">name</span>; <span class="pl-c">// "Foo"</span></pre></div>

<p>So, is that how Chrome is outputting "Foo", by simply examining the object's <code>.constructor.name</code>? Confusingly, the answer is both "yes" and "no".</p>

<p>Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {}

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">constructor</span> <span class="pl-k">=</span> <span class="pl-k">function</span> <span class="pl-en">Gotcha</span>(){};

a1.<span class="pl-c1">constructor</span>; <span class="pl-c">// Gotcha(){}</span>
a1.<span class="pl-c1">constructor</span>.<span class="pl-c1">name</span>; <span class="pl-c">// "Gotcha"</span>

a1; <span class="pl-c">// Foo {}</span></pre></div>

<p>Even though we change <code>a1.constructor.name</code> to legitimately be something else ("Gotcha"), Chrome's console still uses the "Foo" name.</p>

<p>So, it would appear the answer to previous question (does it use <code>.constructor.name</code>?) is <strong>no</strong>, it must track it somewhere else, internally.</p>

<p>But, Not so fast! Let's see how this kind of behavior works with OLOO-style code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Foo <span class="pl-k">=</span> {};

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo );

a1; <span class="pl-c">// Object {}</span>

<span class="pl-c1">Object</span>.defineProperty( Foo, <span class="pl-s"><span class="pl-pds">"</span>constructor<span class="pl-pds">"</span></span>, {
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">Gotcha</span>(){}
});

a1; <span class="pl-c">// Gotcha {}</span></pre></div>

<p>Ah-ha! <strong>Gotcha!</strong> Here, Chrome's console <strong>did</strong> find and use the <code>.constructor.name</code>. Actually, while writing this book, this exact behavior was identified as a bug in Chrome, and by the time you're reading this, it may have already been fixed. So you may instead have seen the corrected <code>a1; // Object {}</code>.</p>

<p>Aside from that bug, the internal tracking (apparently only for debug output purposes) of the "constructor name" that Chrome does (shown in the earlier snippets) is an intentional Chrome-only extension of behavior beyond what the JS specification calls for.</p>

<p>If you don't use a "constructor" to make your objects, as we've discouraged with OLOO-style code here in this chapter, then you'll get objects that Chrome does <em>not</em> track an internal "constructor name" for, and such objects will correctly only be outputted as "Object {}", meaning "object generated from Object() construction".</p>

<p><strong>Don't think</strong> this represents a drawback of OLOO-style coding. When you code with OLOO and behavior delegation as your design pattern, <em>who</em> "constructed" (that is, <em>which function</em> was called with <code>new</code>?) some object is an irrelevant detail. Chrome's specific internal "constructor name" tracking is really only useful if you're fully embracing "class-style" coding, but is moot if you're instead embracing OLOO delegation.</p>

<h3><a id="user-content-mental-models-compared" class="anchor" href="#mental-models-compared" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mental Models Compared</h3>

<p>Now that you can see a difference between "class" and "delegation" design patterns, at least theoretically, let's see the implications these design patterns have on the mental models we use to reason about our code.</p>

<p>We'll examine some more theoretical ("Foo", "Bar") code, and compare both ways (OO vs. OLOO) of implementing the code. The first snippet uses the classical ("prototypal") OO style:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">who</span>) {
    <span class="pl-v">this</span>.me <span class="pl-k">=</span> who;
}
<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">identify</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>I am <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.me;
};

<span class="pl-k">function</span> <span class="pl-en">Bar</span>(<span class="pl-smi">who</span>) {
    Foo.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, who );
}
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );

<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">speak</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c1">alert</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.identify() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span> );
};

<span class="pl-k">var</span> b1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-s"><span class="pl-pds">"</span>b1<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> b2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-s"><span class="pl-pds">"</span>b2<span class="pl-pds">"</span></span> );

b1.speak();
b2.speak();</pre></div>

<p>Parent class <code>Foo</code>, inherited by child class <code>Bar</code>, which is then instantiated twice as <code>b1</code> and <code>b2</code>. What we have is <code>b1</code> delegating to <code>Bar.prototype</code> which delegates to <code>Foo.prototype</code>. This should look fairly familiar to you, at this point. Nothing too ground-breaking going on.</p>

<p>Now, let's implement <strong>the exact same functionality</strong> using <em>OLOO</em> style code:</p>

<div class="highlight highlight-js"><pre>Foo <span class="pl-k">=</span> {
    <span class="pl-en">init</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">who</span>) {
        <span class="pl-v">this</span>.me <span class="pl-k">=</span> who;
    },
    <span class="pl-en">identify</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>I am <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.me;
    }
};

Bar <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo );

<span class="pl-c1">Bar</span>.<span class="pl-en">speak</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c1">alert</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello, <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.identify() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>.<span class="pl-pds">"</span></span> );
};

<span class="pl-k">var</span> b1 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Bar );
b1.init( <span class="pl-s"><span class="pl-pds">"</span>b1<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> b2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Bar );
b2.init( <span class="pl-s"><span class="pl-pds">"</span>b2<span class="pl-pds">"</span></span> );

b1.speak();
b2.speak();</pre></div>

<p>We take exactly the same advantage of <code>[[Prototype]]</code> delegation from <code>b1</code> to <code>Bar</code> to <code>Foo</code> as we did in the previous snippet between <code>b1</code>, <code>Bar.prototype</code>, and <code>Foo.prototype</code>. <strong>We still have the same 3 objects linked together</strong>.</p>

<p>But, importantly, we've greatly simplified <em>all the other stuff</em> going on, because now we just set up <strong>objects</strong> linked to each other, without needing all the cruft and confusion of things that look (but don't behave!) like classes, with constructors and prototypes and <code>new</code> calls.</p>

<p>Ask yourself: if I can get the same functionality with OLOO style code as I do with "class" style code, but OLOO is simpler and has less things to think about, <strong>isn't OLOO better</strong>?</p>

<p>Let's examine the mental models involved between these two snippets.</p>

<p>First, the class-style code snippet implies this mental model of entities and their relationships:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig4.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig4.png" style="max-width:100%;"></a></p>

<p>Actually, that's a little unfair/misleading, because it's showing a lot of extra detail that you don't <em>technically</em> need to know at all times (though you <em>do</em> need to understand it!). One take-away is that it's quite a complex series of relationships. But another take-away: if you spend the time to follow those relationship arrows around, <strong>there's an amazing amount of internal consistency</strong> in JS's mechanisms.</p>

<p>For instance, the ability of a JS function to access <code>call(..)</code>, <code>apply(..)</code>, and <code>bind(..)</code> (see Chapter 2) is because functions themselves are objects, and function-objects also have a <code>[[Prototype]]</code> linkage, to the <code>Function.prototype</code> object, which defines those default methods that any function-object can delegate to. JS can do those things, <em>and you can too!</em>.</p>

<p>OK, let's now look at a <em>slightly</em> simplified version of that diagram which is a little more "fair" for comparison -- it shows only the <em>relevant</em> entities and relationships.</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig5.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig5.png" style="max-width:100%;"></a></p>

<p>Still pretty complex, eh? The dotted lines are depicting the implied relationships when you setup the "inheritance" between <code>Foo.prototype</code> and <code>Bar.prototype</code> and haven't yet <em>fixed</em> the <strong>missing</strong> <code>.constructor</code> property reference (see "Constructor Redux" in Chapter 5). Even with those dotted lines removed, the mental model is still an awful lot to juggle every time you work with object linkages.</p>

<p>Now, let's look at the mental model for OLOO-style code:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/this &amp; object prototypes/fig6.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/this &amp; object prototypes/fig6.png" style="max-width:100%;"></a></p>

<p>As you can see comparing them, it's quite obvious that OLOO-style code has <em>vastly less stuff</em> to worry about, because OLOO-style code embraces the <strong>fact</strong> that the only thing we ever really cared about was the <strong>objects linked to other objects</strong>.</p>

<p>All the other "class" cruft was a confusing and complex way of getting the same end result. Remove that stuff, and things get much simpler (without losing any capability).</p>

<h2><a id="user-content-classes-vs-objects" class="anchor" href="#classes-vs-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Classes vs. Objects</h2>

<p>We've just seen various theoretical explorations and mental models of "classes" vs. "behavior delegation". But, let's now look at more concrete code scenarios to show how'd you actually use these ideas.</p>

<p>We'll first examine a typical scenario in front-end web dev: creating UI widgets (buttons, drop-downs, etc).</p>

<h3><a id="user-content-widget-classes" class="anchor" href="#widget-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Widget "Classes"</h3>

<p>Because you're probably still so used to the OO design pattern, you'll likely immediately think of this problem domain in terms of a parent class (perhaps called <code>Widget</code>) with all the common base widget behavior, and then child derived classes for specific widget types (like <code>Button</code>).</p>

<p><strong>Note:</strong> We're going to use jQuery here for DOM and CSS manipulation, only because it's a detail we don't really care about for the purposes of our current discussion. None of this code cares which JS framework (jQuery, Dojo, YUI, etc), if any, you might solve such mundane tasks with.</p>

<p>Let's examine how we'd implement the "class" design in classic-style pure JS without any "class" helper library or syntax:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// Parent class</span>
<span class="pl-k">function</span> <span class="pl-en">Widget</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">=</span> width <span class="pl-k">||</span> <span class="pl-c1">50</span>;
    <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">=</span> height <span class="pl-k">||</span> <span class="pl-c1">50</span>;
    <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> <span class="pl-c1">null</span>;
}

<span class="pl-c1">Widget</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">$where</span>){
    <span class="pl-k">if</span> (<span class="pl-v">this</span>.$elem) {
        <span class="pl-v">this</span>.$elem.css( {
            width<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>,
            height<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>
        } ).appendTo( $where );
    }
};

<span class="pl-c">// Child class</span>
<span class="pl-k">function</span> <span class="pl-en">Button</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>,<span class="pl-smi">label</span>) {
    <span class="pl-c">// "super" constructor call</span>
    Widget.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, width, height );
    <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> label <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">"</span>Default<span class="pl-pds">"</span></span>;

    <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> $( <span class="pl-s"><span class="pl-pds">"</span>&lt;button&gt;<span class="pl-pds">"</span></span> ).<span class="pl-c1">text</span>( <span class="pl-v">this</span>.<span class="pl-c1">label</span> );
}

<span class="pl-c">// make `Button` "inherit" from `Widget`</span>
<span class="pl-c1">Button</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Widget.<span class="pl-c1">prototype</span> );

<span class="pl-c">// override base "inherited" `render(..)`</span>
<span class="pl-c1">Button</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">$where</span>) {
    <span class="pl-c">// "super" call</span>
    Widget.<span class="pl-c1">prototype</span>.render.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, $where );
    <span class="pl-v">this</span>.$elem.<span class="pl-c1">click</span>( <span class="pl-v">this</span>.onClick.bind( <span class="pl-v">this</span> ) );
};

<span class="pl-c1">Button</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">onClick</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">evt</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Button '<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>' clicked!<span class="pl-pds">"</span></span> );
};

$( <span class="pl-c1">document</span> ).ready( <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> $body <span class="pl-k">=</span> $( <span class="pl-c1">document</span>.<span class="pl-c1">body</span> );
    <span class="pl-k">var</span> btn1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Button</span>( <span class="pl-c1">125</span>, <span class="pl-c1">30</span>, <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> btn2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Button</span>( <span class="pl-c1">150</span>, <span class="pl-c1">40</span>, <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> );

    btn1.render( $body );
    btn2.render( $body );
} );</pre></div>

<p>OO design patterns tell us to declare a base <code>render(..)</code> in the parent class, then override it in our child class, but not to replace it per se, rather to augment the base functionality with button-specific behavior.</p>

<p>Notice the ugliness of <em>explicit pseudo-polymorphism</em> (see Chapter 4) with <code>Widget.call</code> and <code>Widget.prototype.render.call</code> references for faking "super" calls from the child "class" methods back up to the "parent" class base methods. Yuck.</p>

<h4><a id="user-content-es6-class-sugar" class="anchor" href="#es6-class-sugar" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES6 <code>class</code> sugar</h4>

<p>We cover ES6 <code>class</code> syntax sugar in detail in Appendix A, but let's briefly demonstrate how we'd implement the same code using <code>class</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">Widget</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>) {
        <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">=</span> width <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">=</span> height <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-en">render</span>(<span class="pl-smi">$where</span>){
        <span class="pl-k">if</span> (<span class="pl-v">this</span>.$elem) {
            <span class="pl-v">this</span>.$elem.css( {
                width<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>,
                height<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>
            } ).appendTo( $where );
        }
    }
}

<span class="pl-k">class</span> <span class="pl-en">Button</span> <span class="pl-k">extends</span> <span class="pl-en">Widget</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>,<span class="pl-smi">label</span>) {
        <span class="pl-v">super</span>( width, height );
        <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> label <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">"</span>Default<span class="pl-pds">"</span></span>;
        <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> $( <span class="pl-s"><span class="pl-pds">"</span>&lt;button&gt;<span class="pl-pds">"</span></span> ).<span class="pl-c1">text</span>( <span class="pl-v">this</span>.<span class="pl-c1">label</span> );
    }
    <span class="pl-en">render</span>(<span class="pl-smi">$where</span>) {
        <span class="pl-v">super</span>( $where );
        <span class="pl-v">this</span>.$elem.<span class="pl-c1">click</span>( <span class="pl-v">this</span>.onClick.bind( <span class="pl-v">this</span> ) );
    }
    <span class="pl-en">onClick</span>(<span class="pl-smi">evt</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Button '<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>' clicked!<span class="pl-pds">"</span></span> );
    }
}

$( <span class="pl-c1">document</span> ).ready( <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> $body <span class="pl-k">=</span> $( <span class="pl-c1">document</span>.<span class="pl-c1">body</span> );
    <span class="pl-k">var</span> btn1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Button</span>( <span class="pl-c1">125</span>, <span class="pl-c1">30</span>, <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> btn2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Button</span>( <span class="pl-c1">150</span>, <span class="pl-c1">40</span>, <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> );

    btn1.render( $body );
    btn2.render( $body );
} );</pre></div>

<p>Undoubtedly, a number of the syntax uglies of the previous classical approach have been smoothed over with ES6's <code>class</code>. The presence of a <code>super(..)</code> in particular seems quite nice (though when you dig into it, it's not all roses!).</p>

<p>Despite syntactic improvements, <strong>these are not <em>real</em> classes</strong>, as they still operate on top of the <code>[[Prototype]]</code> mechanism. They suffer from all the same mental-model mismatches we explored in Chapters 4, 5 and thus far in this chapter. Appendix A will expound on the ES6 <code>class</code> syntax and its implications in detail. We'll see why solving syntax hiccups doesn't substantially solve our class confusions in JS, though it makes a valiant effort masquerading as a solution!</p>

<p>Whether you use the classic prototypal syntax or the new ES6 sugar, you've still made a <em>choice</em> to model the problem domain (UI widgets) with "classes". And as the previous few chapters try to demonstrate, this <em>choice</em> in JavaScript is opting you into extra headaches and mental tax.</p>

<h3><a id="user-content-delegating-widget-objects" class="anchor" href="#delegating-widget-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegating Widget Objects</h3>

<p>Here's our simpler <code>Widget</code> / <code>Button</code> example, using <strong>OLOO style delegation</strong>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Widget <span class="pl-k">=</span> {
    <span class="pl-en">init</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>){
        <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">=</span> width <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">=</span> height <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    },
    <span class="pl-en">insert</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">$where</span>){
        <span class="pl-k">if</span> (<span class="pl-v">this</span>.$elem) {
            <span class="pl-v">this</span>.$elem.css( {
                width<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>,
                height<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>
            } ).appendTo( $where );
        }
    }
};

<span class="pl-k">var</span> <span class="pl-c1">Button</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Widget );

<span class="pl-c1">Button</span>.<span class="pl-en">setup</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>,<span class="pl-smi">label</span>){
    <span class="pl-c">// delegated call</span>
    <span class="pl-v">this</span>.init( width, height );
    <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> label <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">"</span>Default<span class="pl-pds">"</span></span>;

    <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> $( <span class="pl-s"><span class="pl-pds">"</span>&lt;button&gt;<span class="pl-pds">"</span></span> ).<span class="pl-c1">text</span>( <span class="pl-v">this</span>.<span class="pl-c1">label</span> );
};
<span class="pl-c1">Button</span>.<span class="pl-en">build</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">$where</span>) {
    <span class="pl-c">// delegated call</span>
    <span class="pl-v">this</span>.insert( $where );
    <span class="pl-v">this</span>.$elem.<span class="pl-c1">click</span>( <span class="pl-v">this</span>.onClick.bind( <span class="pl-v">this</span> ) );
};
<span class="pl-c1">Button</span>.<span class="pl-en">onClick</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">evt</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Button '<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>' clicked!<span class="pl-pds">"</span></span> );
};

$( <span class="pl-c1">document</span> ).ready( <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> $body <span class="pl-k">=</span> $( <span class="pl-c1">document</span>.<span class="pl-c1">body</span> );

    <span class="pl-k">var</span> btn1 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( <span class="pl-c1">Button</span> );
    btn1.setup( <span class="pl-c1">125</span>, <span class="pl-c1">30</span>, <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span> );

    <span class="pl-k">var</span> btn2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( <span class="pl-c1">Button</span> );
    btn2.setup( <span class="pl-c1">150</span>, <span class="pl-c1">40</span>, <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> );

    btn1.build( $body );
    btn2.build( $body );
} );</pre></div>

<p>With this OLOO-style approach, we don't think of <code>Widget</code> as a parent and <code>Button</code> as a child. Rather, <code>Widget</code> <strong>is just an object</strong> and is sort of a utility collection that any specific type of widget might want to delegate to, and <code>Button</code> <strong>is also just a stand-alone object</strong> (with a delegation link to <code>Widget</code>, of course!).</p>

<p>From a design pattern perspective, we <strong>didn't</strong> share the same method name <code>render(..)</code> in both objects, the way classes suggest, but instead we chose different names (<code>insert(..)</code> and <code>build(..)</code>) that were more descriptive of what task each does specifically. The <em>initialization</em> methods are called <code>init(..)</code> and <code>setup(..)</code>, respectively, for the same reasons.</p>

<p>Not only does this delegation design pattern suggest different and more descriptive names (rather than shared and more generic names), but doing so with OLOO happens to avoid the ugliness of the explicit pseudo-polymorphic calls (<code>Widget.call</code> and <code>Widget.prototype.render.call</code>), as you can see by the simple, relative, delegated calls to <code>this.init(..)</code> and <code>this.insert(..)</code>.</p>

<p>Syntactically, we also don't have any constructors, <code>.prototype</code> or <code>new</code> present, as they are, in fact, just unnecessary cruft.</p>

<p>Now, if you're paying close attention, you may notice that what was previously just one call (<code>var btn1 = new Button(..)</code>) is now two calls (<code>var btn1 = Object.create(Button)</code> and <code>btn1.setup(..)</code>). Initially this may seem like a drawback (more code).</p>

<p>However, even this is something that's <strong>a pro of OLOO style code</strong> as compared to classical prototype style code. How?</p>

<p>With class constructors, you are "forced" (not really, but strongly suggested) to do both construction and initialization in the same step. However, there are many cases where being able to do these two steps separately (as you do with OLOO!) is more flexible.</p>

<p>For example, let's say you create all your instances in a pool at the beginning of your program, but you wait to initialize them with specific setup until they are pulled from the pool and used. We showed the two calls happening right next to each other, but of course they can happen at very different times and in very different parts of our code, as needed.</p>

<p><strong>OLOO</strong> supports <em>better</em> the principle of separation of concerns, where creation and initialization are not necessarily conflated into the same operation.</p>

<h2><a id="user-content-simpler-design" class="anchor" href="#simpler-design" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simpler Design</h2>

<p>In addition to OLOO providing ostensibly simpler (and more flexible!) code, behavior delegation as a pattern can actually lead to simpler code architecture. Let's examine one last example that illustrates how OLOO simplifies your overall design.</p>

<p>The scenario we'll examine is two controller objects, one for handling the login form of a web page, and another for actually handling the authentication (communication) with the server.</p>

<p>We'll need a utility helper for making the Ajax communication to the server. We'll use jQuery (though any framework would do fine), since it handles not only the Ajax for us, but it returns a promise-like answer so that we can listen for the response in our calling code with <code>.then(..)</code>.</p>

<p><strong>Note:</strong> We don't cover Promises here, but we will cover them in a future title of the <em>"You Don't Know JS"</em> series.</p>

<p>Following the typical class design pattern, we'll break up the task into base functionality in a class called <code>Controller</code>, and then we'll derive two child classes, <code>LoginController</code> and <code>AuthController</code>, which both inherit from <code>Controller</code> and specialize some of those base behaviors.</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// Parent class</span>
<span class="pl-k">function</span> <span class="pl-en">Controller</span>() {
    <span class="pl-v">this</span>.errors <span class="pl-k">=</span> [];
}
<span class="pl-c1">Controller</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">showDialog</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">title</span>,<span class="pl-smi">msg</span>) {
    <span class="pl-c">// display title &amp; message to user in dialog</span>
};
<span class="pl-c1">Controller</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">success</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">msg</span>) {
    <span class="pl-v">this</span>.showDialog( <span class="pl-s"><span class="pl-pds">"</span>Success<span class="pl-pds">"</span></span>, msg );
};
<span class="pl-c1">Controller</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">failure</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
    <span class="pl-v">this</span>.errors.<span class="pl-c1">push</span>( err );
    <span class="pl-v">this</span>.showDialog( <span class="pl-s"><span class="pl-pds">"</span>Error<span class="pl-pds">"</span></span>, err );
};</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-c">// Child class</span>
<span class="pl-k">function</span> <span class="pl-en">LoginController</span>() {
    Controller.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
}
<span class="pl-c">// Link child class to parent</span>
<span class="pl-c1">LoginController</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Controller.<span class="pl-c1">prototype</span> );
<span class="pl-c1">LoginController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">getUser</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>login_username<span class="pl-pds">"</span></span> ).<span class="pl-c1">value</span>;
};
<span class="pl-c1">LoginController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">getPassword</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>login_password<span class="pl-pds">"</span></span> ).<span class="pl-c1">value</span>;
};
<span class="pl-c1">LoginController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">validateEntry</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">user</span>,<span class="pl-smi">pw</span>) {
    user <span class="pl-k">=</span> user <span class="pl-k">||</span> <span class="pl-v">this</span>.getUser();
    pw <span class="pl-k">=</span> pw <span class="pl-k">||</span> <span class="pl-v">this</span>.getPassword();

    <span class="pl-k">if</span> (<span class="pl-k">!</span>(user <span class="pl-k">&amp;&amp;</span> pw)) {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.failure( <span class="pl-s"><span class="pl-pds">"</span>Please enter a username &amp; password!<span class="pl-pds">"</span></span> );
    }
    <span class="pl-k">else</span> <span class="pl-k">if</span> (pw.<span class="pl-c1">length</span> <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>) {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.failure( <span class="pl-s"><span class="pl-pds">"</span>Password must be 5+ characters!<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// got here? validated!</span>
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
};
<span class="pl-c">// Override to extend base `failure()`</span>
<span class="pl-c1">LoginController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">failure</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
    <span class="pl-c">// "super" call</span>
    Controller.<span class="pl-c1">prototype</span>.failure.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, <span class="pl-s"><span class="pl-pds">"</span>Login invalid: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> err );
};</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-c">// Child class</span>
<span class="pl-k">function</span> <span class="pl-en">AuthController</span>(<span class="pl-smi">login</span>) {
    Controller.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
    <span class="pl-c">// in addition to inheritance, we also need composition</span>
    <span class="pl-v">this</span>.login <span class="pl-k">=</span> login;
}
<span class="pl-c">// Link child class to parent</span>
<span class="pl-c1">AuthController</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Controller.<span class="pl-c1">prototype</span> );
<span class="pl-c1">AuthController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">server</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">url</span>,<span class="pl-smi">data</span>) {
    <span class="pl-k">return</span> $.ajax( {
        url<span class="pl-k">:</span> url,
        data<span class="pl-k">:</span> data
    } );
};
<span class="pl-c1">AuthController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">checkAuth</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">var</span> user <span class="pl-k">=</span> <span class="pl-v">this</span>.login.getUser();
    <span class="pl-k">var</span> pw <span class="pl-k">=</span> <span class="pl-v">this</span>.login.getPassword();

    <span class="pl-k">if</span> (<span class="pl-v">this</span>.login.validateEntry( user, pw )) {
        <span class="pl-v">this</span>.server( <span class="pl-s"><span class="pl-pds">"</span>/check-auth<span class="pl-pds">"</span></span>,{
            user<span class="pl-k">:</span> user,
            pw<span class="pl-k">:</span> pw
        } )
        .then( <span class="pl-v">this</span>.success.bind( <span class="pl-v">this</span> ) )
        .fail( <span class="pl-v">this</span>.failure.bind( <span class="pl-v">this</span> ) );
    }
};
<span class="pl-c">// Override to extend base `success()`</span>
<span class="pl-c1">AuthController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">success</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c">// "super" call</span>
    Controller.<span class="pl-c1">prototype</span>.success.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, <span class="pl-s"><span class="pl-pds">"</span>Authenticated!<span class="pl-pds">"</span></span> );
};
<span class="pl-c">// Override to extend base `failure()`</span>
<span class="pl-c1">AuthController</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">failure</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
    <span class="pl-c">// "super" call</span>
    Controller.<span class="pl-c1">prototype</span>.failure.<span class="pl-c1">call</span>( <span class="pl-v">this</span>, <span class="pl-s"><span class="pl-pds">"</span>Auth Failed: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> err );
};</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> auth <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">AuthController</span>(
    <span class="pl-c">// in addition to inheritance, we also need composition</span>
    <span class="pl-k">new</span> <span class="pl-en">LoginController</span>()
);
auth.checkAuth();</pre></div>

<p>We have base behaviors that all controllers share, which are <code>success(..)</code>, <code>failure(..)</code> and <code>showDialog(..)</code>. Our child classes <code>LoginController</code> and <code>AuthController</code> override <code>failure(..)</code> and <code>success(..)</code> to augment the default base class behavior. Also note that <code>AuthController</code> needs an instance of <code>LoginController</code> to interact with the login form, so that becomes a member data property.</p>

<p>The other thing to mention is that we chose some <em>composition</em> to sprinkle in on top of the inheritance. <code>AuthController</code> needs to know about <code>LoginController</code>, so we instantiate it (<code>new LoginController()</code>) and keep a class member property called <code>this.login</code> to reference it, so that <code>AuthController</code> can invoke behavior on <code>LoginController</code>.</p>

<p><strong>Note:</strong> There <em>might</em> have been a slight temptation to make <code>AuthController</code> inherit from <code>LoginController</code>, or vice versa, such that we had <em>virtual composition</em> through the inheritance chain. But this is a strongly clear example of what's wrong with class inheritance as <em>the</em> model for the problem domain, because neither <code>AuthController</code> nor <code>LoginController</code> are specializing base behavior of the other, so inheritance between them makes little sense except if classes are your only design pattern. Instead, we layered in some simple <em>composition</em> and now they can cooperate, while still both benefiting from the inheritance from the parent base <code>Controller</code>.</p>

<p>If you're familiar with class-oriented (OO) design, this should all look pretty familiar and natural.</p>

<h3><a id="user-content-de-class-ified" class="anchor" href="#de-class-ified" aria-hidden="true"><span class="octicon octicon-link"></span></a>De-class-ified</h3>

<p>But, <strong>do we really need to model this problem</strong> with a parent <code>Controller</code> class, two child classes, <strong>and some composition</strong>? Is there a way to take advantage of OLOO-style behavior delegation and have a <em>much</em> simpler design? <strong>Yes!</strong></p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> LoginController <span class="pl-k">=</span> {
    errors<span class="pl-k">:</span> [],
    <span class="pl-en">getUser</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>login_username<span class="pl-pds">"</span></span> ).<span class="pl-c1">value</span>;
    },
    <span class="pl-en">getPassword</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-k">return</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>( <span class="pl-s"><span class="pl-pds">"</span>login_password<span class="pl-pds">"</span></span> ).<span class="pl-c1">value</span>;
    },
    <span class="pl-en">validateEntry</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">user</span>,<span class="pl-smi">pw</span>) {
        user <span class="pl-k">=</span> user <span class="pl-k">||</span> <span class="pl-v">this</span>.getUser();
        pw <span class="pl-k">=</span> pw <span class="pl-k">||</span> <span class="pl-v">this</span>.getPassword();

        <span class="pl-k">if</span> (<span class="pl-k">!</span>(user <span class="pl-k">&amp;&amp;</span> pw)) {
            <span class="pl-k">return</span> <span class="pl-v">this</span>.failure( <span class="pl-s"><span class="pl-pds">"</span>Please enter a username &amp; password!<span class="pl-pds">"</span></span> );
        }
        <span class="pl-k">else</span> <span class="pl-k">if</span> (pw.<span class="pl-c1">length</span> <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>) {
            <span class="pl-k">return</span> <span class="pl-v">this</span>.failure( <span class="pl-s"><span class="pl-pds">"</span>Password must be 5+ characters!<span class="pl-pds">"</span></span> );
        }

        <span class="pl-c">// got here? validated!</span>
        <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    },
    <span class="pl-en">showDialog</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">title</span>,<span class="pl-smi">msg</span>) {
        <span class="pl-c">// display success message to user in dialog</span>
    },
    <span class="pl-en">failure</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-v">this</span>.errors.<span class="pl-c1">push</span>( err );
        <span class="pl-v">this</span>.showDialog( <span class="pl-s"><span class="pl-pds">"</span>Error<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Login invalid: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> err );
    }
};</pre></div>

<div class="highlight highlight-js"><pre><span class="pl-c">// Link `AuthController` to delegate to `LoginController`</span>
<span class="pl-k">var</span> AuthController <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( LoginController );

AuthController.errors <span class="pl-k">=</span> [];
<span class="pl-c1">AuthController</span>.<span class="pl-en">checkAuth</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">var</span> user <span class="pl-k">=</span> <span class="pl-v">this</span>.getUser();
    <span class="pl-k">var</span> pw <span class="pl-k">=</span> <span class="pl-v">this</span>.getPassword();

    <span class="pl-k">if</span> (<span class="pl-v">this</span>.validateEntry( user, pw )) {
        <span class="pl-v">this</span>.server( <span class="pl-s"><span class="pl-pds">"</span>/check-auth<span class="pl-pds">"</span></span>,{
            user<span class="pl-k">:</span> user,
            pw<span class="pl-k">:</span> pw
        } )
        .then( <span class="pl-v">this</span>.accepted.bind( <span class="pl-v">this</span> ) )
        .fail( <span class="pl-v">this</span>.rejected.bind( <span class="pl-v">this</span> ) );
    }
};
<span class="pl-c1">AuthController</span>.<span class="pl-en">server</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">url</span>,<span class="pl-smi">data</span>) {
    <span class="pl-k">return</span> $.ajax( {
        url<span class="pl-k">:</span> url,
        data<span class="pl-k">:</span> data
    } );
};
<span class="pl-c1">AuthController</span>.<span class="pl-en">accepted</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-v">this</span>.showDialog( <span class="pl-s"><span class="pl-pds">"</span>Success<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Authenticated!<span class="pl-pds">"</span></span> )
};
<span class="pl-c1">AuthController</span>.<span class="pl-en">rejected</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
    <span class="pl-v">this</span>.failure( <span class="pl-s"><span class="pl-pds">"</span>Auth Failed: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> err );
};</pre></div>

<p>Since <code>AuthController</code> is just an object (so is <code>LoginController</code>), we don't need to instantiate (like <code>new AuthController()</code>) to perform our task. All we need to do is:</p>

<div class="highlight highlight-js"><pre>AuthController.checkAuth();</pre></div>

<p>Of course, with OLOO, if you do need to create one or more additional objects in the delegation chain, that's easy, and still doesn't require anything like class instantiation:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> controller1 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( AuthController );
<span class="pl-k">var</span> controller2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( AuthController );</pre></div>

<p>With behavior delegation, <code>AuthController</code> and <code>LoginController</code> are <strong>just objects</strong>, <em>horizontal</em> peers of each other, and are not arranged or related as parents and children in class-orientation. We somewhat arbitrarily chose to have <code>AuthController</code> delegate to <code>LoginController</code> -- it would have been just as valid for the delegation to go the reverse direction.</p>

<p>The main takeaway from this second code listing is that we only have two entities (<code>LoginController</code> and <code>AuthController</code>), <strong>not three</strong> as before.</p>

<p>We didn't need a base <code>Controller</code> class to "share" behavior between the two, because delegation is a powerful enough mechanism to give us the functionality we need. We also, as noted before, don't need to instantiate our classes to work with them, because there are no classes, <strong>just the objects themselves.</strong> Furthermore, there's no need for <em>composition</em> as delegation gives the two objects the ability to cooperate <em>differentially</em> as needed.</p>

<p>Lastly, we avoided the polymorphism pitfalls of class-oriented design by not having the names <code>success(..)</code> and <code>failure(..)</code> be the same on both objects, which would have required ugly explicit pseudopolymorphism. Instead, we called them <code>accepted()</code> and <code>rejected(..)</code> on <code>AuthController</code> -- slightly more descriptive names for their specific tasks.</p>

<p><strong>Bottom line</strong>: we end up with the same capability, but a (significantly) simpler design. That's the power of OLOO-style code and the power of the <em>behavior delegation</em> design pattern.</p>

<h2><a id="user-content-nicer-syntax" class="anchor" href="#nicer-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nicer Syntax</h2>

<p>One of the nicer things that makes ES6's <code>class</code> so deceptively attractive (see Appendix A on why to avoid it!) is the short-hand syntax for declaring class methods:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">methodName</span>() { <span class="pl-c">/* .. */</span> }
}</pre></div>

<p>We get to drop the word <code>function</code> from the declaration, which makes JS developers everywhere cheer!</p>

<p>And you may have noticed and been frustrated that the suggested OLOO syntax above has lots of <code>function</code> appearances, which seems like a bit of a detractor to the goal of OLOO simplification. <strong>But it doesn't have to be that way!</strong></p>

<p>As of ES6, we can use <em>concise method declarations</em> in any object literal, so an object in OLOO style can be declared this way (same short-hand sugar as with <code>class</code> body syntax):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> LoginController <span class="pl-k">=</span> {
    errors<span class="pl-k">:</span> [],
    <span class="pl-en">getUser</span>() { <span class="pl-c">// Look ma, no `function`!</span>
        <span class="pl-c">// ...</span>
    },
    <span class="pl-en">getPassword</span>() {
        <span class="pl-c">// ...</span>
    }
    <span class="pl-c">// ...</span>
};</pre></div>

<p>About the only difference is that object literals will still require <code>,</code> comma separators between elements whereas <code>class</code> syntax doesn't. Pretty minor concession in the whole scheme of things.</p>

<p>Moreover, as of ES6, the clunkier syntax you use (like for the <code>AuthController</code> definition), where you're assigning properties individually and not using an object literal, can be re-written using an object literal (so that you can use concise methods), and you can just modify that object's <code>[[Prototype]]</code> with <code>Object.setPrototypeOf(..)</code>, like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// use nicer object literal syntax w/ concise methods!</span>
<span class="pl-k">var</span> AuthController <span class="pl-k">=</span> {
    errors<span class="pl-k">:</span> [],
    <span class="pl-en">checkAuth</span>() {
        <span class="pl-c">// ...</span>
    },
    <span class="pl-en">server</span>(<span class="pl-smi">url</span>,<span class="pl-smi">data</span>) {
        <span class="pl-c">// ...</span>
    }
    <span class="pl-c">// ...</span>
};

<span class="pl-c">// NOW, link `AuthController` to delegate to `LoginController`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( AuthController, LoginController );</pre></div>

<p>OLOO-style as of ES6, with concise methods, <strong>is a lot friendlier</strong> than it was before (and even then, it was much simpler and nicer than classical prototype-style code). <strong>You don't have to opt for class</strong> (complexity) to get nice clean object syntax!</p>

<h3><a id="user-content-unlexical" class="anchor" href="#unlexical" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unlexical</h3>

<p>There <em>is</em> one drawback to concise methods that's subtle but important to note. Consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Foo <span class="pl-k">=</span> {
    <span class="pl-en">bar</span>() { <span class="pl-c">/*..*/</span> },
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { <span class="pl-c">/*..*/</span> }
};</pre></div>

<p>Here's the syntactic de-sugaring that expresses how that code will operate:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Foo <span class="pl-k">=</span> {
    <span class="pl-en">bar</span><span class="pl-k">:</span> <span class="pl-k">function</span>() { <span class="pl-c">/*..*/</span> },
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { <span class="pl-c">/*..*/</span> }
};</pre></div>

<p>See the difference? The <code>bar()</code> short-hand became an <em>anonymous function expression</em> (<code>function()..</code>) attached to the <code>bar</code> property, because the function object itself has no name identifier. Compare that to the manually specified <em>named function expression</em> (<code>function baz()..</code>) which has a lexical name identifier <code>baz</code> in addition to being attached to a <code>.baz</code> property.</p>

<p>So what? In the <em>"Scope &amp; Closures"</em> title of this <em>"You Don't Know JS"</em> book series, we cover the three main downsides of <em>anonymous function expressions</em> in detail. We'll just briefly repeat them so we can compare to the concise method short-hand.</p>

<p>Lack of a <code>name</code> identifier on an anonymous function:</p>

<ol>
<li>makes debugging stack traces harder</li>
<li>makes self-referencing (recursion, event (un)binding, etc) harder</li>
<li>makes code (a little bit) harder to understand</li>
</ol>

<p>Items 1 and 3 don't apply to concise methods.</p>

<p>Even though the de-sugaring uses an <em>anonymous function expression</em> which normally would have no <code>name</code> in stack traces, concise methods are specified to set the internal <code>name</code> property of the function object accordingly, so stack traces should be able to use it (though that's implementation dependent so not guaranteed).</p>

<p>Item 2 is, unfortunately, <strong>still a drawback to concise methods</strong>. They will not have a lexical identifier to use as a self-reference. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Foo <span class="pl-k">=</span> {
    <span class="pl-en">bar</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>) {
            <span class="pl-k">return</span> Foo.bar( x <span class="pl-k">*</span> <span class="pl-c1">2</span> );
        }
        <span class="pl-k">return</span> x;
    },
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>) {
            <span class="pl-k">return</span> baz( x <span class="pl-k">*</span> <span class="pl-c1">2</span> );
        }
        <span class="pl-k">return</span> x;
    }
};</pre></div>

<p>The manual <code>Foo.bar(x*2)</code> reference above kind of suffices in this example, but there are many cases where a function wouldn't necessarily be able to do that, such as cases where the function is being shared in delegation across different objects, using <code>this</code> binding, etc. You would want to use a real self-reference, and the function object's <code>name</code> identifier is the best way to accomplish that.</p>

<p>Just be aware of this caveat for concise methods, and if you run into such issues with lack of self-reference, make sure to forgo the concise method syntax <strong>just for that declaration</strong> in favor of the manual <em>named function expression</em> declaration form: <code>baz: function baz(){..}</code>.</p>

<h2><a id="user-content-introspection" class="anchor" href="#introspection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introspection</h2>

<p>If you've spent much time with class oriented programming (either in JS or other languages), you're probably familiar with <em>type introspection</em>: inspecting an instance to find out what <em>kind</em> of object it is. The primary goal of <em>type introspection</em> with class instances is to reason about the structure/capabilities of the object based on <em>how it was created</em>.</p>

<p>Consider this code which uses <code>instanceof</code> (see Chapter 5) for introspecting on an object <code>a1</code> to infer its capability:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-c">// ...</span>
}
<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">something</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-c">// ...</span>
}

<span class="pl-k">var</span> a1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

<span class="pl-c">// later</span>

<span class="pl-k">if</span> (a1 <span class="pl-k">instanceof</span> Foo) {
    a1.something();
}</pre></div>

<p>Because <code>Foo.prototype</code> (not <code>Foo</code>!) is in the <code>[[Prototype]]</code> chain (see Chapter 5) of <code>a1</code>, the <code>instanceof</code> operator (confusingly) pretends to tell us that <code>a1</code> is an instance of the <code>Foo</code> "class". With this knowledge, we then assume that <code>a1</code> has the capabilities described by the <code>Foo</code> "class".</p>

<p>Of course, there is no <code>Foo</code> class, only a plain old normal function <code>Foo</code>, which happens to have a reference to an arbitrary object (<code>Foo.prototype</code>) that <code>a1</code> happens to be delegation-linked to. By its syntax, <code>instanceof</code> pretends to be inspecting the relationship between <code>a1</code> and <code>Foo</code>, but it's actually telling us whether <code>a1</code> and (the arbitrary object referenced by) <code>Foo.prototype</code> are related.</p>

<p>The semantic confusion (and indirection) of <code>instanceof</code> syntax  means that to use <code>instanceof</code>-based introspection to ask if object <code>a1</code> is related to the capabilities object in question, you <em>have to</em> have a function that holds a reference to that object -- you can't just directly ask if the two objects are related.</p>

<p>Recall the abstract <code>Foo</code> / <code>Bar</code> / <code>b1</code> example from earlier in this chapter, which we'll abbreviate here:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() { <span class="pl-c">/* .. */</span> }
Foo.<span class="pl-c1">prototype</span>...

<span class="pl-k">function</span> <span class="pl-en">Bar</span>() { <span class="pl-c">/* .. */</span> }
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );

<span class="pl-k">var</span> b1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-s"><span class="pl-pds">"</span>b1<span class="pl-pds">"</span></span> );</pre></div>

<p>For <em>type introspection</em> purposes on the entities in that example, using <code>instanceof</code> and <code>.prototype</code> semantics, here are the various checks you might need to perform:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// relating `Foo` and `Bar` to each other</span>
Bar.<span class="pl-c1">prototype</span> <span class="pl-k">instanceof</span> Foo; <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.getPrototypeOf( Bar.<span class="pl-c1">prototype</span> ) <span class="pl-k">===</span> Foo.<span class="pl-c1">prototype</span>; <span class="pl-c">// true</span>
Foo.<span class="pl-c1">prototype</span>.isPrototypeOf( Bar.<span class="pl-c1">prototype</span> ); <span class="pl-c">// true</span>

<span class="pl-c">// relating `b1` to both `Foo` and `Bar`</span>
b1 <span class="pl-k">instanceof</span> Foo; <span class="pl-c">// true</span>
b1 <span class="pl-k">instanceof</span> Bar; <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.getPrototypeOf( b1 ) <span class="pl-k">===</span> Bar.<span class="pl-c1">prototype</span>; <span class="pl-c">// true</span>
Foo.<span class="pl-c1">prototype</span>.isPrototypeOf( b1 ); <span class="pl-c">// true</span>
Bar.<span class="pl-c1">prototype</span>.isPrototypeOf( b1 ); <span class="pl-c">// true</span></pre></div>

<p>It's fair to say that some of that kinda sucks. For instance, intuitively (with classes) you might want to be able to say something like <code>Bar instanceof Foo</code> (because it's easy to mix up what "instance" means to think it includes "inheritance"), but that's not a sensible comparison in JS. You have to do <code>Bar.prototype instanceof Foo</code> instead.</p>

<p>Another common, but perhaps less robust, pattern for <em>type introspection</em>, which many devs seem to prefer over <code>instanceof</code>, is called "duck typing". This term comes from the adage, "if it looks like a duck, and it quacks like a duck, it must be a duck".</p>

<p>Example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (a1.something) {
    a1.something();
}</pre></div>

<p>Rather than inspecting for a relationship between <code>a1</code> and an object that holds the delegatable <code>something()</code> function, we assume that the test for <code>a1.something</code> passing means <code>a1</code> has the capability to call <code>.something()</code> (regardless of if it found the method directly on <code>a1</code> or delegated to some other object). In and of itself, that assumption isn't so risky.</p>

<p>But "duck typing" is often extended to make <strong>other assumptions about the object's capabilities</strong> besides what's being tested, which of course introduces more risk (aka, brittle design) into the test.</p>

<p>One notable example of "duck typing" comes with ES6 Promises (which as an earlier note explained are not being covered in this book).</p>

<p>For various reasons, there's a need to determine if any arbitrary object reference <em>is a Promise</em>, but the way that test is done is to check if the object happens to have a <code>then()</code> function present on it. In other words, <strong>if any object</strong> happens to have a <code>then()</code> method, ES6 Promises will assume unconditionally that the object <strong>is a "thenable"</strong> and therefore will expect it to behave conformantly to all standard behaviors of Promises.</p>

<p>If you have any non-Promise object that happens for whatever reason to have a <code>then()</code> method on it, you are strongly advised to keep it far away from the ES6 Promise mechanism to avoid broken assumptions.</p>

<p>That example clearly illustrates the perils of "duck typing". You should only use such approaches sparingly and in controlled conditions.</p>

<p>Turning our attention once again back to OLOO-style code as presented here in this chapter, <em>type introspection</em> turns out to be much cleaner. Let's recall (and abbreviate) the <code>Foo</code> / <code>Bar</code> / <code>b1</code> OLOO example from earlier in the chapter:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> Foo <span class="pl-k">=</span> { <span class="pl-c">/* .. */</span> };

<span class="pl-k">var</span> Bar <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo );
Bar...

<span class="pl-k">var</span> b1 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Bar );</pre></div>

<p>Using this OLOO approach, where all we have are plain objects that are related via <code>[[Prototype]]</code> delegation, here's the quite simplified <em>type introspection</em> we might use:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// relating `Foo` and `Bar` to each other</span>
Foo.isPrototypeOf( Bar ); <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.getPrototypeOf( Bar ) <span class="pl-k">===</span> Foo; <span class="pl-c">// true</span>

<span class="pl-c">// relating `b1` to both `Foo` and `Bar`</span>
Foo.isPrototypeOf( b1 ); <span class="pl-c">// true</span>
Bar.isPrototypeOf( b1 ); <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.getPrototypeOf( b1 ) <span class="pl-k">===</span> Bar; <span class="pl-c">// true</span></pre></div>

<p>We're not using <code>instanceof</code> anymore, because it's confusingly pretending to have something to do with classes. Now, we just ask the (informally stated) question, "are you <em>a</em> prototype of me?" There's no more indirection necessary with stuff like <code>Foo.prototype</code> or the painfully verbose <code>Foo.prototype.isPrototypeOf(..)</code>.</p>

<p>I think it's fair to say these checks are significantly less complicated/confusing than the previous set of introspection checks. <strong>Yet again, we see that OLOO is simpler than (but with all the same power of) class-style coding in JavaScript.</strong></p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p>Classes and inheritance are a design pattern you can <em>choose</em>, or <em>not choose</em>, in your software architecture. Most developers take for granted that classes are the only (proper) way to organize code, but here we've seen there's another less-commonly talked about pattern that's actually quite powerful: <strong>behavior delegation</strong>.</p>

<p>Behavior delegation suggests objects as peers of each other, which delegate amongst themselves, rather than parent and child class relationships. JavaScript's <code>[[Prototype]]</code> mechanism is, by its very designed nature, a behavior delegation mechanism. That means we can either choose to struggle to implement class mechanics on top of JS (see Chapters 4 and 5), or we can just embrace the natural state of <code>[[Prototype]]</code> as a delegation mechanism.</p>

<p>When you design code with objects only, not only does it simplify the syntax you use, but it can actually lead to simpler code architecture design.</p>

<p><strong>OLOO</strong> (objects-linked-to-other-objects) is a code style which creates and relates objects directly without the abstraction of classes. OLOO quite naturally implements <code>[[Prototype]]</code>-based behavior delegation.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-this--object-prototypes" class="anchor" href="#you-dont-know-js-this--object-prototypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: <em>this</em> &amp; Object Prototypes</h1>

<h1><a id="user-content-appendix-a-es6-class" class="anchor" href="#appendix-a-es6-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix A: ES6 <code>class</code></h1>

<p>If there's any take-away message from the second half of this book (Chapters 4-6), it's that classes are an optional design pattern for code (not a necessary given), and that furthermore they are often quite awkward to implement in a <code>[[Prototype]]</code> language like JavaScript.</p>

<p>This awkwardness is <em>not</em> just about syntax, although that's a big part of it. Chapters 4 and 5 examined quite a bit of syntactic ugliness, from verbosity of <code>.prototype</code> references cluttering the code, to <em>explicit pseudo-polymorphism</em> (see Chapter 4) when you give methods the same name at different levels of the chain and try to implement a polymorphic reference from a lower-level method to a higher-level method. <code>.constructor</code> being wrongly interpreted as "was constructed by" and yet being unreliable for that definition is yet another syntactic ugly.</p>

<p>But the problems with class design are much deeper. Chapter 4 points out that classes in traditional class-oriented languages actually produce a <em>copy</em> action from parent to child to instance, whereas in <code>[[Prototype]]</code>, the action is <strong>not</strong> a copy, but rather the opposite -- a delegation link.</p>

<p>When compared to the simplicity of OLOO-style code and behavior delegation (see Chapter 6), which embrace <code>[[Prototype]]</code> rather than hide from it, classes stand out as a sore thumb in JS.</p>

<h2><a id="user-content-class" class="anchor" href="#class" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>class</code></h2>

<p>But we <em>don't</em> need to re-argue that case again. I re-mention those issues briefly only so that you keep them fresh in your mind now that we turn our attention to the ES6 <code>class</code> mechanism. We'll demonstrate here how it works, and look at whether or not <code>class</code> does anything substantial to address any of those "class" concerns.</p>

<p>Let's revisit the <code>Widget</code> / <code>Button</code> example from Chapter 6:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">Widget</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>) {
        <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">=</span> width <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">=</span> height <span class="pl-k">||</span> <span class="pl-c1">50</span>;
        <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> <span class="pl-c1">null</span>;
    }
    <span class="pl-en">render</span>(<span class="pl-smi">$where</span>){
        <span class="pl-k">if</span> (<span class="pl-v">this</span>.$elem) {
            <span class="pl-v">this</span>.$elem.css( {
                width<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">width</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>,
                height<span class="pl-k">:</span> <span class="pl-v">this</span>.<span class="pl-c1">height</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>px<span class="pl-pds">"</span></span>
            } ).appendTo( $where );
        }
    }
}

<span class="pl-k">class</span> <span class="pl-en">Button</span> <span class="pl-k">extends</span> <span class="pl-en">Widget</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">width</span>,<span class="pl-smi">height</span>,<span class="pl-smi">label</span>) {
        <span class="pl-v">super</span>( width, height );
        <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">=</span> label <span class="pl-k">||</span> <span class="pl-s"><span class="pl-pds">"</span>Default<span class="pl-pds">"</span></span>;
        <span class="pl-v">this</span>.$elem <span class="pl-k">=</span> $( <span class="pl-s"><span class="pl-pds">"</span>&lt;button&gt;<span class="pl-pds">"</span></span> ).<span class="pl-c1">text</span>( <span class="pl-v">this</span>.<span class="pl-c1">label</span> );
    }
    <span class="pl-en">render</span>(<span class="pl-smi">$where</span>) {
        <span class="pl-v">super</span>( $where );
        <span class="pl-v">this</span>.$elem.<span class="pl-c1">click</span>( <span class="pl-v">this</span>.onClick.bind( <span class="pl-v">this</span> ) );
    }
    <span class="pl-en">onClick</span>(<span class="pl-smi">evt</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Button '<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-c1">label</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>' clicked!<span class="pl-pds">"</span></span> );
    }
}</pre></div>

<p>Beyond this syntax <em>looking</em> nicer, what problems does ES6 solve?</p>

<ol>
<li>There's no more (well, sorta, see below!) references to <code>.prototype</code> cluttering the code.</li>
<li><code>Button</code> is declared directly to "inherit from" (aka <code>extends</code>) <code>Widget</code>, instead of needing to use <code>Object.create(..)</code> to replace a <code>.prototype</code> object that's linked, or having to set with <code>.__proto__</code> or <code>Object.setPrototypeOf(..)</code>.</li>
<li><code>super(..)</code> now gives us a very helpful <strong>relative polymorphism</strong> capability, so that any method at one level of the chain can refer relatively one level up the chain to a method of the same name. This includes a solution to the note from Chapter 4 about the weirdness of constructors not belonging to their class, and so being unrelated -- <code>super()</code> works inside constructors exactly as you'd expect.</li>
<li><code>class</code> literal syntax has no affordance for specifying properties (only methods). This might seem limiting to some, but it's expected that the vast majority of cases where a property (state) exists elsewhere but the end-chain "instances", this is usually a mistake and surprising (as it's state that's implicitly "shared" among all "instances"). So, one <em>could</em> say the <code>class</code> syntax is protecting you from mistakes.</li>
<li><code>extends</code> lets you extend even built-in object (sub)types, like <code>Array</code> or <code>RegExp</code>, in a very natural way. Doing so without <code>class .. extends</code> has long been an exceedingly complex and frustrating task, one that only the most adept of framework authors have ever been able to accurately tackle. Now, it will be rather trivial!</li>
</ol>

<p>In all fairness, those are some substantial solutions to many of the most obvious (syntactic) issues and surprises people have with classical prototype-style code.</p>

<h2><a id="user-content-class-gotchas" class="anchor" href="#class-gotchas" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>class</code> Gotchas</h2>

<p>It's not all bubblegum and roses, though. There are still some deep and profoundly troubling issues with using "classes" as a design pattern in JS.</p>

<p>Firstly, the <code>class</code> syntax may convince you a new "class" mechanism exists in JS as of ES6. <strong>Not so.</strong> <code>class</code> is, mostly, just syntactic sugar on top of the existing <code>[[Prototype]]</code> (delegation!) mechanism.</p>

<p>That means <code>class</code> is not actually copying definitions statically at declaration time the way it does in traditional class-oriented languages. If you change/replace a method (on purpose or by accident) on the parent "class", the child "class" and/or instances will still be "affected", in that they didn't get copies at declaration time, they are all still using the live-delegation model based on <code>[[Prototype]]</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">C</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-v">this</span>.num <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();
    }
    <span class="pl-en">rand</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Random: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.num );
    }
}

<span class="pl-k">var</span> c1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>();
c1.rand(); <span class="pl-c">// "Random: 0.4324299..."</span>

<span class="pl-c1">C</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">rand</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Random: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-c1">Math</span>.<span class="pl-c1">round</span>( <span class="pl-v">this</span>.num <span class="pl-k">*</span> <span class="pl-c1">1000</span> ));
};

<span class="pl-k">var</span> c2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>();
c2.rand(); <span class="pl-c">// "Random: 867"</span>

c1.rand(); <span class="pl-c">// "Random: 432" -- oops!!!</span></pre></div>

<p>This only seems like reasonable behavior <em>if you already know</em> about the delegation nature of things, rather than expecting <em>copies</em> from "real classes". So the question to ask yourself is, why are you choosing <code>class</code> syntax for something fundamentally different from classes?</p>

<p>Doesn't the ES6 <code>class</code> syntax <strong>just make it harder</strong> to see and understand the difference between traditional classes and delegated objects?</p>

<p><code>class</code> syntax <em>does not</em> provide a way to declare class member properties (only methods). So if you need to do that to track shared state among instances, then you end up going back to the ugly <code>.prototype</code> syntax, like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">C</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-c">// make sure to modify the shared state,</span>
        <span class="pl-c">// not set a shadowed property on the</span>
        <span class="pl-c">// instances!</span>
        C.<span class="pl-c1">prototype</span>.count<span class="pl-k">++</span>;

        <span class="pl-c">// here, `this.count` works as expected</span>
        <span class="pl-c">// via delegation</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.count );
    }
}

<span class="pl-c">// add a property for shared state directly to</span>
<span class="pl-c">// prototype object</span>
<span class="pl-c1">C</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">count</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">var</span> c1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>();
<span class="pl-c">// Hello: 1</span>

<span class="pl-k">var</span> c2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>();
<span class="pl-c">// Hello: 2</span>

c1.count <span class="pl-k">===</span> <span class="pl-c1">2</span>; <span class="pl-c">// true</span>
c1.count <span class="pl-k">===</span> c2.count; <span class="pl-c">// true</span></pre></div>

<p>The biggest problem here is that it betrays the <code>class</code> syntax by exposing (leakage!) <code>.prototype</code> as an implementation detail.</p>

<p>But, we also still have the surprise gotcha that <code>this.count++</code> would implicitly create a separate shadowed <code>.count</code> property on both <code>c1</code> and <code>c2</code> objects, rather than updating the shared state. <code>class</code> offers us no consolation from that issue, except (presumably) to imply by lack of syntactic support that you shouldn't be doing that <em>at all</em>.</p>

<p>Moreover, accidental shadowing is still a hazard:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">C</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">id</span>) {
        <span class="pl-c">// oops, gotcha, we're shadowing `id()` method</span>
        <span class="pl-c">// with a property value on the instance</span>
        <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> id;
    }
    <span class="pl-en">id</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Id: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> id );
    }
}

<span class="pl-k">var</span> c1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>( <span class="pl-s"><span class="pl-pds">"</span>c1<span class="pl-pds">"</span></span> );
c1.<span class="pl-c1">id</span>(); <span class="pl-c">// TypeError -- `c1.id` is now the string "c1"</span></pre></div>

<p>There's also some very subtle nuanced issues with how <code>super</code> works. You might assume that <code>super</code> would be bound in an analogous way to how <code>this</code> gets bound (see Chapter 2), which is that <code>super</code> would always be bound to one level higher than whatever the current method's position in the <code>[[Prototype]]</code> chain is.</p>

<p>However, for performance reasons (<code>this</code> binding is already expensive), <code>super</code> is not bound dynamically. It's bound sort of "statically", as declaration time. No big deal, right?</p>

<p>Ehh... maybe, maybe not. If you, like most JS devs, start assigning functions around to different objects (which came from <code>class</code> definitions), in various different ways, you probably won't be very aware that in all those cases, the <code>super</code> mechanism under the covers is having to be re-bound each time.</p>

<p>And depending on what sorts of syntactic approaches you take to these assignments, there may very well be cases where the <code>super</code> can't be properly bound (at least, not where you suspect), so you may (at time of writing, TC39 discussion is ongoing on the topic) have to manually bind <code>super</code> with <code>toMethod(..)</code> (kinda like you have to do <code>bind(..)</code> for <code>this</code> -- see Chapter 2).</p>

<p>You're used to being able to assign around methods to different objects to <em>automatically</em> take advantage of the dynamism of <code>this</code> via the <em>implicit binding</em> rule (see Chapter 2). But the same will likely not be true with methods that use <code>super</code>.</p>

<p>Consider what <code>super</code> should do here (against <code>D</code> and <code>E</code>):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">class</span> <span class="pl-en">P</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>P.foo<span class="pl-pds">"</span></span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">C</span> <span class="pl-k">extends</span> <span class="pl-en">P</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>();
    }
}

<span class="pl-k">var</span> c1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>();
c1.foo(); <span class="pl-c">// "P.foo"</span>

<span class="pl-k">var</span> D <span class="pl-k">=</span> {
    <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">function</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>D.foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-k">var</span> E <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> C.<span class="pl-c1">prototype</span>.foo
};

<span class="pl-c">// Link E to D for delegation</span>
<span class="pl-c1">Object</span>.setPrototypeOf( E, D );

E.foo(); <span class="pl-c">// "P.foo"</span></pre></div>

<p>If you were thinking (quite reasonably!) that <code>super</code> would be bound dynamically at call-time, you might expect that <code>super()</code> would automatically recognize that <code>E</code> delegates to <code>D</code>, so <code>E.foo()</code> using <code>super()</code> should call to <code>D.foo()</code>.</p>

<p><strong>Not so.</strong> For performance pragmatism reasons, <code>super</code> is not <em>late bound</em> (aka, dynamically bound) like <code>this</code> is. Instead it's derived at call-time from <code>[[HomeObject]].[[Prototype]]</code>, where <code>[[HomeObject]]</code> is statically bound at creation time.</p>

<p>In this particular case, <code>super()</code> is still resolving to <code>P.foo()</code>, since the method's <code>[[HomeObject]]</code> is still <code>C</code> and <code>C.[[Prototype]]</code> is <code>P</code>.</p>

<p>There will <em>probably</em> be ways to manually address such gotchas. Using <code>toMethod(..)</code> to bind/rebind a method's <code>[[HomeObject]]</code> (along with setting the <code>[[Prototype]]</code> of that object!) appears to work in this scenario:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> D <span class="pl-k">=</span> {
    <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">function</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>D.foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-c">// Link E to D for delegation</span>
<span class="pl-k">var</span> E <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( D );

<span class="pl-c">// manually bind `foo`s `[[HomeObject]]` as</span>
<span class="pl-c">// `E`, and `E.[[Prototype]]` is `D`, so thus</span>
<span class="pl-c">// `super()` is `D.foo()`</span>
E.foo <span class="pl-k">=</span> C.<span class="pl-c1">prototype</span>.foo.toMethod( E, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

E.foo(); <span class="pl-c">// "D.foo"</span></pre></div>

<p><strong>Note:</strong> <code>toMethod(..)</code> clones the method, and takes <code>homeObject</code> as its first parameter (which is why we pass <code>E</code>), and the second parameter (optionally) sets a <code>name</code> for the new method (which keep at "foo").</p>

<p>It remains to be seen if there are other corner case gotchas that devs will run into beyond this scenario. Regardless, you will have to be diligent and stay aware of which places the engine automatically figures out <code>super</code> for you, and which places you have to manually take care of it. <strong>Ugh!</strong></p>

<h1><a id="user-content-static--dynamic" class="anchor" href="#static--dynamic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Static &gt; Dynamic?</h1>

<p>But the biggest problem of all about ES6 <code>class</code> is that all these various gotchas mean <code>class</code> sorta opts you into a syntax which seems to imply (like traditional classes) that once you declare a <code>class</code>, it's a static definition of a (future instantiated) thing. You completely lose sight of the fact <code>C</code> is an object, a concrete thing, which you can directly interact with.</p>

<p>In traditional class-oriented languages, you never adjust the definition of a class later, so the class design pattern doesn't suggest such capabilities. But <strong>one of the most powerful parts</strong> of JS is that it <em>is</em> dynamic, and the definition of any object is (unless you make it immutable) a fluid and mutable <em>thing</em>.</p>

<p><code>class</code> seems to imply you shouldn't do such things, by forcing you into the uglier <code>.prototype</code> syntax to do so, or forcing you think about <code>super</code> gotchas, etc. It also offers <em>very little</em> support for any of the pitfalls that this dynamism can bring.</p>

<p>In other words, it's as if <code>class</code> is telling you: "dynamic is too hard, so it's probably not a good idea. Here's a static-looking syntax, so code your stuff statically."</p>

<p>What a sad commentary on JavaScript: <strong>dynamic is too hard, let's pretend to be (but not actually be!) static</strong>.</p>

<p>These are the reasons why ES6 <code>class</code> is masquerading as a nice solution to syntactic headaches, but it's actually muddying the waters further and making things worse for JS and for clear and concise understanding.</p>

<p><strong>Note:</strong> If you use the <code>.bind(..)</code> utility to make a hard-bound function (see Chapter 2), the function created is not subclassable with ES6 <code>extend</code> like normal functions are.</p>

<h2><a id="user-content-review-tldr" class="anchor" href="#review-tldr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review (TL;DR)</h2>

<p><code>class</code> does a very good job of pretending to fix the problems with the class/inheritance design pattern in JS. But it actually does the opposite: <strong>it hides many of the problems, and introduces other subtle but dangerous ones</strong>.</p>

<p><code>class</code> contributes to the ongoing confusion of "class" in JavaScript which has plagued the language for nearly two decades. In some respects, it asks more questions than it answers, and it feels in totality like a very unnatural fit on top of the elegant simplicity of the <code>[[Prototype]]</code> mechanism.</p>

<p>Bottom line: if ES6 <code>class</code> makes it harder to robustly leverage <code>[[Prototype]]</code>, and hides the most important nature of the JS object mechanism -- <strong>the live delegation links between objects</strong> -- shouldn't we see <code>class</code> as creating more troubles than it solves, and just relegate it to an anti-pattern?</p>

<p>I can't really answer that question for you. But I hope this book has fully explored the issue at a deeper level than you've ever gone before, and has given you the information you need <em>to answer it yourself</em>.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-async--performance" class="anchor" href="#you-dont-know-js-async--performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Async &amp; Performance</h1>

<h1><a id="user-content-chapter-1-asynchrony-now--later" class="anchor" href="#chapter-1-asynchrony-now--later" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: Asynchrony: Now &amp; Later</h1>

<p>One of the most important and yet often misunderstood parts of programming in a language like JavaScript is how to express and manipulate program behavior spread out over a period of time.</p>

<p>This is not just about what happens from the beginning of a <code>for</code> loop to the end of a <code>for</code> loop, which of course takes <em>some time</em> (microseconds to milliseconds) to complete. It's about what happens when part of your program runs <em>now</em>, and another part of your program runs <em>later</em> -- there's a gap between <em>now</em> and <em>later</em> where your program isn't actively executing.</p>

<p>Practically all nontrivial programs ever written (especially in JS) have in some way or another had to manage this gap, whether that be in waiting for user input, requesting data from a database or file system, sending data across the network and waiting for a response, or performing a repeated task at a fixed interval of time (like animation). In all these various ways, your program has to manage state across the gap in time. As they famously say in London (of the chasm between the subway door and the platform): "mind the gap."</p>

<p>In fact, the relationship between the <em>now</em> and <em>later</em> parts of your program is at the heart of asynchronous programming.</p>

<p>Asynchronous programming has been around since the beginning of JS, for sure. But most JS developers have never really carefully considered exactly how and why it crops up in their programs, or explored various <em>other</em> ways to handle it. The <em>good enough</em> approach has always been the humble callback function. Many to this day will insist that callbacks are more than sufficient.</p>

<p>But as JS continues to grow in both scope and complexity, to meet the ever-widening demands of a first-class programming language that runs in browsers and servers and every conceivable device in between, the pains by which we manage asynchrony are becoming increasingly crippling, and they cry out for approaches that are both more capable and more reason-able.</p>

<p>While this all may seem rather abstract right now, I assure you we'll tackle it more completely and concretely as we go on through this book. We'll explore a variety of emerging techniques for async JavaScript programming over the next several chapters.</p>

<p>But before we can get there, we're going to have to understand much more deeply what asynchrony is and how it operates in JS.</p>

<h2><a id="user-content-a-program-in-chunks" class="anchor" href="#a-program-in-chunks" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Program in Chunks</h2>

<p>You may write your JS program in one <em>.js</em> file, but your program is almost certainly comprised of several chunks, only one of which is going to execute <em>now</em>, and the rest of which will execute <em>later</em>. The most common unit of <em>chunk</em> is the <code>function</code>.</p>

<p>The problem most developers new to JS seem to have is that <em>later</em> doesn't happen strictly and immediately after <em>now</em>. In other words, tasks that cannot complete <em>now</em> are, by definition, going to complete asynchronously, and thus we will not have blocking behavior as you might intuitively expect or want.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
<span class="pl-k">var</span> data <span class="pl-k">=</span> ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( data );
<span class="pl-c">// Oops! `data` generally won't have the Ajax results</span></pre></div>

<p>You're probably aware that standard Ajax requests don't complete synchronously, which means the <code>ajax(..)</code> function does not yet have any value to return back to be assigned to <code>data</code> variable. If <code>ajax(..)</code> <em>could</em> block until the response came back, then the <code>data = ..</code> assignment would work fine.</p>

<p>But that's not how we do Ajax. We make an asynchronous Ajax request <em>now</em>, and we won't get the results back until <em>later</em>.</p>

<p>The simplest (but definitely not only, or necessarily even best!) way of "waiting" from <em>now</em> until <em>later</em> is to use a function, commonly called a callback function:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">myCallbackFunction</span>(<span class="pl-smi">data</span>){

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( data ); <span class="pl-c">// Yay, I gots me some `data`!</span>

} );</pre></div>

<p><strong>Warning:</strong> You may have heard that it's possible to make synchronous Ajax requests. While that's technically true, you should never, ever do it, under any circumstances, because it locks the browser UI (buttons, menus, scrolling, etc.) and prevents any user interaction whatsoever. This is a terrible idea, and should always be avoided.</p>

<p>Before you protest in disagreement, no, your desire to avoid the mess of callbacks is <em>not</em> justification for blocking, synchronous Ajax.</p>

<p>For example, consider this code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">now</span>() {
    <span class="pl-k">return</span> <span class="pl-c1">21</span>;
}

<span class="pl-k">function</span> <span class="pl-en">later</span>() {
    answer <span class="pl-k">=</span> answer <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Meaning of life:<span class="pl-pds">"</span></span>, answer );
}

<span class="pl-k">var</span> answer <span class="pl-k">=</span> now();

<span class="pl-c1">setTimeout</span>( later, <span class="pl-c1">1000</span> ); <span class="pl-c">// Meaning of life: 42</span></pre></div>

<p>There are two chunks to this program: the stuff that will run <em>now</em>, and the stuff that will run <em>later</em>. It should be fairly obvious what those two chunks are, but let's be super explicit:</p>

<p>Now:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">now</span>() {
    <span class="pl-k">return</span> <span class="pl-c1">21</span>;
}

<span class="pl-k">function</span> <span class="pl-en">later</span>() { .. }

<span class="pl-k">var</span> answer <span class="pl-k">=</span> now();

<span class="pl-c1">setTimeout</span>( later, <span class="pl-c1">1000</span> );</pre></div>

<p>Later:</p>

<div class="highlight highlight-js"><pre>answer <span class="pl-k">=</span> answer <span class="pl-k">*</span> <span class="pl-c1">2</span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Meaning of life:<span class="pl-pds">"</span></span>, answer );</pre></div>

<p>The <em>now</em> chunk runs right away, as soon as you execute your program. But <code>setTimeout(..)</code> also sets up an event (a timeout) to happen <em>later</em>, so the contents of the <code>later()</code> function will be executed at a later time (1,000 milliseconds from now).</p>

<p>Any time you wrap a portion of code into a <code>function</code> and specify that it should be executed in response to some event (timer, mouse click, Ajax response, etc.), you are creating a <em>later</em> chunk of your code, and thus introducing asynchrony to your program.</p>

<h3><a id="user-content-async-console" class="anchor" href="#async-console" aria-hidden="true"><span class="octicon octicon-link"></span></a>Async Console</h3>

<p>There is no specification or set of requirements around how the <code>console.*</code> methods work -- they are not officially part of JavaScript, but are instead added to JS by the <em>hosting environment</em> (see the <em>Types &amp; Grammar</em> title of this book series).</p>

<p>So, different browsers and JS environments do as they please, which can sometimes lead to confusing behavior.</p>

<p>In particular, there are some browsers and some conditions that <code>console.log(..)</code> does not actually immediately output what it's given. The main reason this may happen is because I/O is a very slow and blocking part of many programs (not just JS). So, it may perform better (from the page/UI perspective) for a browser to handle <code>console</code> I/O asynchronously in the background, without you perhaps even knowing that occurred.</p>

<p>A not terribly common, but possible, scenario where this could be <em>observable</em> (not from code itself but from the outside):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> {
    index<span class="pl-k">:</span> <span class="pl-c1">1</span>
};

<span class="pl-c">// later</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( a ); <span class="pl-c">// ??</span>

<span class="pl-c">// even later</span>
a.<span class="pl-c1">index</span><span class="pl-k">++</span>;</pre></div>

<p>We'd normally expect to see the <code>a</code> object be snapshotted at the exact moment of the <code>console.log(..)</code> statement, printing something like <code>{ index: 1 }</code>, such that in the next statment when <code>a.index++</code> happens, it's modifying something different than, or just strictly after, the output of <code>a</code>.</p>

<p>Most of the time, the preceding code will probably produce an object representation in your developer tools' console that's what you'd expect. But it's possible this same code could run in a situation where the browser felt it needed to defer the console I/O to the background, in which case it's <em>possible</em> that by the time the object is represented in the browser console, the <code>a.index++</code> has already happened, and it shows <code>{ index: 2 }</code>.</p>

<p>It's a moving target under what conditions exactly <code>console</code> I/O will be deferred, or even whether it will be observable. Just be aware of this possible asynchronicity in I/O in case you ever run into issues in debugging where objects have been modified <em>after</em> a <code>console.log(..)</code> statement and yet you see the unexpected modifications show up.</p>

<p><strong>Note:</strong> If you run into this rare scenario, the best option is to use breakpoints in your JS debugger instead of relying on <code>console</code> output. The next best option would be to force a "snapshot" of the object in question by serializing it to a <code>string</code>, like with <code>JSON.stringify(..)</code>.</p>

<h2><a id="user-content-event-loop" class="anchor" href="#event-loop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Event Loop</h2>

<p>Let's make a (perhaps shocking) claim: despite clearly allowing asynchronous JS code (like the timeout we just looked at), up until recently (ES6), JavaScript itself has actually never had any direct notion of asynchrony built into it.</p>

<p><strong>What!?</strong> That seems like a crazy claim, right? In fact, it's quite true. The JS engine itself has never done anything more than execute a single chunk of your program at any given moment, when asked to.</p>

<p>"Asked to." By whom? That's the important part!</p>

<p>The JS engine doesn't run in isolation. It runs inside a <em>hosting environment</em>, which is for most developers the typical web browser. Over the last several years (but by no means exclusively), JS has expanded beyond the browser into other environments, such as servers, via things like Node.js. In fact, JavaScript gets embedded into all kinds of devices these days, from robots to lightbulbs.</p>

<p>But the one common "thread" (that's a not-so-subtle asynchronous joke, for what it's worth) of all these environments is that they have a mechanism in them that handles executing multiple chunks of your program <em>over time</em>, at each moment invoking the JS engine, called the "event loop."</p>

<p>In other words, the JS engine has had no innate sense of <em>time</em>, but has instead been an on-demand execution environment for any arbitrary snippet of JS. It's the surrounding environment that has always <em>scheduled</em> "events" (JS code executions).</p>

<p>So, for example, when your JS program makes an Ajax request to fetch some data from a server, you set up the "response" code in a function (commonly called a "callback"), and the JS engine tells the hosting environment, "Hey, I'm going to suspend execution for now, but whenever you finish with that network request, and you have some data, please <em>call</em> this function <em>back</em>."</p>

<p>The browser is then set up to listen for the response from the network, and when it has something to give you, it schedules the callback function to be executed by inserting it into the <em>event loop</em>.</p>

<p>So what is the <em>event loop</em>?</p>

<p>Let's conceptualize it first through some fake-ish code:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span>
<span class="pl-k">var</span> eventLoop <span class="pl-k">=</span> [ ];
<span class="pl-k">var</span> <span class="pl-c1">event</span>;

<span class="pl-c">// keep going "forever"</span>
<span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
    <span class="pl-c">// perform a "tick"</span>
    <span class="pl-k">if</span> (eventLoop.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-c">// get the next event in the queue</span>
        <span class="pl-c1">event</span> <span class="pl-k">=</span> eventLoop.<span class="pl-c1">shift</span>();

        <span class="pl-c">// now, execute the next event</span>
        <span class="pl-k">try</span> {
            <span class="pl-c1">event</span>();
        }
        <span class="pl-k">catch</span> (err) {
            reportError(err);
        }
    }
}</pre></div>

<p>This is, of course, vastly simplified pseudocode to illustrate the concepts. But it should be enough to help get a better understanding.</p>

<p>As you can see, there's a continuously running loop represented by the <code>while</code> loop, and each iteration of this loop is called a "tick." For each tick, if an event is waiting on the queue, it's taken off and executed. These events are your function callbacks.</p>

<p>It's important to note that <code>setTimeout(..)</code> doesn't put your callback on the event loop queue. What it does is set up a timer; when the timer expires, the environment places your callback into the event loop, such that some future tick will pick it up and execute it.</p>

<p>What if there are already 20 items in the event loop at that moment? Your callback waits. It gets in line behind the others -- there's not normally a path for preempting the queue and skipping ahead in line. This explains why <code>setTimeout(..)</code> timers may not fire with perfect temporal accuracy. You're guaranteed (roughly speaking) that your callback won't fire <em>before</em> the time interval you specify, but it can happen at or after that time, depending on the state of the event queue.</p>

<p>So, in other words, your program is generally broken up into lots of small chunks, which happen one after the other in the event loop queue. And technically, other events not related directly to your program can be interleaved within the queue as well.</p>

<p><strong>Note:</strong> We mentioned "up until recently" in relation to ES6 changing the nature of where the event loop queue is managed. It's mostly a formal technicality, but ES6 now specifies how the event loop works, which means technically it's within the purview of the JS engine, rather than just the <em>hosting environment</em>. One main reason for this change is the introduction of ES6 Promises, which we'll discuss in Chapter 3, because they require the ability to have direct, fine-grained control over scheduling operations on the event loop queue (see the discussion of <code>setTimeout(..0)</code> in the "Cooperation" section).</p>

<h2><a id="user-content-parallel-threading" class="anchor" href="#parallel-threading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parallel Threading</h2>

<p>It's very common to conflate the terms "async" and "parallel," but they are actually quite different. Remember, async is about the gap between <em>now</em> and <em>later</em>. But parallel is about things being able to occur simultaneously.</p>

<p>The most common tools for parallel computing are processes and threads. Processes and threads execute independently and may execute simultaneously: on separate processors, or even separate computers, but multiple threads can share the memory of a single process.</p>

<p>An event loop, by contrast, breaks its work into tasks and executes them in serial, disallowing parallel access and changes to shared memory. Parallelism and "serialism" can coexist in the form of cooperating event loops in separate threads.</p>

<p>The interleaving of parallel threads of execution and the interleaving of asynchronous events occur at very different levels of granularity.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">later</span>() {
    answer <span class="pl-k">=</span> answer <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Meaning of life:<span class="pl-pds">"</span></span>, answer );
}</pre></div>

<p>While the entire contents of <code>later()</code> would be regarded as a single event loop queue entry, when thinking about a thread this code would run on, there's actually perhaps a dozen different low-level operations. For example, <code>answer = answer * 2</code> requires first loading the current value of <code>answer</code>, then putting <code>2</code> somewhere, then performing the multiplication, then taking the result and storing it back into <code>answer</code>.</p>

<p>In a single-threaded environment, it really doesn't matter that the items in the thread queue are low-level operations, because nothing can interrupt the thread. But if you have a parallel system, where two different threads are operating in the same program, you could very likely have unpredictable behavior.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">20</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    a <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    a <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>In JavaScript's single-threaded behavior, if <code>foo()</code> runs before <code>bar()</code>, the result is that <code>a</code> has <code>42</code>, but if <code>bar()</code> runs before <code>foo()</code> the result in <code>a</code> will be <code>41</code>.</p>

<p>If JS events sharing the same data executed in parallel, though, the problems would be much more subtle. Consider these two lists of pseudocode tasks as the threads that could respectively run the code in <code>foo()</code> and <code>bar()</code>, and consider what happens if they are running at exactly the same time:</p>

<p>Thread 1 (<code>X</code> and <code>Y</code> are temporary memory locations):</p>

<pre><code>foo():
  a. load value of `a` in `X`
  b. store `1` in `Y`
  c. add `X` and `Y`, store result in `X`
  d. store value of `X` in `a`
</code></pre>

<p>Thread 2 (<code>X</code> and <code>Y</code> are temporary memory locations):</p>

<pre><code>bar():
  a. load value of `a` in `X`
  b. store `2` in `Y`
  c. multiply `X` and `Y`, store result in `X`
  d. store value of `X` in `a`
</code></pre>

<p>Now, let's say that the two threads are running truly in parallel. You can probably spot the problem, right? They use shared memory locations <code>X</code> and <code>Y</code> for their temporary steps.</p>

<p>What's the end result in <code>a</code> if the steps happen like this?</p>

<pre><code>1a  (load value of `a` in `X`   ==&gt; `20`)
2a  (load value of `a` in `X`   ==&gt; `20`)
1b  (store `1` in `Y`   ==&gt; `1`)
2b  (store `2` in `Y`   ==&gt; `2`)
1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)
1d  (store value of `X` in `a`   ==&gt; `22`)
2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)
2d  (store value of `X` in `a`   ==&gt; `44`)
</code></pre>

<p>The result in <code>a</code> will be <code>44</code>. But what about this ordering?</p>

<pre><code>1a  (load value of `a` in `X`   ==&gt; `20`)
2a  (load value of `a` in `X`   ==&gt; `20`)
2b  (store `2` in `Y`   ==&gt; `2`)
1b  (store `1` in `Y`   ==&gt; `1`)
2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)
1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)
1d  (store value of `X` in `a`   ==&gt; `21`)
2d  (store value of `X` in `a`   ==&gt; `21`)
</code></pre>

<p>The result in <code>a</code> will be <code>21</code>.</p>

<p>So, threaded programming is very tricky, because if you don't take special steps to prevent this kind of interruption/interleaving from happening, you can get very surprising, nondeterministic behavior that frequently leads to headaches.</p>

<p>JavaScript never shares data across threads, which means <em>that</em> level of nondeterminism isn't a concern. But that doesn't mean JS is always deterministic. Remember earlier, where the relative ordering of <code>foo()</code> and <code>bar()</code> produces two different results (<code>41</code> or <code>42</code>)?</p>

<p><strong>Note:</strong> It may not be obvious yet, but not all nondeterminism is bad. Sometimes it's irrelevant, and sometimes it's intentional. We'll see more examples of that throughout this and the next few chapters.</p>

<h3><a id="user-content-run-to-completion" class="anchor" href="#run-to-completion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run-to-Completion</h3>

<p>Because of JavaScript's single-threading, the code inside of <code>foo()</code> (and <code>bar()</code>) is atomic, which means that once <code>foo()</code> starts running, the entirety of its code will finish before any of the code in <code>bar()</code> can run, or vice versa. This is called "run-to-completion" behavior.</p>

<p>In fact, the run-to-completion semantics are more obvious when <code>foo()</code> and <code>bar()</code> have more code in them, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    a<span class="pl-k">++</span>;
    b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
    a <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    b<span class="pl-k">--</span>;
    a <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> b;
    b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>Because <code>foo()</code> can't be interrupted by <code>bar()</code>, and <code>bar()</code> can't be interrupted by <code>foo()</code>, this program only has two possible outcomes depending on which starts running first -- if threading were present, and the individual statements in <code>foo()</code> and <code>bar()</code> could be interleaved, the number of possible outcomes would be greatly increased!</p>

<p>Chunk 1 is synchronous (happens <em>now</em>), but chunks 2 and 3 are asynchronous (happen <em>later</em>), which means their execution will be separated by a gap of time.</p>

<p>Chunk 1:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;</pre></div>

<p>Chunk 2 (<code>foo()</code>):</p>

<div class="highlight highlight-js"><pre>a<span class="pl-k">++</span>;
b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
a <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">3</span>;</pre></div>

<p>Chunk 3 (<code>bar()</code>):</p>

<div class="highlight highlight-js"><pre>b<span class="pl-k">--</span>;
a <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> b;
b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;</pre></div>

<p>Chunks 2 and 3 may happen in either-first order, so there are two possible outcomes for this program, as illustrated here:</p>

<p>Outcome 1:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-c">// foo()</span>
a<span class="pl-k">++</span>;
b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
a <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">3</span>;

<span class="pl-c">// bar()</span>
b<span class="pl-k">--</span>;
a <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> b;
b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;

a; <span class="pl-c">// 11</span>
b; <span class="pl-c">// 22</span></pre></div>

<p>Outcome 2:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-c">// bar()</span>
b<span class="pl-k">--</span>;
a <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> b;
b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;

<span class="pl-c">// foo()</span>
a<span class="pl-k">++</span>;
b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
a <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">3</span>;

a; <span class="pl-c">// 183</span>
b; <span class="pl-c">// 180</span></pre></div>

<p>Two outcomes from the same code means we still have nondeterminism! But it's at the function (event) ordering level, rather than at the statement ordering level (or, in fact, the expression operation ordering level) as it is with threads. In other words, it's <em>more deterministic</em> than threads would have been.</p>

<p>As applied to JavaScript's behavior, this function-ordering nondeterminism is the common term "race condition," as <code>foo()</code> and <code>bar()</code> are racing against each other to see which runs first. Specifically, it's a "race condition" because you cannot predict reliably how <code>a</code> and <code>b</code> will turn out.</p>

<p><strong>Note:</strong> If there was a function in JS that somehow did not have run-to-completion behavior, we could have many more possible outcomes, right? It turns out ES6 introduces just such a thing (see Chapter 4 "Generators"), but don't worry right now, we'll come back to that!</p>

<h2><a id="user-content-concurrency" class="anchor" href="#concurrency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concurrency</h2>

<p>Let's imagine a site that displays a list of status updates (like a social network news feed) that progressively loads as the user scrolls down the list. To make such a feature work correctly, (at least) two separate "processes" will need to be executing <em>simultaneously</em> (i.e., during the same window of time, but not necessarily at the same instant).</p>

<p><strong>Note:</strong> We're using "process" in quotes here because they aren't true operating systemlevel processes in the computer science sense. They're virtual processes, or tasks, that represent a logically connected, sequential series of operations. We'll simply prefer "process" over "task" because terminology-wise, it will match the definitions of the concepts we're exploring.</p>

<p>The first "process" will respond to <code>onscroll</code> events (making Ajax requests for new content) as they fire when the user has scrolled the page further down. The second "process" will receive Ajax responses back (to render content onto the page).</p>

<p>Obviously, if a user scrolls fast enough, you may see two or more <code>onscroll</code> events fired during the time it takes to get the first response back and process, and thus you're going to have <code>onscroll</code> events and Ajax response events firing rapidly, interleaved with each other.</p>

<p>Concurrency is when two or more "processes" are executing simultaneously over the same period, regardless of whether their individual constituent operations happen <em>in parallel</em> (at the same instant on separate processors or cores) or not. You can think of concurrency then as "process"-level (or task-level) parallelism, as opposed to operation-level parallelism (separate-processor threads).</p>

<p><strong>Note:</strong> Concurrency also introduces an optional notion of these "processes" interacting with each other. We'll come back to that later.</p>

<p>For a given window of time (a few seconds worth of a user scrolling), let's visualize each independent "process" as a series of events/operations:</p>

<p>"Process" 1 (<code>onscroll</code> events):</p>

<pre><code>onscroll, request 1
onscroll, request 2
onscroll, request 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
onscroll, request 7
</code></pre>

<p>"Process" 2 (Ajax response events):</p>

<pre><code>response 1
response 2
response 3
response 4
response 5
response 6
response 7
</code></pre>

<p>It's quite possible that an <code>onscroll</code> event and an Ajax response event could be ready to be processed at exactly the same <em>moment</em>. For example let's visualize these events in a timeline:</p>

<pre><code>onscroll, request 1
onscroll, request 2          response 1
onscroll, request 3          response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6          response 4
onscroll, request 7
response 6
response 5
response 7
</code></pre>

<p>But, going back to our notion of the event loop from earlier in the chapter, JS is only going to be able to handle one event at a time, so either <code>onscroll, request 2</code> is going to happen first or <code>response 1</code> is going to happen first, but they cannot happen at literally the same moment. Just like kids at a school cafeteria, no matter what crowd they form outside the doors, they'll have to merge into a single line to get their lunch!</p>

<p>Let's visualize the interleaving of all these events onto the event loop queue.</p>

<p>Event Loop Queue:</p>

<pre><code>onscroll, request 1   &lt;--- Process 1 starts
onscroll, request 2
response 1            &lt;--- Process 2 starts
onscroll, request 3
response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
response 4
onscroll, request 7   &lt;--- Process 1 finishes
response 6
response 5
response 7            &lt;--- Process 2 finishes
</code></pre>

<p>"Process 1" and "Process 2" run concurrently (task-level parallel), but their individual events run sequentially on the event loop queue.</p>

<p>By the way, notice how <code>response 6</code> and <code>response 5</code> came back out of expected order?</p>

<p>The single-threaded event loop is one expression of concurrency (there are certainly others, which we'll come back to later).</p>

<h3><a id="user-content-noninteracting" class="anchor" href="#noninteracting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Noninteracting</h3>

<p>As two or more "processes" are interleaving their steps/events concurrently within the same program, they don't necessarily need to interact with each other if the tasks are unrelated. <strong>If they don't interact, nondeterminism is perfectly acceptable.</strong></p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> {};

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">results</span>) {
    res.foo <span class="pl-k">=</span> results;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">results</span>) {
    res.bar <span class="pl-k">=</span> results;
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p><code>foo()</code> and <code>bar()</code> are two concurrent "processes," and it's nondeterminate which order they will be fired in. But we've constructed the program so it doesn't matter what order they fire in, because they act independently and as such don't need to interact.</p>

<p>This is not a "race condition" bug, as the code will always work correctly, regardless of the ordering.</p>

<h3><a id="user-content-interaction" class="anchor" href="#interaction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interaction</h3>

<p>More commonly, concurrent "processes" will by necessity interact, indirectly through scope and/or the DOM. When such interaction will occur, you need to coordinate these interactions to prevent "race conditions," as described earlier.</p>

<p>Here's a simple example of two concurrent "processes" that interact because of implied ordering, which is only <em>sometimes broken</em>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">data</span>) {
    res.<span class="pl-c1">push</span>( data );
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, response );</pre></div>

<p>The concurrent "processes" are the two <code>response()</code> calls that will be made to handle the Ajax responses. They can happen in either-first order.</p>

<p>Let's assume the expected behavior is that <code>res[0]</code> has the results of the <code>"http://some.url.1"</code> call, and <code>res[1]</code> has the results of the <code>"http://some.url.2"</code> call. Sometimes that will be the case, but sometimes they'll be flipped, depending on which call finishes first. There's a pretty good likelihood that this nondeterminism is a "race condition" bug.</p>

<p><strong>Note:</strong> Be extremely wary of assumptions you might tend to make in these situations. For example, it's not uncommon for a developer to observe that <code>"http://some.url.2"</code> is "always" much slower to respond than <code>"http://some.url.1"</code>, perhaps by virtue of what tasks they're doing (e.g., one performing a database task and the other just fetching a static file), so the observed ordering seems to always be as expected. Even if both requests go to the same server, and <em>it</em> intentionally responds in a certain order, there's no <em>real</em> guarantee of what order the responses will arrive back in the browser.</p>

<p>So, to address such a race condition, you can coordinate ordering interaction:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">data</span>) {
    <span class="pl-k">if</span> (data.url <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>) {
        res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> data;
    }
    <span class="pl-k">else</span> <span class="pl-k">if</span> (data.url <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>) {
        res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> data;
    }
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, response );</pre></div>

<p>Regardless of which Ajax response comes back first, we inspect the <code>data.url</code> (assuming one is returned from the server, of course!) to figure out which position the response data should occupy in the <code>res</code> array. <code>res[0]</code> will always hold the <code>"http://some.url.1"</code> results and <code>res[1]</code> will always hold the <code>"http://some.url.2"</code> results. Through simple coordination, we eliminated the "race condition" nondeterminism.</p>

<p>The same reasoning from this scenario would apply if multiple concurrent function calls were interacting with each other through the shared DOM, like one updating the contents of a <code>&lt;div&gt;</code> and the other updating the style or attributes of the <code>&lt;div&gt;</code> (e.g., to make the DOM element visible once it has content). You probably wouldn't want to show the DOM element before it had content, so the coordination must ensure proper ordering interaction.</p>

<p>Some concurrency scenarios are <em>always broken</em> (not just <em>sometimes</em>) without coordinated interaction. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    a <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    baz();
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">y</span>) {
    b <span class="pl-k">=</span> y <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    baz();
}

<span class="pl-k">function</span> <span class="pl-en">baz</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(a <span class="pl-k">+</span> b);
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>In this example, whether <code>foo()</code> or <code>bar()</code> fires first, it will always cause <code>baz()</code> to run too early (either <code>a</code> or <code>b</code> will still be <code>undefined</code>), but the second invocation of <code>baz()</code> will work, as both <code>a</code> and <code>b</code> will be available.</p>

<p>There are different ways to address such a condition. Here's one simple way:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    a <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-k">if</span> (a <span class="pl-k">&amp;&amp;</span> b) {
        baz();
    }
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">y</span>) {
    b <span class="pl-k">=</span> y <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    <span class="pl-k">if</span> (a <span class="pl-k">&amp;&amp;</span> b) {
        baz();
    }
}

<span class="pl-k">function</span> <span class="pl-en">baz</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b );
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>The <code>if (a &amp;&amp; b)</code> conditional around the <code>baz()</code> call is traditionally called a "gate," because we're not sure what order <code>a</code> and <code>b</code> will arrive, but we wait for both of them to get there before we proceed to open the gate (call <code>baz()</code>).</p>

<p>Another concurrency interaction condition you may run into is sometimes called a "race," but more correctly called a "latch." It's characterized by "only the first one wins" behavior. Here, nondeterminism is acceptable, in that you are explicitly saying it's OK for the "race" to the finish line to have only one winner.</p>

<p>Consider this broken code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    a <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    baz();
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    a <span class="pl-k">=</span> x <span class="pl-k">/</span> <span class="pl-c1">2</span>;
    baz();
}

<span class="pl-k">function</span> <span class="pl-en">baz</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>Whichever one (<code>foo()</code> or <code>bar()</code>) fires last will not only overwrite the assigned <code>a</code> value from the other, but it will also duplicate the call to <code>baz()</code> (likely undesired).</p>

<p>So, we can coordinate the interaction with a simple latch, to let only the first one through:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">undefined</span>) {
        a <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
        baz();
    }
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (a <span class="pl-k">==</span> <span class="pl-c1">undefined</span>) {
        a <span class="pl-k">=</span> x <span class="pl-k">/</span> <span class="pl-c1">2</span>;
        baz();
    }
}

<span class="pl-k">function</span> <span class="pl-en">baz</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, foo );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, bar );</pre></div>

<p>The <code>if (a == undefined)</code> conditional allows only the first of <code>foo()</code> or <code>bar()</code> through, and the second (and indeed any subsequent) calls would just be ignored. There's just no virtue in coming in second place!</p>

<p><strong>Note:</strong> In all these scenarios, we've been using global variables for simplistic illustration purposes, but there's nothing about our reasoning here that requires it. As long as the functions in question can access the variables (via scope), they'll work as intended. Relying on lexically scoped variables (see the <em>Scope &amp; Closures</em> title of this book series), and in fact global variables as in these examples, is one obvious downside to these forms of concurrency coordination. As we go through the next few chapters, we'll see other ways of coordination that are much cleaner in that respect.</p>

<h3><a id="user-content-cooperation" class="anchor" href="#cooperation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cooperation</h3>

<p>Another expression of concurrency coordination is called "cooperative concurrency." Here, the focus isn't so much on interacting via value sharing in scopes (though that's obviously still allowed!). The goal is to take a long-running "process" and break it up into steps or batches so that other concurrent "processes" have a chance to interleave their operations into the event loop queue.</p>

<p>For example, consider an Ajax response handler that needs to run through a long list of results to transform the values. We'll use <code>Array#map(..)</code> to keep the code shorter:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-c">// `response(..)` receives array of results from the Ajax call</span>
<span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">data</span>) {
    <span class="pl-c">// add onto existing `res` array</span>
    res <span class="pl-k">=</span> res.<span class="pl-c1">concat</span>(
        <span class="pl-c">// make a new transformed array with all `data` values doubled</span>
        data.map( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
            <span class="pl-k">return</span> val <span class="pl-k">*</span> <span class="pl-c1">2</span>;
        } )
    );
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, response );</pre></div>

<p>If <code>"http://some.url.1"</code> gets its results back first, the entire list will be mapped into <code>res</code> all at once. If it's a few thousand or less records, this is not generally a big deal. But if it's say 10 million records, that can take a while to run (several seconds on a powerful laptop, much longer on a mobile device, etc.).</p>

<p>While such a "process" is running, nothing else in the page can happen, including no other <code>response(..)</code> calls, no UI updates, not even user events like scrolling, typing, button clicking, and the like. That's pretty painful.</p>

<p>So, to make a more cooperatively concurrent system, one that's friendlier and doesn't hog the event loop queue, you can process these results in asynchronous batches, after each one "yielding" back to the event loop to let other waiting events happen.</p>

<p>Here's a very simple approach:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-c">// `response(..)` receives array of results from the Ajax call</span>
<span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">data</span>) {
    <span class="pl-c">// let's just do 1000 at a time</span>
    <span class="pl-k">var</span> chunk <span class="pl-k">=</span> data.<span class="pl-c1">splice</span>( <span class="pl-c1">0</span>, <span class="pl-c1">1000</span> );

    <span class="pl-c">// add onto existing `res` array</span>
    res <span class="pl-k">=</span> res.<span class="pl-c1">concat</span>(
        <span class="pl-c">// make a new transformed array with all `chunk` values doubled</span>
        chunk.map( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
            <span class="pl-k">return</span> val <span class="pl-k">*</span> <span class="pl-c1">2</span>;
        } )
    );

    <span class="pl-c">// anything left to process?</span>
    <span class="pl-k">if</span> (data.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
        <span class="pl-c">// async schedule next batch</span>
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            response( data );
        }, <span class="pl-c1">0</span> );
    }
}

<span class="pl-c">// ajax(..) is some arbitrary Ajax function given by a library</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );
ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>, response );</pre></div>

<p>We process the data set in maximum-sized chunks of 1,000 items. By doing so, we ensure a short-running "process," even if that means many more subsequent "processes," as the interleaving onto the event loop queue will give us a much more responsive (performant) site/app.</p>

<p>Of course, we're not interaction-coordinating the ordering of any of these "processes," so the order of results in <code>res</code> won't be predictable. If ordering was required, you'd need to use interaction techniques like those we discussed earlier, or ones we will cover in later chapters of this book.</p>

<p>We use the <code>setTimeout(..0)</code> (hack) for async scheduling, which basically just means "stick this function at the end of the current event loop queue."</p>

<p><strong>Note:</strong> <code>setTimeout(..0)</code> is not technically inserting an item directly onto the event loop queue. The timer will insert the event at its next opportunity. For example, two subsequent <code>setTimeout(..0)</code> calls would not be strictly guaranteed to be processed in call order, so it <em>is</em> possible to see various conditions like timer drift where the ordering of such events isn't predictable. In Node.js, a similar approach is <code>process.nextTick(..)</code>. Despite how convenient (and usually more performant) it would be, there's not a single direct way (at least yet) across all environments to ensure async event ordering. We cover this topic in more detail in the next section.</p>

<h2><a id="user-content-jobs" class="anchor" href="#jobs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jobs</h2>

<p>As of ES6, there's a new concept layered on top of the event loop queue, called the "Job queue." The most likely exposure you'll have to it is with the asynchronous behavior of Promises (see Chapter 3).</p>

<p>Unfortunately, at the moment it's a mechanism without an exposed API, and thus demonstrating it is a bit more convoluted. So we're going to have to just describe it conceptually, such that when we discuss async behavior with Promises in Chapter 3, you'll understand how those actions are being scheduled and processed.</p>

<p>So, the best way to think about this that I've found is that the "Job queue" is a queue hanging off the end of every tick in the event loop queue. Certain async-implied actions that may occur during a tick of the event loop will not cause a whole new event to be added to the event loop queue, but will instead add an item (aka Job) to the end of the current tick's Job queue.</p>

<p>It's kinda like saying, "oh, here's this other thing I need to do <em>later</em>, but make sure it happens right away before anything else can happen."</p>

<p>Or, to use a metaphor: the event loop queue is like an amusement park ride, where once you finish the ride, you have to go to the back of the line to ride again. But the Job queue is like finishing the ride, but then cutting in line and getting right back on.</p>

<p>A Job can also cause more Jobs to be added to the end of the same queue. So, it's theoretically possible that a Job "loop" (a Job that keeps adding another Job, etc.) could spin indefinitely, thus starving the program of the ability to move on to the next event loop tick. This would conceptually be almost the same as just expressing a long-running or infinite loop (like <code>while (true) ..</code>) in your code.</p>

<p>Jobs are kind of like the spirit of the <code>setTimeout(..0)</code> hack, but implemented in such a way as to have a much more well-defined and guaranteed ordering: <strong>later, but as soon as possible</strong>.</p>

<p>Let's imagine an API for scheduling Jobs (directly, without hacks), and call it <code>schedule(..)</code>. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> );

<span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> );
}, <span class="pl-c1">0</span> );

<span class="pl-c">// theoretical "Job API"</span>
schedule( <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> );

    schedule( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span> );
    } );
} );</pre></div>

<p>You might expect this to print out <code>A B C D</code>, but instead it would print out <code>A C D B</code>, because the Jobs happen at the end of the current event loop tick, and the timer fires to schedule for the <em>next</em> event loop tick (if available!).</p>

<p>In Chapter 3, we'll see that the asynchronous behavior of Promises is based on Jobs, so it's important to keep clear how that relates to event loop behavior.</p>

<h2><a id="user-content-statement-ordering" class="anchor" href="#statement-ordering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Statement Ordering</h2>

<p>The order in which we express statements in our code is not necessarily the same order as the JS engine will execute them. That may seem like quite a strange assertion to make, so we'll just briefly explore it.</p>

<p>But before we do, we should be crystal clear on something: the rules/grammar of the language (see the <em>Types &amp; Grammar</em> title of this book series) dictate a very predictable and reliable behavior for statement ordering from the program point of view. So what we're about to discuss are <strong>not things you should ever be able to observe</strong> in your JS program.</p>

<p><strong>Warning:</strong> If you are ever able to <em>observe</em> compiler statement reordering like we're about to illustrate, that'd be a clear violation of the specification, and it would unquestionably be due to a bug in the JS engine in question -- one which should promptly be reported and fixed! But it's vastly more common that you <em>suspect</em> something crazy is happening in the JS engine, when in fact it's just a bug (probably a "race condition"!) in your own code -- so look there first, and again and again. The JS debugger, using breakpoints and stepping through code line by line, will be your most powerful tool for sniffing out such bugs in <em>your code</em>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
b <span class="pl-k">=</span> <span class="pl-c1">30</span>;

a <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-c1">1</span>;
b <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">1</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b ); <span class="pl-c">// 42</span></pre></div>

<p>This code has no expressed asynchrony to it (other than the rare <code>console</code> async I/O discussed earlier!), so the most likely assumption is that it would process line by line in top-down fashion.</p>

<p>But it's <em>possible</em> that the JS engine, after compiling this code (yes, JS is compiled -- see the <em>Scope &amp; Closures</em> title of this book series!) might find opportunities to run your code faster by rearranging (safely) the order of these statements. Essentially, as long as you can't observe the reordering, anything's fair game.</p>

<p>For example, the engine might find it's faster to actually execute the code like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a<span class="pl-k">++</span>;

b <span class="pl-k">=</span> <span class="pl-c1">30</span>;
b<span class="pl-k">++</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b ); <span class="pl-c">// 42</span></pre></div>

<p>Or this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">11</span>;
b <span class="pl-k">=</span> <span class="pl-c1">31</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b ); <span class="pl-c">// 42</span></pre></div>

<p>Or even:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// because `a` and `b` aren't used anymore, we can</span>
<span class="pl-c">// inline and don't even need them!</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">42</span> ); <span class="pl-c">// 42</span></pre></div>

<p>In all these cases, the JS engine is performing safe optimizations during its compilation, as the end <em>observable</em> result will be the same.</p>

<p>But here's a scenario where these specific optimizations would be unsafe and thus couldn't be allowed (of course, not to say that it's not optimized at all):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
b <span class="pl-k">=</span> <span class="pl-c1">30</span>;

<span class="pl-c">// we need `a` and `b` in their preincremented state!</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">*</span> b ); <span class="pl-c">// 300</span>

a <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-c1">1</span>;
b <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">1</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b ); <span class="pl-c">// 42</span></pre></div>

<p>Other examples where the compiler reordering could create observable side effects (and thus must be disallowed) would include things like any function call with side effects (even and especially getter functions), or ES6 Proxy objects (see the <em>ES6 &amp; Beyond</em> title of this book series).</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b );
    <span class="pl-k">return</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">var</span> a, b, c;

<span class="pl-c">// ES5.1 getter literal syntax</span>
c <span class="pl-k">=</span> {
    get <span class="pl-en">bar</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
        <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    }
};

a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
b <span class="pl-k">=</span> <span class="pl-c1">30</span>;

a <span class="pl-k">+=</span> foo();             <span class="pl-c">// 30</span>
b <span class="pl-k">+=</span> c.bar;             <span class="pl-c">// 11</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a <span class="pl-k">+</span> b );   <span class="pl-c">// 42</span></pre></div>

<p>If it weren't for the <code>console.log(..)</code> statements in this snippet (just used as a convenient form of observable side effect for the illustration), the JS engine would likely have been free, if it wanted to (who knows if it would!?), to reorder the code to:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// ...</span>

a <span class="pl-k">=</span> <span class="pl-c1">10</span> <span class="pl-k">+</span> foo();
b <span class="pl-k">=</span> <span class="pl-c1">30</span> <span class="pl-k">+</span> c.bar;

<span class="pl-c">// ...</span></pre></div>

<p>While JS semantics thankfully protect us from the <em>observable</em> nightmares that compiler statement reordering would seem to be in danger of, it's still important to understand just how tenuous a link there is between the way source code is authored (in top-down fashion) and the way it runs after compilation.</p>

<p>Compiler statement reordering is almost a micro-metaphor for concurrency and interaction. As a general concept, such awareness can help you understand async JS code flow issues better.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>A JavaScript program is (practically) always broken up into two or more chunks, where the first chunk runs <em>now</em> and the next chunk runs <em>later</em>, in response to an event. Even though the program is executed chunk-by-chunk, all of them share the same access to the program scope and state, so each modification to state is made on top of the previous state.</p>

<p>Whenever there are events to run, the <em>event loop</em> runs until the queue is empty. Each iteration of the event loop is a "tick." User interaction, IO, and timers enqueue events on the event queue.</p>

<p>At any given moment, only one event can be processed from the queue at a time. While an event is executing, it can directly or indirectly cause one or more subsequent events.</p>

<p>Concurrency is when two or more chains of events interleave over time, such that from a high-level perspective, they appear to be running <em>simultaneously</em> (even though at any given moment only one event is being processed).</p>

<p>It's often necessary to do some form of interaction coordination between these concurrent "processes" (as distinct from operating system processes), for instance to ensure ordering or to prevent "race conditions." These "processes" can also <em>cooperate</em> by breaking themselves into smaller chunks and to allow other "process" interleaving.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-async--performance" class="anchor" href="#you-dont-know-js-async--performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Async &amp; Performance</h1>

<h1><a id="user-content-chapter-2-callbacks" class="anchor" href="#chapter-2-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: Callbacks</h1>

<p>In Chapter 1, we explored the terminology and concepts around asynchronous programming in JavaScript. Our focus is on understanding the single-threaded (one-at-a-time) event loop queue that drives all "events" (async function invocations). We also explored various ways that concurrency patterns explain the relationships (if any!) between <em>simultaneously</em> running chains of events, or "processes" (tasks, function calls, etc.).</p>

<p>All our examples in Chapter 1 used the function as the individual, indivisible unit of operations, whereby inside the function, statements run in predictable order (above the compiler level!), but at the function-ordering level, events (aka async function invocations) can happen in a variety of orders.</p>

<p>In all these cases, the function is acting as a "callback," because it serves as the target for the event loop to "call back into" the program, whenever that item in the queue is processed.</p>

<p>As you no doubt have observed, callbacks are by far the most common way that asynchrony in JS programs is expressed and managed. Indeed, the callback is the most fundamental async pattern in the language.</p>

<p>Countless JS programs, even very sophisticated and complex ones, have been written upon no other async foundation than the callback (with of course the concurrency interaction patterns we explored in Chapter 1). The callback function is the async work horse for JavaScript, and it does its job respectably.</p>

<p>Except... callbacks are not without their shortcomings. Many developers are excited by the <em>promise</em> (pun intended!) of better async patterns. But it's impossible to effectively use any abstraction if you don't understand what it's abstracting, and why.</p>

<p>In this chapter, we will explore a couple of those in depth, as motivation for why more sophisticated async patterns (explored in subsequent chapters of this book) are necessary and desired.</p>

<h2><a id="user-content-continuations" class="anchor" href="#continuations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Continuations</h2>

<p>Let's go back to the async callback example we started with in Chapter 1, but let me slightly modify it to illustrate a point:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// A</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(..){
    <span class="pl-c">// C</span>
} );
<span class="pl-c">// B</span></pre></div>

<p><code>// A</code> and <code>// B</code> represent the first half of the program (aka the <em>now</em>), and <code>// C</code> marks the second half of the program (aka the <em>later</em>). The first half executes right away, and then there's a "pause" of indeterminate length. At some future moment, if the Ajax call completes, then the program will pick up where it left off, and <em>continue</em> with the second half.</p>

<p>In other words, the callback function wraps or encapsulates the <em>continuation</em> of the program.</p>

<p>Let's make the code even simpler:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// A</span>
<span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
    <span class="pl-c">// C</span>
}, <span class="pl-c1">1000</span> );
<span class="pl-c">// B</span></pre></div>

<p>Stop for a moment and ask yourself how you'd describe (to someone else less informed about how JS works) the way that program behaves. Go ahead, try it out loud. It's a good exercise that will help my next points make more sense.</p>

<p>Most readers just now probably thought or said something to the effect of: "Do A, then set up a timeout to wait 1,000 milliseconds, then once that fires, do C." How close was your rendition?</p>

<p>You might have caught yourself and self-edited to: "Do A, setup the timeout for 1,000 milliseconds, then do B, then after the timeout fires, do C." That's more accurate than the first version. Can you spot the difference?</p>

<p>Even though the second version is more accurate, both versions are deficient in explaining this code in a way that matches our brains to the code, and the code to the JS engine. The disconnect is both subtle and monumental, and is at the very heart of understanding the shortcomings of callbacks as async expression and management.</p>

<p>As soon as we introduce a single continuation (or several dozen as many programs do!) in the form of a callback function, we have allowed a divergence to form between how our brains work and the way the code will operate. Any time these two diverge (and this is by far not the only place that happens, as I'm sure you know!), we run into the inevitable fact that our code becomes harder to understand, reason about, debug, and maintain.</p>

<h2><a id="user-content-sequential-brain" class="anchor" href="#sequential-brain" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequential Brain</h2>

<p>I'm pretty sure most of you readers have heard someone say (even made the claim yourself), "I'm a multitasker." The effects of trying to act as a multitasker range from humorous (e.g., the silly patting-head-rubbing-stomach kids' game) to mundane (chewing gum while walking) to downright dangerous (texting while driving).</p>

<p>But are we multitaskers? Can we really do two conscious, intentional actions at once and think/reason about both of them at exactly the same moment? Does our highest level of brain functionality have parallel multithreading going on?</p>

<p>The answer may surprise you: <strong>probably not.</strong></p>

<p>That's just not really how our brains appear to be set up. We're much more single taskers than many of us (especially A-type personalities!) would like to admit. We can really only think about one thing at any given instant.</p>

<p>I'm not talking about all our involuntary, subconscious, automatic brain functions, such as heart beating, breathing, and eyelid blinking. Those are all vital tasks to our sustained life, but we don't intentionally allocate any brain power to them. Thankfully, while we obsess about checking social network feeds for the 15th time in three minutes, our brain carries on in the background (threads!) with all those important tasks.</p>

<p>We're instead talking about whatever task is at the forefront of our minds at the moment. For me, it's writing the text in this book right now. Am I doing any other higher level brain function at exactly this same moment? Nope, not really. I get distracted quickly and easily -- a few dozen times in these last couple of paragraphs!</p>

<p>When we <em>fake</em> multitasking, such as trying to type something at the same time we're talking to a friend or family member on the phone, what we're actually most likely doing is acting as fast context switchers. In other words, we switch back and forth between two or more tasks in rapid succession, <em>simultaneously</em> progressing on each task in tiny, fast little chunks. We do it so fast that to the outside world it appears as if we're doing these things <em>in parallel</em>.</p>

<p>Does that sound suspiciously like async evented concurrency (like the sort that happens in JS) to you?! If not, go back and read Chapter 1 again!</p>

<p>In fact, one way of simplifying (i.e., abusing) the massively complex world of neurology into something I can remotely hope to discuss here is that our brains work kinda like the event loop queue.</p>

<p>If you think about every single letter (or word) I type as a single async event, in just this sentence alone there are several dozen opportunities for my brain to be interrupted by some other event, such as from my senses, or even just my random thoughts.</p>

<p>I don't get interrupted and pulled to another "process" at every opportunity that I could be (thankfully -- or this book would never be written!). But it happens often enough that I feel my own brain is nearly constantly switching to various different contexts (aka "processes"). And that's an awful lot like how the JS engine would probably feel.</p>

<h3><a id="user-content-doing-versus-planning" class="anchor" href="#doing-versus-planning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Doing Versus Planning</h3>

<p>OK, so our brains can be thought of as operating in single-threaded event loop queue like ways, as can the JS engine. That sounds like good match.</p>

<p>But we need to be more nuanced than that in our analysis. There's a big, observable difference between how we plan various tasks, and how our brains actually operate those tasks.</p>

<p>Again, back to the writing of this text as my metaphor. My rough mental outline plan here is to keep writing and writing, going sequentially through a set of points I have ordered in my thoughts. I don't plan to have any interruptions or nonlinear activity in this writing. But yet, my brain is nevertheless switching around all the time.</p>

<p>Even though at an operational level our brains are async evented, we seem to plan out tasks in a sequential, synchronous way. "I need to go to the store, then buy some milk, then drop off my dry cleaning."</p>

<p>You'll notice that this higher level thinking (planning) doesn't seem very async evented in its formulation. In fact, it's kind of rare for us to deliberately think solely in terms of events. Instead, we plan things out carefully, sequentially (A then B then C), and we assume to an extent a sort of temporal blocking that forces B to wait on A, and C to wait on B.</p>

<p>When a developer writes code, they are planning out a set of actions to occur. If they're any good at being a developer, they're <strong>carefully planning</strong> it out. "I need to set <code>z</code> to the value of <code>x</code>, and then <code>x</code> to the value of <code>y</code>," and so forth.</p>

<p>When we write out synchronous code, statement by statement, it works a lot like our errands to-do list:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// swap `x` and `y` (via temp variable `z`)</span>
z <span class="pl-k">=</span> x;
x <span class="pl-k">=</span> y;
y <span class="pl-k">=</span> z;</pre></div>

<p>These three assignment statements are synchronous, so <code>x = y</code> waits for <code>z = x</code> to finish, and <code>y = z</code> in turn waits for <code>x = y</code> to finish. Another way of saying it is that these three statements are temporally bound to execute in a certain order, one right after the other. Thankfully, we don't need to be bothered with any async evented details here. If we did, the code gets a lot more complex, quickly!</p>

<p>So if synchronous brain planning maps well to synchronous code statements, how well do our brains do at planning out asynchronous code?</p>

<p>It turns out that how we express asynchrony (with callbacks) in our code doesn't map very well at all to that synchronous brain planning behavior.</p>

<p>Can you actually imagine having a line of thinking that plans out your to-do errands like this?</p>

<blockquote>
<p>"I need to go to the store, but on the way I'm sure I'll get a phone call, so 'Hi, Mom', and while she starts talking, I'll be looking up the store address on GPS, but that'll take a second to load, so I'll turn down the radio so I can hear Mom better, then I'll realize I forgot to put on a jacket and it's cold outside, but no matter, keep driving and talking to Mom, and then the seatbelt ding reminds me to buckle up, so 'Yes, Mom, I am wearing my seatbelt, I always do!'. Ah, finally the GPS got the directions, now..."</p>
</blockquote>

<p>As ridiculous as that sounds as a formulation for how we plan our day out and think about what to do and in what order, nonetheless it's exactly how our brains operate at a functional level. Remember, that's not multitasking, it's just fast context switching.</p>

<p>The reason it's difficult for us as developers to write async evented code, especially when all we have is the callback to do it, is that stream of consciousness thinking/planning is unnatural for most of us.</p>

<p>We think in step-by-step terms, but the tools (callbacks) available to us in code are not expressed in a step-by-step fashion once we move from synchronous to asynchronous.</p>

<p>And <strong>that</strong> is why it's so hard to accurately author and reason about async JS code with callbacks: because it's not how our brain planning works.</p>

<p><strong>Note:</strong> The only thing worse than not knowing why some code breaks is not knowing why it worked in the first place! It's the classic "house of cards" mentality: "it works, but not sure why, so nobody touch it!" You may have heard, "Hell is other people" (Sartre), and the programmer meme twist, "Hell is other people's code." I believe truly: "Hell is not understanding my own code." And callbacks are one main culprit.</p>

<h3><a id="user-content-nestedchained-callbacks" class="anchor" href="#nestedchained-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested/Chained Callbacks</h3>

<p>Consider:</p>

<div class="highlight highlight-js"><pre>listen( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">handler</span>(<span class="pl-smi">evt</span>){
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">request</span>(){
        ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">text</span>){
            <span class="pl-k">if</span> (text <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) {
                handler();
            }
            <span class="pl-k">else</span> <span class="pl-k">if</span> (text <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>) {
                request();
            }
        } );
    }, <span class="pl-c1">500</span>) ;
} );</pre></div>

<p>There's a good chance code like that is recognizable to you. We've got a chain of three functions nested together, each one representing a step in an asynchronous series (task, "process").</p>

<p>This kind of code is often called "callback hell," and sometimes also referred to as the "pyramid of doom" (for its sideways-facing triangular shape due to the nested indentation).</p>

<p>But "callback hell" actually has almost nothing to do with the nesting/indentation. It's a far deeper problem than that. We'll see how and why as we continue through the rest of this chapter.</p>

<p>First, we're waiting for the "click" event, then we're waiting for the timer to fire, then we're waiting for the Ajax response to come back, at which point it might do it all again.</p>

<p>At first glance, this code may seem to map its asynchrony naturally to sequential brain planning.</p>

<p>First (<em>now</em>), we:</p>

<div class="highlight highlight-js"><pre>listen( <span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">handler</span>(..){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>Then <em>later</em>, we:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span> <span class="pl-en">request</span>(..){
    <span class="pl-c">// ..</span>
}, <span class="pl-c1">500</span>) ;</pre></div>

<p>Then still <em>later</em>, we:</p>

<div class="highlight highlight-js"><pre>ajax( <span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">response</span>(..){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>And finally (most <em>later</em>), we:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> ( .. ) {
    <span class="pl-c">// ..</span>
}
<span class="pl-k">else</span> ..</pre></div>

<p>But there's several problems with reasoning about this code linearly in such a fashion.</p>

<p>First, it's an accident of the example that our steps are on subsequent lines (1, 2, 3, and 4...). In real async JS programs, there's often a lot more noise cluttering things up, noise that we have to deftly maneuver past in our brains as we jump from one function to the next. Understanding the async flow in such callback-laden code is not impossible, but it's certainly not natural or easy, even with lots of practice.</p>

<p>But also, there's something deeper wrong, which isn't evident just in that code example. Let me make up another scenario (pseudocode-ish) to illustrate it:</p>

<div class="highlight highlight-js"><pre>doA( <span class="pl-k">function</span>(){
    doB();

    doC( <span class="pl-k">function</span>(){
        doD();
    } )

    doE();
} );

doF();</pre></div>

<p>While the experienced among you will correctly identify the true order of operations here, I'm betting it is more than a little confusing at first glance, and takes some concerted mental cycles to arrive at. The operations will happen in this order:</p>

<ul>
<li><code>doA()</code></li>
<li><code>doF()</code></li>
<li><code>doB()</code></li>
<li><code>doC()</code></li>
<li><code>doE()</code></li>
<li><code>doD()</code></li>
</ul>

<p>Did you get that right the very first time you glanced at the code?</p>

<p>OK, some of you are thinking I was unfair in my function naming, to intentionally lead you astray. I swear I was just naming in top-down appearance order. But let me try again:</p>

<div class="highlight highlight-js"><pre>doA( <span class="pl-k">function</span>(){
    doC();

    doD( <span class="pl-k">function</span>(){
        doF();
    } )

    doE();
} );

doB();</pre></div>

<p>Now, I've named them alphabetically in order of actual execution. But I still bet, even with experience now in this scenario, tracing through the <code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code> order doesn't come natural to many if any of you readers. Certainly your eyes do an awful lot of jumping up and down the code snippet, right?</p>

<p>But even if that all comes natural to you, there's still one more hazard that could wreak havoc. Can you spot what it is?</p>

<p>What if <code>doA(..)</code> or <code>doD(..)</code> aren't actually async, the way we obviously assumed them to be? Uh oh, now the order is different. If they're both sync (and maybe only sometimes, depending on the conditions of the program at the time), the order is now <code>A -&gt; C -&gt; D -&gt; F -&gt; E -&gt; B</code>.</p>

<p>That sound you just heard faintly in the background is the sighs of thousands of JS developers who just had a face-in-hands moment.</p>

<p>Is nesting the problem? Is that what makes it so hard to trace the async flow? That's part of it, certainly.</p>

<p>But let me rewrite the previous nested event/timeout/Ajax example without using nesting:</p>

<div class="highlight highlight-js"><pre>listen( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, handler );

<span class="pl-k">function</span> <span class="pl-en">handler</span>() {
    <span class="pl-c1">setTimeout</span>( request, <span class="pl-c1">500</span> );
}

<span class="pl-k">function</span> <span class="pl-en">request</span>(){
    ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );
}

<span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">text</span>){
    <span class="pl-k">if</span> (text <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) {
        handler();
    }
    <span class="pl-k">else</span> <span class="pl-k">if</span> (text <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>) {
        request();
    }
}</pre></div>

<p>This formulation of the code is not hardly as recognizable as having the nesting/indentation woes of its previous form, and yet it's every bit as susceptible to "callback hell." Why?</p>

<p>As we go to linearly (sequentially) reason about this code, we have to skip from one function, to the next, to the next, and bounce all around the code base to "see" the sequence flow. And remember, this is simplified code in sort of best-case fashion. We all know that real async JS program code bases are often fantastically more jumbled, which makes such reasoning orders of magnitude more difficult.</p>

<p>Another thing to notice: to get steps 2, 3, and 4 linked together so they happen in succession, the only affordance callbacks alone gives us is to hardcode step 2 into step 1, step 3 into step 2, step 4 into step 3, and so on. The hardcoding isn't necessarily a bad thing, if it really is a fixed condition that step 2 should always lead to step 3.</p>

<p>But the hardcoding definitely makes the code a bit more brittle, as it doesn't account for anything going wrong that might cause a deviation in the progression of steps. For example, if step 2 fails, step 3 never gets reached, nor does step 2 retry, or move to an alternate error handling flow, and so on.</p>

<p>All of these issues are things you <em>can</em> manually hardcode into each step, but that code is often very repetitive and not reusable in other steps or in other async flows in your program.</p>

<p>Even though our brains might plan out a series of tasks in a sequential type of way (this, then this, then this), the evented nature of our brain operation makes recovery/retry/forking of flow control almost effortless. If you're out running errands, and you realize you left a shopping list at home, it doesn't end the day because you didn't plan that ahead of time. Your brain routes around this hiccup easily: you go home, get the list, then head right back out to the store.</p>

<p>But the brittle nature of manually hardcoded callbacks (even with hardcoded error handling) is often far less graceful. Once you end up specifying (aka pre-planning) all the various eventualities/paths, the code becomes so convoluted that it's hard to ever maintain or update it.</p>

<p><strong>That</strong> is what "callback hell" is all about! The nesting/indentation are basically a side show, a red herring.</p>

<p>And as if all that's not enough, we haven't even touched what happens when two or more chains of these callback continuations are happening <em>simultaneously</em>, or when the third step branches out into "parallel" callbacks with gates or latches, or... OMG, my brain hurts, how about yours!?</p>

<p>Are you catching the notion here that our sequential, blocking brain planning behaviors just don't map well onto callback-oriented async code? That's the first major deficiency to articulate about callbacks: they express asynchrony in code in ways our brains have to fight just to keep in sync with (pun intended!).</p>

<h2><a id="user-content-trust-issues" class="anchor" href="#trust-issues" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trust Issues</h2>

<p>The mismatch between sequential brain planning and callback-driven async JS code is only part of the problem with callbacks. There's something much deeper to be concerned about.</p>

<p>Let's once again revisit the notion of a callback function as the continuation (aka the second half) of our program:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// A</span>
ajax( <span class="pl-s"><span class="pl-pds">"</span>..<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(..){
    <span class="pl-c">// C</span>
} );
<span class="pl-c">// B</span></pre></div>

<p><code>// A</code> and <code>// B</code> happen <em>now</em>, under the direct control of the main JS program. But <code>// C</code> gets deferred to happen <em>later</em>, and under the control of another party -- in this case, the <code>ajax(..)</code> function. In a basic sense, that sort of hand-off of control doesn't regularly cause lots of problems for programs.</p>

<p>But don't be fooled by its infrequency that this control switch isn't a big deal. In fact, it's one of the worst (and yet most subtle) problems about callback-driven design. It revolves around the idea that sometimes <code>ajax(..)</code> (i.e., the "party" you hand your callback continuation to) is not a function that you wrote, or that you directly control. Many times it's a utility provided by some third party.</p>

<p>We call this "inversion of control," when you take part of your program and give over control of its execution to another third party. There's an unspoken "contract" that exists between your code and the third-party utility -- a set of things you expect to be maintained.</p>

<h3><a id="user-content-tale-of-five-callbacks" class="anchor" href="#tale-of-five-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tale of Five Callbacks</h3>

<p>It might not be terribly obvious why this is such a big deal. Let me construct an exaggerated scenario to illustrate the hazards of trust at play.</p>

<p>Imagine you're a developer tasked with building out an ecommerce checkout system for a site that sells expensive TVs. You already have all the various pages of the checkout system built out just fine. On the last page, when the user clicks "confirm" to buy the TV, you need to call a third-party function (provided say by some analytics tracking company) so that the sale can be tracked.</p>

<p>You notice that they've provided what looks like an async tracking utility, probably for the sake of performance best practices, which means you need to pass in a callback function. In this continuation that you pass in, you will have the final code that charges the customer's credit card and displays the thank you page.</p>

<p>This code might look like:</p>

<div class="highlight highlight-js"><pre>analytics.trackPurchase( purchaseData, <span class="pl-k">function</span>(){
    chargeCreditCard();
    displayThankyouPage();
} );</pre></div>

<p>Easy enough, right? You write the code, test it, everything works, and you deploy to production. Everyone's happy!</p>

<p>Six months go by and no issues. You've almost forgotten you even wrote that code. One morning, you're at a coffee shop before work, casually enjoying your latte, when you get a panicked call from your boss insisting you drop the coffee and rush into work right away.</p>

<p>When you arrive, you find out that a high-profile customer has had his credit card charged five times for the same TV, and he's understandably upset. Customer service has already issued an apology and processed a refund. But your boss demands to know how this could possibly have happened. "Don't we have tests for stuff like this!?"</p>

<p>You don't even remember the code you wrote. But you dig back in and start trying to find out what could have gone awry.</p>

<p>After digging through some logs, you come to the conclusion that the only explanation is that the analytics utility somehow, for some reason, called your callback five times instead of once. Nothing in their documentation mentions anything about this.</p>

<p>Frustrated, you contact customer support, who of course is as astonished as you are. They agree to escalate it to their developers, and promise to get back to you. The next day, you receive a lengthy email explaining what they found, which you promptly forward to your boss.</p>

<p>Apparently, the developers at the analytics company had been working on some experimental code that, under certain conditions, would retry the provided callback once per second, for five seconds, before failing with a timeout. They had never intended to push that into production, but somehow they did, and they're totally embarrassed and apologetic. They go into plenty of detail about how they've identified the breakdown and what they'll do to ensure it never happens again. Yadda, yadda.</p>

<p>What's next?</p>

<p>You talk it over with your boss, but he's not feeling particularly comfortable with the state of things. He insists, and you reluctantly agree, that you can't trust <em>them</em> anymore (that's what bit you), and that you'll need to figure out how to protect the checkout code from such a vulnerability again.</p>

<p>After some tinkering, you implement some simple ad hoc code like the following, which the team seems happy with:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> tracked <span class="pl-k">=</span> <span class="pl-c1">false</span>;

analytics.trackPurchase( purchaseData, <span class="pl-k">function</span>(){
    <span class="pl-k">if</span> (<span class="pl-k">!</span>tracked) {
        tracked <span class="pl-k">=</span> <span class="pl-c1">true</span>;
        chargeCreditCard();
        displayThankyouPage();
    }
} );</pre></div>

<p><strong>Note:</strong> This should look familiar to you from Chapter 1, because we're essentially creating a latch to handle if there happen to be multiple concurrent invocations of our callback.</p>

<p>But then one of your QA engineers asks, "what happens if they never call the callback?" Oops. Neither of you had thought about that.</p>

<p>You begin to chase down the rabbit hole, and think of all the possible things that could go wrong with them calling your callback. Here's roughly the list you come up with of ways the analytics utility could misbehave:</p>

<ul>
<li>Call the callback too early (before it's been tracked)</li>
<li>Call the callback too late (or never)</li>
<li>Call the callback too few or too many times (like the problem you encountered!)</li>
<li>Fail to pass along any necessary environment/parameters to your callback</li>
<li>Swallow any errors/exceptions that may happen</li>
<li>...</li>
</ul>

<p>That should feel like a troubling list, because it is. You're probably slowly starting to realize that you're going to have to invent an awful lot of ad hoc logic <strong>in each and every single callback</strong> that's passed to a utility you're not positive you can trust.</p>

<p>Now you realize a bit more completely just how hellish "callback hell" is.</p>

<h3><a id="user-content-not-just-others-code" class="anchor" href="#not-just-others-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not Just Others' Code</h3>

<p>Some of you may be skeptical at this point whether this is as big a deal as I'm making it out to be. Perhaps you don't interact with truly third-party utilities much if at all. Perhaps you use versioned APIs or self-host such libraries, so that its behavior can't be changed out from underneath you.</p>

<p>So, contemplate this: can you even <em>really</em> trust utilities that you do theoretically control (in your own code base)?</p>

<p>Think of it this way: most of us agree that at least to some extent we should build our own internal functions with some defensive checks on the input parameters, to reduce/prevent unexpected issues.</p>

<p>Overly trusting of input:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">addNumbers</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-c">// + is overloaded with coercion to also be</span>
    <span class="pl-c">// string concatenation, so this operation</span>
    <span class="pl-c">// isn't strictly safe depending on what's</span>
    <span class="pl-c">// passed in.</span>
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

addNumbers( <span class="pl-c1">21</span>, <span class="pl-c1">21</span> );   <span class="pl-c">// 42</span>
addNumbers( <span class="pl-c1">21</span>, <span class="pl-s"><span class="pl-pds">"</span>21<span class="pl-pds">"</span></span> ); <span class="pl-c">// "2121"</span></pre></div>

<p>Defensive against untrusted input:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">addNumbers</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-c">// ensure numerical input</span>
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> x <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span> <span class="pl-k">||</span> <span class="pl-k">typeof</span> y <span class="pl-k">!=</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
        <span class="pl-k">throw</span> Error( <span class="pl-s"><span class="pl-pds">"</span>Bad parameters<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// if we get here, + will safely do numeric addition</span>
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

addNumbers( <span class="pl-c1">21</span>, <span class="pl-c1">21</span> );   <span class="pl-c">// 42</span>
addNumbers( <span class="pl-c1">21</span>, <span class="pl-s"><span class="pl-pds">"</span>21<span class="pl-pds">"</span></span> ); <span class="pl-c">// Error: "Bad parameters"</span></pre></div>

<p>Or perhaps still safe but friendlier:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">addNumbers</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-c">// ensure numerical input</span>
    x <span class="pl-k">=</span> <span class="pl-c1">Number</span>( x );
    y <span class="pl-k">=</span> <span class="pl-c1">Number</span>( y );

    <span class="pl-c">// + will safely do numeric addition</span>
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

addNumbers( <span class="pl-c1">21</span>, <span class="pl-c1">21</span> );   <span class="pl-c">// 42</span>
addNumbers( <span class="pl-c1">21</span>, <span class="pl-s"><span class="pl-pds">"</span>21<span class="pl-pds">"</span></span> ); <span class="pl-c">// 42</span></pre></div>

<p>However you go about it, these sorts of checks/normalizations are fairly common on function inputs, even with code we theoretically entirely trust. In a crude sort of way, it's like the programming equivalent of the geopolitical principle of "Trust But Verify."</p>

<p>So, doesn't it stand to reason that we should do the same thing about composition of async function callbacks, not just with truly external code but even with code we know is generally "under our own control"? <strong>Of course we should.</strong></p>

<p>But callbacks don't really offer anything to assist us. We have to construct all that machinery ourselves, and it often ends up being a lot of boilerplate/overhead that we repeat for every single async callback.</p>

<p>The most troublesome problem with callbacks is <em>inversion of control</em> leading to a complete breakdown along all those trust lines.</p>

<p>If you have code that uses callbacks, especially but not exclusively with third-party utilities, and you're not already applying some sort of mitigation logic for all these <em>inversion of control</em> trust issues, your code <em>has</em> bugs in it right now even though they may not have bitten you yet. Latent bugs are still bugs.</p>

<p>Hell indeed.</p>

<h2><a id="user-content-trying-to-save-callbacks" class="anchor" href="#trying-to-save-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trying to Save Callbacks</h2>

<p>There are several variations of callback design that have attempted to address some (not all!) of the trust issues we've just looked at. It's a valiant, but doomed, effort to save the callback pattern from imploding on itself.</p>

<p>For example, regarding more graceful error handling, some API designs provide for split callbacks (one for the success notification, one for the error notification):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">success</span>(<span class="pl-smi">data</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( data );
}

<span class="pl-k">function</span> <span class="pl-en">failure</span>(<span class="pl-smi">err</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
}

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, success, failure );</pre></div>

<p>In APIs of this design, often the <code>failure()</code> error handler is optional, and if not provided it will be assumed you want the errors swallowed. Ugh.</p>

<p><strong>Note:</strong> This split-callback design is what the ES6 Promise API uses. We'll cover ES6 Promises in much more detail in the next chapter.</p>

<p>Another common callback pattern is called "error-first style" (sometimes called "Node style," as it's also the convention used across nearly all Node.js APIs), where the first argument of a single callback is reserved for an error object (if any). If success, this argument will be empty/falsy (and any subsequent arguments will be the success data), but if an error result is being signaled, the first argument is set/truthy (and usually nothing else is passed):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">err</span>,<span class="pl-smi">data</span>) {
    <span class="pl-c">// error?</span>
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
    <span class="pl-c">// otherwise, assume success</span>
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( data );
    }
}

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, response );</pre></div>

<p>In both of these cases, several things should be observed.</p>

<p>First, it has not really resolved the majority of trust issues like it may appear. There's nothing about either callback that prevents or filters unwanted repeated invocations. Moreover, things are worse now, because you may get both success and error signals, or neither, and you still have to code around either of those conditions.</p>

<p>Also, don't miss the fact that while it's a standard pattern you can employ, it's definitely more verbose and boilerplate-ish without much reuse, so you're going to get weary of typing all that out for every single callback in your application.</p>

<p>What about the trust issue of never being called? If this is a concern (and it probably should be!), you likely will need to set up a timeout that cancels the event. You could make a utility (proof-of-concept only shown) to help you with that:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">timeoutify</span>(<span class="pl-smi">fn</span>,<span class="pl-smi">delay</span>) {
    <span class="pl-k">var</span> intv <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            intv <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            fn( <span class="pl-k">new</span> <span class="pl-en">Error</span>( <span class="pl-s"><span class="pl-pds">"</span>Timeout!<span class="pl-pds">"</span></span> ) );
        }, delay )
    ;

    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// timeout hasn't happened yet?</span>
        <span class="pl-k">if</span> (intv) {
            <span class="pl-c1">clearTimeout</span>( intv );
            fn.<span class="pl-c1">apply</span>( <span class="pl-v">this</span>, arguments );
        }
    };
}</pre></div>

<p>Here's how you use it:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// using "error-first style" callback design</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">err</span>,<span class="pl-smi">data</span>) {
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( data );
    }
}

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, timeoutify( foo, <span class="pl-c1">500</span> ) );</pre></div>

<p>Another trust issue is being called "too early." In application-specific terms, this may actually involve being called before some critical task is complete. But more generally, the problem is evident in utilities that can either invoke the callback you provide <em>now</em> (synchronously), or <em>later</em> (asynchronously).</p>

<p>This nondeterminism around the sync-or-async behavior is almost always going to lead to very difficult to track down bugs. In some circles, the fictional insanity-inducing monster named Zalgo is used to describe the sync/async nightmares. "Don't release Zalgo!" is a common cry, and it leads to very sound advice: always invoke callbacks asynchronously, even if that's "right away" on the next turn of the event loop, so that all callbacks are predictably async.</p>

<p><strong>Note:</strong> For more information on Zalgo, see Oren Golan's "Don't Release Zalgo!" (<a href="https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md">https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md</a>) and Isaac Z. Schlueter's "Designing APIs for Asynchrony" (<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony</a>).</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">result</span>(<span class="pl-smi">data</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">0</span>;

ajax( <span class="pl-s"><span class="pl-pds">"</span>..pre-cached-url..<span class="pl-pds">"</span></span>, result );
a<span class="pl-k">++</span>;</pre></div>

<p>Will this code print <code>0</code> (sync callback invocation) or <code>1</code> (async callback invocation)? Depends... on the conditions.</p>

<p>You can see just how quickly the unpredictability of Zalgo can threaten any JS program. So the silly-sounding "never release Zalgo" is actually incredibly common and solid advice. Always be asyncing.</p>

<p>What if you don't know whether the API in question will always execute async? You could invent a utility like this <code>asyncify(..)</code> proof-of-concept:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">asyncify</span>(<span class="pl-smi">fn</span>) {
    <span class="pl-k">var</span> orig_fn <span class="pl-k">=</span> fn,
        intv <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            intv <span class="pl-k">=</span> <span class="pl-c1">null</span>;
            <span class="pl-k">if</span> (fn) fn();
        }, <span class="pl-c1">0</span> )
    ;

    fn <span class="pl-k">=</span> <span class="pl-c1">null</span>;

    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// firing too quickly, before `intv` timer has fired to</span>
        <span class="pl-c">// indicate async turn has passed?</span>
        <span class="pl-k">if</span> (intv) {
            fn <span class="pl-k">=</span> orig_fn.bind.<span class="pl-c1">apply</span>(
                orig_fn,
                <span class="pl-c">// add the wrapper's `this` to the `bind(..)`</span>
                <span class="pl-c">// call parameters, as well as currying any</span>
                <span class="pl-c">// passed in parameters</span>
                [<span class="pl-v">this</span>].<span class="pl-c1">concat</span>( [].slice.<span class="pl-c1">call</span>( arguments ) )
            );
        }
        <span class="pl-c">// already async</span>
        <span class="pl-k">else</span> {
            <span class="pl-c">// invoke original function</span>
            orig_fn.<span class="pl-c1">apply</span>( <span class="pl-v">this</span>, arguments );
        }
    };
}</pre></div>

<p>You use <code>asyncify(..)</code> like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">result</span>(<span class="pl-smi">data</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">0</span>;

ajax( <span class="pl-s"><span class="pl-pds">"</span>..pre-cached-url..<span class="pl-pds">"</span></span>, asyncify( result ) );
a<span class="pl-k">++</span>;</pre></div>

<p>Whether the Ajax request is in the cache and resolves to try to call the callback right away, or must be fetched over the wire and thus complete later asynchronously, this code will always output <code>1</code> instead of <code>0</code> -- <code>result(..)</code> cannot help but be invoked asynchronously, which means the <code>a++</code> has a chance to run before <code>result(..)</code> does.</p>

<p>Yay, another trust issued "solved"! But it's inefficient, and yet again more bloated boilerplate to weigh your project down.</p>

<p>That's just the story, over and over again, with callbacks. They can do pretty much anything you want, but you have to be willing to work hard to get it, and oftentimes this effort is much more than you can or should spend on such code reasoning.</p>

<p>You might find yourself wishing for built-in APIs or other language mechanics to address these issues. Finally ES6 has arrived on the scene with some great answers, so keep reading!</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Callbacks are the fundamental unit of asynchrony in JS. But they're not enough for the evolving landscape of async programming as JS matures.</p>

<p>First, our brains plan things out in sequential, blocking, single-threaded semantic ways, but callbacks express asynchronous flow in a rather nonlinear, nonsequential way, which makes reasoning properly about such code much harder. Bad to reason about code is bad code that leads to bad bugs.</p>

<p>We need a way to express asynchrony in a more synchronous, sequential, blocking manner, just like our brains do.</p>

<p>Second, and more importantly, callbacks suffer from <em>inversion of control</em> in that they implicitly give control over to another party (often a third-party utility not in your control!) to invoke the <em>continuation</em> of your program. This control transfer leads us to a troubling list of trust issues, such as whether the callback is called more times than we expect.</p>

<p>Inventing ad hoc logic to solve these trust issues is possible, but it's more difficult than it should be, and it produces clunkier and harder to maintain code, as well as code that is likely insufficiently protected from these hazards until you get visibly bitten by the bugs.</p>

<p>We need a generalized solution to <strong>all of the trust issues</strong>, one that can be reused for as many callbacks as we create without all the extra boilerplate overhead.</p>

<p>We need something better than callbacks. They've served us well to this point, but the <em>future</em> of JavaScript demands more sophisticated and capable async patterns. The subsequent chapters in this book will dive into those emerging evolutions.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-async--performance" class="anchor" href="#you-dont-know-js-async--performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Async &amp; Performance</h1>

<h1><a id="user-content-chapter-3-promises" class="anchor" href="#chapter-3-promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3: Promises</h1>

<p>In Chapter 2, we identified two major categories of deficiencies with using callbacks to express program asynchrony and manage concurrency: lack of sequentiality and lack of trustability. Now that we understand the problems more intimately, it's time we turn our attention to patterns that can address them.</p>

<p>The issue we want to address first is the <em>inversion of control</em>, the trust that is so fragilely held and so easily lost.</p>

<p>Recall that we wrap up the <em>continuation</em> of our program in a callback function, and hand that callback over to another party (potentially even external code) and just cross our fingers that it will do the right thing with the invocation of the callback.</p>

<p>We do this because we want to say, "here's what happens <em>later</em>, after the current step finishes."</p>

<p>But what if we could uninvert that <em>inversion of control</em>? What if instead of handing the continuation of our program to another party, we could expect it to return us a capability to know when its task finishes, and then our code could decide what to do next?</p>

<p>This paradigm is called <strong>Promises</strong>.</p>

<p>Promises are starting to take the JS world by storm, as developers and specification writers alike desperately seek to untangle the insanity of callback hell in their code/design. In fact, most new async APIs being added to JS/DOM platform are being built on Promises. So it's probably a good idea to dig in and learn them, don't you think!?</p>

<p><strong>Note:</strong> The word "immediately" will be used frequently in this chapter, generally to refer to some Promise resolution action. However, in essentially all cases, "immediately" means in terms of the Job queue behavior (see Chapter 1), not in the strictly synchronous <em>now</em> sense.</p>

<h2><a id="user-content-what-is-a-promise" class="anchor" href="#what-is-a-promise" aria-hidden="true"><span class="octicon octicon-link"></span></a>What Is a Promise?</h2>

<p>When developers decide to learn a new technology or pattern, usually their first step is "Show me the code!" It's quite natural for us to just jump in feet first and learn as we go.</p>

<p>But it turns out that some abstractions get lost on the APIs alone. Promises are one of those tools where it can be painfully obvious from how someone uses it whether they understand what it's for and about versus just learning and using the API.</p>

<p>So before I show the Promise code, I want to fully explain what a Promise really is conceptually. I hope this will then guide you better as you explore integrating Promise theory into your own async flow.</p>

<p>With that in mind, let's look at two different analogies for what a Promise <em>is</em>.</p>

<h3><a id="user-content-future-value" class="anchor" href="#future-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Value</h3>

<p>Imagine this scenario: I walk up to the counter at a fast-food restaurant, and place an order for a cheeseburger. I hand the cashier $1.47. By placing my order and paying for it, I've made a request for a <em>value</em> back (the cheeseburger). I've started a transaction.</p>

<p>But often, the cheeseburger is not immediately available for me. The cashier hands me something in place of my cheeseburger: a receipt with an order number on it. This order number is an IOU ("I owe you") <em>promise</em> that ensures that eventually, I should receive my cheeseburger.</p>

<p>So I hold onto my receipt and order number. I know it represents my <em>future cheeseburger</em>, so I don't need to worry about it anymore -- aside from being hungry!</p>

<p>While I wait, I can do other things, like send a text message to a friend that says, "Hey, can you come join me for lunch? I'm going to eat a cheeseburger."</p>

<p>I am reasoning about my <em>future cheeseburger</em> already, even though I don't have it in my hands yet. My brain is able to do this because it's treating the order number as a placeholder for the cheeseburger. The placeholder essentially makes the value <em>time independent</em>. It's a <strong>future value</strong>.</p>

<p>Eventually, I hear, "Order 113!" and I gleefully walk back up to the counter with receipt in hand. I hand my receipt to the cashier, and I take my cheeseburger in return.</p>

<p>In other words, once my <em>future value</em> was ready, I exchanged my value-promise for the value itself.</p>

<p>But there's another possible outcome. They call my order number, but when I go to retrieve my cheeseburger, the cashier regretfully informs me, "I'm sorry, but we appear to be all out of cheeseburgers." Setting aside the customer frustration of this scenario for a moment, we can see an important characteristic of <em>future values</em>: they can either indicate a success or failure.</p>

<p>Every time I order a cheeseburger, I know that I'll either get a cheeseburger eventually, or I'll get the sad news of the cheeseburger shortage, and I'll have to figure out something else to eat for lunch.</p>

<p><strong>Note:</strong> In code, things are not quite as simple, because metaphorically the order number may never be called, in which case we're left indefinitely in an unresolved state. We'll come back to dealing with that case later.</p>

<h4><a id="user-content-values-now-and-later" class="anchor" href="#values-now-and-later" aria-hidden="true"><span class="octicon octicon-link"></span></a>Values Now and Later</h4>

<p>This all might sound too mentally abstract to apply to your code. So let's be more concrete.</p>

<p>However, before we can introduce how Promises work in this fashion, we're going to derive in code that we already understand -- callbacks! -- how to handle these <em>future values</em>.</p>

<p>When you write code to reason about a value, such as performing math on a <code>number</code>, whether you realize it or not, you've been assuming something very fundamental about that value, which is that it's a concrete <em>now</em> value already:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> x, y <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y ); <span class="pl-c">// NaN  &lt;-- because `x` isn't set yet</span></pre></div>

<p>The <code>x + y</code> operation assumes both <code>x</code> and <code>y</code> are already set. In terms we'll expound on shortly, we assume the <code>x</code> and <code>y</code> values are already <em>resolved</em>.</p>

<p>It would be nonsense to expect that the <code>+</code> operator by itself would somehow be magically capable of detecting and waiting around until both <code>x</code> and <code>y</code> are resolved (aka ready), only then to do the operation. That would cause chaos in the program if different statements finished <em>now</em> and others finished <em>later</em>, right?</p>

<p>How could you possibly reason about the relationships between two statements if either one (or both) of them might not be finished yet? If statement 2 relies on statement 1 being finished, there are just two outcomes: either statement 1 finished right <em>now</em> and everything proceeds fine, or statement 1 didn't finish yet, and thus statement 2 is going to fail.</p>

<p>If this sort of thing sounds familiar from Chapter 1, good!</p>

<p>Let's go back to our <code>x + y</code> math operation. Imagine if there was a way to say, "Add <code>x</code> and <code>y</code>, but if either of them isn't ready yet, just wait until they are. Add them as soon as you can."</p>

<p>Your brain might have just jumped to callbacks. OK, so...</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">getX</span>,<span class="pl-smi">getY</span>,<span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> x, y;
    getX( <span class="pl-k">function</span>(<span class="pl-smi">xVal</span>){
        x <span class="pl-k">=</span> xVal;
        <span class="pl-c">// both are ready?</span>
        <span class="pl-k">if</span> (y <span class="pl-k">!=</span> <span class="pl-c1">undefined</span>) {
            cb( x <span class="pl-k">+</span> y );    <span class="pl-c">// send along sum</span>
        }
    } );
    getY( <span class="pl-k">function</span>(<span class="pl-smi">yVal</span>){
        y <span class="pl-k">=</span> yVal;
        <span class="pl-c">// both are ready?</span>
        <span class="pl-k">if</span> (x <span class="pl-k">!=</span> <span class="pl-c1">undefined</span>) {
            cb( x <span class="pl-k">+</span> y );    <span class="pl-c">// send along sum</span>
        }
    } );
}

<span class="pl-c">// `fetchX()` and `fetchY()` are sync or async</span>
<span class="pl-c">// functions</span>
<span class="pl-c1">add</span>( fetchX, fetchY, <span class="pl-k">function</span>(<span class="pl-smi">sum</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum ); <span class="pl-c">// that was easy, huh?</span>
} );</pre></div>

<p>Take just a moment to let the beauty (or lack thereof) of that snippet sink in (whistles patiently).</p>

<p>While the ugliness is undeniable, there's something very important to notice about this async pattern.</p>

<p>In that snippet, we treated <code>x</code> and <code>y</code> as future values, and we express an operation <code>add(..)</code> that (from the outside) does not care whether <code>x</code> or <code>y</code> or both are available right away or not. In other words, it normalizes the <em>now</em> and <em>later</em>, such that we can rely on a predictable outcome of the <code>add(..)</code> operation.</p>

<p>By using an <code>add(..)</code> that is temporally consistent -- it behaves the same across <em>now</em> and <em>later</em> times -- the async code is much easier to reason about.</p>

<p>To put it more plainly: to consistently handle both <em>now</em> and <em>later</em>, we make both of them <em>later</em>: all operations become async.</p>

<p>Of course, this rough callbacks-based approach leaves much to be desired. It's just a first tiny step toward realizing the benefits of reasoning about <em>future values</em> without worrying about the time aspect of when it's available or not.</p>

<h4><a id="user-content-promise-value" class="anchor" href="#promise-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Value</h4>

<p>We'll definitely go into a lot more detail about Promises later in the chapter -- so don't worry if some of this is confusing -- but let's just briefly glimpse at how we can express the <code>x + y</code> example via <code>Promise</code>s:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">xPromise</span>,<span class="pl-smi">yPromise</span>) {
    <span class="pl-c">// `Promise.all([ .. ])` takes an array of promises,</span>
    <span class="pl-c">// and returns a new promise that waits on them</span>
    <span class="pl-c">// all to finish</span>
    <span class="pl-k">return</span> Promise.<span class="pl-c1">all</span>( [xPromise, yPromise] )

    <span class="pl-c">// when that promise is resolved, let's take the</span>
    <span class="pl-c">// received `X` and `Y` values and add them together.</span>
    .then( <span class="pl-k">function</span>(<span class="pl-smi">values</span>){
        <span class="pl-c">// `values` is an array of the messages from the</span>
        <span class="pl-c">// previously resolved promises</span>
        <span class="pl-k">return</span> values[<span class="pl-c1">0</span>] <span class="pl-k">+</span> values[<span class="pl-c1">1</span>];
    } );
}

<span class="pl-c">// `fetchX()` and `fetchY()` return promises for</span>
<span class="pl-c">// their respective values, which may be ready</span>
<span class="pl-c">// *now* or *later*.</span>
<span class="pl-c1">add</span>( fetchX(), fetchY() )

<span class="pl-c">// we get a promise back for the sum of those</span>
<span class="pl-c">// two numbers.</span>
<span class="pl-c">// now we chain-call `then(..)` to wait for the</span>
<span class="pl-c">// resolution of that returned promise.</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum ); <span class="pl-c">// that was easier!</span>
} );</pre></div>

<p>There are two layers of Promises in this snippet.</p>

<p><code>fetchX()</code> and <code>fetchY()</code> are called directly, and the values they return (promises!) are passed into <code>add(..)</code>. The underlying values those promises represent may be ready <em>now</em> or <em>later</em>, but each promise normalizes the behavior to be the same regardless. We reason about <code>X</code> and <code>Y</code> values in a time-independent way. They are <em>future values</em>.</p>

<p>The second layer is the promise that <code>add(..)</code> creates (via <code>Promise.all([ .. ])</code>) and returns, which we wait on by calling <code>then(..)</code>. When the <code>add(..)</code> operation completes, our <code>sum</code> <em>future value</em> is ready and we can print it out. We hide inside of <code>add(..)</code> the logic for waiting on the <code>X</code> and <code>Y</code> <em>future values</em>.</p>

<p><strong>Note:</strong> Inside <code>add(..)</code>, the <code>Promise.all([ .. ])</code> call creates a promise (which is waiting on <code>promiseX</code> and <code>promiseY</code> to resolve). The chained call to <code>.then(..)</code> creates another promise, which the <code>return values[0] + values[1]</code> line immediately resolves (with the result of the addition). Thus, the <code>then(..)</code> call we chain off the end of the <code>add(..)</code> call -- at the end of the snippet -- is actually operating on that second promise returned, rather than the first one created by <code>Promise.all([ .. ])</code>. Also, though we are not chaining off the end of that second <code>then(..)</code>, it too has created another promise, had we chosen to observe/use it. This Promise chaining stuff will be explained in much greater detail later in this chapter.</p>

<p>Just like with cheeseburger orders, it's possible that the resolution of a Promise is rejection instead of fulfillment. Unlike a fulfilled Promise, where the value is always programmatic, a rejection value -- commonly called a "rejection reason" -- can either be set directly by the program logic, or it can result implicitly from a runtime exception.</p>

<p>With Promises, the <code>then(..)</code> call can actually take two functions, the first for fulfillment (as shown earlier), and the second for rejection:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">add</span>( fetchX(), fetchY() )
.then(
    <span class="pl-c">// fullfillment handler</span>
    <span class="pl-k">function</span>(<span class="pl-smi">sum</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );
    },
    <span class="pl-c">// rejection handler</span>
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err ); <span class="pl-c">// bummer!</span>
    }
);</pre></div>

<p>If something went wrong getting <code>X</code> or <code>Y</code>, or something somehow failed during the addition, the promise that <code>add(..)</code> returns is rejected, and the second callback error handler passed to <code>then(..)</code> will receive the rejection value from the promise.</p>

<p>Because Promises encapsulate the time-dependent state -- waiting on the fulfillment or rejection of the underlying value -- from the outside, the Promise itself is time-independent, and thus Promises can be composed (combined) in predictable ways regardless of the timing or outcome underneath.</p>

<p>Moreover, once a Promise is resolved, it stays that way forever -- it becomes an <em>immutable value</em> at that point -- and can then be <em>observed</em> as many times as necessary.</p>

<p><strong>Note:</strong> Because a Promise is externally immutable once resolved, it's now safe to pass that value around to any party and know that it cannot be modified accidentally or maliciously. This is especially true in relation to multiple parties observing the resolution of a Promise. It is not possible for one party to affect another party's ability to observe Promise resolution. Immutability may sound like an academic topic, but it's actually one of the most fundamental and important aspects of Promise design, and shouldn't be casually passed over.</p>

<p>That's one of the most powerful and important concepts to understand about Promises. With a fair amount of work, you could ad hoc create the same effects with nothing but ugly callback composition, but that's not really an effective strategy, especially because you have to do it over and over again.</p>

<p>Promises are an easily repeatable mechanism for encapsulating and composing <em>future values</em>.</p>

<h3><a id="user-content-completion-event" class="anchor" href="#completion-event" aria-hidden="true"><span class="octicon octicon-link"></span></a>Completion Event</h3>

<p>As we just saw, an individual Promise behaves as a <em>future value</em>. But there's another way to think of the resolution of a Promise: as a flow-control mechanism -- a temporal this-then-that -- for two or more steps in an asynchronous task.</p>

<p>Let's imagine calling a function <code>foo(..)</code> to perform some task. We don't know about any of its details, nor do we care. It may complete the task right away, or it may take a while.</p>

<p>We just simply need to know when <code>foo(..)</code> finishes so that we can move on to our next task. In other words, we'd like a way to be notified of <code>foo(..)</code>'s completion so that we can <em>continue</em>.</p>

<p>In typical JavaScript fashion, if you need to listen for a notification, you'd likely think of that in terms of events. So we could reframe our need for notification as a need to listen for a <em>completion</em> (or <em>continuation</em>) event emitted by <code>foo(..)</code>.</p>

<p><strong>Note:</strong> Whether you call it a "completion event" or a "continuation event" depends on your perspective. Is the focus more on what happens with <code>foo(..)</code>, or what happens <em>after</em> <code>foo(..)</code> finishes? Both perspectives are accurate and useful. The event notification tells us that <code>foo(..)</code> has <em>completed</em>, but also that it's OK to <em>continue</em> with the next step. Indeed, the callback you pass to be called for the event notification is itself what we've previously called a <em>continuation</em>. Because <em>completion event</em> is a bit more focused on the <code>foo(..)</code>, which more has our attention at present, we slightly favor <em>completion event</em> for the rest of this text.</p>

<p>With callbacks, the "notification" would be our callback invoked by the task (<code>foo(..)</code>). But with Promises, we turn the relationship around, and expect that we can listen for an event from <code>foo(..)</code>, and when notified, proceed accordingly.</p>

<p>First, consider some pseudocode:</p>

<div class="highlight highlight-js"><pre><span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// start doing something that could take a while</span>
}

foo( <span class="pl-c1">42</span> )

<span class="pl-en">on</span> (<span class="pl-smi">foo</span> <span class="pl-s"><span class="pl-pds">"</span>completion<span class="pl-pds">"</span></span>) {
    <span class="pl-c">// now we can do the next step!</span>
}

<span class="pl-en">on</span> (<span class="pl-smi">foo</span> <span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>) {
    <span class="pl-c">// oops, something went wrong in `foo(..)`</span>
}</pre></div>

<p>We call <code>foo(..)</code> and then we set up two event listeners, one for <code>"completion"</code> and one for <code>"error"</code> -- the two possible <em>final</em> outcomes of the <code>foo(..)</code> call. In essence, <code>foo(..)</code> doesn't even appear to be aware that the calling code has subscribed to these events, which makes for a very nice <em>separation of concerns</em>.</p>

<p>Unfortunately, such code would require some "magic" of the JS environment that doesn't exist (and would likely be a bit impractical). Here's the more natural way we could express that in JS:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// start doing something that could take a while</span>

    <span class="pl-c">// make a `listener` event notification</span>
    <span class="pl-c">// capability to return</span>

    <span class="pl-k">return</span> listener;
}

<span class="pl-k">var</span> evt <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

evt.on( <span class="pl-s"><span class="pl-pds">"</span>completion<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
    <span class="pl-c">// now we can do the next step!</span>
} );

evt.on( <span class="pl-s"><span class="pl-pds">"</span>failure<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
    <span class="pl-c">// oops, something went wrong in `foo(..)`</span>
} );</pre></div>

<p><code>foo(..)</code> expressly creates an event subscription capability to return back, and the calling code receives and registers the two event handlers against it.</p>

<p>The inversion from normal callback-oriented code should be obvious, and it's intentional. Instead of passing the callbacks to <code>foo(..)</code>, it returns an event capability we call <code>evt</code>, which receives the callbacks.</p>

<p>But if you recall from Chapter 2, callbacks themselves represent an <em>inversion of control</em>. So inverting the callback pattern is actually an <em>inversion of inversion</em>, or an <em>uninversion of control</em> -- restoring control back to the calling code where we wanted it to be in the first place.</p>

<p>One important benefit is that multiple separate parts of the code can be given the event listening capability, and they can all independently be notified of when <code>foo(..)</code> completes to perform subsequent steps after its completion:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> evt <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

<span class="pl-c">// let `bar(..)` listen to `foo(..)`'s completion</span>
bar( evt );

<span class="pl-c">// also, let `baz(..)` listen to `foo(..)`'s completion</span>
baz( evt );</pre></div>

<p><em>Uninversion of control</em> enables a nicer <em>separation of concerns</em>, where <code>bar(..)</code> and <code>baz(..)</code> don't need to be involved in how <code>foo(..)</code> is called. Similarly, <code>foo(..)</code> doesn't need to know or care that <code>bar(..)</code> and <code>baz(..)</code> exist or are waiting to be notified when <code>foo(..)</code> completes.</p>

<p>Essentially, this <code>evt</code> object is a neutral third-party negotiation between the separate concerns.</p>

<h4><a id="user-content-promise-events" class="anchor" href="#promise-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise "Events"</h4>

<p>As you may have guessed by now, the <code>evt</code> event listening capability is an analogy for a Promise.</p>

<p>In a Promise-based approach, the previous snippet would have <code>foo(..)</code> creating and returning a <code>Promise</code> instance, and that promise would then be passed to <code>bar(..)</code> and <code>baz(..)</code>.</p>

<p><strong>Note:</strong> The Promise resolution "events" we listen for aren't strictly events (though they certainly behave like events for these purposes), and they're not typically called <code>"completion"</code> or <code>"error"</code>. Instead, we use <code>then(..)</code> to register a <code>"then"</code> event. Or perhaps more precisely, <code>then(..)</code> registers <code>"fulfillment"</code> and/or <code>"rejection"</code> event(s), though we don't see those terms used explicitly in the code.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// start doing something that could take a while</span>

    <span class="pl-c">// construct and return a promise</span>
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// eventually, call `resolve(..)` or `reject(..)`,</span>
        <span class="pl-c">// which are the resolution callbacks for</span>
        <span class="pl-c">// the promise.</span>
    } );
}

<span class="pl-k">var</span> p <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

bar( p );

baz( p );</pre></div>

<p><strong>Note:</strong> The pattern shown with <code>new Promise( function(..){ .. } )</code> is generally called the <a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/">"revealing constructor"</a>. The function passed in is executed immediately (not async deferred, as callbacks to <code>then(..)</code> are), and it's provided two parameters, which in this case we've named <code>resolve</code> and <code>reject</code>. These are the resolution functions for the promise. <code>resolve(..)</code> generally signals fulfillment, and <code>reject(..)</code> signals rejection.</p>

<p>You can probably guess what the internals of <code>bar(..)</code> and <code>baz(..)</code> might look like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">fooPromise</span>) {
    <span class="pl-c">// listen for `foo(..)` to complete</span>
    fooPromise.then(
        <span class="pl-k">function</span>(){
            <span class="pl-c">// `foo(..)` has now finished, so</span>
            <span class="pl-c">// do `bar(..)`'s task</span>
        },
        <span class="pl-k">function</span>(){
            <span class="pl-c">// oops, something went wrong in `foo(..)`</span>
        }
    );
}

<span class="pl-c">// ditto for `baz(..)`</span></pre></div>

<p>Promise resolution doesn't necessarily need to involve sending along a message, as it did when we were examining Promises as <em>future values</em>. It can just be a flow-control signal, as used in the previous snippet.</p>

<p>Another way to approach this is:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// `foo(..)` has definitely finished, so</span>
    <span class="pl-c">// do `bar(..)`'s task</span>
}

<span class="pl-k">function</span> <span class="pl-en">oopsBar</span>() {
    <span class="pl-c">// oops, something went wrong in `foo(..)`,</span>
    <span class="pl-c">// so `bar(..)` didn't run</span>
}

<span class="pl-c">// ditto for `baz()` and `oopsBaz()`</span>

<span class="pl-k">var</span> p <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

p.then( bar, oopsBar );

p.then( baz, oopsBaz );</pre></div>

<p><strong>Note:</strong> If you've seen Promise-based coding before, you might be tempted to believe that the last two lines of that code could be written as <code>p.then( .. ).then( .. )</code>, using chaining, rather than <code>p.then(..); p.then(..)</code>. That would have an entirely different behavior, so be careful! The difference might not be clear right now, but it's actually a different async pattern than we've seen thus far: splitting/forking. Don't worry! We'll come back to this point later in this chapter.</p>

<p>Instead of passing the <code>p</code> promise to <code>bar(..)</code> and <code>baz(..)</code>, we use the promise to control when <code>bar(..)</code> and <code>baz(..)</code> will get executed, if ever. The primary difference is in the error handling.</p>

<p>In the first snippet's approach, <code>bar(..)</code> is called regardless of whether <code>foo(..)</code> succeeds or fails, and it handles its own fallback logic if it's notified that <code>foo(..)</code> failed. The same is true for <code>baz(..)</code>, obviously.</p>

<p>In the second snippet, <code>bar(..)</code> only gets called if <code>foo(..)</code> succeeds, and otherwise <code>oopsBar(..)</code> gets called. Ditto for <code>baz(..)</code>.</p>

<p>Neither approach is <em>correct</em> per se. There will be cases where one is preferred over the other.</p>

<p>In either case, the promise <code>p</code> that comes back from <code>foo(..)</code> is used to control what happens next.</p>

<p>Moreover, the fact that both snippets end up calling <code>then(..)</code> twice against the same promise <code>p</code> illustrates the point made earlier, which is that Promises (once resolved) retain their same resolution (fulfillment or rejection) forever, and can subsequently be observed as many times as necessary.</p>

<p>Whenever <code>p</code> is resolved, the next step will always be the same, both <em>now</em> and <em>later</em>.</p>

<h2><a id="user-content-thenable-duck-typing" class="anchor" href="#thenable-duck-typing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thenable Duck Typing</h2>

<p>In Promises-land, an important detail is how to know for sure if some value is a genuine Promise or not. Or more directly, is it a value that will behave like a Promise?</p>

<p>Given that Promises are constructed by the <code>new Promise(..)</code> syntax, you might think that <code>p instanceof Promise</code> would be an acceptable check. But unfortunately, there are a number of reasons that's not totally sufficient.</p>

<p>Mainly, you can receive a Promise value from another browser window (iframe, etc.), which would have its own Promise different from the one in the current window/frame, and that check would fail to identify the Promise instance.</p>

<p>Moreover, a library or framework may choose to vend its own Promises and not use the native ES6 <code>Promise</code> implementation to do so. In fact, you may very well be using Promises with libraries in older browsers that have no Promise at all.</p>

<p>When we discuss Promise resolution processes later in this chapter, it will become more obvious why a non-genuine-but-Promise-like value would still be very important to be able to recognize and assimilate. But for now, just take my word for it that it's a critical piece of the puzzle.</p>

<p>As such, it was decided that the way to recognize a Promise (or something that behaves like a Promise) would be to define something called a "thenable" as any object or function which has a <code>then(..)</code> method on it. It is assumed that any such value is a Promise-conforming thenable.</p>

<p>The general term for "type checks" that make assumptions about a value's "type" based on its shape (what properties are present) is called "duck typing" -- "If it looks like a duck, and quacks like a duck, it must be a duck" (see the <em>Types &amp; Grammar</em> title of this book series). So the duck typing check for a thenable would roughly be:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (
    p <span class="pl-k">!==</span> <span class="pl-c1">null</span> <span class="pl-k">&amp;&amp;</span>
    (
        <span class="pl-k">typeof</span> p <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>object<span class="pl-pds">"</span></span> <span class="pl-k">||</span>
        <span class="pl-k">typeof</span> p <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>
    ) <span class="pl-k">&amp;&amp;</span>
    <span class="pl-k">typeof</span> p.then <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>
) {
    <span class="pl-c">// assume it's a thenable!</span>
}
<span class="pl-k">else</span> {
    <span class="pl-c">// not a thenable</span>
}</pre></div>

<p>Yuck! Setting aside the fact that this logic is a bit ugly to implement in various places, there's something deeper and more troubling going on.</p>

<p>If you try to fulfill a Promise with any object/function value that happens to have a <code>then(..)</code> function on it, but you weren't intending it to be treated as a Promise/thenable, you're out of luck, because it will automatically be recognized as thenable and treated with special rules (see later in the chapter).</p>

<p>This is even true if you didn't realize the value has a <code>then(..)</code> on it. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){} };

<span class="pl-c">// make `v` be `[[Prototype]]`-linked to `o`</span>
<span class="pl-k">var</span> v <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( o );

v.someStuff <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;
v.otherStuff <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>not so cool<span class="pl-pds">"</span></span>;

v.hasOwnProperty( <span class="pl-s"><span class="pl-pds">"</span>then<span class="pl-pds">"</span></span> );     <span class="pl-c">// false</span></pre></div>

<p><code>v</code> doesn't look like a Promise or thenable at all. It's just a plain object with some properties on it. You're probably just intending to send that value around like any other object.</p>

<p>But unknown to you, <code>v</code> is also <code>[[Prototype]]</code>-linked (see the <em>this &amp; Object Prototypes</em> title of this book series) to another object <code>o</code>, which happens to have a <code>then(..)</code> on it. So the thenable duck typing checks will think and assume <code>v</code> is a thenable. Uh oh.</p>

<p>It doesn't even need to be something as directly intentional as that:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">Object</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">then</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){};
<span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">then</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){};

<span class="pl-k">var</span> v1 <span class="pl-k">=</span> { hello<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span> };
<span class="pl-k">var</span> v2 <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>World<span class="pl-pds">"</span></span> ];</pre></div>

<p>Both <code>v1</code> and <code>v2</code> will be assumed to be thenables. You can't control or predict if any other code accidentally or maliciously adds <code>then(..)</code> to <code>Object.prototype</code>, <code>Array.prototype</code>, or any of the other native prototypes. And if what's specified is a function that doesn't call either of its parameters as callbacks, then any Promise resolved with such a value will just silently hang forever! Crazy.</p>

<p>Sound implausible or unlikely? Perhaps.</p>

<p>But keep in mind that there were several well-known non-Promise libraries preexisting in the community prior to ES6 that happened to already have a method on them called <code>then(..)</code>. Some of those libraries chose to rename their own methods to avoid collision (that sucks!). Others have simply been relegated to the unfortunate status of "incompatible with Promise-based coding" in reward for their inability to change to get out of the way.</p>

<p>The standards decision to hijack the previously nonreserved -- and completely general-purpose sounding -- <code>then</code> property name means that no value (or any of its delegates), either past, present, or future, can have a <code>then(..)</code> function present, either on purpose or by accident, or that value will be confused for a thenable in Promises systems, which will probably create bugs that are really hard to track down.</p>

<p><strong>Warning:</strong> I do not like how we ended up with duck typing of thenables for Promise recognition. There were other options, such as "branding" or even "anti-branding"; what we got seems like a worst-case compromise. But it's not all doom and gloom. Thenable duck typing can be helpful, as we'll see later. Just beware that thenable duck typing can be hazardous if it incorrectly identifies something as a Promise that isn't.</p>

<h2><a id="user-content-promise-trust" class="anchor" href="#promise-trust" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Trust</h2>

<p>We've now seen two strong analogies that explain different aspects of what Promises can do for our async code. But if we stop there, we've missed perhaps the single most important characteristic that the Promise pattern establishes: trust.</p>

<p>Whereas the <em>future values</em> and <em>completion events</em> analogies play out explicitly in the code patterns we've explored, it won't be entirely obvious why or how Promises are designed to solve all of the <em>inversion of control</em> trust issues we laid out in the "Trust Issues" section of Chapter 2. But with a little digging, we can uncover some important guarantees that restore the confidence in async coding that Chapter 2 tore down!</p>

<p>Let's start by reviewing the trust issues with callbacks-only coding. When you pass a callback to a utility <code>foo(..)</code>, it might:</p>

<ul>
<li>Call the callback too early</li>
<li>Call the callback too late (or never)</li>
<li>Call the callback too few or too many times</li>
<li>Fail to pass along any necessary environment/parameters</li>
<li>swallow any errors/exceptions that may happen</li>
</ul>

<p>The characteristics of Promises are intentionally designed to provide useful, repeatable answers to all these concerns.</p>

<h3><a id="user-content-calling-too-early" class="anchor" href="#calling-too-early" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calling Too Early</h3>

<p>Primarily, this is a concern of whether code can introduce Zalgo-like effects (see Chapter 2), where sometimes a task finishes synchronously and sometimes asynchronously, which can lead to race conditions.</p>

<p>Promises by definition cannot be susceptible to this concern, because even an immediately fulfilled Promise (like <code>new Promise(function(resolve){ resolve(42); })</code>) cannot be <em>observed</em> synchronously.</p>

<p>That is, when you call <code>then(..)</code> on a Promise, even if that Promise was already resolved, the callback you provide to <code>then(..)</code> will <strong>always</strong> be called asynchronously (for more on this, refer back to "Jobs" in Chapter 1).</p>

<p>No more need to insert your own <code>setTimeout(..,0)</code> hacks. Promises prevent Zalgo automatically.</p>

<h3><a id="user-content-calling-too-late" class="anchor" href="#calling-too-late" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calling Too Late</h3>

<p>Similar to the previous point, a Promise's <code>then(..)</code> registered observation callbacks are automatically scheduled when either <code>resolve(..)</code> or <code>reject(..)</code> are called by the Promise creation capability. Those scheduled callbacks will predictably be fired at the next asynchronous moment (see "Jobs" in Chapter 1).</p>

<p>It's not possible for synchronous observation, so it's not possible for a synchronous chain of tasks to run in such a way to in effect "delay" another callback from happening as expected. That is, when a Promise is resolved, all <code>then(..)</code> registered callbacks on it will be called, in order, immediately at the next asynchronous opportunity (again, see "Jobs" in Chapter 1), and nothing that happens inside of one of those callbacks can affect/delay the calling of the other callbacks.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre>p.then( <span class="pl-k">function</span>(){
    p.then( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> );
    } );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> );
} );
p.then( <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> );
} );
<span class="pl-c">// A B C</span></pre></div>

<p>Here, <code>"C"</code> cannot interrupt and precede <code>"B"</code>, by virtue of how Promises are defined to operate.</p>

<h4><a id="user-content-promise-scheduling-quirks" class="anchor" href="#promise-scheduling-quirks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Scheduling Quirks</h4>

<p>It's important to note, though, that there are lots of nuances of scheduling where the relative ordering between callbacks chained off two separate Promises is not reliably predictable.</p>

<p>If two promises <code>p1</code> and <code>p2</code> are both already resolved, it should be true that <code>p1.then(..); p2.then(..)</code> would end up calling the callback(s) for <code>p1</code> before the ones for <code>p2</code>. But there are subtle cases where that might not be true, such as the following:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    resolve( <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> );
} );

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    resolve( p3 );
} );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    resolve( <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> );
} );

p1.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );

p2.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );

<span class="pl-c">// A B  &lt;-- not  B A  as you might expect</span></pre></div>

<p>We'll cover this more later, but as you can see, <code>p1</code> is resolved not with an immediate value, but with another promise <code>p3</code> which is itself resolved with the value <code>"B"</code>. The specified behavior is to <em>unwrap</em> <code>p3</code> into <code>p1</code>, but asynchronously, so <code>p1</code>'s callback(s) are <em>behind</em> <code>p2</code>'s callback(s) in the asynchronus Job queue (see Chapter 1).</p>

<p>To avoid such nuanced nightmares, you should never rely on anything about the ordering/scheduling of callbacks across Promises. In fact, a good practice is not to code in such a way where the ordering of multiple callbacks matters at all. Avoid that if you can.</p>

<h3><a id="user-content-never-calling-the-callback" class="anchor" href="#never-calling-the-callback" aria-hidden="true"><span class="octicon octicon-link"></span></a>Never Calling the Callback</h3>

<p>This is a very common concern. It's addressable in several ways with Promises.</p>

<p>First, nothing (not even a JS error) can prevent a Promise from notifying you of its resolution (if it's resolved). If you register both fulfillment and rejection callbacks for a Promise, and the Promise gets resolved, one of the two callbacks will always be called.</p>

<p>Of course, if your callbacks themselves have JS errors, you may not see the outcome you expect, but the callback will in fact have been called. We'll cover later how to be notified of an error in your callback, because even those don't get swallowed.</p>

<p>But what if the Promise itself never gets resolved either way? Even that is a condition that Promises provide an answer for, using a higher level abstraction called a "race":</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// a utility for timing out a Promise</span>
<span class="pl-k">function</span> <span class="pl-en">timeoutPromise</span>(<span class="pl-smi">delay</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            reject( <span class="pl-s"><span class="pl-pds">"</span>Timeout!<span class="pl-pds">"</span></span> );
        }, delay );
    } );
}

<span class="pl-c">// setup a timeout for `foo()`</span>
Promise.race( [
    foo(),                  <span class="pl-c">// attempt `foo()`</span>
    timeoutPromise( <span class="pl-c1">3000</span> )  <span class="pl-c">// give it 3 seconds</span>
] )
.then(
    <span class="pl-k">function</span>(){
        <span class="pl-c">// `foo(..)` fulfilled in time!</span>
    },
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// either `foo()` rejected, or it just</span>
        <span class="pl-c">// didn't finish in time, so inspect</span>
        <span class="pl-c">// `err` to know which</span>
    }
);</pre></div>

<p>There are more details to consider with this Promise timeout pattern, but we'll come back to it later.</p>

<p>Importantly, we can ensure a signal as to the outcome of <code>foo()</code>, to prevent it from hanging our program indefinitely.</p>

<h3><a id="user-content-calling-too-few-or-too-many-times" class="anchor" href="#calling-too-few-or-too-many-times" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calling Too Few or Too Many Times</h3>

<p>By definition, <em>one</em> is the appropriate number of times for the callback to be called. The "too few" case would be zero calls, which is the same as the "never" case we just examined.</p>

<p>The "too many" case is easy to explain. Promises are defined so that they can only be resolved once. If for some reason the Promise creation code tries to call <code>resolve(..)</code> or <code>reject(..)</code> multiple times, or tries to call both, the Promise will accept only the first resolution, and will silently ignore any subsequent attempts.</p>

<p>Because a Promise can only be resolved once, any <code>then(..)</code> registered callbacks will only ever be called once (each).</p>

<p>Of course, if you register the same callback more than once, (e.g., <code>p.then(f); p.then(f);</code>), it'll be called as many times as it was registered.  The guarantee that a response function is called only once does not prevent you from shooting yourself in the foot.</p>

<h3><a id="user-content-failing-to-pass-along-any-parametersenvironment" class="anchor" href="#failing-to-pass-along-any-parametersenvironment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Failing to Pass Along Any Parameters/Environment</h3>

<p>Promises can have, at most, one resolution value (fulfillment or rejection).</p>

<p>If you don't explicitly resolve with a value either way, the value is <code>undefined</code>, as is typical in JS. But whatever the value, it will always be passed to all registered (and appropriate: fulfillment or rejection) callbacks, either <em>now</em> or in the future.</p>

<p>Something to be aware of: If you call <code>resolve(..)</code> or <code>reject(..)</code> with multiple parameters, all subsequent parameters beyond the first will be silently ignored. Although that might seem a violation of the guarantee we just described, it's not exactly, because it constitutes an invalid usage of the Promise mechanism. Other invalid usages of the API (such as calling <code>resolve(..)</code> multiple times) are similarly <em>protected</em>, so the Promise behavior here is consistent (if not a tiny bit frustrating).</p>

<p>If you want to pass along multiple values, you must wrap them in another single value that you pass, such as an <code>array</code> or an <code>object</code>.</p>

<p>As for environment, functions in JS always retain their closure of the scope in which they're defined (see the <em>Scope &amp; Closures</em> title of this series), so they of course would continue to have access to whatever surrounding state you provide. Of course, the same is true of callbacks-only design, so this isn't a specific augmentation of benefit from Promises -- but it's a guarantee we can rely on nonetheless.</p>

<h3><a id="user-content-swallowing-any-errorsexceptions" class="anchor" href="#swallowing-any-errorsexceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Swallowing Any Errors/Exceptions</h3>

<p>In the base sense, this is a restatement of the previous point. If you reject a Promise with a <em>reason</em> (aka error message), that value is passed to the rejection callback(s).</p>

<p>But there's something much bigger at play here. If at any point in the creation of a Promise, or in the observation of its resolution, a JS exception error occurs, such as a <code>TypeError</code> or <code>ReferenceError</code>, that exception will be caught, and it will force the Promise in question to become rejected.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    foo.bar();  <span class="pl-c">// `foo` is not defined, so error!</span>
    resolve( <span class="pl-c1">42</span> );  <span class="pl-c">// never gets here :(</span>
} );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// never gets here :(</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// `err` will be a `TypeError` exception object</span>
        <span class="pl-c">// from the `foo.bar()` line.</span>
    }
);</pre></div>

<p>The JS exception that occurs from <code>foo.bar()</code> becomes a Promise rejection that you can catch and respond to.</p>

<p>This is an important detail, because it effectively solves another potential Zalgo moment, which is that errors could create a synchronous reaction whereas nonerrors would be asynchronous. Promises turn even JS exceptions into asynchronous behavior, thereby reducing the race condition chances greatly.</p>

<p>But what happens if a Promise is fulfilled, but there's a JS exception error during the observation (in a <code>then(..)</code> registered callback)? Even those aren't lost, but you may find how they're handled a bit surprising, until you dig in a little deeper:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    resolve( <span class="pl-c1">42</span> );
} );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>){
        foo.bar();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg ); <span class="pl-c">// never gets here :(</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// never gets here either :(</span>
    }
);</pre></div>

<p>Wait, that makes it seem like the exception from <code>foo.bar()</code> really did get swallowed. Never fear, it didn't. But something deeper is wrong, which is that we've failed to listen for it. The <code>p.then(..)</code> call itself returns another promise, and it's <em>that</em> promise that will be rejected with the <code>TypeError</code> exception.</p>

<p>Why couldn't it just call the error handler we have defined there? Seems like a logical behavior on the surface. But it would violate the fundamental principle that Promises are <strong>immutable</strong> once resolved. <code>p</code> was already fulfilled to the value <code>42</code>, so it can't later be changed to a rejection just because there's an error in observing <code>p</code>'s resolution.</p>

<p>Besides the principle violation, such behavior could wreak havoc, if say there were multiple <code>then(..)</code> registered callbacks on the promise <code>p</code>, because some would get called and others wouldn't, and it would be very opaque as to why.</p>

<h3><a id="user-content-trustable-promise" class="anchor" href="#trustable-promise" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trustable Promise?</h3>

<p>There's one last detail to examine to establish trust based on the Promise pattern.</p>

<p>You've no doubt noticed that Promises don't get rid of callbacks at all. They just change where the callback is passed to. Instead of passing a callback to <code>foo(..)</code>, we get <em>something</em> (ostensibly a genuine Promise) back from <code>foo(..)</code>, and we pass the callback to that <em>something</em> instead.</p>

<p>But why would this be any more trustable than just callbacks alone? How can we be sure the <em>something</em> we get back is in fact a trustable Promise? Isn't it basically all just a house of cards where we can trust only because we already trusted?</p>

<p>One of the most important, but often overlooked, details of Promises is that they have a solution to this issue as well. Included with the native ES6 <code>Promise</code> implementation is <code>Promise.resolve(..)</code>.</p>

<p>If you pass an immediate, non-Promise, non-thenable value to <code>Promise.resolve(..)</code>, you get a promise that's fulfilled with that value. In other words, these two promises <code>p1</code> and <code>p2</code> will behave basically identically:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    resolve( <span class="pl-c1">42</span> );
} );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );</pre></div>

<p>But if you pass a genuine Promise to <code>Promise.resolve(..)</code>, you just get the same promise back:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.resolve( p1 );

p1 <span class="pl-k">===</span> p2; <span class="pl-c">// true</span></pre></div>

<p>Even more importantly, if you pass a non-Promise thenable value to <code>Promise.resolve(..)</code>, it will attempt to unwrap that value, and the unwrapping will keep going until a concrete final non-Promise-like value is extracted.</p>

<p>Recall our previous discussion of thenables?</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
        cb( <span class="pl-c1">42</span> );
    }
};

<span class="pl-c">// this works OK, but only by good fortune</span>
p
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val ); <span class="pl-c">// 42</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// never gets here</span>
    }
);</pre></div>

<p>This <code>p</code> is a thenable, but it's not a genuine Promise. Luckily, it's reasonable, as most will be. But what if you got back instead something that looked like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>,<span class="pl-smi">errcb</span>) {
        cb( <span class="pl-c1">42</span> );
        errcb( <span class="pl-s"><span class="pl-pds">"</span>evil laugh<span class="pl-pds">"</span></span> );
    }
};

p
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val ); <span class="pl-c">// 42</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// oops, shouldn't have run</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// evil laugh</span>
    }
);</pre></div>

<p>This <code>p</code> is a thenable but it's not so well behaved of a promise. Is it malicious? Or is it just ignorant of how Promises should work? It doesn't really matter, to be honest. In either case, it's not trustable as is.</p>

<p>Nonetheless, we can pass either of these versions of <code>p</code> to <code>Promise.resolve(..)</code>, and we'll get the normalized, safe result we'd expect:</p>

<div class="highlight highlight-js"><pre>Promise.resolve( p )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val ); <span class="pl-c">// 42</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// never gets here</span>
    }
);</pre></div>

<p><code>Promise.resolve(..)</code> will accept any thenable, and will unwrap it to its non-thenable value. But you get back from <code>Promise.resolve(..)</code> a real, genuine Promise in its place, <strong>one that you can trust</strong>. If what you passed in is already a genuine Promise, you just get it right back, so there's no downside at all to filtering through <code>Promise.resolve(..)</code> to gain trust.</p>

<p>So let's say we're calling a <code>foo(..)</code> utility and we're not sure we can trust its return value to be a well-behaving Promise, but we know it's at least a thenable. <code>Promise.resolve(..)</code> will give us a trustable Promise wrapper to chain off of:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// don't just do this:</span>
foo( <span class="pl-c1">42</span> )
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );

<span class="pl-c">// instead, do this:</span>
Promise.resolve( foo( <span class="pl-c1">42</span> ) )
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );</pre></div>

<p><strong>Note:</strong> Another beneficial side effect of wrapping <code>Promise.resolve(..)</code> around any function's return value (thenable or not) is that it's an easy way to normalize that function call into a well-behaving async task. If <code>foo(42)</code> returns an immediate value sometimes, or a Promise other times, <code>Promise.resolve( foo(42) )</code> makes sure it's always a Promise result. And avoiding Zalgo makes for much better code.</p>

<h3><a id="user-content-trust-built" class="anchor" href="#trust-built" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trust Built</h3>

<p>Hopefully the previous discussion now fully "resolves" (pun intended) in your mind why the Promise is trustable, and more importantly, why that trust is so critical in building robust, maintainable software.</p>

<p>Can you write async code in JS without trust? Of course you can. We JS developers have been coding async with nothing but callbacks for nearly two decades.</p>

<p>But once you start questioning just how much you can trust the mechanisms you build upon to actually be predictable and reliable, you start to realize callbacks have a pretty shaky trust foundation.</p>

<p>Promises are a pattern that augments callbacks with trustable semantics, so that the behavior is more reason-able and more reliable. By uninverting the <em>inversion of control</em> of callbacks, we place the control with a trustable system (Promises) that was designed specifically to bring sanity to our async.</p>

<h2><a id="user-content-chain-flow" class="anchor" href="#chain-flow" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chain Flow</h2>

<p>We've hinted at this a couple of times already, but Promises are not just a mechanism for a single-step <em>this-then-that</em> sort of operation. That's the building block, of course, but it turns out we can string multiple Promises together to represent a sequence of async steps.</p>

<p>The key to making this work is built on two behaviors intrinsic to Promises:</p>

<ul>
<li>Every time you call <code>then(..)</code> on a Promise, it creates and returns a new Promise, which we can <em>chain</em> with.</li>
<li>Whatever value you return from the <code>then(..)</code> call's fulfillment callback (the first parameter) is automatically set as the fulfillment of the <em>chained</em> Promise (from the first point).</li>
</ul>

<p>Let's first illustrate what that means, and <em>then</em> we'll derive how that helps us create async sequences of flow control. Consider the following:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">21</span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> p.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 21</span>

    <span class="pl-c">// fulfill `p2` with value `42`</span>
    <span class="pl-k">return</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span>;
} );

<span class="pl-c">// chain off `p2`</span>
p2.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 42</span>
} );</pre></div>

<p>By returning <code>v * 2</code> (i.e., <code>42</code>), we fulfill the <code>p2</code> promise that the first <code>then(..)</code> call created and returned. When <code>p2</code>'s <code>then(..)</code> call runs, it's receiving the fulfillment from the <code>return v * 2</code> statement. Of course, <code>p2.then(..)</code> creates yet another promise, which we could have stored in a <code>p3</code> variable.</p>

<p>But it's a little annoying to have to create an intermediate variable <code>p2</code> (or <code>p3</code>, etc.). Thankfully, we can easily just chain these together:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">21</span> );

p
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 21</span>

    <span class="pl-c">// fulfill the chained promise with value `42`</span>
    <span class="pl-k">return</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span>;
} )
<span class="pl-c">// here's the chained promise</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 42</span>
} );</pre></div>

<p>So now the first <code>then(..)</code> is the first step in an async sequence, and the second <code>then(..)</code> is the second step. This could keep going for as long as you needed it to extend. Just keep chaining off a previous <code>then(..)</code> with each automatically created Promise.</p>

<p>But there's something missing here. What if we want step 2 to wait for step 1 to do something asynchronous? We're using an immediate <code>return</code> statement, which immediately fulfills the chained promise.</p>

<p>The key to making a Promise sequence truly async capable at every step is to recall how <code>Promise.resolve(..)</code> operates when what you pass to it is a Promise or thenable instead of a final value. <code>Promise.resolve(..)</code> directly returns a received genuine Promise, or it unwraps the value of a received thenable -- and keeps going recursively while it keeps unwrapping thenables.</p>

<p>The same sort of unwrapping happens if you <code>return</code> a thenable or Promise from the fulfillment (or rejection) handler. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">21</span> );

p.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 21</span>

    <span class="pl-c">// create a promise and return it</span>
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// fulfill with value `42`</span>
        resolve( v <span class="pl-k">*</span> <span class="pl-c1">2</span> );
    } );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 42</span>
} );</pre></div>

<p>Even though we wrapped <code>42</code> up in a promise that we returned, it still got unwrapped and ended up as the resolution of the chained promise, such that the second <code>then(..)</code> still received <code>42</code>. If we introduce asynchrony to that wrapping promise, everything still nicely works the same:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">21</span> );

p.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 21</span>

    <span class="pl-c">// create a promise to return</span>
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// introduce asynchrony!</span>
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            <span class="pl-c">// fulfill with value `42`</span>
            resolve( v <span class="pl-k">*</span> <span class="pl-c1">2</span> );
        }, <span class="pl-c1">100</span> );
    } );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-c">// runs after the 100ms delay in the previous step</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );   <span class="pl-c">// 42</span>
} );</pre></div>

<p>That's incredibly powerful! Now we can construct a sequence of however many async steps we want, and each step can delay the next step (or not!), as necessary.</p>

<p>Of course, the value passing from step to step in these examples is optional. If you don't return an explicit value, an implicit <code>undefined</code> is assumed, and the promises still chain together the same way. Each Promise resolution is thus just a signal to proceed to the next step.</p>

<p>To further the chain illustration, let's generalize a delay-Promise creation (without resolution messages) into a utility we can reuse for multiple steps:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">delay</span>(<span class="pl-smi">time</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c1">setTimeout</span>( resolve, time );
    } );
}

delay( <span class="pl-c1">100</span> ) <span class="pl-c">// step 1</span>
.then( <span class="pl-k">function</span> <span class="pl-en">STEP2</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 2 (after 100ms)<span class="pl-pds">"</span></span> );
    <span class="pl-k">return</span> delay( <span class="pl-c1">200</span> );
} )
.then( <span class="pl-k">function</span> <span class="pl-en">STEP3</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 3 (after another 200ms)<span class="pl-pds">"</span></span> );
} )
.then( <span class="pl-k">function</span> <span class="pl-en">STEP4</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 4 (next Job)<span class="pl-pds">"</span></span> );
    <span class="pl-k">return</span> delay( <span class="pl-c1">50</span> );
} )
.then( <span class="pl-k">function</span> <span class="pl-en">STEP5</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 5 (after another 50ms)<span class="pl-pds">"</span></span> );
} )
...</pre></div>

<p>Calling <code>delay(200)</code> creates a promise that will fulfill in 200ms, and then we return that from the first <code>then(..)</code> fulfillment callback, which causes the second <code>then(..)</code>'s promise to wait on that 200ms promise.</p>

<p><strong>Note:</strong> As described, technically there are two promises in that interchange: the 200ms-delay promise and the chained promise that the second <code>then(..)</code> chains from. But you may find it easier to mentally combine these two promises together, because the Promise mechanism automatically merges their states for you. In that respect, you could think of <code>return delay(200)</code> as creating a promise that replaces the earlier-returned chained promise.</p>

<p>To be honest, though, sequences of delays with no message passing isn't a terribly useful example of Promise flow control. Let's look at a scenario that's a little more practical.</p>

<p>Instead of timers, let's consider making Ajax requests:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// assume an `ajax( {url}, {callback} )` utility</span>

<span class="pl-c">// Promise-aware ajax</span>
<span class="pl-k">function</span> <span class="pl-en">request</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// the `ajax(..)` callback should be our</span>
        <span class="pl-c">// promise's `resolve(..)` function</span>
        ajax( url, resolve );
    } );
}</pre></div>

<p>We first define a <code>request(..)</code> utility that constructs a promise to represent the completion of the <code>ajax(..)</code> call:</p>

<div class="highlight highlight-js"><pre>request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/<span class="pl-pds">"</span></span> )
.then( <span class="pl-k">function</span>(<span class="pl-smi">response1</span>){
    <span class="pl-k">return</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> response1 );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">response2</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( response2 );
} );</pre></div>

<p><strong>Note:</strong> Developers commonly encounter situations in which they want to do Promise-aware async flow control with utilities that are not themselves Promise-enabled (like <code>ajax(..)</code> here, which expects a callback). Although the native ES6 <code>Promise</code> mechanism doesn't automatically solve this pattern for us, practically all Promise libraries <em>do</em>. They usually call this process "lifting" or "promisifying" or some variation thereof. We'll come back to this technique later.</p>

<p>Using the Promise-returning <code>request(..)</code>, we create the first step in our chain implicitly by calling it with the first URL, and chain off that returned promise with the first <code>then(..)</code>.</p>

<p>Once <code>response1</code> comes back, we use that value to construct a second URL, and make a second <code>request(..)</code> call. That second <code>request(..)</code> promise is <code>return</code>ed so that the third step in our async flow control waits for that Ajax call to complete. Finally, we print <code>response2</code> once it returns.</p>

<p>The Promise chain we construct is not only a flow control that expresses a multistep async sequence, but it also acts as a message channel to propagate messages from step to step.</p>

<p>What if something went wrong in one of the steps of the Promise chain? An error/exception is on a per-Promise basis, which means it's possible to catch such an error at any point in the chain, and that catching acts to sort of "reset" the chain back to normal operation at that point:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// step 1:</span>
request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/<span class="pl-pds">"</span></span> )

<span class="pl-c">// step 2:</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">response1</span>){
    foo.bar(); <span class="pl-c">// undefined, error!</span>

    <span class="pl-c">// never gets here</span>
    <span class="pl-k">return</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> response1 );
} )

<span class="pl-c">// step 3:</span>
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">response2</span>){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-c">// rejection handler to catch the error</span>
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// `TypeError` from `foo.bar()` error</span>
        <span class="pl-k">return</span> <span class="pl-c1">42</span>;
    }
)

<span class="pl-c">// step 4:</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">msg</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg );     <span class="pl-c">// 42</span>
} );</pre></div>

<p>When the error occurs in step 2, the rejection handler in step 3 catches it. The return value (<code>42</code> in this snippet), if any, from that rejection handler fulfills the promise for the next step (4), such that the chain is now back in a fulfillment state.</p>

<p><strong>Note:</strong> As we discussed earlier, when returning a promise from a fulfillment handler, it's unwrapped and can delay the next step. That's also true for returning promises from rejection handlers, such that if the <code>return 42</code> in step 3 instead returned a promise, that promise could delay step 4. A thrown exception inside either the fulfillment or rejection handler of a <code>then(..)</code> call causes the next (chained) promise to be immediately rejected with that exception.</p>

<p>If you call <code>then(..)</code> on a promise, and you only pass a fulfillment handler to it, an assumed rejection handler is substituted:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
} );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// never gets here</span>
    }
    <span class="pl-c">// assumed rejection handler, if omitted or</span>
    <span class="pl-c">// any other non-function value passed</span>
    <span class="pl-c">// function(err) {</span>
    <span class="pl-c">//     throw err;</span>
    <span class="pl-c">// }</span>
);</pre></div>

<p>As you can see, the assumed rejection handler simply rethrows the error, which ends up forcing <code>p2</code> (the chained promise) to reject with the same error reason. In essence, this allows the error to continue propagating along a Promise chain until an explicitly defined rejection handler is encountered.</p>

<p><strong>Note:</strong> We'll cover more details of error handling with Promises a little later, because there are other nuanced details to be concerned about.</p>

<p>If a proper valid function is not passed as the fulfillment handler parameter to <code>then(..)</code>, there's also a default handler substituted:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

p.then(
    <span class="pl-c">// assumed fulfillment handler, if omitted or</span>
    <span class="pl-c">// any other non-function value passed</span>
    <span class="pl-c">// function(v) {</span>
    <span class="pl-c">//     return v;</span>
    <span class="pl-c">// }</span>
    <span class="pl-c1">null</span>,
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// never gets here</span>
    }
);</pre></div>

<p>As you can see, the default fulfillment handler simply passes whatever value it receives along to the next step (Promise).</p>

<p><strong>Note:</strong> The <code>then(null,function(err){ .. })</code> pattern -- only handling rejections (if any) but letting fulfillments pass through -- has a shortcut in the API: <code>catch(function(err){ .. })</code>. We'll cover <code>catch(..)</code> more fully in the next section.</p>

<p>Let's review briefly the intrinsic behaviors of Promises that enable chaining flow control:</p>

<ul>
<li>A <code>then(..)</code> call against one Promise automatically produces a new Promise to return from the call.</li>
<li>Inside the fulfillment/rejection handlers, if you return a value or an exception is thrown, the new returned (chainable) Promise is resolved accordingly.</li>
<li>If the fulfillment or rejection handler returns a Promise, it is unwrapped, so that whatever its resolution is will become the resolution of the chained Promise returned from the current <code>then(..)</code>.</li>
</ul>

<p>While chaining flow control is helpful, it's probably most accurate to think of it as a side benefit of how Promises compose (combine) together, rather than the main intent. As we've discussed in detail several times already, Promises normalize asynchrony and encapsulate time-dependent value state, and <em>that</em> is what lets us chain them together in this useful way.</p>

<p>Certainly, the sequential expressiveness of the chain (this-then-this-then-this...) is a big improvement over the tangled mess of callbacks as we identified in Chapter 2. But there's still a fair amount of boilerplate (<code>then(..)</code> and <code>function(){ .. }</code>) to wade through. In the next chapter, we'll see a significantly nicer pattern for sequential flow control expressivity, with generators.</p>

<h3><a id="user-content-terminology-resolve-fulfill-and-reject" class="anchor" href="#terminology-resolve-fulfill-and-reject" aria-hidden="true"><span class="octicon octicon-link"></span></a>Terminology: Resolve, Fulfill, and Reject</h3>

<p>There's some slight confusion around the terms "resolve," "fulfill," and "reject" that we need to clear up, before you get too much deeper into learning about Promises. Let's first consider the <code>Promise(..)</code> constructor:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">X</span>,<span class="pl-smi">Y</span>){
    <span class="pl-c">// X() for fulfillment</span>
    <span class="pl-c">// Y() for rejection</span>
} );</pre></div>

<p>As you can see, two callbacks (here labeled <code>X</code> and <code>Y</code>) are provided. The first is <em>usually</em> used to mark the Promise as fulfilled, and the second <em>always</em> marks the Promise as rejected. But what's the "usually" about, and what does that imply about accurately naming those parameters?</p>

<p>Ultimately, it's just your user code and the identifier names aren't interpreted by the engine to mean anything, so it doesn't <em>technically</em> matter; <code>foo(..)</code> and <code>bar(..)</code> are equally functional. But the words you use can affect not only how you are thinking about the code, but how other developers on your team will think about it. Thinking wrongly about carefully orchestrated async code is almost surely going to be worse than the spaghetti-callback alternatives.</p>

<p>So it actually does kind of matter what you call them.</p>

<p>The second parameter is easy to decide. Almost all literature uses <code>reject(..)</code> as its name, and because that's exactly (and only!) what it does, that's a very good choice for the name. I'd strongly recommend you always use <code>reject(..)</code>.</p>

<p>But there's a little more ambiguity around the first parameter, which in Promise literature is often labeled <code>resolve(..)</code>. That word is obviously related to "resolution," which is what's used across the literature (including this book) to describe setting a final value/state to a Promise. We've already used "resolve the Promise" several times to mean either fulfilling or rejecting the Promise.</p>

<p>But if this parameter seems to be used to specifically fulfill the Promise, why shouldn't we call it <code>fulfill(..)</code> instead of <code>resolve(..)</code> to be more accurate? To answer that question, let's also take a look at two of the <code>Promise</code> API methods:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> fulfilledPr <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

<span class="pl-k">var</span> rejectedPr <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );</pre></div>

<p><code>Promise.resolve(..)</code> creates a Promise that's resolved to the value given to it. In this example, <code>42</code> is a normal, non-Promise, non-thenable value, so the fulfilled promise <code>fulfilledPr</code> is created for the value <code>42</code>. <code>Promise.reject("Oops")</code> creates the rejected promise <code>rejectedPr</code> for the reason <code>"Oops"</code>.</p>

<p>Let's now illustrate why the word "resolve" (such as in <code>Promise.resolve(..)</code>) is unambiguous and indeed more accurate, if used explicitly in a context that could result in either fulfillment or rejection:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> rejectedTh <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">resolved</span>,<span class="pl-smi">rejected</span>) {
        rejected( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> rejectedPr <span class="pl-k">=</span> Promise.resolve( rejectedTh );</pre></div>

<p>As we discussed earlier in this chapter, <code>Promise.resolve(..)</code> will return a received genuine Promise directly, or unwrap a received thenable. If that thenable unwrapping reveals a rejected state, the Promise returned from <code>Promise.resolve(..)</code> is in fact in that same rejected state.</p>

<p>So <code>Promise.resolve(..)</code> is a good, accurate name for the API method, because it can actually result in either fulfillment or rejection.</p>

<p>The first callback parameter of the <code>Promise(..)</code> constructor will unwrap either a thenable (identically to <code>Promise.resolve(..)</code>) or a genuine Promise:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> rejectedPr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c">// resolve this promise with a rejected promise</span>
    resolve( Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> ) );
} );

rejectedPr.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// "Oops"</span>
    }
);</pre></div>

<p>It should be clear now that <code>resolve(..)</code> is the appropriate name for the first callback parameter of the <code>Promise(..)</code> constructor.</p>

<p><strong>Warning:</strong> The previously mentioned <code>reject(..)</code> does <strong>not</strong> do the unwrapping that <code>resolve(..)</code> does. If you pass a Promise/thenable value to <code>reject(..)</code>, that untouched value will be set as the rejection reason. A subsequent rejection handler would receive the actual Promise/thenable you passed to <code>reject(..)</code>, not its underlying immediate value.</p>

<p>But now let's turn our attention to the callbacks provided to <code>then(..)</code>. What should they be called (both in literature and in code)? I would suggest <code>fulfilled(..)</code> and <code>rejected(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg );
}

<span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
}

p.then(
    fulfilled,
    rejected
);</pre></div>

<p>In the case of the first parameter to <code>then(..)</code>, it's unambiguously always the fulfillment case, so there's no need for the duality of "resolve" terminology. As a side note, the ES6 specification uses <code>onFulfilled(..)</code> and <code>onRejected(..)</code> to label these two callbacks, so they are accurate terms.</p>

<h2><a id="user-content-error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Handling</h2>

<p>We've already seen several examples of how Promise rejection -- either intentional through calling <code>reject(..)</code> or accidental through JS exceptions -- allows saner error handling in asynchronous programming. Let's circle back though and be explicit about some of the details that we glossed over.</p>

<p>The most natural form of error handling for most developers is the synchronous <code>try..catch</code> construct. Unfortunately, it's synchronous-only, so it fails to help in async code patterns:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        baz.bar();
    }, <span class="pl-c1">100</span> );
}

<span class="pl-k">try</span> {
    foo();
    <span class="pl-c">// later throws global error from `baz.bar()`</span>
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c">// never gets here</span>
}</pre></div>

<p><code>try..catch</code> would certainly be nice to have, but it doesn't work across async operations. That is, unless there's some additional environmental support, which we'll come back to with generators in Chapter 4.</p>

<p>In callbacks, some standards have emerged for patterned error handling, most notably the "error-first callback" style:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        <span class="pl-k">try</span> {
            <span class="pl-k">var</span> x <span class="pl-k">=</span> baz.bar();
            cb( <span class="pl-c1">null</span>, x ); <span class="pl-c">// success!</span>
        }
        <span class="pl-k">catch</span> (err) {
            cb( err );
        }
    }, <span class="pl-c1">100</span> );
}

foo( <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">val</span>){
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err ); <span class="pl-c">// bummer :(</span>
    }
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
    }
} );</pre></div>

<p><strong>Note:</strong> The <code>try..catch</code> here works only from the perspective that the <code>baz.bar()</code> call will either succeed or fail immediately, synchronously. If <code>baz.bar()</code> was itself its own async completing function, any async errors inside it would not be catchable.</p>

<p>The callback we pass to <code>foo(..)</code> expects to receive a signal of an error by the reserved first parameter <code>err</code>. If present, error is assumed. If not, success is assumed.</p>

<p>This sort of error handling is technically <em>async capable</em>, but it doesn't compose well at all. Multiple levels of error-first callbacks woven together with these ubiquitous <code>if</code> statement checks inevitably will lead you to the perils of callback hell (see Chapter 2).</p>

<p>So we come back to error handling in Promises, with the rejection handler passed to <code>then(..)</code>. Promises don't use the popular "error-first callback" design style, but instead use "split callbacks" style; there's one callback for fulfillment and one for rejection:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// "Oops"</span>
    }
);</pre></div>

<p>While this pattern of error handling makes fine sense on the surface, the nuances of Promise error handling are often a fair bit more difficult to fully grasp.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>){
        <span class="pl-c">// numbers don't have string functions,</span>
        <span class="pl-c">// so will throw an error</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg.<span class="pl-c1">toLowerCase</span>() );
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// never gets here</span>
    }
);</pre></div>

<p>If the <code>msg.toLowerCase()</code> legitimately throws an error (it does!), why doesn't our error handler get notified? As we explained earlier, it's because <em>that</em> error handler is for the <code>p</code> promise, which has already been fulfilled with value <code>42</code>. The <code>p</code> promise is immutable, so the only promise that can be notified of the error is the one returned from <code>p.then(..)</code>, which in this case we don't capture.</p>

<p>That should paint a clear picture of why error handling with Promises is error-prone (pun intended). It's far too easy to have errors swallowed, as this is very rarely what you'd intend.</p>

<p><strong>Warning:</strong> If you use the Promise API in an invalid way and an error occurs that prevents proper Promise construction, the result will be an immediately thrown exception, <strong>not a rejected Promise</strong>. Some examples of incorrect usage that fail Promise construction: <code>new Promise(null)</code>, <code>Promise.all()</code>, <code>Promise.race(42)</code>, and so on. You can't get a rejected Promise if you don't use the Promise API validly enough to actually construct a Promise in the first place!</p>

<h3><a id="user-content-pit-of-despair" class="anchor" href="#pit-of-despair" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pit of Despair</h3>

<p>Jeff Atwood noted years ago: programming languages are often set up in such a way that by default, developers fall into the "pit of despair" (<a href="http://blog.codinghorror.com/falling-into-the-pit-of-success/">http://blog.codinghorror.com/falling-into-the-pit-of-success/</a>) -- where accidents are punished -- and that you have to try harder to get it right. He implored us to instead create a "pit of success," where by default you fall into expected (successful) action, and thus would have to try hard to fail.</p>

<p>Promise error handling is unquestionably "pit of despair" design. By default, it assumes that you want any error to be swallowed by the Promise state, and if you forget to observe that state, the error silently languishes/dies in obscurity -- usually despair.</p>

<p>To avoid losing an error to the silence of a forgotten/discarded Promise, some developers have claimed that a "best practice" for Promise chains is to always end your chain with a final <code>catch(..)</code>, like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>){
        <span class="pl-c">// numbers don't have string functions,</span>
        <span class="pl-c">// so will throw an error</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg.<span class="pl-c1">toLowerCase</span>() );
    }
)
.catch( handleErrors );</pre></div>

<p>Because we didn't pass a rejection handler to the <code>then(..)</code>, the default handler was substituted, which simply propagates the error to the next promise in the chain. As such, both errors that come into <code>p</code>, and errors that come <em>after</em> <code>p</code> in its resolution (like the <code>msg.toLowerCase()</code> one) will filter down to the final <code>handleErrors(..)</code>.</p>

<p>Problem solved, right? Not so fast!</p>

<p>What happens if <code>handleErrors(..)</code> itself also has an error in it? Who catches that? There's still yet another unattended promise: the one <code>catch(..)</code> returns, which we don't capture and don't register a rejection handler for.</p>

<p>You can't just stick another <code>catch(..)</code> on the end of that chain, because it too could fail. The last step in any Promise chain, whatever it is, always has the possibility, even decreasingly so, of dangling with an uncaught error stuck inside an unobserved Promise.</p>

<p>Sound like an impossible conundrum yet?</p>

<h3><a id="user-content-uncaught-handling" class="anchor" href="#uncaught-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Uncaught Handling</h3>

<p>It's not exactly an easy problem to solve completely. There are other ways to approach it which many would say are <em>better</em>.</p>

<p>Some Promise libraries have added methods for registering something like a "global unhandled rejection" handler, which would be called instead of a globally thrown error. But their solution for how to identify an error as "uncaught" is to have an arbitrary-length timer, say 3 seconds, running from time of rejection. If a Promise is rejected but no error handler is registered before the timer fires, then it's assumed that you won't ever be registering a handler, so it's "uncaught."</p>

<p>In practice, this has worked well for many libraries, as most usage patterns don't typically call for significant delay between Promise rejection and observation of that rejection. But this pattern is troublesome because 3 seconds is so arbitrary (even if empirical), and also because there are indeed some cases where you want a Promise to hold on to its rejectedness for some indefinite period of time, and you don't really want to have your "uncaught" handler called for all those false positives (not-yet-handled "uncaught errors").</p>

<p>Another more common suggestion is that Promises should have a <code>done(..)</code> added to them, which essentially marks the Promise chain as "done." <code>done(..)</code> doesn't create and return a Promise, so the callbacks passed to <code>done(..)</code> are obviously not wired up to report problems to a chained Promise that doesn't exist.</p>

<p>So what happens instead? It's treated as you might usually expect in uncaught error conditions: any exception inside a <code>done(..)</code> rejection handler would be thrown as a global uncaught error (in the developer console, basically):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

p.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>){
        <span class="pl-c">// numbers don't have string functions,</span>
        <span class="pl-c">// so will throw an error</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg.<span class="pl-c1">toLowerCase</span>() );
    }
)
.done( <span class="pl-c1">null</span>, handleErrors );

<span class="pl-c">// if `handleErrors(..)` caused its own exception, it would</span>
<span class="pl-c">// be thrown globally here</span></pre></div>

<p>This might sound more attractive than the never-ending chain or the arbitrary timeouts. But the biggest problem is that it's not part of the ES6 standard, so no matter how good it sounds, at best it's a lot longer way off from being a reliable and ubiquitous solution.</p>

<p>Are we just stuck, then? Not entirely.</p>

<p>Browsers have a unique capability that our code does not have: they can track and know for sure when any object gets thrown away and garbage collected. So, browsers can track Promise objects, and whenever they get garbage collected, if they have a rejection in them, the browser knows for sure this was a legitimate "uncaught error," and can thus confidently know it should report it to the developer console.</p>

<p><strong>Note:</strong> At the time of this writing, both Chrome and Firefox have early attempts at that sort of "uncaught rejection" capability, though support is incomplete at best.</p>

<p>However, if a Promise doesn't get garbage collected -- it's exceedingly easy for that to accidentally happen through lots of different coding patterns -- the browser's garbage collection sniffing won't help you know and diagnose that you have a silently rejected Promise laying around.</p>

<p>Is there any other alternative? Yes.</p>

<h3><a id="user-content-pit-of-success" class="anchor" href="#pit-of-success" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pit of Success</h3>

<p>The following is just theoretical, how Promises <em>could</em> be someday changed to behave. I believe it would be far superior to what we currently have. And I think this change would be possible even post-ES6 because I don't think it would break web compatibility with ES6 Promises. Moreover, it can be polyfilled/prollyfilled in, if you're careful. Let's take a look:</p>

<ul>
<li>Promises could default to reporting (to the developer console) any rejection, on the next Job or event loop tick, if at that exact moment no error handler has been registered for the Promise.</li>
<li>For the cases where you want a rejected Promise to hold onto its rejected state for an indefinite amount of time before observing, you could call <code>defer()</code>, which suppresses automatic error reporting on that Promise.</li>
</ul>

<p>If a Promise is rejected, it defaults to noisily reporting that fact to the developer console (instead of defaulting to silence). You can opt out of that reporting either implicitly (by registering an error handler before rejection), or explicitly (with <code>defer()</code>). In either case, <em>you</em> control the false positives.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> ).<span class="pl-c1">defer</span>();

<span class="pl-c">// `foo(..)` is Promise-aware</span>
foo( <span class="pl-c1">42</span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-k">return</span> p;
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// handle `foo(..)` error</span>
    }
);
...</pre></div>

<p>When we create <code>p</code>, we know we're going to wait a while to use/observe its rejection, so we call <code>defer()</code> -- thus no global reporting. <code>defer()</code> simply returns the same promise, for chaining purposes.</p>

<p>The promise returned from <code>foo(..)</code> gets an error handler attached <em>right away</em>, so it's implicitly opted out and no global reporting for it occurs either.</p>

<p>But the promise returned from the <code>then(..)</code> call has no <code>defer()</code> or error handler attached, so if it rejects (from inside either resolution handler), then <em>it</em> will be reported to the developer console as an uncaught error.</p>

<p><strong>This design is a pit of success.</strong> By default, all errors are either handled or reported -- what almost all developers in almost all cases would expect. You either have to register a handler or you have to intentionally opt out, and indicate you intend to defer error handling until <em>later</em>; you're opting for the extra responsibility in just that specific case.</p>

<p>The only real danger in this approach is if you <code>defer()</code> a Promise but then fail to actually ever observe/handle its rejection.</p>

<p>But you had to intentionally call <code>defer()</code> to opt into that pit of despair -- the default was the pit of success -- so there's not much else we could do to save you from your own mistakes.</p>

<p>I think there's still hope for Promise error handling (post-ES6). I hope the powers that be will rethink the situation and consider this alternative. In the meantime, you can implement this yourself (a challenging exercise for the reader!), or use a <em>smarter</em> Promise library that does so for you!</p>

<p><strong>Note:</strong> This exact model for error handling/reporting is implemented in my <em>asynquence</em> Promise abstraction library, which will be discussed in Appendix A of this book.</p>

<h2><a id="user-content-promise-patterns" class="anchor" href="#promise-patterns" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Patterns</h2>

<p>We've already implicitly seen the sequence pattern with Promise chains (this-then-this-then-that flow control) but there are lots of variations on asynchronous patterns that we can build as abstractions on top of Promises. These patterns serve to simplify the expression of async flow control -- which helps make our code more reason-able and more maintainable -- even in the most complex parts of our programs.</p>

<p>Two such patterns are codified directly into the native ES6 <code>Promise</code> implementation, so we get them for free, to use as building blocks for other patterns.</p>

<h3><a id="user-content-promiseall--" class="anchor" href="#promiseall--" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.all([ .. ])</h3>

<p>In an async sequence (Promise chain), only one async task is being coordinated at any given moment -- step 2 strictly follows step 1, and step 3 strictly follows step 2. But what about doing two or more steps concurrently (aka "in parallel")?</p>

<p>In classic programming terminology, a "gate" is a mechanism that waits on two or more parallel/concurrent tasks to complete before continuing. It doesn't matter what order they finish in, just that all of them have to complete for the gate to open and let the flow control through.</p>

<p>In the Promise API, we call this pattern <code>all([ .. ])</code>.</p>

<p>Say you wanted to make two Ajax requests at the same time, and wait for both to finish, regardless of their order, before making a third Ajax request. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility,</span>
<span class="pl-c">// like we defined earlier in the chapter</span>

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2/<span class="pl-pds">"</span></span> );

Promise.<span class="pl-c1">all</span>( [p1,p2] )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msgs</span>){
    <span class="pl-c">// both `p1` and `p2` fulfill and pass in</span>
    <span class="pl-c">// their messages here</span>
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> msgs.<span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>)
    );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msg</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg );
} );</pre></div>

<p><code>Promise.all([ .. ])</code> expects a single argument, an <code>array</code>, consisting generally of Promise instances. The promise returned from the <code>Promise.all([ .. ])</code> call will receive a fulfillment message (<code>msgs</code> in this snippet) that is an <code>array</code> of all the fulfillment messages from the passed in promises, in the same order as specified (regardless of fulfillment order).</p>

<p><strong>Note:</strong> Technically, the <code>array</code> of values passed into <code>Promise.all([ .. ])</code> can include Promises, thenables, or even immediate values. Each value in the list is essentially passed through <code>Promise.resolve(..)</code> to make sure it's a genuine Promise to be waited on, so an immediate value will just be normalized into a Promise for that value. If the <code>array</code> is empty, the main Promise is immediately fulfilled.</p>

<p>The main promise returned from <code>Promise.all([ .. ])</code> will only be fulfilled if and when all its constituent promises are fulfilled. If any one of those promises instead is rejected, the main <code>Promise.all([ .. ])</code> promise is immediately rejected, discarding all results from any other promises.</p>

<p>Remember to always attach a rejection/error handler to every promise, even and especially the one that comes back from <code>Promise.all([ .. ])</code>.</p>

<h3><a id="user-content-promiserace--" class="anchor" href="#promiserace--" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.race([ .. ])</h3>

<p>While <code>Promise.all([ .. ])</code> coordinates multiple Promises concurrently and assumes all are needed for fulfillment, sometimes you only want to respond to the "first Promise to cross the finish line," letting the other Promises fall away.</p>

<p>This pattern is classically called a "latch," but in Promises it's called a "race."</p>

<p><strong>Warning:</strong> While the metaphor of "only the first across the finish line wins" fits the behavior well, unfortunately "race" is kind of a loaded term, because "race conditions" are generally taken as bugs in programs (see Chapter 1). Don't confuse <code>Promise.race([ .. ])</code> with "race condition."</p>

<p><code>Promise.race([ .. ])</code> also expects a single <code>array</code> argument, containing one or more Promises, thenables, or immediate values. It doesn't make much practical sense to have a race with immediate values, because the first one listed will obviously win -- like a foot race where one runner starts at the finish line!</p>

<p>Similar to <code>Promise.all([ .. ])</code>, <code>Promise.race([ .. ])</code> will fulfill if and when any Promise resolution is a fulfillment, and it will reject if and when any Promise resolution is a rejection.</p>

<p><strong>Warning:</strong> A "race" requires at least one "runner," so if you pass an empty <code>array</code>, instead of immediately resolving, the main <code>race([..])</code> Promise will never resolve. This is a footgun! ES6 should have specified that it either fulfills, rejects, or just throws some sort of synchronous error. Unfortunately, because of precedence in Promise libraries predating ES6 <code>Promise</code>, they had to leave this gotcha in there, so be careful never to send in an empty <code>array</code>.</p>

<p>Let's revisit our previous concurrent Ajax example, but in the context of a race between <code>p1</code> and <code>p2</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility,</span>
<span class="pl-c">// like we defined earlier in the chapter</span>

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2/<span class="pl-pds">"</span></span> );

Promise.race( [p1,p2] )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msg</span>){
    <span class="pl-c">// either `p1` or `p2` will win the race</span>
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> msg
    );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msg</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg );
} );</pre></div>

<p>Because only one promise wins, the fulfillment value is a single message, not an <code>array</code> as it was for <code>Promise.all([ .. ])</code>.</p>

<h4><a id="user-content-timeout-race" class="anchor" href="#timeout-race" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timeout Race</h4>

<p>We saw this example earlier, illustrating how <code>Promise.race([ .. ])</code> can be used to express the "promise timeout" pattern:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `foo()` is a Promise-aware function</span>

<span class="pl-c">// `timeoutPromise(..)`, defined ealier, returns</span>
<span class="pl-c">// a Promise that rejects after a specified delay</span>

<span class="pl-c">// setup a timeout for `foo()`</span>
Promise.race( [
    foo(),                  <span class="pl-c">// attempt `foo()`</span>
    timeoutPromise( <span class="pl-c1">3000</span> )  <span class="pl-c">// give it 3 seconds</span>
] )
.then(
    <span class="pl-k">function</span>(){
        <span class="pl-c">// `foo(..)` fulfilled in time!</span>
    },
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        <span class="pl-c">// either `foo()` rejected, or it just</span>
        <span class="pl-c">// didn't finish in time, so inspect</span>
        <span class="pl-c">// `err` to know which</span>
    }
);</pre></div>

<p>This timeout pattern works well in most cases. But there are some nuances to consider, and frankly they apply to both <code>Promise.race([ .. ])</code> and <code>Promise.all([ .. ])</code> equally.</p>

<h4><a id="user-content-finally" class="anchor" href="#finally" aria-hidden="true"><span class="octicon octicon-link"></span></a>"Finally"</h4>

<p>The key question to ask is, "What happens to the promises that get discarded/ignored?" We're not asking that question from the performance perspective -- they would typically end up garbage collection eligible -- but from the behavioral perspective (side effects, etc.). Promises cannot be canceled -- and shouldn't be as that would destroy the external immutability trust discussed in the "Promise Uncancelable" section later in this chapter -- so they can only be silently ignored.</p>

<p>But what if <code>foo()</code> in the previous example is reserving some sort of resource for usage, but the timeout fires first and causes that promise to be ignored? Is there anything in this pattern that proactively frees the reserved resource after the timeout, or otherwise cancels any side effects it may have had? What if all you wanted was to log the fact that <code>foo()</code> timed out?</p>

<p>Some developers have proposed that Promises need a <code>finally(..)</code> callback registration, which is always called when a Promise resolves, and allows you to specify any cleanup that may be necessary. This doesn't exist in the specification at the moment, but it may come in ES7+. We'll have to wait and see.</p>

<p>It might look like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

p.then( something )
.finally( cleanup )
.then( another )
.finally( cleanup );</pre></div>

<p><strong>Note:</strong> In various Promise libraries, <code>finally(..)</code> still creates and returns a new Promise (to keep the chain going). If the <code>cleanup(..)</code> function were to return a Promise, it would be linked into the chain, which means you could still have the unhandled rejection issues we discussed earlier.</p>

<p>In the meantime, we could make a static helper utility that lets us observe (without interfering) the resolution of a Promise:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// polyfill-safe guard check</span>
<span class="pl-k">if</span> (<span class="pl-k">!</span>Promise.observe) {
    <span class="pl-c1">Promise</span>.<span class="pl-en">observe</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">pr</span>,<span class="pl-smi">cb</span>) {
        <span class="pl-c">// side-observe `pr`'s resolution</span>
        pr.then(
            <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">msg</span>){
                <span class="pl-c">// schedule callback async (as Job)</span>
                Promise.resolve( msg ).then( cb );
            },
            <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
                <span class="pl-c">// schedule callback async (as Job)</span>
                Promise.resolve( err ).then( cb );
            }
        );

        <span class="pl-c">// return original promise</span>
        <span class="pl-k">return</span> pr;
    };
}</pre></div>

<p>Here's how we'd use it in the timeout example from before:</p>

<div class="highlight highlight-js"><pre>Promise.race( [
    Promise.observe(
        foo(),                  <span class="pl-c">// attempt `foo()`</span>
        <span class="pl-k">function</span> <span class="pl-en">cleanup</span>(<span class="pl-smi">msg</span>){
            <span class="pl-c">// clean up after `foo()`, even if it</span>
            <span class="pl-c">// didn't finish before the timeout</span>
        }
    ),
    timeoutPromise( <span class="pl-c1">3000</span> )  <span class="pl-c">// give it 3 seconds</span>
] )</pre></div>

<p>This <code>Promise.observe(..)</code> helper is just an illustration of how you could observe the completions of Promises without interfering with them. Other Promise libraries have their own solutions. Regardless of how you do it, you'll likely have places where you want to make sure your Promises aren't <em>just</em> silently ignored by accident.</p>

<h3><a id="user-content-variations-on-all---and-race--" class="anchor" href="#variations-on-all---and-race--" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variations on all([ .. ]) and race([ .. ])</h3>

<p>While native ES6 Promises come with built-in <code>Promise.all([ .. ])</code> and <code>Promise.race([ .. ])</code>, there are several other commonly used patterns with variations on those semantics:</p>

<ul>
<li><code>none([ .. ])</code> is like <code>all([ .. ])</code>, but fulfillments and rejections are transposed. All Promises need to be rejected -- rejections become the fulfillment values and vice versa.</li>
<li><code>any([ .. ])</code> is like <code>all([ .. ])</code>, but it ignores any rejections, so only one needs to fulfill instead of <em>all</em> of them.</li>
<li><code>first([ .. ])</code> is a like a race with <code>any([ .. ])</code>, which is that it ignores any rejections and fulfills as soon as the first Promise fulfills.</li>
<li><code>last([ .. ])</code> is like <code>first([ .. ])</code>, but only the latest fulfillment wins.</li>
</ul>

<p>Some Promise abstraction libraries provide these, but you could also define them yourself using the mechanics of Promises, <code>race([ .. ])</code> and <code>all([ .. ])</code>.</p>

<p>For example, here's how we could define <code>first([ .. ])</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// polyfill-safe guard check</span>
<span class="pl-k">if</span> (<span class="pl-k">!</span>Promise.first) {
    <span class="pl-c1">Promise</span>.<span class="pl-en">first</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">prs</span>) {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
            <span class="pl-c">// loop through all promises</span>
            prs.forEach( <span class="pl-k">function</span>(<span class="pl-smi">pr</span>){
                <span class="pl-c">// normalize the value</span>
                Promise.resolve( pr )
                <span class="pl-c">// whichever one fulfills first wins, and</span>
                <span class="pl-c">// gets to resolve the main promise</span>
                .then( resolve );
            } );
        } );
    };
}</pre></div>

<p><strong>Note:</strong> This implementation of <code>first(..)</code> does not reject if all its promises reject; it simply hangs, much like a <code>Promise.race([])</code> does. If desired, you could add additional logic to track each promise rejection and if all reject, call <code>reject()</code> on the main promise. We'll leave that as an exercise for the reader.</p>

<h3><a id="user-content-concurrent-iterations" class="anchor" href="#concurrent-iterations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concurrent Iterations</h3>

<p>Sometimes you want to iterate over a list of Promises and perform some task against all of them, much like you can do with synchronous <code>array</code>s (e.g., <code>forEach(..)</code>, <code>map(..)</code>, <code>some(..)</code>, and <code>every(..)</code>). If the task to perform against each Promise is fundamentally synchronous, these work fine, just as we used <code>forEach(..)</code> in the previous snippet.</p>

<p>But if the tasks are fundamentally asynchronous, or can/should otherwise be performed concurrently, you can use async versions of these utilities as provided by many libraries.</p>

<p>For example, let's consider an asynchronous <code>map(..)</code> utility that takes an <code>array</code> of values (could be Promises or anything else), plus a function (task) to perform against each. <code>map(..)</code> itself returns a promise whose fulfillment value is an <code>array</code> that holds (in the same mapping order) the async fulfillment value from each task:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span>Promise.map) {
    <span class="pl-c1">Promise</span>.<span class="pl-en">map</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">vals</span>,<span class="pl-smi">cb</span>) {
        <span class="pl-c">// new promise that waits for all mapped promises</span>
        <span class="pl-k">return</span> Promise.<span class="pl-c1">all</span>(
            <span class="pl-c">// note: regular array `map(..)`, turns</span>
            <span class="pl-c">// the array of values into an array of</span>
            <span class="pl-c">// promises</span>
            vals.map( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
                <span class="pl-c">// replace `val` with a new promise that</span>
                <span class="pl-c">// resolves after `val` is async mapped</span>
                <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>){
                    cb( val, resolve );
                } );
            } )
        );
    };
}</pre></div>

<p><strong>Note:</strong> In this implementation of <code>map(..)</code>, you can't signal async rejection, but if a synchronous exception/error occurs inside of the mapping callback (<code>cb(..)</code>), the main <code>Promise.map(..)</code> returned promise would reject.</p>

<p>Let's illustrate using <code>map(..)</code> with a list of Promises (instead of simple values):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">21</span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );
<span class="pl-k">var</span> p3 <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );

<span class="pl-c">// double values in list even if they're in</span>
<span class="pl-c">// Promises</span>
Promise.map( [p1,p2,p3], <span class="pl-k">function</span>(<span class="pl-smi">pr</span>,<span class="pl-smi">done</span>){
    <span class="pl-c">// make sure the item itself is a Promise</span>
    Promise.resolve( pr )
    .then(
        <span class="pl-c">// extract value as `v`</span>
        <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
            <span class="pl-c">// map fulfillment `v` to new value</span>
            done( v <span class="pl-k">*</span> <span class="pl-c1">2</span> );
        },
        <span class="pl-c">// or, map to promise rejection message</span>
        done
    );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">vals</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( vals );    <span class="pl-c">// [42,84,"Oops"]</span>
} );</pre></div>

<h2><a id="user-content-promise-api-recap" class="anchor" href="#promise-api-recap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise API Recap</h2>

<p>Let's review the ES6 <code>Promise</code> API that we've already seen unfold in bits and pieces throughout this chapter.</p>

<p><strong>Note:</strong> The following API is native only as of ES6, but there are specification-compliant polyfills (not just extended Promise libraries) which can define <code>Promise</code> and all its associated behavior so that you can use native Promises even in pre-ES6 browsers. One such polyfill is "Native Promise Only" (<a href="http://github.com/getify/native-promise-only">http://github.com/getify/native-promise-only</a>), which I wrote!</p>

<h3><a id="user-content-new-promise-constructor" class="anchor" href="#new-promise-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new Promise(..) Constructor</h3>

<p>The <em>revealing constructor</em> <code>Promise(..)</code> must be used with <code>new</code>, and must be provided a function callback that is synchronously/immediately called. This function is passed two function callbacks that act as resolution capabilities for the promise. We commonly label these <code>resolve(..)</code> and <code>reject(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c">// `resolve(..)` to resolve/fulfill the promise</span>
    <span class="pl-c">// `reject(..)` to reject the promise</span>
} );</pre></div>

<p><code>reject(..)</code> simply rejects the promise, but <code>resolve(..)</code> can either fulfill the promise or reject it, depending on what it's passed. If <code>resolve(..)</code> is passed an immediate, non-Promise, non-thenable value, then the promise is fulfilled with that value.</p>

<p>But if <code>resolve(..)</code> is passed a genuine Promise or thenable value, that value is unwrapped recursively, and whatever its final resolution/state is will be adopted by the promise.</p>

<h3><a id="user-content-promiseresolve-and-promisereject" class="anchor" href="#promiseresolve-and-promisereject" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.resolve(..) and Promise.reject(..)</h3>

<p>A shortcut for creating an already-rejected Promise is <code>Promise.reject(..)</code>, so these two promises are equivalent:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
} );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );</pre></div>

<p><code>Promise.resolve(..)</code> is usually used to create an already-fulfilled Promise in a similar way to <code>Promise.reject(..)</code>. However, <code>Promise.resolve(..)</code> also unwraps thenable values (as discussed several times already). In that case, the Promise returned adopts the final resolution of the thenable you passed in, which could either be fulfillment or rejection:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> fulfilledTh <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) { cb( <span class="pl-c1">42</span> ); }
};
<span class="pl-k">var</span> rejectedTh <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>,<span class="pl-smi">errCb</span>) {
        errCb( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( fulfilledTh );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.resolve( rejectedTh );

<span class="pl-c">// `p1` will be a fulfilled promise</span>
<span class="pl-c">// `p2` will be a rejected promise</span></pre></div>

<p>And remember, <code>Promise.resolve(..)</code> doesn't do anything if what you pass is already a genuine Promise; it just returns the value directly. So there's no overhead to calling <code>Promise.resolve(..)</code> on values that you don't know the nature of, if one happens to already be a genuine Promise.</p>

<h3><a id="user-content-then-and-catch" class="anchor" href="#then-and-catch" aria-hidden="true"><span class="octicon octicon-link"></span></a>then(..) and catch(..)</h3>

<p>Each Promise instance (<strong>not</strong> the <code>Promise</code> API namespace) has <code>then(..)</code> and <code>catch(..)</code> methods, which allow registering of fulfillment and rejection handlers for the Promise. Once the Promise is resolved, one or the other of these handlers will be called, but not both, and it will always be called asynchronously (see "Jobs" in Chapter 1).</p>

<p><code>then(..)</code> takes one or two parameters, the first for the fulfillment callback, and the second for the rejection callback. If either is omitted or is otherwise passed as a non-function value, a default callback is substituted respectively. The default fulfillment callback simply passes the message along, while the default rejection callback simply rethrows (propagates) the error reason it receives.</p>

<p><code>catch(..)</code> takes only the rejection callback as a parameter, and automatically substitutes the default fulfillment callback, as just discussed. In other words, it's equivalent to <code>then(null,..)</code>:</p>

<div class="highlight highlight-js"><pre>p.then( fulfilled );

p.then( fulfilled, rejected );

p.catch( rejected ); <span class="pl-c">// or `p.then( null, rejected )`</span></pre></div>

<p><code>then(..)</code> and <code>catch(..)</code> also create and return a new promise, which can be used to express Promise chain flow control. If the fulfillment or rejection callbacks have an exception thrown, the returned promise is rejected. If either callback returns an immediate, non-Promise, non-thenable value, that value is set as the fulfillment for the returned promise. If the fulfillment handler specifically returns a promise or thenable value, that value is unwrapped and becomes the resolution of the returned promise.</p>

<h3><a id="user-content-promiseall---and-promiserace--" class="anchor" href="#promiseall---and-promiserace--" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise.all([ .. ]) and Promise.race([ .. ])</h3>

<p>The static helpers <code>Promise.all([ .. ])</code> and <code>Promise.race([ .. ])</code> on the ES6 <code>Promise</code> API both create a Promise as their return value. The resolution of that promise is controlled entirely by the array of promises that you pass in.</p>

<p>For <code>Promise.all([ .. ])</code>, all the promises you pass in must fulfill for the returned promise to fulfill. If any promise is rejected, the main returned promise is immediately rejected, too (discarding the results of any of the other promises). For fulfillment, you receive an <code>array</code> of all the passed in promises' fulfillment values. For rejection, you receive just the first promise rejection reason value. This pattern is classically called a "gate": all must arrive before the gate opens.</p>

<p>For <code>Promise.race([ .. ])</code>, only the first promise to resolve (fulfillment or rejection) "wins," and whatever that resolution is becomes the resolution of the returned promise. This pattern is classically called a "latch": first one to open the latch gets through. Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> Promise.resolve( <span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> p3 <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );

Promise.race( [p1,p2,p3] )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msg</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msg );     <span class="pl-c">// 42</span>
} );

Promise.<span class="pl-c1">all</span>( [p1,p2,p3] )
.catch( <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );   <span class="pl-c">// "Oops"</span>
} );

Promise.<span class="pl-c1">all</span>( [p1,p2] )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msgs</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( msgs );    <span class="pl-c">// [42,"Hello World"]</span>
} );</pre></div>

<p><strong>Warning:</strong> Be careful! If an empty <code>array</code> is passed to <code>Promise.all([ .. ])</code>, it will fulfill immediately, but <code>Promise.race([ .. ])</code> will hang forever and never resolve.</p>

<p>The ES6 <code>Promise</code> API is pretty simple and straightforward. It's at least good enough to serve the most basic of async cases, and is a good place to start when rearranging your code from callback hell to something better.</p>

<p>But there's a whole lot of async sophistication that apps often demand which Promises themselves will be limited in addressing. In the next section, we'll dive into those limitations as motivations for the benefit of Promise libraries.</p>

<h2><a id="user-content-promise-limitations" class="anchor" href="#promise-limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Limitations</h2>

<p>Many of the details we'll discuss in this section have already been alluded to in this chapter, but we'll just make sure to review these limitations specifically.</p>

<h3><a id="user-content-sequence-error-handling" class="anchor" href="#sequence-error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequence Error Handling</h3>

<p>We covered Promise-flavored error handling in detail earlier in this chapter. The limitations of how Promises are designed -- how they chain, specifically -- creates a very easy pitfall where an error in a Promise chain can be silently ignored accidentally.</p>

<p>But there's something else to consider with Promise errors. Because a Promise chain is nothing more than its constituent Promises wired together, there's no entity to refer to the entire chain as a single <em>thing</em>, which means there's no external way to observe any errors that may occur.</p>

<p>If you construct a Promise chain that has no error handling in it, any error anywhere in the chain will propagate indefinitely down the chain, until observed (by registering a rejection handler at some step). So, in that specific case, having a reference to the <em>last</em> promise in the chain is enough (<code>p</code> in the following snippet), because you can register a rejection handler there, and it will be notified of any propagated errors:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `foo(..)`, `STEP2(..)` and `STEP3(..)` are</span>
<span class="pl-c">// all promise-aware utilities</span>

<span class="pl-k">var</span> p <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> )
.then( <span class="pl-c1">STEP2</span> )
.then( <span class="pl-c1">STEP3</span> );</pre></div>

<p>Although it may seem sneakily confusing, <code>p</code> here doesn't point to the first promise in the chain (the one from the <code>foo(42)</code> call), but instead from the last promise, the one that comes from the <code>then(STEP3)</code> call.</p>

<p>Also, no step in the promise chain is observably doing its own error handling. That means that you could then register a rejection error handler on <code>p</code>, and it would be notified if any errors occur anywhere in the chain:</p>

<pre><code>p.catch( handleErrors );
</code></pre>

<p>But if any step of the chain in fact does its own error handling (perhaps hidden/abstracted away from what you can see), your <code>handleErrors(..)</code> won't be notified. This may be what you want -- it was, after all, a "handled rejection" -- but it also may <em>not</em> be what you want. The complete lack of ability to be notified (of "already handled" rejection errors) is a limitation that restricts capabilities in some use cases.</p>

<p>It's basically the same limitation that exists with a <code>try..catch</code> that can catch an exception and simply swallow it. So this isn't a limitation <strong>unique to Promises</strong>, but it <em>is</em> something we might wish to have a workaround for.</p>

<p>Unfortunately, many times there is no reference kept for the intermediate steps in a Promise-chain sequence, so without such references, you cannot attach error handlers to reliably observe the errors.</p>

<h3><a id="user-content-single-value" class="anchor" href="#single-value" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single Value</h3>

<p>Promises by definition only have a single fulfillment value or a single rejection reason. In simple examples, this isn't that big of a deal, but in more sophisticated scenarios, you may find this limiting.</p>

<p>The typical advice is to construct a values wrapper (such as an <code>object</code> or <code>array</code>) to contain these multiple messages. This solution works, but it can be quite awkward and tedious to wrap and unwrap your messages with every single step of your Promise chain.</p>

<h4><a id="user-content-splitting-values" class="anchor" href="#splitting-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Splitting Values</h4>

<p>Sometimes you can take this as a signal that you could/should decompose the problem into two or more Promises.</p>

<p>Imagine you have a utility <code>foo(..)</code> that produces two values (<code>x</code> and <code>y</code>) asynchronously:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">getY</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
            resolve( (<span class="pl-c1">3</span> <span class="pl-k">*</span> x) <span class="pl-k">-</span> <span class="pl-c1">1</span> );
        }, <span class="pl-c1">100</span> );
    } );
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">bar</span>,<span class="pl-smi">baz</span>) {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> bar <span class="pl-k">*</span> baz;

    <span class="pl-k">return</span> getY( x )
    .then( <span class="pl-k">function</span>(<span class="pl-smi">y</span>){
        <span class="pl-c">// wrap both values into container</span>
        <span class="pl-k">return</span> [x,y];
    } );
}

foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
.then( <span class="pl-k">function</span>(<span class="pl-smi">msgs</span>){
    <span class="pl-k">var</span> x <span class="pl-k">=</span> msgs[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> y <span class="pl-k">=</span> msgs[<span class="pl-c1">1</span>];

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );    <span class="pl-c">// 200 599</span>
} );</pre></div>

<p>First, let's rearrange what <code>foo(..)</code> returns so that we don't have to wrap <code>x</code> and <code>y</code> into a single <code>array</code> value to transport through one Promise. Instead, we can wrap each value into its own promise:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">bar</span>,<span class="pl-smi">baz</span>) {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> bar <span class="pl-k">*</span> baz;

    <span class="pl-c">// return both promises</span>
    <span class="pl-k">return</span> [
        Promise.resolve( x ),
        getY( x )
    ];
}

Promise.<span class="pl-c1">all</span>(
    foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
)
.then( <span class="pl-k">function</span>(<span class="pl-smi">msgs</span>){
    <span class="pl-k">var</span> x <span class="pl-k">=</span> msgs[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> y <span class="pl-k">=</span> msgs[<span class="pl-c1">1</span>];

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
} );</pre></div>

<p>Is an <code>array</code> of promises really better than an <code>array</code> of values passed through a single promise? Syntactically, it's not much of an improvement.</p>

<p>But this approach more closely embraces the Promise design theory. It's now easier in the future to refactor to split the calculation of <code>x</code> and <code>y</code> into separate functions. It's cleaner and more flexible to let the calling code decide how to orchestrate the two promises -- using <code>Promise.all([ .. ])</code> here, but certainly not the only option -- rather than to abstract such details away inside of <code>foo(..)</code>.</p>

<h4><a id="user-content-unwrapspread-arguments" class="anchor" href="#unwrapspread-arguments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unwrap/Spread Arguments</h4>

<p>The <code>var x = ..</code> and <code>var y = ..</code> assignments are still awkward overhead. We can employ some functional trickery (hat tip to Reginald Braithwaite, @raganwald on Twitter) in a helper utility:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">spread</span>(<span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-c1">Function</span>.apply.bind( fn, <span class="pl-c1">null</span> );
}

Promise.<span class="pl-c1">all</span>(
    foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
)
.then(
    spread( <span class="pl-k">function</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );    <span class="pl-c">// 200 599</span>
    } )
)</pre></div>

<p>That's a bit nicer! Of course, you could inline the functional magic to avoid the extra helper:</p>

<div class="highlight highlight-js"><pre>Promise.<span class="pl-c1">all</span>(
    foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
)
.then( <span class="pl-c1">Function</span>.apply.bind(
    <span class="pl-k">function</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );    <span class="pl-c">// 200 599</span>
    },
    <span class="pl-c1">null</span>
) );</pre></div>

<p>These tricks may be neat, but ES6 has an even better answer for us: destructuring. The array destructuring assignment form looks like this:</p>

<div class="highlight highlight-js"><pre>Promise.<span class="pl-c1">all</span>(
    foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
)
.then( <span class="pl-k">function</span>(<span class="pl-smi">msgs</span>){
    <span class="pl-k">var</span> [x,y] <span class="pl-k">=</span> msgs;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );    <span class="pl-c">// 200 599</span>
} );</pre></div>

<p>But best of all, ES6 offers the array parameter destructuring form:</p>

<div class="highlight highlight-js"><pre>Promise.<span class="pl-c1">all</span>(
    foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> )
)
.then( <span class="pl-k">function</span>([<span class="pl-smi">x</span>,<span class="pl-smi">y</span>]){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );    <span class="pl-c">// 200 599</span>
} );</pre></div>

<p>We've now embraced the one-value-per-Promise mantra, but kept our supporting boilerplate to a minimum!</p>

<p><strong>Note:</strong> For more information on ES6 destructuring forms, see the <em>ES6 &amp; Beyond</em> title of this series.</p>

<h3><a id="user-content-single-resolution" class="anchor" href="#single-resolution" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single Resolution</h3>

<p>One of the most intrinsic behaviors of Promises is that a Promise can only be resolved once (fulfillment or rejection). For many async use cases, you're only retrieving a value once, so this works fine.</p>

<p>But there's also a lot of async cases that fit into a different model -- one that's more akin to events and/or streams of data. It's not clear on the surface how well Promises can fit into such use cases, if at all. Without a significant abstraction on top of Promises, they will completely fall short for handling multiple value resolution.</p>

<p>Imagine a scenario where you might want to fire off a sequence of async steps in response to a stimulus (like an event) that can in fact happen multiple times, like a button click.</p>

<p>This probably won't work the way you want:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `click(..)` binds the `"click"` event to a DOM element</span>
<span class="pl-c">// `request(..)` is the previously defined Promise-aware Ajax</span>

<span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c1">click</span>( <span class="pl-s"><span class="pl-pds">"</span>#mybtn<span class="pl-pds">"</span></span>, resolve );
} );

p.then( <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
    <span class="pl-k">var</span> btnID <span class="pl-k">=</span> evt.currentTarget.<span class="pl-c1">id</span>;
    <span class="pl-k">return</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?id=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> btnID );
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">text</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
} );</pre></div>

<p>The behavior here only works if your application calls for the button to be clicked just once. If the button is clicked a second time, the <code>p</code> promise has already been resolved, so the second <code>resolve(..)</code> call would be ignored.</p>

<p>Instead, you'd probably need to invert the paradigm, creating a whole new Promise chain for each event firing:</p>

<div class="highlight highlight-js"><pre><span class="pl-c1">click</span>( <span class="pl-s"><span class="pl-pds">"</span>#mybtn<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
    <span class="pl-k">var</span> btnID <span class="pl-k">=</span> evt.currentTarget.<span class="pl-c1">id</span>;

    request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?id=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> btnID )
    .then( <span class="pl-k">function</span>(<span class="pl-smi">text</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    } );
} );</pre></div>

<p>This approach will <em>work</em> in that a whole new Promise sequence will be fired off for each <code>"click"</code> event on the button.</p>

<p>But beyond just the ugliness of having to define the entire Promise chain inside the event handler, this design in some respects violates the idea of separation of concerns/capabilities (SoC). You might very well want to define your event handler in a different place in your code from where you define the <em>response</em> to the event (the Promise chain). That's pretty awkward to do in this pattern, without helper mechanisms.</p>

<p><strong>Note:</strong> Another way of articulating this limitation is that it'd be nice if we could construct some sort of "observable" that we can subscribe a Promise chain to. There are libraries that have created these abstractions (such as RxJS -- <a href="http://rxjs.codeplex.com/">http://rxjs.codeplex.com/</a>), but the abstractions can seem so heavy that you can't even see the nature of Promises anymore. Such heavy abstraction brings important questions to mind such as whether (sans Promises) these mechanisms are as <em>trustable</em> as Promises themselves have been designed to be. We'll revisit the "Observable" pattern in Appendix B.</p>

<h3><a id="user-content-inertia" class="anchor" href="#inertia" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inertia</h3>

<p>One concrete barrier to starting to use Promises in your own code is all the code that currently exists which is not already Promise-aware. If you have lots of callback-based code, it's far easier to just keep coding in that same style.</p>

<p>"A code base in motion (with callbacks) will remain in motion (with callbacks) unless acted upon by a smart, Promises-aware developer."</p>

<p>Promises offer a different paradigm, and as such, the approach to the code can be anywhere from just a little different to, in some cases, radically different. You have to be intentional about it, because Promises will not just naturally shake out from the same ol' ways of doing code that have served you well thus far.</p>

<p>Consider a callback-based scenario like the following:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">cb</span>) {
    ajax(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y,
        cb
    );
}

foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">text</span>) {
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    }
} );</pre></div>

<p>Is it immediately obvious what the first steps are to convert this callback-based code to Promise-aware code? Depends on your experience. The more practice you have with it, the more natural it will feel. But certainly, Promises don't just advertise on the label exactly how to do it -- there's no one-size-fits-all answer -- so the responsibility is up to you.</p>

<p>As we've covered before, we definitely need an Ajax utility that is Promise-aware instead of callback-based, which we could call <code>request(..)</code>. You can make your own, as we have already. But the overhead of having to manually define Promise-aware wrappers for every callback-based utility makes it less likely you'll choose to refactor to Promise-aware coding at all.</p>

<p>Promises offer no direct answer to that limitation. Most Promise libraries do offer a helper, however. But even without a library, imagine a helper like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// polyfill-safe guard check</span>
<span class="pl-k">if</span> (<span class="pl-k">!</span>Promise.wrap) {
    <span class="pl-c1">Promise</span>.<span class="pl-en">wrap</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">fn</span>) {
        <span class="pl-k">return</span> <span class="pl-k">function</span>() {
            <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments );

            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
                fn.<span class="pl-c1">apply</span>(
                    <span class="pl-c1">null</span>,
                    args.<span class="pl-c1">concat</span>( <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">v</span>){
                        <span class="pl-k">if</span> (err) {
                            reject( err );
                        }
                        <span class="pl-k">else</span> {
                            resolve( v );
                        }
                    } )
                );
            } );
        };
    };
}</pre></div>

<p>OK, that's more than just a tiny trivial utility. However, although it may look a bit intimidating, it's not as bad as you'd think. It takes a function that expects an error-first style callback as its last parameter, and returns a new one that automatically creates a Promise to return, and substitutes the callback for you, wired up to the Promise fulfillment/rejection.</p>

<p>Rather than waste too much time talking about <em>how</em> this <code>Promise.wrap(..)</code> helper works, let's just look at how we use it:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> request <span class="pl-k">=</span> Promise.wrap( ajax );

request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/<span class="pl-pds">"</span></span> )
.then( .. )
..</pre></div>

<p>Wow, that was pretty easy!</p>

<p><code>Promise.wrap(..)</code> does <strong>not</strong> produce a Promise. It produces a function that will produce Promises. In a sense, a Promise-producing function could be seen as a "Promise factory." I propose "promisory" as the name for such a thing ("Promise" + "factory").</p>

<p>The act of wrapping a callback-expecting function to be a Promise-aware function is sometimes referred to as "lifting" or "promisifying". But there doesn't seem to be a standard term for what to call the resultant function other than a "lifted function", so I like "promisory" better as I think it's more descriptive.</p>

<p><strong>Note:</strong> Promisory isn't a made-up term. It's a real word, and its definition means to contain or convey a promise. That's exactly what these functions are doing, so it turns out to be a pretty perfect terminology match!</p>

<p>So, <code>Promise.wrap(ajax)</code> produces an <code>ajax(..)</code> promisory we call <code>request(..)</code>, and that promisory produces Promises for Ajax responses.</p>

<p>If all functions were already promisories, we wouldn't need to make them ourselves, so the extra step is a tad bit of a shame. But at least the wrapping pattern is (usually) repeatable so we can put it into a <code>Promise.wrap(..)</code> helper as shown to aid our promise coding.</p>

<p>So back to our earlier example, we need a promisory for both <code>ajax(..)</code> and <code>foo(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// make a promisory for `ajax(..)`</span>
<span class="pl-k">var</span> request <span class="pl-k">=</span> Promise.wrap( ajax );

<span class="pl-c">// refactor `foo(..)`, but keep it externally</span>
<span class="pl-c">// callback-based for compatibility with other</span>
<span class="pl-c">// parts of the code for now -- only use</span>
<span class="pl-c">// `request(..)`'s promise internally.</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">cb</span>) {
    request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y
    )
    .then(
        <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">text</span>){
            cb( <span class="pl-c1">null</span>, text );
        },
        cb
    );
}

<span class="pl-c">// now, for this code's purposes, make a</span>
<span class="pl-c">// promisory for `foo(..)`</span>
<span class="pl-k">var</span> betterFoo <span class="pl-k">=</span> Promise.wrap( foo );

<span class="pl-c">// and use the promisory</span>
betterFoo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">text</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
);</pre></div>

<p>Of course, while we're refactoring <code>foo(..)</code> to use our new <code>request(..)</code> promisory, we could just make <code>foo(..)</code> a promisory itself, instead of remaining callback-based and needing to make and use the subsequent <code>betterFoo(..)</code> promisory. This decision just depends on whether <code>foo(..)</code> needs to stay callback-based compatible with other parts of the code base or not.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `foo(..)` is now also a promisory because it</span>
<span class="pl-c">// delegates to the `request(..)` promisory</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y
    );
}

foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> )
.then( .. )
..</pre></div>

<p>While ES6 Promises don't natively ship with helpers for such promisory wrapping, most libraries provide them, or you can make your own. Either way, this particular limitation of Promises is addressable without too much pain (certainly compared to the pain of callback hell!).</p>

<h3><a id="user-content-promise-uncancelable" class="anchor" href="#promise-uncancelable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Uncancelable</h3>

<p>Once you create a Promise and register a fulfillment and/or rejection handler for it, there's nothing external you can do to stop that progression if something else happens to make that task moot.</p>

<p><strong>Note:</strong> Many Promise abstraction libraries provide facilities to cancel Promises, but this is a terrible idea! Many developers wish Promises had natively been designed with external cancelation capability, but the problem is that it would let one consumer/observer of a Promise affect some other consumer's ability to observe that same Promise. This violates the future-value's trustability (external immutability), but morever is the embodiment of the "action at a distance" anti-pattern (<a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29">http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29</a>). Regardless of how useful it seems, it will actually lead you straight back into the same nightmares as callbacks.</p>

<p>Consider our Promise timeout scenario from earlier:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

Promise.race( [
    p,
    timeoutPromise( <span class="pl-c1">3000</span> )
] )
.then(
    doSomething,
    handleError
);

p.then( <span class="pl-k">function</span>(){
    <span class="pl-c">// still happens even in the timeout case :(</span>
} );</pre></div>

<p>The "timeout" was external to the promise <code>p</code>, so <code>p</code> itself keeps going, which we probably don't want.</p>

<p>One option is to invasively define your resolution callbacks:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> <span class="pl-c1">OK</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;

<span class="pl-k">var</span> p <span class="pl-k">=</span> foo( <span class="pl-c1">42</span> );

Promise.race( [
    p,
    timeoutPromise( <span class="pl-c1">3000</span> )
    .catch( <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        <span class="pl-c1">OK</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
        <span class="pl-k">throw</span> err;
    } )
] )
.then(
    doSomething,
    handleError
);

p.then( <span class="pl-k">function</span>(){
    <span class="pl-k">if</span> (<span class="pl-c1">OK</span>) {
        <span class="pl-c">// only happens if no timeout! :)</span>
    }
} );</pre></div>

<p>This is ugly. It works, but it's far from ideal. Generally, you should try to avoid such scenarios.</p>

<p>But if you can't, the ugliness of this solution should be a clue that <em>cancelation</em> is a functionality that belongs at a higher level of abstraction on top of Promises. I'd recommend you look to Promise abstraction libraries for assistance rather than hacking it yourself.</p>

<p><strong>Note:</strong> My <em>asynquence</em> Promise abstraction library provides just such an abstraction and an <code>abort()</code> capability for the sequence, all of which will be discussed in Appendix A.</p>

<p>A single Promise is not really a flow-control mechanism (at least not in a very meaningful sense), which is exactly what <em>cancelation</em> refers to; that's why Promise cancelation would feel awkward.</p>

<p>By contrast, a chain of Promises taken collectively together -- what I like to call a "sequence" -- <em>is</em> a flow control expression, and thus it's appropriate for cancelation to be defined at that level of abstraction.</p>

<p>No individual Promise should be cancelable, but it's sensible for a <em>sequence</em> to be cancelable, because you don't pass around a sequence as a single immutable value like you do with a Promise.</p>

<h3><a id="user-content-promise-performance" class="anchor" href="#promise-performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Performance</h3>

<p>This particular limitation is both simple and complex.</p>

<p>Comparing how many pieces are moving with a basic callback-based async task chain versus a Promise chain, it's clear Promises have a fair bit more going on, which means they are naturally at least a tiny bit slower. Think back to just the simple list of trust guarantees that Promises offer, as compared to the ad hoc solution code you'd have to layer on top of callbacks to achieve the same protections.</p>

<p>More work to do, more guards to protect, means that Promises <em>are</em> slower as compared to naked, untrustable callbacks. That much is obvious, and probably simple to wrap your brain around.</p>

<p>But how much slower? Well... that's actually proving to be an incredibly difficult question to answer absolutely, across the board.</p>

<p>Frankly, it's kind of an apples-to-oranges comparison, so it's probably the wrong question to ask. You should actually compare whether an ad-hoc callback system with all the same protections manually layered in is faster than a Promise implementation.</p>

<p>If Promises have a legitimate performance limitation, it's more that they don't really offer a line-item choice as to which trustability protections you want/need or not -- you get them all, always.</p>

<p>Nevertheless, if we grant that a Promise is generally a <em>little bit slower</em> than its non-Promise, non-trustable callback equivalent -- assuming there are places where you feel you can justify the lack of trustability -- does that mean that Promises should be avoided across the board, as if your entire application is driven by nothing but must-be-utterly-the-fastest code possible?</p>

<p>Sanity check: if your code is legitimately like that, <strong>is JavaScript even the right language for such tasks?</strong> JavaScript can be optimized to run applications very performantly (see Chapter 5 and Chapter 6). But is obsessing over tiny performance tradeoffs with Promises, in light of all the benefits they offer, <em>really</em> appropriate?</p>

<p>Another subtle issue is that Promises make <em>everything</em> async, which means that some immediately (synchronously) complete steps still defer advancement of the next step to a Job (see Chapter 1). That means that it's possible that a sequence of Promise tasks could complete ever-so-slightly slower than the same sequence wired up with callbacks.</p>

<p>Of course, the question here is this: are these potential slips in tiny fractions of performance <em>worth</em> all the other articulated benefits of Promises we've laid out across this chapter?</p>

<p>My take is that in virtually all cases where you might think Promise performance is slow enough to be concerned, it's actually an anti-pattern to optimize away the benefits of Promise trustability and composability by avoiding them altogether.</p>

<p>Instead, you should default to using them across the code base, and then profile and analyze your application's hot (critical) paths. Are Promises <em>really</em> a bottleneck, or are they just a theoretical slowdown? Only <em>then</em>, armed with actual valid benchmarks (see Chapter 6) is it responsible and prudent to factor out the Promises in just those identified critical areas.</p>

<p>Promises are a little slower, but in exchange you're getting a lot of trustability, non-Zalgo predictability, and composability built in. Maybe the limitation is not actually their performance, but your lack of perception of their benefits?</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Promises are awesome. Use them. They solve the <em>inversion of control</em> issues that plague us with callbacks-only code.</p>

<p>They don't get rid of callbacks, they just redirect the orchestration of those callbacks to a trustable intermediary mechanism that sits between us and another utility.</p>

<p>Promise chains also begin to address (though certainly not perfectly) a better way of expressing async flow in sequential fashion, which helps our brains plan and maintain async JS code better. We'll see an even better solution to <em>that</em> problem in the next chapter!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-async--performance" class="anchor" href="#you-dont-know-js-async--performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Async &amp; Performance</h1>

<h1><a id="user-content-chapter-4-generators" class="anchor" href="#chapter-4-generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4: Generators</h1>

<p>In Chapter 2, we identified two key drawbacks to expressing async flow control with callbacks:</p>

<ul>
<li>Callback-based async doesn't fit how our brain plans out steps of a task.</li>
<li>Callbacks aren't trustable or composable because of <em>inversion of control</em>.</li>
</ul>

<p>In Chapter 3, we detailed how Promises uninvert the <em>inversion of control</em> of callbacks, restoring trustability/composability.</p>

<p>Now we turn our attention to expressing async flow control in a sequential, synchronous-looking fashion. The "magic" that makes it possible is ES6 <strong>generators</strong>.</p>

<h2><a id="user-content-breaking-run-to-completion" class="anchor" href="#breaking-run-to-completion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Breaking Run-to-Completion</h2>

<p>In Chapter 1, we explained an expectation that JS developers almost universally rely on in their code: once a function starts executing, it runs until it completes, and no other code can interrupt and run in between.</p>

<p>As bizarre as it may seem, ES6 introduces a new type of function that does not behave with the run-to-completion behavior. This new type of function is called a "generator."</p>

<p>To understand the implications, let's consider this example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    x<span class="pl-k">++</span>;
    bar();              <span class="pl-c">// &lt;-- what about this line?</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>x:<span class="pl-pds">"</span></span>, x );
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    x<span class="pl-k">++</span>;
}

foo();                  <span class="pl-c">// x: 3</span></pre></div>

<p>In this example, we know for sure that <code>bar()</code> runs in between <code>x++</code> and <code>console.log(x)</code>. But what if <code>bar()</code> wasn't there? Obviously the result would be <code>2</code> instead of <code>3</code>.</p>

<p>Now let's twist your brain. What if <code>bar()</code> wasn't present, but it could still somehow run between the <code>x++</code> and <code>console.log(x)</code> statements? How would that be possible?</p>

<p>In <strong>preemptive</strong> multithreaded languages, it would essentially be possible for <code>bar()</code> to "interrupt" and run at exactly the right moment between those two statements. But JS is not preemptive, nor is it (currently) multithreaded. And yet, a <strong>cooperative</strong> form of this "interruption" (concurrency) is possible, if <code>foo()</code> itself could somehow indicate a "pause" at that part in the code.</p>

<p><strong>Note:</strong> I use the word "cooperative" not only because of the connection to classical concurrency terminology (see Chapter 1), but because as you'll see in the next snippet, the ES6 syntax for indicating a pause point in code is <code>yield</code> -- suggesting a politely <em>cooperative</em> yielding of control.</p>

<p>Here's the ES6 code to accomplish such cooperative concurrency:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    x<span class="pl-k">++</span>;
    <span class="pl-k">yield</span>; <span class="pl-c">// pause!</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>x:<span class="pl-pds">"</span></span>, x );
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    x<span class="pl-k">++</span>;
}</pre></div>

<p><strong>Note:</strong> You will likely see most other JS documentation/code that will format a generator declaration as <code>function* foo() { .. }</code> instead of as I've done here with <code>function *foo() { .. }</code> -- the only difference being the stylistic positioning of the <code>*</code>. The two forms are functionally/syntactically identical, as is a third <code>function*foo() { .. }</code> (no space) form. There are arguments for both styles, but I basically prefer <code>function *foo..</code> because it then matches when I reference a generator in writing with <code>*foo()</code>. If I said only <code>foo()</code>, you wouldn't know as clearly if I was talking about a generator or a regular function. It's purely a stylistic preference.</p>

<p>Now, how can we run the code in that previous snippet such that <code>bar()</code> executes at the point of the <code>yield</code> inside of <code>*foo()</code>?</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// construct an iterator `it` to control the generator</span>
<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

<span class="pl-c">// start `foo()` here!</span>
it.<span class="pl-c1">next</span>();
x;                      <span class="pl-c">// 2</span>
bar();
x;                      <span class="pl-c">// 3</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// x: 3</span></pre></div>

<p>OK, there's quite a bit of new and potentially confusing stuff in those two code snippets, so we've got plenty to wade through. But before we explain the different mechanics/syntax with ES6 generators, let's walk through the behavior flow:</p>

<ol>
<li>The <code>it = foo()</code> operation does <em>not</em> execute the <code>*foo()</code> generator yet, but it merely constructs an <em>iterator</em> that will control its execution. More on <em>iterators</em> in a bit.</li>
<li>The first <code>it.next()</code> starts the <code>*foo()</code> generator, and runs the <code>x++</code> on the first line of <code>*foo()</code>.</li>
<li><code>*foo()</code> pauses at the <code>yield</code> statement, at which point that first <code>it.next()</code> call finishes. At the moment, <code>*foo()</code> is still running and active, but it's in a paused state.</li>
<li>We inspect the value of <code>x</code>, and it's now <code>2</code>.</li>
<li>We call <code>bar()</code>, which increments <code>x</code> again with <code>x++</code>.</li>
<li>We inspect the value of <code>x</code> again, and it's now <code>3</code>.</li>
<li>The final <code>it.next()</code> call resumes the <code>*foo()</code> generator from where it was paused, and runs the <code>console.log(..)</code> statement, which uses the current value of <code>x</code> of <code>3</code>.</li>
</ol>

<p>Clearly, <code>foo()</code> started, but did <em>not</em> run-to-completion -- it paused at the <code>yield</code>. We resumed <code>foo()</code> later, and let it finish, but that wasn't even required.</p>

<p>So, a generator is a special kind of function that can start and stop one or more times, and doesn't necessarily ever have to finish. While it won't be terribly obvious yet why that's so powerful, as we go throughout the rest of this chapter, that will be one of the fundamental building blocks we use to construct generators-as-async-flow-control as a pattern for our code.</p>

<h3><a id="user-content-input-and-output" class="anchor" href="#input-and-output" aria-hidden="true"><span class="octicon octicon-link"></span></a>Input and Output</h3>

<p>A generator function is a special function with the new processing model we just alluded to. But it's still a function, which means it still has some basic tenets that haven't changed -- namely, that it still accepts arguments (aka "input"), and that it can still return a value (aka "output"):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">*</span> y;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-c1">6</span>, <span class="pl-c1">7</span> );

<span class="pl-k">var</span> res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>();

res.<span class="pl-c1">value</span>;      <span class="pl-c">// 42</span></pre></div>

<p>We pass in the arguments <code>6</code> and <code>7</code> to <code>*foo(..)</code> as the parameters <code>x</code> and <code>y</code>, respectively. And <code>*foo(..)</code> returns the value <code>42</code> back to the calling code.</p>

<p>We now see a difference with how the generator is invoked compared to a normal function. <code>foo(6,7)</code> obviously looks familiar. But subtly, the <code>*foo(..)</code> generator hasn't actually run yet as it would have with a function.</p>

<p>Instead, we're just creating an <em>iterator</em> object, which we assign to the variable <code>it</code>, to control the <code>*foo(..)</code> generator. Then we call <code>it.next()</code>, which instructs the <code>*foo(..)</code> generator to advance from its current location, stopping either at the next <code>yield</code> or end of the generator.</p>

<p>The result of that <code>next(..)</code> call is an object with a <code>value</code> property on it holding whatever value (if anything) was returned from <code>*foo(..)</code>. In other words, <code>yield</code> caused a value to be sent out from the generator during the middle of its execution, kind of like an intermediate <code>return</code>.</p>

<p>Again, it won't be obvious yet why we need this whole indirect <em>iterator</em> object to control the generator. We'll get there, I <em>promise</em>.</p>

<h4><a id="user-content-iteration-messaging" class="anchor" href="#iteration-messaging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iteration Messaging</h4>

<p>In addition to generators accepting arguments and having return values, there's even more powerful and compelling input/output messaging capability built into them, via <code>yield</code> and <code>next(..)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">var</span> y <span class="pl-k">=</span> x <span class="pl-k">*</span> (<span class="pl-k">yield</span>);
    <span class="pl-k">return</span> y;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-c1">6</span> );

<span class="pl-c">// start `foo(..)`</span>
it.<span class="pl-c1">next</span>();

<span class="pl-k">var</span> res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( <span class="pl-c1">7</span> );

res.<span class="pl-c1">value</span>;      <span class="pl-c">// 42</span></pre></div>

<p>First, we pass in <code>6</code> as the parameter <code>x</code>. Then we call <code>it.next()</code>, and it starts up <code>*foo(..)</code>.</p>

<p>Inside <code>*foo(..)</code>, the <code>var y = x ..</code> statement starts to be processed, but then it runs across a <code>yield</code> expression. At that point, it pauses <code>*foo(..)</code> (in the middle of the assignment statement!), and essentially requests the calling code to provide a result value for the <code>yield</code> expression. Next, we call <code>it.next( 7 )</code>, which is passing the <code>7</code> value back in to <em>be</em> that result of the paused <code>yield</code> expression.</p>

<p>So, at this point, the assignment statement is essentially <code>var y = 6 * 7</code>. Now, <code>return y</code> returns that <code>42</code> value back as the result of the <code>it.next( 7 )</code> call.</p>

<p>Notice something very important but also easily confusing, even to seasoned JS developers: depending on your perspective, there's a mismatch between the <code>yield</code> and the <code>next(..)</code> call. In general, you're going to have one more <code>next(..)</code> call than you have <code>yield</code> statements -- the preceding snippet has one <code>yield</code> and two <code>next(..)</code> calls.</p>

<p>Why the mismatch?</p>

<p>Because the first <code>next(..)</code> always starts a generator, and runs to the first <code>yield</code>. But it's the second <code>next(..)</code> call that fulfills the first paused <code>yield</code> expression, and the third <code>next(..)</code> would fulfill the second <code>yield</code>, and so on.</p>

<h5><a id="user-content-tale-of-two-questions" class="anchor" href="#tale-of-two-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tale of Two Questions</h5>

<p>Actually, which code you're thinking about primarily will affect whether there's a perceived mismatch or not.</p>

<p>Consider only the generator code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> y <span class="pl-k">=</span> x <span class="pl-k">*</span> (<span class="pl-k">yield</span>);
<span class="pl-k">return</span> y;</pre></div>

<p>This <strong>first</strong> <code>yield</code> is basically <em>asking a question</em>: "What value should I insert here?"</p>

<p>Who's going to answer that question? Well, the <strong>first</strong> <code>next()</code> has already run to get the generator up to this point, so obviously <em>it</em> can't answer the question. So, the <strong>second</strong> <code>next(..)</code> call must answer the question <em>posed</em> by the <strong>first</strong> <code>yield</code>.</p>

<p>See the mismatch -- second-to-first?</p>

<p>But let's flip our perspective. Let's look at it not from the generator's point of view, but from the iterator's point of view.</p>

<p>To properly illustrate this perspective, we also need to explain that messages can go in both directions -- <code>yield ..</code> as an expression can send out messages in response to <code>next(..)</code> calls, and <code>next(..)</code> can send values to a paused <code>yield</code> expression. Consider this slightly adjusted code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">var</span> y <span class="pl-k">=</span> x <span class="pl-k">*</span> (<span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>);    <span class="pl-c">// &lt;-- yield a value!</span>
    <span class="pl-k">return</span> y;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-c1">6</span> );

<span class="pl-k">var</span> res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>();    <span class="pl-c">// first `next()`, don't pass anything</span>
res.<span class="pl-c1">value</span>;              <span class="pl-c">// "Hello"</span>

res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( <span class="pl-c1">7</span> );     <span class="pl-c">// pass `7` to waiting `yield`</span>
res.<span class="pl-c1">value</span>;              <span class="pl-c">// 42</span></pre></div>

<p><code>yield ..</code> and <code>next(..)</code> pair together as a two-way message passing system <strong>during the execution of the generator</strong>.</p>

<p>So, looking only at the <em>iterator</em> code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>();    <span class="pl-c">// first `next()`, don't pass anything</span>
res.<span class="pl-c1">value</span>;              <span class="pl-c">// "Hello"</span>

res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( <span class="pl-c1">7</span> );     <span class="pl-c">// pass `7` to waiting `yield`</span>
res.<span class="pl-c1">value</span>;              <span class="pl-c">// 42</span></pre></div>

<p><strong>Note:</strong> We don't pass a value to the first <code>next()</code> call, and that's on purpose. Only a paused <code>yield</code> could accept such a value passed by a <code>next(..)</code>, and at the beginning of the generator when we call the first <code>next()</code>, there <strong>is no paused <code>yield</code></strong> to accept such a value. The specification and all compliant browsers just silently <strong>discard</strong> anything passed to the first <code>next()</code>. It's still a bad idea to pass a value, as you're just creating silently "failing" code that's confusing. So, always start a generator with an argument-free <code>next()</code>.</p>

<p>The first <code>next()</code> call (with nothing passed to it) is basically <em>asking a question</em>: "What <em>next</em> value does the <code>*foo(..)</code> generator have to give me?" And who answers this question? The first <code>yield "hello"</code> expression.</p>

<p>See? No mismatch there.</p>

<p>Depending on <em>who</em> you think about asking the question, there is either a mismatch between the <code>yield</code> and <code>next(..)</code> calls, or not.</p>

<p>But wait! There's still an extra <code>next()</code> compared to the number of <code>yield</code> statements. So, that final <code>it.next(7)</code> call is again asking the question about what <em>next</em> value the generator will produce. But there's no more <code>yield</code> statements left to answer, is there? So who answers?</p>

<p>The <code>return</code> statement answers the question!</p>

<p>And if there <strong>is no <code>return</code></strong> in your generator -- <code>return</code> is certainly not any more required in generators than in regular functions -- there's always an assumed/implicit <code>return;</code> (aka <code>return undefined;</code>), which serves the purpose of default answering the question <em>posed</em> by the final <code>it.next(7)</code> call.</p>

<p>These questions and answers -- the two-way message passing with <code>yield</code> and <code>next(..)</code> -- are quite powerful, but it's not obvious at all how these mechanisms are connected to async flow control. We're getting there!</p>

<h3><a id="user-content-multiple-iterators" class="anchor" href="#multiple-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Iterators</h3>

<p>It may appear from the syntactic usage that when you use an <em>iterator</em> to control a generator, you're controlling the declared generator function itself. But there's a subtlety that easy to miss: each time you construct an <em>iterator</em>, you are implicitly constructing an instance of the generator which that <em>iterator</em> will control.</p>

<p>You can have multiple instances of the same generator running at the same time, and they can even interact:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    z<span class="pl-k">++</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-k">yield</span> (x <span class="pl-k">*</span> z);
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

<span class="pl-k">var</span> z <span class="pl-k">=</span> <span class="pl-c1">1</span>;

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> it2 <span class="pl-k">=</span> foo();

<span class="pl-k">var</span> val1 <span class="pl-k">=</span> it1.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;            <span class="pl-c">// 2 &lt;-- yield 2</span>
<span class="pl-k">var</span> val2 <span class="pl-k">=</span> it2.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;            <span class="pl-c">// 2 &lt;-- yield 2</span>

val1 <span class="pl-k">=</span> it1.<span class="pl-c1">next</span>( val2 <span class="pl-k">*</span> <span class="pl-c1">10</span> ).<span class="pl-c1">value</span>;     <span class="pl-c">// 40  &lt;-- x:20,  z:2</span>
val2 <span class="pl-k">=</span> it2.<span class="pl-c1">next</span>( val1 <span class="pl-k">*</span> <span class="pl-c1">5</span> ).<span class="pl-c1">value</span>;      <span class="pl-c">// 600 &lt;-- x:200, z:3</span>

it1.<span class="pl-c1">next</span>( val2 <span class="pl-k">/</span> <span class="pl-c1">2</span> );                   <span class="pl-c">// y:300</span>
                                        <span class="pl-c">// 20 300 3</span>
it2.<span class="pl-c1">next</span>( val1 <span class="pl-k">/</span> <span class="pl-c1">4</span> );                   <span class="pl-c">// y:10</span>
                                        <span class="pl-c">// 200 10 3</span></pre></div>

<p><strong>Warning:</strong> The most common usage of multiple instances of the same generator running concurrently is not such interactions, but when the generator is producing its own values without input, perhaps from some independently connected resource. We'll talk more about value production in the next section.</p>

<p>Let's briefly walk through the processing:</p>

<ol>
<li>Both instances of <code>*foo()</code> are started at the same time, and both <code>next()</code> calls reveal a <code>value</code> of <code>2</code> from the <code>yield 2</code> statements, respectively.</li>
<li><code>val2 * 10</code> is <code>2 * 10</code>, which is sent into the first generator instance <code>it1</code>, so that <code>x</code> gets value <code>20</code>. <code>z</code> is incremented from <code>1</code> to <code>2</code>, and then <code>20 * 2</code> is <code>yield</code>ed out, setting <code>val1</code> to <code>40</code>.</li>
<li><code>val1 * 5</code> is <code>40 * 5</code>, which is sent into the second generator instance <code>it2</code>, so that <code>x</code> gets value <code>200</code>. <code>z</code> is incremented again, from <code>2</code> to <code>3</code>, and then <code>200 * 3</code> is <code>yield</code>ed out, setting <code>val2</code> to <code>600</code>.</li>
<li><code>val2 / 2</code> is <code>600 / 2</code>, which is sent into the first generator instance <code>it1</code>, so that <code>y</code> gets value <code>300</code>, then printing out <code>20 300 3</code> for its <code>x y z</code> values, respectively.</li>
<li><code>val1 / 4</code> is <code>40 / 4</code>, which is sent into the second generator instance <code>it2</code>, so that <code>y</code> gets value <code>10</code>, then printing out <code>200 10 3</code> for its <code>x y z</code> values, respectively.</li>
</ol>

<p>That's a "fun" example to run through in your mind. Did you keep it straight?</p>

<h4><a id="user-content-interleaving" class="anchor" href="#interleaving" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interleaving</h4>

<p>Recall this scenario from the "Run-to-completion" section of Chapter 1:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    a<span class="pl-k">++</span>;
    b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
    a <span class="pl-k">=</span> b <span class="pl-k">+</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    b<span class="pl-k">--</span>;
    a <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> b;
    b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}</pre></div>

<p>With normal JS functions, of course either <code>foo()</code> can run completely first, or <code>bar()</code> can run completely first, but <code>foo()</code> cannot interleave its individual statements with <code>bar()</code>. So, there are only two possible outcomes to the preceding program.</p>

<p>However, with generators, clearly interleaving (even in the middle of statements!) is possible:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    a<span class="pl-k">++</span>;
    <span class="pl-k">yield</span>;
    b <span class="pl-k">=</span> b <span class="pl-k">*</span> a;
    a <span class="pl-k">=</span> (<span class="pl-k">yield</span> b) <span class="pl-k">+</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    b<span class="pl-k">--</span>;
    <span class="pl-k">yield</span>;
    a <span class="pl-k">=</span> (<span class="pl-k">yield</span> <span class="pl-c1">8</span>) <span class="pl-k">+</span> b;
    b <span class="pl-k">=</span> a <span class="pl-k">*</span> (<span class="pl-k">yield</span> <span class="pl-c1">2</span>);
}</pre></div>

<p>Depending on what respective order the <em>iterators</em> controlling <code>*foo()</code> and <code>*bar()</code> are called, the preceding program could produce several different results. In other words, we can actually illustrate (in a sort of fake-ish way) the theoretical "threaded race conditions" circumstances discussed in Chapter 1, by interleaving the two generator interations over the same shared variables.</p>

<p>First, let's make a helper called <code>step(..)</code> that controls an <em>iterator</em>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">step</span>(<span class="pl-smi">gen</span>) {
    <span class="pl-k">var</span> it <span class="pl-k">=</span> gen();
    <span class="pl-k">var</span> last;

    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// whatever is `yield`ed out, just</span>
        <span class="pl-c">// send it right back in the next time!</span>
        last <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( last ).<span class="pl-c1">value</span>;
    };
}</pre></div>

<p><code>step(..)</code> initializes a generator to create its <code>it</code> <em>iterator</em>, then returns a function which, when called, advances the <em>iterator</em> by one step. Additionally, the previously <code>yield</code>ed out value is sent right back in at the <em>next</em> step. So, <code>yield 8</code> will just become <code>8</code> and <code>yield b</code> will just be <code>b</code> (whatever it was at the time of <code>yield</code>).</p>

<p>Now, just for fun, let's experiment to see the effects of interleaving these different chunks of <code>*foo()</code> and <code>*bar()</code>. We'll start with the boring base case, making sure <code>*foo()</code> totally finishes before <code>*bar()</code> (just like we did in Chapter 1):</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// make sure to reset `a` and `b`</span>
a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">var</span> s1 <span class="pl-k">=</span> step( foo );
<span class="pl-k">var</span> s2 <span class="pl-k">=</span> step( bar );

<span class="pl-c">// run `*foo()` completely first</span>
s1();
s1();
s1();

<span class="pl-c">// now run `*bar()`</span>
s2();
s2();
s2();
s2();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b );    <span class="pl-c">// 11 22</span></pre></div>

<p>The end result is <code>11</code> and <code>22</code>, just as it was in the Chapter 1 version. Now let's mix up the interleaving ordering and see how it changes the final values of <code>a</code> and <code>b</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// make sure to reset `a` and `b`</span>
a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
b <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">var</span> s1 <span class="pl-k">=</span> step( foo );
<span class="pl-k">var</span> s2 <span class="pl-k">=</span> step( bar );

s2();       <span class="pl-c">// b--;</span>
s2();       <span class="pl-c">// yield 8</span>
s1();       <span class="pl-c">// a++;</span>
s2();       <span class="pl-c">// a = 8 + b;</span>
            <span class="pl-c">// yield 2</span>
s1();       <span class="pl-c">// b = b * a;</span>
            <span class="pl-c">// yield b</span>
s1();       <span class="pl-c">// a = b + 3;</span>
s2();       <span class="pl-c">// b = a * 2;</span></pre></div>

<p>Before I tell you the results, can you figure out what <code>a</code> and <code>b</code> are after the preceding program? No cheating!</p>

<div class="highlight highlight-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b );    <span class="pl-c">// 12 18</span></pre></div>

<p><strong>Note:</strong> As an exercise for the reader, try to see how many other combinations of results you can get back rearranging the order of the <code>s1()</code> and <code>s2()</code> calls. Don't forget you'll always need three <code>s1()</code> calls and four <code>s2()</code> calls. Recall the discussion earlier about matching <code>next()</code> with <code>yield</code> for the reasons why.</p>

<p>You almost certainly won't want to intentionally create <em>this</em> level of interleaving confusion, as it creates incredibly difficult to understand code. But the exercise is interesting and instructive to understand more about how multiple generators can run concurrently in the same shared scope, because there will be places where this capability is quite useful.</p>

<p>We'll discuss generator concurrency in more detail at the end of this chapter.</p>

<h2><a id="user-content-generatoring-values" class="anchor" href="#generatoring-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator'ing Values</h2>

<p>In the previous section, we mentioned an interesting use for generators, as a way to produce values. This is <strong>not</strong> the main focus in this chapter, but we'd be remiss if we didn't cover the basics, especially because this use case is essentially the origin of the name: generators.</p>

<p>We're going to take a slight diversion into the topic of <em>iterators</em> for a bit, but we'll circle back to how they relate to generators and using a generator to <em>generate</em> values.</p>

<h3><a id="user-content-producers-and-iterators" class="anchor" href="#producers-and-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producers and Iterators</h3>

<p>Imagine you're producing a series of values where each value has a definable relationship to the previous value. To do this, you're going to need a stateful producer that remembers the last value it gave out.</p>

<p>You can implement something like that straightforwardly using a function closure (see the <em>Scope &amp; Closures</em> title of this series):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> gimmeSomething <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">var</span> nextVal;

    <span class="pl-k">return</span> <span class="pl-k">function</span>(){
        <span class="pl-k">if</span> (nextVal <span class="pl-k">===</span> <span class="pl-c1">undefined</span>) {
            nextVal <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">else</span> {
            nextVal <span class="pl-k">=</span> (<span class="pl-c1">3</span> <span class="pl-k">*</span> nextVal) <span class="pl-k">+</span> <span class="pl-c1">6</span>;
        }

        <span class="pl-k">return</span> nextVal;
    };
})();

gimmeSomething();       <span class="pl-c">// 1</span>
gimmeSomething();       <span class="pl-c">// 9</span>
gimmeSomething();       <span class="pl-c">// 33</span>
gimmeSomething();       <span class="pl-c">// 105</span></pre></div>

<p><strong>Note:</strong> The <code>nextVal</code> computation logic here could have been simplified, but conceptually, we don't want to calculate the <em>next value</em> (aka <code>nextVal</code>) until the <em>next</em> <code>gimmeSomething()</code> call happens, because in general that could be a resource-leaky design for producers of more persistent or resource-limited values than simple <code>number</code>s.</p>

<p>Generating an arbitrary number series isn't a terribly realistic example. But what if you were generating records from a data source? You could imagine much the same code.</p>

<p>In fact, this task is a very common design pattern, usually solved by iterators. An <em>iterator</em> is a well-defined interface for stepping through a series of values from a producer. The JS interface for iterators, as it is in most languages, is to call <code>next()</code> each time you want the next value from the producer.</p>

<p>We could implement the standard <em>iterator</em> interface for our number series producer:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> something <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">var</span> nextVal;

    <span class="pl-k">return</span> {
        <span class="pl-c">// needed for `for..of` loops</span>
        [Symbol.iterator]<span class="pl-k">:</span> <span class="pl-k">function</span>(){ <span class="pl-k">return</span> <span class="pl-v">this</span>; },

        <span class="pl-c">// standard iterator interface method</span>
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
            <span class="pl-k">if</span> (nextVal <span class="pl-k">===</span> <span class="pl-c1">undefined</span>) {
                nextVal <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            }
            <span class="pl-k">else</span> {
                nextVal <span class="pl-k">=</span> (<span class="pl-c1">3</span> <span class="pl-k">*</span> nextVal) <span class="pl-k">+</span> <span class="pl-c1">6</span>;
            }

            <span class="pl-k">return</span> { done<span class="pl-k">:</span><span class="pl-c1">false</span>, value<span class="pl-k">:</span>nextVal };
        }
    };
})();

something.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;     <span class="pl-c">// 1</span>
something.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;     <span class="pl-c">// 9</span>
something.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;     <span class="pl-c">// 33</span>
something.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;     <span class="pl-c">// 105</span></pre></div>

<p><strong>Note:</strong> We'll explain why we need the <code>[Symbol.iterator]: ..</code> part of this code snippet in the "Iterables" section. Syntactically though, two ES6 features are at play. First, the <code>[ .. ]</code> syntax is called a <em>computed property name</em> (see the <em>this &amp; Object Prototypes</em> title of this series). It's a way in an object literal definition to specify an expression and use the result of that expression as the name for the property. Next, <code>Symbol.iterator</code> is one of ES6's predefined special <code>Symbol</code> values (see the <em>ES6 &amp; Beyond</em> title of this book series).</p>

<p>The <code>next()</code> call returns an object with two properties: <code>done</code> is a <code>boolean</code> value signaling the <em>iterator's</em> complete status; <code>value</code> holds the iteration value.</p>

<p>ES6 also adds the <code>for..of</code> loop, which means that a standard <em>iterator</em> can automatically be consumed with native loop syntax:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> something) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );

    <span class="pl-c">// don't let the loop run forever!</span>
    <span class="pl-k">if</span> (v <span class="pl-k">&gt;</span> <span class="pl-c1">500</span>) {
        <span class="pl-k">break</span>;
    }
}
<span class="pl-c">// 1 9 33 105 321 969</span></pre></div>

<p><strong>Note:</strong> Because our <code>something</code> <em>iterator</em> always returns <code>done:false</code>, this <code>for..of</code> loop would run forever, which is why we put the <code>break</code> conditional in. It's totally OK for iterators to be never-ending, but there are also cases where the <em>iterator</em> will run over a finite set of values and eventually return a <code>done:true</code>.</p>

<p>The <code>for..of</code> loop automatically calls <code>next()</code> for each iteration -- it doesn't pass any values in to the <code>next()</code> -- and it will automatically terminate on receiving a <code>done:true</code>. It's quite handy for looping over a set of data.</p>

<p>Of course, you could manually loop over iterators, calling <code>next()</code> and checking for the <code>done:true</code> condition to know when to stop:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (
    <span class="pl-k">var</span> ret;
    (ret <span class="pl-k">=</span> something.<span class="pl-c1">next</span>()) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>ret.done;
) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( ret.<span class="pl-c1">value</span> );

    <span class="pl-c">// don't let the loop run forever!</span>
    <span class="pl-k">if</span> (ret.<span class="pl-c1">value</span> <span class="pl-k">&gt;</span> <span class="pl-c1">500</span>) {
        <span class="pl-k">break</span>;
    }
}
<span class="pl-c">// 1 9 33 105 321 969</span></pre></div>

<p><strong>Note:</strong> This manual <code>for</code> approach is certainly uglier than the ES6 <code>for..of</code> loop syntax, but its advantage is that it affords you the opportunity to pass in values to the <code>next(..)</code> calls if necessary.</p>

<p>In addition to making your own <em>iterators</em>, many built-in data structures in JS (as of ES6), like <code>array</code>s, also have default <em>iterators</em>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>,<span class="pl-c1">9</span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> a) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 3 5 7 9</span></pre></div>

<p>The <code>for..of</code> loop asks <code>a</code> for its <em>iterator</em>, and automatically uses it to iterate over <code>a</code>'s values.</p>

<p><strong>Note:</strong> It may seem a strange omission by ES6, but regular <code>object</code>s intentionally do not come with a default <em>iterator</em> the way <code>array</code>s do. The reasons go deeper than we will cover here. If all you want is to iterate over the properties of an object (with no particular guarantee of ordering), <code>Object.keys(..)</code> returns an <code>array</code>, which can then be used like <code>for (var k of Object.keys(obj)) { ..</code>. Such a <code>for..of</code> loop over an object's keys would be similar to a <code>for..in</code> loop, except that <code>Object.keys(..)</code> does not include properties from the <code>[[Prototype]]</code> chain while <code>for..in</code> does (see the <em>this &amp; Object Prototypes</em> title of this series).</p>

<h3><a id="user-content-iterables" class="anchor" href="#iterables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterables</h3>

<p>The <code>something</code> object in our running example is called an <em>iterator</em>, as it has the <code>next()</code> method on its interface. But a closely related term is <em>iterable</em>, which is an <code>object</code> that <strong>contains</strong> an <em>iterator</em> that can iterate over its values.</p>

<p>As of ES6, the way to retrieve an <em>iterator</em> from an <em>iterable</em> is that the <em>iterable</em> must have a function on it, with the name being the special ES6 symbol value <code>Symbol.iterator</code>. When this function is called, it returns an <em>iterator</em>. Though not required, generally each call should return a fresh new <em>iterator</em>.</p>

<p><code>a</code> in the previous snippet is an <em>iterable</em>. The <code>for..of</code> loop automatically calls its <code>Symbol.iterator</code> function to construct an <em>iterator</em>. But we could of course call the function manually, and use the <em>iterator</em> it returns:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">3</span>,<span class="pl-c1">5</span>,<span class="pl-c1">7</span>,<span class="pl-c1">9</span>];

<span class="pl-k">var</span> it <span class="pl-k">=</span> a[Symbol.iterator]();

it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 1</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 3</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 5</span>
..</pre></div>

<p>In the previous code listing that defined <code>something</code>, you may have noticed this line:</p>

<div class="highlight highlight-js"><pre>[Symbol.iterator]<span class="pl-k">:</span> <span class="pl-k">function</span>(){ <span class="pl-k">return</span> <span class="pl-v">this</span>; }</pre></div>

<p>That little bit of confusing code is making the <code>something</code> value -- the interface of the <code>something</code> <em>iterator</em> -- also an <em>iterable</em>; it's now both an <em>iterable</em> and an <em>iterator</em>. Then, we pass <code>something</code> to the <code>for..of</code> loop:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> something) {
    ..
}</pre></div>

<p>The <code>for..of</code> loop expects <code>something</code> to be an <em>iterable</em>, so it looks for and calls its <code>Symbol.iterator</code> function. We defined that function to simply <code>return this</code>, so it just gives itself back, and the <code>for..of</code> loop is none the wiser.</p>

<h3><a id="user-content-generator-iterator" class="anchor" href="#generator-iterator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Iterator</h3>

<p>Let's turn our attention back to generators, in the context of <em>iterators</em>. A generator can be treated as a producer of values that we extract one at a time through an <em>iterator</em> interface's <code>next()</code> calls.</p>

<p>So, a generator itself is not technically an <em>iterable</em>, though it's very similar -- when you execute the generator, you get an <em>iterator</em> back:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(){ .. }

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();</pre></div>

<p>We can implement the <code>something</code> infinite number series producer from earlier with a generator, like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*something</span>() {
    <span class="pl-k">var</span> nextVal;

    <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
        <span class="pl-k">if</span> (nextVal <span class="pl-k">===</span> <span class="pl-c1">undefined</span>) {
            nextVal <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">else</span> {
            nextVal <span class="pl-k">=</span> (<span class="pl-c1">3</span> <span class="pl-k">*</span> nextVal) <span class="pl-k">+</span> <span class="pl-c1">6</span>;
        }

        <span class="pl-k">yield</span> nextVal;
    }
}</pre></div>

<p><strong>Note:</strong> A <code>while..true</code> loop would normally be a very bad thing to include in a real JS program, at least if it doesn't have a <code>break</code> or <code>return</code> in it, as it would likely run forever, synchronously, and block/lock-up the browser UI. However, in a generator, such a loop is generally totally OK if it has a <code>yield</code> in it, as the generator will pause at each iteration, <code>yield</code>ing back to the main program and/or to the event loop queue. To put it glibly, "generators put the <code>while..true</code> back in JS programming!"</p>

<p>That's a fair bit cleaner and simpler, right? Because the generator pauses at each <code>yield</code>, the state (scope) of the function <code>*something()</code> is kept around, meaning there's no need for the closure boilerplate to preserve variable state across calls.</p>

<p>Not only is it simpler code -- we don't have to make our own <em>iterator</em> interface -- it actually is more reason-able code, because it more clearly expresses the intent. For example, the <code>while..true</code> loop tells us the generator is intended to run forever -- to keep <em>generating</em> values as long as we keep asking for them.</p>

<p>And now we can use our shiny new <code>*something()</code> generator with a <code>for..of</code> loop, and you'll see it works basically identically:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> something()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );

    <span class="pl-c">// don't let the loop run forever!</span>
    <span class="pl-k">if</span> (v <span class="pl-k">&gt;</span> <span class="pl-c1">500</span>) {
        <span class="pl-k">break</span>;
    }
}
<span class="pl-c">// 1 9 33 105 321 969</span></pre></div>

<p>But don't skip over <code>for (var v of something()) ..</code>! We didn't just reference <code>something</code> as a value like in earlier examples, but instead called the <code>*something()</code> generator to get its <em>iterator</em> for the <code>for..of</code> loop to use.</p>

<p>If you're paying close attention, two questions may arise from this interaction between the generator and the loop:</p>

<ul>
<li>Why couldn't we say <code>for (var v of something) ..</code>? Because <code>something</code> here is a generator, which is not an <em>iterable</em>. We have to call <code>something()</code> to construct a producer for the <code>for..of</code> loop to iterate over.</li>
<li>The <code>something()</code> call produces an <em>iterator</em>, but the <code>for..of</code> loop wants an <em>iterable</em>, right? Yep. The generator's <em>iterator</em> also has a <code>Symbol.iterator</code> function on it, which basically does a <code>return this</code>, just like the <code>something</code> <em>iterable</em> we defined earlier. In other words, a generator's <em>iterator</em> is also an <em>iterable</em>!</li>
</ul>

<h4><a id="user-content-stopping-the-generator" class="anchor" href="#stopping-the-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stopping the Generator</h4>

<p>In the previous example, it would appear the <em>iterator</em> instance for the <code>*something()</code> generator was basically left in a suspended state forever after the <code>break</code> in the loop was called.</p>

<p>But there's a hidden behavior that takes care of that for you. "Abnormal completion" (i.e., "early termination") of the <code>for..of</code> loop -- generally caused by a <code>break</code>, <code>return</code>, or an uncaught exception -- sends a signal to the generator's <em>iterator</em> for it to terminate.</p>

<p><strong>Note:</strong> Technically, the <code>for..of</code> loop also sends this signal to the <em>iterator</em> at the normal completion of the loop. For a generator, that's essentially a moot operation, as the generator's <em>iterator</em> had to complete first so the <code>for..of</code> loop completed. However, custom <em>iterators</em> might desire to receive this additional signal from <code>for..of</code> loop consumers.</p>

<p>While a <code>for..of</code> loop will automatically send this signal, you may wish to send the signal manually to an <em>iterator</em>; you do this by calling <code>return(..)</code>.</p>

<p>If you specify a <code>try..finally</code> clause inside the generator, it will always be run even when the generator is externally completed. This is useful if you need to clean up resources (database connections, etc.):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*something</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">var</span> nextVal;

        <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
            <span class="pl-k">if</span> (nextVal <span class="pl-k">===</span> <span class="pl-c1">undefined</span>) {
                nextVal <span class="pl-k">=</span> <span class="pl-c1">1</span>;
            }
            <span class="pl-k">else</span> {
                nextVal <span class="pl-k">=</span> (<span class="pl-c1">3</span> <span class="pl-k">*</span> nextVal) <span class="pl-k">+</span> <span class="pl-c1">6</span>;
            }

            <span class="pl-k">yield</span> nextVal;
        }
    }
    <span class="pl-c">// cleanup clause</span>
    <span class="pl-k">finally</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cleaning up!<span class="pl-pds">"</span></span> );
    }
}</pre></div>

<p>The earlier example with <code>break</code> in the <code>for..of</code> loop will trigger the <code>finally</code> clause. But you could instead manually terminate the generator's <em>iterator</em> instance from the outside with <code>return(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> something();
<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> it) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );

    <span class="pl-c">// don't let the loop run forever!</span>
    <span class="pl-k">if</span> (v <span class="pl-k">&gt;</span> <span class="pl-c1">500</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>(
            <span class="pl-c">// complete the generator's iterator</span>
            it.return( <span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span> ).<span class="pl-c1">value</span>
        );
        <span class="pl-c">// no `break` needed here</span>
    }
}
<span class="pl-c">// 1 9 33 105 321 969</span>
<span class="pl-c">// cleaning up!</span>
<span class="pl-c">// Hello World</span></pre></div>

<p>When we call <code>it.return(..)</code>, it immediately terminates the generator, which of course runs the <code>finally</code> clause. Also, it sets the returned <code>value</code> to whatever you passed in to <code>return(..)</code>, which is how <code>"Hello World"</code> comes right back out. We also don't need to include a <code>break</code> now because the generator's <em>iterator</em> is set to <code>done:true</code>, so the <code>for..of</code> loop will terminate on its next iteration.</p>

<p>Generators owe their namesake mostly to this <em>consuming produced values</em> use. But again, that's just one of the uses for generators, and frankly not even the main one we're concerned with in the context of this book.</p>

<p>But now that we more fully understand some of the mechanics of how they work, we can <em>next</em> turn our attention to how generators apply to async concurrency.</p>

<h2><a id="user-content-iterating-generators-asynchronously" class="anchor" href="#iterating-generators-asynchronously" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterating Generators Asynchronously</h2>

<p>What do generators have to do with async coding patterns, fixing problems with callbacks, and the like? Let's get to answering that important question.</p>

<p>We should revisit one of our scenarios from Chapter 3. Let's recall the callback approach:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">cb</span>) {
    ajax(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y,
        cb
    );
}

foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span>, <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">text</span>) {
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    }
} );</pre></div>

<p>If we wanted to express this same task flow control with a generator, we could do:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    ajax(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y,
        <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">data</span>){
            <span class="pl-k">if</span> (err) {
                <span class="pl-c">// throw an error into `*main()`</span>
                it.throw( err );
            }
            <span class="pl-k">else</span> {
                <span class="pl-c">// resume `*main()` with received `data`</span>
                it.<span class="pl-c1">next</span>( data );
            }
        }
    );
}

<span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">var</span> text <span class="pl-k">=</span> <span class="pl-k">yield</span> foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> main();

<span class="pl-c">// start it all up!</span>
it.<span class="pl-c1">next</span>();</pre></div>

<p>At first glance, this snippet is longer, and perhaps a little more complex looking, than the callback snippet before it. But don't let that impression get you off track. The generator snippet is actually <strong>much</strong> better! But there's a lot going on for us to explain.</p>

<p>First, let's look at this part of the code, which is the most important:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> text <span class="pl-k">=</span> <span class="pl-k">yield</span> foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );</pre></div>

<p>Think about how that code works for a moment. We're calling a normal function <code>foo(..)</code> and we're apparently able to get back the <code>text</code> from the Ajax call, even though it's asynchronous.</p>

<p>How is that possible? If you recall the beginning of Chapter 1, we had almost identical code:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> data <span class="pl-k">=</span> ajax( <span class="pl-s"><span class="pl-pds">"</span>..url 1..<span class="pl-pds">"</span></span> );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( data );</pre></div>

<p>And that code didn't work! Can you spot the difference? It's the <code>yield</code> used in a generator.</p>

<p>That's the magic! That's what allows us to have what appears to be blocking, synchronous code, but it doesn't actually block the whole program; it only pauses/blocks the code in the generator itself.</p>

<p>In <code>yield foo(11,31)</code>, first the <code>foo(11,31)</code> call is made, which returns nothing (aka <code>undefined</code>), so we're making a call to request data, but we're actually then doing <code>yield undefined</code>. That's OK, because the code is not currently relying on a <code>yield</code>ed value to do anything interesting. We'll revisit this point later in the chapter.</p>

<p>We're not using <code>yield</code> in a message passing sense here, only in a flow control sense to pause/block. Actually, it will have message passing, but only in one direction, after the generator is resumed.</p>

<p>So, the generator pauses at the <code>yield</code>, essentially asking the question, "what value should I return to assign to the variable <code>text</code>?" Who's going to answer that question?</p>

<p>Look at <code>foo(..)</code>. If the Ajax request is successful, we call:</p>

<div class="highlight highlight-js"><pre>it.<span class="pl-c1">next</span>( data );</pre></div>

<p>That's resuming the generator with the response data, which means that our paused <code>yield</code> expression receives that value directly, and then as it restarts the generator code, that value gets assigned to the local variable <code>text</code>.</p>

<p>Pretty cool, huh?</p>

<p>Take a step back and consider the implications. We have totally synchronous-looking code inside the generator (other than the <code>yield</code> keyword itself), but hidden behind the scenes, inside of <code>foo(..)</code>, the operations can complete asynchronously.</p>

<p><strong>That's huge!</strong> That's a nearly perfect solution to our previously stated problem with callbacks not being able to express asynchrony in a sequential, synchronous fashion that our brains can relate to.</p>

<p>In essence, we are abstracting the asynchrony away as an implementation detail, so that we can reason synchronously/sequentially about our flow control: "Make an Ajax request, and when it finishes print out the response." And of course, we just expressed two steps in the flow control, but this same capabililty extends without bounds, to let us express however many steps we need to.</p>

<p><strong>Tip:</strong> This is such an important realization, just go back and read the last three paragraphs again to let it sink in!</p>

<h3><a id="user-content-synchronous-error-handling" class="anchor" href="#synchronous-error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Synchronous Error Handling</h3>

<p>But the preceding generator code has even more goodness to <em>yield</em> to us. Let's turn our attention to the <code>try..catch</code> inside the generator:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">try</span> {
    <span class="pl-k">var</span> text <span class="pl-k">=</span> <span class="pl-k">yield</span> foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
}</pre></div>

<p>How does this work? The <code>foo(..)</code> call is asynchronously completing, and doesn't <code>try..catch</code> fail to catch asynchronous errors, as we looked at in Chapter 3?</p>

<p>We already saw how the <code>yield</code> lets the assignment statement pause to wait for <code>foo(..)</code> to finish, so that the completed response can be assigned to <code>text</code>. The awesome part is that this <code>yield</code> pausing <em>also</em> allows the generator to <code>catch</code> an error. We throw that error into the generator with this part of the earlier code listing:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">if</span> (err) {
    <span class="pl-c">// throw an error into `*main()`</span>
    it.throw( err );
}</pre></div>

<p>The <code>yield</code>-pause nature of generators means that not only do we get synchronous-looking <code>return</code> values from async function calls, but we can also synchronously <code>catch</code> errors from those async function calls!</p>

<p>So we've seen we can throw errors <em>into</em> a generator, but what about throwing errors <em>out of</em> a generator? Exactly as you'd expect:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>;

    <span class="pl-k">yield</span> x.<span class="pl-c1">toLowerCase</span>();  <span class="pl-c">// cause an exception!</span>
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> main();

it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;            <span class="pl-c">// Hello World</span>

<span class="pl-k">try</span> {
    it.<span class="pl-c1">next</span>( <span class="pl-c1">42</span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );   <span class="pl-c">// TypeError</span>
}</pre></div>

<p>Of course, we could have manually thrown an error with <code>throw ..</code> instead of causing an exception.</p>

<p>We can even <code>catch</code> the same error that we <code>throw(..)</code> into the generator, essentially giving the generator a chance to handle it but if it doesn't, the <em>iterator</em> code must handle it:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>;

    <span class="pl-c">// never gets here</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> main();

it.<span class="pl-c1">next</span>();

<span class="pl-k">try</span> {
    <span class="pl-c">// will `*main()` handle this error? we'll see!</span>
    it.throw( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c">// nope, didn't handle it!</span>
    <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );           <span class="pl-c">// Oops</span>
}</pre></div>

<p>Synchronous-looking error handling (via <code>try..catch</code>) with async code is a huge win for readability and reason-ability.</p>

<h2><a id="user-content-generators--promises" class="anchor" href="#generators--promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators + Promises</h2>

<p>In our previous discussion, we showed how generators can be iterated asynchronously, which is a huge step forward in sequential reason-ability over the spaghetti mess of callbacks. But we lost something very important: the trustability and composability of Promises (see Chapter 3)!</p>

<p>Don't worry -- we can get that back. The best of all worlds in ES6 is to combine generators (synchronous-looking async code) with Promises (trustable and composable).</p>

<p>But how?</p>

<p>Recall from Chapter 3 the Promise-based approach to our running Ajax example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y
    );
}

foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> )
.then(
    <span class="pl-k">function</span>(<span class="pl-smi">text</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    },
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
);</pre></div>

<p>In our earlier generator code for the running Ajax example, <code>foo(..)</code> returned nothing (<code>undefined</code>), and our <em>iterator</em> control code didn't care about that <code>yield</code>ed value.</p>

<p>But here the Promise-aware <code>foo(..)</code> returns a promise after making the Ajax call. That suggests that we could construct a promise with <code>foo(..)</code> and then <code>yield</code> it from the generator, and then the <em>iterator</em> control code would receive that promise.</p>

<p>But what should the <em>iterator</em> do with the promise?</p>

<p>It should listen for the promise to resolve (fulfillment or rejection), and then either resume the generator with the fulfillment message or throw an error into the generator with the rejection reason.</p>

<p>Let me repeat that, because it's so important. The natural way to get the most out of Promises and generators is <strong>to <code>yield</code> a Promise</strong>, and wire that Promise to control the generator's <em>iterator</em>.</p>

<p>Let's give it a try! First, we'll put the Promise-aware <code>foo(..)</code> together with the generator <code>*main()</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y
    );
}

<span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">var</span> text <span class="pl-k">=</span> <span class="pl-k">yield</span> foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
}</pre></div>

<p>The most powerful revelation in this refactor is that the code inside <code>*main()</code> <strong>did not have to change at all!</strong> Inside the generator, whatever values are <code>yield</code>ed out is just an opaque implementation detail, so we're not even aware it's happening, nor do we need to worry about it.</p>

<p>But how are we going to run <code>*main()</code> now? We still have some of the implementation plumbing work to do, to receive and wire up the <code>yield</code>ed promise so that it resumes the generator upon resolution. We'll start by trying that manually:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> main();

<span class="pl-k">var</span> p <span class="pl-k">=</span> it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;

<span class="pl-c">// wait for the `p` promise to resolve</span>
p.then(
    <span class="pl-k">function</span>(<span class="pl-smi">text</span>){
        it.<span class="pl-c1">next</span>( text );
    },
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        it.throw( err );
    }
);</pre></div>

<p>Actually, that wasn't so painful at all, was it?</p>

<p>This snippet should look very similar to what we did earlier with the manually wired generator controlled by the error-first callback. Instead of an <code>if (err) { it.throw..</code>, the promise already splits fulfillment (success) and rejection (failure) for us, but otherwise the <em>iterator</em> control is identical.</p>

<p>Now, we've glossed over some important details.</p>

<p>Most importantly, we took advantage of the fact that we knew that <code>*main()</code> only had one Promise-aware step in it. What if we wanted to be able to Promise-drive a generator no matter how many steps it has? We certainly don't want to manually write out the Promise chain differently for each generator! What would be much nicer is if there was a way to repeat (aka "loop" over) the iteration control, and each time a Promise comes out, wait on its resolution before continuing.</p>

<p>Also, what if the generator throws out an error (intentionally or accidentally) during the <code>it.next(..)</code> call? Should we quit, or should we <code>catch</code> it and send it right back in? Similarly, what if we <code>it.throw(..)</code> a Promise rejection into the generator, but it's not handled, and comes right back out?</p>

<h3><a id="user-content-promise-aware-generator-runner" class="anchor" href="#promise-aware-generator-runner" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise-Aware Generator Runner</h3>

<p>The more you start to explore this path, the more you realize, "wow, it'd be great if there was just some utility to do it for me." And you're absolutely correct. This is such an important pattern, and you don't want to get it wrong (or exhaust yourself repeating it over and over), so your best bet is to use a utility that is specifically designed to <em>run</em> Promise-<code>yield</code>ing generators in the manner we've illustrated.</p>

<p>Several Promise abstraction libraries provide just such a utility, including my <em>asynquence</em> library and its <code>runner(..)</code>, which will be discussed in Appendix A of this book.</p>

<p>But for the sake of learning and illustration, let's just define our own standalone utility that we'll call <code>run(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// thanks to Benjamin Gruenbaum (@benjamingr on GitHub) for</span>
<span class="pl-c">// big improvements here!</span>
<span class="pl-k">function</span> <span class="pl-en">run</span>(<span class="pl-smi">gen</span>) {
    <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span>), it;

    <span class="pl-c">// initialize the generator in the current context</span>
    it <span class="pl-k">=</span> gen.<span class="pl-c1">apply</span>( <span class="pl-v">this</span>, args );

    <span class="pl-c">// return a promise for the generator completing</span>
    <span class="pl-k">return</span> Promise.resolve()
        .then( <span class="pl-k">function</span> <span class="pl-en">handleNext</span>(<span class="pl-smi">value</span>){
            <span class="pl-c">// run to the next yielded value</span>
            <span class="pl-k">var</span> next <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( value );

            <span class="pl-k">return</span> (<span class="pl-k">function</span> <span class="pl-en">handleResult</span>(<span class="pl-smi">next</span>){
                <span class="pl-c">// generator has completed running?</span>
                <span class="pl-k">if</span> (next.done) {
                    <span class="pl-k">return</span> next.<span class="pl-c1">value</span>;
                }
                <span class="pl-c">// otherwise keep going</span>
                <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> Promise.resolve( next.<span class="pl-c1">value</span> )
                        .then(
                            <span class="pl-c">// resume the async loop on</span>
                            <span class="pl-c">// success, sending the resolved</span>
                            <span class="pl-c">// value back into the generator</span>
                            handleNext,

                            <span class="pl-c">// if `value` is a rejected</span>
                            <span class="pl-c">// promise, propagate error back</span>
                            <span class="pl-c">// into the generator for its own</span>
                            <span class="pl-c">// error handling</span>
                            <span class="pl-k">function</span> <span class="pl-en">handleErr</span>(<span class="pl-smi">err</span>) {
                                <span class="pl-k">return</span> Promise.resolve(
                                    it.throw( err )
                                )
                                .then( handleResult );
                            }
                        );
                }
            })(next);
        } );
}</pre></div>

<p>As you can see, it's a quite a bit more complex than you'd probably want to author yourself, and you especially wouldn't want to repeat this code for each generator you use. So, a utility/library helper is definitely the way to go. Nevertheless, I encourage you to spend a few minutes studying that code listing to get a better sense of how to manage the generator+Promise negotiation.</p>

<p>How would you use <code>run(..)</code> with <code>*main()</code> in our <em>running</em> Ajax example?</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-c">// ..</span>
}

run( main );</pre></div>

<p>That's it! The way we wired <code>run(..)</code>, it will automatically advance the generator you pass to it, asynchronously until completion.</p>

<p><strong>Note:</strong> The <code>run(..)</code> we defined returns a promise which is wired to resolve once the generator is complete, or receive an uncaught exception if the generator doesn't handle it. We don't show that capability here, but we'll come back to it later in the chapter.</p>

<h4><a id="user-content-es7-async-and-await" class="anchor" href="#es7-async-and-await" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES7: <code>async</code> and <code>await</code>?</h4>

<p>The preceding pattern -- generators yielding Promises that then control the generator's <em>iterator</em> to advance it to completion -- is such a powerful and useful approach, it would be nicer if we could do it without the clutter of the library utility helper (aka <code>run(..)</code>).</p>

<p>There's probably good news on that front. At the time of this writing, there's early but strong support for a proposal for more syntactic addition in this realm for the post-ES6, ES7-ish timeframe. Obviously, it's too early to guarantee the details, but there's a pretty decent chance it will shake out similar to the following:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/?x=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> x <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>&amp;y=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> y
    );
}

<span class="pl-k">async</span> <span class="pl-k">function</span> <span class="pl-en">main</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">var</span> text <span class="pl-k">=</span> <span class="pl-k">await</span> foo( <span class="pl-c1">11</span>, <span class="pl-c1">31</span> );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
}

main();</pre></div>

<p>As you can see, there's no <code>run(..)</code> call (meaning no need for a library utility!) to invoke and drive <code>main()</code> -- it's just called as a normal function. Also, <code>main()</code> isn't declared as a generator function anymore; it's a new kind of function: <code>async function</code>. And finally, instead of <code>yield</code>ing a Promise, we <code>await</code> for it to resolve.</p>

<p>The <code>async function</code> automatically knows what to do if you <code>await</code> a Promise -- it will pause the function (just like with generators) until the Promise resolves. We didn't illustrate it in this snippet, but calling an async function like <code>main()</code> automatically returns a promise that's resolved whenever the function finishes completely.</p>

<p><strong>Tip:</strong> The <code>async</code> / <code>await</code> syntax should look very familiar to readers with  experience in C#, because it's basically identical.</p>

<p>The proposal essentially codifies support for the pattern we've already derived, into a syntactic mechanism: combining Promises with sync-looking flow control code. That's the best of both worlds combined, to effectively address practically all of the major concerns we outlined with callbacks.</p>

<p>The mere fact that such a ES7-ish proposal already exists and has early support and enthusiasm is a major vote of confidence in the future importance of this async pattern.</p>

<h3><a id="user-content-promise-concurrency-in-generators" class="anchor" href="#promise-concurrency-in-generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promise Concurrency in Generators</h3>

<p>So far, all we've demonstrated is a single-step async flow with Promises+generators. But real-world code will often have many async steps.</p>

<p>If you're not careful, the sync-looking style of generators may lull you into complacency with how you structure your async concurrency, leading to suboptimal performance patterns. So we want to spend a little time exploring the options.</p>

<p>Imagine a scenario where you need to fetch data from two different sources, then combine those responses to make a third request, and finally print out the last response. We explored a similar scenario with Promises in Chapter 3, but let's reconsider it in the context of generators.</p>

<p>Your first instinct might be something like:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );

    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r1 <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2
    );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

<span class="pl-c">// use previously defined `run(..)` utility</span>
run( foo );</pre></div>

<p>This code will work, but in the specifics of our scenario, it's not optimal. Can you spot why?</p>

<p>Because the <code>r1</code> and <code>r2</code> requests can -- and for performance reasons, <em>should</em> -- run concurrently, but in this code they will run sequentially; the <code>"http://some.url.2"</code> URL isn't Ajax fetched until after the <code>"http://some.url.1"</code> request is finished. These two requests are independent, so the better performance approach would likely be to have them run at the same time.</p>

<p>But how exactly would you do that with a generator and <code>yield</code>? We know that <code>yield</code> is only a single pause point in the code, so you can't really do two pauses at the same time.</p>

<p>The most natural and effective answer is to base the async flow on Promises, specifically on their capability to manage state in a time-independent fashion (see "Future Value" in Chapter 3).</p>

<p>The simplest approach:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// make both requests "in parallel"</span>
    <span class="pl-k">var</span> p1 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> p2 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );

    <span class="pl-c">// wait until both promises resolve</span>
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> p1;
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> <span class="pl-k">yield</span> p2;

    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r1 <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2
    );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

<span class="pl-c">// use previously defined `run(..)` utility</span>
run( foo );</pre></div>

<p>Why is this different from the previous snippet? Look at where the <code>yield</code> is and is not. <code>p1</code> and <code>p2</code> are promises for Ajax requests made concurrently (aka "in parallel"). It doesn't matter which one finishes first, because promises will hold onto their resolved state for as long as necessary.</p>

<p>Then we use two subsequent <code>yield</code> statements to wait for and retrieve the resolutions from the promises (into <code>r1</code> and <code>r2</code>, respectively). If <code>p1</code> resolves first, the <code>yield p1</code> resumes first then waits on the <code>yield p2</code> to resume. If <code>p2</code> resolves first, it will just patiently hold onto that resolution value until asked, but the <code>yield p1</code> will hold on first, until <code>p1</code> resolves.</p>

<p>Either way, both <code>p1</code> and <code>p2</code> will run concurrently, and both have to finish, in either order, before the <code>r3 = yield request..</code> Ajax request will be made.</p>

<p>If that flow control processing model sounds familiar, it's basically the same as what we identified in Chapter 3 as the "gate" pattern, enabled by the <code>Promise.all([ .. ])</code> utility. So, we could also express the flow control like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// make both requests "in parallel," and</span>
    <span class="pl-c">// wait until both promises resolve</span>
    <span class="pl-k">var</span> results <span class="pl-k">=</span> <span class="pl-k">yield</span> Promise.<span class="pl-c1">all</span>( [
        request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> ),
        request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> )
    ] );

    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> results[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> results[<span class="pl-c1">1</span>];

    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r1 <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2
    );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

<span class="pl-c">// use previously defined `run(..)` utility</span>
run( foo );</pre></div>

<p><strong>Note:</strong> As we discussed in Chapter 3, we can even use ES6 destructuring assignment to simplify the <code>var r1 = .. var r2 = ..</code> assignments, with <code>var [r1,r2] = results</code>.</p>

<p>In other words, all of the concurrency capabilities of Promises are available to us in the generator+Promise approach. So in any place where you need more than sequential this-then-that async flow control steps, Promises are likely your best bet.</p>

<h4><a id="user-content-promises-hidden" class="anchor" href="#promises-hidden" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promises, Hidden</h4>

<p>As a word of stylistic caution, be careful about how much Promise logic you include <strong>inside your generators</strong>. The whole point of using generators for asynchrony in the way we've described is to create simple, sequential, sync-looking code, and to hide as much of the details of asynchrony away from that code as possible.</p>

<p>For example, this might be a cleaner approach:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// note: normal function, not generator</span>
<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">url1</span>,<span class="pl-smi">url2</span>) {
    <span class="pl-k">return</span> Promise.<span class="pl-c1">all</span>( [
        request( url1 ),
        request( url2 )
    ] );
}

<span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// hide the Promise-based concurrency details</span>
    <span class="pl-c">// inside `bar(..)`</span>
    <span class="pl-k">var</span> results <span class="pl-k">=</span> <span class="pl-k">yield</span> bar(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>
    );

    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> results[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> results[<span class="pl-c1">1</span>];

    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request(
        <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r1 <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2
    );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

<span class="pl-c">// use previously defined `run(..)` utility</span>
run( foo );</pre></div>

<p>Inside <code>*foo()</code>, it's cleaner and clearer that all we're doing is just asking <code>bar(..)</code> to get us some <code>results</code>, and we'll <code>yield</code>-wait on that to happen. We don't have to care that under the covers a <code>Promise.all([ .. ])</code> Promise composition will be used to make that happen.</p>

<p><strong>We treat asynchrony, and indeed Promises, as an implementation detail.</strong></p>

<p>Hiding your Promise logic inside a function that you merely call from your generator is especially useful if you're going to do a sophisticated series flow-control. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    Promise.<span class="pl-c1">all</span>( [
        baz( .. )
        .then( .. ),
        Promise.race( [ .. ] )
    ] )
    .then( .. )
}</pre></div>

<p>That kind of logic is sometimes required, and if you dump it directly inside your generator(s), you've defeated most of the reason why you would want to use generators in the first place. We <em>should</em> intentionally abstract such details away from our generator code so that they don't clutter up the higher level task expression.</p>

<p>Beyond creating code that is both functional and performant, you should also strive to make code that is as reason-able and maintainable as possible.</p>

<p><strong>Note:</strong> Abstraction is not <em>always</em> a healthy thing for programming -- many times it can increase complexity in exchange for terseness. But in this case, I believe it's much healthier for your generator+Promise async code than the alternatives. As with all such advice, though, pay attention to your specific situations and make proper decisions for you and your team.</p>

<h2><a id="user-content-generator-delegation" class="anchor" href="#generator-delegation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Delegation</h2>

<p>In the previous section, we showed calling regular functions from inside a generator, and how that remains a useful technique for abstracting away implementation details (like async Promise flow). But the main drawback of using a normal function for this task is that it has to behave by the normal function rules, which means it cannot pause itself with <code>yield</code> like a generator can.</p>

<p>It may then occur to you that you might try to call one generator from another generator, using our <code>run(..)</code> helper, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2 );

    <span class="pl-k">return</span> r3;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

    <span class="pl-c">// "delegating" to `*foo()` via `run(..)`</span>
    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> run( foo );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

run( bar );</pre></div>

<p>We run <code>*foo()</code> inside of <code>*bar()</code> by using our <code>run(..)</code> utility again. We take advantage here of the fact that the <code>run(..)</code> we defined earlier returns a promise which is resolved when its generator is run to completion (or errors out), so if we <code>yield</code> out to a <code>run(..)</code> instance the promise from another <code>run(..)</code> call, it automatically pauses <code>*bar()</code> until <code>*foo()</code> finishes.</p>

<p>But there's an even better way to integrate calling <code>*foo()</code> into <code>*bar()</code>, and it's called <code>yield</code>-delegation. The special syntax for <code>yield</code>-delegation is: <code>yield * __</code> (notice the extra <code>*</code>). Before we see it work in our previous example, let's look at a simpler scenario:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>`*foo()` starting<span class="pl-pds">"</span></span> );
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">4</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>`*foo()` finished<span class="pl-pds">"</span></span> );
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();   <span class="pl-c">// `yield`-delegation!</span>
    <span class="pl-k">yield</span> <span class="pl-c1">5</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 1</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 2</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// `*foo()` starting</span>
                    <span class="pl-c">// 3</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// 4</span>
it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span>;    <span class="pl-c">// `*foo()` finished</span>
                    <span class="pl-c">// 5</span></pre></div>

<p><strong>Note:</strong> Similar to a note earlier in the chapter where I explained why I prefer <code>function *foo() ..</code> instead of <code>function* foo() ..</code>, I also prefer -- differing from most other documentation on the topic -- to say <code>yield *foo()</code> instead of <code>yield* foo()</code>. The placement of the <code>*</code> is purely stylistic and up to your best judgment. But I find the consistency of styling attractive.</p>

<p>How does the <code>yield *foo()</code> delegation work?</p>

<p>First, calling <code>foo()</code> creates an <em>iterator</em> exactly as we've already seen. Then, <code>yield *</code> delegates/transfers the <em>iterator</em> instance control (of the present <code>*bar()</code> generator) over to this other <code>*foo()</code> <em>iterator</em>.</p>

<p>So, the first two <code>it.next()</code> calls are controlling <code>*bar()</code>, but when we make the third <code>it.next()</code> call, now <code>*foo()</code> starts up, and now we're controlling <code>*foo()</code> instead of <code>*bar()</code>. That's why it's called delegation -- <code>*bar()</code> delegated its iteration control to <code>*foo()</code>.</p>

<p>As soon as the <code>it</code> <em>iterator</em> control exhausts the entire <code>*foo()</code> <em>iterator</em>, it automatically returns to controlling <code>*bar()</code>.</p>

<p>So now back to the previous example with the three sequential Ajax requests:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2 );

    <span class="pl-k">return</span> r3;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

    <span class="pl-c">// "delegating" to `*foo()` via `yield*`</span>
    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

run( bar );</pre></div>

<p>The only difference between this snippet and the version used earlier is the use of <code>yield *foo()</code> instead of the previous <code>yield run(foo)</code>.</p>

<p><strong>Note:</strong> <code>yield *</code> yields iteration control, not generator control; when you invoke the <code>*foo()</code> generator, you're now <code>yield</code>-delegating to its <em>iterator</em>. But you can actually <code>yield</code>-delegate to any <em>iterable</em>; <code>yield *[1,2,3]</code> would consume the default <em>iterator</em> for the <code>[1,2,3]</code> array value.</p>

<h3><a id="user-content-why-delegation" class="anchor" href="#why-delegation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why Delegation?</h3>

<p>The purpose of <code>yield</code>-delegation is mostly code organization, and in that way is symmetrical with normal function calling.</p>

<p>Imagine two modules that respectively provide methods <code>foo()</code> and <code>bar()</code>, where <code>bar()</code> calls <code>foo()</code>. The reason the two are separate is generally because the proper organization of code for the program calls for them to be in separate functions. For example, there may be cases where <code>foo()</code> is called standalone, and other places where <code>bar()</code> calls <code>foo()</code>.</p>

<p>For all these exact same reasons, keeping generators separate aids in program readability, maintenance, and debuggability. In that respect, <code>yield *</code> is a syntactic shortcut for manually iterating over the steps of <code>*foo()</code> while inside of <code>*bar()</code>.</p>

<p>Such manual approach would be especially complex if the steps in <code>*foo()</code> were asynchronous, which is why you'd probably need to use that <code>run(..)</code> utility to do it. And as we've shown, <code>yield *foo()</code> eliminates the need for a sub-instance of the <code>run(..)</code> utility (like <code>run(foo)</code>).</p>

<h3><a id="user-content-delegating-messages" class="anchor" href="#delegating-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegating Messages</h3>

<p>You may wonder how this <code>yield</code>-delegation works not just with <em>iterator</em> control but with the two-way message passing. Carefully follow the flow of messages in and out, through the <code>yield</code>-delegation:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*foo()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span> );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*foo()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> );

    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> );

    <span class="pl-c">// `yield`-delegation!</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-k">*</span>foo() );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span> );

    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span> );
<span class="pl-c">// outside: A</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">1</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*bar()`: 1</span>
<span class="pl-c">// outside: B</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">2</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*foo()`: 2</span>
<span class="pl-c">// outside: C</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">3</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*foo()`: 3</span>
<span class="pl-c">// inside `*bar()`: D</span>
<span class="pl-c">// outside: E</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">4</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*bar()`: 4</span>
<span class="pl-c">// outside: F</span></pre></div>

<p>Pay particular attention to the processing steps after the <code>it.next(3)</code> call:</p>

<ol>
<li>The <code>3</code> value is passed (through the <code>yield</code>-delegation in <code>*bar()</code>) into the waiting <code>yield "C"</code> expression inside of <code>*foo()</code>.</li>
<li><code>*foo()</code> then calls <code>return "D"</code>, but this value doesn't get returned all the way back to the outside <code>it.next(3)</code> call.</li>
<li>Instead, the <code>"D"</code> value is sent as the result of the waiting <code>yield *foo()</code> expression inside of <code>*bar()</code> -- this <code>yield</code>-delegation expression has essentially been paused while all of <code>*foo()</code> was exhausted. So <code>"D"</code> ends up inside of <code>*bar()</code> for it to print out.</li>
<li><code>yield "E"</code> is called inside of <code>*bar()</code>, and the <code>"E"</code> value is yielded to the outside as the result of the <code>it.next(3)</code> call.</li>
</ol>

<p>From the perspective of the external <em>iterator</em> (<code>it</code>), it doesn't appear any differently between controlling the initial generator or a delegated one.</p>

<p>In fact, <code>yield</code>-delegation doesn't even have to be directed to another generator; it can just be directed to a non-generator, general <em>iterable</em>. For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span> );

    <span class="pl-c">// `yield`-delegation to a non-generator!</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-k">*</span>[ <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span> ] );

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>inside `*bar()`:<span class="pl-pds">"</span></span>, <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span> );

    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span> );
<span class="pl-c">// outside: A</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">1</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*bar()`: 1</span>
<span class="pl-c">// outside: B</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">2</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// outside: C</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">3</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// outside: D</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">4</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*bar()`: undefined</span>
<span class="pl-c">// outside: E</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">5</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// inside `*bar()`: 5</span>
<span class="pl-c">// outside: F</span></pre></div>

<p>Notice the differences in where the messages were received/reported between this example and the one previous.</p>

<p>Most strikingly, the default <code>array</code> <em>iterator</em> doesn't care about any messages sent in via <code>next(..)</code> calls, so the values <code>2</code>, <code>3</code>, and <code>4</code> are essentially ignored. Also, because that <em>iterator</em> has no explicit <code>return</code> value (unlike the previously used <code>*foo()</code>), the <code>yield *</code> expression gets an <code>undefined</code> when it finishes.</p>

<h4><a id="user-content-exceptions-delegated-too" class="anchor" href="#exceptions-delegated-too" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exceptions Delegated, Too!</h4>

<p>In the same way that <code>yield</code>-delegation transparently passes messages through in both directions, errors/exceptions also pass in both directions:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>;
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>error caught inside `*foo()`:<span class="pl-pds">"</span></span>, err );
    }

    <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span>;

    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>D<span class="pl-pds">"</span></span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>;

    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>error caught inside `*bar()`:<span class="pl-pds">"</span></span>, err );
    }

    <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>E<span class="pl-pds">"</span></span>;

    <span class="pl-k">yield</span> <span class="pl-k">*</span>baz();

    <span class="pl-c">// note: can't get here!</span>
    <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>G<span class="pl-pds">"</span></span>;
}

<span class="pl-k">function</span> <span class="pl-en">*baz</span>() {
    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>F<span class="pl-pds">"</span></span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>().<span class="pl-c1">value</span> );
<span class="pl-c">// outside: A</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">1</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// outside: B</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.throw( <span class="pl-c1">2</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// error caught inside `*foo()`: 2</span>
<span class="pl-c">// outside: C</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">3</span> ).<span class="pl-c1">value</span> );
<span class="pl-c">// error caught inside `*bar()`: D</span>
<span class="pl-c">// outside: E</span>

<span class="pl-k">try</span> {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>outside:<span class="pl-pds">"</span></span>, it.<span class="pl-c1">next</span>( <span class="pl-c1">4</span> ).<span class="pl-c1">value</span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>error caught outside:<span class="pl-pds">"</span></span>, err );
}
<span class="pl-c">// error caught outside: F</span></pre></div>

<p>Some things to note from this snippet:</p>

<ol>
<li>When we call <code>it.throw(2)</code>, it sends the error message <code>2</code> into <code>*bar()</code>, which delegates that to <code>*foo()</code>, which then <code>catch</code>es it and handles it gracefully. Then, the <code>yield "C"</code> sends <code>"C"</code> back out as the return <code>value</code> from the <code>it.throw(2)</code> call.</li>
<li>The <code>"D"</code> value that's next <code>throw</code>n from inside <code>*foo()</code> propagates out to <code>*bar()</code>, which <code>catch</code>es it and handles it gracefully. Then the <code>yield "E"</code> sends <code>"E"</code> back out as the return <code>value</code> from the <code>it.next(3)</code> call.</li>
<li>Next, the exception <code>throw</code>n from <code>*baz()</code> isn't caught in <code>*bar()</code> -- though we did <code>catch</code> it outside -- so both <code>*baz()</code> and <code>*bar()</code> are set to a completed state. After this snippet, you would not be able to get the <code>"G"</code> value out with any subsequent <code>next(..)</code> call(s) -- they will just return <code>undefined</code> for <code>value</code>.</li>
</ol>

<h3><a id="user-content-delegating-asynchrony" class="anchor" href="#delegating-asynchrony" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegating Asynchrony</h3>

<p>Let's finally get back to our earlier <code>yield</code>-delegation example with the multiple sequential Ajax requests:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> r2 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );
    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.3/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> r2 );

    <span class="pl-k">return</span> r3;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

    <span class="pl-k">var</span> r3 <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r3 );
}

run( bar );</pre></div>

<p>Instead of calling <code>yield run(foo)</code> inside of <code>*bar()</code>, we just call <code>yield *foo()</code>.</p>

<p>In the previous version of this example, the Promise mechanism (controlled by <code>run(..)</code>) was used to transport the value from <code>return r3</code> in <code>*foo()</code> to the local variable <code>r3</code> inside <code>*bar()</code>. Now, that value is just returned back directly via the <code>yield *</code> mechanics.</p>

<p>Otherwise, the behavior is pretty much identical.</p>

<h3><a id="user-content-delegating-recursion" class="anchor" href="#delegating-recursion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegating "Recursion"</h3>

<p>Of course, <code>yield</code>-delegation can keep following as many delegation steps as you wire up. You could even use <code>yield</code>-delegation for async-capable generator "recursion" -- a generator <code>yield</code>-delegating to itself:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">val</span>) {
    <span class="pl-k">if</span> (val <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
        <span class="pl-c">// generator recursion</span>
        val <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( val <span class="pl-k">-</span> <span class="pl-c1">1</span> );
    }

    <span class="pl-k">return</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url/?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> val );
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> r1 <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( <span class="pl-c1">3</span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( r1 );
}

run( bar );</pre></div>

<p><strong>Note:</strong> Our <code>run(..)</code> utility could have been called with <code>run( foo, 3 )</code>, because it supports additional parameters being passed along to the initialization of the generator. However, we used a parameter-free <code>*bar()</code> here to highlight the flexibility of <code>yield *</code>.</p>

<p>What processing steps follow from that code? Hang on, this is going to be quite intricate to describe in detail:</p>

<ol>
<li><code>run(bar)</code> starts up the <code>*bar()</code> generator.</li>
<li><code>foo(3)</code> creates an <em>iterator</em> for <code>*foo(..)</code> and passes <code>3</code> as its <code>val</code> parameter.</li>
<li>Because <code>3 &gt; 1</code>, <code>foo(2)</code> creates another <em>iterator</em> and passes in <code>2</code> as its <code>val</code> parameter.</li>
<li>Because <code>2 &gt; 1</code>, <code>foo(1)</code> creates yet another <em>iterator</em> and passes in <code>1</code> as its <code>val</code> parameter.</li>
<li><code>1 &gt; 1</code> is <code>false</code>, so we next call <code>request(..)</code> with the <code>1</code> value, and get a promise back for that first Ajax call.</li>
<li>That promise is <code>yield</code>ed out, which comes back to the <code>*foo(2)</code> generator instance.</li>
<li>The <code>yield *</code> passes that promise back out to the <code>*foo(3)</code> generator instance. Another <code>yield *</code> passes the promise out to the <code>*bar()</code> generator instance. And yet again another <code>yield *</code> passes the promise out to the <code>run(..)</code> utility, which will wait on that promise (for the first Ajax request) to proceed.</li>
<li>When the promise resolves, its fulfillment message is sent to resume <code>*bar()</code>, which passes through the <code>yield *</code> into the <code>*foo(3)</code> instance, which then passes through the <code>yield *</code> to the <code>*foo(2)</code> generator instance, which then passes through the <code>yield *</code> to the normal <code>yield</code> that's waiting in the <code>*foo(3)</code> generator instance.</li>
<li>That first call's Ajax response is now immediately <code>return</code>ed from the <code>*foo(3)</code> generator instance, which sends that value back as the result of the <code>yield *</code> expression in the <code>*foo(2)</code> instance, and assigned to its local <code>val</code> variable.</li>
<li>Inside <code>*foo(2)</code>, a second Ajax request is made with <code>request(..)</code>, whose promise is <code>yield</code>ed back to the <code>*foo(1)</code> instance, and then <code>yield *</code> propagates all the way out to <code>run(..)</code> (step 7 again). When the promise resolves, the second Ajax response propagates all the way back into the <code>*foo(2)</code> generator instance, and is assigned to its local <code>val</code> variable.</li>
<li>Finally, the third Ajax request is made with <code>request(..)</code>, its promise goes out to <code>run(..)</code>, and then its resolution value comes all the way back, which is then <code>return</code>ed so that it comes back to the waiting <code>yield *</code> expression in <code>*bar()</code>.</li>
</ol>

<p>Phew! A lot of crazy mental juggling, huh? You might want to read through that a few more times, and then go grab a snack to clear your head!</p>

<h2><a id="user-content-generator-concurrency" class="anchor" href="#generator-concurrency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Concurrency</h2>

<p>As we discussed in both Chapter 1 and earlier in this chapter, two simultaneously running "processes" can cooperatively interleave their operations, and many times this can <em>yield</em> (pun intended) very powerful asynchrony expressions.</p>

<p>Frankly, our earlier examples of concurrency interleaving of multiple generators showed how to make it really confusing. But we hinted that there's places where this capability is quite useful.</p>

<p>Recall a scenario we looked at in Chapter 1, where two different simultaneous Ajax response handlers needed to coordinate with each other to make sure that the data communication was not a race condition. We slotted the responses into the <code>res</code> array like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">response</span>(<span class="pl-smi">data</span>) {
    <span class="pl-k">if</span> (data.url <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>) {
        res[<span class="pl-c1">0</span>] <span class="pl-k">=</span> data;
    }
    <span class="pl-k">else</span> <span class="pl-k">if</span> (data.url <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>) {
        res[<span class="pl-c1">1</span>] <span class="pl-k">=</span> data;
    }
}</pre></div>

<p>But how can we use multiple generators concurrently for this scenario?</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-k">function</span> <span class="pl-en">*reqData</span>(<span class="pl-smi">url</span>) {
    res.<span class="pl-c1">push</span>(
        <span class="pl-k">yield</span> request( url )
    );
}</pre></div>

<p><strong>Note:</strong> We're going to use two instances of the <code>*reqData(..)</code> generator here, but there's no difference to running a single instance of two different generators; both approaches are reasoned about identically. We'll see two different generators coordinating in just a bit.</p>

<p>Instead of having to manually sort out <code>res[0]</code> and <code>res[1]</code> assignments, we'll use coordinated ordering so that <code>res.push(..)</code> properly slots the values in the expected and predictable order. The expressed logic thus should feel a bit cleaner.</p>

<p>But how will we actually orchestrate this interaction? First, let's just do it manually, with Promises:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> it1 <span class="pl-k">=</span> reqData( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> it2 <span class="pl-k">=</span> reqData( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> it1.<span class="pl-c1">next</span>();
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> it2.<span class="pl-c1">next</span>();

p1
.then( <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    it1.<span class="pl-c1">next</span>( data );
    <span class="pl-k">return</span> p2;
} )
.then( <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    it2.<span class="pl-c1">next</span>( data );
} );</pre></div>

<p><code>*reqData(..)</code>'s two instances are both started to make their Ajax requests, then paused with <code>yield</code>. Then we choose to resume the first instance when <code>p1</code> resolves, and then <code>p2</code>'s resolution will restart the second instance. In this way, we use Promise orchestration to ensure that <code>res[0]</code> will have the first response and <code>res[1]</code> will have the second response.</p>

<p>But frankly, this is awfully manual, and it doesn't really let the generators orchestrate themselves, which is where the true power can lie. Let's try it a different way:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">var</span> res <span class="pl-k">=</span> [];

<span class="pl-k">function</span> <span class="pl-en">*reqData</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">var</span> data <span class="pl-k">=</span> <span class="pl-k">yield</span> request( url );

    <span class="pl-c">// transfer control</span>
    <span class="pl-k">yield</span>;

    res.<span class="pl-c1">push</span>( data );
}

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> reqData( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );
<span class="pl-k">var</span> it2 <span class="pl-k">=</span> reqData( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> it1.<span class="pl-c1">next</span>();
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> it2.<span class="pl-c1">next</span>();

p1.then( <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    it1.<span class="pl-c1">next</span>( data );
} );

p2.then( <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    it2.<span class="pl-c1">next</span>( data );
} );

Promise.<span class="pl-c1">all</span>( [p1,p2] )
.then( <span class="pl-k">function</span>(){
    it1.<span class="pl-c1">next</span>();
    it2.<span class="pl-c1">next</span>();
} );</pre></div>

<p>OK, this is a bit better (though still manual!), because now the two instances of <code>*reqData(..)</code> run truly concurrently, and (at least for the first part) independently.</p>

<p>In the previous snippet, the second instance was not given its data until after the first instance was totally finished. But here, both instances receive their data as soon as their respective responses come back, and then each instance does another <code>yield</code> for control transfer purposes. We then choose what order to resume them in the <code>Promise.all([ .. ])</code> handler.</p>

<p>What may not be as obvious is that this approach hints at an easier form for a reusable utility, because of the symmetry. We can do even better. Let's imagine using a utility called <code>runAll(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">var</span> res <span class="pl-k">=</span> [];

runAll(
    <span class="pl-k">function*</span>(){
        <span class="pl-k">var</span> p1 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

        <span class="pl-c">// transfer control</span>
        <span class="pl-k">yield</span>;

        res.<span class="pl-c1">push</span>( <span class="pl-k">yield</span> p1 );
    },
    <span class="pl-k">function*</span>(){
        <span class="pl-k">var</span> p2 <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span> );

        <span class="pl-c">// transfer control</span>
        <span class="pl-k">yield</span>;

        res.<span class="pl-c1">push</span>( <span class="pl-k">yield</span> p2 );
    }
);</pre></div>

<p><strong>Note:</strong> We're not including a code listing for <code>runAll(..)</code> as it is not only long enough to bog down the text, but is an extension of the logic we've already implemented in <code>run(..)</code> earlier. So, as a good supplementary exercise for the reader, try your hand at evolving the code from <code>run(..)</code> to work like the imagined <code>runAll(..)</code>. Also, my <em>asynquence</em> library provides a previously mentioned <code>runner(..)</code> utility with this kind of capability already built in, and will be discussed in Appendix A of this book.</p>

<p>Here's how the processing inside <code>runAll(..)</code> would operate:</p>

<ol>
<li>The first generator gets a promise for the first Ajax response from <code>"http://some.url.1"</code>, then <code>yield</code>s control back to the <code>runAll(..)</code> utility.</li>
<li>The second generator runs and does the same for <code>"http://some.url.2"</code>, <code>yield</code>ing control back to the <code>runAll(..)</code> utility.</li>
<li>The first generator resumes, and then <code>yield</code>s out its promise <code>p1</code>. The <code>runAll(..)</code> utility does the same in this case as our previous <code>run(..)</code>, in that it waits on that promise to resolve, then resumes the same generator (no control transfer!). When <code>p1</code> resolves, <code>runAll(..)</code> resumes the first generator again with that resolution value, and then <code>res[0]</code> is given its value. When the first generator then finishes, that's an implicit transfer of control.</li>
<li>The second generator resumes, <code>yield</code>s out its promise <code>p2</code>, and waits for it to resolve. Once it does, <code>runAll(..)</code> resumes the second generator with that value, and <code>res[1]</code> is set.</li>
</ol>

<p>In this running example, we use an outer variable called <code>res</code> to store the results of the two different Ajax responses -- that's our concurrency coordination making that possible.</p>

<p>But it might be quite helpful to further extend <code>runAll(..)</code> to provide an inner variable space for the multiple generator instances to <em>share</em>, such as an empty object we'll call <code>data</code> below. Also, it could take non-Promise values that are <code>yield</code>ed and hand them off to the next generator.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

runAll(
    <span class="pl-k">function*</span>(<span class="pl-smi">data</span>){
        data.res <span class="pl-k">=</span> [];

        <span class="pl-c">// transfer control (and message pass)</span>
        <span class="pl-k">var</span> url1 <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2<span class="pl-pds">"</span></span>;

        <span class="pl-k">var</span> p1 <span class="pl-k">=</span> request( url1 ); <span class="pl-c">// "http://some.url.1"</span>

        <span class="pl-c">// transfer control</span>
        <span class="pl-k">yield</span>;

        data.res.<span class="pl-c1">push</span>( <span class="pl-k">yield</span> p1 );
    },
    <span class="pl-k">function*</span>(<span class="pl-smi">data</span>){
        <span class="pl-c">// transfer control (and message pass)</span>
        <span class="pl-k">var</span> url2 <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>;

        <span class="pl-k">var</span> p2 <span class="pl-k">=</span> request( url2 ); <span class="pl-c">// "http://some.url.2"</span>

        <span class="pl-c">// transfer control</span>
        <span class="pl-k">yield</span>;

        data.res.<span class="pl-c1">push</span>( <span class="pl-k">yield</span> p2 );
    }
);</pre></div>

<p>In this formulation, the two generators are not just coordinating control transfer, but actually communicating with each other, both through <code>data.res</code> and the <code>yield</code>ed messages that trade <code>url1</code> and <code>url2</code> values. That's incredibly powerful!</p>

<p>Such realization also serves as a conceptual base for a more sophisticated asynchrony technique called CSP (Communicating Sequential Processes), which we will cover in Appendix B of this book.</p>

<h2><a id="user-content-thunks" class="anchor" href="#thunks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thunks</h2>

<p>So far, we've made the assumption that <code>yield</code>ing a Promise from a generator -- and having that Promise resume the generator via a helper utility like <code>run(..)</code> -- was the best possible way to manage asynchrony with generators. To be clear, it is.</p>

<p>But we skipped over another pattern that has some mildly widespread adoption, so in the interest of completeness we'll take a brief look at it.</p>

<p>In general computer science, there's an old pre-JS concept called a "thunk." Without getting bogged down in the historical nature, a narrow expression of a thunk in JS is a function that -- without any parameters -- is wired to call another function.</p>

<p>In other words, you wrap a function definition around function call -- with any parameters it needs -- to <em>defer</em> the execution of that call, and that wrapping function is a thunk. When you later execute the thunk, you end up calling the original function.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

<span class="pl-k">function</span> <span class="pl-en">fooThunk</span>() {
    <span class="pl-k">return</span> foo( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );
}

<span class="pl-c">// later</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( fooThunk() );  <span class="pl-c">// 7</span></pre></div>

<p>So, a synchronous thunk is pretty straightforward. But what about an async thunk? We can essentially extend the narrow thunk definition to include it receiving a callback.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">cb</span>) {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        cb( x <span class="pl-k">+</span> y );
    }, <span class="pl-c1">1000</span> );
}

<span class="pl-k">function</span> <span class="pl-en">fooThunk</span>(<span class="pl-smi">cb</span>) {
    foo( <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, cb );
}

<span class="pl-c">// later</span>

fooThunk( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
} );</pre></div>

<p>As you can see, <code>fooThunk(..)</code> only expects a <code>cb(..)</code> parameter, as it already has values <code>3</code> and <code>4</code> (for <code>x</code> and <code>y</code>, respectively) pre-specified and ready to pass to <code>foo(..)</code>. A thunk is just waiting around patiently for the last piece it needs to do its job: the callback.</p>

<p>You don't want to make thunks manually, though. So, let's invent a utility that does this wrapping for us.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">thunkify</span>(<span class="pl-smi">fn</span>) {
    <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span> );
    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
        args.<span class="pl-c1">push</span>( cb );
        <span class="pl-k">return</span> fn.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, args );
    };
}

<span class="pl-k">var</span> fooThunk <span class="pl-k">=</span> thunkify( foo, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );

<span class="pl-c">// later</span>

fooThunk( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
} );</pre></div>

<p><strong>Tip:</strong> Here we assume that the original (<code>foo(..)</code>) function signature expects its callback in the last position, with any other parameters coming before it. This is a pretty ubiquitous "standard" for async JS function standards. You might call it "callback-last style." If for some reason you had a need to handle "callback-first style" signatures, you would just make a utility that used <code>args.unshift(..)</code> instead of <code>args.push(..)</code>.</p>

<p>The preceding formulation of <code>thunkify(..)</code> takes both the <code>foo(..)</code> function reference, and any parameters it needs, and returns back the thunk itself (<code>fooThunk(..)</code>). However, that's not the typical approach you'll find to thunks in JS.</p>

<p>Instead of <code>thunkify(..)</code> making the thunk itself, typically -- if not perplexingly -- the <code>thunkify(..)</code> utility would produce a function that produces thunks.</p>

<p>Uhhhh... yeah.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">thunkify</span>(<span class="pl-smi">fn</span>) {
    <span class="pl-k">return</span> <span class="pl-k">function</span>() {
        <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments );
        <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">cb</span>) {
            args.<span class="pl-c1">push</span>( cb );
            <span class="pl-k">return</span> fn.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, args );
        };
    };
}</pre></div>

<p>The main difference here is the extra <code>return function() { .. }</code> layer. Here's how its usage differs:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> whatIsThis <span class="pl-k">=</span> thunkify( foo );

<span class="pl-k">var</span> fooThunk <span class="pl-k">=</span> whatIsThis( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );

<span class="pl-c">// later</span>

fooThunk( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
} );</pre></div>

<p>Obviously, the big question this snippet implies is what is <code>whatIsThis</code> properly called? It's not the thunk, it's the thing that will produce thunks from <code>foo(..)</code> calls. It's kind of like a "factory" for "thunks." There doesn't seem to be any kind of standard agreement for naming such a thing.</p>

<p>So, my proposal is "thunkory" ("thunk" + "factory").  So, <code>thunkify(..)</code> produces a thunkory, and a thunkory produces thunks. That reasoning is symmetric to my proposal for "promisory" in Chapter 3:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> fooThunkory <span class="pl-k">=</span> thunkify( foo );

<span class="pl-k">var</span> fooThunk1 <span class="pl-k">=</span> fooThunkory( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );
<span class="pl-k">var</span> fooThunk2 <span class="pl-k">=</span> fooThunkory( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );

<span class="pl-c">// later</span>

fooThunk1( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
} );

fooThunk2( <span class="pl-k">function</span>(<span class="pl-smi">sum</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 11</span>
} );</pre></div>

<p><strong>Note:</strong> The running <code>foo(..)</code> example expects a style of callback that's not "error-first style." Of course, "error-first style" is much more common. If <code>foo(..)</code> had some sort of legitimate error-producing expectation, we could change it to expect and use an error-first callback. None of the subsequent <code>thunkify(..)</code> machinery cares what style of callback is assumed. The only difference in usage would be <code>fooThunk1(function(err,sum){..</code>.</p>

<p>Exposing the thunkory method -- instead of how the earlier <code>thunkify(..)</code> hides this intermediary step -- may seem like unnecessary complication. But in general, it's quite useful to make thunkories at the beginning of your program to wrap existing API methods, and then be able to pass around and call those thunkories when you need thunks. The two distinct steps preserve a cleaner separation of capability.</p>

<p>To illustrate:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// cleaner:</span>
<span class="pl-k">var</span> fooThunkory <span class="pl-k">=</span> thunkify( foo );

<span class="pl-k">var</span> fooThunk1 <span class="pl-k">=</span> fooThunkory( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );
<span class="pl-k">var</span> fooThunk2 <span class="pl-k">=</span> fooThunkory( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );

<span class="pl-c">// instead of:</span>
<span class="pl-k">var</span> fooThunk1 <span class="pl-k">=</span> thunkify( foo, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );
<span class="pl-k">var</span> fooThunk2 <span class="pl-k">=</span> thunkify( foo, <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );</pre></div>

<p>Regardless of whether you like to deal with the thunkories explicitly or not, the usage of thunks <code>fooThunk1(..)</code> and <code>fooThunk2(..)</code> remains the same.</p>

<h3><a id="user-content-spromisethunk" class="anchor" href="#spromisethunk" aria-hidden="true"><span class="octicon octicon-link"></span></a>s/promise/thunk/</h3>

<p>So what's all this thunk stuff have to do with generators?</p>

<p>Comparing thunks to promises generally: they're not directly interchangable as they're not equivalent in behavior. Promises are vastly more capable and trustable than bare thunks.</p>

<p>But in another sense, they both can be seen as a request for a value, which may be async in its answering.</p>

<p>Recall from Chapter 3 we defined a utility for promisifying a function, which we called <code>Promise.wrap(..)</code> -- we could have called it <code>promisify(..)</code>, too! This Promise-wrapping utility doesn't produce Promises; it produces promisories that in turn produce Promises. This is completely symmetric to the thunkories and thunks presently being discussed.</p>

<p>To illustrate the symmetry, let's first alter the running <code>foo(..)</code> example from earlier to assume an "error-first style" callback:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">cb</span>) {
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        <span class="pl-c">// assume `cb(..)` as "error-first style"</span>
        cb( <span class="pl-c1">null</span>, x <span class="pl-k">+</span> y );
    }, <span class="pl-c1">1000</span> );
}</pre></div>

<p>Now, we'll compare using <code>thunkify(..)</code> and <code>promisify(..)</code> (aka <code>Promise.wrap(..)</code> from Chapter 3):</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// symmetrical: constructing the question asker</span>
<span class="pl-k">var</span> fooThunkory <span class="pl-k">=</span> thunkify( foo );
<span class="pl-k">var</span> fooPromisory <span class="pl-k">=</span> promisify( foo );

<span class="pl-c">// symmetrical: asking the question</span>
<span class="pl-k">var</span> fooThunk <span class="pl-k">=</span> fooThunkory( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );
<span class="pl-k">var</span> fooPromise <span class="pl-k">=</span> fooPromisory( <span class="pl-c1">3</span>, <span class="pl-c1">4</span> );

<span class="pl-c">// get the thunk answer</span>
fooThunk( <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">sum</span>){
    <span class="pl-k">if</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
    <span class="pl-k">else</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
    }
} );

<span class="pl-c">// get the promise answer</span>
fooPromise
.then(
    <span class="pl-k">function</span>(<span class="pl-smi">sum</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( sum );     <span class="pl-c">// 7</span>
    },
    <span class="pl-k">function</span>(<span class="pl-smi">err</span>){
        <span class="pl-en">console</span><span class="pl-c1">.error</span>( err );
    }
);</pre></div>

<p>Both the thunkory and the promisory are essentially asking a question (for a value), and respectively the thunk <code>fooThunk</code> and promise <code>fooPromise</code> represent the future answers to that question. Presented in that light, the symmetry is clear.</p>

<p>With that perspective in mind, we can see that generators which <code>yield</code> Promises for asynchrony could instead <code>yield</code> thunks for asynchrony. All we'd need is a smarter <code>run(..)</code> utility (like from before) that can not only look for and wire up to a <code>yield</code>ed Promise but also to provide a callback to a <code>yield</code>ed thunk.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> val <span class="pl-k">=</span> <span class="pl-k">yield</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}

run( foo );</pre></div>

<p>In this example, <code>request(..)</code> could either be a promisory that returns a promise, or a thunkory that returns a thunk. From the perspective of what's going on inside the generator code logic, we don't care about that implementation detail, which is quite powerful!</p>

<p>So, <code>request(..)</code> could be either:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// promisory `request(..)` (see Chapter 3)</span>
<span class="pl-k">var</span> request <span class="pl-k">=</span> Promise.wrap( ajax );

<span class="pl-c">// vs.</span>

<span class="pl-c">// thunkory `request(..)`</span>
<span class="pl-k">var</span> request <span class="pl-k">=</span> thunkify( ajax );</pre></div>

<p>Finally, as a thunk-aware patch to our earlier <code>run(..)</code> utility, we would need logic like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// ..</span>
<span class="pl-c">// did we receive a thunk back?</span>
<span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-k">typeof</span> next.<span class="pl-c1">value</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// call the thunk with an error-first callback</span>
        next.<span class="pl-c1">value</span>( <span class="pl-k">function</span>(<span class="pl-smi">err</span>,<span class="pl-smi">msg</span>) {
            <span class="pl-k">if</span> (err) {
                reject( err );
            }
            <span class="pl-k">else</span> {
                resolve( msg );
            }
        } );
    } )
    .then(
        handleNext,
        <span class="pl-k">function</span> <span class="pl-en">handleErr</span>(<span class="pl-smi">err</span>) {
            <span class="pl-k">return</span> Promise.resolve(
                it.throw( err )
            )
            .then( handleResult );
        }
    );
}</pre></div>

<p>Now, our generators can either call promisories to <code>yield</code> Promises, or call thunkories to <code>yield</code> thunks, and in either case, <code>run(..)</code> would handle that value and use it to wait for the completion to resume the generator.</p>

<p>Symmetry wise, these two approaches look identical. However, we should point out that's true only from the perspective of Promises or thunks representing the future value continuation of a generator.</p>

<p>From the larger perspective, thunks do not in and of themselves have hardly any of the trustability or composability guarantees that Promises are designed with. Using a thunk as a stand-in for a Promise in this particular generator asynchrony pattern is workable but should be seen as less than ideal when compared to all the benefits that Promises offer (see Chapter 3).</p>

<p>If you have the option, prefer <code>yield pr</code> rather than <code>yield th</code>. But there's nothing wrong with having a <code>run(..)</code> utility which can handle both value types.</p>

<p><strong>Note:</strong> The <code>runner(..)</code> utility in my <em>asynquence</em> library, which will be discussed in Appendix A, handles <code>yield</code>s of Promises, thunks and <em>asynquence</em> sequences.</p>

<h2><a id="user-content-pre-es6-generators" class="anchor" href="#pre-es6-generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pre-ES6 Generators</h2>

<p>You're hopefully convinced now that generators are a very important addition to the async programming toolbox. But it's a new syntax in ES6, which means you can't just polyfill generators like you can Promises (which are just a new API). So what can we do to bring generators to our browser JS if we don't have the luxury of ignoring pre-ES6 browsers?</p>

<p>For all new syntax extensions in ES6, there are tools -- the most common term for them is transpilers, for trans-compilers -- which can take your ES6 syntax and transform it into equivalent (but obviously uglier!) pre-ES6 code. So, generators can be transpiled into code that will have the same behavior but work in ES5 and below.</p>

<p>But how? The "magic" of <code>yield</code> doesn't obviously sound like code that's easy to transpile. We actually hinted at a solution in our earlier discussion of closure-based <em>iterators</em>.</p>

<h3><a id="user-content-manual-transformation" class="anchor" href="#manual-transformation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manual Transformation</h3>

<p>Before we discuss the transpilers, let's derive how manual transpilation would work in the case of generators. This isn't just an academic exercise, because doing so will actually help further reinforce how they work.</p>

<p>Consider:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">try</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>requesting:<span class="pl-pds">"</span></span>, url );
        <span class="pl-k">var</span> val <span class="pl-k">=</span> <span class="pl-k">yield</span> request( url );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Oops:<span class="pl-pds">"</span></span>, err );
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );</pre></div>

<p>The first thing to observe is that we'll still need a normal <code>foo()</code> function that can be called, and it will still need to return an <em>iterator</em>. So, let's sketch out the non-generator transformation:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">url</span>) {

    <span class="pl-c">// ..</span>

    <span class="pl-c">// make and return an iterator</span>
    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-c">// ..</span>
        },
        <span class="pl-en">throw</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">e</span>) {
            <span class="pl-c">// ..</span>
        }
    };
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );</pre></div>

<p>The next thing to observe is that a generator does its "magic" by suspending its scope/state, but we can emulate that with function closure (see the <em>Scope &amp; Closures</em> title of this series). To understand how to write such code, we'll first annotate different parts of our generator with state values:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-c">// STATE *1*</span>

    <span class="pl-k">try</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>requesting:<span class="pl-pds">"</span></span>, url );
        <span class="pl-k">var</span> <span class="pl-c1">TMP1</span> <span class="pl-k">=</span> request( url );

        <span class="pl-c">// STATE *2*</span>
        <span class="pl-k">var</span> val <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">TMP1</span>;
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-c">// STATE *3*</span>
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Oops:<span class="pl-pds">"</span></span>, err );
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
    }
}</pre></div>

<p><strong>Note:</strong> For more accurate illustration, we split up the <code>val = yield request..</code> statement into two parts, using the temporary <code>TMP1</code> variable. <code>request(..)</code> happens in state <code>*1*</code>, and the assignment of its completion value to <code>val</code> happens in state <code>*2*</code>. We'll get rid of that intermediate <code>TMP1</code> when we convert the code to its non-generator equivalent.</p>

<p>In other words, <code>*1*</code> is the beginning state, <code>*2*</code> is the state if the <code>request(..)</code> succeeds, and <code>*3*</code> is the state if the <code>request(..)</code> fails. You can probably imagine how any extra <code>yield</code> steps would just be encoded as extra states.</p>

<p>Back to our transpiled generator, let's define a variable <code>state</code> in the closure we can use to keep track of the state:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-c">// manage generator state</span>
    <span class="pl-k">var</span> state;

    <span class="pl-c">// ..</span>
}</pre></div>

<p>Now, let's define an inner function called <code>process(..)</code> inside the closure which handles each state, using a <code>switch</code> statement:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-c">// manage generator state</span>
    <span class="pl-k">var</span> state;

    <span class="pl-c">// generator-wide variable declarations</span>
    <span class="pl-k">var</span> val;

    <span class="pl-k">function</span> <span class="pl-en">process</span>(<span class="pl-smi">v</span>) {
        <span class="pl-k">switch</span> (state) {
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>requesting:<span class="pl-pds">"</span></span>, url );
                <span class="pl-k">return</span> request( url );
            <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span>
                val <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
                <span class="pl-k">return</span>;
            <span class="pl-k">case</span> <span class="pl-c1">3</span><span class="pl-k">:</span>
                <span class="pl-k">var</span> err <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Oops:<span class="pl-pds">"</span></span>, err );
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
    }

    <span class="pl-c">// ..</span>
}</pre></div>

<p>Each state in our generator is represented by its own <code>case</code> in the <code>switch</code> statement. <code>process(..)</code> will be called each time we need to process a new state. We'll come back to how that works in just a moment.</p>

<p>For any generator-wide variable declarations (<code>val</code>), we move those to a <code>var</code> declaration outside of <code>process(..)</code> so they can survive multiple calls to <code>process(..)</code>. But the "block scoped" <code>err</code> variable is only needed for the <code>*3*</code> state, so we leave it in place.</p>

<p>In state <code>*1*</code>, instead of <code>yield request(..)</code>, we did <code>return request(..)</code>. In terminal state <code>*2*</code>, there was no explicit <code>return</code>, so we just do a <code>return;</code> which is the same as <code>return undefined</code>. In terminal state <code>*3*</code>, there was a <code>return false</code>, so we preserve that.</p>

<p>Now we need to define the code in the <em>iterator</em> functions so they call <code>process(..)</code> appropriately:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-c">// manage generator state</span>
    <span class="pl-k">var</span> state;

    <span class="pl-c">// generator-wide variable declarations</span>
    <span class="pl-k">var</span> val;

    <span class="pl-k">function</span> <span class="pl-en">process</span>(<span class="pl-smi">v</span>) {
        <span class="pl-k">switch</span> (state) {
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>requesting:<span class="pl-pds">"</span></span>, url );
                <span class="pl-k">return</span> request( url );
            <span class="pl-k">case</span> <span class="pl-c1">2</span><span class="pl-k">:</span>
                val <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
                <span class="pl-k">return</span>;
            <span class="pl-k">case</span> <span class="pl-c1">3</span><span class="pl-k">:</span>
                <span class="pl-k">var</span> err <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Oops:<span class="pl-pds">"</span></span>, err );
                <span class="pl-k">return</span> <span class="pl-c1">false</span>;
        }
    }

    <span class="pl-c">// make and return an iterator</span>
    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-c">// initial state</span>
            <span class="pl-k">if</span> (<span class="pl-k">!</span>state) {
                state <span class="pl-k">=</span> <span class="pl-c1">1</span>;
                <span class="pl-k">return</span> {
                    done<span class="pl-k">:</span> <span class="pl-c1">false</span>,
                    value<span class="pl-k">:</span> <span class="pl-c1">process</span>()
                };
            }
            <span class="pl-c">// yield resumed successfully</span>
            <span class="pl-k">else</span> <span class="pl-k">if</span> (state <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                state <span class="pl-k">=</span> <span class="pl-c1">2</span>;
                <span class="pl-k">return</span> {
                    done<span class="pl-k">:</span> <span class="pl-c1">true</span>,
                    value<span class="pl-k">:</span> <span class="pl-c1">process</span>( v )
                };
            }
            <span class="pl-c">// generator already completed</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">return</span> {
                    done<span class="pl-k">:</span> <span class="pl-c1">true</span>,
                    value<span class="pl-k">:</span> <span class="pl-c1">undefined</span>
                };
            }
        },
        <span class="pl-s"><span class="pl-pds">"</span><span class="pl-en">throw</span><span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">e</span>) {
            <span class="pl-c">// the only explicit error handling is in</span>
            <span class="pl-c">// state *1*</span>
            <span class="pl-k">if</span> (state <span class="pl-k">==</span> <span class="pl-c1">1</span>) {
                state <span class="pl-k">=</span> <span class="pl-c1">3</span>;
                <span class="pl-k">return</span> {
                    done<span class="pl-k">:</span> <span class="pl-c1">true</span>,
                    value<span class="pl-k">:</span> <span class="pl-c1">process</span>( e )
                };
            }
            <span class="pl-c">// otherwise, an error won't be handled,</span>
            <span class="pl-c">// so just throw it right back out</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> e;
            }
        }
    };
}</pre></div>

<p>How does this code work?</p>

<ol>
<li>The first call to the <em>iterator</em>'s <code>next()</code> call would move the generator from the unitialized state to state <code>1</code>, and then call <code>process()</code> to handle that state. The return value from <code>request(..)</code>, which is the promise for the Ajax response, is returned back as the <code>value</code> property from the <code>next()</code> call.</li>
<li>If the Ajax request succeeds, the second call to <code>next(..)</code> should send in the Ajax response value, which moves our state to <code>2</code>. <code>process(..)</code> is again called (this time with the passed in Ajax response value), and the <code>value</code> property returned from <code>next(..)</code> will be <code>undefined</code>.</li>
<li>However, if the Ajax request fails, <code>throw(..)</code> should be called with the error, which would move the state from <code>1</code> to <code>3</code> (instead of <code>2</code>). Again <code>process(..)</code> is called, this time with the error value. That <code>case</code> returns <code>false</code>, which is set as the <code>value</code> property returned from the <code>throw(..)</code> call.</li>
</ol>

<p>From the outside -- that is, interacting only with the <em>iterator</em> -- this <code>foo(..)</code> normal function works pretty much the same as the <code>*foo(..)</code> generator would have worked. So we've effectively "transpiled" our ES6 generator to pre-ES6 compatibility!</p>

<p>We could then manually instantiate our generator and control its iterator -- calling <code>var it = foo("..")</code> and <code>it.next(..)</code> and such -- or better, we could pass it to our previously defined <code>run(..)</code> utility as <code>run(foo,"..")</code>.</p>

<h3><a id="user-content-automatic-transpilation" class="anchor" href="#automatic-transpilation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Automatic Transpilation</h3>

<p>The preceding exercise of manually deriving a transformation of our ES6 generator to pre-ES6 equivalent teaches us how generators work conceptually. But that transformation was really intricate and very non-portable to other generators in our code. It would be quite impractical to do this work by hand, and would completely obviate all the benefit of generators.</p>

<p>But luckily, several tools already exist that can automatically convert ES6 generators to things like what we derived in the previous section. Not only do they do the heavy lifting work for us, but they also handle several complications that we glossed over.</p>

<p>One such tool is regenerator (<a href="https://facebook.github.io/regenerator/">https://facebook.github.io/regenerator/</a>), from the smart folks at Facebook.</p>

<p>If we use regenerator to transpile our previous generator, here's the code produced (at the time of this writing):</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `request(..)` is a Promise-aware Ajax utility</span>

<span class="pl-k">var</span> foo <span class="pl-k">=</span> regeneratorRuntime.mark(<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">var</span> val;

    <span class="pl-k">return</span> regeneratorRuntime.wrap(<span class="pl-k">function</span> <span class="pl-en">foo$</span>(<span class="pl-smi">context$1$0</span>) {
        <span class="pl-k">while</span> (<span class="pl-c1">1</span>) <span class="pl-k">switch</span> (context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.prev <span class="pl-k">=</span> context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.<span class="pl-c1">next</span>) {
        <span class="pl-k">case</span> <span class="pl-c1">0</span><span class="pl-k">:</span>
            context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.prev <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>requesting:<span class="pl-pds">"</span></span>, url );
            context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.<span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>;
            <span class="pl-k">return</span> request( url );
        <span class="pl-k">case</span> <span class="pl-c1">4</span><span class="pl-k">:</span>
            val <span class="pl-k">=</span> context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.sent;
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
            context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.<span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-c1">12</span>;
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> <span class="pl-c1">8</span><span class="pl-k">:</span>
            context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.prev <span class="pl-k">=</span> <span class="pl-c1">8</span>;
            context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.t0 <span class="pl-k">=</span> context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.catch(<span class="pl-c1">0</span>);
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Oops:<span class="pl-pds">"</span></span>, context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.t0);
            <span class="pl-k">return</span> context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.abrupt(<span class="pl-s"><span class="pl-pds">"</span>return<span class="pl-pds">"</span></span>, <span class="pl-c1">false</span>);
        <span class="pl-k">case</span> <span class="pl-c1">12</span><span class="pl-k">:</span>
        <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span><span class="pl-k">:</span>
            <span class="pl-k">return</span> context$<span class="pl-c1">1</span>$<span class="pl-c1">0</span>.<span class="pl-c1">stop</span>();
        }
    }, foo, <span class="pl-v">this</span>, [[<span class="pl-c1">0</span>, <span class="pl-c1">8</span>]]);
});</pre></div>

<p>There's some obvious similarities here to our manual derivation, such as the <code>switch</code> / <code>case</code> statements, and we even see <code>val</code> pulled out of the closure just as we did.</p>

<p>Of course, one trade-off is that regenerator's transpilation requires a helper library <code>regeneratorRuntime</code> that holds all the reusable logic for managing a general generator / <em>iterator</em>. A lot of that boilerplate looks different than our version, but even then, the concepts can be seen, like with <code>context$1$0.next = 4</code> keeping track of the next state for the generator.</p>

<p>The main takeaway is that generators are not restricted to only being useful in ES6+ environments. Once you understand the concepts, you can employ them throughout your code, and use tools to transform the code to be compatible with older environments.</p>

<p>This is more work than just using a <code>Promise</code> API polyfill for pre-ES6 Promises, but the effort is totally worth it, because generators are so much better at expressing async flow control in a reason-able, sensible, synchronous-looking, sequential fashion.</p>

<p>Once you get hooked on generators, you'll never want to go back to the hell of async spaghetti callbacks!</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Generators are a new ES6 function type that does not run-to-completion like normal functions. Instead, the generator can be paused in mid-completion (entirely preserving its state), and it can later be resumed from where it left off.</p>

<p>This pause/resume interchange is cooperative rather than preemptive, which means that the generator has the sole capability to pause itself, using the <code>yield</code> keyword, and yet the <em>iterator</em> that controls the generator has the sole capability (via <code>next(..)</code>) to resume the generator.</p>

<p>The <code>yield</code> / <code>next(..)</code> duality is not just a control mechanism, it's actually a two-way message passing mechanism. A <code>yield ..</code> expression essentially pauses waiting for a value, and the next <code>next(..)</code> call passes a value (or implicit <code>undefined</code>) back to that paused <code>yield</code> expression.</p>

<p>The key benefit of generators related to async flow control is that the code inside a generator expresses a sequence of steps for the task in a naturally sync/sequential fashion. The trick is that we essentially hide potential asynchrony behind the <code>yield</code> keyword -- moving the asynchrony to the code where the generator's <em>iterator</em> is controlled.</p>

<p>In other words, generators preserve a sequential, synchronous, blocking code pattern for async code, which lets our brains reason about the code much more naturally, addressing one of the two key drawbacks of callback-based async.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-async--performance" class="anchor" href="#you-dont-know-js-async--performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: Async &amp; Performance</h1>

<h1><a id="user-content-chapter-5-program-performance" class="anchor" href="#chapter-5-program-performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 5: Program Performance</h1>

<p>This book so far has been all about how to leverage asynchrony patterns more effectively. But we haven't directly addressed why asynchrony really matters to JS. The most obvious explicit reason is <strong>performance</strong>.</p>

<p>For example, if you have two Ajax requests to make, and they're independent, but you need to wait on them both to finish before doing the next task, you have two options for modeling that interaction: serial and concurrent.</p>

<p>You could make the first request and wait to start the second request until the first finishes. Or, as we've seen both with promises and generators, you could make both requests "in parallel," and express the "gate" to wait on both of them before moving on.</p>

<p>Clearly, the latter is usually going to be more performant than the former. And better performance generally leads to better user experience.</p>

<p>It's even possible that asynchrony (interleaved concurrency) can improve just the perception of performance, even if the overall program still takes the same amount of time to complete. User perception of performance is every bit -- if not more! -- as important as actual measurable performance.</p>

<p>We want to now move beyond localized asynchrony patterns to talk about some bigger picture performance details at the program level.</p>

<p><strong>Note:</strong> You may be wondering about micro-performance issues like if <code>a++</code> or <code>++a</code> is faster. We'll look at those sorts of performance details in the next chapter on "Benchmarking &amp; Tuning."</p>

<h2><a id="user-content-web-workers" class="anchor" href="#web-workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Web Workers</h2>

<p>If you have processing-intensive tasks but you don't want them to run on the main thread (which may slow down the browser/UI), you might have wished that JavaScript could operate in a multithreaded manner.</p>

<p>In Chapter 1, we talked in detail about how JavaScript is single threaded. And that's still true. But a single thread isn't the only way to organize the execution of your program.</p>

<p>Imagine splitting your program into two pieces, and running one of those pieces on the main UI thread, and running the other piece on an entirely separate thread.</p>

<p>What kinds of concerns would such an architecture bring up?</p>

<p>For one, you'd want to know if running on a separate thread meant that it ran in parallel (on systems with multiple CPUs/cores) such that a long-running process on that second thread would <strong>not</strong> block the main program thread. Otherwise, "virtual threading" wouldn't be of much benefit over what we already have in JS with async concurrency.</p>

<p>And you'd want to know if these two pieces of the program have access to the same shared scope/resources. If they do, then you have all the questions that multithreaded languages (Java, C++, etc.) deal with, such as needing cooperative or preemptive locking (mutexes, etc.). That's a lot of extra work, and shouldn't be undertaken lightly.</p>

<p>Alternatively, you'd want to know how these two pieces could "communicate" if they couldn't share scope/resources.</p>

<p>All these are great questions to consider as we explore a feature added to the web platform circa HTML5 called "Web Workers." This is a feature of the browser (aka host environment) and actually has almost nothing to do with the JS language itself. That is, JavaScript does not <em>currently</em> have any features that support threaded execution.</p>

<p>But an environment like your browser can easily provide multiple instances of the JavaScript engine, each on its own thread, and let you run a different program in each thread. Each of those separate threaded pieces of your program is called a "(Web) Worker." This type of parallelism is called "task parallelism," as the emphasis is on splitting up chunks of your program to run in parallel.</p>

<p>From your main JS program (or another Worker), you instantiate a Worker like so:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> w1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Worker</span>( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/mycoolworker.js<span class="pl-pds">"</span></span> );</pre></div>

<p>The URL should point to the location of a JS file (not an HTML page!) which is intended to be loaded into a Worker. The browser will then spin up a separate thread and let that file run as an independent program in that thread.</p>

<p><strong>Note:</strong> The kind of Worker created with such a URL is called a "Dedicated Worker." But instead of providing a URL to an external file, you can also create an "Inline Worker" by providing a Blob URL (another HTML5 feature); essentially it's an inline file stored in a single (binary) value. However, Blobs are beyond the scope of what we'll discuss here.</p>

<p>Workers do not share any scope or resources with each other or the main program -- that would bring all the nightmares of theaded programming to the forefront -- but instead have a basic event messaging mechanism connecting them.</p>

<p>The <code>w1</code> Worker object is an event listener and trigger, which lets you subscribe to events sent by the Worker as well as send events to the Worker.</p>

<p>Here's how to listen for events (actually, the fixed <code>"message"</code> event):</p>

<div class="highlight highlight-js"><pre>w1.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
    <span class="pl-c">// evt.data</span>
} );</pre></div>

<p>And you can send the <code>"message"</code> event to the Worker:</p>

<div class="highlight highlight-js"><pre>w1.postMessage( <span class="pl-s"><span class="pl-pds">"</span>something cool to say<span class="pl-pds">"</span></span> );</pre></div>

<p>Inside the Worker, the messaging is totally symmetrical:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// "mycoolworker.js"</span>

addEventListener( <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
    <span class="pl-c">// evt.data</span>
} );

postMessage( <span class="pl-s"><span class="pl-pds">"</span>a really cool reply<span class="pl-pds">"</span></span> );</pre></div>

<p>Notice that a dedicated Worker is in a one-to-one relationship with the program that created it. That is, the <code>"message"</code> event doesn't need any disambiguation here, because we're sure that it could only have come from this one-to-one relationship -- either it came from the Worker or the main page.</p>

<p>Usually the main page application creates the Workers, but a Worker can instantiate its own child Worker(s) -- known as subworkers -- as necessary. Sometimes this is useful to delegate such details to a sort of "master" Worker that spawns other Workers to process parts of a task. Unfortunately, at the time of this writing, Chrome still does not support subworkers, while Firefox does.</p>

<p>To kill a Worker immediately from the program that created it, call <code>terminate()</code> on the Worker object (like <code>w1</code> in the previous snippets). Abruptly terminating a Worker thread does not give it any chance to finish up its work or clean up any resources. It's akin to you closing a browser tab to kill a page.</p>

<p>If you have two or more pages (or multiple tabs with the same page!) in the browser that try to create a Worker from the same file URL, those will actually end up as completely separate Workers. Shortly, we'll discuss a way to "share" a Worker.</p>

<p><strong>Note:</strong> It may seem like a malicious or ignorant JS program could easily perform a denial-of-service attack on a system by spawning hundreds of Workers, seemingly each with their own thread. While it's true that it's somewhat of a guarantee that a Worker will end up on a separate thread, this guarantee is not unlimited. The system is free to decide how many actual threads/CPUs/cores it really wants to create. There's no way to predict or guarantee how many you'll have access to, though many people assume it's at least as many as the number of CPUs/cores available. I think the safest assumption is that there's at least one other thread besides the main UI thread, but that's about it.</p>

<h3><a id="user-content-worker-environment" class="anchor" href="#worker-environment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Worker Environment</h3>

<p>Inside the Worker, you do not have access to any of the main program's resources. That means you cannot access any of its global variables, nor can you access the page's DOM or other resources. Remember: it's a totally separate thread.</p>

<p>You can, however, perform network operations (Ajax, WebSockets) and set timers. Also, the Worker has access to its own copy of several important global variables/features, including <code>navigator</code>, <code>location</code>, <code>JSON</code>, and <code>applicationCache</code>.</p>

<p>You can also load extra JS scripts into your Worker, using <code>importScripts(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// inside the Worker</span>
importScripts( <span class="pl-s"><span class="pl-pds">"</span>foo.js<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar.js<span class="pl-pds">"</span></span> );</pre></div>

<p>These scripts are loaded synchronously, which means the <code>importScripts(..)</code> call will block the rest of the Worker's execution until the file(s) are finished loading and executing.</p>

<p><strong>Note:</strong> There have also been some discussions about exposing the <code>&lt;canvas&gt;</code> API to Workers, which combined with having canvases be Transferables (see the "Data Transfer" section), would allow Workers to perform more sophisticated off-thread graphics processing, which can be useful for high-performance gaming (WebGL) and other similar applications. Although this doesn't exist yet in any browsers, it's likely to happen in the near future.</p>

<p>What are some common uses for Web Workers?</p>

<ul>
<li>Processing intensive math calculations</li>
<li>Sorting large data sets</li>
<li>Data operations (compression, audio analysis, image pixel manipulations, etc.)</li>
<li>High-traffic network communications</li>
</ul>

<h3><a id="user-content-data-transfer" class="anchor" href="#data-transfer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Transfer</h3>

<p>You may notice a common characteristic of most of those uses, which is that they require a large amount of information to be transferred across the barrier between threads using the event mechanism, perhaps in both directions.</p>

<p>In the early days of Workers, serializing all data to a string value was the only option. In addition to the speed penalty of the two-way serializations, the other major negative was that the data was being copied, which meant a doubling of memory usage (and the subsequent churn of garbage collection).</p>

<p>Thankfully, we now have a few better options.</p>

<p>If you pass an object, a so-called "Structured Cloning Algorithm" (<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm">https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm</a>) is used to copy/duplicate the object on the other side. This algorithm is fairly sophisticated and can even handle duplicating objects with circular references. The to-string/from-string performance penalty is not paid, but we still have duplication of memory using this approach. There is support for this in IE10 and above, as well as all the other major browsers.</p>

<p>An even better option, especially for larger data sets, is "Transferable Objects" (<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast">http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast</a>). What happens is that the object's "ownership" is transferred, but the data itself is not moved. Once you transfer away an object to a Worker, it's empty or inaccessible in the originating location -- that eliminates the hazards of threaded programming over a shared scope. Of course, transfer of ownership can go in both directions.</p>

<p>There really isn't much you need to do to opt into a Transferable Object; any data structure that implements the Transferable interface (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable">https://developer.mozilla.org/en-US/docs/Web/API/Transferable</a>) will automatically be transferred this way (support Firefox &amp; Chrome).</p>

<p>For example, typed arrays like <code>Uint8Array</code> (see the <em>ES6 &amp; Beyond</em> title of this series) are "Transferables." This is how you'd send a Transferable Object using <code>postMessage(..)</code>:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// `foo` is a `Uint8Array` for instance</span>

postMessage( foo.buffer, [ foo.buffer ] );</pre></div>

<p>The first parameter is the raw buffer and the second parameter is a list of what to transfer.</p>

<p>Browsers that don't support Transferable Objects simply degrade to structured cloning, which means performance reduction rather than outright feature breakage.</p>

<h3><a id="user-content-shared-workers" class="anchor" href="#shared-workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shared Workers</h3>

<p>If your site or app allows for loading multiple tabs of the same page (a common feature), you may very well want to reduce the resource usage of their system by preventing duplicate dedicated Workers; the most common limited resource in this respect is a socket network connection, as browsers limit the number of simultaneous connections to a single host. Of course, limiting multiple connections from a client also eases your server resource requirements.</p>

<p>In this case, creating a single centralized Worker that all the page instances of your site or app can <em>share</em> is quite useful.</p>

<p>That's called a <code>SharedWorker</code>, which you create like so (support for this is limited to Firefox and Chrome):</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> w1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SharedWorker</span>( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1/mycoolworker.js<span class="pl-pds">"</span></span> );</pre></div>

<p>Because a shared Worker can be connected to or from more than one program instance or page on your site, the Worker needs a way to know which program a message comes from. This unique identification is called a "port" -- think network socket ports. So the calling program must use the <code>port</code> object of the Worker for communication:</p>

<div class="highlight highlight-js"><pre>w1.<span class="pl-c1">port</span>.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, handleMessages );

<span class="pl-c">// ..</span>

w1.<span class="pl-c1">port</span>.postMessage( <span class="pl-s"><span class="pl-pds">"</span>something cool<span class="pl-pds">"</span></span> );</pre></div>

<p>Also, the port connection must be initialized, as:</p>

<div class="highlight highlight-js"><pre>w1.<span class="pl-c1">port</span>.<span class="pl-c1">start</span>();</pre></div>

<p>Inside the shared Worker, an extra event must be handled: <code>"connect"</code>. This event provides the port <code>object</code> for that particular connection. The most convenient way to keep multiple connections separate is to use closure (see <em>Scope &amp; Closures</em> title of this series) over the <code>port</code>, as shown next, with the event listening and transmitting for that connection defined inside the handler for the <code>"connect"</code> event:</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// inside the shared Worker</span>
addEventListener( <span class="pl-s"><span class="pl-pds">"</span>connect<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
    <span class="pl-c">// the assigned port for this connection</span>
    <span class="pl-k">var</span> port <span class="pl-k">=</span> evt.ports[<span class="pl-c1">0</span>];

    port.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">evt</span>){
        <span class="pl-c">// ..</span>

        port.postMessage( .. );

        <span class="pl-c">// ..</span>
    } );

    <span class="pl-c">// initialize the port connection</span>
    port.<span class="pl-c1">start</span>();
} );</pre></div>

<p>Other than that difference, shared and dedicated Workers have the same capabilities and semantics.</p>

<p><strong>Note:</strong> Shared Workers survive the termination of a port connection if other port connections are still alive, whereas dedicated Workers are terminated whenever the connection to their initiating program is terminated.</p>

<h3><a id="user-content-polyfilling-web-workers" class="anchor" href="#polyfilling-web-workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polyfilling Web Workers</h3>

<p>Web Workers are very attractive performance-wise for running JS programs in parallel. However, you may be in a position where your code needs to run in older browsers that lack support. Because Workers are an API and not a syntax, they can be polyfilled, to an extent.</p>

<p>If a browser doesn't support Workers, there's simply no way to fake multithreading from the performance perspective. Iframes are commonly thought of to provide a parallel environment, but in all modern browsers they actually run on the same thread as the main page, so they're not sufficient for faking parallelism.</p>

<p>As we detailed in Chapter 1, JS's asynchronicity (not parallelism) comes from the event loop queue, so you can force faked Workers to be asynchronous using timers (<code>setTimeout(..)</code>, etc.). Then you just need to provide a polyfill for the Worker API. There are some listed here (<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers</a>), but frankly none of them look great.</p>

<p>I've written a sketch of a polyfill for <code>Worker</code> here (<a href="https://gist.github.com/getify/1b26accb1a09aa53ad25">https://gist.github.com/getify/1b26accb1a09aa53ad25</a>). It's basic, but it should get the job done for simple <code>Worker</code> support, given that the two-way messaging works correctly as well as <code>"onerror"</code> handling. You could probably also extend it with more features, such as <code>terminate()</code> or faked Shared Workers, as you see fit.</p>

<p><strong>Note:</strong> You can't fake synchronous blocking, so this polyfill just disallows use of <code>importScripts(..)</code>. Another option might have been to parse and transform the Worker's code (once Ajax loaded) to handle rewriting to some asynchronous form of an <code>importScripts(..)</code> polyfill, perhaps with a promise-aware interface.</p>

<h2><a id="user-content-simd" class="anchor" href="#simd" aria-hidden="true"><span class="octicon octicon-link"></span></a>SIMD</h2>

<p>Single instruction, multiple data (SIMD) is a form of "data parallelism," as contrasted to "task parallelism" with Web Workers, because the emphasis is not really on program logic chunks being parallelized, but rather multiple bits of data being processed in parallel.</p>

<p>With SIMD, threads don't provide the parallelism. Instead, modern CPUs provide SIMD capability with "vectors" of numbers -- think: type specialized arrays -- as well as instructions that can operate in parallel across all the numbers; these are low-level operations leveraging instruction-level parallelism.</p>

<p>The effort to expose SIMD capability to JavaScript is primarily spearheaded by Intel (<a href="https://01.org/node/1495">https://01.org/node/1495</a>), namely by Mohammad Haghighat (at the time of this writing), in cooperation with Firefox and Chrome teams. SIMD is on an early standards track with a good chance of making it into a future revision of JavaScript, likely in the ES7 timeframe.</p>

<p>SIMD JavaScript proposes to expose short vector types and APIs to JS code, which on those SIMD-enabled systems would map the operations directly through to the CPU equivalents, with fallback to non-parallelized operation "shims" on non-SIMD systems.</p>

<p>The performance benefits for data-intensive applications (signal analysis, matrix operations on graphics, etc.) with such parallel math processing are quite obvious!</p>

<p>Early proposal forms of the SIMD API at the time of this writing look like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> v1 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">3.14159</span>, <span class="pl-c1">21.0</span>, <span class="pl-c1">32.3</span>, <span class="pl-c1">55.55</span> );
<span class="pl-k">var</span> v2 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">2.1</span>, <span class="pl-c1">3.2</span>, <span class="pl-c1">4.3</span>, <span class="pl-c1">5.4</span> );

<span class="pl-k">var</span> v3 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.int32x4( <span class="pl-c1">10</span>, <span class="pl-c1">101</span>, <span class="pl-c1">1001</span>, <span class="pl-c1">10001</span> );
<span class="pl-k">var</span> v4 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.int32x4( <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">40</span> );

<span class="pl-c1">SIMD</span>.float32x4.mul( v1, v2 );   <span class="pl-c">// [ 6.597339, 67.2, 138.89, 299.97 ]</span>
<span class="pl-c1">SIMD</span>.int32x4.<span class="pl-c1">add</span>( v3, v4 );     <span class="pl-c">// [ 20, 121, 1031, 10041 ]</span></pre></div>

<p>Shown here are two different vector data types, 32-bit floating-point numbers and 32-bit integer numbers. You can see that these vectors are sized exactly to four 32-bit elements, as this matches the SIMD vector sizes (128-bit) available in most modern CPUs. It's also possible we may see an <code>x8</code> (or larger!) version of these APIs in the future.</p>

<p>Besides <code>mul()</code> and <code>add()</code>, many other operations are likely to be included, such as <code>sub()</code>, <code>div()</code>, <code>abs()</code>, <code>neg()</code>, <code>sqrt()</code>, <code>reciprocal()</code>, <code>reciprocalSqrt()</code> (arithmetic), <code>shuffle()</code> (rearrange vector elements), <code>and()</code>, <code>or()</code>, <code>xor()</code>, <code>not()</code> (logical), <code>equal()</code>, <code>greaterThan()</code>, <code>lessThan()</code> (comparison), <code>shiftLeft()</code>, <code>shiftRightLogical()</code>, <code>shiftRightArithmetic()</code> (shifts), <code>fromFloat32x4()</code>, and <code>fromInt32x4()</code> (conversions).</p>

<p><strong>Note:</strong> There's an official "prollyfill" (hopeful, expectant, future-leaning polyfill) for the SIMD functionality available (<a href="https://github.com/johnmccutchan/ecmascript_simd">https://github.com/johnmccutchan/ecmascript_simd</a>), which illustrates a lot more of the planned SIMD capability than we've illustrated in this section.</p>

<h2><a id="user-content-asmjs" class="anchor" href="#asmjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>asm.js</h2>

<p>"asm.js" (<a href="http://asmjs.org/">http://asmjs.org/</a>) is a label for a highly optimizable subset of the JavaScript language. By carefully avoiding certain mechanisms and patterns that are <em>hard</em> to optimize (garbage collection, coercion, etc.), asm.js-styled code can be recognized by the JS engine and given special attention with aggressive low-level optimizations.</p>

<p>Distinct from other program perfomance mechanisms discussed in this chapter, asm.js isn't necessarily something that needs to be adopted into the JS language specification. There <em>is</em> an asm.js specification (<a href="http://asmjs.org/spec/latest/">http://asmjs.org/spec/latest/</a>), but it's mostly for tracking an agreed upon set of candidate inferences for optimization rather than a set of requirements of JS engines.</p>

<p>There's not currently any new syntax being proposed. Instead, asm.js suggests ways to recognize existing standard JS syntax that conforms to the rules of asm.js and let engines implement their own optimizations accordingly.</p>

<p>There's been some disagreement between browser vendors over exactly how asm.js should be activated in a program. Early versions of the asm.js experiment required a <code>"use asm";</code> pragma (similar to strict mode's <code>"use strict";</code>) to help clue the JS engine to be looking for asm.js optimization opportunities and hints. Others have asserted that asm.js should just be a set of heuristics that engines automatically recognize without the author having to do anything extra, meaning that existing programs could theoretically benefit from asm.js-style optimizations without doing anything special.</p>

<h3><a id="user-content-how-to-optimize-with-asmjs" class="anchor" href="#how-to-optimize-with-asmjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to Optimize with asm.js</h3>

<p>The first thing to understand about asm.js optimizations is around types and coercion (see the <em>Types &amp; Grammar</em> title of this series). If the JS engine has to track multiple different types of values in a variable through various operations, so that it can handle coercions between types as necessary, that's a lot of extra work that keeps the program optimization suboptimal.</p>

<p><strong>Note:</strong> We're going to use asm.js-style code here for illustration purposes, but be aware that it's not commonly expected that you'll author such code by hand. asm.js is more intended to a compliation target from other tools, such as Emscripten (<a href="https://github.com/kripken/emscripten/wiki">https://github.com/kripken/emscripten/wiki</a>). It's of course possible to write your own asm.js code, but that's usually a bad idea because the code is very low level and managing it can be very time consuming and error prone. Nevertheless, there may be cases where you'd want to hand tweak your code for asm.js optimization purposes.</p>

<p>There are some "tricks" you can use to hint to an asm.js-aware JS engine what the intended type is for variables/operations, so that it can skip these coercion tracking steps.</p>

<p>For example:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// ..</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> a;</pre></div>

<p>In that program, the <code>b = a</code> assignment leaves the door open for type divergence in variables. However, it could instead be written as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// ..</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> a | <span class="pl-c1">0</span>;</pre></div>

<p>Here, we've used the <code>|</code> ("binary OR") with value <code>0</code>, which has no effect on the value other than to make sure it's a 32-bit integer. That code run in a normal JS engine works just fine, but when run in an asm.js-aware JS engine it <em>can</em> signal that <code>b</code> should always be treated as a 32-bit integer, so the coercion tracking can be skipped.</p>

<p>Similarly, the addition operation between two variables can be restricted to a more performant integer addition (instead of floating point):</p>

<div class="highlight highlight-js"><pre>(a <span class="pl-k">+</span> b) | <span class="pl-c1">0</span></pre></div>

<p>Again, the asm.js-aware JS engine can see that hint and infer that the <code>+</code> operation should be 32-bit integer addition because the end result of the whole expression would automatically be 32-bit integer conformed anyway.</p>

<h3><a id="user-content-asmjs-modules" class="anchor" href="#asmjs-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>asm.js Modules</h3>

<p>One of the biggest detractors to performance in JS is around memory allocation, garbage collection, and scope access. asm.js suggests one of the ways around these issues is to declare a more formalized asm.js "module" -- do not confuse these with ES6 modules; see the <em>ES6 &amp; Beyond</em> title of this series.</p>

<p>For an asm.js module, you need to explicitly pass in a tightly conformed namespace -- this is referred to in the spec as <code>stdlib</code>, as it should represent standard libraries needed -- to import necessary symbols, rather than just using globals via lexical scope. In the base case, the <code>window</code> object is an acceptable <code>stdlib</code> object for asm.js module purposes, but you could and perhaps should construct an even more restricted one.</p>

<p>You also must declare a "heap" -- which is just a fancy term for a reserved spot in memory where variables can already be used without asking for more memory or releasing previously used memory -- and pass that in, so that the asm.js module won't need to do anything that would cause memory churn; it can just use the pre-reserved space.</p>

<p>A "heap" is likely a typed <code>ArrayBuffer</code>, such as:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> heap <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">0x10000</span> );  <span class="pl-c">// 64k heap</span></pre></div>

<p>Using that pre-reserved 64k of binary space, an asm.js module can store and retrieve values in that buffer without any memory allocation or garbage collection penalties. For example, the <code>heap</code> buffer could be used inside the module to back an array of 64-bit float values like this:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Float64Array</span>( heap );</pre></div>

<p>OK, so let's make a quick, silly example of an asm.js-styled module to illustrate how these pieces fit together. We'll define a <code>foo(..)</code> that takes a start (<code>x</code>) and end (<code>y</code>) integer for a range, and calculates all the inner adjacent multiplications of the values in the range, and then finally averages those values together:</p>

<div class="highlight highlight-js"><pre><span class="pl-k">function</span> <span class="pl-en">fooASM</span>(<span class="pl-smi">stdlib</span>,<span class="pl-smi">foreign</span>,<span class="pl-smi">heap</span>) {
    <span class="pl-s"><span class="pl-pds">"</span>use asm<span class="pl-pds">"</span></span>;

    <span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">stdlib.Int32Array</span>( heap );

    <span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        x <span class="pl-k">=</span> x | <span class="pl-c1">0</span>;
        y <span class="pl-k">=</span> y | <span class="pl-c1">0</span>;

        <span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">var</span> sum <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">var</span> count <span class="pl-k">=</span> ((y|<span class="pl-c1">0</span>) <span class="pl-k">-</span> (x|<span class="pl-c1">0</span>)) | <span class="pl-c1">0</span>;

        <span class="pl-c">// calculate all the inner adjacent multiplications</span>
        <span class="pl-k">for</span> (i <span class="pl-k">=</span> x | <span class="pl-c1">0</span>;
            (i | <span class="pl-c1">0</span>) <span class="pl-k">&lt;</span> (y | <span class="pl-c1">0</span>);
            p <span class="pl-k">=</span> (p <span class="pl-k">+</span> <span class="pl-c1">8</span>) | <span class="pl-c1">0</span>, i <span class="pl-k">=</span> (i <span class="pl-k">+</span> <span class="pl-c1">1</span>) | <span class="pl-c1">0</span>
        ) {
            <span class="pl-c">// store result</span>
            arr[ p <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">3</span> ] <span class="pl-k">=</span> (i <span class="pl-k">*</span> (i <span class="pl-k">+</span> <span class="pl-c1">1</span>)) | <span class="pl-c1">0</span>;
        }

        <span class="pl-c">// calculate average of all intermediate values</span>
        <span class="pl-k">for</span> (i <span class="pl-k">=</span> <span class="pl-c1">0</span>, p <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            (i | <span class="pl-c1">0</span>) <span class="pl-k">&lt;</span> (count | <span class="pl-c1">0</span>);
            p <span class="pl-k">=</span> (p <span class="pl-k">+</span> <span class="pl-c1">8</span>) | <span class="pl-c1">0</span>, i <span class="pl-k">=</span> (i <span class="pl-k">+</span> <span class="pl-c1">1</span>) | <span class="pl-c1">0</span>
        ) {
            sum <span class="pl-k">=</span> (sum <span class="pl-k">+</span> arr[ p <span class="pl-k">&gt;&gt;</span> <span class="pl-c1">3</span> ]) | <span class="pl-c1">0</span>;
        }

        <span class="pl-k">return</span> <span class="pl-k">+</span>(sum <span class="pl-k">/</span> count);
    }

    <span class="pl-k">return</span> {
        foo<span class="pl-k">:</span> foo
    };
}

<span class="pl-k">var</span> heap <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">0x1000</span> );
<span class="pl-k">var</span> foo <span class="pl-k">=</span> fooASM( <span class="pl-c1">window</span>, <span class="pl-c1">null</span>, heap ).foo;

foo( <span class="pl-c1">10</span>, <span class="pl-c1">20</span> );      <span class="pl-c">// 233</span></pre></div>

<p><strong>Note:</strong> This asm.js example is hand authored for illustration purposes, so it doesn't represent the same code that would be produced from a compilation tool targeting asm.js. But it does show the typical nature of asm.js code, especially the type hinting and use of the <code>heap</code> buffer for temporary variable storage.</p>

<p>The first call to <code>fooASM(..)</code> is what sets up our asm.js module with its <code>heap</code> allocation. The result is a <code>foo(..)</code> function we can call as many times as necessary. Those <code>foo(..)</code> calls should be specially optimized by an asm.js-aware JS engine. Importantly, the preceding code is completely standard JS and would run just fine (without special optimization) in a non-asm.js engine.</p>

<p>Obviously, the nature of restrictions that make asm.js code so optimizable reduces the possible uses for such code significantly. asm.js won't necessarily be a general optimization set for any given JS program. Instead, it's intended to provide an optimized way of handling specialized tasks such as intensive math operations (e.g., those used in graphics processing for games).</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>The first four chapters of this book are based on the premise that async coding patterns give you the ability to write more performant code, which is generally a very important improvement. But async behavior only gets you so far, because it's still fundamentally bound to a single event loop thread.</p>

<p>So in this chapter we've covered several program-level mechanisms for improving performance even further.</p>

<p>Web Workers let you run a JS file (aka program) in a separate thread using async events to message between the threads. They're wonderful for offloading long-running or resource-intensive tasks to a different thread, leaving the main UI thread more resposive.</p>

<p>SIMD proposes to map CPU-level parallel math operations to JavaScript APIs for high-performance data-parallel operations, like number processing on large data sets.</p>

<p>Finally, asm.js describes a small subset of JavaScript that avoids the hard-to-optimize parts of JS (like garbage collection and coercion) and lets the JS engine recognize and run such code through aggressive optimizations. asm.js could be hand authored, but that's extremely tedious and error prone, akin to hand authoring assembly language (hence the name). Instead, the main intent is that asm.js would be a good target for cross-compilation from other highly optimized program languages -- for example, Emscripten (<a href="https://github.com/kripken/emscripten/wiki">https://github.com/kripken/emscripten/wiki</a>) transpiling C/C++ to JavaScript.</p>

<p>While not covered explicitly in this chapter, there are even more radical ideas under very early discussion for JavaScript, including approximations of direct threaded functionality (not just hidden behind data structure APIs). Whether that happens explicitly, or we just see more parallelism creep into JS behind the scenes, the future of more optimized program-level performance in JS looks really <em>promising</em>.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1 class="post_title">Fluent JavaScript  Three Different Kinds of Prototypal OO</h1>
		<div class="entry_post"> 

<p>In order to claim fluency in JavaScript, its important to understand how JavaScripts native inheritance capabilities work. This is an often neglected area of JavaScript writing and learning, but understanding it can be dramatically empowering.</p>
<p>JavaScript is one of the most expressive programming languages ever created. In particular, its combination of delegate prototypes, runtime object extension, and closures allow you to express three distinct types of prototypes in JavaScript. Lets take a closer look at each of these.</p>
<h3>Delegation / Differential Inheritance</h3>
<p>A delegate prototype is an object that serves as a base for another object. When you inherit from a delegate prototype, the new object gets a reference to the prototype. When you try to access a property on the new object, it checks the objects own properties first. If it doesnt find it there, it checks the prototype, and so on up the chain until it gets back to Object.prototype. </p>
<p>Method delegation is a fantastic way to preserve memory resources, because you only need one copy of each method to be shared by all instances. Its also a great way to add capabilities at runtime to all objects which share a particular prototype.</p>
<p>There are a couple of ways to set up that relationship in JavaScript. The one youre likely to see in a lot of books goes something like this:</p>
<p></p> 
<div id="crayon-5322c785749f8355214122" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; z-index: 0; overflow: hidden;">function Greeter(name) {
  this.name = name || 'John Doe';
}

Greeter.prototype.hello = function hello() {
  return 'Hello, my name is ' + this.name;
}

var george = new Greeter('George');</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">
<td class="crayon-nums " data-settings="show">
<div class="crayon-nums-content" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-num" data-line="crayon-5322c785749f8355214122-1">1</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c785749f8355214122-2">2</div><div class="crayon-num" data-line="crayon-5322c785749f8355214122-3">3</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c785749f8355214122-4">4</div><div class="crayon-num" data-line="crayon-5322c785749f8355214122-5">5</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c785749f8355214122-6">6</div><div class="crayon-num" data-line="crayon-5322c785749f8355214122-7">7</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c785749f8355214122-8">8</div><div class="crayon-num" data-line="crayon-5322c785749f8355214122-9">9</div></div>
</td>
<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c785749f8355214122-1"><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">Greeter</span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c785749f8355214122-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">name</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-i">name</span><span class="crayon-h"> </span><span class="crayon-o">||</span><span class="crayon-h"> </span><span class="crayon-s">'John Doe'</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c785749f8355214122-3"><span class="crayon-sy">}</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c785749f8355214122-4">&nbsp;</div><div class="crayon-line" id="crayon-5322c785749f8355214122-5"><span class="crayon-v">Greeter</span><span class="crayon-sy">.</span><span class="crayon-v">prototype</span><span class="crayon-sy">.</span><span class="crayon-v">hello</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">hello</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c785749f8355214122-6"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-s">'Hello, my name is '</span><span class="crayon-h"> </span><span class="crayon-o">+</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-i">name</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c785749f8355214122-7"><span class="crayon-sy">}</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c785749f8355214122-8">&nbsp;</div><div class="crayon-line" id="crayon-5322c785749f8355214122-9"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">george</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-r">new</span><span class="crayon-h"> </span><span class="crayon-e">Greeter</span><span class="crayon-sy">(</span><span class="crayon-s">'George'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>See <a href="http://ericleads.com/2013/01/javascript-constructor-functions-vs-factory-functions/">JavaScript Constructor Functions vs Factory Functions</a> and <a href="http://ericleads.com/2012/09/stop-using-constructor-functions-in-javascript/">Stop Using Constructor Functions in JavaScript</a> for my thoughts on why you should ignore this technique. I present it here only because its likely to be a familiar point of reference.</p>
<p>I prefer this:</p>
<p></p> 
<div id="crayon-5322c78574a06113052588" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; z-index: 0; overflow: hidden;">var proto = {
  hello: function hello() {
    return 'Hello, my name is ' + this.name;
  }
};

var george = Object.create(proto);
george.name = 'George';</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a06113052588-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">proto</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a06113052588-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-i">hello</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">hello</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a06113052588-3"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-s">'Hello, my name is '</span><span class="crayon-h"> </span><span class="crayon-o">+</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-i">name</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a06113052588-4"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div class="crayon-line" id="crayon-5322c78574a06113052588-5"><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a06113052588-6">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a06113052588-7"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">george</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">Object</span><span class="crayon-sy">.</span><span class="crayon-e">create</span><span class="crayon-sy">(</span><span class="crayon-i">proto</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a06113052588-8"><span class="crayon-v">george</span><span class="crayon-sy">.</span><span class="crayon-v">name</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-s">'George'</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>The one major drawback to delegation is that its not very good at storing state. In particular, if you try to store state as objects or arrays, mutating any member of the object or array will mutate the member for every instance that shares the prototype. In order to preserve instance safety, you need to make a copy of the state for each object.</p>
<h3>Cloning / Concatenative Inheritance / Mixins</h3>
<p>Prototype cloning is the process of copying the properties from one object to another, without retaining a reference between the two objects. Cloning a great way to store default state for objects. This process is commonly achieved by methods like Underscores <code>.extend()</code>, or jQuerys <code>.extend()</code>:</p>
<p></p> 
<div id="crayon-5322c78574a0d996602988" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; z-index: 0; overflow: hidden;">var proto = {
  hello: function hello() {
    return 'Hello, my name is ' + this.name;
  }
};

var george = _.extend({}, proto, {name: 'George'});</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a0d996602988-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">proto</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a0d996602988-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-i">hello</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">hello</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a0d996602988-3"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-s">'Hello, my name is '</span><span class="crayon-h"> </span><span class="crayon-o">+</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-i">name</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a0d996602988-4"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div class="crayon-line" id="crayon-5322c78574a0d996602988-5"><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a0d996602988-6">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a0d996602988-7"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">george</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-v">_</span><span class="crayon-sy">.</span><span class="crayon-e">extend</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">proto</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">'George'</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>Its common to see this style used for mixins. For example, Backbone users can make any object an event emitter by extending from Backbone.Events:</p>
<p></p> 
<div id="crayon-5322c78574a14444106027" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; z-index: 0; overflow: hidden;">var foo = _.extend({
  attrs: {},
  set: function (name, value) {
    this.attrs[name] = value;
    this.trigger('change', {
      name: name,
      value: value
    });
  },
  get: function (name) {
    return this.attrs[name];
  } 
}, Backbone.Events);</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a14444106027-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">foo</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-v">_</span><span class="crayon-sy">.</span><span class="crayon-e">extend</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-i">attrs</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-3"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-i">set</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">value</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-4"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">attrs</span><span class="crayon-sy">[</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-i">value</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-5"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-e">trigger</span><span class="crayon-sy">(</span><span class="crayon-s">'change'</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-6"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">name</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-7"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">value</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">value</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-8"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-9"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-10"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-i">get</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-11"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">attrs</span><span class="crayon-sy">[</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a14444106027-12"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-h"> </span></div><div class="crayon-line" id="crayon-5322c78574a14444106027-13"><span class="crayon-sy">}</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-v">Backbone</span><span class="crayon-sy">.</span><span class="crayon-i">Events</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<h3>Closure Prototypes / Functional Inheritance</h3>
<p>Im cheating on the name for this one. Its not really functional, and its not an <em>object prototype</em>. Its a <em>function prototype</em>. Think of it as an alternative to a constructor / init function. It can be copied (inherited) from one factory to another, and combined with other functions like it to completely replace the need for <code>super()</code> (which is a <a href="http://martinfowler.com/bliki/CallSuper.html">code smell</a>, and should be avoided).</p>
<p>Closure prototypes are functions that can be run against a target object in order to extend it. The primary advantage of this style is that it allows for encapsulation. In other words, you can enforce private state. Douglas Crockford called this style functional inheritance in his book, JavaScript: The Good Parts. It looks something like this (Foo, like above, with private attributes):</p>
<p></p> 
<div id="crayon-5322c78574a33794530363" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; z-index: 0; overflow: hidden;">var model = function () {
  var attrs = {};

  this.set = function (name, value) {
    attrs[name] = value;
    this.trigger('change', {
      name: name,
      value: value
    });
  };

  this.get = function (name, value) {
    return attrs[name];
  };

  _.extend(this, Backbone.Events);
};

model.call(george, 'Top secret');

george.on('change', function (e) { console.log(e); });

george.set('name', 'Sam'); // Object {name: "name", value: "Sam"}</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a33794530363-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">model</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">attrs</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-3">&nbsp;</div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-4"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">set</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">value</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-5"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">attrs</span><span class="crayon-sy">[</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-i">value</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-6"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-e">trigger</span><span class="crayon-sy">(</span><span class="crayon-s">'change'</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-7"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">name</span><span class="crayon-sy">,</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-8"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">value</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">value</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-9"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-10"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-11">&nbsp;</div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-12"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">get</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">value</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-13"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-v">attrs</span><span class="crayon-sy">[</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-14"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-15">&nbsp;</div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-16"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-v">_</span><span class="crayon-sy">.</span><span class="crayon-e">extend</span><span class="crayon-sy">(</span><span class="crayon-r">this</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-v">Backbone</span><span class="crayon-sy">.</span><span class="crayon-i">Events</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a33794530363-17"><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-18">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a33794530363-19"><span class="crayon-v">model</span><span class="crayon-sy">.</span><span class="crayon-e">call</span><span class="crayon-sy">(</span><span class="crayon-i">george</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-s">'Top secret'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-20">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a33794530363-21"><span class="crayon-v">george</span><span class="crayon-sy">.</span><span class="crayon-e">on</span><span class="crayon-sy">(</span><span class="crayon-s">'change'</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">e</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-h"> </span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">e</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a33794530363-22">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a33794530363-23"><span class="crayon-v">george</span><span class="crayon-sy">.</span><span class="crayon-e">set</span><span class="crayon-sy">(</span><span class="crayon-s">'name'</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-s">'Sam'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// Object {name: "name", value: "Sam"}</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>This is all well and good, but theres an awful lot of jumping through hoops if you want to combine the techniques  so I wrote a little library to jump through the hoops for you. Its called <a href="https://github.com/dilvie/stampit">Stampit</a>.</p>
<h2>Stampit</h2>
<p>Create objects from reusable, composable behaviors.</p>
<h3>Features</h3>
<li>Create functions (called factories) which stamp out new objects. All of the new objects inherit all of the prescribed behavior.</li>
<li>Compose factories together to create new factories.</li>
<li>Inherit methods and default state.</li>
<li>Supports composable private state and privileged methods.</li>
<li>State is cloned for each instance, so it wont be accidentally shared.</li>
<li>For the curious  its great for learning about prototypal OO. It mixes three major types of prototypes:
<ol>
<li>differential inheritance, aka delegation (for methods),</li>
<li>cloning, aka concatenation/exemplar prototypes (for state),</li>
<li>functional / closure prototypes (for privacy / encapsulation)</li>
</ol>
</li>
<h3>Whats the Point?</h3>
<p>Prototypal OO is great, and JavaScripts capabilities give us some really powerful tools to explore it, but it could be easier to use.</p>
<p>Basic questions like how do I inherit privileged methods and private data? and what are some good alternatives to inheritance hierarchies? are stumpers for many JavaScript users.</p>
<p>Lets answer both of these questions at the same time. First, well use a closure to create data privacy:</p>
<p></p> 
<div id="crayon-5322c78574a3b731499236" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; overflow: hidden; z-index: 0;">var a = stampit().enclose(function () {
  var a = 'a';
  this.getA = function () {
    return a;
  };
});</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a3b731499236-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">a</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">stampit</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">enclose</span><span class="crayon-sy">(</span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a3b731499236-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">a</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-s">'a'</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a3b731499236-3"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">getA</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a3b731499236-4"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-i">a</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a3b731499236-5"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a3b731499236-6"><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>It uses function scope to encapsulate private data. Note that the getter must be defined inside the function in order to access the closure variables.</p>
<p>Lets see if that worked:</p>
<p></p> 
<div id="crayon-5322c78574a42452072635" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; overflow: hidden; z-index: 0;">a(); // Object -- so far so good.
a().getA(); // "a"</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">
<td class="crayon-nums " data-settings="show">
<div class="crayon-nums-content" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-num" data-line="crayon-5322c78574a42452072635-1">1</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c78574a42452072635-2">2</div></div>
</td>
<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a42452072635-1"><span class="crayon-e">a</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// Object -- so far so good.</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a42452072635-2"><span class="crayon-e">a</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">getA</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// "a"</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>Yes. Got it. In both of these instances, we actually created a brand new object, and then immediately threw it away, because we didnt assign it to anything. Dont worry about that.</p>
<p>Heres another:</p>
<p></p> 
<div id="crayon-5322c78574a48751223046" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; overflow: hidden; z-index: 0;">var b = stampit().enclose(function () {
  var a = 'b';
  this.getB = function () {
    return a;
  };
});</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a48751223046-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">b</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">stampit</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">enclose</span><span class="crayon-sy">(</span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a48751223046-2"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">a</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-s">'b'</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a48751223046-3"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">getB</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a48751223046-4"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-i">a</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a48751223046-5"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a48751223046-6"><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>Those <code>a</code>s are not a typo. The point is to demonstrate that <code>a</code> and <code>b</code>s private variables wont clash.</p>
<p>But heres the real treat:</p>
<p></p> 
<div id="crayon-5322c78574a4e053417393" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; opacity: 0; overflow: hidden; z-index: 0;">var c = stampit.compose(a, b);

var foo = c(); // we won't throw this one away...

foo.getA(); // "a"
foo.getB(); // "b"</textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">
<td class="crayon-nums " data-settings="show">
<div class="crayon-nums-content" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-num" data-line="crayon-5322c78574a4e053417393-1">1</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c78574a4e053417393-2">2</div><div class="crayon-num" data-line="crayon-5322c78574a4e053417393-3">3</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c78574a4e053417393-4">4</div><div class="crayon-num" data-line="crayon-5322c78574a4e053417393-5">5</div><div class="crayon-num crayon-striped-num" data-line="crayon-5322c78574a4e053417393-6">6</div></div>
</td>
<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a4e053417393-1"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">c</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-v">stampit</span><span class="crayon-sy">.</span><span class="crayon-e">compose</span><span class="crayon-sy">(</span><span class="crayon-i">a</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">b</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a4e053417393-2">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a4e053417393-3"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">foo</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">c</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// we won't throw this one away...</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a4e053417393-4">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a4e053417393-5"><span class="crayon-v">foo</span><span class="crayon-sy">.</span><span class="crayon-e">getA</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// "a"</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a4e053417393-6"><span class="crayon-v">foo</span><span class="crayon-sy">.</span><span class="crayon-e">getB</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// "b"</span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
<p>WAT? Yeah. You just inherited privileged methods and private data from two sources at the same time.</p>
<p>But thats boring. Lets see what else is on tap:</p>
<p></p> 
<div id="crayon-5322c78574a54721715260" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover" style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 12px !important; line-height: 15px !important; height: auto;">
<div class="crayon-plain-wrap"><textarea wrap="soft" class="crayon-plain print-no" data-settings="dblclick" readonly="" style="tab-size: 2; font-size: 12px !important; line-height: 15px !important; z-index: 0; opacity: 0; overflow: hidden;">// Some more privileged methods, with some private data.
// Use stampit.extend() to make this feel declarative:
var availability = stampit().enclose(function () {
  var isOpen = false; // private

  return stampit.extend(this, {
    open: function open() {
      isOpen = true;
      return this;
    },
    close: function close() {
      isOpen = false;
      return this;
    },
    isOpen: function isOpenMethod() {
      return isOpen;
    }
  });
});

// Here's a mixin with public methods, and some state:
var membership = stampit({
    add: function (member) {
      this.members[member.name] = member;
      return this;
    },
    getMember: function (name) {
      return this.members[name];
    }
  },
  {
    members: {}
  });

// Let's set some defaults: 
var defaults = stampit().state({
        name: 'The Saloon',
        specials: 'Whisky, Gin, Tequila'
      });

// Classical inheritance has nothing on this. No parent/child coupling. No deep inheritance hierarchies.
// Just good, clean code reusability.
var bar = stampit.compose(defaults, availability, membership);

// Note that you can override state on instantiation:
var myBar = bar({name: 'Moe\'s'});

// Silly, but proves that everything is as it should be.
myBar.add({name: 'Homer' }).open().getMember('Homer'); </textarea></div>
<div class="crayon-main" style="position: relative; z-index: 1; overflow: hidden;">
<table class="crayon-table">
<tbody><tr class="crayon-row">

<td class="crayon-code"><div class="crayon-pre" style="font-size: 12px !important; line-height: 15px !important;"><div class="crayon-line" id="crayon-5322c78574a54721715260-1"><span class="crayon-c">// Some more privileged methods, with some private data.</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-2"><span class="crayon-c">// Use stampit.extend() to make this feel declarative:</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-3"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">availability</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">stampit</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">enclose</span><span class="crayon-sy">(</span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-4"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">isOpen</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">false</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-c">// private</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-5">&nbsp;</div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-6"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-v">stampit</span><span class="crayon-sy">.</span><span class="crayon-e">extend</span><span class="crayon-sy">(</span><span class="crayon-r">this</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-7"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">open</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">open</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-8"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">isOpen</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">true</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-9"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-10"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-11"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">close</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">close</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-12"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">isOpen</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">false</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-13"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-14"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-15"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">isOpen</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-e">isOpenMethod</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-16"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-i">isOpen</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-17"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-18"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-19"><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-20">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a54721715260-21"><span class="crayon-c">// Here's a mixin with public methods, and some state:</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-22"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">membership</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">stampit</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-23"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">add</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">member</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-24"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">members</span><span class="crayon-sy">[</span><span class="crayon-v">member</span><span class="crayon-sy">.</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-i">member</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-25"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-26"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-27"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">getMember</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">name</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-28"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">return</span><span class="crayon-h"> </span><span class="crayon-r">this</span><span class="crayon-sy">.</span><span class="crayon-v">members</span><span class="crayon-sy">[</span><span class="crayon-i">name</span><span class="crayon-sy">]</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-29"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-30"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">,</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-31"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">{</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-32"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">members</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-sy">}</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-33"><span class="crayon-h">&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-34">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a54721715260-35"><span class="crayon-c">// Let's set some defaults: </span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-36"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">defaults</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">stampit</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">state</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-37"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">'The Saloon'</span><span class="crayon-sy">,</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-38"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">specials</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">'Whisky, Gin, Tequila'</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-39"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-40">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a54721715260-41"><span class="crayon-c">// Classical inheritance has nothing on this. No parent/child coupling. No deep inheritance hierarchies.</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-42"><span class="crayon-c">// Just good, clean code reusability.</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-43"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">bar</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-v">stampit</span><span class="crayon-sy">.</span><span class="crayon-e">compose</span><span class="crayon-sy">(</span><span class="crayon-i">defaults</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">availability</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">membership</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-44">&nbsp;</div><div class="crayon-line" id="crayon-5322c78574a54721715260-45"><span class="crayon-c">// Note that you can override state on instantiation:</span></div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-46"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">myBar</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">bar</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">'Moe\'s'</span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-47">&nbsp;</div><div class="crayon-line crayon-striped-line" id="crayon-5322c78574a54721715260-48"><span class="crayon-c">// Silly, but proves that everything is as it should be.</span></div><div class="crayon-line" id="crayon-5322c78574a54721715260-49"><span class="crayon-v">myBar</span><span class="crayon-sy">.</span><span class="crayon-e">add</span><span class="crayon-sy">(</span><span class="crayon-sy">{</span><span class="crayon-i">name</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">'Homer'</span><span class="crayon-h"> </span><span class="crayon-sy">}</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">open</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">getMember</span><span class="crayon-sy">(</span><span class="crayon-s">'Homer'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span><span class="crayon-h"> </span></div></div></td>
</tr>
</tbody></table>
</div>
</div>
 
<p></p>
</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>A Touch of Class: Inheritance in JavaScript</h1>
<div class="entry-content"><p>The object-oriented features of JavaScript, such as constructors and prototype chains, are possibly the most misunderstood aspects of the language. Plenty of people who have been working full time with JavaScript still struggle with these concepts, and I argue that this is purely a result of its confusing, Java-style syntax.</p>

<p>But it doesnt have to be this way. Hiding beneath the new keyword is a rich and elegant object model, and well spend some time coming to grips with it.</p>

<p>By seeing how simple inheritance in JavaScript can be if we use more modern syntax, well be able to better understand the unfortunate syntax weve been stuck with from the beginning.</p>

<h2>JavaScripts lack of class</h2>

<p>The biggest act of misdirection in JavaScript is that it looks like it has <a href="http://en.wikipedia.org/wiki/Class_computer_programming">classes</a>. When someone is new to JavaScript, particularly if they come from another language that <em>does</em> have classes, they might be surprised to find code like this:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">var</span> <span class="nx">charlie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">();</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>Which leads to quite possibly the biggest surprise people face when trying to come to grips with JavaScript: it <em>doesnt</em> have classes. You might assume that elsewhere in the code is the class definition for Actor, but instead you find something like this:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">act</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">': '</span> <span class="o">+</span> <span class="nx">line</span><span class="p">);</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>From here it only gets worse when multiple inheritance is involved:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">canSpeak</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kd">function</span> <span class="nx">SilentActor</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">Actor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="nx">SilentActor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">();</span>
</span><span class="line"><span class="nx">SilentActor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">canSpeak</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>Sometimes despite years of experience, even those who realise that JavaScript doesnt have classes may still find themselves never quite grasping the concepts behind such cryptic syntax.</p>

<h2>Taking a step back</h2>

<p>To put these decisions in the proper historical context, we need to take a trip back to the year 1995. Java was the hot new web language, and <a href="http://sunsite.uakom.sk/sunworldonline/swol-07-1995/swol-07-java.html">Java applets were going to take over the world</a>.</p>

<p>We all know how this story ends, but this was the environment in which <a href="https://brendaneich.com/2010/07/a-brief-history-of-javascript/">Brendan Eich was toiling away at Netscape on his little web scripting langauge</a>.</p>

<p>This cultural pressure resulted in some rebranding. What was originally Mocha, then LiveScript, eventually became known as JavaScript. While it may have eventually extended beyond its original scope, Brendan Eich wasnt shy about pitching it as Javas little brother.</p>

<h2>Its just a prototype</h2>

<p>The problem, of course, is that despite JavaScripts syntactic similarities to Java, its conceptual roots lay elsewhere. A dynamically typed language, it borrowed functional aspects from <a href="http://en.wikipedia.org/wiki/Scheme_programming_language"><em>Scheme</em></a>, and prototypal inheritance from <a href="http://en.wikipedia.org/wiki/Self_programming_language"><em>Self</em></a>.</p>

<p>In classical languages, like Java, instances are created from classes. JavaScript differs in that it has <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototypal inheritance</a>, in which there are no classes.</p>

<p>Instead, <em>objects inherit from other objects</em>.</p>

<h2>Modern inheritance</h2>

<p>To best understand the concepts behind prototypal inheritance, you must unlearn what you have learned. Youll find it is much easier to appreciate object-to-object inheritance if you pretend youve never seen JavaScripts misleading, classically-styled syntax.</p>

<p>In ECMAScript 5, the latest version of JavaScript available in all modern browsers (Chrome, Firefox, Safari, Opera, IE9+), we have new syntax for creating object-to-object inheritance, based on <a href="http://javascript.crockford.com/prototypal.html">Douglas Crockfords original utility method for simple inheritance</a>:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">var</span> <span class="nx">childObject</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">parentObject</span><span class="p">);</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>If we use <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create"><em>Object.create</em></a> to recreate our <em>SilentActor</em> example from earlier, it becomes much easier to see whats really going on:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="c1">// Our 'actor' object has some properties...</span>
</span><span class="line"><span class="kd">var</span> <span class="nx">actor</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">  <span class="nx">canAct</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
</span><span class="line">  <span class="nx">canSpeak</span><span class="o">:</span> <span class="kc">true</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 'silentActor' inherits from 'actor'</span>
</span><span class="line"><span class="kd">var</span> <span class="nx">silentActor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">actor</span><span class="p">);</span>
</span><span class="line"><span class="nx">silentActor</span><span class="p">.</span><span class="nx">canSpeak</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 'busterKeaton' inherits from 'silentActor'</span>
</span><span class="line"><span class="kd">var</span> <span class="nx">busterKeaton</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">silentActor</span><span class="p">);</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>In modern browsers, we also have a <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf">new method for reliably inspecting the prototype chain</a>:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">busterKeaton</span><span class="p">);</span> <span class="c1">// silentActor</span>
</span><span class="line"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">silentActor</span><span class="p">);</span> <span class="c1">// actor</span>
</span><span class="line"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">actor</span><span class="p">);</span> <span class="c1">// Object</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>In this simple example, weve been able to set up a prototype chain without using a single constructor or new keyword.</p>

<h2>Walking the chain</h2>

<p>So how does a prototype chain work? When we try to read a property from our new <em>busterKeaton</em> object, it checks the object itself and, if it didnt find the property, it traverses up the prototype chain, checking each of its prototype objects in order until it finds the first occurence of the property.</p>

<p>All this happens when we ask for the value of a property from an object.</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="nx">busterKeaton</span><span class="p">.</span><span class="nx">canAct</span><span class="p">;</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>In order to properly evaluate the value of <em>canAct</em> on <em>busterKeaton</em>, the JS engine does the following:</p>

<ol>
<li>Checks <em>busterKeaton</em> for the <em>canAct</em> property, but finds nothing.</li>
<li>Checks <em>silentActor</em>, but doesnt find the <em>canAct</em> property.</li>
<li>Checks <em>actor</em> and finds the <em>canAct</em> property, so returns its value, which is true.</li>
</ol>


<h2>Modifying the chain</h2>

<p>The interesting thing is that the <em>actor</em> and <em>silentActor</em> objects are still live in the system and can be modified at runtime.</p>

<p>So, for a contrived example, if all silect actors lost their jobs, we could do the following:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="nx">silentActor</span><span class="p">.</span><span class="nx">isEmployed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// So now...</span>
</span><span class="line"><span class="nx">busterKeaton</span><span class="p">.</span><span class="nx">isEmployed</span><span class="p">;</span> <span class="c1">// false</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<h2>Wheres super?</h2>

<p>In classical languages, when overriding methods, you can run the method from the parent class in the current context.</p>

<p>In JavaScript we have even more options: <em>we can run any function in any context</em>.</p>

<p>How do we achieve this? Using JavaScripts <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call"><em>call</em></a> and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply"><em>apply</em></a> methods which are available on all functions. Appropiately enough, these are available because they exist on the Function prototype.</p>

<p>They both allow us to run a function in a specific context which we provide as the first parameter, along with any arguments we wish to pass to the function.</p>

<p>Using our <em>silentActor</em> example, if we want to achieve the equivalent of calling <em>super</em>, it looks something like this:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="nx">actor</span><span class="p">.</span><span class="nx">act</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">': '</span> <span class="o">+</span> <span class="nx">line</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="nx">silentActor</span><span class="p">.</span><span class="nx">act</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Super:</span>
</span><span class="line">    <span class="nx">actor</span><span class="p">.</span><span class="nx">act</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">line</span><span class="p">);</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>If it took multiple arguments, it would look like this:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="nx">silentActor</span><span class="p">.</span><span class="nx">act</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Using 'call':</span>
</span><span class="line">    <span class="nx">actor</span><span class="p">.</span><span class="nx">act</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Using 'apply':</span>
</span><span class="line">    <span class="nx">actor</span><span class="p">.</span><span class="nx">act</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">[</span><span class="nx">line</span><span class="p">,</span> <span class="nx">emotion</span><span class="p">]);</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<h2>Where are the constructors?</h2>

<p>With this setup, it is quite simple for us to create our own DIY constructor:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">makeActor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Create a new instance that inherits from 'actor':</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">actor</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Set the properties of our instance:</span>
</span><span class="line">    <span class="nx">a</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Return the new instance:</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<h2>Understanding prototypes with a touch of class</h2>

<p>Now that weve seen how simple object-to-object inheritance can be, its time to look at our original example again with fresh eyes:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">var</span> <span class="nx">charlie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">();</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p><em>Actor</em> is, obviously, not a class. It is, however, a function.</p>

<p>It could be a function that does nothing:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>Or, it could set some properties on the new instance:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>In our example, the <em>Actor</em> function is being used as a constructor since it is invoked with the new keyword.</p>

<p>The funny thing about JavaScript is that <em>any</em> function can be used as a constructor, so theres nothing special about our <em>Actor</em> function that makes it different from any other function.</p>

<h2>Clarifying constructors</h2>

<p>Since any function can be a constructor, all functions have a <em>prototype</em> property just in case theyre used as a constructor. Even when it doesnt make sense.</p>

<p>A perfect example is the <a href="https://developer.mozilla.org/en-US/docs/DOM/window.alert"><em>alert</em></a> function, which is provided by the browser. Even though its not meant to be used as a constructor (in fact, the browser wont even let you), it still has a <em>prototype</em> property:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="k">typeof</span> <span class="nx">alert</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// 'object'</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="nx">alert</span><span class="p">();</span> <span class="c1">// TypeError: Illegal invocation</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>When <em>Actor</em> is used as a constructor, our new <em>charlie</em> object inherits from the object sitting at <em>Actor.prototype</em>.</p>

<h2>Functions are objects</h2>

<p>If you missed that, let me re-iterate. <em><a href="http://my.safaribooksonline.com/book/programming/javascript/9780596517748/functions/function_objects">Functions are objects</a>, and can have arbitrary properties</em>.</p>

<p>For example, this is completely valid:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">(){}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// We can set any property:</span>
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">abc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>However, the <em>prototype</em> property of a function is where we store the object that all new instances will inherit from:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">(){}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Used for constructors:</span>
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span><span class="nx">foo</span><span class="o">:</span> <span class="s1">'bar'</span><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="kd">var</span> <span class="nx">charlie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">();</span>
</span><span class="line"><span class="nx">charile</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span> <span class="c1">// 'bar'</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<h2>Creating the chain</h2>

<p>Setting up multiple inheritance with our class-like syntax should now be a bit easier to grasp.</p>

<p>Its simply a case of making a functions <em>prototype</em> property inherit from another functions <em>prototype</em>:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="c1">// Set up Actor</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">Actor</span><span class="p">()</span> <span class="p">{}</span>
</span><span class="line"><span class="nx">Actor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">canAct</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Set up SilentActor to inherit from Actor:</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">SilentActor</span><span class="p">()</span> <span class="p">{}</span>
</span><span class="line"><span class="nx">SilentActor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Actor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="c1">// We can now add new properties to the SilentActor prototype:</span>
</span><span class="line"><span class="nx">SilentActor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">canSpeak</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// So instances can act, but can't speak:</span>
</span><span class="line"><span class="kd">var</span> <span class="nx">charlie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SilentActor</span><span class="p">();</span>
</span><span class="line"><span class="nx">charlie</span><span class="p">.</span><span class="nx">canAct</span><span class="p">;</span> <span class="c1">// true</span>
</span><span class="line"><span class="nx">charlie</span><span class="p">.</span><span class="nx">canSpeak</span><span class="p">;</span> <span class="c1">// false</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<h2>Construction: Just 3 simple steps</h2>

<p>At this point, its important to point out whats going on inside a constructor. Instantiating a new object with a constructor performs three actions and, as an example, lets take a look at what happens with our <em>Actor</em> constructor:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">var</span> <span class="nx">charlie</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Actor</span><span class="p">();</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>This one line of the code does the following:</p>

<ol>
<li>Creates a new object, <em>charlie</em>, that inherits from the object sitting at <em>Actor.prototype</em>,</li>
<li>Runs the <em>Actor</em> function against <em>charlie</em>, and</li>
<li>Returns <em>charlie</em>.</li>
</ol>


<h2>Coming full circle</h2>

<p>You might think that this sounds awfully familiar because this precisely mirrors the steps in our DIY constructor from earlier, which looked like this:</p>

<figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tbody><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="js"><span class="line"><span class="kd">function</span> <span class="nx">makeActor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Create a new instance that inherits from 'actor':</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">actor</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Set the properties of our instance:</span>
</span><span class="line">    <span class="nx">a</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Return the new instance:</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>Just like our earlier example, asking our <em>busterKeaton</em> object for the <em>canAct</em> property will walk up the prototype chain, except this time the JS engine will act slightly differently:</p>

<ol>
<li>Checks <em>busterKeaton</em> for the <em>canAct</em> property, but finds nothing.</li>
<li>Checks <em>SilentActor.prototype</em>, but doesnt find the <em>canAct</em> property.</li>
<li>Checks <em>Actor.prototype</em> and finds the <em>canAct</em> property, so returns its value.</li>
</ol>


<p>Youll notice that the chain now consists of objects sitting at the <em>prototype</em> property of functions, each of which had been used as the objects constructor.</p>

<h2>Keeping it classic</h2>

<p>Even after understanding the syntax, its still common for people to want to get as far away from it as possible.</p>

<p>There are implementations of classical inheritance built on top of JavaScripts prototypal inhertance, the most notable of which is <a href="http://ejohn.org/blog/simple-javascript-inheritance/">John Resigs famous Class function</a>.</p>

<p>Youll also find a lot of languages that compile to JavaScript, such as <a href="http://coffeescript.org/">CoffeeScript</a> or <a href="http://www.typescriptlang.org/">TypeScript</a>, offer standard class syntax. TypeScript in particular ensures it closely resembles the <a href="http://wiki.ecmascript.org/doku.php?id=harmony:classes">draft ECMAScript 6 class specification</a>.</p>

<p>Yes, the ES6 specification draft contains class sugar which, like CoffeeScript and TypeScript, is really prototypal inheritance under the hood.</p>

<h2>Clearing the air</h2>

<p>Of course none of the classical misdirection and shim layers can really replace a true understanding of prototypal inheritance and the power it affords you.</p>

<p>Hopefully this article has helped clear things up for you and, if you still find yourself puzzled, I hope at the very least that the next time you dig into prototypal inheritance, your mind will have been sufficiently prepared for thinking like Brendan Eich did all those years ago.</p>

<p>If not, theres always Java applets.</p>

<h3>Slides from Web Directions South 2012</h3>

<p>This article is based on a presentation I gave on 18 October, 2012 at <a href="http://south12.webdirections.org/">Web Directions South</a> in Sydney, Australia. The <a href="http://markdalgleish.com/presentations/atouchofclass">slides are available online</a>.</p>
</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
	</body>
</html>