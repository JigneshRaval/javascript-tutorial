<html><head>
		<meta charset="utf-8">
		<title>Javascript Book :: Part 4</title>
		<meta name="title" content="">
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!--<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>-->
		<link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i|PT+Serif:400,700" rel="stylesheet">
		<style>
			* { box-sizing: border-box; }
			body { 
			font-family: 'Open Sans', Arial, sans-serif;
			font-size: 14px;
			line-height: 1.7;
			padding: 0.5em;
			font-family: 'PT Sans', Arial, sans-serif;
			
			}
			img { display: block; margin: 0 auto; max-width: 100%; }
			pre { 
			border: 1px dashed #333; 
			padding: 1em 2em; 
			font-family: Consolas,monospace; 
			background-color: #EEE; 
			overflow-x: scroll; 
			font-size: 14px;  
			white-space: pre-wrap; 
			word-wrap: break-word; 
			}
			pre {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    margin: 1em auto;
    border: 1px dashed #333;
    width: 100%;
    padding: 1em 1.5em;
    font-family: Inconsolata, Consolas, monospace, sans-serif;
    font-size: 1em;
	line-height: 1.5;
    overflow: auto;
    background: #F7FAFB;
    border-radius: 3px;
	position:relative;
}
			code { background-color: #EEE; padding: 3px; font-family: Consolas,monospace; }
			pre code { background-color: transparent; padding: 0; display: block; }
			
			pre:after {
				content: "<CODE>";
				position: absolute;
				top:0;
				right: 0;
				padding: 5px 15px;
				background: #999;
				color: #FFF;
			}
			
			.tutorial-index {
			counter-reset: section;
			}
			.tutorial-index h1:before {
    counter-increment: section;
    content: "(" counter(section) ") ";
}
.tutorial-index h1 {font-size: 1.2em; padding: 5px 0; font-family: 'Open Sans', Arial, sans-serif; line-height: normal;}
			.tutorial-index a { text-decoration: none; }
			.tutorial-index a { display: block; float: left; width: 50%; }
			h1 { font-size: 1.6em; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			
			.main { counter-reset: mainsection; }
			.main h1 { font-size: 1.6em; border-bottom: 2px solid #000; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			/*.main h1:before {
    counter-increment: mainsection;
    content: counter(mainsection) " : ";
}*/
			
			
			
			h2, h3, h6 { 
			font-size: 1.2em;
			font-family: 'PT Serif', Arial, serif;
			padding-left: 1em;
			border-left: 2px solid #868686; 
			}
			.cf:before,
.cf:after {
    content: " ";
    display: table;
}
.cf:after {
    clear: both;
}
table { border-collapse: collapse;}
table td { border: 1px solid #999; padding: 5px;}

@media print {
    .main h1 {page-break-before: always;}
}
.tc { text-align: center}
.home-screen { border: 1px solid #777; padding: 4em 0; }
.home-screen * {    font-family: 'PT Sans', Arial, sans-serif;
    font-size: 3em;
    font-weight: normal;}
		</style>
	</head>
	<body>
		<div class="home-screen tc">
			<h1>JavaScript Tutorials</h1>
			<h4>- Part 4 -</h4>
		</div>
		<!--================= START :: Tutorial Index =================-->
<div class="tutorial-index cf">
	<a href="#t-01"><h1>Functional Concepts For JavaScript Developers: Currying</h1></a>
	<a href="#t-02"><h1>Currying vs partial application</h1></a>
	<a href="#t-03"><h1>Binding objects to functions</h1></a>
	<a href="#t-04"><h1>Currying vs Partial Application</h1></a>
	<a href="#t-05"><h1>What's the difference between Currying and Partial Application?</h1></a>
	<a href="#t-06"><h1>Approaches to currying in JavaScript</h1></a>
	<a href="#t-07"><h1>7 Essential JavaScript Functions</h1></a>
	<a href="#t-08"><h1>Collection of useful JavaScript functions and patterns</h1></a>
	<a href="#t-09"><h1>My todays top 10 most useful Javascript Functions</h1></a>
	<a href="#t-10"><h1>12 Extremely Useful Hacks for JavaScript</h1></a>
	<a href="#t-11"><h1>45 Useful JavaScript Tips, Tricks and Best Practices</h1></a>
	<a href="#t-12"><h1>JavaScript Architecture for the 23rd Century</h1></a>
	<a href="#t-13"><h1>9 New Array Functions in ES6</h1></a>
	<a href="#t-14"><h1>Implementing EventEmitter in ES6</h1></a>
	<a href="#t-15"><h1>Getting Functional with Javascript (Part 1)</h1></a>
	<a href="#t-16"><h1>Getting Functional with Javascript (Part 2)</h1></a>
	<a href="#t-17"><h1>Understanding Prototypes, Delegation &amp; Composition</h1></a>
	<a href="#t-18"><h1>Some jQuery Functions And Their JavaScript Equivalents</h1></a>
	<a href="#t-19"><h1>Is everything in JavaScript an Object?</h1></a>
	<a href="#t-20"><h1>Partial Application with Function#bind</h1></a>
	<a href="#t-21"><h1>Partial Application in JavaScript</h1></a>
	<a href="#t-22"><h1>Composing Functions in JavaScript</h1></a>
	<a href="#t-23"><h1>A JavaScript Invoke Function</h1></a>
	<a href="#t-24"><h1>YOU MIGHT NOT NEED JQUERY</h1></a>
	<a href="#t-25"><h1>The JavaScript Bind Function</h1></a>
	<a href="#t-26"><h1>Forcing Function Arity in JavaScript</h1></a>
	<a href="#t-27"><h1>Wrapping JavaScript Functions</h1></a>
	<a href="#t-28"><h1>Javascript : Basic Scope</h1></a>
	<a href="#t-29"><h1>Part 2 : Functions</h1></a>
	<a href="#t-30"><h1>Part 3 : .map, .reduce &amp; .filter, Oh My!</h1></a>
	<a href="#t-31"><h1>Part 4 : Object-ively Javascript</h1></a>
	<a href="#t-32"><h1>Chapter 4: Currying</h1></a>
	<a href="#t-33"><h1>Chapter 5: Coding by Composing</h1></a>
	<a href="#t-34"><h1>Functional Mixins in ECMAScript 2015</h1></a>
	<a href="#t-35"><h1>JavaScript Mixins, Subclass Factories, and Method Advice</h1></a>
	<a href="#t-36"><h1>Compose me That: Function Composition in JavaScript</h1></a>
	<a href="#t-37"><h1>Curry me This: Partial Application in JavaScript</h1></a>
	<a href="#t-38"><h1>Functional Data Structures in JavaScript: The Basics</h1></a>
	<a href="#t-39"><h1>Model-View-Controller (MVC) with JavaScript</h1></a>
	<a href="#t-40"><h1>JavaScript Function Memoization</h1></a>
	<a href="#t-41"><h1>Javascript Memoization</h1></a>
	<a href="#t-42"><h1>Hello World : A "Hello World"-like example of Javascript using the MVC pattern.</h1></a>
	<a href="#t-43"><h1>JavaScript's Magical Tips Every Developer Should Remember</h1></a>
	<a href="#t-44"><h1>5 Features You Can Use in ES6 Today</h1></a>
	<a href="#t-45"><h1>Asynchronous in the Browser</h1></a>
	<a href="#t-46"><h1>The Basics of DOM Manipulation in Vanilla JavaScript (No jQuery)</h1></a>
	<a href="#t-47"><h1>Functional Programming Jargon</h1></a>
	<a href="#t-48"><h1>ES6 Object Destructuring</h1></a>
	<a href="#t-49"><h1>49 : ECMAScript 6 equivalents in ES5</h1></a>
	<a href="#t-50"><h1>50 : JavaScript Inheritance Done Right</h1></a>
	<a href="#t-51"><h1>51 : Javascript Inheritance Done Right</h1></a>
	<a href="#t-52"><h1>52 : Basic Inheritance with JavaScript Constructors</h1></a>
	<a href="#t-53"><h1>53 : Call and Apply for Beginners</h1></a>
	<a href="#t-54"><h1>54 : Understanding JavaScript Constructors</h1></a>
	<a href="#t-56"><h1>55 : Functions as First Class Citizens in Javascript</h1></a>
	<a href="#t-56"><h1>56 : Quick Tip: How JavaScript References Work</h1></a>
</div>
		<!--================= END :: Tutorial Index =================-->
		
		<main class="main">
			
			<section class="section__one">
			
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t01" name="t01"></a><h1>01 : Functional Concepts For JavaScript Developers: Currying</h1>
					<div class="tutorial__content">
<span>https://blog.simpleblend.net/functional-javascript-concepts-currying/</span>
<p>Before I understood the concept of currying, I was always filled with anxiety when hearing other developers describe it. They always made it seem so complicated and difficult to understand; as if an ominous thundercloud arrived every time the topic was mentioned. Well I assure you that the concept of currying, at least applied to programming, is not hard to understand at all. It's actually quite easy to grasp and once you do, opens the door to a powerful functional programming technique.</p>
<h2>The Core Idea</h2>
<p>Let's first start with a definition from the great book by <a href="https://twitter.com/drboolean">Brian Lonsdorf</a></p>
<blockquote><p>"The concept is simple: You can call a function with fewer arguments than it expects. It returns a function that takes the remaining arguments."</p></blockquote>
<p>In other words, a curry function takes and provides additional arguments over time. It does this by returning additional functions to do the work for us.<span class="citation-num" data-citation-num="1">1</span> In order to see how this works, let's take a normal function and curry it.</p>
<pre><code class="language-javascript">var add = function(x, y) {
  return x + y;
}

add(10, 20); // 30
</code></pre>
<p>Here we have a function that takes two numbers and returns the sum. Simple. Let's curry it.</p>
<pre><code class="language-javascript">var add = function(x) {
  return function(y) {
    return x + y;
  }
}

var addFifty = add(50);

addFifty(10); // 60
</code></pre>
<p>Instead of returning the immediate result, we're returning a function that acts as a closure over variable x. This allows us to keep a reference to that value when we execute the returned function <b>addFifty</b> at a later time. Finally, our returned function provides us with the summation of both numbers. In this example we would say the add function is "curried".</p>
<h2>Why is Currying useful?</h2>
<p>Curry functions are useful for many reasons. From a functional programming perspective, they allow your program to become "pure". I'll be writing more about pure functions at a later time but suffice it to say for now, pure functions allow your application to be better understood by yourself and other team members.</p>
<p>A more applicable reason can be shown by demonstrating a less contrived example. While adding two numbers together is great for explaining a new concept, it doesn't immediately highlight the enormous benefits of using it within the context of a larger application. Let's do that now.</p>
<p>Let's assume we're working with a list of animals like the below:</p>
<pre><code class="language-javascript">const animals = [
  {
    id: 1,
    name: "Tails",
    type: "Cat",
    adoptable: false
  },
  {
    id: 2,
    name: "Soul",
    type: "Cat",
    adoptable: true
  },
  {
    id: 3,
    name: "Fred",
    type: "Dog",
    adoptable: true
  },
  {
    id: 4,
    name: "Fury",
    type: "Lion",
    adoptable: true
  }
];
</code></pre>
<p>We need a way to filter down these animals based on type. We could do something like this:</p>
<pre><code class="language-javascript">animals.filter(animal =&gt;
   animal.type === "Cat"
);

/*
[{
   adoptable: false,
   id: 1,
   name: "Tails",
   type: "Cat"
 },
 {
   adoptable: true,
   id: 2,
   name: "Soul",
   type: "Cat"
 }];
*/
</code></pre>
<p>Looks pretty good. This grabs all of the cats in the list. However there's a better way to write the same thing.</p>
<p>One major drawback to the above code is that the <em>type</em> of animal is tightly coupled to <em>the act filtering itself</em>. This prevents reusability and encourages the cultivation of our worst enemy: state.</p>
<p>Let's see if we can do better.</p>
<pre><code class="language-javascript">const isAnimal = 
   type =&gt; 
     animal =&gt;
       animal.type === type

animals.filter(isAnimal("Cat"));
 
/*
 [{
   adoptable: false,
   id: 1,
   name: "Tails",
   type: "Cat"
 },
 {
   adoptable: true,
   id: 2,
   name: "Soul",
   type: "Cat"
 }];
 */
</code></pre>
<p>Much cleaner. Let's break this down into steps.</p>
<ul>
<li>isAnimal expects one argument, the type</li>
<li>isAnimal then returns a whole new function</li>
<li>The returned function is used as the callback to .filter()</li>
<li>Closure then allows our returned function to access the <strong>type</strong> variable which finally allows us to perform our equality comparison</li>
</ul>
<p>Again, why is this better than the previous example? As an application grows in size, it becomes harder to understand what functions are doing what and where they're coming from within the codebase. Striving to write pure functions like in our solution eliminates the state chase, and makes our entire app more testable by breaking things into single responsibilities.</p>
<h2>Conclusion &amp; Resources</h2>
<p>I hope this inspired you to see the powerful nature behind curry functions. I've personally found them very useful and really inspired me to learn more about functional programming concepts.</p>
<p>If you're interested in further learning, I encourage you to checkout functional libraries like <a href="http://ramdajs.com/0.21.0/docs/#curry">Ramda.js</a> or <a href="https://lodash.com/docs#curry">lodash</a> which contain general curry functions that can help build some really exciting functionality.</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t02" name="t02"></a><h1>02 : Currying vs partial application</h1>
					<span>http://www.jstips.co/en/javascript/curry-vs-partial-application/</span>
					<div class="tutorial__content">


<div class="post-content" itemprop="articleBody">
    <p><strong>Currying</strong></p>

<p>Currying takes a function</p>

<p>f: X * Y -&gt; R</p>

<p>and turns it into a function</p>

<p>f': X -&gt; (Y -&gt; R)</p>

<p>Instead of calling f with two arguments, we invoke f' with the first argument. The result is a function that we then call with the second argument to produce the result.</p>

<p>Thus, if the uncurried f is invoked as</p>

<p>f(3,5)</p>

<p>then the curried f' is invoked as</p>

<p>f(3)(5)</p>

<p>For example:
Uncurried add()</p>

<div class="language-javascript highlighter-rouge"><pre><code>
function add(x, y) {
  return x + y;
}

add(3, 5);   // returns 8
</code></pre>
</div>

<p>Curried add()</p>

<div class="language-javascript highlighter-rouge"><pre><code>function addC(x) {
  return function (y) {
    return x + y;
  }
}

addC(3)(5);   // returns 8
</code></pre>
</div>

<p><strong>The algorithm for currying.</strong></p>

<p>Curry takes a binary function and returns a unary function that returns a unary function.</p>

<p>curry: (X × Y → R) → (X → (Y → R))</p>

<p>Javascript Code:</p>

<div class="language-javascript highlighter-rouge"><pre><code>function curry(f) {
  return function(x) {
    return function(y) {
      return f(x, y);
    }
  }
}
</code></pre>
</div>

<p><strong>Partial application</strong></p>

<p>Partial application takes a function</p>

<p>f: X * Y -&gt; R</p>

<p>and a fixed value for the first argument to produce a new function</p>

<p>f`: Y -&gt; R</p>

<p>f' does the same as f, but only has to fill in the second parameter which is why its arity is one less than the arity of f.</p>

<p>For example: Binding the first argument of function add to 5 produces the function plus5.</p>

<div class="language-javascript highlighter-rouge"><pre><code>function plus5(y) {
  return 5 + y;
}

plus5(3);  // returns 8
</code></pre>
</div>

<p><strong>The algorithm of partial application.</strong>*</p>

<p>partApply takes a binary function and a value and produces a unary function.</p>

<p>partApply : ((X × Y → R) × X) → (Y → R)</p>

<p>Javascript Code:</p>

<div class="language-javascript highlighter-rouge"><pre><code>function partApply(f, x) {
  return function(y) {
    return f(x, y);
  }
}
</code></pre>
</div>

    
  </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t03" name="t03"></a><h1>03 : Binding objects to functions</h1>
					<span>http://www.jstips.co/en/javascript/binding-objects-to-functions/</span>
					<div class="tutorial__content">


<div class="post-content" itemprop="articleBody">
    <p>More than often, we need to bind an object to a function's this object. JS uses the bind method when this is specified explicitly and we need to invoke desired method.</p>

<h3 id="bind-syntax">Bind syntax</h3>

<div class="language-js highlighter-rouge"><pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
</div>

<h2 id="parameters">Parameters</h2>
<p><strong>thisArg</strong></p>

<p><code class="highlighter-rouge">this</code> parameter value to be passed to target function while calling the <code class="highlighter-rouge">bound</code> function.</p>

<p><strong>arg1, arg2, …</strong></p>

<p>Prepended arguments to be passed to the <code class="highlighter-rouge">bound</code> function while invoking the target function.</p>

<p><strong>Return value</strong></p>

<p>A copy of the given function along with the specified <code class="highlighter-rouge">this</code> value and initial arguments.</p>

<h3 id="bind-method-in-action-in-js">Bind method in action in JS</h3>

<div class="language-js highlighter-rouge"><pre><code>const myCar = {
 brand: 'Ford',
 type: 'Sedan'
 Color: ‘Red'
};

const getBrand = () =&gt; {
 console.log(this.brand);
};

const getType = () =&gt; {
 console.log(this.type);
};

const getColor = () =&gt; {
 console.log(this.color);
};

getBrand(); // object not bind,undefined

getBrand(myCar); // object not bind,undefined

getType.bind(myCar)(); // Sedan

getColor.bind(myCar); // Red

</code></pre>
</div>

    
  </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t04" name="t04"></a><h1>04 : Currying vs Partial Application</h1>
					<span>http://www.datchley.name/currying-vs-partial-application/</span>
					<div class="tutorial__content">


 <p>In this post we'll cover a couple techniques in Javascript that are common among functional languages: <em>currying</em> and <em>partial application</em>.  You don't need a background in functional programming to understand these, so don't worry. </p>

<h2 id="aquickreviewaboutfunctions">A quick review about functions...</h2>

<p>So, I'll assume you have a basic understanding of functions in Javascript, including <a href="http://eloquentjavascript.net/05_higher_order.html">higher-order functions</a>, <a href="http://www.datchley.name/basic-scope/">closures</a> and <a href="http://www.datchley.name/functions/"><code>call</code> &amp; <code>apply</code></a>; if not, go review those topics quickly and come back. </p>

<p>Now that you're back, let's review a couple of important points before moving ahead.</p>

<blockquote>
  <p><strong>Arity</strong> refers to the number of arguments a function can accept. This might be none, one (<em>unary</em>), two (<em>binary</em>) or more (<em>polyadic</em>). You can also have functions that take a variable number of arguments, (<em>variadic functions</em>).</p>
</blockquote>

<p>Functions allow you to access their arity via the <code>.length</code> property of the function.  The <code>.length</code> of a function never changes - it always matches the number of declared arguments for the function.</p>

<pre><code class="language-javascript">function howMany(a,b,c) {  
    console.log(howmany.length);
}

howMany(1,2);      // 3  
howMany(1,2,3,4);  // 3  
</code></pre>

<p>Obviously, it's up to you and your function to properly handle the cases of too few and too many arguments.</p>

<blockquote>
  <p><strong>Variadic Functions</strong> are those functions which take a variable number of arguments.  </p>
</blockquote>

<p>Javascript allows us to access all the arguments passed to a function via the  <code>arguments</code> variable made available inside a function's scope.  This variable contains an <em>array-like</em> list of all the arguments pass to the function when it was called.  </p>

<p>I say, <em>array-like</em>, because even though it's a list, it only has a <code>.length</code> and none of the other properties you'd expect of a real Array.  You can access it via indexing <code>[]</code>, get the <code>.length</code> and iterate over it using a loop construct - and that's about it.</p>

<p>But we can convert this into a 'real' array which will make the arguments list much more useful to us:</p>

<pre><code class="language-javascript">function showArgs() {  
   var args = [].slice.call(arguments);
}
</code></pre>

<p>The <code>[].slice.call(arguments)</code> is a short-handed way of doing <code>Array.prototype.slice.call(arguments)</code>, we just take advantage of the use of an array literal. </p>

<p>In ES6 we can access and '<em>unpack</em>' our arguments even more easily with the help of the spread/gather operator:</p>

<pre><code class="language-javascript">function howMany(...args) {  
   console.log("args:", args, ", length:", args.length);
}
howMany(1,2,3,4);  // args: [1,2,3,4], length: 4   (a "real" array)!  
</code></pre>

<p>With all that out of the way -- which I'm sure you knew already -- we can move on to our main topic!</p>

<h2 id="currying">Currying</h2>

<blockquote>
  <p><strong>Currying</strong> is the process of taking a function that accepts <em>N</em> arguments and turning it into a chained series of <em>N</em> functions each taking <em>1</em> argument. </p>
</blockquote>

<p>If we had an <code>add()</code> function that accepted 3 arguments and returned the sum,</p>

<pre><code class="language-javascript">function add(a,b,c) { return a+b+c; }  
</code></pre>

<p>we can turn it into a curried function as follows:  </p>

<pre><code class="language-javascript">function curriedAdd(a) {  
   return function(b) {
     return function(c) {
       return a+b+c;
     }
   }
}
</code></pre>

<p>How does currying work? It works by nesting functions for each possible argument, using the natural closure created by the nested functions to retain access to each of the successive arguments.</p>

<p><img src="/content/images/2015/07/curry-function-closures.png" alt="">
What we want is a way to easily convert an existing function that takes <em>N</em> arguments into its curried version without having to write-out each curried version of a function as we did with <code>curriedAdd()</code>.  </p>

<p>Let's see if we can decompose this and build something useful.</p>

<h3 id="writingagenericcurry">Writing a generic <code>curry()</code></h3>

<p>Ideally, this is the <code>curry()</code> function interface we'd like to design:</p>

<pre><code class="language-javascript">function foo(a,b,c){ return a+b+c; }  
var curriedFoo = curry(foo);

curriedFoo(1,2,3);   // 6  
curriedFoo(1)(2,3);  // 6  
curriedFoo(1)(2)(3); // 6  
curriedFoo(1,2)(3);  // 6  
</code></pre>

<p>Our <code>curry()</code> returns a new function that allows us to call it with one or more arguments, which it will then partially apply; up until it receives the last argument (<em>based on the original function's arity</em>) at which point it will return the evaluation of invoking the original function with all the arguments.</p>

<p>We know we can access the <em>arity</em> of a function using the <code>.length</code> property of the function.  We can use this knowledge to allow us to know how many chained sequences of that function we need to call.</p>

<p>And, we'll need to store the original function passed in as well, so that once we have all the required arguments we can call the original function with the proper arguments and return its results.</p>

<p>Here's our first attempt:</p>

<pre><code class="language-javascript linenumbers">function curry(fn) {  
  return function curried() {                           
    var args = [].slice.call(arguments);
    return args.length &gt;= fn.length ?
      fn.apply(null, args) :
      function () {
        var rest = [].slice.call(arguments);
          return curried.apply(null, args.concat(rest));
      };
  };
}
</code></pre>

<p>Let's break this down in detail...</p>

<ul>
<li><strong>line 2</strong> our <code>curry</code> function returns a new function, in this case a named function expression called <code>curried()</code>.</li>
<li><strong>line 3</strong> every time this function is called, we store the arguments passed to it in <code>args</code></li>
<li><strong>line 4</strong> if the number of arguments is equal to the arity of the original function, we have them all, so</li>
<li><strong>line 5</strong> return the invocation of the original function with all the arguments</li>
<li><strong>line 6</strong> otherwise, return a function that will accept more arguments that, when called, will call our <code>curried</code> function again with the original arguments passed previously combined with the arguments passed to the newly returned function.</li>
</ul>

<p>Let's give this a try with our original <code>add</code> function from before.</p>

<pre><code class="language-javascript">var curriedAdd = curry(add);  
curriedAdd(1)(2)(3);  
// 6
curriedAdd(1)(2,3);  
// 6
</code></pre>

<p>Excellent!  This seems to do exactly what we want it to do. However, suppose we had an object with functions that depended on the proper object being set to the calling context (<code>this</code>) of the function.  Can we use our <code>curry</code> function to curry an object method?</p>

<pre><code class="language-javascript">var border = {  
  style: 'border',
  generate: function(length, measure, type, color) {
    return [this.style + ':', length + measure, type, color].join(' ') +';';
  }
};

border.curriedGenerate = curry(border.generate);

border.curriedGenerate(2)('px')('solid')('#369')  
// =&gt; "undefined: 2px solid #369;"
</code></pre>

<p>Uh oh. That's not what we wanted.  </p>

<p>Using our <code>curry()</code> function as a method decorator<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> seems to break the object context expected by the method. We'll have to retain the original context and be sure and pass it along to successive calls to the returned <code>curried</code> function.</p>

<pre><code class="language-javascript">function curry(fn) {  
    return function curried() {
        var args = toArray(arguments), 
            context = this;

        return args.length &gt;= fn.length ?
            fn.apply(context, args) :
            function () {
                var rest = toArray(arguments);
                return curried.apply(context, args.concat(rest));
            };
    }
}
</code></pre>

<p>Let's try it again.</p>

<pre><code class="language-javascript">border.curriedGenerate(2)('px')('solid')('#369')  
// =&gt; "border: 2px solid #369;"
</code></pre>

<p>Got it!  Now our <code>curry()</code> function is context aware and can be used in any number of situations as a function decorator.</p>

<h3 id="curryingvariadicfunctions">Currying Variadic Functions?</h3>

<p>So our current solution works and correctly retains the context when called, as long as those functions being curried only accept exactly the number of arguments they declare - no more, no less.  This doesn't help us if we want to curry a function that has optional declared arguments or a variable number of arguments (<em>variadic functions</em>).</p>

<p>With variable argument functions, we need a way to tell our <code>curry()</code> function <em>when</em> it has enough arguments to evaluate the original function that it's currying.  </p>

<p>Take the following functions</p>

<pre><code class="language-javascript">function max(/* variable arguments */) {  
  var args = [].slice.call(arguments);
  return Math.max.apply(Math, args);
}

function  range(start, end, step) {  
  var stop = Math.max(start, end),
      start = Math.min(start, end),
      set = [];

  // step is optional
  step = typeof step !== 'undefined' ? step : 1;

  for (var i=start; i &lt;=stop; i+=step) {
      set.push(i);
  }  
  return set;
}
</code></pre>

<p>In the above, if we tried to use <code>curry(max)(1)(2)(3)</code> it evaluates too soon and we get a <code>TypeError</code>. </p>

<p>If we try to use <code>curry(range)(1)(10)</code> it never evaluates and simply stops by returning us a function that is still expecting another argument.</p>

<p>There is no feasible implementation of <code>curry</code> which will suffice for the example of our <code>max()</code> function which can take any number of arguments. Without an arity or a minimum number of arguments, there's no efficient way to determine when we should evaluate the original function with the arguments up to that point.</p>

<p>However, we can try to handle the case of optional, trailing arguments as in our <code>range()</code> example; and with minimal changes to our original <code>curry()</code> implementation.  </p>

<p>We can modify our original <code>curry()</code> function to take an optional second argument which is the minimum number of arguments to curry.</p>

<pre><code class="language-javascript">function curry(fn, n) {  
  var arity = n || fn.length;
  return function curried() {
      var args = toArray(arguments), 
          context = this;

      return args.length &gt;= arity ?
          fn.apply(context, args) :
          function () {
              var rest = toArray(arguments);
              return curried.apply(context, args.concat(rest));
          };
  };
}
</code></pre>

<p>Now, we can call <code>curry(range, 2)(1)(10)</code> as well as <code>curry(range, 2)(1)(10,2)</code>. Unfortunately, though, we can't call it as <code>curry(range, 2)(1)(10)(2)</code>, because as soon as it sees the minimum number of arguments, 2 in this case, it will return the results of evaluating the curried function.</p>

<h2 id="whattodoaboutcurryingthen">What to do about Currying then?</h2>

<p>It's clear from our examination above that currying in Javascript is definitely possible and useful. However, because Javascript allows any function to be variadic by nature, it becomes inefficient to implement a <code>curry()</code> function that can handle all possible cases.</p>

<p><strong>Solution</strong>: If you're writing in a functional style, with unary and/or binary functions; and those functions take specific arguments that are declared, take advantage of currying. Otherwise, using our original implementation of <code>curry()</code> with the understanding that there are limitations surrounding functions with optional or variable arguments might be the best approach. </p>

<h2 id="partialapplication">Partial Application</h2>

<p>That was a lot of talking about currying; so, what is <em>partial application</em>?  </p>

<blockquote>
  <p><strong>Partial application</strong> means taking a function and <em>paritally</em> applying it to one or more of its arguments, but not all, creating a new function in the process.</p>
</blockquote>

<p>Javascript already lets you do this with <code>Function.prototype.bind()</code></p>

<pre><code class="language-javascript">function add3(a, b, c) { return a+b+c; }  
add3(2,4,8);  // 14

var add6 = add3.bind(this, 2, 4);  
add6(8);  // 14  
</code></pre>

<p>But, that sounds a lot like what our <code>curry()</code> function does internally. If you have <code>curry()</code>, you also have partial application!<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<pre><code class="language-javascript">var add6 = curry(add3)(2)(4);  
add6(8); // 14  
</code></pre>

<p>The primary difference is in how you use them.  We can implement a partial application function fairly easily (<em>this is applying arguments from left to right</em>)</p>

<pre><code class="language-javascript">// Apply left arbitrary number of arguments
function apply(fn /* partial arguments... */) {  
    var args = [].slice.call(arguments, 1);
    return function() {
        var _args = [].slice.call(arguments);
        return fn.apply(this, args.concat(_args));
    }
}
</code></pre>

<p>And we can call this, much like <code>bind</code> but without the initial context argument, like <code>var add6 = apply(add3, 2, 4)</code>.</p>

<h2 id="es6curryandapplyimplementations">ES6 <code>curry</code> and <code>apply</code> implementations</h2>

<p>To wrap things up, I promised to cover the ES6 implementations as well, so here is <code>curry()</code>,</p>

<pre><code class="language-javascript">function curry(fn) {  
    return function curried(...args) {
        return args.length &gt;= fn.length ?
            fn.call(this, ...args) :
            (...rest) =&gt; {
                return curried.call(this, ...args, ...rest);
            };
    };
}
</code></pre>

<p>and here's our <code>apply()</code> function in ES6 as well.</p>

<pre><code class="language-javascript">// Apply left arbitrary number of arguments
function apply(fn, ...args) {  
    return (..._args) =&gt; {
        return fn(...args, ..._args);
    };
}
</code></pre>

<p>The <code>...</code>(spread/gather) operator and <code>=&gt;</code> fat arrow functions simplify the amount of code we need to implement our previous ES5 versions of <code>curry</code> and <code>apply</code>; and, I think they make the implementation more clear and understandable as well.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>05 : What's the difference between Currying and Partial Application?</h1>
					<span>http://raganwald.com/2013/03/07/currying-and-partial-application.html</span>
					<div class="tutorial__content">

<section id="main_content">
          <p>I was participating in <a href="http://wrocloverb.com">wroc_love.rb</a> last week-end, and <a href="http://steveklabnik.com">Steve Klabnik</a> put up a slide mentioning <a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a> and <a href="https://en.wikipedia.org/wiki/Currying">currying</a>. "The difference between them is not important right now," he said, pressing on. And it wasn't.</p>

<p>But here we are, it's a brand new day, and we've already read five different explanations of <code class="highlighter-rouge">this</code> and closures this week, but only three or four about currying, so let's get into it.</p>

<h3 id="arity">arity</h3>

<p>Before we jump in, let's get some terminology straight. Functions have <em>arity</em>, meaning the number of arguments they accept. A "unary" function accepts one argument, a "polyadic" function takes more than one argument. There are specialized terms we can use: A "binary" function accepts two, a "ternary" function accepts three, and you can rustle about with greek or latin words and invent names for functions that accept more than three arguments.</p>

<p>Some functions accept a variable number of arguments, we call them <em>variadic</em>, although variadic functions and functions taking no arguments aren't our primary focus in this essay.</p>

<h3 id="partial-application">partial application</h3>

<p>Partial application is straightforward. We could start with addition or some such completely trivial example, but if you don't mind we'll have a look at something from the <a href="http://allong.es">allong.es</a> JavaScript library that is of actual use in daily programming.</p>

<p>As a preamble, let's make ourselves a <code class="highlighter-rouge">map</code> function that maps another function over a list:</p>

<pre><code>var __map = [].map;

function map (list, unaryFn) {
  return __map.call(list, unaryFn);
};

function square (n) {
  return n * n;
};

map([1, 2, 3], square);
  //=&gt; [1, 4, 9]
</code></pre>

<p><code class="highlighter-rouge">map</code> is obviously a binary function, <code class="highlighter-rouge">square</code> is a unary function. When we called <code class="highlighter-rouge">map</code> with arguments <code class="highlighter-rouge">[1, 2, 3]</code> and <code class="highlighter-rouge">square</code>, we <em>applied</em> the arguments to the function and got our result.</p>

<p>Since <code class="highlighter-rouge">map</code> takes two arguments, and we supplied two arguments, we <em>fully applied</em> the arguments to the function. So what's partial application? Supplying fewer arguments. Like supplying one argument to <code class="highlighter-rouge">map</code>.</p>

<p>Now what happens if we supply one argument to <code class="highlighter-rouge">map</code>? We can't get a result without the other argument, so what we get back is a unary function that takes the other argument and produces the result we want.</p>

<p>If we're going to apply one argument to <code class="highlighter-rouge">map</code>, let's make it the <code class="highlighter-rouge">unaryFn</code>. We'll start with the end result and work backwards. First thing we do, is set up a wrapper around map:</p>

<pre><code>function mapWrapper (list, unaryFn) {
  return map(list, unaryFn);
};
</code></pre>

<p>Next we'll break our binary wrapper function into two nested unary functions:</p>

<pre><code>function mapWrapper (unaryFn) {
  return function (list) {
    return map(list, unaryFn);
  };
};
</code></pre>

<p>Now we can supply our arguments one at a time:</p>

<pre><code>mapWrapper(square)([1, 2, 3]);
  //=&gt; [1, 4, 9]
</code></pre>

<p>Instead of a binary <code class="highlighter-rouge">map</code> function that returns our result, we now have a unary function that returns a unary function that returns our result. So where's the partial application? Let's get our hands on the second unary function:</p>

<pre><code>var squareAll = mapWrapper(square);
  //=&gt; [function]

squareAll([1, 2, 3]);
  //=&gt; [1, 4, 9]
squareAll([5, 7, 5]);
  //=&gt; [25, 49, 25]
</code></pre>

<p>We've just partially applied the value <code class="highlighter-rouge">square</code> to the function <code class="highlighter-rouge">map</code>. We got back a unary function, <code class="highlighter-rouge">squareAll</code>, that we could use as we liked. Partially applying <code class="highlighter-rouge">map</code> in this fashion is handy, so much so that the <a href="http://allong.es">allong.es</a> library includes a function called <code class="highlighter-rouge">mapWith</code> that does this exact thing.</p>

<p>If we had to physically write ourselves a wrapper function every time we want to do some partial application, we'd never bother. Being programmers though, we can automate this. There are two ways to do it.</p>

<h3 id="currying">currying</h3>

<p>First up, we can write a function that returns a wrapper function. Sticking with binary function, we start with this:</p>

<pre><code>function wrapper (unaryFn) {
  return function (list) {
    return map(list, unaryFn);
  };
};
</code></pre>

<p>Rename <code class="highlighter-rouge">map</code> and the two arguments:</p>

<pre><code>function wrapper (secondArg) {
  return function (firstArg) {
    return binaryFn(firstArg, secondArg);
  };
};
</code></pre>

<p>And now we can wrap the whole thing in a function that takes <code class="highlighter-rouge">binaryFn</code> as an argument:</p>

<pre><code>function rightmostCurry (binaryFn) {
  return function (secondArg) {
    return function (firstArg) {
      return binaryFn(firstArg, secondArg);
    };
  };
};
</code></pre>

<p>So now we've ‘abstracted' our little pattern. We can use it like this:</p>

<pre><code>var rightmostCurriedMap = rightmostCurry(map);

var squareAll = rightmostCurriedMap(square);

squareAll([1, 4, 9]);
  //=&gt; [1, 4, 9]
squareAll([5, 7, 5]);
  //=&gt; [25, 49, 25]
</code></pre>

<p>Converting a polyadic function into a nested series of unary functions is called <strong>currying</strong>, after Haskell Curry, who popularized the technique. He actually rediscovered the combinatory logic work of <a href="https://en.wikipedia.org/wiki/Moses_Schönfinkel">Moses Schönfinkel</a>, so we could easily call it "schönfinkeling."<sup id="fnref:birds"><a href="#fn:birds" class="footnote">1</a></sup></p>

<p>Our <code class="highlighter-rouge">rightmostCurry</code> function curries any binary function into a chain of unary functions starting with the second argument. This is a "rightmost" curry because it starts at the right.</p>

<p>The opposite order would be a "leftmost" curry. Most logicians work with leftmost currying, so when we write a leftmost curry, most people just call it "curry:"</p>

<pre><code>function curry (binaryFn) {
  return function (firstArg) {
    return function (secondArg) {
      return binaryFn(firstArg, secondArg);
    };
  };
};

var curriedMap = curry(map),
    double = function (n) { return n + n; };

var oneToThreeEach = curriedMap([1, 2, 3]);

oneToThreeEach(square);
  //=&gt; [1, 4, 9]
oneToThreeEach(double);
  //=&gt; [2, 4, 6]
</code></pre>

<p>When would you use a regular curry and when would you use a rightmost curry? It really depends on your usage. In our binary function example, we're emulating a kind of subject-object grammar. The first argument we want to use is going to be the subject, the second is going to be the object.</p>

<p>So when we use a rightmost curry on <code class="highlighter-rouge">map</code>, we are setting up a "sentence" that makes the mapping function the subject.</p>

<p>So we read <code class="highlighter-rouge">squareAll([1, 2, 3])</code> as "square all the elements of the array [1, 2, 3]." By using a rightmost curry, we made "squaring" the subject and the list the object. Whereas when we used a regular curry, the list became the subject and the mapper function became the object.</p>

<p>Another way to look at it that is a little more like "patterns and programming" is to think about what you want to name and/or reuse. Having both kinds of currying lets you name and/or reuse either the mapping function or the list.</p>

<h3 id="partial-application-1">partial application</h3>

<p>So many words about currying! What about "partial application?" Well, if you have currying you don't need partial application. And conversely, if you have partial application you don't need currying. So when you write this kind of essay, it's easy to spend a lot of words describing one of these two things and then explain everything else on top of what you already have.</p>

<p>Let's look at our rightmost curry again:</p>

<pre><code>function rightmostCurry (binaryFn) {
  return function (secondArg) {
    return function (firstArg) {
      return binaryFn(firstArg, secondArg);
    };
  };
};
</code></pre>

<p>You might find yourself writing code like this over and over again:</p>

<pre><code>var squareAll = rightmostCurry(map)(square),
    doubleAll = rightmostCurry(map)(double);
</code></pre>

<p>This business of making a rightmost curry and then immediately applying an argument to it is extremely common, and when something's common we humans like to name it. And it has a name, it's called a <em>rightmost unary partial application of the map function</em>.</p>

<p>What a mouthful. Let's take it step by step:</p>

<ol>
  <li>rightmost: From the right.</li>
  <li>unary: One argument.</li>
  <li>partial application: Not applying all of the arguments.</li>
  <li>map: To the map function.</li>
</ol>

<p>So what we're really doing is applying one argument to the map function. It's a binary function, so that means what we're left with is a unary function. Again, functional languages and libraries almost always include a first-class function to do this for us.</p>

<p>We <em>could</em> build one out of a rightmost curry:</p>

<pre><code>function rightmostUnaryPartialApplication (binaryFn, secondArg) {
  return rightmostCurry(binaryFn)(secondArg);
};
</code></pre>

<p>However it is usually implemented in more direct fashion:<sup id="fnref:caveat"><a href="#fn:caveat" class="footnote">2</a></sup></p>

<pre><code>function rightmostUnaryPartialApplication (binaryFn, secondArg) {
  return function (firstArg) {
    return binaryFn(firstArg, secondArg);
  };
};
</code></pre>

<p><code class="highlighter-rouge">rightmostUnaryPartialApplication</code> is a bit much, so we'll alias it <code class="highlighter-rouge">applyLast</code>:</p>

<pre><code>var applyLast = rightmostUnaryPartialApplication;
</code></pre>

<p>And here're our <code class="highlighter-rouge">squareAll</code> and <code class="highlighter-rouge">doubleAll</code> functions built with <code class="highlighter-rouge">applyLast</code>:</p>

<pre><code>var squareAll = applyLast(map, square),
    doubleAll = applyLast(map, double);
</code></pre>

<p>You can also make an <code class="highlighter-rouge">applyFirst</code> function (we'll skip calling it "leftmostUnaryPartialApplication"):</p>

<pre><code>function applyFirst (binaryFn, firstArg) {
  return function (secondArg) {
    return binaryFn(firstArg, secondArg);
  };
};
</code></pre>

<p>As with leftmost and rightmost currying, you want to have both in your toolbox so that you can choose what you are naming and/or reusing.</p>

<h3 id="so-whats-the-difference-between-currying-and-partial-application">so what's the difference between currying and partial application?</h3>

<p>"Currying is the decomposition of a polyadic function into a chain of nested unary functions. Thus decomposed, you can partially apply one or more arguments,<sup id="fnref:also"><a href="#fn:also" class="footnote">3</a></sup> although the curry operation itself does not apply any arguments to the function."</p>

<p>"Partial application is the conversion of a polyadic function into a function taking fewer arguments arguments by providing one or more arguments in advance."</p>

<h3 id="is-that-all-there-is">is that all there is?</h3>

<p>Yes. And no. Here are some further directions to explore on your own:</p>

<ol>
  <li>We saw how to use currying to implement partial application. Is it possible to use partial application to implement currying? Why? Why not?<sup id="fnref:tao"><a href="#fn:tao" class="footnote">4</a></sup></li>
  <li>All of our examples of partial application have concerned converting binary functions into unary functions by providing one argument. Write more general versions of <code class="highlighter-rouge">applyFirst</code> and <code class="highlighter-rouge">applyLast</code> that provide one argument to any polyadic function. For example, if you have a function that takes four arguments, <code class="highlighter-rouge">applyFirst</code> should return a function taking three arguments.</li>
  <li>When you have <code class="highlighter-rouge">applyFirst</code> and <code class="highlighter-rouge">applyLast</code> working with all polyadic functions, try implementing <code class="highlighter-rouge">applyLeft</code> and <code class="highlighter-rouge">applyRight</code>: <code class="highlighter-rouge">applyLeft</code> takes a polyadic function and one <em>or more</em> arguments and leftmost partially applies them. So if you provide it with a ternary function and two arguments, it should return a unary function. <code class="highlighter-rouge">applyRight</code> does the same with rightmost application.</li>
  <li>Rewrite curry and rightmostCurry to accept any polyadic function. So just as a binary function curries into two nested unary functions, a ternary function should curry into three nested unary functions and so on.</li>
  <li>Review the source code for <a href="http://allong.es">allong.es</a>, the functional programming library extracted from <a href="http://leanpub.com/javascriptallongesix">JavaScript Allongé</a>, especially <a href="https://github.com/raganwald/allong.es/blob/master/lib/partial_application.js">partial_application.js</a>.</li>
</ol>

<p>Thanks for reading, if you discover a bug in the code, please either <a href="https://github.com/raganwald/raganwald.github.com">fork the repo</a> and submit a pull request, or <a href="https://github.com/raganwald/raganwald.github.com/issues">submit an issue on Github</a>.</p>

        </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t06" name="t06"></a><h1>06 : Approaches to currying in JavaScript</h1>
					<span>http://extralogical.net/articles/currying-javascript.html</span>
					<div class="tutorial__content">


<article>
    
    
    
    
    <p>JavaScript's dynamic nature makes it hard to straightforwardly apply many functional programming idioms. One example of this is <a href="http://en.wikipedia.org/wiki/Currying">currying</a>: any function may be passed an arbitrary number of arguments, making it impossible to write a truly general currying function.</p>
<p>To recap, currying is a technique for transforming a function which accepts <em>n</em> parameters into a nest of partially applicable functions. Consider the function <em>f = λxyz.M</em>, which has three parameters, <em>x</em>, <em>y</em> and <em>z</em>. By currying, we obtain a new function <em>f* = λx.(λy.(λz.M))</em>.</p>
<p>One simple example is currying an <code>add</code> function which accepts 2 parameters and returns the result of adding them together.</p>
<pre><code>var add = function(a, b) {
    return a + b;
};

var curriedAdd = function(a) {
    return function(b) {
        return a + b;
    };
};</code></pre>
<p>A function which returns the result of evaluating a quadratic expression demonstrates more clearly the ‘nesting' of functions which currying produces.</p>
<pre><code>var quadratic = function(a, b, c, x) {
    return a * x * x + b * x + c;
};

var curriedQuadratic = function(a) {
    return function(b) {
        return function(c) {
            return function(x) {
                return a * x * x + b * x + c;
            };
        };
    };
};</code></pre>
<p>Given a pattern like this, the obvious question is how to generalise it. Ideally, we would write a <code>curry</code> function to automatically transform functions like <code>quadratic</code> into ones like <code>curriedQuadratic</code>. The simplest approach is to make curried functions always return a single wrapping function:</p>
<pre><code>var naiveCurry = function(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    
    return function() {
        var largs = Array.prototype.slice.call(arguments, 0);
        return f.apply(this, args.concat(largs));
    };
};</code></pre>
<p>Clearly this is not true currying, except for functions of arity 2. We cannot use it to perform the transformation from <code>quadratic</code> to <code>curriedQuadratic</code>.</p>
<p>A cleverer approach would be to detect the arity of the function we wish to curry. To do this, we can use the length property of the function, which returns the number of named arguments the function accepts. <code>Math.tan.length</code> is 1, while <code>parseInt.length</code> is 2.</p>
<pre><code>var curryByLength = function(f) {
    var arity = f.length,
        args  = Array.prototype.slice.call(arguments, 1),
    
    accumulator = function() {
        var largs = args;
        
        if (arguments.length &gt; 0) {
            // We must be careful to copy the `args` array with `concat` rather
            // than mutate it; otherwise, executing curried functions can have
            // strange non-local effects on other curried functions.
            largs = largs.concat(Array.prototype.slice.call(arguments, 0));
        }
        
        if (largs.length &gt;= arity) {
            return f.apply(this, largs);
        } else {
            return curryByLength.apply(this, [f].concat(largs));
        }
    };
    
    return args.length &gt;= arity ? accumulator() : accumulator;
};</code></pre>
<p>However, the length property of any given JavaScript function can easily mislead. To begin with, we often find it useful to define functions with optional parameters.</p>
<pre><code>var someFunction = function(a, flag) {
    if (flag) {
        // Some computation involving a
    } else {
        // Some other computation involving a
    }
};</code></pre>
<p>Now consider a variadic function, like <code>Math.max</code>, which returns the largest number amongst its arguments. Despite the fact that it can in fact be called with any number of arguments, including 0 and 1, it has a length property of 2. Consequently, our ‘smarter' curry function will only work with <code>Math.max</code> up to a point. This will throw a type error, even though <code>Math.max</code> will accept three arguments quite happily:</p>
<pre><code>curryByLength(Math.max)(1)(2)(3);</code></pre>
<p>Currying <code>Math.max</code> limits its utility to discriminating between two numbers, not <em>n</em> numbers. We can easily think of similar examples—other variadic functions, functions with optional arguments, and similarly clever abuses of JavaScript's dynamic arguments to create complex APIs. jQuery's <code>bind</code> method could be considered <a href="http://api.jquery.com/bind/">an example</a> of this: the event handler can be passed to the method as either the second or the third argument, depending on whether the user wishes to use the optional <code>eventData</code> parameter or not.</p>
<p>It is easy to see that there is no general way of resolving this issue: currying is essentially at odds with variadic functions and the ability to change the number of arguments a function accepts at runtime. However, one's choices are not limited simply to the approaches discussed above; there are alternatives, even if they do not fully dispose of the problem of dynamic arity.</p>
<p>Firstly, one can simply leave things as they are, with the <code>curry</code> function having a known limitation around functions with dynamic arity. The burden is placed on the user to ensure they take care when currying.</p>
<p>Alternatively, one could make the arity an explicit component of the <code>curry</code> function. This differs from the implicit detection of the arity via the curried function's length property (however, the implementation is almost identical).</p>
<pre><code>var curryWithExplicitArity = function(f, n) {
    var args = Array.prototype.slice.call(arguments, 2),
    
    accumulator = function() {
        var largs = args;
        
        if (arguments.length &gt; 0) {
            largs = largs.concat(Array.prototype.slice.call(arguments, 0));
        }
        
        if (largs.length &gt;= n) {
            return f.apply(this, largs);
        } else {
            return curryByLength.apply(this, [f].concat(largs));
        }
    };
    
    return args.length &gt;= n ? accumulator() : accumulator;
};</code></pre>
<p>Finally, one could have entirely different <code>curry</code> functions for each arity. This has the benefit of being explicit, and while it doesn't solve the problem of functions with dynamic arity, it does mean that one doesn't have to specify the arity of the function one wishes to curry each time as an additional parameter. Instead of writing <code>curry(f, 3)</code>, one can simply write <code>curry3(f)</code>.</p>
<p>In fact, there is a way to combine these last two approaches, by writing a function which generates curry functions for any given arity.</p>
<pre><code>var ncurry = function(n) {
    var _curry = function(f) {
        var args = Array.prototype.slice.call(arguments, 1),
        
        return function() {
            var largs = args.concat(Array.prototype.slice.call(arguments, 0));
            
            if (largs.length &lt; n) {
                largs.unshift(f);
                return _curry.apply(null, largs);
            } else {
                return f.apply(null, largs);
            }
        };
    };
    
    return _curry;
};</code></pre>
<p>For common use cases such as functions which accept 2 or 3 arguments, one can write simple aliases using <code>ncurry</code>, while one can always use <code>ncurry</code> ‘inline' where necessary.</p>
<pre><code>var curry  = ncurry(2),
    curry3 = ncurry(3);

// Presumably `f7` is a function which accepts 7 arguments
var fc7 = ncurry(7)(f7);</code></pre>
<p>However, oftentimes something along the lines of <code>curryByLength</code> is preferable. If the library of functions one is working with consists of a set of functions with well-defined lists of parameters, then implicit rather than explicit conversion can be more convenient and more natural; it is, after all, rather nicer to be able to write <code>curry(f)</code> than <code>curry(f, n)</code> or even <code>ncurry(n)(f)</code>.</p>
<p>Ultimately which approach one decides to take must be based on understanding of the properties of the functions one is working with. A choice of currying function will then arise naturally—and after all, one can always use several. Both of these approaches are <a href="../projects/udon">available in Udon</a>, my library for functional programming in JavaScript, as <code>Udon.curry</code> and <code>Udon.ncurry</code>.</p>

</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t07" name="t07"></a><h1>07 : 7 Essential JavaScript Functions</h1>
					<div class="tutorial__content">
<span>https://davidwalsh.name/essential-javascript-functions</span>
<p>I remember the early days of JavaScript where you needed a simple function for just about everything because the browser vendors implemented features differently, and not just edge features, basic features, like <code>addEventListener</code> and <code>attachEvent</code>.  Times have changed but there are still a few functions each developer should have in their arsenal, for performance for functional ease purposes.</p>

<h2><a href="https://davidwalsh.name/javascript-debounce-function"><code>debounce</code></a></h2>

<p>The debounce function can be a game-changer when it comes to event-fueled performance.  If you aren't using a debouncing function with a <code>scroll</code>, <code>resize</code>, <code>key*</code> event, you're probably doing it wrong.  Here's a <code>debounce</code> function to keep your code efficient:</p>

<pre class="js">// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
	var timeout;
	return function() {
		var context = this, args = arguments;
		var later = function() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate &amp;&amp; !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
};

// Usage
var myEfficientFn = debounce(function() {
	// All the taxing stuff you do
}, 250);
window.addEventListener('resize', myEfficientFn);
</pre>

<p>The <code>debounce</code> function will not allow a callback to be used more than once per given time frame.  This is especially important when assigning a callback function to frequently-firing events.</p>

<h2><a href="https://davidwalsh.name/javascript-polling"><code>poll</code></a></h2>

<p>As I mentioned with the <code>debounce</code> function, sometimes you don't get to plug into an event to signify a desired state -- if the event doesn't exist, you need to check for your desired state at intervals:</p>

<pre class="js">// The polling function
function poll(fn, timeout, interval) {
    var endTime = Number(new Date()) + (timeout || 2000);
    interval = interval || 100;

    var checkCondition = function(resolve, reject) {
        // If the condition is met, we're done! 
        var result = fn();
        if(result) {
            resolve(result);
        }
        // If the condition isn't met but the timeout hasn't elapsed, go again
        else if (Number(new Date()) &lt; endTime) {
            setTimeout(checkCondition, interval, resolve, reject);
        }
        // Didn't match and too much time, reject!
        else {
            reject(new Error('timed out for ' + fn + ': ' + arguments));
        }
    };

    return new Promise(checkCondition);
}

// Usage:  ensure element is visible
poll(function() {
	return document.getElementById('lightbox').offsetWidth &gt; 0;
}, 2000, 150).then(function() {
    // Polling done, now do something else!
}).catch(function() {
    // Polling timed out, handle the error!
});
</pre>

<p>Polling has long been useful on the web and will continue to be in the future!</p>

<h2><a href="https://davidwalsh.name/javascript-once"><code>once</code></a></h2>

<p>There are times when you prefer a given functionality only happen once, similar to the way you'd use an <code>onload</code> event.  This code provides you said functionality:</p>

<pre class="js">function once(fn, context) { 
	var result;

	return function() { 
		if(fn) {
			result = fn.apply(context || this, arguments);
			fn = null;
		}

		return result;
	};
}

// Usage
var canOnlyFireOnce = once(function() {
	console.log('Fired!');
});

canOnlyFireOnce(); // "Fired!"
canOnlyFireOnce(); // nada
</pre>

<p>The <code>once</code> function ensures a given function can only be called once, thus prevent duplicate initialization!</p>

<h2><a href="https://davidwalsh.name/get-absolute-url"><code>getAbsoluteUrl</code></a></h2>

<p>Getting an absolute URL from a variable string isn't as easy as you think.  There's the <code>URL</code> constructor but it can act up if you don't provide the required arguments (which sometimes you can't).  Here's a suave trick for getting an absolute URL from and string input:</p>

<pre class="js">var getAbsoluteUrl = (function() {
	var a;

	return function(url) {
		if(!a) a = document.createElement('a');
		a.href = url;

		return a.href;
	};
})();

// Usage
getAbsoluteUrl('/something'); // https://davidwalsh.name/something
</pre>

<p>The "burn" element <code>href</code> handles and URL nonsense for you, providing a reliable absolute URL in return.</p>

<h2><a href="https://davidwalsh.name/detect-native-function"><code>isNative</code></a></h2>

<p>Knowing if a given function is native or not can signal if you're willing to override it.  This handy code can give you the answer:</p>

<pre class="js">;(function() {

  // Used to resolve the internal `[[Class]]` of values
  var toString = Object.prototype.toString;
  
  // Used to resolve the decompiled source of functions
  var fnToString = Function.prototype.toString;
  
  // Used to detect host constructors (Safari &gt; 4; really typed array specific)
  var reHostCtor = /^\[object .+?Constructor\]$/;

  // Compile a regexp using a common native method as a template.
  // We chose `Object#toString` because there's a good chance it is not being mucked with.
  var reNative = RegExp('^' +
    // Coerce `Object#toString` to a string
    String(toString)
    // Escape any special regexp characters
    .replace(/[.*+?^${}()|[\]\/\\]/g, '\\$&amp;')
    // Replace mentions of `toString` with `.*?` to keep the template generic.
    // Replace thing like `for ...` to support environments like Rhino which add extra info
    // such as method arity.
    .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );
  
  function isNative(value) {
    var type = typeof value;
    return type == 'function'
      // Use `Function#toString` to bypass the value's own `toString` method
      // and avoid being faked out.
      ? reNative.test(fnToString.call(value))
      // Fallback to a host object check because some environments will represent
      // things like typed arrays as DOM methods which may not conform to the
      // normal native pattern.
      : (value &amp;&amp; type == 'object' &amp;&amp; reHostCtor.test(toString.call(value))) || false;
  }
  
  // export however you want
  module.exports = isNative;
}());

// Usage
isNative(alert); // true
isNative(myCustomFunction); // false
</pre>

<p>The function isn't pretty but it gets the job done!</p>

<h2><a href="https://davidwalsh.name/add-rules-stylesheets"><code>insertRule</code></a></h2>

<p>We all know that we can grab a NodeList from a selector (via <code>document.querySelectorAll</code>) and give each of them a style, but what's more efficient is setting that style to a selector (like you do in a stylesheet):</p>

<pre class="js">var sheet = (function() {
	// Create the &lt;style&gt; tag
	var style = document.createElement('style');

	// Add a media (and/or media query) here if you'd like!
	// style.setAttribute('media', 'screen')
	// style.setAttribute('media', 'only screen and (max-width : 1024px)')

	// WebKit hack :(
	style.appendChild(document.createTextNode(''));

	// Add the &lt;style&gt; element to the page
	document.head.appendChild(style);

	return style.sheet;
})();

// Usage
sheet.insertRule("header { float: left; opacity: 0.8; }", 1);
</pre>

<p>This is especially useful when working on a dynamic, AJAX-heavy site.  If you set the style to a selector, you don't need to account for styling each element that may match that selector (now or in the future).</p>

<h2><a href="https://davidwalsh.name/element-matches-selector"><code>matchesSelector</code></a></h2>

<p>Oftentimes we validate input before moving forward; ensuring a truthy value, ensuring forms data is valid, etc.  But how often do we ensure an element qualifies for moving forward?  You can use a <code>matchesSelector</code> function to validate if an element is of a given selector match:</p>

<pre class="js">function matchesSelector(el, selector) {
	var p = Element.prototype;
	var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) {
		return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
	};
	return f.call(el, selector);
}

// Usage
matchesSelector(document.getElementById('myDiv'), 'div.someSelector[some-attribute=true]')
</pre>

					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t08" name="t08"></a><h1>08 : Collection of useful JavaScript functions and patterns</h1>
					<div class="tutorial__content">
<span>http://codebits.glennjones.net/cheatsheet/javascript.htm</span>

<p>This is a collection of useful JavaScript functions and patterns that I often use, when not coding with jQuery. 
                    I am still copying example from my projects into this document so it is a bit of a <strong>work in progress</strong>.</p>

                    <ul>
                        <li><a href="#strings">Strings</a></li>
                        <li><a href="#arrays">Arrays</a></li>
                        <li><a href="#dates">Dates</a></li>
                        <li><a href="#objects">Objects</a></li>
                        <li><a href="#dom">DOM</a></li>
                        <li><a href="#loops">Loops</a></li>
                        <li><a href="#events">Events</a></li>
                        <li><a href="#typedetection">Type detection</a></li>
                        <li><a href="#objectdetection">Object detection</a></li>
                        <li><a href="#json">JSON</a></li>
                        <li><a href="#module">Module</a></li>
                        <li><a href="#closure">Closure</a></li>
                    </ul>




<h2><a name="strings">Strings</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Removes any white space to the right and left of the string
function trim(str) {
    return str.replace(/^\s+|\s+$/g, "");
}


// Removes any white space to the left of the string
function ltrim(str) {
    return str.replace(/^\s+/, "");
}


// Removes any white space to the right of the string
function rtrim(str) {
    return str.replace(/\s+$/, "");
}


// Truncate a string to a given length
function truncate(str, len) {
    if (str.length &gt; len) {
        str = str.substring(0, len);
    }
    return str;
};


// Return a string only containing the letters a to z
function onlyLetters(str) {
    return str.toLowerCase().replace(/[^a-z]/g, "");
};


// Return a string only containing the letters a to z and numbers
function onlyLettersNums(str) {
    return str.toLowerCase().replace(/[^a-z,0-9,-]/g, "");
};
</code></pre>


<h2><a name="arrays">Arrays</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Removes an item from a given array
function removeArrayItem(arr, item) {
    var i = 0;
    while (i &lt; arr.length) {
        if (arr[i] == item) {
            arr.splice(i, 1);
        } else {
            i++;
        }
    }
};


// Does a given array contain a item
function contains(a, obj) {
    var i = a.length;
    while (i--) {
        if (a[i] === obj) {
            return true;
        }
    }
    return false;
};


// The index of an item - Javascript 1.6+
['glenn','john'].indexOf('john')  returns 2
</code></pre>


<h2><a name="dates">Dates</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Converts native date to a ISO date
function isoDateString(d) {
    function pad(n) {
        return n &lt; 10 ? '0' + n : n
    }
    return d.getUTCFullYear() + '-'
        + pad(d.getUTCMonth() + 1) + '-'
        + pad(d.getUTCDate()) + 'T'
        + pad(d.getUTCHours()) + ':'
        + pad(d.getUTCMinutes()) + ':'
        + pad(d.getUTCSeconds()) + 'Z'
}
</code></pre>


<h2><a name="objects">Objects</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Sorts a array of objects by a property
function sortObjectsByProperty(a, field, reverse, primer) {
    return a.sort(sortObjects(field, reverse, primer));
};


// Object sort
function sortObjects(field, reverse, primer) {
    reverse = (reverse) ? -1 : 1;
    return function (a, b) {
        a = a[field];
        b = b[field];
        if (primer !== undefined &amp;&amp; a !== undefined &amp;&amp; b !== undefined) {
            a = primer(a);
            b = primer(b);
        }
        if (a &lt; b) return reverse * -1;
        if (a &gt; b) return reverse * 1;
        return 0;
    }
};
</code></pre>


<h2><a name="dom">DOM</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Does the node have a class
function hasClass(node, className) {
    if (node.className) {
        return node.className.match(
            new RegExp('(\\s|^)' + className + '(\\s|$)'));
    } else {
        return false;
    }
};


// Add a class to an node
function addClass(node, className) {
    if (hasClass(node, className)) node.className += " " + className;
};


// Removes a class from an node
function removeClass(node, className) {
    if (hasClass(node, className)) {
        var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
        node.className = node.className.replace(reg, ' ');
    }
};


//Returns first ancestor of required class or a null
function getParentByClass(node, className) {
    if (arguments.length === 2) {
        if (node.parentNode &amp;&amp; node.nodeName !== "BODY")
            return getParentByClass(node.parentNode, className, 1);
        else
            return null;
    }
    // Recursive calls
    if (node !== null &amp;&amp; node !== undefined) {
        if (hasClass(node, className)) {
            return node;
        } else {
            if (node.parentNode &amp;&amp; node.nodeName !== "BODY")
                return getParentByClass(node.parentNode, className, 1);
            else
                return null;
        }
    } else {
        return null;
    }
};


// Returns the text of a given node 
function getTextContent(node) {
    if (typeof node.textContent != "undefined") {
        return node.textContent;
    }
    return node.innerText;
};


// Removes all child nodes
function removeAllChildren(node) {
    if (node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }
}


// Appends a new element to a given node
function append(node, eltName, attArr, strHtml) {
    if (node) {
        var nNode = document.createElement(eltName);
        if (attArr !== undefined) {
            var j = attArr.length;
            while (j--) {
                nNode.setAttribute(attArr[j][0], attArr[j][1]);
            }
        }
        if (strHtml !== undefined) {
            nNode.innerHTML = strHtml;
        }
        node.appendChild(nNode);
        return nNode;
    } else {
        return null;
    }
}


// Get elements by class name (Backwards compatible version)
function getElementsByClassName(rootNode, className) {
    var returnElements = [];
    if (rootNode.getElementsByClassName) {
        // Native getElementsByClassName 
        returnElements = rootNode.getElementsByClassName(className);
    } else if (document.evaluate) {
        // XPath 
        var xpathExpression;
        xpathExpression = ".//*[contains(concat(' ', @class, ' '), ' " 
            + className + " ')]";
        var xpathResult = document.evaluate(
            xpathExpression, rootNode, null, 0, null);
        var node;
        while ((node = xpathResult.iterateNext())) {
            returnElements.push(node);
        }
    } else {
        // Slower DOM fallback 
        className = className.replace(/\-/g, "\\-");
        var elements = rootNode.getElementsByTagName("*");
        for (var x = 0; x &lt; elements.length; x++) {
            if (elements[x].className.match("(^|\\s)" + className 
                + "(\\s|$)")) {
                returnElements.push(elements[x]);
            }
        }
    }
    return returnElements;
}


// Get elements by attribute (Backwards compatible version)
function getElementsByAttribute(
    rootNode, attributeName, attributeValues) {

    var attributeList = attributeValues.split(" ");
    var returnElements = [];
    if (rootNode.querySelectorAll) {
        var selector = '';
        for (var i = 0; i &lt; attributeList.length; i++) {
            selector += '[' + attributeName 
                + '*= "' + attributeList[i] + '"], ';
        }
        returnElements = rootNode.querySelectorAll(
            selector.substring(0, selector.length - 2));
    } else if (document.evaluatex) {
        // XPath 
        var xpathExpression = ".//*[";
        for (var i = 0; i &lt; attributeList.length; i++) {
            if (i !== 0) {
                xpathExpression += " or ";
            }
            xpathExpression += "contains(
                concat(' ', @" + attributeName 
                + ", ' '), ' " + attributeList[i] + " ')";
        }
        xpathExpression += "]";
        var xpathResult = document.evaluate(
            xpathExpression, rootNode, null, 0, null);
        var node;
        while ((node = xpathResult.iterateNext())) {
            returnElements.push(node);
        }
    } else {
        // Slower fallback 
        attributeName = attributeName.replace(/\-/g, "\\-");
        var elements = rootNode.getElementsByTagName("*");
        for (var x = 0; x &lt; elements.length; x++) {
            if (elements[x][attributeName]) {
                var found = false;
                for (var y = 0; y &lt; attributeList.length; y++) {
                    if (elements[x][attributeName].match("(^|\\s)" 
                        + attributeList[y] + "(\\s|$)")) {
                        found = true;
                    }
                }
                if (found)
                    returnElements.push(elements[x]);
            }
        }
    }
    return returnElements;
},

</code></pre>


<h2><a name="loops">Loops</a></h2>
<pre class="prettyprint" lang-html=""><code>
// While reverse loop - fast
var i = arr.length;
while (i--) {
    // Do Stuff
}


// While loop
var i = arr.length;
var x = 0;
while (x &lt; i) {
    // Do stuff
    x++;
}
</code></pre>



<h2><a name="events">Events</a></h2>
<pre class="prettyprint" lang-html=""><code>
    
// Add event (Cross browser old school)
function addEvent(obj, type, fn) {
    if (obj) {
        if (obj.attachEvent) {
            obj['e' + type + fn] = fn;
            obj[type + fn] = function () { 
                obj['e' + type + fn](window.event); 
            };
            obj.attachEvent('on' + type, obj[type + fn]);
        } else {
            obj.addEventListener(type, fn, false);
        }
    }
};


// Remove event (Cross browser old school)
function removeEvent(obj, type, fn) {
    if (obj) {
        if (obj.detachEvent) {
            obj.detachEvent('on' + type, obj[type + fn]);
            obj[type + fn] = null;
        } else {
            obj.removeEventListener(type, fn, false);
        }
    }
};


// Cancel event bubbling to the rest of DOM
function cancelBubble(e) {
    if (window.event)
        window.event.cancelBubble = true;
    else
        e.stopPropagation();
};


// Prevents the events default action from happening.
u.preventDefault = function (e) {
    if (e.preventDefault)
        e.preventDefault();
    try {
        e.returnValue = false;
    } catch (ex) {
        // Do nothing
    }
};

// Cancel bubbling and prevent default action
function eventStop(e) {
    cancelBubble(e);
    preventDefault(e);
}
</code></pre>



<h2><a name="typedetection">Type detection</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Is an object a string
function isString(obj) {
    return typeof (obj) == 'string';
};


// Is an object a array
function isArray(obj) {
    return obj &amp;&amp; !(obj.propertyIsEnumerable('length')) 
        &amp;&amp; typeof obj === 'object' 
        &amp;&amp; typeof obj.length === 'number';
};


// Is an object a int
function isInt(obj) {
    var re = /^\d+$/;
    return re.test(obj);
};


// Is an object a email address
function isEmail(obj) {
    if(isString(obj)){
        return obj.match(/\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b/ig);
    }else{
        return false;
    }
};


// Is an object a URL
function isUrl (obj) {
    if(isString(obj)){
        var re = new RegExp("^(http|https)\://([a-zA-Z0-9\.\-]+(\:" +
            "[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|" +
            "[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2" +
            "[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\." +
            "(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|" +
            "[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]" +
            "{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z" +
            "0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name" +
            "|pro|aero|coop|museum|[a-zA-Z]{2}))(\:[0-9]+)*(/($|[a-z" +
            "A-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+))*$");
        return obj.match(re);
    }else{
        return false;
    }
};
</code></pre>


<h2><a name="objectdetection">Object/Method detection</a></h2>
<pre class="prettyprint" lang-html=""><code>
    // Checks for Drag and Drop API support
    function hasDragDrop() {
        var element = document.createElement('div');
        var name = 'ondragstart';
        var isSupported = (name in element);
        if (!isSupported &amp;&amp; element.setAttribute) {
            element.setAttribute(name, 'return;');
            isSupported = typeof element[name] == 'function';
        }
        element = null;
        return isSupported;
    };
</code></pre>


<h2><a name="json">JSON</a></h2>
<pre class="prettyprint" lang-html=""><code>
// Loads a JSON file into document
function getJSON(url) {
    script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    if (url.indexOf('?') &gt; -1)
        url += '&amp;';
    else
        url += '?';
    url += 'rand=' + Math.random();
    script.setAttribute("src", url);
    document.getElementsByTagName('head')[0].appendChild(script);
};
</code></pre>


<h2><a name="module">Module</a></h2>
<pre class="prettyprint" lang-html=""><code>
// The module pattern
var PeopleStore = (function (m) {
    m.newModule = {};
    newModule.version = 0.1;

    return m;

} (PeopleStore || {}));
</code></pre> 


<h2><a name="closure">Closure</a></h2>
<pre class="prettyprint" lang-html=""><code>
// onClick with a external closure
removeBtn.onclick = post(obj.aValue)
function post(aValue) {
  return function() {
    // do somthing with aValue
  };
}


// onClick with a closure
removeBtn.onclick = function (aValue) {
    return function () {
        // do somthing with aValue
    };
} (obj.aValue)


// addEventListener with a closure
removeBtn.addEventListener('click', function (aValue) {
	return function () {
        // do somthing with aValue
    };
}(obj.aValue), false);
</code></pre>


                  
<p>I have coded and collected these functions over time. They often follow patterns that are found in the public domain. 
Everyone sits on the shoulders of others. The RegExp are copied from public sources on the web. </p>

					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t09" name="t09"></a><h1>09 : My todays top 10 most useful Javascript Functions</h1>
					<div class="tutorial__content">
<div class="art_content"><p>These are my todays top 10 Javascript functions which I gathered in more than 6 months of casually Javascript Development. Almost each of them helped out of more than one problem, so they deserve to be perpetuated here and help again. Most of these are not written by me, but by some other great programmer on the web, and I really would like to mention all of them here if I would know where I have got all of these great scripts.</p><p>&nbsp;</p><p>Have fun an use wisely.</p><h2>1. Get Elements By Class Name (getElementsByClassName)</h2><p>This is maybe one of the most used and most needed custom Javascript functions of all time. It provides a way to get all elements in a page with a certain class attribute.<br><br></p><pre><code>function getElementsByClassName(classname, node){
&nbsp; &nbsp; if (!node) {
&nbsp; &nbsp; &nbsp; &nbsp; node = document.getElementsByTagName('body')[0];
&nbsp; &nbsp; }
&nbsp;
&nbsp; &nbsp; var a = [], re = new RegExp('\\b' + classname + '\\b');
&nbsp; &nbsp; els = node.getElementsByTagName('*');
&nbsp; &nbsp; for (var i = 0, j = els.length; i &lt; j; i++) {
&nbsp; &nbsp; &nbsp; &nbsp; if (re.test(els[i].className)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.push(els[i]);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; return a;
}</code></pre><h2>2. Test if Internet Explorer is used and get its version number</h2><p>I do not know how much functions, CSS selectors or whatever - IE so often acts different or just stupid. It always requires extra work. This after all will help you to detect this nasty browser.<br><br></p><pre><code>// use the class
if(Browser.Version() &lt;8) {
&nbsp;// make crazy IE shit
}
&nbsp;
var Browser = {
&nbsp; &nbsp; Version: function(){
&nbsp; &nbsp; &nbsp; &nbsp; var version = 999; // we assume a sane browser
&nbsp; &nbsp; &nbsp; &nbsp; if (navigator.appVersion.indexOf("MSIE") != -1) 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // bah, IE again, lets downgrade version number
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; version = parseFloat(navigator.appVersion.split("MSIE")[1]);
&nbsp; &nbsp; &nbsp; &nbsp; return version;
&nbsp; &nbsp; }
}</code></pre><h2>3. Clear input-field onclick, if value is default</h2><p>This is not much of javascript, we actually call it dynamic html. It is just the standard way to present the comfortable input fields to users.<br><br></p><pre><code><input type="text" name="" value="username" onclick="if(this.value=='username') this.value='';"></code></pre><h2>4. Test if a String is not empty</h2><p>Can help to avoid a lot of common mistakes with javascript.<br><br></p><pre><code>var bpat &nbsp; &nbsp;= /\S/;
function isNonblank (s) {
&nbsp; &nbsp;return String (s).search (bpat) != -1
}</code></pre><h2>5. Function Exists</h2><p>This is a possibility in Javascript to test if a function exists (like function_exists in PHP). This can be useful in cases of debugging or when you are not sure if some required script file is loaded, for example.<br><br></p><pre><code>if(typeof yourFunctionName == 'function') {
&nbsp; &nbsp; &nbsp;yourFunctionName();
}</code></pre><h2>6. Get scroll width/height of page visitors' browser window</h2><p>A browser-safe way to get the number of pixels, which a user scrolled down the webpage currently.<br><br></p><pre><code>function getScrollXY() {
&nbsp; &nbsp; var scrOfX = 0, scrOfY = 0;
&nbsp;
&nbsp; &nbsp; if( typeof( window.pageYOffset ) == 'number' ) {
&nbsp; &nbsp; &nbsp; &nbsp; //Netscape compliant
&nbsp; &nbsp; &nbsp; &nbsp; scrOfY = window.pageYOffset;
&nbsp; &nbsp; &nbsp; &nbsp; scrOfX = window.pageXOffset;
&nbsp; &nbsp; } else if( document.body &amp;&amp; ( document.body.scrollLeft || document.body.scrollTop ) ) {
&nbsp; &nbsp; &nbsp; &nbsp; //DOM compliant
&nbsp; &nbsp; &nbsp; &nbsp; scrOfY = document.body.scrollTop;
&nbsp; &nbsp; &nbsp; &nbsp; scrOfX = document.body.scrollLeft;
&nbsp; &nbsp; } else if( document.documentElement &amp;&amp; ( document.documentElement.scrollLeft || document.documentElement.scrollTop ) ) {
&nbsp; &nbsp; &nbsp; &nbsp; //IE6 standards compliant mode
&nbsp; &nbsp; &nbsp; &nbsp; scrOfY = document.documentElement.scrollTop;
&nbsp; &nbsp; &nbsp; &nbsp; scrOfX = document.documentElement.scrollLeft;
&nbsp; &nbsp; }
&nbsp; &nbsp; return [ scrOfX, scrOfY ];
}</code></pre><h2>7. Get current size of page visitors' browser window</h2><p>A browser-safe way to get the window height and window width of the current viewers browser in pixels.<br><br></p><pre><code>function getWindowSize() {
&nbsp; &nbsp; var myWidth = 0, myHeight = 0;
&nbsp;
&nbsp; &nbsp; if( typeof( window.innerWidth ) == 'number' ) {
&nbsp; &nbsp; &nbsp; &nbsp; //Non-IE
&nbsp; &nbsp; &nbsp; &nbsp; myWidth = window.innerWidth;
&nbsp; &nbsp; &nbsp; &nbsp; myHeight = window.innerHeight;
&nbsp; &nbsp; } else if( document.documentElement &amp;&amp; ( document.documentElement.clientWidth || document.documentElement.clientHeight ) ) {
&nbsp; &nbsp; &nbsp; &nbsp; //IE 6+ in 'standards compliant mode'
&nbsp; &nbsp; &nbsp; &nbsp; myWidth = document.documentElement.clientWidth;
&nbsp; &nbsp; &nbsp; &nbsp; myHeight = document.documentElement.clientHeight;
&nbsp; &nbsp; } else if( document.body &amp;&amp; ( document.body.clientWidth || document.body.clientHeight ) ) {
&nbsp; &nbsp; &nbsp; &nbsp; //IE 4 compatible
&nbsp; &nbsp; &nbsp; &nbsp; myWidth = document.body.clientWidth;
&nbsp; &nbsp; &nbsp; &nbsp; myHeight = document.body.clientHeight;
&nbsp; &nbsp; }
&nbsp; &nbsp; return [ myWidth, myHeight ];
}</code></pre><h2>8. Scale images by setting a maximum width/height</h2><p>It is not always the best idea to scale images with javascript. But I came to several applications there this was useful though.<br><br></p><pre><code>
var images = document.getElementsByTagName("img"); // get your images somehow
scaleImages(imgs,150,150); // call the function
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
// scales the images to a maximum width/height
function scaleImages(images,maxh,maxw) {
&nbsp; 
for(i=0;i<imgs.length;i++) {=""  var="" ratio="maxh/maxw;" img="imgs[i];"  =""  if="" (img.height="" img.width=""> ratio){
&nbsp; // height is the problem
&nbsp; if (img.height &gt; maxh){
&nbsp; &nbsp;img.width = Math.round(img.width*(maxh/img.height));
&nbsp; &nbsp;img.height = maxh;
&nbsp; }
&nbsp;} else {
&nbsp; // width is the problem
&nbsp; if (img.width &gt; maxh){
&nbsp; &nbsp;img.height = Math.round(img.height*(maxw/img.width));
&nbsp; &nbsp;img.width = maxw;
&nbsp; }
&nbsp; &nbsp;}
&nbsp; &nbsp;img.setAttribute("class","showpreview ready");
&nbsp; }
}</imgs.length;i++)></code></pre><h2>9. Print Javascript Array (like print_r()-in PHP)</h2><p>A really useful function for debugging and developing with javascript. Instead of [object Object] or something similar you will see the whole contents of an array in your output.<br><br></p><pre><code>&nbsp;function dump(arr,level) {
&nbsp; var dumped_text = "";
&nbsp; if(!level) level = 0;
&nbsp; 
&nbsp; //The padding given at the beginning of the line.
&nbsp; var level_padding = "";
&nbsp; for(var j=0;j<level+1;j++) level_padding="" +=" &nbsp; &nbsp;" ;=""  ="" if(typeof(arr)="=" 'object')="" {="" array="" hashes="" objects=""  for(var="" item="" in="" arr)="" var="" value="arr[item];" if(typeof(value)="=" if="" it="" is="" an="" array,=""  dumped_text="" "'"="" "'="" ...\n";="" }="" else=""> \"" + value + "\"\n";
&nbsp; &nbsp; }
&nbsp; &nbsp;}
&nbsp; } else { //Stings/Chars/Numbers etc.
&nbsp; &nbsp;dumped_text = "===&gt;"+arr+"&lt;===("+typeof(arr)+")";
&nbsp; }
&nbsp; return dumped_text;
&nbsp;}</level+1;j++)></code></pre><h2>10. XML2Array (parse xml to javascript array)</h2><p>For the special case of reading XML with Javascript. But very useful, when it comes to the case. It is much easier to handle a huge array in Javascript than reading lots of data from a complex XML-file. Maybe there is a tiny disadvantage concerning speed, but I think it is worth that.<br><br></p><pre><code>//////////////////////////////////// xml2array() ////////////////////////////////////////
// See http://www.openjs.com/scripts/xml_parser/
var not_whitespace = new RegExp(/[^\s]/|&gt;); //This can be given inside the funciton - I made it a global variable to make the scipt a little bit faster.
var parent_count;
//Process the xml data
function xml2array(xmlDoc,parent_count) {
&nbsp;var arr;
&nbsp;var parent = "";
&nbsp;parent_count = parent_count || new Object;

&nbsp;var attribute_inside = 0; /*:CONFIG: Value - 1 or 0
&nbsp;* If 1, Value and Attribute will be shown inside the tag - like this...
&nbsp;* For the XML string...
&nbsp;* <guid ispermalink="true">http://www.bin-co.com/</guid>
&nbsp;* The resulting array will be...
&nbsp;* array['guid']['value'] = "http://www.bin-co.com/";
&nbsp;* array['guid']['attribute_isPermaLink'] = "true";
&nbsp;* 
&nbsp;* If 0, the value will be inside the tag but the attribute will be outside - like this... 
&nbsp;* For the same XML String the resulting array will be...
&nbsp;* array['guid'] = "http://www.bin-co.com/";
&nbsp;* array['attribute_guid_isPermaLink'] = "true";
&nbsp;*/

&nbsp;if(xmlDoc.nodeName &amp;&amp; xmlDoc.nodeName.charAt(0) != "#") {
&nbsp; if(xmlDoc.childNodes.length &gt; 1) { //If its a parent
&nbsp; &nbsp;arr = new Object;
&nbsp; &nbsp;parent = xmlDoc.nodeName;
&nbsp; &nbsp;
&nbsp; }
&nbsp;}
&nbsp;var value = xmlDoc.nodeValue;
&nbsp;if(xmlDoc.parentNode &amp;&amp; xmlDoc.parentNode.nodeName &amp;&amp; value) {
&nbsp; if(not_whitespace.test(value)) {//If its a child
&nbsp; &nbsp;arr = new Object;
&nbsp; &nbsp;arr[xmlDoc.parentNode.nodeName] = value;
&nbsp; }
&nbsp;}

&nbsp;if(xmlDoc.childNodes.length) {
&nbsp; if(xmlDoc.childNodes.length == 1) { //Just one item in this tag.
&nbsp; &nbsp;arr = xml2array(xmlDoc.childNodes[0],parent_count); //:RECURSION:
&nbsp; } else { //If there is more than one childNodes, go thru them one by one and get their results.
&nbsp; &nbsp;var index = 0;

&nbsp; &nbsp;for(var i=0; i<xmldoc.childnodes.length; i++)="" {="" go="" thru="" all="" the="" child="" nodes.=""  ="" var="" temp="xml2array(xmlDoc.childNodes[i],parent_count);" :recursion:="" if(temp)=""  var="" assoc="false;" arr_count="0;"  for(key="" in="" temp)="" if(isnan(key))="" arr_count++;="" if(arr_count="">2) break;//We just need to know wether it is a single value array or not
&nbsp; &nbsp; &nbsp;}

&nbsp; &nbsp; &nbsp;if(assoc &amp;&amp; arr_count == 1) {
&nbsp; &nbsp; &nbsp; if(arr[key]) { &nbsp;//If another element exists with the same tag name before,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;put it in a numeric array.
&nbsp; &nbsp; &nbsp; &nbsp;//Find out how many time this parent made its appearance
&nbsp; &nbsp; &nbsp; &nbsp;if(!parent_count || !parent_count[key]) {
&nbsp; &nbsp; &nbsp; &nbsp; parent_count[key] = 0;

&nbsp; &nbsp; &nbsp; &nbsp; var temp_arr = arr[key];
&nbsp; &nbsp; &nbsp; &nbsp; arr[key] = new Object;
&nbsp; &nbsp; &nbsp; &nbsp; arr[key][0] = temp_arr;
&nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp;parent_count[key]++;
&nbsp; &nbsp; &nbsp; &nbsp;arr[key][parent_count[key]] = temp[key]; //Members of of a numeric array
&nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp;parent_count[key] = 0;
&nbsp; &nbsp; &nbsp; &nbsp;arr[key] = temp[key];
&nbsp; &nbsp; &nbsp; &nbsp;if(xmlDoc.childNodes[i].attributes &amp;&amp; xmlDoc.childNodes[i].attributes.length) {
&nbsp; &nbsp; &nbsp; &nbsp; for(var j=0; j</xmldoc.childnodes.length;></code></pre></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t10" name="t10"></a><h1>10 : 12 Extremely Useful Hacks for JavaScript</h1>
					<span>https://blog.jscrambler.com/12-extremely-useful-hacks-for-javascript/</span>
					<div class="tutorial__content">



<p>In this post I will share <strong>12 extremely useful hacks for JavaScript</strong>. These hacks reduce the code and will help you to run optimized code. So let's start hacking!  </p>

<h2 id="1convertingtobooleanusingoperator">1) Converting to boolean using <strong>!!</strong> operator</h2>

<p>Sometimes we need to check if some variable exists or if it has a valid value, to consider them as <em>true value</em>. For do this kind of validation, you can use the <code>!!</code><em>(Double negation operator)</em> a simple <code>!!variable</code>, which will automatically convert any kind of data to boolean and this variable will return <code>false</code> only if it has some of these values: <code>0</code>, <code>null</code>, <code>""</code>, <code>undefined</code> or <code>NaN</code>, otherwise it will return <code>true</code>. To understand it in practice, take a look this simple example:</p>

<pre><code class="language- javascript">function Account(cash) {  
    this.cash = cash;
    this.hasMoney = !!cash;
}
var account = new Account(100.50);  
console.log(account.cash); // 100.50  
console.log(account.hasMoney); // true

var emptyAccount = new Account(0);  
console.log(emptyAccount.cash); // 0  
console.log(emptyAccount.hasMoney); // false  
</code></pre>

<p>In this case, if an <code>account.cash</code> value is greater than zero, the <code>account.hasMoney</code> will be true.  </p>

<h2 id="2convertingtonumberusingoperator">2) Converting to number using <strong>+</strong> operator</h2>

<p>This magic is awesome! And it's very simple to be done, but it only works with string numbers, otherwise it will return <code>NaN</code><em>(Not a Number)</em>. Have a look on this example:</p>

<pre><code class="language- javascript">function toNumber(strNumber) {  
    return +strNumber;
}
console.log(toNumber("1234")); // 1234  
console.log(toNumber("ACB")); // NaN  
</code></pre>

<p>This magic will work with <code>Date</code> too and, in this case, it will return the timestamp number:</p>

<pre><code class="language- javascript">console.log(+new Date()) // 1461288164385  
</code></pre>

<h2 id="3shortcircuitsconditionals">3) Short-circuits conditionals</h2>

<p>If you see a similar code:</p>

<pre><code class="language- javascript">if (conected) {  
    login();
}
</code></pre>

<p>You can shorten it by using the combination of a variable (which will be verified) and a function using the <code>&amp;&amp;</code> (AND operator) between both. For example, the previous code can become smaller in one line:</p>

<pre><code class="language- javascript">conected &amp;&amp; login();  
</code></pre>

<p>You can do the same to check if some attribute or function exists in the object. Similar to the below code:</p>

<pre><code class="language- javascript">user &amp;&amp; user.login();  
</code></pre>

<h2 id="4defaultvaluesusingoperator">4) Default values using <strong>||</strong> operator</h2>

<p>Today in ES6 there is the default argument feature. In order to simulate this feature in old browsers you can use the <code>||</code> (OR operator) by including the default value as a second parameter to be used. If the first parameter returns <code>false</code> the second one will be used as a default value. See this example:</p>

<pre><code class="language- javascript">function User(name, age) {  
    this.name = name || "Oliver Queen";
    this.age = age || 27;
}
var user1 = new User();  
console.log(user1.name); // Oliver Queen  
console.log(user1.age); // 27

var user2 = new User("Barry Allen", 25);  
console.log(user2.name); // Barry Allen  
console.log(user2.age); // 25  
</code></pre>

<h2 id="5cachingthearraylengthintheloop">5) Caching the <code>array.length</code> in the loop</h2>

<p>This tip is very simple and causes a huge impact on the performance when processing large arrays during a loop. Basically, almost everybody writes this synchronous <code>for</code> to iterate an array:</p>

<pre><code class="language- javascript">for (var i = 0; i &lt; array.length; i++) {  
    console.log(array[i]);
}
</code></pre>

<p>If you work with smaller arrays – it's fine, but if you process large arrays, this code will recalculate the size of array in every iteration of this loop and this will cause a bit of delays. To avoid it, you can cache the <code>array.length</code> in a variable to use it instead of invoking the <code>array.length</code> every time during the loop:</p>

<pre><code class="language- javascript">var length = array.length;  
for (var i = 0; i &lt; length; i++) {  
    console.log(array[i]);
}
</code></pre>

<p>To make it smaller, just write this code:</p>

<pre><code class="language- javascript">for (var i = 0, length = array.length; i &lt; length; i++) {  
    console.log(array[i]);
}
</code></pre>

<h2 id="6detectingpropertiesinanobject">6) Detecting properties in an object</h2>

<p>This trick is very useful when you need to check if some attribute exists and it avoids running undefined functions or attributes. If you are planning to write cross-browser code, probably you will use this technique too. For example, let's imagine that you need to write code that is compatible with the old Internet Explorer 6 and you want to use the <code>document.querySelector()</code>, to get some elements by their ids. However, in this browser this function doesn't exist, so to check the existence of this function you can use the <code>in</code> operator, see this example:</p>

<pre><code class="language- javascript">if ('querySelector' in document) {  
    document.querySelector("#id");
} else {
    document.getElementById("id");
}
</code></pre>

<p>In this case, if there is no <code>querySelector</code> function in the <code>document</code> object, we can use the <code>document.getElementById()</code> as fallback.</p>

<h2 id="7gettingthelastiteminthearray">7) Getting the last item in the array</h2>

<p>The <code>Array.prototype.slice(begin, end)</code> has the power to cut arrays when you set the <code>begin</code> and <code>end</code> arguments. But if you don't set the <code>end</code> argument, this function will automatically set the max value for the array. I think that few people know that this function can accept negative values, and if you set a negative number as <code>begin</code> argument you will get the last elements from the array:</p>

<pre><code class="language- javascript">var array = [1, 2, 3, 4, 5, 6];  
console.log(array.slice(-1)); // [6]  
console.log(array.slice(-2)); // [5,6]  
console.log(array.slice(-3)); // [4,5,6]  
</code></pre>

<h2 id="8arraytruncation">8) Array truncation</h2>

<p>This technique can lock the array's size, this is very useful to delete some elements of the array based on the number of elements you want to set. For example, if you have an array with 10 elements, but you want to get only the first five elements, you can truncate the array, making it smaller by setting the <code>array.length = 5</code>. See this example:</p>

<pre><code class="language- javascript">var array = [1, 2, 3, 4, 5, 6];  
console.log(array.length); // 6  
array.length = 3;  
console.log(array.length); // 3  
console.log(array); // [1,2,3]  
</code></pre>

<h2 id="9replaceall">9) Replace all</h2>

<p>The <code>String.replace()</code> function allows using String and Regex to replace strings, natively this function only replaces the first occurrence. But you can simulate a <code>replaceAll()</code> function by using the <code>/g</code> at the end of a Regex:</p>

<pre><code class="language- javascript">var string = "john john";  
console.log(string.replace(/hn/, "ana")); // "joana john"  
console.log(string.replace(/hn/g, "ana")); // "joana joana"  
</code></pre>

<h2 id="10mergingarrays">10) Merging arrays</h2>

<p>If you need to merge two arrays you can use the <code>Array.concat()</code> function:</p>

<pre><code class="language- javascript">var array1 = [1, 2, 3];  
var array2 = [4, 5, 6];  
console.log(array1.concat(array2)); // [1,2,3,4,5,6];  
</code></pre>

<p>However, this function is not the most suitable to merge large arrays because it will consume a lot of memory by creating a new array. In this case, you can use <code>Array.push.apply(arr1, arr2)</code> which instead creates a new array – it will merge the second array in the first one reducing the memory usage:</p>

<pre><code class="language- javascript">var array1 = [1, 2, 3];  
var array2 = [4, 5, 6];  
console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];  
</code></pre>

<h2 id="11convertingnodelisttoarrays">11) Converting NodeList to Arrays</h2>

<p>If you run the <code>document.querySelectorAll("p")</code> function, it will probably return an array of DOM elements, the NodeList object. But this object doesn't have all array's functions, like: <code>sort()</code>, <code>reduce()</code>, <code>map()</code>, <code>filter()</code>. In order to enable these and many other native array's functions you need to convert NodeList into Arrays. To run this technique just use this function: <code>[].slice.call(elements)</code>:</p>

<pre><code class="language- javascript">var elements = document.querySelectorAll("p"); // NodeList  
var arrayElements = [].slice.call(elements); // Now the NodeList is an array  
var arrayElements = Array.from(elements); // This is another way of converting NodeList to Array  
</code></pre>

<h2 id="12shufflingarrayselements">12) Shuffling array's elements</h2>

<p>To shuffle the array's elements without using any external library like <em>Lodash</em>, just run this magic trick:</p>

<pre><code class="language- javascript">var list = [1, 2, 3];  
console.log(list.sort(function() {  
    return Math.random() - 0.5
})); // [2,1,3]
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Now you learned some useful JS hacks which are largely used to minify JavaScript code and some of these tricks are used in many popular JS frameworks like Lodash, Underscore.js, Strings.js, among others. If you want to go even deeper and learn more about how you can minify your code even more and even protect it from prying eyes talk to <a href="support@jscrambler.com">us</a>. I hope you enjoyed this post and if you know other JS hacks, please let us know!</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t11" name="t11"></a><h1>11 : 45 Useful JavaScript Tips, Tricks and Best Practices</h1>
					<div class="tutorial__content">
<span>https://modernweb.com/45-useful-javascript-tips-tricks-and-best-practices/</span>
<p>As you know, JavaScript is the number one programming language in the world, the language of the web, of mobile hybrid apps (like <a href="http://phonegap.com/">PhoneGap</a> or <a href="http://www.appcelerator.com/">Appcelerator</a>), of the server side (like <a href="http://nodejs.org">NodeJS</a> or <a href="http://wakanda.org">Wakanda</a>) and has many other implementations. It's also the starting point for many new developers to the world of programming, as it can be used to display a simple alert in the web browser but also to control a robot (using <a href="http://nodebots.io/">nodebot</a>, or <a href="http://semu.github.io/noduino/">nodruino</a>). The developers who master JavaScript and write organized and performant code have become the most sought after in the job market.</p>
<p>In this article, I'll share a set of JavaScript tips, tricks and best practices that should be known by all JavaScript developers regardless of their browser/engine or the SSJS (Server Side JavaScript) interpreter.</p>
<p>Note that the code snippets in this article have been tested in the latest Google Chrome version 30, which uses the V8 JavaScript Engine (V8 3.20.17.15).</p>
<p><strong>1 – Don't forget <code>var</code> keyword when assigning a variable's value for the first time.</strong></p>
<p>Assignment to an undeclared variable automatically results in a global variable being created. Avoid global variables.</p>
<p><strong>2 – use <code>===</code> instead of <code>==</code></strong></p>
<p>The <code>==</code> (or <code>!=</code>) operator performs an automatic type conversion if needed. The <code>===</code> (or <code>!==</code>) operator will not perform any conversion. It compares the value and the type, which could be considered faster than <code>==</code>.</p>
<pre><code class="language-javascript">[10] === 10    // is false
[10]  == 10    // is true
'10' == 10     // is true
'10' === 10    // is false
 []   == 0     // is true
 [] ===  0     // is false
 '' == false   // is true but true == "a" is false
 '' ===   false // is false </code></pre>
<p><strong>3 – <code>undefined</code>, <code>null</code>, 0, <code>false</code>, <code>NaN</code>, <code>''</code> (empty string) are all falsy.</strong><br>
<strong>4 – Use Semicolons for line termination</strong></p>
<p>The use of semi-colons for line termination is a good practice. You won't be warned if you forget it, because in most cases it will be inserted by the JavaScript parser. For more details about why you should use semi-colons, take a look to this artice: <a href="http://davidwalsh.name/javascript-semicolons">http://davidwalsh.name/javascript-semicolons</a>.</p>
<p><strong>5 – Create an object constructor</strong></p>
<pre><code class="language-javascript">function Person(firstName, lastName){
    this.firstName =  firstName;
    this.lastName = lastName;        
}  

var Saad = new Person("Saad", "Mousliki");</code></pre>
<p><strong>6 – Be careful when using <code>typeof</code>, <code>instanceof</code> and <code>constructor</code>.</strong></p>
<ul>
<li><em>typeof</em> : a JavaScript unary operator used to  return a string that represents the primitive type of a variable,  don't forget that <code>typeof null</code> will return "object", and for the majority of object types (Array, Date, and others) will return also "object".</li>
<li><em>constructor</em> : is a property of the internal prototype property, which could be overridden by code.</li>
<li><em>instanceof</em> : is another JavaScript operator that check in all the prototypes chain the constructor it returns true if it's found and false if not.</li>
</ul>
<pre><code class="language-javascript">var arr = ["a", "b", "c"];
typeof arr;   // return "object" 
arr  instanceof Array // true
arr.constructor();  //[]
</code></pre>
<p><strong>7 – Create a Self-calling Function</strong></p>
<p>This is often called a Self-Invoked Anonymous Function or Immediately Invoked Function Expression (IIFE). It is a function that executes automatically when you create it, and has the following form:</p>
<pre><code class="language-javascript">(function(){
    // some private code that will be executed automatically
})();  
(function(a,b){
    var result = a+b;
    return result;
})(10,20)</code></pre>
<p><strong>8 – Get a random item from an array</strong></p>
<pre><code class="language-javascript">var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];

var  randomItem = items[Math.floor(Math.random() * items.length)];</code></pre>
<p><strong>9 – Get a random number in a specific range</strong></p>
<p>This code snippet can be useful when trying to generate fake data for testing purposes, such as a salary between min and max.</p>
<pre><code class="language-javascript">var x = Math.floor(Math.random() * (max - min + 1)) + min;</code></pre>
<p><strong>10 – Generate an array of numbers with numbers from 0 to max</strong></p>
<pre><code class="language-javascript">var numbersArray = [] , max = 100;

for( var i=1; numbersArray.push(i++) &lt; max;);  // numbers = [1,2,3 ... 100] </code></pre>
<p><strong>11 – Generate a random set of alphanumeric characters</strong></p>
<pre><code class="language-javascript">function generateRandomAlphaNum(len) {
    var rdmString = "";
    for( ; rdmString.length &lt; len; rdmString  += Math.random().toString(36).substr(2));
    return  rdmString.substr(0, len);

}
</code></pre>
<p><strong>12 – Shuffle an array of numbers</strong></p>
<pre><code class="language-javascript">var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];
numbers = numbers.sort(function(){ return Math.random() - 0.5});
/* the array numbers will be equal for example to [120, 5, 228, -215, 400, 458, -85411, 122205]  */</code></pre>
<p>A better option could be to implement a random sort order by code (e.g. : Fisher-Yates shuffle), than using the native sort JavaScript function. For more details take a look to <a href="http://stackoverflow.com/questions/962802/is-it-correct-to-use-javascript-array-sort-method-for-shuffling/962890#962890">this discussion</a>.</p>
<p><strong>13 – A string trim function</strong></p>
<p>The classic trim function of Java, C#, PHP and many other language that remove whitespace from a string doesn't exist in JavaScript, so we could add it to the <code>String</code> object.</p>
<pre><code class="language-javascript">String.prototype.trim = function(){return this.replace(/^s+|s+$/g, "");};  </code></pre>
<p>A native implementation of the trim() function is available in the recent JavaScript engines.</p>
<p><strong>14 – Append an array to another array</strong></p>
<pre><code class="language-javascript">var array1 = [12 , "foo" , {name "Joe"} , -2458];

var array2 = ["Doe" , 555 , 100];
Array.prototype.push.apply(array1, array2);
/* array1 will be equal to  [12 , "foo" , {name "Joe"} , -2458 , "Doe" , 555 , 100] */</code></pre>
<p><strong>15 – Transform the <code>arguments</code> object into an array</strong></p>
<pre><code class="language-javascript">var argArray = Array.prototype.slice.call(arguments);</code></pre>
<p><strong>16 – Verify that a given argument is a number</strong></p>
<pre><code class="language-javascript">function isNumber(n){
    return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
}</code></pre>
<p><strong>17 – Verify that a given argument is an array</strong></p>
<pre><code class="language-javascript">function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]' ;
}</code></pre>
<p>Note that if the toString() method is overridden, you will not get the expected result using this trick.</p>
<p>Or use…</p>
<pre><code class="language-javascript">Array.isArray(obj); // its a new Array method</code></pre>
<p>You could also use <code>instanceof</code> if you are not working with multiple frames. However, if you have many contexts, you will get a wrong result.</p>
<pre><code class="language-javascript">var myFrame = document.createElement('iframe');
document.body.appendChild(myFrame);

var myArray = window.frames[window.frames.length-1].Array;
var arr = new myArray(a,b,10); // [a,b,10]  

// instanceof will not work correctly, myArray loses his constructor 
// constructor is not shared between frames
arr instanceof Array; // false</code></pre>
<p><strong>18 – Get the max or the min in an array of numbers</strong></p>
<pre><code class="language-javascript">var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; 
var maxInNumbers = Math.max.apply(Math, numbers); 
var minInNumbers = Math.min.apply(Math, numbers);</code></pre>
<p><strong>19 – Empty an array</strong></p>
<pre><code class="language-javascript">var myArray = [12 , 222 , 1000 ];  
myArray.length = 0; // myArray will be equal to [].</code></pre>
<p><strong>20 – Don't use delete to remove an item from array</strong></p>
<p>Use <code>splice</code> instead of using <code>delete</code> to delete an item from an array. Using <code>delete</code> replaces the item with <code>undefined</code> instead of the removing it from the array.</p>
<p>Instead of…</p>
<pre><code class="language-javascript">var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; 
items.length; // return 11 
delete items[3]; // return true 
items.length; // return 11 
/* items will be equal to [12, 548, "a", undefined × 1, 5478, "foo", 8852, undefined × 1, "Doe", 2154,       119]   */</code></pre>
<p>Use…</p>
<pre><code class="language-javascript">var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; 
items.length; // return 11 
items.splice(3,1) ; 
items.length; // return 10 
/* items will be equal to [12, 548, "a", 5478, "foo", 8852, undefined × 1, "Doe", 2154,       119]   */</code></pre>
<p>The delete method should be used to delete an object property.</p>
<p><strong>21 – Truncate an array using length</strong></p>
<p>Like the previous example of emptying an array, we truncate it using the <code>length</code> property.</p>
<pre><code class="language-javascript">var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  
myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].</code></pre>
<p>As a bonus, if you set the array length to a higher value, the length will be changed and new items will be added with <code>undefined</code> as a value. The array length is not a read only property.</p>
<pre><code class="language-javascript">myArray.length = 10; // the new array length is 10 
myArray[myArray.length - 1] ; // undefined</code></pre>
<p><strong>22 – Use logical AND/ OR for conditions</strong></p>
<pre><code class="language-javascript">var foo = 10;  
foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething(); 
foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething();</code></pre>
<p>The logical OR could also be used to set a default value for function argument.</p>
<pre><code class="language-javascript">function doSomething(arg1){ 
    arg1 = arg1 || 10; // arg1 will have 10 as a default value if it's not already set
}</code></pre>
<p><strong>23 – Use the map() function method to loop through an array's items</strong></p>
<pre><code class="language-javascript">var squares = [1,2,3,4].map(function (val) {  
    return val * val;  
}); 
// squares will be equal to [1, 4, 9, 16] </code></pre>
<p><strong>24 – Rounding number to N decimal place</strong></p>
<pre><code class="language-javascript">var num =2.443242342;
num = num.toFixed(4);  // num will be equal to 2.4432</code></pre>
<p>NOTE : the <code>toFixed()</code> function returns a string and not a number.</p>
<p><strong>25 – Floating point problems</strong></p>
<pre><code class="language-javascript">0.1 + 0.2 === 0.3 // is false 
9007199254740992 + 1 // is equal to 9007199254740992  
9007199254740992 + 2 // is equal to 9007199254740994</code></pre>
<p>Why does this happen? 0.1 +0.2 is equal to 0.30000000000000004. What you need to know is that all JavaScript numbers are floating points represented internally in 64 bit binary according to the IEEE 754 standard. For more explanation, take a look to <a href="http://www.2ality.com/2012/04/number-encoding.html">this blog post</a>.</p>
<p>You can use <code>toFixed()</code> and <code>toPrecision()</code> to resolve this problem.</p>
<p><strong>26 – Check the properties of an object when using a for-in loop</strong></p>
<p>This code snippet could be useful in order to avoid iterating through the properties from the object's prototype.</p>
<pre><code class="language-javascript">for (var name in object) {  
    if (object.hasOwnProperty(name)) { 
        // do something with name                    
    }  
}</code></pre>
<p><strong>27 – Comma operator</strong></p>
<pre><code class="language-javascript">var a = 0; 
var b = ( a++, 99 ); 
console.log(a);  // a will be equal to 1 
console.log(b);  // b is equal to 99</code></pre>
<p><strong>28 – Cache variables that need calculation or querying</strong></p>
<p>In the case of a jQuery selector, we could cache the DOM element.</p>
<pre><code class="language-javascript">var navright = document.querySelector('#right'); 
var navleft = document.querySelector('#left'); 
var navup = document.querySelector('#up'); 
var navdown = document.querySelector('#down');</code></pre>
<p><strong>29 – Verify the argument before passing it to <code>isFinite()</code></strong></p>
<pre><code class="language-javascript">isFinite(0/0) ; // false 
isFinite("foo"); // false 
isFinite("10"); // true 
isFinite(10);   // true 
isFinite(undefined);  // false 
isFinite();   // false 
isFinite(null);  // true  !!! </code></pre>
<p><strong>30 – Avoid negative indexes in arrays</strong></p>
<pre><code class="language-javascript">var numbersArray = [1,2,3,4,5]; 
var from = numbersArray.indexOf("foo") ;  // from is equal to -1 
numbersArray.splice(from,2);    // will return [5]</code></pre>
<p>Make sure that the arguments passed to <code>splice</code> are not negative.</p>
<p><strong>31 – Serialization and deserialization (working with JSON)</strong></p>
<pre><code class="language-javascript">var person = {name :'Saad', age : 26, department : {ID : 15, name : "R&amp;D"} }; 
var stringFromPerson = JSON.stringify(person); 
/* stringFromPerson is equal to "{"name":"Saad","age":26,"department":{"ID":15,"name":"R&amp;D"}}"   */ 
var personFromString = JSON.parse(stringFromPerson);  
/* personFromString is equal to person object  */</code></pre>
<p><strong>32 – Avoid the use of <code>eval()</code> or the <code>Function</code> constructor</strong></p>
<p>Use of <code>eval</code> or the <code>Function</code> constructor are expensive operations as each time they are called script engine must convert source code to executable code.</p>
<pre><code class="language-javascript">var func1 = new Function(functionCode);
var func2 = eval(functionCode);</code></pre>
<p><strong>33 – Avoid using <code>with()</code> (The good part)</strong></p>
<p>Using <code>with()</code> inserts a variable at the global scope. Thus, if another variable has the same name it could cause confusion and overwrite the value.</p>
<p><strong>34 – Avoid using for-in loop for arrays</strong></p>
<p>Instead of using…</p>
<pre><code class="language-javascript">var sum = 0;  
for (var i in arrayNumbers) {  
    sum += arrayNumbers[i];  
}</code></pre>
<p>…it's better to use…</p>
<pre><code class="language-javascript">var sum = 0;  
for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) {  
    sum += arrayNumbers[i];  
}</code></pre>
<p>As a bonus, the instantiation of <code>i</code> and <code>len</code> is executed once because it's in the first statement of the for loop. Thsi is faster than using…</p>
<pre><code class="language-javascript">for (var i = 0; i &lt; arrayNumbers.length; i++)</code></pre>
<p>Why? The length of the array <code>arrayNumbers</code> is recalculated every time the loop iterates.</p>
<p>NOTE : the issue of recalculating the length in each iteration was fixed in the latest JavaScript engines.</p>
<p><strong>35 – Pass functions, not strings, to <code>setTimeout()</code> and <code>setInterval()</code></strong></p>
<p>If you pass a string into <code>setTimeout()</code> or <code>setInterval()</code>, the string will be evaluated the same way as with <code>eval</code>, which is slow. Instead of using…</p>
<pre><code class="language-javascript">setInterval('doSomethingPeriodically()', 1000);  
setTimeout('doSomethingAfterFiveSeconds()', 5000);</code></pre>
<p>…use…</p>
<pre><code class="language-javascript">setInterval(doSomethingPeriodically, 1000);  
setTimeout(doSomethingAfterFiveSeconds, 5000);</code></pre>
<p><strong>36 – Use a switch/case statement instead of a series of if/else</strong></p>
<p>Using switch/case is faster when there are more than 2 cases, and it is more elegant (better organized code). Avoid using it when you have more than 10 cases.</p>
<p><strong>37 – Use switch/case statement with numeric ranges</strong></p>
<p>Using a switch/case statement with numeric ranges is possible with this trick.</p>
<pre><code class="language-javascript">function getCategory(age) {  
    var category = "";  
    switch (true) {  
        case isNaN(age):  
            category = "not an age";  
            break;  
        case (age &gt;= 50):  
            category = "Old";  
            break;  
        case (age &lt;= 20):  
            category = "Baby";  
            break;  
        default:  
            category = "Young";  
            break;  
    };  
    return category;  
}  
getCategory(5);  // will return "Baby"</code></pre>
<p><strong>38 – Create an object whose prototype is a given object</strong></p>
<p>It's possible to write a function that creates an object whose prototype is the given argument like this…</p>
<pre><code class="language-javascript">function clone(object) {  
    function OneShotConstructor(){}; 
    OneShotConstructor.prototype= object;  
    return new OneShotConstructor(); 
} 
clone(Array).prototype ;  // []</code></pre>
<p><strong>39 – An HTML escaper function</strong></p>
<pre><code class="language-javascript">function escapeHTML(text) {  
    var replacements= {"&lt;": "&amp;lt;", "&gt;": "&amp;gt;","&amp;": "&amp;amp;", """: "&amp;quot;"};                      
    return text.replace(/[&lt;&gt;&amp;"]/g, function(character) {  
        return replacements[character];  
    }); 
}</code></pre>
<p><strong>40 – Avoid using try-catch-finally inside a loop</strong></p>
<p>The try-catch-finally construct creates a new variable in the current scope at runtime each time the catch clause is executed where the caught exception object is assigned to a variable.</p>
<p>Instead of using…</p>
<pre><code class="language-javascript">var object = ['foo', 'bar'], i;  
for (i = 0, len = object.length; i &lt;len; i++) {  
    try {  
        // do something that throws an exception 
    }  
    catch (e) {   
        // handle exception  
    } 
}</code></pre>
<p>…use…</p>
<pre><code class="language-javascript">var object = ['foo', 'bar'], i;  
try { 
    for (i = 0, len = object.length; i &lt;len; i++) {  
        // do something that throws an exception 
    } 
} 
catch (e) {   
    // handle exception  
} </code></pre>
<p><strong>41 – Set timeouts to <code class="language-javascript">XMLHttpRequests</code></strong></p>
<p>You could abort the connection if an XHR takes a long time (for example, due to a network issue), by using <code>setTimeout()</code> with the XHR call.</p>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest (); 
xhr.onreadystatechange = function () {  
    if (this.readyState == 4) {  
        clearTimeout(timeout);  
        // do something with response data 
    }  
}  
var timeout = setTimeout( function () {  
    xhr.abort(); // call error callback  
}, 60*1000 /* timeout after a minute */ ); 
xhr.open('GET', url, true);  

xhr.send();</code></pre>
<p>As a bonus, you should generally avoid synchronous XHR calls completely.</p>
<p><strong>42 – Deal with WebSocket timeout</strong></p>
<p>Generally when a WebSocket connection is established, a server could time out your connection after 30 seconds of inactivity. The firewall could also time out the connection after a period of inactivity.</p>
<p>To deal with the timeout issue you could send an empty message to the server periodically. To do this, add these two functions to your code: one to keep alive the connection and the other one to cancel the keep alive. Using this trick, you'll control the timeout.</p>
<p>Add a <code>timerID</code>…</p>
<pre><code class="language-javascript">var timerID = 0; 
function keepAlive() { 
    var timeout = 15000;  
    if (webSocket.readyState == webSocket.OPEN) {  
        webSocket.send('');  
    }  
    timerId = setTimeout(keepAlive, timeout);  
}  
function cancelKeepAlive() {  
    if (timerId) {  
        cancelTimeout(timerId);  
    }  
}</code></pre>
<p>The <code>keepAlive()</code> function should be added at the end of the <code>onOpen()</code> method of the webSocket connection and the <code>cancelKeepAlive()</code> at the end of the <code>onClose()</code> method.</p>
<p><strong>43 – Keep in mind that <a href="http://dev.opera.com/articles/view/efficient-javascript/?page=2#primitiveoperator">primitive operations can be faster than function calls</a>. Use <a href="http://vanilla-js.com/">VanillaJS</a>.</strong></p>
<p>For example, instead of using…</p>
<pre><code class="language-javascript">var min = Math.min(a,b); 
A.push(v);</code></pre>
<p>…use…</p>
<pre><code class="language-javascript">var min = a &lt; b ? a : b; 
A[A.length] = v;</code></pre>
<p><strong>44 – Don't forget to use a code beautifier when coding. Use JSLint and minification (JSMin, for example) before going live.</strong></p>
<p><strong>45 – JavaScript is awesome: <a href="http://stackoverflow.com/questions/11246/best-resources-to-learn-javascript">Best Resources To Learn JavaScript</a></strong></p>
<ul>
<li>Code Academy JavaScript tracks: <a href="http://www.codecademy.com/tracks/javascript">http://www.codecademy.com/tracks/javascript</a></li>
<li>Eloquent JavaScript by Marjin Haverbeke: <a href="http://eloquentjavascript.net/">http://eloquentjavascript.net/</a></li>
<li>Advanced JavaScript by John Resig: <a href="http://ejohn.org/apps/learn/">http://ejohn.org/apps/learn/</a></li>
</ul>
<h2>Conclusion</h2>
<p>I know that there are many other tips, tricks and best practices, so if you have any ones to add or if you have any feedback or corrections to the ones that I have shared, please adda comment.</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t12" name="t12"></a><h1>12 : JavaScript Architecture for the 23rd Century</h1>
					<span>https://modernweb.com/javascript-architecture-23rd-century/</span>
					<div class="tutorial__content">

<blockquote><p>Jonathan discusses JavaScript architecture patterns of the 23rd century and what the future of JavaScript holds for the 24th century."</p></blockquote>
<p>JavaScript applications have grown in size and complexity for the last several years. More and more single page applications have hit the market, and demands for that type of experience have increased to the point where even Google finally decided to <a href="http://googlewebmastercentral.blogspot.com/2014/05/understanding-web-pages-better.html">render JavaScript</a> when it crawls pages.</p>
<p>This demand for SPA type applications has made JavaScript architecture increasingly important. JavaScript, being a dynamic language, you have to go the extra mile to ensure that the code is written in a maintainable fashion and to avoid spaghetti code.</p>
<p>For a long time it seemed like it was ok to just use a single file full of jQuery selectors and event handlers. This is just not a sustainable pattern. The Modern Web that we are entering here in the 23rd century demands a more thought out, and architected approach.</p>
<h2>Architecture Patterns</h2>
<p>An architectural pattern is not something that you sit down and write. No one sits at their desk and thinks about how to write a new shiny pattern. A pattern is something that comes about as a discovery. Some problem is solved potentially multiple times and a pattern is extracted from the solution(s).</p>
<h3>Constructor</h3>
<p>First of all let's take a step back into some native JavaScript functionality that has been there for years, the constructor pattern.</p>
<pre><code class="language-javascript">function Starship() {}
</code></pre>
<p>Every function you declare in JavaScript can be used as a <strong>constructor</strong> to create an instance. This allows you to create reusable functions.</p>
<pre><code class="language-javascript">var enterprise = new Starship(),
IKSBuruk = new Starship();
</code></pre>
<p>You can modify the original function to take arguments to help describe the instance better. You can assign the arguments to properties on <code>this</code> which will refer to the instance of the constructor.</p>
<pre><code class="language-javascript">function Starship(owner, operator, type) {
  this.owner = owner;
  this.operator = operator;
  this.type = type;
}

var enterprise = new Starship('Federation', 'Star Fleet', 'Class 1 Heavy Cruiser'),
birdOfprey = new Starship('Klingon Empire', 'Klingon Imperial Fleet', 'Klingon Warship');
</code></pre>
<p>You can also utilize a built in feature of JavaScript constructors called the <code>prototype</code>. The <code>prototype</code> is simply an object. On it, you define properties and methods that will be added to every instance of a constructor.</p>
<pre><code class="language-javascript">function Starship(owner, operator, type, weapons) {
  /* ... */
  this.weapons = weapons;
}

Starship.prototype.fire = function(weapon) {
  this.weapons[weapon].launch();
};

function PhotonTorpedoSystem() {}
  PhotonTorpedoSystem.prototype.launch = function() {
  console.log('launching torpedos');
};

var torpedos = new PhotonTorpedoSystem(),

var weaponSystem = {
  torpedos: torpedos;
};

var enterprise = new Starship(
  'Federation',
  'Star Fleet',
  'Class 1 Heavy Cruiser',
  weaponSystem
);
enterprise.fire('torpedos') // launching torpedos;
</code></pre>
<p>What's great about the <code>prototype</code> system in JavaScript is it enables you to create a system of inheritance. Inheritance in JavaScript is a little bit different than in other languages, but it's not too difficult with a bit of practice.</p>
<pre><code class="language-javascript">function ConstitutionClass(captain, firstOfficer, missionDuration) {
  this.captain = captain;
  this.firstOfficer = firstOfficer;
  this.missionDuration = missionDuration;

  Starship.apply(this, ['Federation', 'Star Fleet', 'Class 1 Heavy Cruiser', weaponSystem]);
}

ConstitutionClass.prototype = Object.create(Starship.prototype);
ConstitutionClass.prototype.constructor = ConstitutionClass;

ConstitutionClass.prototype.warp = function(speed) {
console.log('warping at: ' + speed);
};

var enterprise = new ConstitutionClass('Kirk', 'Spock', 5);
enterprise.fire('torpedos'); // Launching Torpedos
enterprise.warp(14.1); // warping at: 14.1
</code></pre>
<p>Here we've created the <code>ConstitutionClass</code> constructor. This constructor takes a <code>captain</code>, <code>firstOfficer</code>, and <code>missionDuration</code> as arguments. It then goes on to call <code>Starship.apply</code> and passes in an array of arguments. This ensures that the parent constructor gets called.</p>
<p>Every function in JavaScript has a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a> method that allows you to invoke a function by passing in a <code>context</code> and, in the case of <code>apply</code>, an array of arguments to use when invoking the function.</p>
<p>Next, to properly tell the <code>ConstitutionClass</code> to inherit from <code>Starship</code> we simply use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create</code></a> to assign the prototype of <code>ConstitutionClass</code>.</p>
<p>What this does is tell <code>ConstitutionClass</code> that it's a type of <code>Starship</code> by adding all of the <code>Starship</code> prototype properties and methods to the <code>ConstitutionClass</code> prototype.</p>
<p>Check out how this looks when you run it and open up the console…</p>
<p><img src="http://d.pr/i/12tb7+" alt=""></p>
<p>You can easily see how the <code>enterprise</code> instance of <code>ConstitutionClass</code> has correctly been assigned its properties, as well as the properties of a <code>Starship</code>.</p>
<p>Notice also how the <code>ConstitutionClass</code> has a warp method as well as a <code>fire</code> method that it inherits from the <code>Starship</code>.</p>
<p>That's <strong>prototypical inheritance</strong>.</p>
<h3>IIFEs to prevent global leaks</h3>
<p>An important thing to note about the code above is there are several global leaks occurring. When you simply declare a function or variable in a JavaScript file, it will automatically be added to the global namespace (the <code>window</code> in the case of a browser);</p>
<p>This code here will create several globals…</p>
<pre><code class="language-javascript">function PhotonTorpedoSystem() {}
PhotonTorpedoSystem.prototype.launch = function() {
  console.log('launching torpedos');
};

var torpedos = new PhotonTorpedoSystem(),

var weaponSystem = {
  torpedos: torpedos;
};
</code></pre>
<p>After running this code you will have created <code>window.PhotonTorpedoSystem</code>, <code>window.torpedos</code>, and <code>window.weaponSystem</code>. This is not an ideal scenario.</p>
<p>One great pattern for avoiding this issue is to utilize an Immediately Invoked Function Expression…</p>
<pre><code class="language-javascript">(function(global) {

function PhotonTorpedoSystem() {}
  PhotonTorpedoSystem.prototype.launch = function() {
  console.log('launching torpedos');
};

var torpedos = new PhotonTorpedoSystem(),

var weaponSystem = {
  torpedos: torpedos;
};

/* Create instance of enterprise etc */

global.PhotonTorpedoSystem = PhotonTorpedoSystem; // Export just this to the window
}(window));
</code></pre>
<p>Here you can see the <code>(function(global) {</code> at the beginning and the <code>}(window));</code><br>
at the end. This causes the anonymous function <code>function(global)</code> to fire right away, and sets <code>global</code> to the <code>window</code>. This all works because the IIFE creates a closure. Everything defined inside the IIFE is contained in the memory for that function alone unless it gets exported on the <code>global</code> we defined.</p>
<p>Now you can explicitly set things on the <code>window</code> for use in other JavaScript files.</p>
<p>This is a step in the right direction, but another even better pattern to utilize here would be the <strong>Namespace Pattern</strong>.</p>
<pre><code class="language-javascript">// weaponSystems.js
(function(global, NS) {
NS.Weapons = NS.Weapons || {};

function PhotonTorpedoSystem() {}
PhotonTorpedoSystem.prototype.launch = function() {
  console.log('launching torpedos');
};

/* ... */

NS.Weapons.PhotonTorpedoSystem = PhotonTorpedoSystem; // Export just this to the NS.Weapons namespace
}(window, window.NS = NS || {});
</code></pre>
<p>Notice how we've changed the bottom of the IIFE to <code>}(window, window.NS = NS || {});</code>. This will pass the <code>window</code>, as well as an <code>NS</code> object. This slightly odd notation here says, "pass NS if it exists, or create a new object for it".</p>
<p>You can also see this syntax used again here <code>NS.Weapons = NS.Weapons || {};</code>.</p>
<p>It's effectively the same thing as using an if statement, but is more terse.</p>
<pre><code class="language-javascript">if (!NS.Weapons) {
NS.Weapons = {};
}
</code></pre>
<p>You can add whatever objects and functions you want to on to the namespace. This will allow you to avoid adding too many globals to the window.</p>
<pre><code class="language-javascript">(function(global, NS) {
NS.Ships = NS.Ships || {};

function Starship(owner, operator, type, weapons) { /* ... */ }
function ConstitutionClass(captain, firstOfficer, missionDuration) { /* ... */ }

/* ... */

NS.Ships.Starship = Starship;
NS.Ships.ConstitutionClass = ConstitutionClass;

}(window, window.NS = NS || {});
</code></pre>
<h3>IIFE for the Revealing Module Pattern</h3>
<p>Another pattern for creating functions is the "revealing module pattern".</p>
<pre><code class="language-javascript">NS.Owners.starFleet = (function() {
  var ships = [];

  var addShip = function(ship) {
    ships.push(ship);
  };

  var removeShip = function(ship) {
    var index = ships.indexOf(ship);

    if (index &gt; -1) {
      ships.splice(index, 1);
    }
  };

  var getTotal = function() {
    return ships.length;
  };

  return {
    addShip: addShip,
    removeShip: removeShip,
    totalShipsInFleet: getTotal
  };
}());
</code></pre>
<p>This pattern allows you to define the public API for an object as well as have a few private members because of the IIFE. In this case, <code>ships</code> stays private because it's defined within the IIFE, whereas <code>addShip</code> and <code>removeShip</code> are exported via the object in the <code>return</code> statement.</p>
<pre><code class="language-javascript">(function() {
var enterprise = new NS.Ships.ConstitutionClass('Kirk', 'Spock', 5);

NS.Owners.starFleet.addShip(enterprise);

NS.Owners.starFleet.getTotal(); // 1
}());
</code></pre>
<p>Now you can use <code>NS.Owers.starFleet</code> to add ships to Star Fleet.</p>
<h3>Organizing Files</h3>
<p>Architectural patterns are very helpful for creating maintainable web applications. One further problem exists though in large scale applications, and that's file organization.</p>
<p>In the early days, having all of your code in a single Javascript file was still not a great idea, but it could work because there wasn't that much code. Today in the 23rd century, that's just not the case. There are hundreds, if not thousands, of lines of code necessary for a web application. Having a single JavaScript file is just not feasible.</p>
<p>When you start adopting architectural patterns like constructor or module patterns, your code will have been broken down into smaller units. This is great for multiple reasons. For one, you'll now be able to move these small units in to their own files. And it makes unit testing much easier.</p>
<p>As a goal, try to keep each JavaScript file containing one logical "class" or module.</p>
<p>You may have something like this.</p>
<pre><code>/js/
/js/app.js
/js/starship.js
/js/constitutionClass.js
/js/starFleet.js
</code></pre>
<p>This is much nicer. You're able to logically divide up each piece of functionality. After a while though, you may have too many JS files in the <code>/js</code> folder and may want to consider some subfolders.</p>
<blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things.<br>
— Phil Karlton</p></blockquote>
<p>Naming things is hard, so when getting ready to divide your application up into subfolder, just pick some standards for you and your team and follow them. Consistency always wins!</p>
<pre><code>/js/
/js/app.js
/js/classes/starship.js
/js/classes/constitutionClass.js
/js/core/starFleet.js
/js/infrastructure/..js
/js/templates/..js
</code></pre>
<p>Another common organizational strategy is to break up large pieces of functionality into their own folders.</p>
<pre><code>/js/
/js/app.js
/js/ships/starship.js
/js/ships/constitutionClass.js
/js/core/starFleet.js
/js/captainsLog/..js
/js/weaponSystems/..js
</code></pre>
<p>No matter what you choose, the idea is to maintain consistency within your structure for your team. There's no wrong answer here, just pick something and go with it.</p>
<p>One hiccup you'll find breaking up your logic into many files though is dealing with loading them into your HTML pages.</p>
<p>With a structure like this you'll end up having to have many <code>script</code> includes that have to be in a very specific order to avoid errors.</p>
<pre><code class="language-markup">&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/js/app.js"&gt;&lt;/script&gt;
&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/js/core/starFleet.js"&gt;&lt;/script&gt;
&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/js/weaponSystems/photonTorpedos.js"&gt;&lt;/script&gt;
&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/js/starship.js"&gt;&lt;/script&gt;
&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/js/constitutionClass.js"&gt;&lt;/script&gt;
</code></pre>
<p>If any one of those files gets included in the wrong order, you'll run into problems. You also will have many synchronous script includes that slow your page render.</p>
<p>Enter AMD.</p>
<h3>AMD</h3>
<p>Asynchronous Module Definition is a specification created by the CommonJS group to handle these types of issues. It defines a specification for creating and requiring modules into an application.</p>
<p>One of the best implementations of AMD is <a href="http://requirejs.org">require.js</a>.</p>
<p>With require.js, you create many modules just like we have been working with so far, but there's a wrapper for each module. This wrapper not only hides globals from the window, but also helps define a dependency chain which allows you to have a single <code>script</code> tag on your page. There is also a great build tool called <code>r.js</code> that can compile all your modules to a single minified file.</p>
<p>To start, download require.js and include it in your page.</p>
<pre><code class="language-markup">&lt;script src="https://x6ar5ez4ac-flywheel.netdna-ssl.com/vendor/require.js" data-main="/js/main"&gt;&lt;/script&gt;
</code></pre>
<p>The <code>data-main</code> here points to a <code>main.js</code> file in our <code>/js</code> directory. This <code>main</code> file is responsible for some initial setup that tells <code>require</code> a bit about our application and kicks off the process of loading in files.</p>
<pre><code class="language-javascript">require.config({
  paths: {
    'foo': '/vendor/foo'
  }
});

require(['app'], function(app) {
  app.init();
});
</code></pre>
<p>Here is a very simple <code>main</code> file. The <code>require.config</code> can set up some aliases if you need them. Then you use the <code>require</code> method by passing in an array of module names. The module names correspond directly to their file names minus the <code>.js</code><br>
extension. Here we kick off the application by loading <code>/js/app.js</code>.</p>
<p><code>app.js</code> would look something like…</p>
<pre><code class="language-javascript">define(function(require) {
  var ConstitutionClass = require('ships/constitutionClass');
  starFleet = require('core/starFleet'),
  captainsLog = require('captainsLog/log');

  return {
    init: function() {
      var enterprise = new ConstitutionClass('Kirk', 'Spock', 5);

      starFleet.addShip(enterprise);
      captainsLog.record('Stardate 43125.8. Commence 5 year mission into deep space');
    }
  };
});
</code></pre>
<p>This module is defined with the commonjs syntax. There are 2 ways you can export an API with requre.js's commonjs syntax as well. Either via the return statement as above, or via the actual <code>commonjs</code> way of using <code>module.exports</code>.</p>
<pre><code class="language-javascript">module.exports = {
  init: function() {
    var enterprise = new ConstitutionClass('Kirk', 'Spock', 5);

    starFleet.addShip(enterprise);
    captainsLog.record('Stardate 43125.8. Commence 5 year mission into deep space');
  }
};
</code></pre>
<p>Another quick note about require.js. All the examples below are going to use the commonjs syntax for creating modules, however you can either use the commonjs syntax or use a syntax like this…</p>
<pre><code class="language-javascript">define([
  'ships/constitutionClass',
  'core/starFleet',
  'captainsLog/log'
], function(ConstitutionClass, starFleet, captainsLog) {

  return {
    init: function() {
      var enterprise = new ConstitutionClass('Kirk', 'Spock', 5);

      starFleet.addShip(enterprise);
      captainsLog.record('Stardate 43125.8. Commence 5 year mission into deep space');
    }
  }
});
</code></pre>
<p>Rather than a function that asks for the require function <code>function(require)</code>, you can pass in an array of dependencies. The modules are loaded in and are passed in as the arguments to the function. <code>function(ConstitutionClass, starFleet, captainsLog) {</code>. This is important to know because what require.js actually does is convert the commonjs syntax into this syntax for you.</p>
<p>Either syntax is perfectly valid, so choose which you prefer. The commonjs syntax is nice though because in theory you could share your modules with node, and/or browserify which we'll talk about later.</p>
<p>Then the <code>ships/constitutionClass.js</code> would look like…</p>
<pre><code class="language-javascript">define(function(require) {
  var Starship = require('ships/starship');

  function ConstitutionClass() { /* ... */}

  return ConstitutionClass;
});
</code></pre>
<p>This module returns a constructor function just like we created above, except now there's no need for any namespacing because you're working with a module that keeps everything private except what you return from the module.</p>
<p>You can also see how the dependency chain is beginning to form. <code>app.js</code> requires <code>ships/constitutionClass.js</code> which then requires <code>ships/starship.js</code>. This will continue on and on down the chain of dependencies.</p>
<p>A module like <code>core/starFleet.js</code> might look like this…</p>
<pre><code class="language-javascript">define(function() {
  var ships = [];

  var addShip = function(ship) {
    ships.push(ship);
  };

    var removeShip = function(ship) {
    var index = ships.indexOf(ship);

    if (index &gt; -1) {
      ships.splice(index, 1);
    }
  };

  var getTotal = function() {
    return ships.length;
  };

  return {
    addShip: addShip,
    removeShip: removeShip,
    totalShipsInFleet: getTotal
  };
});
</code></pre>
<p>Effectively the same thing as the revealing module pattern gave us. Simply return an object literal with a public API.</p>
<h3>Browserify</h3>
<p>Browserify is another method of creating JavaScript modules. With browserify, you basically write commonjs modules and run <code>browserify</code> with the global node.js module and it will bundle up your code for use in the browser.</p>
<p>The syntax of creating modules with require and browserify is very close if you choose to use the commonjs syntax and the <code>module.exports</code> when working with require.</p>
<p>The <code>app.js</code> above written as an actual commonjs module looks like…</p>
<pre><code class="language-javascript">var ConstitutionClass = require('ships/constitutionClass');
starFleet = require('core/starFleet'),
captainsLog = require('captainsLog/log');

module.exports = {
  init: function() {
    var enterprise = new ConstitutionClass('Kirk', 'Spock', 5);

    starFleet.addShip(enterprise);
    captainsLog.record('Stardate 43125.8. Commence 5 year mission into deep space');
  }
};
</code></pre>
<p>The only difference is that you use <code>module.exports</code> to export your public API rather than a return statement.</p>
<p>To use browserify, install it with npm…</p>
<pre><code>npm install -g browserifylanguage-shell
</code></pre>
<p>Then you run it…</p>
<pre><code class="language-shell">browserify main.js &gt; bundle.js
</code></pre>
<p>This will output a single <code>bundle.js</code> file for use in the browser. There are a lot of advantages to both browserify and require.js. Module loading helps break up your application and no matter which you choose, it will help you create a more maintainable application.</p>
<h3>ES6</h3>
<p>One of the many awesome features coming in ES6 or ES.next is built-in classes with native JavaScript. ECMAScript is currently working on the spec for classes. You can view the <a href="http://people.mozilla.org/~jorendorff/es6-draft.html">unofficial draft</a> of the spec.</p>
<p>The new spec for JavaScript defines a new way of creating classes in JavaScript. If we take our previous examples and write them using ES6, the <code>Starship</code> class would look like…</p>
<pre><code class="language-javascript">class Starship {
  constructor(owner, operator, type, weapons) {
    this.owner = owner;
    this.operator = operator;
    this.type = type;
    this.weapons = weapons;
  }

  fire(weapon) {
    this.weapons[weapon].launch();
  }
}
</code></pre>
<p>You can see immediate differences here. First is the <code>class</code> identifier. Then you can see how you define a constructor with <code>constructor</code> and methods by simply a <code>methodname(a, b, c)</code> signature. No need to use <code>function</code> anywhere here.</p>
<p>Inheritance is also much easier. The <code>ConstitutionClass</code> can easily inherit from the <code>Starship</code> using <code>extends</code>…</p>
<pre><code class="language-javascript">class ConstitutionClass extends Starship {
  constructor(captain, firstOfficer, missionDuration) {
    this.captain = captain;
    this.firstOfficer = firstOfficer;
    this.missionDuration = missionDuration;

    super('Federation', 'Star Fleet', 'Class 1 Heavy Cruiser', {
      torpedos: new PhotonTorpedoSystem()
    });
  }

  warp(speed) {
    console.log('warping at: ' + speed);
  }
}
</code></pre>
<p>You'll also notice <code>super</code> here which is how you call the parent method and takes the place of <code>Starship.apply(this, [/* ... */])</code>.</p>
<p>This new <code>class</code> syntax is incredibly exciting for the future of JavaScript. Having built in classes is something JavaScript has needed for a while, and this new syntax is looking great.</p>
<h3>Traceur</h3>
<p>There is no telling when this <code>class</code> syntax will make it into browsers, but fortunately there's a tool called <a href="https://github.com/google/traceur-compiler">Traceur</a> that allows us to work with new features of JavaScript before they release.</p>
<p>You can install traceur with npm…</p>
<pre><code class="language-shell">npm install -g traceur
</code></pre>
<p>And you can compile ES6 file down to ES5 for use today.</p>
<pre><code class="language-shell">traceur --out build.js --script starship.js
</code></pre>
<p>Just note that if you plan on using it in the browser you must also include the runtime file above your includes…</p>
<pre><code class="language-markup">&lt;script src="bin/traceur-runtime.js"&gt;&lt;/script&gt;
</code></pre>
<p>Hopefully ES6 classes is the future of how we'll be writing maintainable JavaScript in the future.</p>
<h2>Conclusion</h2>
<p>JavaScript is an ever-changing language. As it grows there will be more and more ways to use it, and architect it. The architectural patterns above are a great way you can create JavaScript applications today, while the <code>class</code> syntax will be the way of things in the 24th century. Keep JavaScripting, and live long and prosper.</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t13" name="t13"></a><h1>13 : 9 New Array Functions in ES6</h1>
					<span>http://vegibit.com/new-array-functions-in-es6/</span>
					<div class="tutorial__content">


<div class="entry-content">
            <p><a href="http://vegibit.com/new-array-functions-in-es6/"><img src="http://vegibit.com/wp-content/uploads/2017/03/new-array-functions-in-es6.png" alt="new array functions in es6" width="400" height="300" class="alignleft size-full wp-image-22991" srcset="http://vegibit.com/wp-content/uploads/2017/03/new-array-functions-in-es6.png 400w, http://vegibit.com/wp-content/uploads/2017/03/new-array-functions-in-es6-300x225.png 300w" sizes="(max-width: 400px) 100vw, 400px" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>
<p class="lead">There are many new extensions to the array object in ES6.  In this journey of learning the foo of ES6, we will set our targets on mastering the ways of new functions like Array.of(), Array.from(), Array.fill(), Array.find(), Array.findIndex(), Array.copyWithin(), Array.entries(), Array.keys(), and Array.values().  These new functions make it easier to fill up arrays, or find data within them.  In addition to that it is now easier to work with specific keys and values in the array itself.  These newer functions are lessening the need for utility libraries so they are definitely welcome.  Let's put the rubber to the road with all of the new array extensions in ES6 right now.</p>
<hr>
<h2>1. Array.of()</h2>
<p>To learn about the new <strong>Array.of()</strong> function, let us first take a look at a strange little quirk in ES5 concerning using the Array constructor.  We'll set up an array of <code>prices</code>, then take a look at the length of the array.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = Array(5000);
console.log(prices.length);
&nbsp;
// 5000
</pre>
<!-- [Format Time: 0.0004 seconds] -->
<p>When the code runs, it tells us that we have an array with a length of 5000.  What?!  We only passed one value, <code>5000</code>, into the array.  Well in ES5, if you pass just one value to the array constructor which is numeric, an array of that size will be created.  That is kind of strange, don't you think?  This is the purpose of <strong>Array.of()</strong>.  Let have a redo with our new function.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = Array.of(5000);
console.log(prices.length);
&nbsp;
// 1
</pre>
<!-- [Format Time: 0.0003 seconds] -->
<p><span class="label label-success"><strong>Nice!</strong></span>  In this go round, we find the length of <code>prices</code> to be <code>1</code>.  That seems to make much more sense.  Array.of() is a new way of creating an array which fixes this odd behavior in ES5.  If you create an array with just one numeric value, the array is created with just that value and not the amount of that value.</p>
<hr>
<h2>2. Array.from()</h2>
<p>Let's see how the new <strong>Array.from()</strong> function works.  Below we have set up an array with three values of 500, 700, and 1000.  On the second line, we make a call to Array.from() and pass in <code>prices</code> as the <em>first</em> argument, and an <strong><a href="http://vegibit.com/es6-arrow-function-tutorial/">arrow function</a></strong> as the <em>second</em> argument.  By running the code, we see that the prices are now taxed at 5 percent.  Array.from() creates a brand new array based on <code>prices</code>, and for each element in that array the arrow function is called.  So basically we take each price and multiply it by 1.05 denoting a tax rate of 5 percent.</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 700, 1000];
let taxed = Array.from(prices, price =&gt; price * 1.05);
console.log(taxed);
&nbsp;
// [525, 735, 1050]
</pre>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<hr>
<h4>Using Array.from() with three arguments</h4>
<p>In the prior example, we passed two arguments to the Array.from() function.  The first was the array we were working with, and the second was a function.  In this example we will pass an array, a function, <em>and also an object</em>.  Say you had a site that listed items for sale, but for each item sold you had to pay a listing fee of 5 dollars.  Let's see how to calculate this.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 700, 1000];
let totalprice = Array.from(prices, function (price) {
&nbsp;&nbsp;&nbsp;&nbsp;return price + this.listingfee;
}, {listingfee: 5});
&nbsp;
console.log(totalprice);
&nbsp;
// [505, 705, 1005]
</pre>
<!-- [Format Time: 0.0010 seconds] -->
<p></p>
<p>What is happening here is that the third argument to Array.from() is an object which becomes <code>this</code> in the function.  That is why we are able to take the <code>price</code> and add <code>this.listingfee</code> to give us the total price.  Note that when using this technique, we need to use a standard function as opposed to an arrow function for the second argument to Array.from().  This is because arrow functions do not allow meddling with the <code>this</code> value.</p>
<hr>
<h2>3. Array.fill()</h2>
<p>ES6 now gives you an easy way to fill up an array using <strong>Array.fill()</strong>.  Let's see a quick example.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 700, 1000];
prices.fill(2000);
console.log(prices);
&nbsp;
// Array [ 2000, 2000, 2000 ]
</pre>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<p>So it looks like this function will overwrite any existing values in all keys of the array with the provided value.  Since we call <code>.fill()</code> on the <code>prices</code> array which has 3 elements in it, all elements in the array are now <code>9000</code>.  There is also an option to pass a second argument to Array.fill() in order to start at a specific index.  Let's see how to do that.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 700, 1000];
prices.fill(2000, 2);
console.log(prices);
&nbsp;
// Array [ 500, 700, 2000 ]
</pre>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<p>By passing the value of <code>2</code> as the second argument, we are telling the fill function to start filling the array at the 2nd index.  Since arrays are 0 based as we know, it is the third value in our array that gets overwritten with the value of <code>2000</code>.</p>
<p>Now, why only pass two arguments when you can pass three?!  Here we will pass another argument to Array.fill().  This will demonstrate that the second argument specifies what index to start at while the third argument specifies <em>where to stop</em>.  Check it out now.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
prices.fill(2000, 2, 4);
console.log(prices);
&nbsp;
// Array [ 500, 600, 2000, 2000, 900, 1000, 1500 ]
</pre>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<p>We added a few more values to our original array so that it is a bit easier to see how this works.  Notice that we begin filling with the value of <code>2000</code> at <em>index 2</em> and stop at <em>index 4</em>.  Note that the filling stops before actually placing a value in the index.  This is why you see only index 2 and 3 with the value of 2000.</p>
<hr>
<h2>4. Array.find()</h2>
<p><strong>Array.find()</strong> is another new function added to arrays in ES6.  You can use it to easily find a value in an array that meets a given criteria.  Let's see how it works.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
let result = prices.find(price =&gt; price &gt; 777);
console.log(result);
&nbsp;
// 800
</pre>
<!-- [Format Time: 0.0008 seconds] -->
<p></p>
<p>Notice that we pass an arrow function to the .find() function.  That function is applied against every element in the array, and as soon as it finds a value that meets the criteria, that value is returned.  It does not continue to return all values that meet the criteria.  This is why we only get one result in this example.  Let's run through this example just one more time to see it in action.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
let result = prices.find(price =&gt; price &lt; 777 &amp;&amp; price &gt; 600);
console.log(result);
&nbsp;
// 700
</pre>
<!-- [Format Time: 0.0009 seconds] -->
<p></p>
<p>So here, we use a compound expression in the arrow function to be more specific.  We specify that we want a value that is less than 777 but also greater than 600.  700 is the first value to meet that criteria, so we get that result back.</p>
<hr>
<h2>5. Array.findIndex()</h2>
<p>In addition to Array.find(), we now also have the <strong>Array.findIndex()</strong> function which works in a similar way but instead of returning the value, it returns the <em>index</em>.  Let's see how it works.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
let result = prices.findIndex(function (price) {
&nbsp;&nbsp;&nbsp;&nbsp;return price == this;
}, 1000);
console.log(result);
&nbsp;
// 5
</pre>
<!-- [Format Time: 0.0009 seconds] -->
<p></p>
<p>Here we use a regular JavaScript function passed into the .findIndex() function.  We simply return the result of price being equal to <code>this</code>.  <code>this</code> is set to 1000, which is the second argument to .findIndex().  We can see that the value of 1000 lives at index 5 of the zero based array.</p>
<hr>
<h2>6. Array.copyWithin()</h2>
<p><strong>Array.copyWithin()</strong> is an interesting addition to the array function library in ES6.  With it, you can copy values inside the array just like the name implies.  It takes a value from one index, and places it in another.  Here is an example.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
prices.copyWithin(3, 1);
console.log(prices);
&nbsp;
// Array [ 500, 600, 700, 600, 700, 800, 900 ]
</pre>
<!-- [Format Time: 0.0006 seconds] -->
<p></p>
<p>The key to understanding copyWithin() is what the arguments mean.  Argument 1 is the index which will be overwritten.  It is where data will be copied to.  The second argument is the data to copy from.  So in our example, we are saying that we are going to copy the data at index 1 (600) and paste it into index 3 (800).  After the function runs, we see that index 3 no longer holds 800, it now holds 600.  It is working as expected.  There is also the option to pass a third argument to copyWithin().  This third argument tells us how many items to copy.  Let's see how it works.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let prices = [500, 600, 700, 800, 900, 1000, 1500];
prices.copyWithin(2, 0, 3);
console.log(prices);
&nbsp;
// Array [ 500, 600, 500, 600, 700, 1000, 1500 ]
</pre>
<!-- [Format Time: 0.0007 seconds] -->
<p></p>
<p>The destination index is 2, or the third value in the array.  We start copying form index 0, or the first value in the array.  We are going to copy three successive values starting at index 0.  So the result correctly displays 500 in the 2nd index position, followed by two additional copied values of 600 and 700.  Index 5 and 6 are unaffected and so they contain their original values of 1000 and 1500.</p>
<hr>
<h2>7. Array.entries()</h2>
<p>The <strong>Array.entries()</strong> function is a really cool addition to the language.  It takes an array, and creates a listing so to speak of each entry.  Let's examine closely how it works.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let words = ['Lenovo', 'Tablet', 'Coffee'];
console.log(words.entries());
&nbsp;
// Array Iterator {&nbsp;&nbsp;}
</pre>
<!-- [Format Time: 0.0005 seconds] -->
<p>First up, we simply set up an array of words.  Then we log out the value of calling .entries() on that array.  Interesting!  It results in an <strong><a href="http://vegibit.com/iterators-in-es6/">array iterator</a></strong>.  Hmm, well we learned that we can call the <code>.next()</code> function on iterators, so let's try that out!</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let words = ['Lenovo', 'Tablet', 'Coffee'];
console.log(words.entries().next());
&nbsp;
// Object { value: Array[2], done: false }
// The Array held in value contains 0: 0 and 1: Lenovo
</pre>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<p>Awesome!  We can see that we get the first list so to speak of the array.  The iterator object is not done, so it is set to <code>false</code>.  However the <code>value</code> contains an array which holds two values.  At index 0 of that array is the index of where Lenovo lives.  That is index <code>0</code>.  At index 1 is the value itself, which is <code>Lenovo</code>.  Very neat.  Finally, since we know we can use the <strong><a href="http://vegibit.com/es6-rest-parameters-and-spread-operators/">spread operator</a></strong> on iterators, let's go ahead and do that now.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let words = ['Lenovo', 'Tablet', 'Coffee'];
console.log(...words.entries());
&nbsp;
// Array [ 0, "Lenovo" ] 
// Array [ 1, "Tablet" ] 
// Array [ 2, "Coffee" ]
</pre>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<p>The .entries() function gives us the index / value pair of the array.</p>
<hr>
<h2>8. Array.keys()</h2>
<p><strong>Array.keys()</strong> works in a similar way to Array.entries() except that it only provides the keys of the array.  See it in action now.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let words = ['Lenovo', 'Tablet', 'Coffee'];
console.log(...words.keys());
&nbsp;
// 0 1 2
</pre>
<!-- [Format Time: 0.0004 seconds] -->
<p></p>
<hr>
<h2>9. Array.values()</h2>
<p>Finally, we have our Array.values() function which is similar to the prior two examples but provides only the values at each key.  Observe young Jedi.</p>
<p></p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<pre>let words = ['Lenovo', 'Tablet', 'Coffee'];
console.log(...words.values());
&nbsp;
// Lenovo Tablet Coffee
</pre>
<!-- [Format Time: 0.0005 seconds] -->
<p></p>
<hr>
<h3>9 New Array Functions in ES6 Summary</h3>
<p>You are now wielding special kung foo powers in your handling of arrays in ES6.  No longer are you confined by the burdens of working with arrays such as was done in ES5.  On your path to enlightenment you have found new and easier ways to get your work done, and as such, we hope you have found this journey exciting.</p>

            
                    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t14" name="t14"></a><h1>14 : Implementing EventEmitter in ES6</h1>
					<span>http://www.datchley.name/es6-eventemitter/</span>
					<div class="tutorial__content">

 <p>So, since I've been swamped with work recently and haven't posted much, I'd like to get back into the swing of things and throw up a simple EventEmitter implementation I put together for my current <a href="https://github.com/datchley/ng-reflux">ngReflux</a> project I'm working on.  </p>

<p>ngReflux is a Flux implementation for use with AngularJS applications and based on Mikael Brassman's <a href="https://gist.github.com/spoike/ba561727a3f133b942dc">original gist</a> idea for RefluxJS.  You can read more about the Flux architecture <a href="https://facebook.github.io/flux/docs/overview.html">elsewhere</a>.</p>

<p>Since Reflux removes the Dispatcher from the Flux flow altogether, it makes both Actions and Stores observables by having them prototypically inherit from an EventEmitter. Reflux uses <a href="https://github.com/primus/eventemitter3">EventEmitter3</a>, which is a full implementation for Node and the browser; but I wanted to keep this small and simple, with few outside dependencies, so I rolled my own.</p>

<h3 id="theobserverpattern">The Observer Pattern</h3>

<p>Before we look at the code, let's quickly review the <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a>, which is what EventEmitter is based on.</p>

<p>The Observer Pattern is fairly simple.  An object (<em>typically called a "subject"</em>) allows other Objects called Observers to be notified when some state in the Observable changes.  This is essentially the pub/sub architecture.</p>

<p><img src="http://www.datchley.name/content/images/2015/10/Observer-Pattern.png" alt=""></p>

<p>Making an object "observable" focuses primarily on providing at least three different behaviors:</p>

<ol>
<li><code>addListener(label,callback)</code> - Allow others to "listen" to the observer, providing it a callback to invoke when the observable's state changes.  </li>
<li><code>removeListener(label, callback)</code> - Allow those listening to remove themselves as listeners so they can stop receiving notifications of state changes.  </li>
<li><code>emit(label,...)</code> - Allow the observable to notify all observers of a state change by invoking each observer's callback with any changed state.</li>
</ol>

<p>In our <code>EventEmitter</code> implementation we also have labels, which allows an object acting as an observable to allow others to listen for changes on a specific "channel", which is just a string identifying the type or category of changes the observer wants to be notified about.  Observables can have one or more channels depending on their needs.</p>

<h3 id="implementingeventemitter">Implementing EventEmitter</h3>

<p>Let's use some of the latest Javascript ES2015/ECMA Script 6 features and get this thing rolling. </p>

<p>First, we'll setup our EventEmitter as a <code>class</code>, which is really just syntactic sugar for creating a function that is intended to be invoked with <code>new</code>, combined with adding methods on its prototype property.</p>

<pre><code class="language-javascript">class EventEmitter {  
  constructor() {
    this.listeners = new Map();
  }
  addListener(label, callback) { }
  removeListener(label, callback) { }
  emit(label, ...args) {  }
}
</code></pre>

<p>Our class has a constructor which sets up an initially empty map for keeping track of our listeners.  Note, too, the shorter syntax of declaring prototype methods on the class.  We've stubbed them out above and will show the implementation below.</p>

<h4 id="addlistenerlabelcallback">addListener(label, callback)</h4>

<p>Adding a listener takes two parameters. We'll need the label that identifies the type of notifications the listener wants to receive; and the callback function we should invoke for the listener when we emit that event.</p>

<pre><code class="language-javascript">  addListener(label, callback) {
    this.listeners.has(label) || this.listeners.set(label, []);
    this.listeners.get(label).push(callback);
  }
</code></pre>

<p>We just ensure we have a queue (<em>array of</em>) of listeners for the given label, creating it if it isn't there; and then push the callback function into that queue.</p>

<h4 id="removelistenerlabelcallback">removeListener(label, callback)</h4>

<p>Removing a listener takes the same parameters as <code>addListener</code>; but we need to be able to find that callback in the appropriate list in order to remove it.  </p>

<pre><code class="language-javascript">let isFunction = function(obj) {  
    return typeof obj == 'function' || false;
};

removeListener(label, callback) {  
    let listeners = this.listeners.get(label),
        index;

    if (listeners &amp;&amp; listeners.length) {
        index = listeners.reduce((i, listener, index) =&gt; {
            return (isFunction(listener) &amp;&amp; listener === callback) ?
                i = index :
                i;
        }, -1);

        if (index &gt; -1) {
            listeners.splice(index, 1);
            this.listeners.set(label, listeners);
            return true;
        }
    }
    return false;
}
</code></pre>

<p>Outside of our helper function to determine if an object is a <code>function</code>, the implementation is straight forward. Loop through the listeners for that label, if there are any, and retain the index of the callback that matches the one passed in, using that to remove that item from the list.</p>

<p>If you aren't familiar with using Array functions like <code>reduce</code> and <code>map</code>, take a look at my <a href="http://www.datchley.name/working-with-collections/">previous post</a> on the subject.</p>

<h4 id="emitlabelargs">emit(label, ...args)</h4>

<p>Here's where we emit events to all our listeners passing on some data that we think might interest them.  We just need the label to emit the event on, which tells us which set of listeners to notify; and the remaining arguments are passed to each listener callback directly.</p>

<pre><code class="language-javascript">emit(label, ...args) {  
    let listeners = this.listeners.get(label);

    if (listeners &amp;&amp; listeners.length) {
        listeners.forEach((listener) =&gt; {
            listener(...args); 
        });
        return true;
    }
    return false;
}
</code></pre>

<p>We use ES6's spread/rest operator here to collect all our arguments for emit into the single variable <code>args</code>; as well as to pass them as individual arguments to each listener callback invocation. Every time we emit on a label, all the other data we pass in gets passed to <em>all</em> our listeners callbacks.</p>

<p>Handling the arguments for each of those actions above in ES5 would be analogous to the following:</p>

<pre><code>function emit(label) {  
  var args = [].slice.call(arguments, 1);
  // ...
          listeners.apply(null, args);
}
</code></pre>

<p>The spread/rest operator helps make for cleaner and clearer code in this case.</p>

<h3 id="puttingitalltogether">Putting it all together</h3>

<p>Now that we have our EventEmitter class let's create an an observer and see how it works.  Our simple <code>Observer</code> constructor takes a single argument of the specific Observable that we want to listen on. We then listen for <code>"change"</code> events and output any data received to the console.</p>

<pre><code class="language-javascript">class Observer {  
  constructor(id, subject) {
    this.id = id;
    this.subject = subject;
    this.subject.addListener("change", (data) =&gt; this.onChange(data));
  }
  onChange(data) {
    console.log(`${this.id} notified of change:`, data);
  }
}
</code></pre>

<p>We use ES6's new string templating interpolation to format our console output as well, which is pretty nice.</p>

<p>Now we can create an Observable using our EventEmitter and a couple of Observers and fire off some events and see it all work.</p>

<pre><code>let observable = new EventEmitter();  
let [observer1, observer2] = [  
  new Observer(1, observable),
  new Observer(2, observable)
];

observable.emit("change", { a: 1 });  
// =&gt; (1) notified of change: { a: 1 }
// =&gt; (2) notified of change: { a: 1 }
</code></pre>

<p>We also used ES6's destructuring for the assignment on our observers, too.</p>

<p>Hopefully this has helped give you some insight into both the Observer Pattern and how EventEmitters are implemented.  You can find out more about ES2015 and ES6 through Babel's <a href="https://babeljs.io/docs/learn-es2015/">learning resource</a>. You can view the full code in <a href="https://gist.github.com/datchley/37353d6a2cb629687eb9">a gist</a>; and feel free to ask questions and leave comments!</p>

<p><em>Updated</em> As commenters Greg and Christian pointed out, the better way to compare functions in the <code>removeListener()</code> method is to use straight <code>===</code> comparison rather than relying on <code>.toString()</code> to compare a decompiled version of the function. Using <code>toString()</code>'s results is inconsitent across various browsers/devices, and will not work for bound functions, using <code>.bind()</code>. </p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t15" name="t15"></a><h1>15 : Getting Functional with Javascript (Part 1)</h1>
					<span>http://www.datchley.name/getting-functional-with-javascript-part-1/</span>
					<div class="tutorial__content">


<section class="post-content">
    <p>After reading about <em>currying</em>, <em>partial application</em> and other functional programming techniques, some developers are left wondering when, exactly, they would ever use those methods; and why would they want to?</p>

<p>With this three part blog post series we'll try to tackle that issue and show how you could approach solving a problem in a functional fashion in the context of a small, realistic example.</p>

<h2 id="whatisfunctionalprogramming">What is Functional Programming</h2>

<p>Before we dive right in, let's take a brief moment to review some practical functional programming concepts.  </p>

<p>Functional programming focuses on the <em>"function"</em> as the primary expression of reuse. By building small functions that focus on very specific tasks, functional programming uses composition to build up more complex functions - this is where techniques like <em>currying</em> and <em>partial application</em> come into play.</p>

<blockquote>
  <p>Functional Programming uses functions as the declarative expression of reuse, avoiding mutating state, eliminating side effects &amp; using composition to build functionality</p>
</blockquote>

<p>Functional programming is essentially programming with functions! The additional considerations like avoiding mutating state, pure functions with no side effects and elimination of loops in favor of recursion are part of a Pure Functional Programming approach, which is built in in languages like Haskell.  </p>

<p>We'll focus on the practical parts of functional programming that we can immediately make use of in Javascript in this blog series.</p>

<p><strong>Higher Order Functions</strong> - Javascript has <em>first-class functions</em>, which means we can pass functions as arguments to other functions; and return functions as values from functions. </p>

<p><strong>Decorators</strong> - Because we can make higher order functions, we can create functions that augment other functions' behavior and/or arguments</p>

<p><strong>Composition</strong> - we can also create functions that are composed of multiple functions, created chained processing of inputs.</p>

<p>We'll introduce the techniques we'll use to take advantage of these features as they are needed.  This lets us introduce them in context and keep the concepts digestible and easy to understand.</p>

<h2 id="letsbuildsomethingalready">Let's Build Something, Already!</h2>

<p>Ok, so what is it we are going to build?  </p>

<p>Let's take the typical example of needing to process some data coming back from an asynchronous request.  In this case, the response is in JSON format and contains a list of blog post summaries. </p>

<p>Here's our response data we'll be working with: <a href="https://gist.github.com/datchley/26bce4a05fde0226b405#file-json-data-js">View full data in Gist</a> and an example record.</p>

<pre><code>// An example record from our JSON response data
var records = [  
  {
    "id": 1,
    "title": "Currying Things",
    "author": "Dave",
    "selfurl": "/posts/1",
    "published": 1437847125528,
    "tags": [
      "functional programming"
    ],
    "displayDate": "2015-07-25"
  },
  // ...
];
</code></pre>

<p><strong>Our Requirements</strong>: Now, suppose that we want to build a display of recent posts (<em>no older than a month</em>), organized in groups by tags and sorted by publish date. Let's think for a moment about what we need to do:</p>

<ul>
<li>filter out posts older than a month (<em>say, 30 days</em>).</li>
<li>group the posts by their tags (<em>this might mean posts show up in two groups if they have more than one tag.</em>)</li>
<li>sort each tag listing by published date, descending.</li>
</ul>

<p>We'll cover each requirement above in a single post in this series, starting with filtering in this post.</p>

<h3 id="filteringtherecords">Filtering the Records</h3>

<p>Our first step is to filter out the records where the published date is older than the last 30 days.  Since functional programming is all about <em>functions</em> as the primary expression for reuse, let's build a function to encapsulate the act of filtering a list.</p>

<pre><code>function filter(list, fn) {  
  return list.filter(fn);
}
</code></pre>

<p>I can hear you asking now..., <em>"Really? That's all!?"</em>  </p>

<p>Well, yes, and no.  </p>

<p>While this function encapsulates the concept of filtering an array (<code>list</code>) using a predicate function (<code>fn</code>), which could have easily been done by just calling <code>list.filter(fn)</code> directly.  So, why not do it that way?</p>

<p>Because when we abstract the operation into a function, we can then use <em>currying</em> to build a more useful function.</p>

<blockquote>
  <p><strong>Currying</strong> is the act of taking a function with <em>N</em> arguments and returning a nested series of <em>N</em> functions that each take 1 argument.</p>
</blockquote>

<p>For more information and to brush up on this concept, read my <a href="http://www.datchley.name/currying-vs-partial-application/">previous post</a> about currying and an implementation of <em>left-&gt;right</em> currying.</p>

<p><a href="/content/images/2015/08/curry-argument-diagram-1.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/curry-argument-diagram-1.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>In this case we'll use a function called <code>rightCurry()</code>, which curries a function's arguments from right to left.  Typically, a plain <code>curry()</code> function would curry arguments left to right.  </p>

<p>Here's our implementation, along with another utility function <code>flip()</code>, which it uses internally.</p>

<pre><code>// Returns a function which reverses the order of the 
// arguments to the passed in function when invoked.
function flip(fn) {  
    return function() {
        var args = [].slice.call(arguments);
        return fn.apply(this, args.reverse());
    };
}

// Returns a new function that curries the original 
// function's arguments from right to left.
function rightCurry(fn, n) {  
  var arity = n || fn.length,
      fn = flip(fn);
  return function curried() {
      var args = [].slice.call(arguments), 
          context = this;

      return args.length &gt;= arity ?
          fn.apply(context, args.slice(0, arity)) : 
          function () {
              var rest = [].slice.call(arguments);
              return curried.apply(context, args.concat(rest));
          };
  };
}
</code></pre>

<p>With currying we can create functions that allow us to create new, partially applied functions we can reuse. In our case, we'll use it to create a function which partially applies a predicate to the operation of filtering a list.</p>

<p><a href="/content/images/2015/08/filterWith-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/filterWith-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<pre><code>// A function to filter a list with a given predicate
var filterWith = rightCurry(filter);  
</code></pre>

<p>This is basically the same as manually currying our binary <code>filter(list, fn)</code> function like this.</p>

<pre><code>function filterWith(fn) {  
  return function(list) {
    return filter(list, fn);
  }
}
</code></pre>

<p>And we can use it as follows?  </p>

<pre><code>var list = [1,2,3,4,5,6,7,8,9,10];

// Create a partially applied filter to get even numbers from a list
var justEvens = filterWith(function(n) { return n%2 == 0; });

justEvens(list);  
// [2,4,6,8,10]
</code></pre>

<p>Wow, seems like a lot of work initially; but what we got out of this approach is </p>

<ul>
<li>using <em>currying</em> to create a general, reusable function, <code>filterWith()</code>, which can be used in a number of situations to create more specific list filters</li>
<li>the ability to execute this new filter lazily whenever we get some data. <em>We can't call <code>Array.prototype.filter</code> without having it act on a list of data immediately</em></li>
<li>a more declarative API that aids in readability and understanding </li>
</ul>

<h3 id="aboutthatpredicatefunction">About that Predicate Function</h3>

<p>Our <code>filterWith()</code> function needs a predicate function, which returns <em>true</em> or <em>false</em> when given an item in the list, to determine if that item should be returned in the newly filtered list. </p>

<p>Let's start off by making a more generic comparison function that can tell us if a given number is greater than or equal to another number.</p>

<pre><code>// Simple comparison for '&gt;='
function greaterThanOrEqual(a, b) {  
  return a &gt;= b;
}
</code></pre>

<p>Given that our published dates are in numeric, timestamp format (<em>milliseconds since the Epoch</em>) this should work fine.  But, the predicate function for filtering Arrays is only passed a single argument to check, not two. </p>

<p>So, how do we make our binary comparison function work in a situation that needs a unary function?</p>

<p>Currying to the rescue again! We'll use it to make a function that can create unary comparison functions.</p>

<pre><code>var greaterThanOrEqualTo = rightCurry(greaterThanOrEqual);  
</code></pre>

<p>We can now use this curried version to create a unary predicate function that will work with list filtering, such as:</p>

<pre><code>var list = [5,3,6,2,8,1,9,4,7],  
    // a unary comparison function to see if a value is &gt;= 5
    fiveOrMore = greaterThanOrEqualTo(5);

filterWith(fiveOrMore)(list);  
// [5,6,8,9,7]
</code></pre>

<p>Awesome!  Now we can be more specific and create a predicate that solves our original problem of filtering dates greater than or equal to 30 days ago:</p>

<pre><code>var thirtyDaysAgo = (new Date()).getTime() - (86400000 * 30),  
    within30Days = greaterThanOrEqualTo(thirtyDaysAgo);

var dates = [  
  (new Date('2015-07-29')).getTime(), 
  (new Date('2015-05-01')).getTime() 
];

filterWith(within30Days)(dates);  
// [1438128000000]  - July 29th, 2015
</code></pre>

<p>So far, so good!  </p>

<p>We've created a predicate for filtering that can be easily reused. Also, because we're using a functional approach, our code is much more declarative and easy to follow - it sort of reads exactly as it works.  Readability and maintenance are important things to consider when writing any code!</p>

<h3 id="typeproblems">Type Problems...</h3>

<p><em>Uh-oh, we have another issue</em>! Our program needs to filter a list of objects, so our predicate function is going to need to access the <code>published</code> property on each item passed in.  </p>

<p>Our current predicate, <code>within30Days()</code>, doesn't handle object argument types, only scalar values! Let's solve that with another function! (<em>are you seeing a pattern here?</em>)</p>

<p>We'd like to reuse our existing predicate function; but modify its arguments so that it can work with our specific object types.  Here's a new utility function that let's us augment an existing function by modifying its arguments.</p>

<pre><code>function useWith(fn /*, txfn, ... */) {  
  var transforms = [].slice.call(arguments, 1),
      _transform = function(args) {
        return args.map(function(arg, i) {
          return transforms[i](arg);
        });
      };
  return function() {
    var args = [].slice.call(arguments),
        targs = args.slice(0, transforms.length),
        remaining = args.slice(transforms.length);

    return fn.apply(this, _transform(targs).concat(remaining));
  }
}
</code></pre>

<p>This is our most interesting functional utility so far, and nearly identical to the function of the same name in the <a href="http://ramdajs.com/docs/#useWith">Ramda.js library</a>.  </p>

<p><code>useWith()</code> returns a function which modifies the original function, <code>fn</code>, so that when it is invoked, it will pass each argument through a corresponding transform (<code>txnfn</code>) function.  If there are more arguments when invoked than transform functions, the remaining arguments will be passed in <em>"as is."</em></p>

<p>Let's help that definition out with a small example. Simply, <code>useWith()</code> lets us do the following:  </p>

<pre><code>function sum(a,b) { return a + b; }  
function add1(v) { return v+1; }  
var additiveSum = useWith(sum, add1, add1);

// Before sum receives 4 &amp; 5, they are each passed through
// the 'add1()' function and transformed
additiveSum(4,5);  // 11  
</code></pre>

<p>When we call <code>additiveSum(4,5)</code> we essentially get the following call stack:</p>

<ul>
<li><code>additiveSum(4,5)</code>
<ul><li><code>add1(4) =&gt; 5</code></li>
<li><code>add1(5) =&gt; 6</code></li>
<li><code>sum(5, 6) =&gt; 11</code></li></ul></li>
</ul>

<p>We can use <code>useWith()</code> to modify our existing predicate to operate on object types rather than scalar values. First, let's use <em>currying</em> again to create a function that lets us create partially applied functions that can access objects by property name.</p>

<pre><code>// function to access a property on an object
function get(obj, prop) { return obj[prop]; }  
// Curried version of `get()`
var getWith = rightCurry(get);  
</code></pre>

<p>Now we can use <code>getWith()</code> as the transform function to grab the <code>.published</code> date from each object to pass to our unary predicate function used in the filter.</p>

<pre><code>// Our modified predicate that can work on the `.published` 
// property of our record objects.
var within30Days = useWith(greaterThanOrEqualTo(thirtyDaysAgo), getWith('published'));  
</code></pre>

<p>Let's give this a try with some test data:</p>

<pre><code>// Array of sample object data
var dates = [  
      { id: 1, published: (new Date('2015-07-29')).getTime() }, 
      { id: 2, published: (new Date('2015-05-01')).getTime() }
    ],
    within30Days = useWith(greaterThanOrEqualTo(thirtyDaysAgo), getWith('published'));

// Get any object with a published date in the last 30 days
filterWith(within30Days)(dates);  
// { id: 1, published: 1438128000000 }
</code></pre>

<h3 id="readytofilter">Ready to Filter!</h3>

<p>Ok, given our first requirement to keep only post records within the last 30 days, let's give our full implementation a run with our response data.</p>

<pre><code>filterWith(within30Days)(records);  
// [
//    { id: 1, title: "Currying Things", displayDate: "2015-07-25", ... },
//    { id: 2, title: "ES6 Promises", displayDate: "2015-07-26", ... },
//    { id: 7, title: "Common Promise Idioms", displayDate: "2015-08-06", ... },
//    { id: 9, title: "Default Function Parameters in ES6", displayDate: "2015-07-06", ... },
//    { id: 10, title: "Use More Parenthesis!", displayDate: "2015-08-26", ... },
// ]
</code></pre>

<p>We now have a new list of <em>just</em> posts within the last 30 days. Looks like we've met our first requirement and are off to a good start. As we go along, we'll put our functional utilities in a library that we can reuse.  </p>

<p><strong>Get the Source</strong>: You can see the <a href="https://gist.github.com/datchley/26bce4a05fde0226b405">source code</a> for this post, which has all our functional utilities in a single <code>.js</code> file and our main application logic in its own file as well. We'll continue to add to these in each post in this series.</p>

<h2 id="summary">Summary</h2>

<p>We've discovered some key functional programming techniques like <em>currying</em> and <em>partial application</em> and the contexts in which we can use them. We also found out that focusing on building small, useful functions in conjunction with functional techniques allows us to compose higher order functions and enable better reuse.  With these basics under our belt, the next two posts will seem much less daunting.</p>

<p>In the next post in this series we'll combine what we have so far for filtering with grouping the records by <em>tag name</em>, where we'll introduce more list related functions and more flexible function composition as well.</p>
        <ul class="tags">
            <li class="tag" id="tag-id-17"><a href="/tag/currying/">currying</a></li> 
            <li class="tag" id="tag-id-19"><a href="/tag/functional-programming/">functional programming</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t16" name="t16"></a><h1>16 : Getting Functional with Javascript (Part 2)</h1>
					<span>http://www.datchley.name/getting-functional-with-javascript-part-2/</span>
					<div class="tutorial__content">

						
<section class="post-content">
    <p>In our <a href="http://www.datchley.name/getting-functional-with-javascript-part-1/">previous post</a> on functional programming we began introducing some functional themes by working through requirements for processing a typical <a href="https://gist.github.com/datchley/26bce4a05fde0226b405#file-json-data-js">JSON response</a>. </p>

<p>Here's a recap of our requirements:</p>

<ul>
<li><i class="fa fa-check-square-o"></i> filter out posts older than a month (say, 30 days).</li>
<li><i class="fa fa-square-o"></i> group the posts by their tags (this might mean posts show up in two groups if they have more than one tag.)</li>
<li><i class="fa fa-square-o"></i> sort each tag listing by published date, descending.</li>
</ul>

<p>That first post focused on our first requirement above - filtering out posts older than 30 days.  </p>

<p>We also started a <a href="https://gist.github.com/datchley/26bce4a05fde0226b405#file-functional-js">library</a> of useful functional utilities, which we'll continue to add to in this post. You can view <a href="https://gist.github.com/datchley/26bce4a05fde0226b405">the gist</a> to see the full source code for this series.</p>

<p>In this post, we'll cover our second requirement which is grouping our records in the newly filtered list by their <code>tags</code>.</p>

<h2 id="groupingthings">Grouping Things</h2>

<p>In Javascript, we can group items in a list using <code>Array#reduce()</code>, which we covered in a <a href="http://www.datchley.name/working-with-collections/">previous blog post</a>. Definitely take a look at that now if you aren't familiar; but the basic idea is that <code>reduce()</code> allows us to iteratively build up a new value by doing something with each item in the array. </p>

<p><a href="/content/images/2015/08/Copy-of-Untitled-drawing-1-.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/Copy-of-Untitled-drawing-1-.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>Usually, you think of taking some list of values and using <code>reduce()</code> to produce a single, new value, like: </p>

<pre><code>[1,2,3,4].reduce(function(sum, n) { return sum += n; }, 0);  // 10
</code></pre>

<p>It's this ability to iterate over values and build up or accumulate a new value that allows us to use <code>reduce()</code> to perform grouping operations. For instance:</p>

<pre><code>var list = [  
  { name: 'Dave', age: 40 },
  { name: 'Dan', age: 35 },
  { name: 'Kurt', age: 44 },
  { name: 'Josh', age: 33 }
];

list.reduce(function(acc, item) {  
  var key = item.age &lt; 40 ? 'under40' : 'over40';
  acc[key] = acc[key] || [];
  acc[key].push(item);
  return acc;
}, {});
// {
//   'over40': [ 
//      { name: 'Dave', age: 40 }, 
//      { name: 'Kurt', age: 44 }
//   ],
//   'under40': [ 
//      { name: 'Dan', age: 35 }, 
//      { name: 'Josh', age: 33 }
//   ]
// }
</code></pre>

<p>In the above snippet, we use <code>reduce()</code> to iterate over a list of objects.  We use an empty object as the starting point and group the records based on their age.  This allows us to treat an object like a map, assigning records to groups identified by property names on the resulting object.</p>

<p>Let's use this ability via <code>reduce()</code> to create a <code>group()</code> function.</p>

<pre><code>var toString = Object.prototype.toString;  
var isFunction = function(o) { return toString.call(o) == '[object Function]'; };

function group(list, prop) {  
  return list.reduce(function(grouped, item) {
      var key = isFunction(prop) ? prop.apply(this, [item]) : item[prop];
      grouped[key] = grouped[key] || [];
      grouped[key].push(item);
      return grouped;
  }, {});
}
// our right curried version of `group()`
var groupBy = rightCurry(group);  
</code></pre>

<p><a href="/content/images/2015/08/diagram-groupby.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/diagram-groupby.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p><code>group()</code> and <code>groupBy()</code> divide a list into sets, grouped by the property named <code>prop</code> on each object in the list. If <code>prop</code> is a function it will use the result of passing each value through <code>prop</code>. This is similar to the way <code>_.groupBy()</code> works in the lodash and underscore libraries.</p>

<p>Here's our previous example, now using <code>groupBy()</code>:</p>

<pre><code>var getKey = function(item) { return item.age &lt; 40 ? 'under40' : 'over40'; };  
groupBy(getKey)(list);  
// gives us the same results as previous example
</code></pre>

<p>In this case we passed a function as the <code>prop</code> argument that returned a string for grouping.  But we can use the non-function use of <code>prop</code> for records like our JSON response, where we want to group by a given property on the record:</p>

<pre><code>var list = [  
  { value: 'A', tag: 'letter' },
  { value: 1, tag: 'number' },
  { value: 'B', tag: 'letter' },
  { value: 2, tag: 'number' },
];
groupBy('tag')(list);  
// {
//   'letter': [ 
//      { value: 'A', tag: 'letter' },
//      { value: 'B', tag: 'letter' }
//   ],
//   'number': [ 
//      { value: 1, tag: 'number' },
//      { value: 2, tag: 'number' }
//   ]
// }
</code></pre>

<p>This looks like it should work well. However, the list of objects we were grouping above could only belong to one possible group: 'letter' or 'number'. The list of objects had a <em>many-to-one</em> relationship with the grouping key.</p>

<p>In our JSON response, this isn't the case, as each post's <code>tag</code> property is an array of one or more tag names.</p>

<h2 id="groupingmanytomanyrelationships">Grouping Many-to-Many relationships?</h2>

<p>So, did we go to all that trouble building a <code>groupBy()</code> function that won't work for our requirement?  Absolutely not! This is functional programming, after all, so we'll just use that function composed with other functions to build the one we want!</p>

<p>Let's take a step back and look at our JSON response again; but in a different light, like a typical database table:</p>

<p><a href="/content/images/2015/08/json-data-table-format.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/json-data-table-format.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>We need a way to explode our list so that we output a list with one record for each tag-post combination. That output list is very similar to a <em>linking</em> or <em>joining</em> table used in databases that have tables with a many-to-many relationship - <em>in this case tags to posts</em>. </p>

<p>Doing this will necessarily create duplicates on our output; but we need those since a post can show up in multiple groups given our requirements.  </p>

<p>Our output list would resemble the following given our table example:</p>

<p><a href="/content/images/2015/08/many-to-many-table-example.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/many-to-many-table-example.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>Given the above diagram, it's clear that what we are doing is outputing a combination. In this case, our output is the combination of the post record with each of its possible tags.  </p>

<p>We know we'll need to map over our lists, so let's create a <code>map()</code> and <code>mapWith()</code> function we can use going forward:</p>

<p><a href="/content/images/2015/08/mapwith-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/mapwith-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<pre><code>// Returns a new list by applying the function `fn` to each item
// in `list`
function map(list, fn) {  
  return list.map(fn);
}
var mapWith = rightCurry(map);  
</code></pre>

<p>Now, let's create a <code>pair()</code> function that can combine the elements from two lists.</p>

<pre><code>function isArray(o) { return toString.call(o) == '[object Array]'; }

function pair(list, listFn) {  
  isArray(list) || (list = [list]);
  (isFunction(listFn) || isArray(listFn)) || (listFn = [listFn]);
  return mapWith(function(itemLeft){
    return mapWith(function(itemRight) {
      return [itemLeft, itemRight];
    })(isFunction(listFn) ? listFn.call(this, itemLeft) : listFn);
  })(list);
}
var pairWith = rightCurry(pair);  
</code></pre>

<p>We basically take two lists, map over each item in the first list, and for each item, output the results of combining that item with each item in the second list using a nested map. We also allow a function that returns a list as the second parameter, which will be passed the item from the first list on each iteration.</p>

<p>Let's try this with our filtered records from the before. We'll use our right curried <code>getWith()</code> to pass a function as the second parameter that will return the array of tags on each post as the second set to combine against.</p>

<pre><code>pair(filtered, getWith('tags'));  
// [ 
//   [ [ { /* ... */ }, 'functional programming' ] ],
//   [ [ { /* ... */ }, 'es6' ],
//     [ { /* ... */ }, 'promises' ]
//   ],
//   /* ... */
// ]
</code></pre>

<p>Interesting..., those are the right tag-&gt;post pairs, but they're nested in arrays within the array because we have nested <code>mapWith()</code> calls, each of which return an array.  </p>

<p>We can, however, flatten that using another handy function called <code>flatten()</code>, which will flatten an array by one level, ie, transform <code>[[1,2],[3,4]]</code> into <code>[1,2,3,4]</code>.</p>

<pre><code>function flatten(list) {  
    return list.reduce(function(items, item) {
        return isArray(item) ? items.concat(item) : item;
    }, []);
}
</code></pre>

<p>We use <code>reduce()</code> here to build up the new array, concatenating any values that are arrays directly into the resulting array, removing nesting. Flattening our previous results gives us the following:</p>

<pre><code>// [ 
//   [ { /* ... */ }, 'functional programming' ],
//   [ { /* ... */ }, 'es6' ],
//   [ { /* ... */ }, 'promises' ],
//   /* ... */
// ]
</code></pre>

<p>Now we have the data structure we want to start doing our grouping! </p>

<p>But, this operation is so common -- <em>the idea of flattening nested lists as we map across them</em> -- that it's usually combined into a single function, <code>flatMap(list, fn)</code>. </p>

<p>Let's create a <code>flatMap()</code> function and its right curried friend <code>flatMapWith()</code>.</p>

<p><a href="/content/images/2015/08/flatmapwith-diagram-1-.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/flatmapwith-diagram-1-.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<pre><code>function flatMap(list, fn) {  
  return flatten(map(list, fn));
}
var flatMapWith = rightCurry(flatMap);  
</code></pre>

<p>We can use that inside our <code>pair()</code> function as well to ensure the right output:</p>

<p><a href="/content/images/2015/08/diagram-pair.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/diagram-pair.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<pre><code>function pair(list, listFn) {  
  isArray(list) || (list = [list]);
  (isFunction(listFn) || isArray(listFn)) || (listFn = [listFn]);
  return flatMapWith(function(itemLeft){
    return mapWith(function(itemRight) {
      return [itemLeft, itemRight];
    })(isFunction(listFn) ? listFn.call(this, itemLeft) : listFn);
  })(list);
}
</code></pre>

<p>Now we can put our entire flow together, which consists of:</p>

<ol>
<li>creating a many-to-many list of tag-&gt;post pairs using <code>pairWith()</code>  </li>
<li>using that new list as input to <code>groupBy()</code> to group each record by its given tag (<em>the second item in each pair</em>).</li>
</ol>

<pre><code>var bytags = pairWith(getWith('tags'))(records);  // #1  
var groupedtags = groupBy(getWith(1), bytags);       // #2  
// {
//    'destructuring': [
//         [ { /* ... */ }, 'destructuring' ],
//         [ { /* ... */ }, 'destructuring' ]
//    ],
//    'es6': [
//        [ { /* ... */ }, 'es6' ],
//        [ { /* ... */ }, 'es6' ]
//    ],
//    /* ... */
// }
</code></pre>

<h2 id="cleaningup">Cleaning Up</h2>

<p>So, after rebuilding the list as a many-to-many joined list and then grouping by the tags as the key, we end up with a structure that still isn't quite what we want - each post record is still nested in a list pair with its group key.</p>

<p>We need a way to map over our output object's properties and then map over each of those arrays and replace each list pair with just the post record.</p>

<p>We can map over arrays already using <code>map()</code> and its variants; but we can also do the same thing with objects if we think of the objects as a list where each item is a property and its value.</p>

<p>We'll call this <code>mapObject()</code> and it will return an object as well. </p>

<p><a href="/content/images/2015/08/mapObject-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/mapObject-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<pre><code>function mapObject(obj, fn) {  
  return keys(obj).reduce(function(res, key) {
    res[key] = fn.apply(this, [key, obj[key]]);
    return res;
  }, {});
}
// A right curried version
var mapObjectWith = rightCurry(mapObject);  
</code></pre>

<p>The function passed to <code>mapObject()</code> is passed not only the item but also the property name.  Now, we can use our ability to map over an object to convert our structure:</p>

<pre><code>// Remove our extraneous group key and pair, replacing with the post record
var finalgroups = mapObjectWith(function(group, set){  
    return mapWith(getWith(0))(set);
})(groupedtags);
// {
//   'destructuring': [
//      { id: 2, title: 'ES6 Promises', ..., tags: ['es6', 'promises'] },
//      { id: 4, title: 'Basic Destructuring in ES6', ..., tags: ['es6', 'destructuring'] },
//   ],
//   'es6': [ /*...*/ ],
//   /*...*/
// }
</code></pre>

<h3 id="beingmoredeclarative">Being More Declarative</h3>

<p>The operation we used above in which we want to pull out a specific property's value from a list of objects, <code>mapWith(getWith(prop))</code>, is a fairly common action. So much so, that this is commonly named <code>pluck()</code>, and you'll find it in numerous functional libraries.  </p>

<pre><code>// For each object in `list`, return the value of `prop`
function pluck(list, prop) {  
  return mapWith(getWith(prop))(list);
}
// right curried version of `pluck`
var pluckWith = rightCurry(pluck);  
</code></pre>

<p>That's a bit more declarative and gives us another higher order function we can reuse. But we'd like our resulting code to be a bit more descriptive of the actions it is actually performing - getting the post record from each nested pair.</p>

<p>Let's start by being explicit with the function we're passing to <code>mapObjectWith()</code>:</p>

<pre><code>function getPostRecords(prop, pair) {  
  return pluckWith(0)(pair); 
}
</code></pre>

<p>Ah, that's a bit more descriptive. And when combined with our original solution, becomes much more declarative of the action we're actually performing.</p>

<pre><code>var finalgroups = mapObjectWith(getPostRecords)(groupedtags);  
</code></pre>

<h3 id="thefullimplementation">The full implementation</h3>

<p>The final implementation for meeting our second requirement:</p>

<pre><code>// Step 1: Build our many-to-many list 
var bytags = pairWith(getWith('tags'))(records);

// Step 2: group by the tags (pair[1]):  
var groupedtags = groupBy(getWith(1), bytags);

// Step 3: strip extra key in nested pairs: 
function getPostRecords(prop, value) {  
  return pluckWith(0)(value); 
}
var finalgroups = mapObjectWith(getPostRecords)(groupedtags);  
</code></pre>

<h2 id="summary">Summary</h2>

<p>In this post we've added a number of utility functions to our library.  We also took a circuitous route through transforming our initial data due to its many-to-many relationship between posts and tags.  We were then able to output a list of posts for each tag.</p>

<p>We also looked at a handful of common functional programming and combinative idioms like <code>pluck</code>, <code>map</code> and <code>mapObject</code>.  Be sure and look over <a href="https://gist.github.com/datchley/26bce4a05fde0226b405">the gist</a> of the full source for this second part of our blog series. </p>

<p>In the next and final blog post, we'll find out why we keep making right curried versions of all our functions as we discuss composition; and we'll finish our final requirement which is sorting each group of posts.</p>
        <ul class="tags">
            <li class="tag" id="tag-id-5"><a href="/tag/javascript/">javascript</a></li> 
            <li class="tag" id="tag-id-19"><a href="/tag/functional-programming/">functional programming</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t17" name="t17"></a><h1>17 : Understanding Prototypes, Delegation &amp; Composition</h1>
					<span>http://www.datchley.name/understanding-prototypes-delegation-composition/</span>
					<div class="tutorial__content">


					
<p>In the <a href="http://www.datchley.name/delegate-object-to-classical-inheritance/">last post</a> we covered the basics of creating and using Javascript objects, which included using <code>new</code> to invoke functions as constructors. In this post, we're going to focus on the following:</p>

<ul>
<li>how Javascript's prototype based objects work</li>
<li>building up functionality through <em>pseudo-classical inheritance</em> via constructor functions and the prototype chain</li>
<li>and a simpler, more idiomatic way to build up functionality using composition, delegation and mixins.</li>
</ul>

<h2 id="whatisthisprototypething">What is this 'prototype' thing?</h2>

<p>When most developers think of Object Oriented (OO) programming, they are usually coming from languages like Java and C++ where the concept of a <em>class</em> represents a kind of <em>blueprint</em> for a particular type of object's behavior. In those languages, a class is a separate, (<em>typically</em>) static representation of how an object should be created; and this is much different than an <em>instance</em> of an object created from that class.</p>

<p>Despite what some people might tell you, Javascript does not have classes.  What some developers refer to as a "class", is actually just a function, with other functions assigned to its <code>.prototype</code> property; which, in turn, is called with <code>new</code> in order to treat the function like a constructor.</p>

<pre><code>// Not a 'class', just a function
function Person(name) {  
  this.name = name;
}
Person.prototype.hello = function() {  
  console.log("Hello, my name is " + this.name);
};

// invoke our function with `new` for magical constructor behavior
var dave = new Person("Dave");  
dave.hello();  
// "Hello, my name is Dave"
</code></pre>

<p>The <code>.prototype</code> property of <code>Person</code> above is an actual property on the <code>Person</code> function (<em>functions are objects</em>). This property is treated as an object and used to create the actual prototype to which our new object is linked.  </p>

<p><strong>Note</strong>: In some browsers you can access an objects prototype using <code>__proto__</code> property - typically referred to using the <code>[[Prototype]]</code> symbol. </p>

<blockquote>
  <p>The actual prototype of an object "<em>is just another object</em>" to which it is linked</p>
</blockquote>

<p>Using the <code>.prototype</code> property of a function we can assign new properties so that when a new object is created from that constructor function, those properties are available on that object's actual prototype.  </p>

<p>To wit, the above code snippet yields the following relationships:</p>

<p><img src="http://www.datchley.name/content/images/2015/06/js-prototype-example--1-.png" alt=""></p>

<p>These prototypes in Javascript are really just a way to compose functionality. They allow an object to <em>delegate</em> behavior to its <em>prototype</em>, which is simply just another object that it links to via an internal, single path chain.  </p>

<p>This resembles "inheritance" in the sense that you can call a function on your object that isn't directly defined on that object, so long as it is defined on an object that your function links to in the prototype chain. </p>

<p>You may have heard this referred to as <em>prototypal inheritance</em>; but, in reality, this is simply Ojects Linking to Other Objects (<em>OLOO</em>), as <a href="http://davidwalsh.name/javascript-objects-deconstruction">Kyle Simpson</a> correctly termed it. The actual work is being accomplished via:</p>

<ul>
<li><strong>composition</strong> - your object contains another object, called its prototype, and</li>
<li><strong>delegation</strong> - when you access a property on your object, if it's not directly defined on it, javascript will search the prototype chain and delegate that behavior to the first object it finds that defines that property.</li>
</ul>

<h3 id="constructor"><code>.constructor</code></h3>

<p>Just to make OO concepts even muddier in Javascript, we also have the <code>.constructor</code> property. This property will reference a function used to create one of the objects in a given object's prototype chain. </p>

<p>When you call a function with <code>new</code> the <code>.constructor</code> property is set for you on the returned object's prototype.</p>

<p>In the case of our example above, we can inspect the <code>.constructor</code> property and see that it holds a reference to the <code>Person()</code> function, which we used to construct the object. </p>

<pre><code>dave.__proto__.constructor; // function Person()  
dave.__proto__.__proto__.constructor; // function Object()  
</code></pre>

<p><img src="http://www.datchley.name/content/images/2015/06/js-prototype-example--2-.png" alt=""></p>

<p>However, this direct relationship doesn't always hold true; especially when we start trying to implement <em>inheritance</em> using <code>new</code> and assigning prototypes. </p>

<pre><code>function Foo(){}

function Bar(){  
    // Call our parent constructor on our object
    Foo.call(this);
}
// "inherit" from Foo's prototype
Bar.prototype = Object.create(Foo.prototype);

var bar = new Bar();

console.log(bar.constructor);  
// function Foo() !WOOPS, that's not our constructor
</code></pre>

<p>By re-assigning the prototype, we end up with the <code>.constructor</code> property of the prototype object referencing <code>Foo()</code>, not the constructor of our <code>bar</code> object, which we expected to be <code>Bar()</code>. To fix that, we have to manually reassign the constructor right after setting its prototype.</p>

<pre><code>Bar.prototype = Object.create(Foo.prototype);  
Bar.prototype.constructor = Bar;  
</code></pre>

<h3 id="instanceof"><code>instanceof</code></h3>

<p>When using <code>new</code> for constructor functions, Javascript allows us to use <code>instanceof</code> to check if an object is an instance of a particular constructor function.  More precisely, <code>instanceof</code> checks if an object's prototype chain contains an instance of a given constructor's prototype.</p>

<p>For example:  </p>

<pre><code>function A(){}

function B(){}  
B.prototype = Object.create(A.prototype);

var obj = new B();  
console.log(obj instanceof B); // true  
console.log(obj instanceof A); // true  
console.log(obj instanceof Object);  // true  
console.log("%o", obj.constructor.prototype); // A {}  
</code></pre>

<p>However, <code>instanceof</code> can be problematic in some circumstances and return incorrect results:</p>

<ul>
<li>the prototype of the object in question has changed</li>
<li>you are comparing across frame/window execution contexts (<em>object from one frame, say an Array, checked in another frame will return false when doing <code>obj instanceof Array</code></em>)</li>
<li>you don't have a constructor function to use to introspect the object (<em>say, a third party library, module or closure</em>)</li>
</ul>

<p>For instance:  </p>

<pre><code>// Related objects whose constructors are out of scope
var a = (function(){  
    function A(){};
    return new A();
})();
var b = (function(proto) {  
    function B(){};
    B.prototype = proto;
    return new B();
})(a);

// Can we determine if b is related to a?
function F(){}  
F.prototype = a;  
console.log("Related? ", b instanceof F);  
// Related? true
</code></pre>

<p>In this case, we have two objects whose constructor functions weren't available for comparison using <code>instanceof</code>; so we create a throw-away function and assign the base object <code>a</code> to it's <code>.prototype</code> and then use <code>instanceof</code> to determine if <code>b</code> is an instance of the function <code>F()</code>. Rather, if the prototype of <code>F()</code> is anywhere in the prototype chain of <code>b</code>.</p>

<p>Clearly the object <code>b</code> was not constructed by the function <code>F</code>, but we still get a false positive because of how <code>instanceof</code> tests for ancestry using the constructor's prototype.</p>

<blockquote>
  <p><code>obj instanceof F</code> is semantically misleading. It does not imply that <code>obj</code> was created by <code>F()</code> or is even remotely related to <code>F()</code>; only that the prototype <code>F</code> will use when invoked with <code>new</code> is somewhere in the prototype chain of <code>obj</code>.</p>
</blockquote>

<h2 id="implementinginheritanceinjavascript">Implementing inheritance in Javascript</h2>

<p>So far we've seen that Javascript provides us with a number of "features" that make it <em>seem</em> as if it supports thinking about and implementing objects using classical inheritance. But, we've also seen the caveats that surround those features like <code>instanceof</code>, <code>new</code> to invoke functions as constructors and the <code>.constructor</code> and <code>.prototype</code> properties. </p>

<p>To implement classical inheritance, we need to understand the details of how it's implemented behind the scenes to fully appreciate that Javascript isn't really using "classes" or inheritance at all.</p>

<p>Let's give it a go with a simple, albeit contrived, example of inheritance with a <code>Dog</code> which inherits from <code>Animal</code>.</p>

<pre><code>// Our base "class" Animal
function Animal(name) {  
    this.me = name;
}
// Some base "class" methods
Animal.prototype.who = function() {  
    return "I am " + this.me;
};
Animal.prototype.speak = function() {  
    // What should this do? I dunno...
    console.log("(Animal) speak!");
}

// A child "class" that "inherits" from Animal
function Dog(name) {  
    Animal.call(this, name);
}
// Ensure we properly inherit from our base class
Dog.prototype = Object.create( Animal.prototype );  
Dog.prototype.constructor = Dog;

// Add our own 'speak' method and call our base class 'speak' as well
Dog.prototype.speak = function() {  
    Animal.prototype.speak.call(this); 
    console.log("Hello, " + this.who() + "." );
};

// Puppies! Awwwww
var fluffy = new Dog( "Fluffy" );  
var spot = new Dog( "Spot" );  
</code></pre>

<p>So, yeah, we now have a couple of talking dogs. Nothing to see here, move along...</p>

<p>Get a cup of coffee (<em>or your favorite beverage</em>) and sit down for second. Take some deep breaths; because as straight forward (<em>not so much</em>) as the above code looks, the following diagram shows what's actually happening under the hood:</p>

<p><img src="http://www.datchley.name/content/images/2015/06/classical-inheritance-js.png" alt=""></p>

<p>Seems like we're going to a lot of effort to treat Javascript like it has classes by </p>

<ul>
<li>using <code>new</code> to invoke functions as constructors</li>
<li>mimicking methods by assigning them to the function's <code>.prototype</code> property</li>
<li>ensuring that we create the proper relationships by setting the correct prototype for child classes and ensuring we call our parent class's constructor in the right context</li>
<li>and re-wiring the <code>.constructor</code> property of our <code>.prototype</code> to ensure it points to our actual constructor function</li>
</ul>

<p>In fact, this all boils down to jumping through hoops to basically ensure our objects properly compose behavior via creating the right linkage to another object via composition in the prototype chain.</p>

<p>I hear you asking, "<em>There must be a better, more idiomatic, way to do this in Javascript?</em>" </p>

<p>Yes, there is.</p>

<h2 id="delegationusingobjectcreate">Delegation using <code>Object.create()</code></h2>

<p>We used <code>Object.create()</code> above when creating the function prototypes. <code>Object.create()</code> does exactly what we really want - creating a linkage between objects by building an object based on another object.</p>

<p>So, maybe we can just use "plain objects", instead of constructor functions?</p>

<pre><code>var foo = { a: 1 };

var bar = Object.create(foo);  
bar.b = 2;

var baz = Object.create(bar);  
baz.c = 3;

console.log("I can haz 'a' and 'b'? ", !!(baz.a &amp;&amp; baz.b));  
// true
</code></pre>

<p><code>Object.create()</code> properly sets up the prototype linkage and gives us a new object; which we can then link to another object.  We don't have to worry about <code>instanceof</code> because we're not using functions as constructors; nor do we have to deal with setting a <code>.prototype</code> or <code>.constructor</code> property correctly.</p>

<p>So let's go back to our <code>Animal</code> and <code>Dog</code> example and see how we would compose that same functionality using delegation through <code>Object.create()</code> instead of constructors. </p>

<p>We'll use <code>Object.assign()</code> to initialize the objects in the our chain. Most browsers don't support <code>Object.assign()</code> yet, so you can use this simple polyfill to run the examples:</p>

<pre><code>if (!Object.prototype.assign) {  
    Object.prototype.assign = function() {
        var args = [].slice.call(arguments),
            target = args.shift();

        return args.reduce(function(base, obj) {
            Object.keys(obj).forEach(function(prop) {
                if (obj.hasOwnProperty(prop)) {
                    base[prop] = obj[prop];
                }
            });
            return base;
        }, target);
    }
}
</code></pre>

<p>The functionality we want to compose using delegation will be similar to our original; but delegation is a fundamentally different approach and pattern than inheritance.</p>

<ul>
<li>Delegation builds functionality by composing (<em>via links</em>) regular objects, not by using constructor functions.</li>
<li>Delegation uses more specific method names on the delegator objects that are reflective of the actions they perform. Inheritance keeps method names fairly generic, as sub-classes tend to re-implement specific behavior that override the base classes method. </li>
<li>State is typically maintained at the delegator level, not in the delegatee objects.</li>
</ul>

<pre><code>var Animal = {  
    who: function() { return this.name; },
    speak: function(s) { console.log(this.who() + ": " + s); }
}

var Dog = Object.create(Animal, {  
    bark: {
        value: function() { this.speak("woof!"); }
    }
});

var spot = Object.assign(Object.create(Dog), { name: "Spot" });  
var fluffy = Object.assign(Object.create(Dog), { name: "Fluffy" });

spot.bark();  
fluffy.bark();  
</code></pre>

<p>That's much less code; and here's the new mental model you'll have to grok.  Much easier!</p>

<p><img src="http://www.datchley.name/content/images/2015/06/js-object-create-example--2-.png" alt=""></p>

<p>We're composing functionality here using <code>Object.create()</code>. And the <code>bark()</code> method of our <code>Dog</code> objects delegates to <code>Animal.speak()</code>, available via its prototype chain. </p>

<p>The approach with the delegation pattern is to use an object as a base "type" that contains common behavior and have other objects link to that object to use that functionality. </p>

<p>In many respects, what we're trying to do is simply <em>compose behavior</em>, not create types, like inheritance does.  The relationship between two objects is explicit via composition using <code>Object.create()</code>, rather than implicit via an internal inheritance mechanism.</p>

<p>So, if we're wanting to really just compose behavior; and those behaviors might be common to a number of different objects, there is actually another pattern we can use: <strong>mixins</strong>. </p>

<h3 id="composingbehaviorthroughmixins">Composing Behavior through Mixins</h3>

<p>The concept of <em>mixins</em> is fairly wide spread and found in a number of languages.  The idea is to factor out common, reusable behavior into their own objects and then integrate those objects into more specific objects that need to use them.</p>

<pre><code>// A base object so we can create people
var Person = {  
    who: function(){ return this.name; },
    init: function(name) {
        this.name = name;
    }
};

// Factor out common functionality into their own
// objects
var canSpeak = {  
    speak: function(s) { console.log(this.who() + ": " + s); }
};
var canWalk = {  
    walk: function() { console.log(this.who() + " is walking..."); }
};
var canBuild = {  
    tools: ['hammer', 'pliers'],
    use: function(tool) { this.tools.push(tool); },
    build: function(thing) { 
        var withTool = parseInt(Math.floor(Math.random() * this.tools.length));
        console.log(this.who() + " is building a " + thing + " using " + this.tools[withTool]);
    }
};

// Can we build it?...
var bob = Object.assign(Object.create(Person), canSpeak, canWalk, canBuild);  
bob.init("Bob the Builder");  
bob.speak("Hi there!");  
bob.walk();  
bob.use("stapler");  
bob.build("web site");  
</code></pre>

<p>This pattern improves things by </p>

<ul>
<li>further simplifying the mental model used to create objects, </li>
<li>improves the readability of the code,</li>
<li>makes it very easy to isolate functionality in specific objects for better reuse. (<em>DRY, Separation of Concerns</em>)  </li>
</ul>

<p>Here's the inside view of using mixins.</p>

<p><img src="http://www.datchley.name/content/images/2015/06/js-prototype-example--3-.png" alt=""></p>

<p>What an object can do is explicitly stated through the use of mixins. Plus, we can add as many behaviors/mixins as make sense to an object.</p>

<p>We're still using delegation here, via the prototype chain; but mixins give us the ability to inherit from objects in a different way.  Mixins represent <em>concatenative inheritance</em>, meaning that instead of delegating behavior to another object, we copy that behavior directly. You can see this in the above diagram, as all the mixins' properties now exist on our new object.</p>

<h2 id="summary">Summary</h2>

<p>There are many libraries available that wrap the implementation of <em>inheritance</em> making it easier to program in Javascript if you come from a strict OO background or "class" centric language. But using inheritance and trying to maintain that mental model in Javascript is complex and hard to manage due to various problems.</p>

<p>With the end goal of simply being able to compose functionality, we found that the more idiomatic way to do that in Javascript is through simple objects, the prototype chain, and using new patterns of thinking in our design like <em>delegation</em> and <em>mixins</em>.</p>

<p>Hopefully this post has been enlightening for at least some of you; as this is a topic that is amply covered in books and online by various people - each with their own take on the subject.</p>

<hr>

<p><em>MDN can give you a good reference on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> if you're curious about the details.</em></p>

<p><em>Also, be sure and check out Kyle Simpson's <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes">You Don't Know JS: this &amp; Object Prototypes</a> and Eric Elliott's <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">Common Misconceptions about Inheritance in Javascript</a> for more on this subject and a much deeper insight.</em></p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t18" name="t18"></a><h1>18 : Some jQuery Functions And Their JavaScript Equivalents</h1>
					<span>http://callmenick.com/post/jquery-functions-javascript-equivalents</span>
					<div class="tutorial__content">
					

<p>In light of my recent forays into the JavaScript DOM world, I'd decided to do a little research and write a snippet collection based on jQuery functions and their JavaScript equivalents. I think jQuery is a great tool, and it has done great things for me and many others as developers. But I'm a firm believer that nowadays, JavaScript is an indispensable tool to keep in your arsenal. Manipulating the DOM with JavaScript DOM methods is fun and easy, and the majority of times, plain old vanilla JS is all we need. It seems scary at first, but let's take a look at some core functions/methods that we're accustomed to, how they work, and how to execute them with just plain old JavaScript.</p>
<h2>Accessing Elements</h2>
<p>There are many ways to access elements with JavaScript and jQuery. Let's look at a few important ones here.</p>
<h3>By ID</h3>
<p>In this above scenario, we're accessing by ID, so we'd expect that only one element is returned. With jQuery, we tend to access single elements by ID like this:</p>
<pre><code class="language-javascript">var el = $("#element");</code></pre>
<p>With regular JS, we can achieve this two ways:</p>
<pre><code class="language-javascript">// traditional JS
var el = document.getElementById("element");

// new school JS
var el = document.querySelector("#element");</code></pre>
<p>From here on, we can use these variables and apply our manipulations whenever we want. We've successfully assigned an element to a variable, and can now use it wherever we want.</p>
<h3>By Class &amp; Tag</h3>
<p>In jQuery, we also see that we can access all elements that have a certain class or tag. This is useful when we want to iterate over all of these elements and perform functions on them. We'd access them like this:</p>
<pre><code class="language-javascript">// access by tag name
var els = $("p");

// access by class
var els = $(".class");</code></pre>
<p>Here's the JavaScript equivalents:</p>
<pre><code class="language-javascript">// by tag name
var els = document.getElementsByTagName("p");        // OR
var els = document.querySelectorAll("p");

// by class name
var els = document.getElementsByClassName("class");    // OR
var els = document.querySelectorAll(".class");</code></pre>
<h3>Useful Tips</h3>
<p>The methods <code>getElementsByTagName</code>, <code>getElementsByClassName</code>, <code>querySelector</code>, and <code>querySelectorAll</code> can be applied to DOM elements to return collections of elements or node lists that are children of an element in question. We can, for example, do this:</p>
<pre><code class="language-javascript">var wrapper = document.getElementById("wrapper"),
    els = wrapper.querySelectorAll("p");</code></pre>
<p>A jQuery equivalent would be this:</p>
<pre><code class="language-javascript">var els = $("#wrapper p");</code></pre>
<h3>Caveats</h3>
<p>Here are some things to note:</p>
<ol>
<li>Using <code>querySelector</code> on an element that exists more than once (e.g.: <code>querySelector("p")</code> will return the first matching element.</li>
<li>Technically, <code>querySelectorAll</code> returns a non-live node list of elements. This is in contrast to the HTMLCollection returned by <code>getElementsByTagName</code> and <code>getElementsByClassName</code>. Be mindful of that! </li>
</ol>
<h2>Getting &amp; Setting the HTML of an Element</h2>
<p>It's fairly common practice in simple interfaces that after a user commits to a call to action, the HTML of an element is replaced. This can be to display a success or error message after a form submission, for example. Sometimes, we might want to fetch the HTML contents of an element and throw it into another element in our DOM. With jQuery, this is made possible by the simple <code>.html()</code> function. Here it is in action:</p>
<pre><code class="language-javascript">// getting the HTML
var content = $("#content").html();

// setting the HTML
$("#box").html(content);</code></pre>
<p>With JavaScript, we're presented with the function <code>innerHTML</code> that serves the same purpose. Here's a replication of the above, but with pure JavaScript:</p>
<pre><code class="language-javascript">// getting the HTML
var content = document.getElementById("content").innerHTML;

// setting the HTML
document.getElementById("box").innerHTML = content;</code></pre>
<p>Be mindful when using <code>innerHTML</code> though. According to the MDN:</p>
<blockquote>
<p>If a <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>, or <code>&lt;noembed&gt;</code> node has a child text node that includes the characters (&amp;), (&lt;), or (&gt;), innerHTML returns these characters as <code>&amp;amp</code>, <code>&amp;lt</code> and <code>&amp;gt</code> respectively. Use <code>Node.textContent</code> to get a correct copy of these text nodes' contents.</p>
</blockquote>
<h2>Attaching Event Handler Functions to Elements</h2>
<p>A very important part of JavaScript programming is attaching evened handler functions, or "listening" for events on elements in the DOM. These events range from click and hover, to blur. jQuery offers us a lot of direct attachment of event handlers, for example <code>$("#el").click();</code>, but we're going to look at a jQuery function that resembles pure JavaScript, and is very useful - the <code>.on()</code> function. Here it is in action, listening for a click on an element:</p>
<pre><code class="language-javascript">// listening for a click on #el
$("#el").on("click", function(){
    console.log("element clicked");
});</code></pre>
<p>The above should output "element clicked" to the console. With JavaScript, the implementation is friendly and straightforward. In fact, the name itself is very self explanatory. Here's the implementation:</p>
<pre><code class="language-javascript">// listening for a click on #el
document.querySelector("#el").addEventListener("click", function(){
    console.log("element clicked");
});</code></pre>
<h3>Multiple Event Handlers with jQuery</h3>
<p>Here's something cool to note though. With jQuery, we can add multiple event handlers on the same element by comma-separating them before the function is called. Here's an example:</p>
<pre><code class="language-javascript">// listening for a click and hover on #el
$("#el").on("click", "hover", function(){
    console.log("click or hover");
});</code></pre>
<h2>Appending and Prepending Content</h2>
<p>Often, we want to append or prepend some additional information or message to an element after user interaction. jQuery provides us two neat functions to take care of this -  <code>.append()</code> and <code>.prepend()</code>. The names give away their functionality, so let's look at some implementation:</p>
<pre><code class="language-javascript">// append "success" message to a log
$("#log").append("&lt;p&gt;Success!&lt;/p&gt;");

// prepend "error" message to a log
$("#log").prepend("&lt;p&gt;Error...go back and fix.&lt;/p&gt;");</code></pre>
<p>For appending content, JavaScript offers us a self explanatory function too - <code>Node.appendChild</code>. In this case though, we are dealing with nodes, so we can't directly insert content. Instead, we must insert a node that contains content. Let's take a look at this function in action:</p>
<pre><code class="language-javascript">// create an element, give it some HTML, append it to #log
var p = document.createElement("p");
p.innerHTML = "Success!";
document.getElementById("log").appendChild(p);</code></pre>
<p>Prepending isn't as straightforward, as there is no <code>Node.prependChild</code> function in JavaScript. However, using a combination of <code>insertBefore</code> and <code>firstChild</code>, we can insert our node before the first child of the element in question, i.e. prepending our node to <code>#log</code>. Let's take a look at this in action:</p>
<pre><code class="language-javascript">// create an element and get our #log div
var p = document.createElement("p"),
    log = document.getElementById("log");

// add some HTML to p
p.innerHTML = "Error...go back and fix.";

// prepend p to #log
log.insertBefore(p, log.firstChild);</code></pre>
<h2>Altering the CSS of an Element</h2>
<p>Users tend to feel more welcome and safe when they feel this sense of familiarity. It's not uncommon then to see different colours or styles of things changing based on user interaction. Form failed to submit? Change the background colour to red. Successful submission? Change it to green. Want to hide the form after successful submission? Set the property to <code>display: none</code>. These are attributes of DOM elements that can all be controlled via CSS. jQuery conveniently gives us the <code>.css()</code> function to tap into an elements CSS. Let's take a look how:</p>
<pre><code class="language-javascript">// this will output the element's background colour
var col = $("#el").css("background-color");
console.log(col);

// this will change the element's background colour to green
$("#el").css("background-color", "green");

// alternate syntax for passing array into .css
$("#el").css({
    "background-color": "green",
    "colour": "white"
});</code></pre>
<p>On the vanilla JS side of things, we're presented with the function <code>HTMLElement.style</code>. This allows us to set the style of an element. Here it is in action:</p>
<pre><code class="language-javascript">// change the colour of #el to green
document.getElementById("el").style.color = "green";</code></pre>
<p>To actually get the style attribute of an element is a bit different though. According to the MDN:</p>
<blockquote>
<p>The style property is not useful for learning about the element's style in general, since it represents only the CSS declarations set in the element's inline style attribute, not those that come from style rules elsewhere, such as style rules in the <code>&lt;head&gt;</code> section, or external style sheets. To get the values of all CSS properties for an element you should use <code>window.getComputedStyle()</code> instead.</p>
</blockquote>
<p>In jQuery, a similar function goes down when getting the style. Here's a look at <code>window.getComputedStyle()</code> in action:</p>
<pre><code class="language-javascript">// this will return the computed colour of "el"
var el = document.getElementById("el");
var elStyle = window.getComputedStyle(el, null);
console.log(elStyle.color);</code></pre>
<h2>Iterating Over a Collection of Elements</h2>
<p>The last comparison we'll go through is of significant importance as it entails looping. Looping is a very important part of any programming language, and JavaScript is no different. Often times, we need to iterate over a collection of elements and perform some functionality to each of those elements. This is what loops are for.</p>
<p>Let's target all elements in our DOM with a class of <code>.el</code>, loop over them, and change the colour to blue. With jQuery, the <code>.each()</code> function gives us a nice starting point. Combining what we've learnt above, here's the implementation:</p>
<pre><code class="language-javascript">$(".el").each(function(i, el){
    /**
     * i represents the integer value of where we are in the loop
     * el represents the element in question in the current loop
     * $(this) also represents the element in question in the current loop
     */

    // change the element colour to blue.
    $(this).css({
        "colour": "blue"
    });    
});</code></pre>
<p>With JavaScript, we can use a simple <code>for</code> loop to take care of this. The thought process behind it is the same - get a collection of HTML elements, loop over them, and edit them. Here's how:</p>
<pre><code class="language-javascript">// get all elements with class .el
var els = document.querySelectorAll(".el");

// loop over them while i less than number of elements
for (var i = 0, len = els.length; i &lt; len; i++) {
  els[i].style.backgroundColor = "blue";
}</code></pre>
<h3>Bonus</h3>
<p>Here's some swanky alternative JavaScript syntax that resembles the <code>.each()</code> function a bit more. It's a <code>forEach</code> function, and we first create an empty array and then add each of the nodes to it. After that, we iterate using a <code>forEach</code> statement. Here it is in action:</p>
<pre><code class="language-javascript">[].slice.call(document.querySelectorAll(".el")).forEach(function(el,i){
    /**
     * i represents the integer value of where we are in the loop
     * el represents the element in question in the current loop
     */

     // change the element colour to blue.
     el.style.backgroundColor = "blue";
});</code></pre>
<h2>Wrap Up</h2>
<p>And that's a wrap! We've looked at some common and important jQuery/JavaScript comparisons, and seen that JavaScript isn't that scary after all. I'm not taking anything away from jQuery, I think it's amazing. But if you're using jQuery because you're scared to dive in to vanilla JS, then you shouldn't be. In 2014, JavaScript is a very important language and can take you far. I hope this collection of snippets helped clear the air for you a bit and got your feet a little wet with JS programming. If you have any comments, feedback, suggestions, or questions, feel free to leave them below.</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t19" name="t19"></a><h1>19 : Is everything in JavaScript an Object?</h1>
					<span>https://blog.simpleblend.net/is-everything-in-javascript-an-object/</span>
					<div class="tutorial__content">



          
      <p>I have always found this statement confusing: "Everything in JavaScript is an Object". What did they mean by this? How can a Function or an Array at the same time be an Object? Before we tackle this question, we need to understand how the different Data Types are categorized.</p>
<p>In JavaScript, there are two Data Types: <strong>Primitives</strong> and <strong>Objects</strong>. (Object Types are also sometimes referred to as Reference Types). <span class="citation-num" data-citation-num="1">1</span></p>
<table>
<thead>
<tr>
<th>Primitive</th>
<th>Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td>Function</td>
</tr>
<tr>
<td>String</td>
<td>Object</td>
</tr>
<tr>
<td>Boolean</td>
<td>Array</td>
</tr>
<tr>
<td>Symbol</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
</tr>
<tr>
<td>undefined</td>
<td></td>
</tr>
</tbody>
</table>
<p>Based on this categorizing, the simple anwser is no, not everything in JavaScript is an Object. Only values that belong to that Type are Objects. Another way of looking at it is, any Type that isn't a Primitive Type is an Object Type. But what is it that <em>differentiates</em> Primitives from Objects? And more importantly, what do people <em>really mean</em> when they say "everything" or "almost everything" is an Object"? There are two main distinctions: mutability, and comparison.</p>
<h2>Mutability</h2>
<p>From my experience, what people <em>really mean</em> when they talk about values being "object like" is their mutability. More specifically, they're talking about the ability to add and remove properties. For example, because Functions and Arrays belong to the Object Type you can add properties to them just like you would an object literal.</p>
<pre><code class="language-javascript">var func = function() {};
func.firstName = "Andrew";
func.firstName; // "Andrew"

var arry = [];
arry.age = 26;
arry.age; // 26
</code></pre>
<p>This opens the door to all sorts of fascinating use cases, and is really the key to understanding how Prototypes and Constructors work.</p>
<p>However because Primitive Types are immutable, we're unable to assign properties to them. <span class="citation-num" data-citation-num="2">2</span> The parser will immediately discard them when attemping to read their value.</p>
<pre><code class="language-javascript">var me = "Andrew";
me.lastname = "Robbins";
me.lastname; // undefined

var num = 10;
num.prop = 11;
num.prop; // undefined
</code></pre>
<p>At this point, I think it would be useful to examine things at a more fundamental level. With regards to primitives, what does it really mean to say that their values cannot be changed? Consider the following code:</p>
<pre><code class="language-javascript">1 = 2; // ReferenceError
</code></pre>
<p>This might seem like a silly example, but I think it shines a much needed light on exactly what we're talking about when we talk about mutability. When you type the number 1 into the JavaScript console, the compiler assigns that piece of data to the Primitive data type. Therefore when you attempt to change the number 1 to the number 2, it fails and probably has a heartattack.</p>
<h2>Comparison and passing around</h2>
<p>Besides mutability, another important distinction between Primitive Types and Object Types is the way they're compared and passed around within the program. Primitive Types are compared by value, while Object Types are compared by reference. What does this mean? Let's look at Primitives first. Consider the following code:</p>
<pre><code class="language-javascript">"a" === "a"; // true
</code></pre>
<p>This is true because the value "a" is equal to "a". Simple. However what happens when we introduce variables into the picture? Nothing has changed except that we're now storing our Primitive Types into variables.</p>
<pre><code class="language-javascript">var a = "a",
    b = "a";

a === b; // true
</code></pre>
<p>Since Primitive Types are compared by value, the result will true. The value of the variable a is exactly equal to the value of the variable b. In other words, "a" equals "a". Aristotle would be proud. However look at this. If we apply the same example to an Object Type, we get the opposite result.</p>
<pre><code class="language-javascript">var a = {name: "andrew"},
    b = {name: "andrew"};

a === b; // false
</code></pre>
<p>Why is this? Object Types must reference the same object in order for its comparison to be true. In the example above, we're creating a <em>new</em> object for the variable b. As David Flanagan puts it:</p>
<blockquote><p>"…we say that objects are compared by reference: two object values are the same if and only if they refer to the same underlying object." <span class="citation-num" data-citation-num="3">3</span></p></blockquote>
<p>Now, what happens when we pass these values around?</p>
<pre><code class="language-javascript">var a = {name: "andrew"},
    b = a;

b.name = "robbins";

a === b; // true
</code></pre>
<p>This might seem strange at first, but look closer at what's happening. Because objects are part of the Object type, it's values are compared and passed by reference. Reference to what? Reference to the same underlying object. In the above example, we're setting b equal to a. We didn't create a <em>new</em> object. We're simply creating a <em>reference</em> to another object. A different way of looking at it is that we're pointing the variable b to a. Therefore when we mutate the "name" property on b, we're at the same time mutating the "name" property on a.</p>
<p>Back to Primitives, how would the same example apply to them?</p>
<pre><code class="language-javascript">var a = "Andrew",
    b = a;

b = "Robbins";

a === b; // false
</code></pre>
<p>Remembering that Primitives are compared and passed by value, when we set b equal to a, we're actually creating a new copy of a. Therefore when we change the value of b and then compare it to a, the value is not the same anymore.</p>
<h2>Wrapper Objects</h2>
<p>Some of you may be wondering, "Ok, if Primitives aren't Objects then why can I call methods on them?" The answer is Wrapper Objects.</p>
<p>When you attempt to call methods on a Primitive, JavaScript does a magic trick behind the scenes. It takes your Primitive value and converts it to a <em>temporary</em> Object using a constructor function. <span class="citation-num" data-citation-num="4">4</span> The decision of which constructor function to use will depend on the Primitive value you're attempting to change. For example, calling .length on a string will use the built in String() constructor to <em>temporarily</em> change the Primitive to an Object—allowing you to use the length method to mutate it. This temporary Object is called a Wrapper Object. <span class="citation-num" data-citation-num="5">5</span></p>
<p>Interestingly enough, the two Primitive values null and undefined do not behave this way. Trying to call methods on these values will result in a TypeError.</p>
<p>We can use the typeof keyword to show the difference.</p>
<pre><code class="language-javascript">typeof "s"; // "string"
typeof new String(s); // "object"
</code></pre>
<p>As a sidenote, it's useful to know that there's a well-documented bug <span class="citation-num" data-citation-num="6">6</span> in JS compilers which returns "object" when executing typeof null.</p>
<pre><code class="language-javascript">typeof null // "object"
</code></pre>
<p>Considering that JavaScript was written in 10 days <span class="citation-num" data-citation-num="7">7</span>, I'm not going to lose any sleep over it =)</p>
<p>It's also useful to know that properties on Primitives are read-only, and temporary.</p>
<pre><code class="language-javascript">var hello = "hello";
hello.slice(1); // "ello" (Here we're actually calling slice not on hello, but of a copy of hello)
hello; // "hello"
</code></pre>
<h2>Summary</h2>
<p>JavaScript values can be categorized into two Types: Primitives and Objects. The Primitive Types are String, Number, Boolean, Symbol, undefined and null. The Object Types are Function, Object and Array.</p>
<p>The two distinctions between Primitives and Objects are their mutability and the way they're compared and "passed around" within the program.</p>
<p>Primitives are immutable. Another way of saying this is that their values can't be changed. On the other hand, Objects are mutable. Their values can be updated and changed.</p>
<p>Primitives are compared by value. When assigning one primitive to another using variables, a copy is made. Objects on the other hand are compared by reference. Reference to what? Reference to the underlying Object. When assigning one Object to another, a reference / pointer is created. At this stage, mutating a value on one Object will update the value on the other Object.</p>
<p>When attempting to call methods on Primitive values, JavaScript uses a Wrapper Object to temporarily coerce the Primitive. The resulting Object is read-only and garbage collected after execution.</p>
<p>In the next section, we'll go over how these Types fit into the bigger picture by analyzing Prototypes, Constructors, and Inheritance.</p>
<h2>Update: 11/8/14</h2>
<p>Recently there was a discussion over at <a href="https://javascriptkicks.com/stories/1669">https://javascriptkicks.com/stories/1669</a> regarding the performance of both Objects and Primitives. <a href="https://twitter.com/drewpcodes">@drewpcodes</a> wanted to know which approach would be faster: storing floating point numbers in Primitive form or Objects form? I was curious to know as-well so I wrote a small program to test it out. You can find the code I used here: <a href="http://jsfiddle.net/pmqortov">http://jsfiddle.net/pmqortov</a></p>
<p>I created two arrays: one array stored the data as Objects, and another stored the data as Primitives. Based on <a href="https://twitter.com/drewpcodes">@drewpcodes</a> use-case, the data I used was 150 floating point numbers. I also decided to limit both arrays to 150 entries so it wouldn't freeze my computer.</p>
<p>I then iterated over the arrays and saved a timestamp before and after every iteration. Then I did a little math on each timestamp and found the average in ms. For the sake of accuracy, I looped 5000 times for each instance. I noticed increasing this number would freeze Chrome. =)</p>
<p>Surprisingly enough, the list containing the data stored as Objects was actually 2ms faster then stored as Primitives! Here were the actual numbers:</p>
<pre><code class="language-javascript">// List with Objects 
// Average execution across 5000 repetitions: 16.8528 ms 
 
// List with Primitives 
// Average execution across 5000 repetitions: 18.2898 ms 
</code></pre>
<p>At this point I don't have an opinion either way of which method is best for storing your data. It could be that at higher volumes the Object method would be advantagous, but I'd like to see more evidence first.</p>
<p>Cheers!</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t20" name="t20"></a><h1>20 : Partial Application with Function#bind</h1>
					<span>http://adripofjavascript.com/blog/drips/partial-application-with-function-bind.html</span>
					<div class="tutorial__content">
<div class="post">
        <h1 class="post-title">Partial Application with Function#bind</h1>
        
            <p><i>
                Originally published in the 
                <a href="/">A Drip of JavaScript newsletter</a>.
            </i></p>
        

        <p>In <a href="/blog/drips/partial-application-with-function-bind.html">last week's drip</a>, we covered using <code>bind</code> to create bound functions. But <code>bind</code> is also a very convenient way of implementing partial application. First, let's take a look at exactly what partial application is.</p>

<p>According to <a href="https://en.wikipedia.org/wiki/Partial_application">Wikipedia</a>, partial application "refers to the process of fixing a number of arguments to a function, producing another function of smaller arity." Arity refers to the number of arguments that a function takes.</p>

<p>Here's an example:</p>
<pre><code>function multiply (x, y) {
    return x * y;
}

function double (num) {
    return multiply(2, num);
}
</code></pre>
<p>That's a very rudimentary form of partial application, where inside <code>double</code> we permanently fix <code>multiply</code>'s first argument as <code>2</code>, producing a new function <code>double</code>.</p>

<p>But explicitly declaring the body of the new function isn't actually necessary if you use <code>bind</code>. Here's how we could rewrite that:</p>
<pre><code>function multiply (x, y) {
    return x * y;
}

var double = multiply.bind(null, 2);
</code></pre>
<p>As we covered last time, the first argument to <code>bind</code> sets it's internal <code>this</code> value. Since our function doesn't depend on <code>this</code>, we just pass in <code>null</code>. But any subsequent arguments that we supply will be used to permanently fix the arguments of the function we are binding. In this case, we are only fixing one argument, but we can potentially fix as many as we want.</p>
<pre><code>function greet (salutation, person, delivery) {
    var message = '"'+ salutation + ', ' + person + '," ' +
                  delivery + ' the greeter.';

    console.log(message);
}

var hail = greet.bind(null, "Hail");

// Outputs: '"Hail, Lord Elrond," said the greeter.'
hail("Lord Elrond", "said");

var begone = greet.bind(null, "Begone", "Wormtongue", "commanded");

// Outputs: '"Begone, Wormtongue," commanded the greeter.'
begone();
</code></pre>
<p>One thing you may have noticed is that <code>bind</code> always fixes the arguments from left to right. This means that it isn't suitable for all forms of partial application, but it does cover the most common ones.</p>

<p>You may be wondering if partial application is actually all that useful in real code. To answer, let's revisit an example from our <a href="http://designpepper.com/blog/drips/using-dispatch-tables-to-avoid-conditionals-in-javascript">discussion of dispatch tables</a>:</p>
<pre><code>var commandTable = {
    north:    function() { movePlayer("north"); },
    east:     function() { movePlayer("east");  },
    south:    function() { movePlayer("south"); },
    west:     function() { movePlayer("west");  },
    look:     describeLocation,
    backpack: showBackpack
};

function processUserInput(command) {
    commandTable[command]();
}
</code></pre>
<p>In this example we are taking user input from a text adventure game, and then calling the appropriate command from <code>commandTable</code>. As you can see, we're using the same rudimentary form of partial application that we saw in our first example.</p>

<p>Using <code>bind</code> we can clean this up a bit.</p>
<pre><code>var commandTable = {
    north:    movePlayer.bind(null, "north"),
    east:     movePlayer.bind(null, "east"),
    south:    movePlayer.bind(null, "south"),
    west:     movePlayer.bind(null, "west"),
    look:     describeLocation,
    backpack: showBackpack
};

function processUserInput(command) {
    commandTable[command]();
}
</code></pre>
<p>As I mentioned last time, <code>bind</code> isn't available in IE8 and older, so you may want to use a polyfill or library to achieve the same functionality. If you only want to implement partial application and don't need to create bound functions, you might want to consider the <code>partial</code> methods in <a href="http://underscorejs.org/#partial">Underscore</a> and <a href="http://lodash.com/docs#partial">Lo-Dash</a>.</p>

    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t21" name="t21"></a><h1>21 : Partial Application in JavaScript</h1>
					<span>http://blakeembrey.com/articles/2014/01/partial-application-in-javascript/</span>
					<div class="tutorial__content">
						<article class="content article"><p>Partial application is the act of pre-filling arguments of a function and returning a new function of smaller arity. The returned function can be called with additional parameters and in JavaScript, the <code>this</code> context can also be changed when called. Using a partially applied function is extremely common in functional programming with JavaScript as it allows us to compose some really nifty utilities and avoid repeating ourselves in code.</p>
<p>In modern JavaScript engines, there is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind function</a> which can be used to achieve a similar result. The difference between <code>partial</code> and <code>bind</code> is that the a partial functions <code>this</code> context is set when the returned function is called, while a bound functions <code>this</code> context has already been defined and can't be changed.</p>
<pre><code>var __slice = Array.prototype.slice;

/**
 * Wrap a function with default arguments for partial application.
 *
 * @param  {Function} fn
 * @param  {*}        ...
 * @return {Function}
 */
var partial = function (fn /*, ...args */) {
  var args = __slice.call(arguments, 1);

return function () {
    return fn.apply(this, args.concat(__slice.call(arguments)));
  };
};
</code></pre>
<p>From the function above, we can understand that <code>partial</code> accepts the function to be pre-filled and it's default arguments. It then returns a new function which can be called with some more arguments. It's important to note that the context (<code>this</code>) is being defined when the returned function is called. But when would you even want to use this?</p>
<p>Normally I would be happy to give a simple example of transforming an <code>add</code> function into an <code>add5</code> by partially applying it - <code>partial(add, 5)</code>. This definitely demonstates how we can use the utility, but doesn't really touch on why.</p>
<p>Consider writing a logging utility that accepts some different arguments that need to be logged - <code>var log = function (type, value) {}</code>. Fantastic, it looks like a really simple function to use. But now we want set every log in our file to the <code>testing</code> type. We can do a couple of things to achieve this. One option would be to assign our type to a variable and reuse the variable - <code>var testType = 'Testing'</code> and <code>log(testType, value)</code>. This will get messy after we write it more than once. What if we just wrapped the <code>log</code> function automatically?</p>
<pre><code>var testLog = function () {
  return log.apply(this, ['testing'].concat(__slice.call(arguments)));
};
</code></pre>
<p>Great, this looks familiar - we could have just used partial - <code>var testLog = partial(log, 'Testing')</code>. Now we have a function we can continue to reuse any number of times without fear of repeating ourselves.</p>
<h2 id="bonus-points">Bonus Points</h2>
<p>If you've been reading any of my previous blog posts, you may have noticed me abusing the usefulness of <a href="http://blakeembrey.com/articles/forcing-function-arity-in-javascript/">function arity</a> in anonymously returned functions. And in another article I wrote about a utility that can help us remove the <a href="http://blakeembrey.com/articles/javascript-variadic-function/">repetitive argument slicing</a>. If you haven't checked out these utilities yet, take a quick look and I bet you'll see how we could use them here.</p>
<pre><code>var partial = variadic(function (fn, args) {
  var remaining = Math.max(fn.length - args.length, 0);

  return arity(remaining, variadic(function (called) {
    return fn.apply(this, args.concat(called));
  }));
});
</code></pre>
<p>Now the returned partially applied function gives us the correct number of trailing arguments still to be filled using the <code>arity</code> utility. On top of that, we managed to get rid of slicing arguments constantly by using the <code>variadic</code> utility. In fact, I've been so interested in these reusable utilities that I published the <a href="https://github.com/blakeembrey/partial">partial utility on Github</a> so I can reuse it later.</p>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t22" name="t22"></a><h1>22 ; Composing Functions in JavaScript</h1>
					<span>http://blakeembrey.com/articles/2014/01/compose-functions-javascript/</span>
					<div class="tutorial__content">
<article class="content article"><p>Composing multiple functions to create more complex ones is a common utility in any programming language. And the ability to construct functions in a way that is easily composable is a true talent, but it really shines with code maintenance and reuse. It's not uncommon to find huge applications composed of many, much smaller functions. Inspired by this pattern of extremely modular functions, I've been slowly migrating my programming style to allow for more composable and reusable functions.</p>
<p>To compose functions together, we will need to accept a list of functions for it to be made up from. Let's call the functions <code>a</code>, <code>b</code> and <code>c</code>. Now that we have the list of functions, we need to call each of them with the result of the next function. In JavaScript, we would do this with <code>a(b(c(x)))</code> - with <code>x</code> being the starting value. However, it would be much more useful to have something a little more reusable than this.</p>
<pre><code>var compose = function () {
  var fns = arguments;

  return function (result) {
    for (var i = fns.length - 1; i &gt; -1; i--) {
      result = fns[i].call(this, result);
    }

    return result;
  };
};
</code></pre>
<p>The above function iterates over the function list (our arguments) in reverse - the last function to pass in is executed first. Given a single value as the initial input, it'll chain that value between every function call and return the final result. This allows us to do some really cool things.</p>
<pre><code>var number = compose(Math.round, parseFloat);

number('72.5'); //=&gt; 73
</code></pre>
<h2 id="sequence">Sequence</h2>
<p>Another utility I've seen about in some functional libraries is called <a href="https://github.com/raganwald/allong.es#functional-composition">sequence</a>. It's very similar to <code>compose</code>, except the arguments are executed in reverse. For example:</p>
<pre><code>var sequence = function () {
  var fns = arguments;

  return function (result) {
    for (var i = 0; i &lt; fns.length; i++) {
      result = fns[i].call(this, result);
    }

    return result;
  };
};
</code></pre>
<p>However, we should make a note of the almost identical function signature to <code>compose</code>. Usually, seeing something like this should trigger a warning in your head to find some way to reuse previous functionality, instead of replicating it. In this example, we can reuse the <code>compose</code> function to write the <code>sequence</code> implementation.</p>
<pre><code>var __slice = Array.prototype.slice;

var sequence = function () {
  return compose.apply(this, __slice.call(arguments).reverse());
};
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t23" name="t23"></a><h1>23 : A JavaScript Invoke Function</h1>
					<span>http://blakeembrey.com/articles/2014/01/javascript-invoke-function/</span>
					<div class="tutorial__content">
<article class="content article"><p><strong>Update:</strong> Now available on <a href="https://github.com/blakeembrey/invoke">github</a> and <a href="https://www.npmjs.org/package/util-invoke">npm</a>.</p>
<p>Under certain functional JavaScript toolbelts, we can find a utility that is used purely for invoking a method on a passed in object. The utility is a really simple snippet that can be used in a number of different circumstances.</p>
<pre><code>var __slice = Array.prototype.slice;

var invoke = function (method /*, ...args */) {
  var args = __slice.call(arguments, 1);

  return function (obj /*, ..args */) {
    return obj[method].apply(obj, args.concat(__slice.call(arguments, 1)));
  };
};
</code></pre>
<p>The most useful situation for a utility such as this is in combination with other functional utilities and iterators. Consider the case where we have an array of objects with identical methods. Not uncommon in a complex MVC application where you may be tracking child views. To remove every child view, we need to iterate over an array of views and call <code>remove</code>.</p>
<pre><code>var children = [/* ... */];

children.forEach(invoke('remove'));
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t24" name="t24"></a><h1>24 : YOU MIGHT NOT NEED JQUERY</h1>
					<span class="ref-site">http://youmightnotneedjquery.com/</span>
					<div class="tutorial__content">
<div class="comparisons">
      <div class="empty-message">Your search didn't match any comparisons.</div>
      <section id="ajax" class="odd">
        <div class="inner">
          <h2>AJAX</h2>
          <div class="alternatives-block">
            <h4>Alternatives:</h4>
            <ul class="alternatives">
              <li><a href=" https://github.com/ded/Reqwest" target="_blank">reqwest</a></li>
              <li><a href=" https://github.com/then/request" target="_blank">then-request</a></li>
              <li><a href=" https://github.com/visionmedia/superagent" target="_blank">superagent</a></li>
            </ul>
          </div>
          <div id="json" class="comparison">
            <h3><a href="#json">JSON</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.getJSON('/my/url', function(data) {

});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onreadystatechange = function() {
  if (this.readyState === 4) {
    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
      // Success!
      var data = JSON.parse(this.responseText);
    } else {
      // Error :(
    }
  }
};

request.send();
request = null;
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onload = function() {
  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) {
    // Success!
    var data = JSON.parse(request.responseText);
  } else {
    // We reached our target server, but it returned an error

  }
};

request.onerror = function() {
  // There was a connection error of some sort
};

request.send();
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onload = function() {
  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
    // Success!
    var data = JSON.parse(this.response);
  } else {
    // We reached our target server, but it returned an error

  }
};

request.onerror = function() {
  // There was a connection error of some sort
};

request.send();
</code></pre>
            </div>
          </div>
          <div id="post" class="comparison">
            <h3><a href="#post">Post</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.ajax({
  type: 'POST',
  url: '/my/url',
  data: data
});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('POST', '/my/url', true);
request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
request.send(data);
</code></pre>
            </div>
          </div>
          <div id="request" class="comparison">
            <h3><a href="#request">Request</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.ajax({
  type: 'GET',
  url: '/my/url',
  success: function(resp) {

  },
  error: function() {

  }
});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onreadystatechange = function() {
  if (this.readyState === 4) {
    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
      // Success!
      var resp = this.responseText;
    } else {
      // Error :(
    }
  }
};

request.send();
request = null;
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onload = function() {
  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) {
    // Success!
    var resp = request.responseText;
  } else {
    // We reached our target server, but it returned an error

  }
};

request.onerror = function() {
  // There was a connection error of some sort
};

request.send();
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>var request = new XMLHttpRequest();
request.open('GET', '/my/url', true);

request.onload = function() {
  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) {
    // Success!
    var resp = this.response;
  } else {
    // We reached our target server, but it returned an error

  }
};

request.onerror = function() {
  // There was a connection error of some sort
};

request.send();
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section id="effects">
        <div class="inner">
          <h2>Effects</h2>
          <div class="alternatives-block">
            <h4>Alternatives:</h4>
            <ul class="alternatives">
              <li><a href=" http://daneden.github.io/animate.css/" target="_blank">animate.css</a></li>
              <li><a href=" https://github.com/visionmedia/move.js" target="_blank">move.js</a></li>
            </ul>
          </div>
          <div id="fade_in" class="comparison">
            <h3><a href="#fade_in">Fade In</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).fadeIn();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function fadeIn(el) {
  var opacity = 0;

  el.style.opacity = 0;
  el.style.filter = '';

  var last = +new Date();
  var tick = function() {
    opacity += (new Date() - last) / 400;
    el.style.opacity = opacity;
    el.style.filter = 'alpha(opacity=' + (100 * opacity)|0 + ')';

    last = +new Date();

    if (opacity &lt; 1) {
      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16);
    }
  };

  tick();
}

fadeIn(el);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>function fadeIn(el) {
  el.style.opacity = 0;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;
    last = +new Date();

    if (+el.style.opacity &lt; 1) {
      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16);
    }
  };

  tick();
}

fadeIn(el);
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>el.classList.add('show');
el.classList.remove('hide');
</code></pre>
              <pre><code>.show {
  transition: opacity 400ms;
}
.hide {
  opacity: 0;
}
</code></pre>
            </div>
          </div>
          <div id="hide" class="comparison">
            <h3><a href="#hide">Hide</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).hide();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.style.display = 'none';
</code></pre>
            </div>
          </div>
          <div id="show" class="comparison">
            <h3><a href="#show">Show</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).show();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.style.display = '';
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section id="elements" class="odd">
        <div class="inner">
          <h2>Elements</h2>
          <div class="alternatives-block">
            <h4>Alternatives:</h4>
            <ul class="alternatives">
              <li><a href=" https://github.com/ded/bonzo" target="_blank">bonzo</a></li>
              <li><a href=" https://github.com/julienw/dollardom" target="_blank">$dom</a></li>
            </ul>
          </div>
          <div id="add_class" class="comparison">
            <h3><a href="#add_class">Add Class</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).addClass(className);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>if (el.classList)
  el.classList.add(className);
else
  el.className += ' ' + className;
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>el.classList.add(className);
</code></pre>
            </div>
          </div>
          <div id="after" class="comparison">
            <h3><a href="#after">After</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).after(htmlString);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.insertAdjacentHTML('afterend', htmlString);
</code></pre>
            </div>
          </div>
          <div id="append" class="comparison">
            <h3><a href="#append">Append</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(parent).append(el);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>parent.appendChild(el);
</code></pre>
            </div>
          </div>
          <div id="before" class="comparison">
            <h3><a href="#before">Before</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).before(htmlString);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.insertAdjacentHTML('beforebegin', htmlString);
</code></pre>
            </div>
          </div>
          <div id="children" class="comparison">
            <h3><a href="#children">Children</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).children();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var children = [];
for (var i = el.children.length; i--;) {
  // Skip comment nodes on IE8
  if (el.children[i].nodeType != 8)
    children.unshift(el.children[i]);
}
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.children
</code></pre>
            </div>
          </div>
          <div id="clone" class="comparison">
            <h3><a href="#clone">Clone</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).clone();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.cloneNode(true);
</code></pre>
            </div>
          </div>
          <div id="contains" class="comparison">
            <h3><a href="#contains">Contains</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.contains(el, child);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el !== child &amp;&amp; el.contains(child);
</code></pre>
            </div>
          </div>
          <div id="contains_selector" class="comparison">
            <h3><a href="#contains_selector">Contains Selector</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).find(selector).length;
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.querySelector(selector) !== null
</code></pre>
            </div>
          </div>
          <div id="each" class="comparison">
            <h3><a href="#each">Each</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(selector).each(function(i, el){

});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function forEachElement(selector, fn) {
  var elements = document.querySelectorAll(selector);
  for (var i = 0; i &lt; elements.length; i++)
    fn(elements[i], i);
}

forEachElement(selector, function(el, i){

});
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>var elements = document.querySelectorAll(selector);
Array.prototype.forEach.call(elements, function(el, i){

});
</code></pre>
            </div>
          </div>
          <div id="empty" class="comparison">
            <h3><a href="#empty">Empty</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).empty();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>while(el.firstChild)
  el.removeChild(el.firstChild);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.innerHTML = '';
</code></pre>
            </div>
          </div>
          <div id="filter" class="comparison">
            <h3><a href="#filter">Filter</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(selector).filter(filterFn);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function filter(selector, filterFn) {
  var elements = document.querySelectorAll(selector);
  var out = [];
  for (var i = elements.length; i--;) {
    if (filterFn(elements[i]))
      out.unshift(elements[i]);
  }
  return out;
}

filter(selector, filterFn);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>Array.prototype.filter.call(document.querySelectorAll(selector), filterFn);
</code></pre>
            </div>
          </div>
          <div id="find_children" class="comparison">
            <h3><a href="#find_children">Find Children</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).find(selector);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.querySelectorAll(selector);
</code></pre>
            </div>
          </div>
          <div id="find_elements" class="comparison">
            <h3><a href="#find_elements">Find Elements</a></h3>
            <div class="alternatives-block">
              <h4>Alternatives:</h4>
              <ul class="alternatives">
                <li><a href=" https://github.com/ded/qwery" target="_blank">qwery</a></li>
                <li><a href=" http://sizzlejs.com/" target="_blank">sizzle</a></li>
              </ul>
            </div>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$('.my #awesome selector');
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>document.querySelectorAll('.my #awesome selector');
</code></pre>
            </div>
          </div>
          <div id="get_attributes" class="comparison">
            <h3><a href="#get_attributes">Get Attributes</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).attr('tabindex');
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.getAttribute('tabindex');
</code></pre>
            </div>
          </div>
          <div id="get_html" class="comparison">
            <h3><a href="#get_html">Get Html</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).html();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.innerHTML
</code></pre>
            </div>
          </div>
          <div id="get_outer_html" class="comparison">
            <h3><a href="#get_outer_html">Get Outer Html</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$('<div>').append($(el).clone()).html();
</div></code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.outerHTML
</code></pre>
            </div>
          </div>
          <div id="get_style" class="comparison">
            <h3><a href="#get_style">Get Style</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).css(ruleName);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>// Varies based on the properties being retrieved, some can be retrieved from el.currentStyle
// https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/getComputedStyle.js
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>getComputedStyle(el)[ruleName];
</code></pre>
            </div>
          </div>
          <div id="get_text" class="comparison">
            <h3><a href="#get_text">Get Text</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).text();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>el.textContent || el.innerText
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.textContent
</code></pre>
            </div>
          </div>
          <div id="has_class" class="comparison">
            <h3><a href="#has_class">Has Class</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).hasClass(className);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>if (el.classList)
  el.classList.contains(className);
else
  new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>el.classList.contains(className);
</code></pre>
            </div>
          </div>
          <div id="matches" class="comparison">
            <h3><a href="#matches">Matches</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).is($(otherEl));
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el === otherEl
</code></pre>
            </div>
          </div>
          <div id="matches_selector" class="comparison">
            <h3><a href="#matches_selector">Matches Selector</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).is('.my-class');
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var matches = function(el, selector) {
  var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);

  if (_matches) {
    return _matches.call(el, selector);
  } else {
    var nodes = el.parentNode.querySelectorAll(selector);
    for (var i = nodes.length; i--;) {
      if (nodes[i] === el)
        return true;
    }
    return false;
  }
};

matches(el, '.my-class');
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>var matches = function(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
};

matches(el, '.my-class');
</code></pre>
            </div>
          </div>
          <div id="next" class="comparison">
            <h3><a href="#next">Next</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).next();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>// nextSibling can include text nodes
function nextElementSibling(el) {
  do { el = el.nextSibling; } while ( el &amp;&amp; el.nodeType !== 1 );
  return el;
}

el.nextElementSibling || nextElementSibling(el);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.nextElementSibling
</code></pre>
            </div>
          </div>
          <div id="offset" class="comparison">
            <h3><a href="#offset">Offset</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).offset();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>var rect = el.getBoundingClientRect();

{
  top: rect.top + document.body.scrollTop,
  left: rect.left + document.body.scrollLeft
}
</code></pre>
            </div>
          </div>
          <div id="offset_parent" class="comparison">
            <h3><a href="#offset_parent">Offset Parent</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).offsetParent();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.offsetParent || el
</code></pre>
            </div>
          </div>
          <div id="outer_height" class="comparison">
            <h3><a href="#outer_height">Outer Height</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).outerHeight();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.offsetHeight
</code></pre>
            </div>
          </div>
          <div id="outer_height_with_margin" class="comparison">
            <h3><a href="#outer_height_with_margin">Outer Height With Margin</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).outerHeight(true);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function outerHeight(el) {
  var height = el.offsetHeight;
  var style = el.currentStyle || getComputedStyle(el);

  height += parseInt(style.marginTop) + parseInt(style.marginBottom);
  return height;
}

outerHeight(el);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>function outerHeight(el) {
  var height = el.offsetHeight;
  var style = getComputedStyle(el);

  height += parseInt(style.marginTop) + parseInt(style.marginBottom);
  return height;
}

outerHeight(el);
</code></pre>
            </div>
          </div>
          <div id="outer_width" class="comparison">
            <h3><a href="#outer_width">Outer Width</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).outerWidth();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.offsetWidth
</code></pre>
            </div>
          </div>
          <div id="outer_width_with_margin" class="comparison">
            <h3><a href="#outer_width_with_margin">Outer Width With Margin</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).outerWidth(true);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function outerWidth(el) {
  var width = el.offsetWidth;
  var style = el.currentStyle || getComputedStyle(el);

  width += parseInt(style.marginLeft) + parseInt(style.marginRight);
  return width;
}

outerWidth(el);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>function outerWidth(el) {
  var width = el.offsetWidth;
  var style = getComputedStyle(el);

  width += parseInt(style.marginLeft) + parseInt(style.marginRight);
  return width;
}

outerWidth(el);
</code></pre>
            </div>
          </div>
          <div id="parent" class="comparison">
            <h3><a href="#parent">Parent</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).parent();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.parentNode
</code></pre>
            </div>
          </div>
          <div id="position" class="comparison">
            <h3><a href="#position">Position</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).position();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>{left: el.offsetLeft, top: el.offsetTop}
</code></pre>
            </div>
          </div>
          <div id="position_relative_to_viewport" class="comparison">
            <h3><a href="#position_relative_to_viewport">Position Relative To Viewport</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>var offset = el.offset();

{
  top: offset.top - document.body.scrollTop,
  left: offset.left - document.body.scrollLeft
}
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.getBoundingClientRect()
</code></pre>
            </div>
          </div>
          <div id="prepend" class="comparison">
            <h3><a href="#prepend">Prepend</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(parent).prepend(el);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>parent.insertBefore(el, parent.firstChild);
</code></pre>
            </div>
          </div>
          <div id="prev" class="comparison">
            <h3><a href="#prev">Prev</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).prev();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>// prevSibling can include text nodes
function previousElementSibling(el) {
  do { el = el.previousSibling; } while ( el &amp;&amp; el.nodeType !== 1 );
  return el;
}

el.previousElementSibling || previousElementSibling(el);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.previousElementSibling
</code></pre>
            </div>
          </div>
          <div id="remove" class="comparison">
            <h3><a href="#remove">Remove</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).remove();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.parentNode.removeChild(el);
</code></pre>
            </div>
          </div>
          <div id="remove_class" class="comparison">
            <h3><a href="#remove_class">Remove Class</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).removeClass(className);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>if (el.classList)
  el.classList.remove(className);
else
  el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>el.classList.remove(className);
</code></pre>
            </div>
          </div>
          <div id="replace_from_html" class="comparison">
            <h3><a href="#replace_from_html">Replace From Html</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).replaceWith(string);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.outerHTML = string;
</code></pre>
            </div>
          </div>
          <div id="set_attributes" class="comparison">
            <h3><a href="#set_attributes">Set Attributes</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).attr('tabindex', 3);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.setAttribute('tabindex', 3);
</code></pre>
            </div>
          </div>
          <div id="set_html" class="comparison">
            <h3><a href="#set_html">Set Html</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).html(string);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>el.innerHTML = string;
</code></pre>
            </div>
          </div>
          <div id="set_style" class="comparison">
            <h3><a href="#set_style">Set Style</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).css('border-width', '20px');
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>// Use a class if possible
el.style.borderWidth = '20px';
</code></pre>
            </div>
          </div>
          <div id="set_text" class="comparison">
            <h3><a href="#set_text">Set Text</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).text(string);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>if (el.textContent !== undefined)
  el.textContent = string;
else
  el.innerText = string;
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.textContent = string;
</code></pre>
            </div>
          </div>
          <div id="siblings" class="comparison">
            <h3><a href="#siblings">Siblings</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).siblings();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var siblings = Array.prototype.slice.call(el.parentNode.children);

for (var i = siblings.length; i--;) {
  if (siblings[i] === el) {
    siblings.splice(i, 1);
    break;
  }
}
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>Array.prototype.filter.call(el.parentNode.children, function(child){
  return child !== el;
});
</code></pre>
            </div>
          </div>
          <div id="toggle_class" class="comparison">
            <h3><a href="#toggle_class">Toggle Class</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).toggleClass(className);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>if (el.classList) {
  el.classList.toggle(className);
} else {
    var classes = el.className.split(' ');
    var existingIndex = -1;
    for (var i = classes.length; i--;) {
      if (classes[i] === className)
        existingIndex = i;
    }

    if (existingIndex &gt;= 0)
      classes.splice(existingIndex, 1);
    else
      classes.push(className);

  el.className = classes.join(' ');
}
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>if (el.classList) {
  el.classList.toggle(className);
} else {
  var classes = el.className.split(' ');
  var existingIndex = classes.indexOf(className);

  if (existingIndex &gt;= 0)
    classes.splice(existingIndex, 1);
  else
    classes.push(className);

  el.className = classes.join(' ');
}
</code></pre>
            </div>
            <div data-browser="ie10" class="browser ie10" style="display: none;">
              <h4>IE10+</h4>
              <pre><code>el.classList.toggle(className);
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section id="events">
        <div class="inner">
          <h2>Events</h2>
          <div id="off" class="comparison">
            <h3><a href="#off">Off</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).off(eventName, eventHandler);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function removeEventListener(el, eventName, handler) {
  if (el.removeEventListener)
    el.removeEventListener(eventName, handler);
  else
    el.detachEvent('on' + eventName, handler);
}

removeEventListener(el, eventName, handler);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.removeEventListener(eventName, eventHandler);
</code></pre>
            </div>
          </div>
          <div id="on" class="comparison">
            <h3><a href="#on">On</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).on(eventName, eventHandler);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function addEventListener(el, eventName, handler) {
  if (el.addEventListener) {
    el.addEventListener(eventName, handler);
  } else {
    el.attachEvent('on' + eventName, function(){
      handler.call(el);
    });
  }
}

addEventListener(el, eventName, handler);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>el.addEventListener(eventName, eventHandler);
</code></pre>
            </div>
          </div>
          <div id="ready" class="comparison">
            <h3><a href="#ready">Ready</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(document).ready(function(){

});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function ready(fn) {
  if (document.readyState != 'loading'){
    fn();
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', fn);
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState != 'loading')
        fn();
    });
  }
}
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>function ready(fn) {
  if (document.readyState != 'loading'){
    fn();
  } else {
    document.addEventListener('DOMContentLoaded', fn);
  }
}
</code></pre>
            </div>
          </div>
          <div id="trigger_custom" class="comparison">
            <h3><a href="#trigger_custom">Trigger Custom</a></h3>
            <div class="alternatives-block">
              <h4>Alternatives:</h4>
              <ul class="alternatives">
                <li><a href=" https://github.com/Wolfy87/EventEmitter" target="_blank">EventEmitter</a></li>
                <li><a href=" https://github.com/arextar/Vine" target="_blank">Vine</a></li>
                <li><a href=" https://github.com/jeromeetienne/microevent.js" target="_blank">microevent</a></li>
              </ul>
            </div>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).trigger('my-event', {some: 'data'});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>// Custom events are not natively supported, so you have to hijack a random
// event.
//
// Just use jQuery.
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>if (window.CustomEvent) {
  var event = new CustomEvent('my-event', {detail: {some: 'data'}});
} else {
  var event = document.createEvent('CustomEvent');
  event.initCustomEvent('my-event', true, true, {some: 'data'});
}

el.dispatchEvent(event);
</code></pre>
            </div>
          </div>
          <div id="trigger_native" class="comparison">
            <h3><a href="#trigger_native">Trigger Native</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$(el).trigger('change');
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>if (document.createEvent) {
  var event = document.createEvent('HTMLEvents');
  event.initEvent('change', true, false);
  el.dispatchEvent(event);
} else {
  el.fireEvent('onchange');
}
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent
var event = document.createEvent('HTMLEvents');
event.initEvent('change', true, false);
el.dispatchEvent(event);
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section id="utils" class="odd">
        <div class="inner">
          <h2>Utils</h2>
          <div id="bind" class="comparison">
            <h3><a href="#bind">Bind</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.proxy(fn, context);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>fn.apply(context, arguments);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>fn.bind(context);
</code></pre>
            </div>
          </div>
          <div id="array_each" class="comparison">
            <h3><a href="#array_each">Array Each</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.each(array, function(i, item){

});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function forEach(array, fn) {
  for (var i = 0; i &lt; array.length; i++)
    fn(array[i], i);
}

forEach(array, function(item, i){

});
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>array.forEach(function(item, i){

});
</code></pre>
            </div>
          </div>
          <div id="deep_extend" class="comparison">
            <h3><a href="#deep_extend">Deep Extend</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.extend(true, {}, objA, objB);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>var deepExtend = function(out) {
  out = out || {};

  for (var i = 1; i &lt; arguments.length; i++) {
    var obj = arguments[i];

    if (!obj)
      continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (typeof obj[key] === 'object')
          out[key] = deepExtend(out[key], obj[key]);
        else
          out[key] = obj[key];
      }
    }
  }

  return out;
};

deepExtend({}, objA, objB);
</code></pre>
            </div>
          </div>
          <div id="extend" class="comparison">
            <h3><a href="#extend">Extend</a></h3>
            <div class="alternatives-block">
              <h4>Alternatives:</h4>
              <ul class="alternatives">
                <li><a href=" http://lodash.com/docs#assign" target="_blank">lo-dash</a></li>
                <li><a href=" http://underscorejs.org/#extend" target="_blank">underscore</a></li>
                <li><a href=" http://www.2ality.com/2014/01/object-assign.html" target="_blank">ECMA6</a></li>
              </ul>
            </div>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.extend({}, objA, objB);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>var extend = function(out) {
  out = out || {};

  for (var i = 1; i &lt; arguments.length; i++) {
    if (!arguments[i])
      continue;

    for (var key in arguments[i]) {
      if (arguments[i].hasOwnProperty(key))
        out[key] = arguments[i][key];
    }
  }

  return out;
};

extend({}, objA, objB);
</code></pre>
            </div>
          </div>
          <div id="index_of" class="comparison">
            <h3><a href="#index_of">Index Of</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.inArray(item, array);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function indexOf(array, item) {
  for (var i = 0; i &lt; array.length; i++) {
    if (array[i] === item)
      return i;
  }
  return -1;
}

indexOf(array, item);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>array.indexOf(item);
</code></pre>
            </div>
          </div>
          <div id="is_array" class="comparison">
            <h3><a href="#is_array">Is Array</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.isArray(arr);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>isArray = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

isArray(arr);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>Array.isArray(arr);
</code></pre>
            </div>
          </div>
          <div id="map" class="comparison">
            <h3><a href="#map">Map</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.map(array, function(value, index){

});
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>function map(arr, fn) {
  var results = [];
  for (var i = 0; i &lt; arr.length; i++)
    results.push(fn(arr[i], i));
  return results;
}

map(array, function(value, index){

});
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>array.map(function(value, index){

});
</code></pre>
            </div>
          </div>
          <div id="now" class="comparison">
            <h3><a href="#now">Now</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.now();
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>new Date().getTime();
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>Date.now();
</code></pre>
            </div>
          </div>
          <div id="parse_html" class="comparison">
            <h3><a href="#parse_html">Parse Html</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.parseHTML(htmlString);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>var parseHTML = function(str) {
  var el = document.createElement('div');
  el.innerHTML = str;
  return el.children;
};

parseHTML(htmlString);
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>var parseHTML = function(str) {
  var tmp = document.implementation.createHTMLDocument();
  tmp.body.innerHTML = str;
  return tmp.body.children;
};

parseHTML(htmlString);
</code></pre>
            </div>
          </div>
          <div id="parse_json" class="comparison">
            <h3><a href="#parse_json">Parse Json</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.parseJSON(string);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>JSON.parse(string);
</code></pre>
            </div>
          </div>
          <div id="trim" class="comparison">
            <h3><a href="#trim">Trim</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.trim(string);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: none;">
              <h4>IE8+</h4>
              <pre><code>string.replace(/^\s+|\s+$/g, '');
</code></pre>
            </div>
            <div data-browser="ie9" class="browser ie9" style="display: block;">
              <h4>IE9+</h4>
              <pre><code>string.trim();
</code></pre>
            </div>
          </div>
          <div id="type" class="comparison">
            <h3><a href="#type">Type</a></h3>
            <div data-browser="jquery" class="browser jquery">
              <h4>jQuery</h4>
              <pre><code>$.type(obj);
</code></pre>
            </div>
            <div data-browser="ie8" class="browser ie8" style="display: block;">
              <h4>IE8+</h4>
              <pre><code>Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
</code></pre>
            </div>
          </div>
        </div>
      </section>
    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t25" name="t25"></a><h1>25 : The JavaScript Bind Function</h1>
					<span class="ref-site">http://blakeembrey.com/articles/2013/12/javascript-bind-function/</span>
					<div class="tutorial__content">
<article class="content article"><p>The JavaScript <code>bind</code> function is a common-place utility when working with many different frameworks and libraries. It's purpose is to bind the <code>this</code> value to a static object and is useful when passing functions around as callbacks, where maintaining the correct <code>this</code> value is required. A common convention to circumvent this utility is the <code>var that = this</code>, but this isn't very feasible everywhere.</p>
<p>In <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">modern JavaScript implementations</a> the function is built directly onto <code>Function.prototype</code>, giving us <code>bind</code> functionality on every function. For our implementation we'll be implementing a standalone functionality that works similar to the built-in <code>bind</code> function.</p>
<p>However, it's important to note that <code>bind</code> also comes with another handy feature. It accepts an unlimited number of arguments after the context to pass in as the function parameters, from left to right.</p>
<pre><code>var __slice = Array.prototype.slice;

/**
 * Bind a function to a certain context.
 *
 * @param  {Function} fn
 * @param  {Object}   context
 * @param  {*}        ...
 * @return {Function}
 */
var bind = function (fn, context /*, ...args */) {
  var args = __slice.call(arguments, 2);
  
  return function () {
    return fn.apply(context, args.concat(__slice.call(arguments)));
  };
};
</code></pre>
<p>Bind allows us to keep the <code>this</code> context when passing the callback to another function. Imagine passing a function that uses <code>this</code> into <code>setTimeout</code> or someone elses library utility, where <code>this</code> could be unpredictable.</p>
<pre><code>var greet = function (greeting) {
  return greeting + ' ' + this.user;
};

greet('Hello'); //=&gt; "Hello undefined"

var boundGreet = bind(greet, { user: 'Bob' });

boundGreet('Hello'); //=&gt; "Hello Bob"
</code></pre>
<p>We also have another useful feature built into <code>bind</code> - partial application. Partial application is essentially the act of pre-filling function arguments. Any future arguments are then appended to the arguments we have already defined.</p>
<pre><code>var greet = function (user, greeting) {
  return greeting + ' ' + user;
};

var greetBlake = bind(greet, null, 'Blake');

greetBlake('Hi'); //=&gt; "Hi Blake"
greetBlake('Hello'); //=&gt; "Hello Blake"
</code></pre>
<h2 id="bonus-implementation-using-variadic">Bonus Implementation using Variadic</h2>
<p>In my last post, I introduced the concept of a <a href="http://blakeembrey.com/articles/javascript-variadic-function/">variadic function</a>. As this article demonstrates, <code>bind</code> is a perfect example of a variadic function, so let's reimplement <code>bind</code> with the variadic function.</p>
<pre><code>var bind = variadic(function (fn, context, args) {
  return variadic(function (called) {
    return fn.apply(context, args.concat(called));
  });
});
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t26" name="t26"></a><h1>26 : Forcing Function Arity in JavaScript</h1>
					<span class="ref-site">http://blakeembrey.com/articles/2014/01/forcing-function-arity-in-javascript/</span>
					<div class="tutorial__content">
<article class="content article"><p>Function arity in something in JavaScript that is usually overlooked. For the most part, that's perfectly understandable, it's just a number. Unfortunately, this number can be integral to many other functions working correctly. But first, what number am I talking about?</p>
<pre><code>var fn = function (a, b) {};

fn.length; //=&gt; 2
</code></pre>
<p>As you can see, the length gives up the exact number of arguments the function is expecting to be passed in. This can be useful for other functions that might want to alter its behaviour based on this digit. For example, I found outlining this issue <a href="http://raganwald.com/2013/03/21/arity-and-partial-function-application.html">with currying</a>. Basically, the <code>curry</code> function implementation relies on using the arity information to know how many times the function needs to be curried.</p>
<p>To force the number of arity in our returned anonymous functions, we need to dynamically generate a function with the specified number of arguments. Why? Because the previous implementations of <a href="http://blakeembrey.com/articles/wrapping-javascript-functions/">wrapping functions</a>, <a href="http://blakeembrey.com/articles/javascript-bind-function/">bind</a>, <a href="http://blakeembrey.com/articles/javascript-variadic-function/">variadic</a> and every other functional utility I have demonstrated don't proxy the number of arguments through the returned function.</p>
<p>This can be a problem in the case where we want to use this function somewhere that expects a function length to work correctly, like when currying. We could fix this at the source, a half a dozen times and any number of times more. Or we could write a little utility that will enfore a number of arguments for us.</p>
<pre><code>var names   = 'abcdefghijklmnopqrstuvwxyz';
var __slice = Array.prototype.slice;

/**
 * Make a function appear as though it accepts a certain number of arguments.
 *
 * @param  {Number}   length
 * @param  {Function} fn
 * @return {Function}
 */
var arity = function (length, fn) {
  return eval(
    '(function (' + __slice.call(names, 0, length).join(',') + ') {\n' +
    'return fn.apply(this, arguments);\n' +
    '})'
  );
};
</code></pre>
<p>The above function allows us to pass in an argument length and a function to proxy. It then returns to us an anonymous function with the correct number of arguments defined (<code>.length</code> works!) and allows us to call the function and return the usual result. It doesn't do anything to the arguments in the interim, it just tells the world how many arguments we are accepting.</p>
<h2 id="the-other-arity-problem">The Other Arity Problem</h2>
<p>So we've touched one of the arity problems, which is a expecting to read the correct arity from a function. The reverse arity problem is when a function is called with incorrect or overloaded arguments. Consider <code>parseInt</code>, which accepts two arguments - a string and the radix.</p>
<pre><code>[1, 2, 3, 4, 5].map(parseInt); //=&gt; [1, NaN, NaN, NaN, NaN]
</code></pre>
<p>Now we're having problems. To fix this we can make a utility function that limits the number of arguments passed through.</p>
<pre><code>var __slice = Array.prototype.slice;

/**
 * Force a function to accept a specific number of arguments.
 *
 * @param  {Number}   length
 * @param  {Function} fn
 * @return {Function}
 */
var nary = function (length, fn) {
  return function () {
    return fn.apply(this, __slice.call(arguments, 0, length));
  };
};
</code></pre>
<p>If you've been reading, you would have just noticed that we introduced the original bug we've been trying to avoid. That is, we're returning a new anonymous function without proxying the number of arguments through. Let's quickly correct that with the function we just wrote.</p>
<pre><code>var __slice = Array.prototype.slice;

/**
 * Force a function to accept a specific number of arguments.
 *
 * @param  {Number}   length
 * @param  {Function} fn
 * @return {Function}
 */
var nary = function (length, fn) {
  // Uses the previous function to proxy the number of arguments.
  return arity(length, function () {
    return fn.apply(this, __slice.call(arguments, 0, length));
  });
};
</code></pre>
<p>Now we can use this to fix our map error from earlier. We also have the added bonus of a correct argument representation.</p>
<pre><code>nary(1, parseInt).length; //=&gt; 1

[1, 2, 3, 4, 5].map(nary(1, parseInt)); //=&gt; [1, 2, 3, 4, 5]
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t27" name="t27"></a><h1>27 : Wrapping JavaScript Functions</h1>
					<span class="ref-site">http://blakeembrey.com/articles/2014/01/wrapping-javascript-functions/</span>
					<div class="tutorial__content">
<article class="content article"><p>In the modern age of web applications and development, it seems we are constantly adding side effects to every part of our applications - everything from analytics to event triggering. Unfortunately in a lot of cases, we tend to cram this functionality into function with the useful stuff. As programmers, this causes numerous issues down the line - especially when it comes to refactoring and code comprehensibility.</p>
<p>A simple way to keep this functionality apart from the core code is create a helpful utility function to manage it for you. And to keep our code readability, we shouldn't allow anything advanced that can break our understanding of the original function. That means we don't want to be able to alter the original function, but we can still trigger any side effects we need to inline with the original function.</p>
<pre><code>var before = function (before, fn) {
  return function () {
    before.apply(this, arguments);
    return fn.apply(this, arguments);
  };
};
</code></pre>
<p>To use the function, we can pass any function in as the first argument and the original function we want to wrap as the second argument. For example, we could do <code>before(logger, add)</code>. Even without seeing the <code>logger</code> or <code>add</code> functions, we can imagine what each do. And because we are passing all the arguments to the side effect function, we can do stuff with the information.</p>
<p>One thing I find myself doing is checking what arguments were passed to a certain function. To do this now, we can <code>before(console.log.bind(console), fn)</code>. Now, let's implement the reverse functionality.</p>
<pre><code>var after = function (fn, after) {
  return function () {
    var result = fn.apply(this, arguments);
    after.call(this, result);
    return result;
  };
};
</code></pre>
<p>This is extremely similar to the first example. The main difference is that the first function passed in is the side effect, but now we have the side effect running after our wrapped function. Adapting the previous example, we can now do <code>after(add, logger)</code> and the logger will execute after the result is computed with the same arguments.</p>
<p>One cool thing we could actually do, is to run argument validation in the <code>before</code> function. Consider this.</p>
<pre><code>var validAdd = before(function () {
  for (var i = 0; i &lt; arguments.length; i++) {
    if (typeof arguments[i] !== 'number') {
      throw new TypeError('Expected a number');
    }
  }
}, add);
</code></pre>
<p>We can also put these two functions together and create a new utility. This one allows us to pass both a function before and after our core functionality. E.g. <code>around(logger, add, logger)</code>.</p>
<pre><code>var around = function (over, fn, under) {
  return before(over, after(fn, under));
};
</code></pre>
<h2 id="allow-unlimited-before-and-after-functions">Allow unlimited before and after functions</h2>
<p>We can also adapt the functions to accept a variable number of arguments as the <code>before</code> and <code>after</code> functions. However, we can't do this to the <code>around</code> utility since we wouldn't know which argument is the core function.</p>
<pre><code>var __slice = Array.prototype.slice;

var before = function (/* ...before, fn */) {
  var fn     = arguments[arguments.length - 1];
  var before = __slice.call(arguments, 0, -1);

  return function () {
    for (var i = 0; i &lt; before.length; i++) {
      before[i].apply(this, arguments);
    }

    return fn.apply(this, arguments);
  };
};

var after = function (fn /*, ...after */) {
  var after = __slice.call(arguments, 1);

  return function () {
    var result = fn.apply(this, arguments);

    for (var i = 0; i &lt; after.length; i++) {
      after[i].call(this, result);
    }

    return result;
  };
};
</code></pre>
<h2 id="advanced-wrapping-utility">Advanced wrapping utility</h2>
<p>So far we've seen some function wrapping utilities that are purely for side effects. They have no capability to alter the main function arguments or change the function result. For something more advanced than trigger side-effects, we might to want to use something a little different.</p>
<pre><code>var __slice = Array.prototype.slice;

var wrap = function (fn, wrap) {
  return function () {
    return wrap.apply(this, [fn].concat(__slice.call(arguments)));
  };
};
</code></pre>
<p>This is actually pretty similar the <code>wrap</code> function used in Prototype.js. It allows us to call a custom wrapper function with the original function and all the arguments. But, how do we even use this?</p>
<pre><code>var addAndMultiplyBy2 = wrap(add, function (originalFn, a, b) {
  return 2 * originalFn(a, b);
});
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t28" name="t28"></a><h1>28 : Part 1 - Javascript : Basic Scope</h1>
					<span class="ref-site">http://www.datchley.name/basic-scope/</span>
					<div class="tutorial__content">
<section class="post-content">
    <p><em>Part 1 of a <a href="/tag/fundamentals">fundamentals series</a> covering Javascript basics that I routinely come across in mentoring junior developers.</em></p>

<p>It's common for Javascript developers at all levels to deal with scope and its associated implications.  In this post we'll cover the basics of Javascript scope and some of the issues commonly encountered.</p>

<h2 id="lexicalscope">Lexical Scope</h2>

<p>Scope, in general, refers to how the browser's javascript engine looks up identifier names at run time to in order to set how they will be looked up during execution.  That definition implies that there is a <em>lexing</em> phase of the engine which is done prior to executing.</p>

<p>Javascript has two lexical scopes: <em>global</em> and <em>function</em> level. With ES6 there is also <em>block</em> level scoping; but more on that later. These lexical scopes are also nested. For instance:</p>

<p><a href="http://www.datchley.name/content/images/2015/08/js-es5-scope-2.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/08/js-es5-scope-2.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>Here we have three separate lexical scopes. The default global scope which contains declarations for <code>a</code> and <code>foo</code>, the lexical scope declared within the <code>foo()</code> function which contains <code>x</code>, <code>b</code> and <code>bar</code>, and the lexical scope declared within <code>bar()</code> which contains <code>y</code> and <code>c</code>.  </p>

<p>Notice that outside of a function, the default scope of declared variables is the global scope (<em><code>window</code> in the browser</em>). Also, that scopes can be nested.  Nested scopes have access to the scope's they are declared in, which has two important implications:</p>

<ul>
<li>nested scopes can access variables declared in their parent scopes (<em>there is a scope lookup chain</em>)</li>
<li>nested scopes can <em>shadow</em> variables declared in their parent scope.</li>
</ul>

<h3 id="closures">Closures</h3>

<p>The first point allows <em>closures</em>, meaning we can define a function which will retain access to it's enclosing scope, even outside of that enclosing scope.  </p>

<pre><code>var times = function(n) {  
    return function(x) {
        return x * n;
    };
}
var times2 = times(2);  
console.log(times2(4));  
// =&gt; 8
</code></pre>

<p>Here, the function returned by times allows us to create functions that multiply their argument by a given value, <code>n</code>. The function returned retains a reference to <code>n</code>, even though the lexical scope of that function is not accessible outside of the actual function. <code>n</code>, in effect, becomes a <em>free</em> variable that is only accessible to the function defined and returned within the scope in which <code>n</code> was declared.</p>

<h3 id="shadowing">Shadowing</h3>

<p>Scope lookup during the lexical phase also stops once it finds the first match. This means you can <em>shadow</em> a variable further up the scope chain.</p>

<pre><code>var a = 4;  
function foo(x) {  
   var a = x;  // shadows parent 'a' declaration
   console.log(a);
}
console.log(foo(6));   // =&gt; 6  
console.log(a);        // =&gt; 4  
</code></pre>

<p>Here, the locally declared <code>a</code> <em>shadows</em> the <code>a</code> declared in the parent, global scope.  Without the <code>var</code> keyword, we would have been reassigning to the variable <code>a</code> in the parent scope.</p>

<pre><code>var a = 4;  
function foo(x) {  
   a = x;    // woops!
   console.log(a);
}
console.log(foo(6));   // =&gt; 6  
console.log(a);        // =&gt; 6  
</code></pre>

<h3 id="hoisting">Hoisting</h3>

<p>Hoisting also plays a factor with Javascript's scoping. In Javascript, <code>var</code> and <code>function(){}</code> declarations are hoisted to the top of the current scope; and hence, those identifiers are available to any code in that scope.</p>

<pre><code>(function(){
   console.log(inc(4));  // 5
   console.log("a =",a); // a = undefined?

   var a = 1;
   function inc(n){ return ++n; }
})();
</code></pre>

<p>Uh, oh. So we can clearly access <code>inc()</code> which was hoisted and it looks like we can use <code>a</code> without a Reference Error; but, <code>a</code> is undefined? </p>

<p>Javascript only hoists the declaration and not the initialized value.  The value will still end up being assigned at the same spot you have the original declaration. The above code actually gets modified and works as follows:</p>

<pre><code>(function(){
    var a;
    function inc(n){ return ++n; }

    console.log(inc(4));   // 5
    console.log("a = ", a); // a = undefined

    a = 4; // Ah-ha!
})();
</code></pre>

<p>This is the same for variables assigned function expressions as well. Because function expressions are just values in an assignment statement.</p>

<pre><code>(function(){
   console.log(inc(4)); // 5
   console.log(dec(4)); // ReferenceError: dec undefined

   var dec = function(n) { return --n; }
   function inc(n){ return ++n; }
})();
</code></pre>

<h3 id="es6scopingadditions">ES6 Scoping Additions</h3>

<p>With the new ES6 specification, lexical scope has been altered in a handful of ways, primarily with the new <code>let</code> and <code>const</code> declarations and with the shorter <code>=&gt;</code> function syntax.</p>

<p>In ES5, as discussed above, if you wanted to declare a lexically scoped block of code, you could do so by creating a closure, typically with an <em>immediately invoked function expression</em> or <em>IIFE</em>.  ES5 was essentially lexically scoped to <em>functions</em>.</p>

<pre><code>var greet = (function() {  
   var greeting = "Hello!";
   return function(name) { 
      console.log(greeting + ", " + name + "!");
   };
})();
greet("Cap'n Tight Pants");  
// =&gt; "Hello, Cap'n Tight Pants!"
</code></pre>

<h4 id="let"><code>let</code></h4>

<p>With ES6's <code>let</code> declaration we can now have lexically scope <em>blocks</em> of code, without using functions or IIFEs.</p>

<pre><code>var a = 1, b = 2, c = 3;  
{
  let a = 4, b = 5, c = 6;
  console.log("a,b,c = ", a, b, c);
}
console.log("a,b,c = ", a, b , c);  
// =&gt; a,b,c = 4 5 6
// =&gt; a,b,c = 1 2 3
</code></pre>

<p>Something you might encounter with <code>let</code> declarations also, is that according to the ES6 spec, <code>let</code> declarations don't <em>hoist</em> like <code>var</code> and <code>function</code> declarations.</p>

<p>With <code>let</code> declarations, you'll get a reference error if you try to access a <code>let</code> declared variable <em>before</em> its declaration in the code (<em>according to the ES6 spec</em>).  </p>

<pre><code>console.log("a = ", a);  
console.log("b = ", b);  
var a = 4;  
let b = 6;  
// =&gt; a = undefined
// =&gt; b = ReferenceError!
</code></pre>

<p>However, if you are using Traceur or Babel(6to5), this will not be the case, as transpiling this dead zone behavior would require much more work and nearly reimplementing the Javascript run-time to handle those cases.</p>

<h4 id="const"><code>const</code></h4>

<p><code>const</code> is the other new, block scope declaration type, which, as you would suspect creates <em>constant</em> variables.</p>

<pre><code>const a = 4;  
console.log("a = ", a);  
a = 3;    // TypeError! a is readonly  
</code></pre>

<p>A <code>const</code> declared variable must be initialized with a value when it is declared.  Declaring <code>const a;</code> and trying to assign a value to it later on will throw an error.  Also, <code>const</code> works by limiting the assignment to a variable, not by freezing a variable's value. So, if you assign a reference type to it, you can still modify the underlying properties of that reference type:  </p>

<pre><code>const a = { name: 'Mal', ship: 'Serenity' };  
a = 4;   // TypeError  
a.name = 'Wash'  // no problem!

const b = [1,2,3];  
b.unshift(0);  // b = [0,1,2,3]  
</code></pre>

<p><code>const</code> declared reference variables hold a constant reference to that variable, not a constant value - so the underlying reference assigned to a const can change.</p>

<h3 id="lexicalthis">Lexical <code>this</code></h3>

<p>We've already encountered the idea that Javascript <code>var</code> and <code>function</code> declarations are lexically scoped to the enclosing function or scope they are contained in.  But, what about the <code>this</code> keyword inside of functions? What does it reference?</p>

<p>Most familiar is the use of <code>this</code> in functions used as constructors with the <code>new</code> keyword.  When using <code>new</code>, <code>this</code> refers to the eventual object that will be returned from the function.</p>

<pre><code>function Tribble(color) {  
  this.color = color;
}
var my_tribble = new Tribble("brown");  
my_tribble.color;  // "brown"  
</code></pre>

<p>When calling an method on an object, <code>this</code> refers to the object that is the <em>context</em> that that function is being called with; in most cases, this is the object prototype or instance the function is assigned to.</p>

<pre><code>var tardis = {  
  where: "Gallifrey",
  go: function() { 
    console.log("Off to " + this.where + ", Allons-y!"); 
  }
};
tardis.go();  // "Off to Gallifrey, Allons-y!"  
</code></pre>

<p>When calling <code>tardis.go()</code>, the <code>this</code> references the current context of that function, which is the <code>tardis</code> object.  But, even without a context object, <code>this</code> still refers to the functions context, which turns out to be <code>window</code> for browsers.</p>

<pre><code>var where = "Gallifrey";  
function go() {  
  console.log("Off to " + this.where + ", Allons-y!"); 
}
go();  // "Off to Gallifrey, Allons-y!"  
</code></pre>

<p><code>this</code>, it seems, is fairly flexible and potentially dubious in Javascript depending on what you're trying to do.</p>

<h4 id="es6functions">ES6 <code>=&gt;</code> functions</h4>

<p>ES6 specifies a short-hand syntax for declarations for functions using the <em>fat arrow</em> (<code>=&gt;</code>) syntax.  However, <code>=&gt;</code> functions bind <code>this</code> to their enclosing scope, unlike regular functions which create a new scope entirely.</p>

<pre><code>var even = (x) =&gt; x % 2 == 0;  
console.log(even(2));  // true  
console.log(even(3));  // false

var a = 4,  
    list = [1,2,3].map((n) =&gt; n + a);
// list = [5,6,7]
</code></pre>

<p>The left side of the <code>=&gt;</code> declares the function's arguments and the right side declares the return value, or a block of code as the function body.</p>

<pre><code>let evens = [1,2,3,4,5,6].filter((n) =&gt; {  
  if (even(n)) {
    return n;
  }
});
console.log(evens);  // [2,4,6]  
</code></pre>

<p>There is much more to Javascript scoping than this (<em>ha, get it?</em>); and I would suggest you take a look at Kyle Simpson's <a href="http://www.amazon.com/You-Dont-Know-JS-Closures/dp/1449335586">You Don't Know JS: Scope &amp; Closures</a> and the <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-declarations-and-the-variable-statement">ES6 spec</a> related to scoping of <code>let</code> and <code>const</code> as well for a more detailed coverage and understanding.</p>

<p>If you are using <a href="https://babeljs.io/">Babel</a> or <a href="https://github.com/google/traceur-compiler">Traceur</a>, be sure and reference their documentation for any missing parts or inconsistencies from the ES6 specification as well, which will make it easier when you transition for transpilers to native ES6 in the browser.</p>

<hr>

<p><em>In <a href="http://www.datchley.name/functions/">Part 2</a> in the 'fundamentals' series I'll cover some of the basics of Javascript functions, notably <code>call</code>, <code>apply</code>, <code>bind</code> and more on the ES6 <code>=&gt;</code> functions.</em></p>
        <ul class="tags">
            <li class="tag" id="tag-id-2"><a href="/tag/fundamentals/">fundamentals</a></li> 
            <li class="tag" id="tag-id-3"><a href="/tag/scope/">scope</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				

				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t29" name="t29"></a><h1>29 : Part 2 - Functions</h1>
					<span class="ref-site">http://www.datchley.name/functions/</span>
					<div class="tutorial__content">
<section class="post-content">
    <p><em>Part 2 of a series on Javascript Fundamentals. See <a href="http://www.datchley.name/basic-scope/">Part 1</a> on Scope in Javascript.</em></p>

<h3 id="declarationexpressioninvoking">Declaration, Expression, Invoking</h3>

<p>I don't want to belabor the basics of function declaration and definition in Javascript; but there are primarily two different ways you'll see functions in Javascript:</p>

<ul>
<li>function declarations</li>
<li>function expressions (named &amp; anonymous)</li>
</ul>

<p>Functions can be declared using the <code>function</code> keyword and a name, as in  </p>

<pre><code>function compare(a,b) {  
  return a == b ? 0 : (a &lt; b) ? -1 : 1;
}
</code></pre>

<p>This declares a function called <code>compare</code>, which is <em>hoisted</em> to the top of its enclosing scope and available to any code in that scope or its child scopes.</p>

<p>Functions can also be treated as values, meaning you can assign them to variables and pass and return them to and from functions as well. These are referred to as <em>first-class functions</em> and lead to <em>higher-order functions</em> when working in a more declarative, functional style of programming.</p>

<pre><code>// function expression
var even = function(n){ return n % 2 == 0; };  

// returning a function
var log = function(base) {  // returning a function  
  return function(n) {
    return Math.log(n) / Math.log(base);
  }
};
var log10 = log(10);  
log10(100);   // 2  
</code></pre>

<p>For a discussion of function <code>scope</code> in relation to <em>IIFE</em>s and lexical <code>this</code>, refer to <a href="http://www.datchley.name/basic-scope/">Part 1</a> of this series on Scope.</p>

<h3 id="functionargumentsarity">Function Arguments &amp; Arity</h3>

<p>The arity of a function refers to the number of arguments a function expects. This is determined by the number of declared arguments in the function declaration and is available in the function's <code>.length</code> property.</p>

<pre><code>function foo(a,b) { console.log(a, b); }  
foo.length;   // 2  
</code></pre>

<p>A functions arity is, and can be, necessarily different than the arguments it actually receives when called.  If we invoke a function with fewer arguments than it expects, the argument identifiers in the function for arguments not passed will be set to undefined.</p>

<pre><code>foo(4, 5);  // =&gt; 4, 5  
foo(3);     // =&gt; 3, undefined  
foo();      // =&gt; undefined, undefined  
</code></pre>

<p>Within a function we can access all the arguments passed, both those declared in the function declaration and any extras (<em>you can pass more than the declared arguments to a function</em>) using the available <code>arguments</code> variable.</p>

<pre><code>function args(a,b) {  
   console.log("a,b: ", a, b);
   console.log("all: ", arguments);
}
foo(1,2);        // a,b: 1 2  
                 // all: [1,2]
foo(1,2,3,4);    // a,b: 1 2  
                 // all: [1,2,3,4]
</code></pre>

<p>The <code>arguments</code> object is a local variable available within all functions and it is <em>array-like</em>.  This means it is not an instanceof the <code>Array</code> type and does not have many of it's methods.  <code>arguments</code> can be accessed by index, ie <code>arguments[0]</code>, <code>arguments[1]</code> and it has a <code>.length</code> property.</p>

<p>This feature allows Javascript functions to have variable arguments. To work with the arguments as a real array, you can simply convert the arguments object to an array.</p>

<pre><code>function has() {  
  let args = [].slice.call(arguments);
  args.forEach((arg) =&gt; console.log(arg));
}
has(1,2,3,4);  
// 1
// 2 
// 3
// 4
</code></pre>

<h3 id="invokingfunctions">Invoking functions</h3>

<p>Invoking a function is done using the <code>()</code> operator on the function name or variable holding the function expression.</p>

<pre><code>var foo(){ /* do foo */ }   // declaration  
foo();   // invoke

(function baz() {           // IIFE
   console.log("baz!");
})();
// "baz!"

var bar = function(){ /* do bar */ };  // expression  
bar();   // invoke  
</code></pre>

<p>We can also assign a function to a property on an object and invoke it through the standard object property access method as well.</p>

<pre><code>let princess = {  
   name: 'Leia Organa',
   say: function(msg) { console.log(this.name + ": " + msg); }
};
princess.say("I love you!");  
// =&gt; Leia Organa: I love you!
</code></pre>

<p>In this case, when invoking a function via an object's property it's assigned to, the context of <code>this</code> in that function is the object itself.</p>

<p>However, using Javascript's <code>.call()</code> and <code>.apply()</code>, we can change that context when invoking the function.</p>

<pre><code>let name = 'Han Solo';  
princess.say.call(this, "I know.");  
// =&gt; Han Solo: I know.
</code></pre>

<p>What just happened there?  Why would Han totally underplay that kind of declaration <em>and</em> how'd he steal her line?  The <code>.call()</code> method's first argument is an object to use as the invoking context of the function being called.  This allows us to override <code>princess.name</code> and use the global <code>name</code> variable by passing in <code>this</code>, which refers to the <code>window</code> object.</p>

<p><code>.call()</code> also lets us pass in as many arguments for that function using the remaining parameters, which is how Han came across as so smug.</p>

<p>The only difference between <code>.call()</code> and <code>.apply()</code> is that <code>.apply()</code> only takes 2 parameters: a context object just like call, and an array of arguments (<em>instead of passing them as individual parameters</em>). Even though <code>.apply()</code> takes the arguments as an array, they are still passed normally to the function being invoked.</p>

<pre><code>function add(a,b) { console.log(a + b); }  
add.apply(null, [2,3]);  
// 5
</code></pre>

<p>Why did we just pass <code>null</code> as the context object and what exactly did that do? According the the ECMAScript standard, passing in <code>null</code> or <code>undefined</code> will make the function's lexically scoped <code>this</code> point to the global scope.</p>

<p>In most cases with single functions, the lexical context of <code>this</code> is probably not a concern, as you probably aren't referencing <code>this</code> within the function.  However, when dealing with functions assigned to object properties and invoked through them, understanding how the first argument of <code>.call()</code> and <code>.apply()</code> affect the function's <code>this</code> is important.</p>

<p>Why would we use <code>.apply()</code> and not just use <code>.call()</code> everywhere?  Let's say you had a function called <code>after()</code> that would wrap an existing function and ensure some code was executed every time after that function was called. Using <code>.call()</code> would be nearly impossible given that you don't know the number of parameters that function might be called with - without resorting to something potentially dangerous like using <code>eval()</code>.</p>

<pre><code>function lots(a,b,c,d) {  
   console.log([a,b,c,d].join(','));
}
function after(fn) {  
  var orig = fn;
  return function() {
    orig.call(null, /* how do you pass them? */);
  };
}
var lots = after(lots);  
lots(1,2,3,4);  
</code></pre>

<p>This is where <code>.apply()</code> and the <code>arguments</code> local variable come to the rescue:</p>

<pre><code>function after(fn) {  
  var orig = fn;
  return function() {
    var args = [].slice.call(arguments);
    return orig.apply(null, args);
  };
}
var lots = after(lots);  
lots(1,2,3,4);  
/// 1,2,3,4
</code></pre>

<h3 id="usingbind">Using <code>.bind()</code></h3>

<p>So we know now that <code>.call()</code> and <code>.apply()</code> can be used to not only invoke the given function; but to also change it's calling context and pass parameters as well.  But, those methods directly invoke the function when used. </p>

<p>Javascript also gives us the <code>.bind()</code> method on functions to allow us to <em>bind</em> both a context and one or more parameters and <em>not</em> invoke the function; but instead return this newly bound function to be called later.</p>

<p>We can use the same example from above, but allow our <code>after</code> function to take a second parameter to specify the calling context the function should be executed with.</p>

<pre><code>var doctor = {  
  name: 'Matt Smith',
  who: function named() {
   console.log(this.name);
  }
};

function after(fn, context) {  
  var orig = context ? fn.bind(context) : fn;
  return function() {
    var args = [].slice.call(arguments);
    return orig.apply(null, args);
  };
}

var tenth = { name: 'David Tennant' };  
var thedoctor = after(doctor.who, tenth);  
doctor.who();  // Matt Smith  
thedoctor();   // David Tennant  
</code></pre>

<p><code>.bind()</code> also allows us to pre-bind one or more argument parameters to the function as well.  For instance:</p>

<pre><code>function add(a,b) { return a + b; }  
var add2 = add.bind(null, 2);  
add2(4);   // 6  
add2(3,6); // 5  
</code></pre>

<p>Here, we create a new function by <em>partially applying</em> the first argument to <code>add()</code>.  Passing any subsequent parameters makes no difference.</p>

<p>Keep in mind that <code>.call()</code>, <code>.apply()</code> and <code>.bind()</code> can not be used with ES6's <code>=&gt;</code> functions to change the context of <code>this</code>, as <code>this</code> is explicitly bound to the enclosing scope where the function is declared.  You can use <code>.apply</code> and <code>.call</code> to pass in argument parameters, but the first argument is ignored for changing context.</p>

<p>For more detailed information, the Mozilla Developer Network (MDN), a good reference for anything Javascript, has excellent coverage on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>.call</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>.apply</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>.bind</code></a>.</p>

<hr>

<p><em>In Part 3 in the 'fundamentals' series I'll cover a number of the ES5/6 array methods and idioms, like <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>from</code>, <code>of</code> and iterating arrays using <code>for..of</code></em></p>
        <ul class="tags">
            <li class="tag" id="tag-id-2"><a href="/tag/fundamentals/">fundamentals</a></li> 
            <li class="tag" id="tag-id-4"><a href="/tag/functions/">functions</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t30" name="t30"></a><h1>30 : Part 3 - .map, .reduce &amp; .filter, Oh My!</h1>
					<span class="ref-site">http://www.datchley.name/working-with-collections/</span>
					<div class="tutorial__content">
<section class="post-content">
    <p><em>Part 3 of a series on Javascript Fundamentals. See the <a href="/tag/fundamentals">full list of posts</a></em></p>

<p>Making use of Javascript's <code>map()</code>, <code>reduce()</code> and <code>filter()</code> Array methods can help you write more declarative, fluent style code. Rather than building up <code>for</code> loops and nesting to process data in lists and collections, you can take advantage of these methods to better organize your logic into building blocks of functions, and then chain them to create more readable and understandable implementations. And ES6 gives us a few more nice array methods as well, like <code>.from</code>, <code>.find</code>, <code>.findIndex</code>, <code>.of</code> and <code>for..of</code> loops!</p>

<h2 id="arraymap"><code>Array.map</code></h2>

<p>There are very common things we want to do to lists. The first one that comes to mind is cycling through the list and performing an operation on each item. You can do this with <code>Array.forEach</code>. </p>

<pre><code>var numbers = [1,2,3,4,5,6,7,8,9,10];  
numbers.forEach((n, index) =&gt; {  
   numbers[index] = n + 1;
});
// =&gt; [2,3,4,5,6,7,8,9,10,11]
</code></pre>

<p>Here, we're looping through the array and adding one to each item. This approach also has the side effect that it mutates the original list of data. As good developers, we want to reduce side effects and be <em>transparent</em> and <em>idempotent</em> with our functions and processing. </p>

<p>So, let's use <code>map()</code> to perform the same operation and leave the original list in tact.  </p>

<pre><code>var plusone = numbers.map((n) =&gt; n+1);  
// =&gt; numbers: [1,2,3,4,5,6,7,8,9,10]
// =&gt; plusone: [2,3,4,5,6,7,8,9,10,11]
</code></pre>

<p>Easy enough. No side-effects and we have a new list with exactly what we wanted.</p>

<p>Now, what if we then want to take just the <em>even</em> numbers from this result in a list?</p>

<h2 id="arrayfilter"><code>Array.filter</code></h2>

<p>We can use <code>Array.filter()</code> to visit each item in a list, much like <code>map()</code>; however, the predicate function you pass to <code>filter()</code> should return either <code>true</code>, to allow that item in the list, or <code>false</code> to skip it. Also like <code>map()</code>, <code>filter()</code> returns a new array with copies of the items that match the filter and does not modify the original.</p>

<pre><code>var evens = plusone.filter((n) =&gt; n % 2 === 0);  
// =&gt; evens: [2,4,6,8,10]
</code></pre>

<p>Even easier! Now that we've got the list we want to work with, lets get a count of the number of how many are evenly divisible by 4.  </p>

<h2 id="arrayreduce"><code>Array.reduce</code></h2>

<p>When we want to aggregate data in a list, or data related to a list, we can use <code>Array.reduce()</code>.  <code>reduce()</code> applies a function to an accumulated value on each element in a list from left to right.</p>

<pre><code>var byfour = evens.reduce((groups, n) =&gt; {  
  let key = n % 4 == 0 ? 'yes' : 'no';
  (groups[key] = groups[key] || []).push(n);
  return groups;
}, {});
// =&gt; byfour: { 'yes': [4,8], 'no': [2,6,10] }
</code></pre>

<p>Unlike <code>map()</code> and <code>filter()</code>, however, <code>reduce()</code> doesn't return a new list, it returns the aggregate value directly.  In the case of our number list, our accumulated value was the initial empty object passed as the last parameter to the <code>reduce()</code> call.  We then used that to create a property based on the divisible-by-four-ness of each number that served as a bucket to put the numbers in.</p>

<h2 id="beingfluentish">Being fluent-ish</h2>

<p>A fluent API or interface is one that provides better readability through:</p>

<ul>
<li>chaining of method calls over some base context</li>
<li>defining operations via the return value of each called method</li>
<li>is self-referential, where the new context is equivalent to the last</li>
<li>terminates via return of a void context</li>
</ul>

<p>JQuery works likes this, as well as lodash and underscore using the <code>_.chain()</code> method wrapper, allowing chaining of method calls on a base context that represents a DOM element tree.</p>

<p>Because <code>map()</code> and <code>filter()</code> return new arrays, we can take advantage of this and chain multiple array operations together.</p>

<pre><code>[1,2,3,4,5,6,7,8,9,10]
  .map((n) =&gt; n*2)
  .filter((n) =&gt; 10 % n == 0)
  .reduce((sum, n) =&gt; (sum += n), 0);
// =&gt; 12
</code></pre>

<p>Now, this isn't a "real" fluent interface; but it does resemble one from a chaining perspective and gives us a more declarative approach to implementing operations on lists.</p>

<h2 id="someneweres6arraymethods">(Some) Newer ES6 Array methods</h2>

<p>ES6 gives us some new Array methods that make some things easier compared to what we previously had to do in ES5, as well as adding some extra functionality.</p>

<h3 id="arrayfrom"><code>Array.from()</code></h3>

<p>The new <code>.from()</code> method is a static method of Array and allows us to create real arrays from "array-like" objects (<em>such as <code>arguments</code> or dom collections</em>); and it also allows us to pass a function to to apply to items in those arrays, giving us some <code>.map()</code>-like behavior as well.</p>

<p>For instance, we can create a real array from a DOM collection, which isn't really an instance of Array but is array like in that it allows indexing and has a length.</p>

<pre><code>var divs = document.querySelectorAll('div.pane');  
var text = Array.from(divs, (d) =&gt; d.textContent);  
console.log("div text:", text);  
</code></pre>

<p>The above snippet takes the DOM collection returned from <code>querySelectorAll()</code> and uses <code>Array.from</code> to map across each item and return us a "real" array of the text content from those DOM elements.  To use it with the <code>arguments</code> variable in functions is just as easy.</p>

<pre><code>// Old, ES5 way to get array from arguments
function() {  
  var args = [].slice.call(arguments);
  //...
}

// Using ES6 Array.from
function() {  
  var args = Array.from(arguments);
  //..
}
</code></pre>

<p>You can also use <code>Array.from</code> for other cool things, like filling in holes in arrays, since <code>Array.from</code>'s map function is passed <code>undefined</code> for any empty indexes in the array-like value being operated on.  </p>

<pre><code>var filled = Array.from([1,,2,,3], (n) =&gt; n || 0);  
console.log("filled:", filled);  
// =&gt; [1,0,2,0,3]
</code></pre>

<h3 id="arrayfindandarrayfindindex"><code>Array.find()</code> and <code>Array.findIndex()</code></h3>

<p>ES5 gave us <code>Array.filter()</code> which we've seen and is fantastic for filtering out the elements in an array. But, to find an element by value in an array in ES5, we'd have had to resort to something like the following.  To loop over an array and use more complex logic to find a value, we'd have to use a <code>for</code> loop.</p>

<pre><code>function find(list, value) {  
    var index = list.indexOf(value);
    return index == -1 ? undefined : list[index];
}
var arr = ['cat','dog','bat','badger','cow'];  
console.log("dog? ", find(arr, 'dog'));  
// dog? dog
console.log("weasle? ", find(arr, 'weasle'));  
// weasle? undefined

var found;  
// Find the first item longer than 3 characters
for (var i=0; i &lt; arr.length; i++) {  
  if (arr[i].length &gt; 3) {
    found = arr[i];
    break;
  }
}
// found: 'badger'
</code></pre>

<p>But, ES6 allows us to do the same thing using <code>Array.find()</code> to get a value, if it exists in an array; and <code>Array.findIndex()</code> to get the index of something by value.  However, instead of taking a value directly as a parameter, <code>find()</code> and <code>findIndex</code> take a predicate function that is applied to each element in the array, and once the predicate returns true, stops the search and returns the value at that position (<em>for <code>.find</code></em>) or the index at that position (<em>for <code>findIndex</code></em>).</p>

<pre><code>// Array.find and Array.findIndex(fn)
var found = [1,4,-5,10].find((n) =&gt; n &lt; 0);  
console.log("found:", found);

var index = [1,4,-5,10].findIndex((n) =&gt; n &lt; 0);  
console.log("index:", index);

// found: -5
// index: 2
</code></pre>

<h3 id="arrayof"><code>Array.of()</code></h3>

<p><code>Array.of()</code> lets us create a new Array instance from a variable number of arguments, regardless of the type of those arguments.</p>

<pre><code>var arr = Array.of(0,true, undefined, null);  
console.log("arr:", arr);  
// arr: [0, true, undefined, null]
</code></pre>

<p>This is essentially the same as the following ES5 function:</p>

<pre><code>function ArrayOf(){  
  return [].slice.call(arguments);
}
</code></pre>

<p><code>Array.of()</code> works more consistently at creating instances of Arrays than using the <code>Array()</code> constructor.  The <code>Array()</code> constructor can run into issues if a single argument is passed and it's a number.</p>

<pre><code>console.log(new Array(3, -5, 10));  
// [3, -5, 10] - an array with the arguments as entries
console.log(new Array(3));  
// [,,]  - an array with three empty holes
console.log(new Array(5.7));  
// RangeError: invalid array length - woops!
</code></pre>

<h3 id="theforofloop">The <code>for..of</code> loop</h3>

<p>The <code>for..of</code> loop creates a loop over any <em>iterable</em> object, including <code>Array</code>, <code>arguments</code>, <code>Set</code>, <code>Map</code> and custom iterable objects like <code>generators</code>. This is different than the <code>for..in</code> operator, as <code>for..in</code> iterates over an Array, you get indexes, not values.  <code>for..in</code> can be used on Objects, but returns the property names, not values. <code>for..of</code> can not be used on <code>Objects</code>, as there is no default iterator defined for <code>Objects</code> in javascript.</p>

<pre><code>var arr = [3,5,7,9],  
    obj = { a: 1, b: 2, c: 3 };

// ES5 for..in over objects
for (var p in obj) {  
  console.log(p);
}
// a  b   c

// ES5 for..in over arrays
for (var n in arr) {  
  console.log(n);
}
// 0 1 2 3

// ES6 for..of over arrays
for (let n of arr) {  
  console.log(n);
}
// 3 5 7 9 
</code></pre>

<p>Using <code>for..of</code>, we can now actually iterate values on Arrays. Though we still can't use it on <code>Object</code>s, we can use a generator and <code>for..of</code> to loop over the keys and values in an object.</p>

<pre><code>// using a generator function
function* entries(obj) {  
   for (let key of Object.keys(obj)) {
     yield [key, obj[key]];
   }
}


for (let [key, value] of entries(obj)) {  
   console.log(key, "-&gt;", value);
}
// a -&gt; 1
// b -&gt; 2
// c -&gt; 3
</code></pre>

<p>Iterable objects and generators are, however, a topic for a different blog post!</p>

<p>If you're looking for more information on some of the ES6 Array methods, be sure and check out <a href="http://www.2ality.com/2014/05/es6-array-methods.html">Axel Rauschmayer's Post</a> and <a href="http://h3manth.com/new/blog/2014/es6-array-methods/">Hemanth HM's post</a>, and be sure and look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN's entry</a> on <code>for..of</code>.</p>

<hr>

<p><em>In Part 4 in the 'fundamentals' series I'll cover some of the basics of <del>iterables and generators</del> (a bit early for this) Objects, prototypes, delegation and composition, including <code>Object.create()</code>.</em></p>
        <ul class="tags">
            <li class="tag" id="tag-id-2"><a href="/tag/fundamentals/">fundamentals</a></li> 
            <li class="tag" id="tag-id-5"><a href="/tag/javascript/">javascript</a></li> 
            <li class="tag" id="tag-id-6"><a href="/tag/collections/">collections</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t31" name="t31"></a><h1>31 : Part 4 - Object-ively Javascript</h1>
					<span class="ref-site">http://www.datchley.name/delegate-object-to-classical-inheritance/</span>
					<div class="tutorial__content">
<section class="post-content">
    <p><em>Part 4 of a series on Javascript Fundamentals. See the <a href="/tag/fundamentals">full list of posts</a></em></p>

<p>The goal of this post is to, at a high level, cover some of the basics of creating, using and implementing objects in Javascript.  In a second part, we'll follow up with understanding Javascript object prototype, the prototype chain and making better use of composition and delegation over inheritance.</p>

<p><em>I'll mention objects being "prototype linked" to other objects in this article quite often. If you're still confused by Javascript's prototype based object delegation scheme, just hold tight for the second part coming soon</em></p>

<h2 id="makingobjects">Making Objects</h2>

<p>The easiest way to create objects in Javascript, and the most efficient, is using object literals.  </p>

<pre><code>var actor = {  
  name: "David Tennant",
  age: 44
};
</code></pre>

<p>Here,<code>actor</code> is an object with two properties, <code>name</code>, which contains a string, and <code>age</code> which contains a number.  This is the same as using <code>var obj = new Object()</code> and then assigning properties. Both objects are prototype linked the standard <code>Object</code> prototype. </p>

<p>We can also create a function to make objects by calling it as a <em>constructor</em> function using the <code>new</code> operator.  </p>

<pre><code>function Person(name, age) {  
   this.name = name;
   this.age = age;
}
var actor = new Person("David Tennant", 44);  
</code></pre>

<p>Using the <code>new</code> operator introduces some implicit operations, which we'll discuss shortly.</p>

<p>We also have <code>Object.create()</code> as well, though it works a bit differently.</p>

<p><code>Object.create()</code> takes two parameters and returns a new object. This object is prototype linked to the first object passed as a parameter.  The second parameter is an optional object containing property descriptors to assign directly on the newly returned object.  </p>

<p>A property descriptor object is an object containing definitions for properties. The property names in this descriptor object are themselves objects which contain various attributes attributed to that property, such as: <code>value</code>, <code>writable</code>, <code>configurable</code>, and <code>enumerable</code>. </p>

<ul>
<li><code>value</code> (<em>any</em>) - is the value assigned to that property</li>
<li><code>writeable</code> (<em>boolean</em>) - if false, means the value of that property can not be changed</li>
<li><code>enumerable</code> (<em>boolean</em>) - if true, means that property will be iterated over when a user does a <code>for..in</code> or similar operation.</li>
<li><code>configurable</code> (<em>boolean</em>) - if false, any attempts to delete the property or change its value will fail. </li>
</ul>

<p>Try the following in Chrome DevTools to see how basic object properties are setup:</p>

<pre><code>var obj = { a: 42 };  
console.log("%o", Object.getOwnPropertyDescriptor(obj, 'a'));  
// Object
//    configurable: true
//    enumerable: true
//    value: 42
//    writable: true
//    ...
</code></pre>

<p>Using <code>Object.create()</code> we can create objects using another object as a prototype (<em>an exemplar</em>); and an optional property descriptor object. Any properties on the exemplar are accessed via the object's prototype chain; and any properties in the descriptor object are <em>own properties</em> assigned directly to the new object returned.</p>

<pre><code>// creates a new, empty object linked to Object.prototype
var obj = Object.create({});  

// create a new, empty object not linked to Object.prototype
obj = Object.create(null);

var person_proto = {  
      name: "", age: null
    },
    descriptor = {
      tardis: { value: "blue box" }
    };

// creates a new object based on person_proto
var actor = Object.create(person_proto, descriptor)  
actor.name = "David Tennant";  
actor.age = 44;  
// actor:
//   name: "David Tennant"
//   age: 44
//   tardis: "blue box"
</code></pre>

<p>In ES6, we could use the following pattern in creating our <code>actor</code> instance instead:</p>

<pre><code>var actor = Object.assign(Object.create(person_proto), {  
  tardis: "blue box"
});
</code></pre>

<p>ES6's <code>Object.assign()</code> is similar to the many <code>extend()</code> style functions that libraries like jQuery and Underscore use to create/extend objects using one or more objects.</p>

<h3 id="understandingwhatnewdoes">Understanding what <code>new</code> does</h3>

<p>There is much magic happening in a function invoked with the <code>new</code> operator.  At its most basic, when using <code>new</code>, the function invocation is hijacked and given a new, empty object as context, which is assigned to the local variable <code>this</code> inside the function.  </p>

<p>The expectation of functions called as constructors is that they do something with that context: assigning properties or otherwise manipulating it; and magically, that same context object is returned from the function.</p>

<p>Using <code>new</code> works similarly to the following function:  </p>

<pre><code>function _new(/* constructor, param, ... */) {  
  var  args = [].slice.call(arguments),
       constructor = args.shift(), 
       context = Object.create(constructor.prototype),
       res;

  res = constructor.apply(context, args);
  return (typeof res === 'object' &amp;&amp; res != null) ? res : context;
}
var actor = _new(Person, "David Tennant", 44);  
</code></pre>

<p>This is very simplified, but it gives you an idea of what's going on. </p>

<p>But as <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">Eric Elliot</a>, <a href="http://raganwald.com/2014/07/09/javascript-constructor-problem.html">Reginald Braithwaite</a> and <a href="http://davidwalsh.name/javascript-objects">Kyle Simpson</a> point out using <code>new</code> and constructor functions can be problematic for a number of reasons.</p>

<blockquote>
  <p>"If a feature is sometimes dangerous, and there is a better option, then always use the better option." -- Douglas Crockford</p>
</blockquote>

<h2 id="objectaccess">Object Access</h2>

<p>Objects have properties.  Properties are named keys on the object that can hold values. Those values can be basic types like strings, numbers, booleans or even object types like arrays, functions or other objects stored as references.  The easiest way to access properties on an object is using the <code>.</code> operator.  </p>

<pre><code>var obj = {  
  foo: "bar", 
  baz: 42,
  print: function(s){ console.log(s); }
};

obj.foo;  
obj.print("hi");  
</code></pre>

<p>You can also access object properties using the <code>[]</code> operator. The <code>[]</code> operator expects a string argument that identifies the property key you're trying to access.  Any non-string value will be coerced to a string and then used.</p>

<pre><code>var obj = {};  
obj["name"] = "David Tennant";  
obj["age"] = 44;  
obj["33"] = "what?";  // can only access using [] operator  
obj[true] = "true";   // coercion to property named "true"

obj.33;      // syntax error!  
obj["33"];   // "what?"  
obj["true"]; // "true"  
obj.true;    // "true"  
</code></pre>

<p>This makes it easy to dynamically access properties at runtime by storing or building the property names.</p>

<p>ES6 gives us a way to specify properties as shorthand, as well as computed property names.  For example,</p>

<pre><code>let age = 44;  
let obj = {  
  name: "David Tennant",
  // short for, who: function(){...}
  who() { console.log("the doctor"); },
  // short for age: age
  age,
  // computed property names!
  ["hello_" + (() =&gt; "sweetie")()]: "the wife"
};

obj.who();                       // "the doctor"  
console.log(obj.hello_sweetie);  // "the wife"  
</code></pre>

<p>I'll point out some more resources on the new ES6 object features at the end of this post.  Outside of computed property names, most of the object literal shorthand notation is just syntactic sugar to make declaring and working with objects in Javascript easier.</p>

<h2 id="iteratingobjects">Iterating Objects</h2>

<p>Now that our objects have all these properties, maybe we want to iterate through them.  Objects themselves are not <em>iterable objects</em> like arrays - they don't have an iterator defined for them, as access isn't as straight forward as one might think - you might iterate over the property names or property values; and what about prototype linked objects?</p>

<p>You can iterate over objects using the special <code>for..in</code> loop, which does iterate over the object's property keys, not it's values.  But, <code>for..in</code> will iterate over prototype linked, enumerable properties as well, so be sure and use a <code>.hasOwnProperty()</code> to help limit the scope and recursion into the prototype chain of the object you're iterating.</p>

<pre><code>var obj = { a: 1, b: 2 },  
    obj2 = Object.create(obj, {
      c: { value: 3, enumerable: true },
      d: { value: 4, enumerable: true } 
    });

for (var prop in obj2) {  
    console.log(prop);
}
// a b c d
for (var prop in obj2) {  
    if (obj2.hasOwnProperty(prop)) {
        console.log(prop);
    }
}
// c d
</code></pre>

<p>You can get access to an object's property keys using <code>Object.keys()</code>. The benefit of which, is that it only returns enumerable properties directly on the object in question - not prototype linked, enumerable properties.</p>

<pre><code>Object.keys(obj2).forEach(function(p) {  
  console.log(p + " = " + obj2[p]);
});
// c = 3
// d = 4
</code></pre>

<p>For information on ES6's new object shorthand properties and computed properties, check out <a href="https://strongloop.com/strongblog/javascript-es6-object-notation/">Strongloop's article</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">MDN</a>.</p>

<p>Also take a look at Kyle Simpson's <a href="https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes">You Don't Know JS: this &amp; Object properties</a> for more details about Javascript objects, <code>new</code> and more.</p>

<p><em>In the next article I'll cover specifically Javascript objects and prototypes and talk about why you should be using composition and delegation instead of trying to mimic "class" style inheritance with <code>new</code> and constructor functions.</em></p>
        <ul class="tags">
            <li class="tag" id="tag-id-2"><a href="/tag/fundamentals/">fundamentals</a></li> 
            <li class="tag" id="tag-id-5"><a href="/tag/javascript/">javascript</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t32" name="t32"></a><h1>32 : Chapter 4: Currying</h1>
					<span class="ref-site">https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html</span>
					<div class="tutorial__content">
<section class="normal markdown-section">
                                
                                
<h2 id="cant-live-if-livin-is-without-you">Can't live if livin' is without you</h2>
<p class="comments-section">My Dad once explained how there are certain things one can live without until one acquires them. A microwave is one such thing. Smart phones, another. The older folks among us will remember a fulfilling life sans internet. For me, currying is on this list.</p>
<p class="comments-section">The concept is simple: You can call a function with fewer arguments than it expects. It returns a function that takes the remaining arguments.</p><div class="comments-area"><div class="comment"><div class="comment-body "><a class="comment-user" target="_blank" href="https://www.gitbook.com/@deepakanand">Deepak Anand</a><div class="comment-content">"call a function with fewer arguments than it expects"<br><p>Isnt that partial application?</p>
</div></div></div><div class="comments-list" data-thcomments="39"><div class="comment"><div class="comment-body "><a class="comment-user" target="_blank" href="https://www.gitbook.com/@derekhannah">Derek Hannah</a><div class="comment-content"><p>nope. Currying always produces nested unary (1-ary) functions. The transformed function is still largely the same as the original. Partial application produces functions of arbitrary arity. The transformed function is different from the original – it needs less arguments.</p>
</div></div></div><div class="comment"><div class="comment-body "><a class="comment-user" target="_blank" href="https://www.gitbook.com/@derekhannah">Derek Hannah</a><div class="comment-content"><p><a href="http://www.2ality.com/2011/09/currying-vs-part-eval.html">http://www.2ality.com/2011/09/currying-vs-part-eval.html</a></p>
</div></div></div></div><div class="comments-post"><div class="comments-toolbar"><a href="#">Sign in to comment</a></div></div></div><p></p>
<p class="comments-section">You can choose to call it all at once or simply feed in each argument piecemeal.</p>
<pre><code>var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2);
// 3

addTen(2);
// 12
</code></pre>
<p class="comments-section">Here we've made a function <code>add</code> that takes one argument and returns a function. By calling it, the returned function remembers the first argument from then on via the closure. Calling it with both arguments all at once is a bit of a pain, however, so we can use a special helper function called <code>curry</code> to make defining and calling functions like this easier.</p><div class="comments-area"><div class="comment"><div class="comment-body "><a class="comment-user" target="_blank" href="https://www.gitbook.com/@boazblake">Boaz Blake</a><div class="comment-content"> By calling it, the returned function remembers the first argument from then on via the closure</div></div></div><div class="comments-list" data-thcomments="126"></div><div class="comments-post"><div class="comments-toolbar"><a href="#">Sign in to comment</a></div></div></div><p></p>
<p class="comments-section">Let's set up a few curried functions for our enjoyment.</p>
<pre><code>var curry = require('lodash/curry');

var match = curry(function(what, str) {
  return str.match(what);
});

var replace = curry(function(what, replacement, str) {
  return str.replace(what, replacement);
});

var filter = curry(function(f, ary) {
  return ary.filter(f);
});

var map = curry(function(f, ary) {
  return ary.map(f);
});
</code></pre>
<p class="comments-section">The pattern I've followed is a simple, but important one. I've strategically positioned the data we're operating on (String, Array) as the last argument. It will become clear as to why upon use.</p>
<pre><code>match(/\s+/g, 'hello world');
// [ ' ' ]

match(/\s+/g)('hello world');
// [ ' ' ]

var hasSpaces = match(/\s+/g);
// function(x) { return x.match(/\s+/g) }

hasSpaces('hello world');
// [ ' ' ]

hasSpaces('spaceless');
// null

filter(hasSpaces, ['tori_spelling', 'tori amos']);
// ['tori amos']

var findSpaces = filter(hasSpaces);
// function(xs) { return xs.filter(function(x) { return x.match(/\s+/g) }) }

findSpaces(['tori_spelling', 'tori amos']);
// ['tori amos']

var noVowels = replace(/[aeiouy]/ig);
// function(replacement, x) { return x.replace(/[aeiouy]/ig, replacement) }

var censored = noVowels("*");
// function(x) { return x.replace(/[aeiouy]/ig, '*') }

censored('Chocolate Rain');
// 'Ch*c*l*t* R**n'
</code></pre>
<p class="comments-section">What's demonstrated here is the ability to "pre-load" a function with an argument or two in order to receive a new function that remembers those arguments.</p>
<p class="comments-section">I encourage you to <code>npm install lodash</code>, copy the code above and have a go at it in the REPL. You can also do this in a browser where lodash or ramda is available.</p>
<h2 id="more-than-a-pun--special-sauce">More than a pun / special sauce</h2>
<p class="comments-section">Currying is useful for many things. We can make new functions just by giving our base functions some arguments as seen in <code>hasSpaces</code>, <code>findSpaces</code>, and <code>censored</code>.</p>
<p class="comments-section">We also have the ability to transform any function that works on single elements into a function that works on arrays simply by wrapping it with <code>map</code>:</p>
<pre><code>var getChildren = function(x) {
  return x.childNodes;
};

var allTheChildren = map(getChildren);
</code></pre>
<p class="comments-section">Giving a function fewer arguments than it expects is typically called <em>partial application</em>. Partially applying a function can remove a lot of boiler plate code. Consider what the above <code>allTheChildren</code> function would be with the uncurried <code>map</code> from lodash (note the arguments are in a different order):</p>
<pre><code>var allTheChildren = function(elements) {
  return _.map(elements, getChildren);
};
</code></pre>
<p class="comments-section">We typically don't define functions that work on arrays, because we can just call <code>map(getChildren)</code> inline. Same with <code>sort</code>, <code>filter</code>, and other higher order functions(Higher order function: A function that takes or returns a function).</p>
<p class="comments-section">When we spoke about <em>pure functions</em>, we said they take 1 input to 1 output. Currying does exactly this: each single argument returns a new function expecting the remaining arguments. That, old sport, is 1 input to 1 output.</p>
<p class="comments-section">No matter if the output is another function - it qualifies as pure. We do allow more than one argument at a time, but this is seen as merely removing the extra <code>()</code>'s for convenience.</p>
<h2 id="in-summary">In summary</h2>
<p class="comments-section">Currying is handy and I very much enjoy working with curried functions on a daily basis. It is a tool for the belt that makes functional programming less verbose and tedious.</p>
<p class="comments-section">We can make new, useful functions on the fly simply by passing in a few arguments and as a bonus, we've retained the mathematical function definition despite multiple arguments.</p>
<p class="comments-section">Let's acquire another essential tool called <code>compose</code>.</p>
<p class="comments-section"><a href="ch5.html">Chapter 5: Coding by Composing</a></p>
<h2 id="exercises">Exercises</h2>
<p class="comments-section">A quick word before we start. We'll use a library called <a href="http://ramdajs.com" target="_blank">Ramda</a> which curries every function by default. Alternatively you may choose to use <a href="https://github.com/lodash/lodash/wiki/FP-Guide" target="_blank">lodash/fp</a> which does the same and is written/maintained by the creator of lodash. Both will work just fine and it is a matter of preference.</p>
<p class="comments-section">There are <a href="https://github.com/DrBoolean/mostly-adequate-guide/tree/master/code/part1_exercises" target="_blank">unit tests</a> to run against your exercises as you code them, or you can just copy-paste into a JavaScript REPL for the early exercises if you wish.</p>
<p class="comments-section">Answers are provided with the code in the <a href="https://github.com/DrBoolean/mostly-adequate-guide/tree/master/code/part1_exercises/answers" target="_blank">repository for this book</a>. Best way to do the exercises is with an <a href="feedback_loop.md">immediate feedback loop</a>.</p>
<pre><code>var _ = require('ramda');


// Exercise 1
//==============
// Refactor to remove all arguments by partially applying the function.

var words = function(str) {
  return _.split(' ', str);
};

// Exercise 1a
//==============
// Use map to make a new words fn that works on an array of strings.

var sentences = undefined;


// Exercise 2
//==============
// Refactor to remove all arguments by partially applying the functions.

var filterQs = function(xs) {
  return _.filter(function(x) {
    return match(/q/i, x);
  }, xs);
};


// Exercise 3
//==============
// Use the helper function _keepHighest to refactor max to not reference any
// arguments.

// LEAVE BE:
var _keepHighest = function(x, y) {
  return x &gt;= y ? x : y;
};

// REFACTOR THIS ONE:
var max = function(xs) {
  return _.reduce(function(acc, x) {
    return _keepHighest(acc, x);
  }, -Infinity, xs);
};


// Bonus 1:
// ============
// Wrap array's slice to be functional and curried.
// //[1, 2, 3].slice(0, 2)
var slice = undefined;


// Bonus 2:
// ============
// Use slice to define a function "take" that takes n elements from the beginning of the string. Make it curried.
// // Result for "Something" with n=4 should be "Some"
var take = undefined;
</code></pre>

                                
                                </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t33" name="t33"></a><h1>33 : Chapter 5: Coding by Composing</h1>
					<span class="ref-site">https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html</span>
					<div class="tutorial__content">
<section class="normal markdown-section">
                                
                                
<h2 id="functional-husbandry">Functional husbandry</h2>
<p class="comments-section">Here's <code>compose</code>:</p>
<pre><code>var compose = function(f, g) {
  return function(x) {
    return f(g(x));
  };
};
</code></pre>
<p class="comments-section"><code>f</code> and <code>g</code> are functions and <code>x</code> is the value being "piped" through them.</p>
<p class="comments-section">Composition feels like function husbandry. You, breeder of functions, select two with traits you'd like to combine and mash them together to spawn a brand new one. Usage is as follows:</p>
<pre><code>var toUpperCase = function(x) {
  return x.toUpperCase();
};
var exclaim = function(x) {
  return x + '!';
};
var shout = compose(exclaim, toUpperCase);

shout("send in the clowns");
//=&gt; "SEND IN THE CLOWNS!"
</code></pre>
<p class="comments-section">The composition of two functions returns a new function. This makes perfect sense: composing two units of some type (in this case function) should yield a new unit of that very type. You don't plug two legos together and get a lincoln log. There is a theory here, some underlying law that we will discover in due time.</p>
<p class="comments-section">In our definition of <code>compose</code>, the <code>g</code> will run before the <code>f</code>, creating a right to left flow of data. This is much more readable than nesting a bunch of function calls. Without compose, the above would read:</p>
<pre><code>var shout = function(x) {
  return exclaim(toUpperCase(x));
};
</code></pre>
<p class="comments-section">Instead of inside to outside, we run right to left, which I suppose is a step in the left direction(boo). Let's look at an example where sequence matters:</p>
<pre><code>var head = function(x) {
  return x[0];
};
var reverse = reduce(function(acc, x) {
  return [x].concat(acc);
}, []);
var last = compose(head, reverse);

last(['jumpkick', 'roundhouse', 'uppercut']);
//=&gt; 'uppercut'
</code></pre>
<p class="comments-section"><code>reverse</code> will turn the list around while <code>head</code> grabs the initial item. This results in an effective, albeit inefficient, <code>last</code> function. The sequence of functions in the composition should be apparent here. We could define a left to right version, however, we mirror the mathematical version much more closely as it stands. That's right, composition is straight from the math books. In fact, perhaps it's time to look at a property that holds for any composition.</p>
<pre><code>// associativity
var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);
// true
</code></pre>
<p class="comments-section">Composition is associative, meaning it doesn't matter how you group two of them. So, should we choose to uppercase the string, we can write:</p>
<pre><code>compose(toUpperCase, compose(head, reverse));

// or
compose(compose(toUpperCase, head), reverse);
</code></pre>
<p class="comments-section">Since it doesn't matter how we group our calls to <code>compose</code>, the result will be the same. That allows us to write a variadic compose and use it as follows:</p>
<pre><code>// previously we'd have to write two composes, but since it's associative, we can give compose as many fn's as we like and let it decide how to group them.
var lastUpper = compose(toUpperCase, head, reverse);

lastUpper(['jumpkick', 'roundhouse', 'uppercut']);
//=&gt; 'UPPERCUT'


var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

loudLastUpper(['jumpkick', 'roundhouse', 'uppercut']);
//=&gt; 'UPPERCUT!'
</code></pre>
<p class="comments-section">Applying the associative property gives us this flexibility and peace of mind that the result will be equivalent. The slightly more complicated variadic definition is included with the support libraries for this book and is the normal definition you'll find in libraries like <a href="https://lodash.com/" target="_blank">lodash</a>, <a href="http://underscorejs.org/" target="_blank">underscore</a>, and <a href="http://ramdajs.com/" target="_blank">ramda</a>.</p>
<p class="comments-section">One pleasant benefit of associativity is that any group of functions can be extracted and bundled together in their very own composition. Let's play with refactoring our previous example:</p>
<pre><code>var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

// or
var last = compose(head, reverse);
var loudLastUpper = compose(exclaim, toUpperCase, last);

// or
var last = compose(head, reverse);
var angry = compose(exclaim, toUpperCase);
var loudLastUpper = compose(angry, last);

// more variations...
</code></pre>
<p class="comments-section">There's no right or wrong answers - we're just plugging our legos together in whatever way we please. Usually it's best to group things in a reusable way like <code>last</code> and <code>angry</code>. If familiar with Fowler's "<a href="http://martinfowler.com/books/refactoring.html" target="_blank">Refactoring</a>", one might recognize this process as "<a href="http://refactoring.com/catalog/extractMethod.html" target="_blank">extract method</a>"...except without all the object state to worry about.</p>
<h2 id="pointfree">Pointfree</h2>
<p class="comments-section">Pointfree style means never having to say your data. Excuse me. It means functions that never mention the data upon which they operate. First class functions, currying, and composition all play well together to create this style.</p>
<pre><code>//not pointfree because we mention the data: word
var snakeCase = function(word) {
  return word.toLowerCase().replace(/\s+/ig, '_');
};

//pointfree
var snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase);
</code></pre>
<p class="comments-section">See how we partially applied <code>replace</code>? What we're doing is piping our data through each function of 1 argument. Currying allows us to prepare each function to just take its data, operate on it, and pass it along. Something else to notice is how we don't need the data to construct our function in the pointfree version, whereas in the pointful one, we must have our <code>word</code> available before anything else.</p>
<p class="comments-section">Let's look at another example.</p>
<pre><code>//not pointfree because we mention the data: name
var initials = function(name) {
  return name.split(' ').map(compose(toUpperCase, head)).join('. ');
};

//pointfree
var initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));

initials("hunter stockton thompson");
// 'H. S. T'
</code></pre>
<p class="comments-section">Pointfree code can again, help us remove needless names and keep us concise and generic. Pointfree is a good litmus test for functional code as it lets us know we've got small functions that take input to output. One can't compose a while loop, for instance. Be warned, however, pointfree is a double-edged sword and can sometimes obfuscate intention. Not all functional code is pointfree and that is O.K. We'll shoot for it where we can and stick with normal functions otherwise.</p>
<h2 id="debugging">Debugging</h2>
<p class="comments-section">A common mistake is to compose something like <code>map</code>, a function of two arguments, without first partially applying it.</p>
<pre><code>//wrong - we end up giving angry an array and we partially applied map with god knows what.
var latin = compose(map, angry, reverse);

latin(['frog', 'eyes']);
// error


// right - each function expects 1 argument.
var latin = compose(map(angry), reverse);

latin(['frog', 'eyes']);
// ['EYES!', 'FROG!'])
</code></pre>
<p class="comments-section">If you are having trouble debugging a composition, we can use this helpful, but impure trace function to see what's going on.</p>
<pre><code>var trace = curry(function(tag, x) {
  console.log(tag, x);
  return x;
});

var dasherize = compose(join('-'), toLower, split(' '), replace(/\s{2,}/ig, ' '));

dasherize('The world is a vampire');
// TypeError: Cannot read property 'apply' of undefined
</code></pre>
<p class="comments-section">Something is wrong here, let's <code>trace</code></p>
<pre><code>var dasherize = compose(join('-'), toLower, trace('after split'), split(' '), replace(/\s{2,}/ig, ' '));
// after split [ 'The', 'world', 'is', 'a', 'vampire' ]
</code></pre>
<p class="comments-section">Ah! We need to <code>map</code> this <code>toLower</code> since it's working on an array.</p>
<pre><code>var dasherize = compose(join('-'), map(toLower), split(' '), replace(/\s{2,}/ig, ' '));

dasherize('The world is a vampire');

// 'the-world-is-a-vampire'
</code></pre>
<p class="comments-section">The <code>trace</code> function allows us to view the data at a certain point for debugging purposes. Languages like haskell and purescript have similar functions for ease of development.</p>
<p class="comments-section">Composition will be our tool for constructing programs and, as luck would have it, is backed by a powerful theory that ensures things will work out for us. Let's examine this theory.</p>
<h2 id="category-theory">Category theory</h2>
<p class="comments-section">Category theory is an abstract branch of mathematics that can formalize concepts from several different branches such as set theory, type theory, group theory, logic, and more. It primarily deals with objects, morphisms, and transformations, which mirrors programming quite closely. Here is a chart of the same concepts as viewed from each separate theory.</p>
<p><img src="images/cat_theory.png" alt="category theory" draggable="true" data-bukket-ext-bukket-draggable="true"></p>
<p class="comments-section">Sorry, I didn't mean to frighten you. I don't expect you to be intimately familiar with all these concepts. My point is to show you how much duplication we have so you can see why category theory aims to unify these things.</p>
<p class="comments-section">In category theory, we have something called... a category. It is defined as a collection with the following components:</p>
<ul>
<li>A collection of objects</li>
<li>A collection of morphisms</li>
<li>A notion of composition on the morphisms</li>
<li>A distinguished morphism called identity</li>
</ul>
<p class="comments-section">Category theory is abstract enough to model many things, but let's apply this to types and functions, which is what we care about at the moment.</p>
<p class="comments-section"><strong>A collection of objects</strong>
The objects will be data types. For instance, <code>String</code>, <code>Boolean</code>, <code>Number</code>, <code>Object</code>, etc. We often view data types as sets of all the possible values. One could look at <code>Boolean</code> as the set of <code>[true, false]</code> and <code>Number</code> as the set of all possible numeric values. Treating types as sets is useful because we can use set theory to work with them.</p>
<p class="comments-section"><strong>A collection of morphisms</strong>
The morphisms will be our standard every day pure functions.</p>
<p class="comments-section"><strong>A notion of composition on the morphisms</strong>
This, as you may have guessed, is our brand new toy - <code>compose</code>. We've discussed that our <code>compose</code> function is associative which is no coincidence as it is a property that must hold for any composition in category theory.</p>
<p class="comments-section">Here is an image demonstrating composition:</p>
<p><img src="images/cat_comp1.png" alt="category composition 1" draggable="true" data-bukket-ext-bukket-draggable="true">
<img src="images/cat_comp2.png" alt="category composition 2" draggable="true" data-bukket-ext-bukket-draggable="true"></p>
<p class="comments-section">Here is a concrete example in code:</p>
<pre><code>var g = function(x) {
  return x.length;
};
var f = function(x) {
  return x === 4;
};
var isFourLetterWord = compose(f, g);
</code></pre>
<p class="comments-section"><strong>A distinguished morphism called identity</strong>
Let's introduce a useful function called <code>id</code>. This function simply takes some input and spits it back at you. Take a look:</p>
<pre><code>var id = function(x) {
  return x;
};
</code></pre>
<p class="comments-section">You might ask yourself "What in the bloody hell is that useful for?". We'll make extensive use of this function in the following chapters, but for now think of it as a function that can stand in for our value - a function masquerading as every day data.</p>
<p class="comments-section"><code>id</code> must play nicely with compose. Here is a property that always holds for every unary (unary: a one-argument function) function f:</p>
<pre><code>// identity
compose(id, f) == compose(f, id) == f;
// true
</code></pre>
<p class="comments-section">Hey, it's just like the identity property on numbers! If that's not immediately clear, take some time with it. Understand the futility. We'll be seeing <code>id</code> used all over the place soon, but for now we see it's a function that acts as a stand in for a given value. This is quite useful when writing pointfree code.</p>
<p class="comments-section">So there you have it, a category of types and functions. If this is your first introduction, I imagine you're still a little fuzzy on what a category is and why it's useful. We will build upon this knowledge throughout the book. As of right now, in this chapter, on this line, you can at least see it as providing us with some wisdom regarding composition - namely, the associativity and identity properties.</p>
<p class="comments-section">What are some other categories, you ask? Well, we can define one for directed graphs with nodes being objects, edges being morphisms, and composition just being path concatenation. We can define with Numbers as objects and <code>&gt;=</code> as morphisms (actually any partial or total order can be a category). There are heaps of categories, but for the purposes of this book, we'll only concern ourselves with the one defined above. We have sufficiently skimmed the surface and must move on.</p>
<h2 id="in-summary">In Summary</h2>
<p class="comments-section">Composition connects our functions together like a series of pipes. Data will flow through our application as it must - pure functions are input to output after all, so breaking this chain would disregard output, rendering our software useless.</p>
<p class="comments-section">We hold composition as a design principle above all others. This is because it keeps our app simple and reasonable. Category theory will play a big part in app architecture, modelling side effects, and ensuring correctness.</p>
<p class="comments-section">We are now at a point where it would serve us well to see some of this in practice. Let's make an example application.</p>
<p class="comments-section"><a href="ch6.html">Chapter 6: Example Application</a></p>
<h2 id="exercises">Exercises</h2>
<pre><code>var _ = require('ramda');
var accounting = require('accounting');

// Example Data
var CARS = [{
  name: 'Ferrari FF',
  horsepower: 660,
  dollar_value: 700000,
  in_stock: true,
}, {
  name: 'Spyker C12 Zagato',
  horsepower: 650,
  dollar_value: 648000,
  in_stock: false,
}, {
  name: 'Jaguar XKR-S',
  horsepower: 550,
  dollar_value: 132000,
  in_stock: false,
}, {
  name: 'Audi R8',
  horsepower: 525,
  dollar_value: 114200,
  in_stock: false,
}, {
  name: 'Aston Martin One-77',
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}, {
  name: 'Pagani Huayra',
  horsepower: 700,
  dollar_value: 1300000,
  in_stock: false,
}];

// Exercise 1:
// ============
// Use _.compose() to rewrite the function below. Hint: _.prop() is curried.
var isLastInStock = function(cars) {
  var last_car = _.last(cars);
  return _.prop('in_stock', last_car);
};

// Exercise 2:
// ============
// Use _.compose(), _.prop() and _.head() to retrieve the name of the first car.
var nameOfFirstCar = undefined;


// Exercise 3:
// ============
// Use the helper function _average to refactor averageDollarValue as a composition.
var _average = function(xs) {
  return _.reduce(_.add, 0, xs) / xs.length;
}; // &lt;- leave be

var averageDollarValue = function(cars) {
  var dollar_values = _.map(function(c) {
    return c.dollar_value;
  }, cars);
  return _average(dollar_values);
};


// Exercise 4:
// ============
// Write a function: sanitizeNames() using compose that returns a list of lowercase and underscored car's names: e.g: sanitizeNames([{name: 'Ferrari FF', horsepower: 660, dollar_value: 700000, in_stock: true}]) //=&gt; ['ferrari_ff'].

var _underscore = _.replace(/\W+/g, '_'); //&lt;-- leave this alone and use to sanitize

var sanitizeNames = undefined;


// Bonus 1:
// ============
// Refactor availablePrices with compose.

var availablePrices = function(cars) {
  var available_cars = _.filter(_.prop('in_stock'), cars);
  return available_cars.map(function(x) {
    return accounting.formatMoney(x.dollar_value);
  }).join(', ');
};


// Bonus 2:
// ============
// Refactor to pointfree. Hint: you can use _.flip().

var fastestCar = function(cars) {
  var sorted = _.sortBy(function(car) {
    return car.horsepower;
  }, cars);
  var fastest = _.last(sorted);
  return fastest.name + ' is the fastest';
};
</code></pre>

                                
                                </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t34" name="t34"></a><h1>34 : Functional Mixins in ECMAScript 2015</h1>
					<span class="ref-site">http://raganwald.com/2015/06/17/functional-mixins.html</span>
					<div class="tutorial__content">
<section id="main_content">

          <p>In <a href="http://raganwald.com/2015/06/10/mixins.html">Prototypes are Objects</a>, we saw that you can emulate "mixins" using <code class="highlighter-rouge">Object.assign</code> on the prototypes that underly JavaScript "classes." We'll revisit this subject now and spend more time looking at mixing functionality into classes.</p>

<p>First, a quick recap: In JavaScript, a "class" is implemented as a constructor function and its prototype, whether you write it directly, or use the <code class="highlighter-rouge">class</code> keyword. Instances of the class are created by calling the constructor with <code class="highlighter-rouge">new</code>. They "inherit" shared behaviour from the constructor's <code class="highlighter-rouge">prototype</code> property.<sup id="fnref:delegate"><a href="#fn:delegate" class="footnote">1</a></sup></p>

<h3 id="the-object-mixin-pattern">the object mixin pattern</h3>

<p>One way to share behaviour scattered across multiple classes, or to untangle behaviour by factoring it out of an overweight prototype, is to extend a prototype with a <em>mixin</em>.</p>

<p>Here's a class of todo items:</p>

<pre><code>class Todo {
  constructor (name) {
    this.name = name || 'Untitled';
    this.done = false;
  }
  do () {
    this.done = true;
    return this;
  }
  undo () {
    this.done = false;
    return this;
  }
}
</code></pre>

<p>And a "mixin" that is responsible for colour-coding:</p>

<pre><code>const Coloured = {
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },
  getColourRGB () {
    return this.colourCode;
  }
};
</code></pre>

<p>Mixing colour coding into our Todo prototype is straightforward:</p>

<pre><code>Object.assign(Todo.prototype, Coloured);

new Todo('test')
  .setColourRGB({r: 1, g: 2, b: 3})
  //=&gt; {"name":"test","done":false,"colourCode":{"r":1,"g":2,"b":3}}
</code></pre>

<p>We can "upgrade" it to have a <a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">private property</a> if we wish:</p>

<pre><code>const colourCode = Symbol("colourCode");

const Coloured = {
  setColourRGB ({r, g, b}) {
    this[colourCode]= {r, g, b};
    return this;
  },
  getColourRGB () {
    return this[colourCode];
  }
};
</code></pre>

<p>So far, very easy and very simple. This is a <em>pattern</em>, a recipe for solving a certain problem using a particular organization of code.</p>

<p><a href="https://www.flickr.com/photos/chrisjrn/3771031871"><img src="/assets/images/macchiato.jpg" alt="Macchiato" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="functional-mixins">functional mixins</h3>

<p>The object mixin we have above works properly, but our little recipe had two distinct steps: Define the mixin and then extend the class prototype. Angus Croll pointed out that it's more elegant to define a mixin as a function rather than an object. He calls this a <a href="https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/" title="A fresh look at JavaScript Mixins">functional mixin</a>. Here's <code class="highlighter-rouge">Coloured</code> again, recast in functional form:</p>

<pre><code>const Coloured = (target) =&gt;
  Object.assign(target, {
    setColourRGB ({r, g, b}) {
      this.colourCode = {r, g, b};
      return this;
    },
    getColourRGB () {
      return this.colourCode;
    }
  });

Coloured(Todo.prototype);
</code></pre>

<p>We can make ourselves a <em>factory function</em> that also names the pattern:</p>

<pre><code>const FunctionalMixin = (behaviour) =&gt;
  target =&gt; Object.assign(target, behaviour);
</code></pre>

<p>This allows us to define functional mixins neatly:</p>

<pre><code>const Coloured = FunctionalMixin({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },
  getColourRGB () {
    return this.colourCode;
  }
});
</code></pre>

<h3 id="enumerability">enumerability</h3>

<p>If we look at the way <code class="highlighter-rouge">class</code> defines prototypes, we find that the methods defined are not enumerable by default. This works around a common error where programmers iterate over the keys of an instance and fail to test for <code class="highlighter-rouge">.hasOwnProperty</code>.</p>

<p>Our object mixin pattern does not work this way, the methods defined in a mixin <em>are</em> enumerable by default, and if we carefully defined them to be non-enumerable, <code class="highlighter-rouge">Object.assign</code> wouldn't mix them into the target prototype, because <code class="highlighter-rouge">Object.assign</code> only assigns enumerable properties.</p>

<p>And thus:</p>

<pre><code>Coloured(Todo.prototype)

const urgent = new Todo("finish blog post");
urgent.setColourRGB({r: 256, g: 0, b: 0});

for (let property in urgent) console.log(property);
  // =&gt;
    name
    done
    colourCode
    setColourRGB
    getColourRGB
</code></pre>

<p>As we can see, the <code class="highlighter-rouge">setColourRGB</code> and <code class="highlighter-rouge">getColourRGB</code> methods are enumerated, although the <code class="highlighter-rouge">do</code> and <code class="highlighter-rouge">undo</code> methods are not. This can be a problem with naïve code: we can't always rewrite all the <em>other</em> code to carefully use <code class="highlighter-rouge">.hasOwnProperty</code>.</p>

<p>One benefit of functional mixins is that we can solve this problem and transparently make mixins behave like <code class="highlighter-rouge">class</code>:</p>

<pre><code>const FunctionalMixin = (behaviour) =&gt;
  function (target) {
    for (let property of Reflect.ownKeys(behaviour))
      Object.defineProperty(target, property, { value: behaviour[property] })
    return target;
  }
</code></pre>

<p>Writing this out as a pattern would be tedious and error-prone. Encapsulating the behaviour into a function is a small win.</p>

<p><a href="https://www.flickr.com/photos/yellowskyphotography/7449919584"><img src="/assets/images/jbts.jpg" alt="Just Below the Surface" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="mixin-responsibilities">mixin responsibilities</h3>

<p>Like classes, mixins are metaobjects: They define behaviour for instances. In addition to defining behaviour in the form of methods, classes are also responsible for initializing instances. But sometimes, classes and metaobjects handle additional responsibilities.</p>

<p>For example, sometimes a particular concept is associated with some well-known constants. When using a class, can be handy to namespace such values in the class itself:</p>

<pre><code>class Todo {
  constructor (name) {
    this.name = name || Todo.DEFAULT_NAME;
    this.done = false;
  }
  do () {
    this.done = true;
    return this;
  }
  undo () {
    this.done = false;
    return this;
  }
}

Todo.DEFAULT_NAME = 'Untitled';

// If we are sticklers for read-only constants, we could write:
// Object.defineProperty(Todo, 'DEFAULT_NAME', {value: 'Untitled'});
</code></pre>

<p>We can't really do the same thing with simple mixins, because all of the properties in a simple mixin end up being mixed into the prototype of instances we create by default. For example, let's say we want to define <code class="highlighter-rouge">Coloured.RED</code>, <code class="highlighter-rouge">Coloured.GREEN</code>, and <code class="highlighter-rouge">Coloured.BLUE</code>. But we don't want any specific coloured instance to define <code class="highlighter-rouge">RED</code>, <code class="highlighter-rouge">GREEN</code>, or <code class="highlighter-rouge">BLUE</code>.</p>

<p>Again, we can solve this problem by building a functional mixin. Our <code class="highlighter-rouge">FunctionalMixin</code> factory function will accept an optional dictionary of read-only mixin properties, provided they are associated with a special key:</p>

<pre><code>const shared = Symbol("shared");

function FunctionalMixin (behaviour) {
  const instanceKeys = Reflect.ownKeys(behaviour)
    .filter(key =&gt; key !== shared);
  const sharedBehaviour = behaviour[shared] || {};
  const sharedKeys = Reflect.ownKeys(sharedBehaviour);

  function mixin (target) {
    for (let property of instanceKeys)
      Object.defineProperty(target, property, { value: behaviour[property] });
    return target;
  }
  for (let property of sharedKeys)
    Object.defineProperty(mixin, property, {
      value: sharedBehaviour[property],
      enumerable: sharedBehaviour.propertyIsEnumerable(property)
    });
  return mixin;
}

FunctionalMixin.shared = shared;
</code></pre>

<p>And now we can write:</p>

<pre><code>const Coloured = FunctionalMixin({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },
  getColourRGB () {
    return this.colourCode;
  },
  [FunctionalMixin.shared]: {
    RED:   { r: 255, g: 0,   b: 0   },
    GREEN: { r: 0,   g: 255, b: 0   },
    BLUE:  { r: 0,   g: 0,   b: 255 },
  }
});

Coloured(Todo.prototype)

const urgent = new Todo("finish blog post");
urgent.setColourRGB(Coloured.RED);

urgent.getColourRGB()
  //=&gt; {"r":255,"g":0,"b":0}
</code></pre>

<h3 id="mixin-methods">mixin methods</h3>

<p>Such properties need not be values. Sometimes, classes have methods. And likewise, sometimes it makes sense for a mixin to have its own methods. One example concerns <code class="highlighter-rouge">instanceof</code>.</p>

<p>In earlier versions of ECMAScript, <code class="highlighter-rouge">instanceof</code> is an operator that checks to see whether the prototype of an instance matches the prototype of a constructor function. It works just fine with "classes," but it does not work "out of the box" with mixins:</p>

<pre><code>urgent instanceof Todo
  //=&gt; true

urgent instanceof Coloured
  //=&gt; false
</code></pre>

<p>To handle this and some other issues where programmers are creating their own notion of dynamic types, or managing prototypes directly with <code class="highlighter-rouge">Object.create</code> and <code class="highlighter-rouge">Object.setPrototypeOf</code>, ECMAScript 2015 provides a way to override the built-in <code class="highlighter-rouge">instanceof</code> behaviour: An object can define a method associated with a well-known symbol, <code class="highlighter-rouge">Symbol.hasInstance</code>.</p>

<p>We can test this quickly:<sup id="fnref:but"><a href="#fn:but" class="footnote">2</a></sup></p>

<pre><code>Object.defineProperty(Coloured, Symbol.hasInstance, {value: (instance) =&gt; true});
urgent instanceof Coloured
  //=&gt; true
{} instanceof Coloured
  //=&gt; true
</code></pre>

<p>Of course, that is not semantically correct. But using this technique, we can write:</p>

<pre><code>const shared = Symbol("shared");

function FunctionalMixin (behaviour) {
  const instanceKeys = Reflect.ownKeys(behaviour)
    .filter(key =&gt; key !== shared);
  const sharedBehaviour = behaviour[shared] || {};
  const sharedKeys = Reflect.ownKeys(sharedBehaviour);
  const typeTag = Symbol("isA");

  function mixin (target) {
    for (let property of instanceKeys)
      Object.defineProperty(target, property, { value: behaviour[property] });
    target[typeTag] = true;
    return target;
  }
  for (let property of sharedKeys)
    Object.defineProperty(mixin, property, {
      value: sharedBehaviour[property],
      enumerable: sharedBehaviour.propertyIsEnumerable(property)
    });
  Object.defineProperty(mixin, Symbol.hasInstance, {value: (instance) =&gt; !!instance[typeTag]});
  return mixin;
}

FunctionalMixin.shared = shared;

urgent instanceof Coloured
  //=&gt; true
{} instanceof Coloured
  //=&gt; false
</code></pre>

<p>Do you need to implement <code class="highlighter-rouge">instanceof</code>? Quite possibly not. "Rolling your own polymorphism" is usually a last resort. But it can be handy for writing test cases, and a few daring framework developers might be working on multiple dispatch and pattern-matching for functions.</p>

<h3 id="summary">summary</h3>

<p>The charm of the object mixin pattern is its simplicity: It really does not need an abstraction wrapped around an object literal and <code class="highlighter-rouge">Object.assign</code>.</p>

<p>However, behaviour defined with the mixin pattern is <em>slightly</em> different than behaviour defined with the <code class="highlighter-rouge">class</code> keyword. Two examples of these differences are enumerability and mixin properties (such as constants and mixin methods like <code class="highlighter-rouge">[Symbol.hasInstance]</code>).</p>

<p>Functional mixins provide an opportunity to implement such functionality, at the cost of some complexity in the <code class="highlighter-rouge">FunctionalMixin</code> function that creates functional mixins.</p>

<p>As a general rule, it's best to have things behave as similarly as possible in the domain code, and this sometimes does involve some extra complexity in the infrastructure code. But that is more of a guideline than a hard-and-fast rule, and for this reason there is a place for both the object mixin pattern <em>and</em> functional mixins in JavaScript.</p>

<p>(discuss on <a href="https://news.ycombinator.com/item?id=9734774">hacker news</a> and <a href="http://www.reddit.com/r/javascript/comments/3a7hxz/functional_mixins_in_ecmascript_2015/">/r/javascript</a>)</p>

<p><em>follow-up</em>: <a href="http://raganwald.com/2015/06/20/purely-functional-composition.html">Purely Functional Composition</a></p>

<hr>

<p>more reading:</p>

<ul>
  <li><a href="http://raganwald.com/2015/06/10/mixins.html">Prototypes are Objects (and why that matters)</a></li>
  <li><a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">Classes are Expressions (and why that matters)</a></li>
  <li><a href="http://raganwald.com/2015/06/17/functional-mixins.html">Functional Mixins in ECMAScript 2015</a></li>
  <li><a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">Using ES.later Decorators as Mixins</a></li>
  <li><a href="http://raganwald.com/2015/08/05/method-advice.html">Method Advice in Modern JavaScript</a></li>
  <li><a href="http://raganwald.com/2015/12/23/super-considered-hmmmful.html"><code class="highlighter-rouge">super()</code> considered hmmm-ful</a></li>
  <li><a href="http://raganwald.com/2015/12/28/mixins-subclass-factories-and-method-advice.html">JavaScript Mixins, Subclass Factories, and Method Advice</a></li>
  <li><a href="http://raganwald.com/2015/12/31/this-is-not-an-essay-about-traits-in-javascript.html">This is not an essay about ‘Traits in Javascript'</a></li>
</ul>

<p>notes:</p>

<div class="footnotes">
  <ol>
    <li id="fn:delegate">
      <p>A much better way to put it is that objects with a prototype <em>delegate</em> behaviour to their prototype (and that may in turn delegate behaviour to its prototype if it has one, and so on).&nbsp;<a href="#fnref:delegate" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:but">
      <p>This may <strong>not</strong> work with various transpilers and other incomplete ECMAScript 2015 implementations. Check the documentation. For example, you must enable the "high compliancy" mode in <a href="http://babeljs.io">BabelJS</a>. This is off by default to provide the highest possible performance for code bases that do not need to use features like this.&nbsp;<a href="#fnref:but" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>

        </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t35" name="t35"></a><h1>35 : JavaScript Mixins, Subclass Factories, and Method Advice</h1>
					<span class="ref-site">http://raganwald.com/2015/12/28/mixins-subclass-factories-and-method-advice.html</span>
					<div class="tutorial__content">
<section id="main_content">

          <p><em>Mixins</em> solve a very common problem in class-centric OOP: For non-trivial applications, there is a messy many-to-many relationship between behaviour and classes, and it does not neatly decompose into a tree. In this essay, we only touch lightly over the benefits of using mixins with classes, and in their stead we will focus on some of the limitations of mixins and ways to not just overcome them, but create designs that are superior to those created with classes alone.</p>

<p>(For more on why mixins matter in the first place, you may want to review <a href="http://raganwald.com/2015/06/10/mixins.html">Prototypes are Objects (and why that matters)</a>, <a href="http://raganwald.com/2015/06/17/functional-mixins.html">Functional Mixins in ECMAScript 2015</a>, and <a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">Using ES.later Decorators as Mixins</a>.)</p>



<h3 id="simple-mixins">simple mixins</h3>

<p>As noted above, for non-trivial applications, there is a messy many-to-many relationship between behaviour and classes. However, JavaScript's single-inheritance model forces us to organize behaviour in trees, which can only represent one-to-many relationships.</p>

<p>The mixin solution to this problem is to leave classes in a single inheritance hierarchy, and to mix additional behaviour into individual classes as needed. Here's a vastly simplified functional mixin for classes:<sup id="fnref:simplified"><a href="#fn:simplified" class="footnote">1</a></sup></p>

<pre><code>function mixin (behaviour) {
  let instanceKeys = Reflect.ownKeys(behaviour);
  let typeTag = Symbol('isa');

  function _mixin (clazz) {
    for (let property of instanceKeys)
      Object.defineProperty(clazz.prototype, property, {
        value: behaviour[property],
        writable: true
      });
    Object.defineProperty(clazz.prototype, typeTag, { value: true });
    return clazz;
  }
  Object.defineProperty(_mixin, Symbol.hasInstance, {
    value: (i) =&gt; !!i[typeTag]
  });
  return _mixin;
}
</code></pre>

<p>This is more than enough to do a lot of very good work in JavaScript, but it's just the starting point. Here's how we put it to work:</p>

<pre><code>let BookCollector = mixin({
  addToCollection (name) {
    this.collection().push(name);
    return this;
  },
  collection () {
    return this._collected_books || (this._collected_books = []);
  }
});

class Person {
  constructor (first, last) {
    this.rename(first, last);
  }
  fullName () {
    return this.firstName + " " + this.lastName;
  }
  rename (first, last) {
    this.firstName = first;
    this.lastName = last;
    return this;
  }
}

let Executive = BookCollector(
  class extends Person {
    constructor (title, first, last) {
      super(first, last);
      this.title = title;
    }

    fullName () {
      return `${this.title} ${super.fullName()}`;
    }
  }
);

let president = new Executive('President', 'Barak', 'Obama');

president
  .addToCollection("JavaScript Allongé")
  .addToCollection("Kestrels, Quirky Birds, and Hopeless Egocentricity");

president.collection()
  //=&gt; ["JavaScript Allongé","Kestrels, Quirky Birds, and Hopeless Egocentricity"]
</code></pre>

<h3 id="multiple-inheritance">multiple inheritance</h3>

<p>If you want to mix behaviour into a class, mixins do the job very nicely. But sometimes, people want more. They want <strong>multiple inheritance</strong>. Meaning, what they really want is for class <code class="highlighter-rouge">Executive</code> to inherit from <code class="highlighter-rouge">Person</code> <em>and</em> from <code class="highlighter-rouge">BookCollector</code>.</p>

<p>What's the difference between <code class="highlighter-rouge">Executive</code> mixing <code class="highlighter-rouge">BookCollector</code> in and <code class="highlighter-rouge">Executive</code> inheriting from <code class="highlighter-rouge">BookCollector</code>?</p>

<ol>
  <li>If <code class="highlighter-rouge">Executive</code> mixes <code class="highlighter-rouge">BookCollector</code> in, the properties <code class="highlighter-rouge">addToCollection</code> and <code class="highlighter-rouge">collection</code> become own properties of <code class="highlighter-rouge">Executive</code>'s prototype. If <code class="highlighter-rouge">Executive</code> inherits from <code class="highlighter-rouge">BookCollector</code>, they don't.<br><br></li>
  <li>If <code class="highlighter-rouge">Executive</code> mixes <code class="highlighter-rouge">BookCollector</code> in, <code class="highlighter-rouge">Executive</code> can't override methods of <code class="highlighter-rouge">BookCollector</code>. If <code class="highlighter-rouge">Executive</code> inherits from <code class="highlighter-rouge">BookCollector</code>, it can.<br><br></li>
  <li>If <code class="highlighter-rouge">Executive</code> mixes <code class="highlighter-rouge">BookCollector</code> in, <code class="highlighter-rouge">Executive</code> can't override methods of <code class="highlighter-rouge">BookCollector</code>, and therefore it can't make a method that overrides a method of <code class="highlighter-rouge">BookCollector</code> and then uses <code class="highlighter-rouge">super</code> to call the original. If <code class="highlighter-rouge">Executive</code> inherits from <code class="highlighter-rouge">BookCollector</code>, it can.</li>
</ol>

<p>If JavaScript had multiple inheritance, we could extend a class with more than one superclass:</p>

<pre><code>class Todo {
  constructor (name) {
    this.name = name || 'Untitled';
    this.done = false;
  }

  do () {
    this.done = true;
    return this;
  }

  undo () {
    this.done = false;
    return this;
  }

  toHTML () {
    return this.name; // highly insecure
  }
}

class Coloured {
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  }

  getColourRGB () {
    return this.colourCode;
  }
}

let yellow = {r: 'FF', g: 'FF', b: '00'},
    red    = {r: 'FF', g: '00', b: '00'},
    green  = {r: '00', g: 'FF', b: '00'},
    grey   = {r: '80', g: '80', b: '80'};

let oneDayInMilliseconds = 1000 * 60 * 60 * 24;

class TimeSensitiveTodo extends Todo, Coloured {
  constructor (name, deadline) {
    super(name);
    this.deadline = deadline;
  }

  getColourRGB () {
    let slack = this.deadline - Date.now();

    if (this.done) {
      return grey;
    }
    else if (slack &lt;= 0) {
      return red;
    }
    else if (slack &lt;= oneDayInMilliseconds){
      return yellow;
    }
    else return green;
  }

  toHTML () {
    let rgb = this.getColourRGB();

    return `<span style="color: #${rgb.r}${rgb.g}${rgb.b};">${super.toHTML()}</span>`;
  }
}
</code></pre>

<p>This hypothetical <code class="highlighter-rouge">TimeSensitiveTodo</code> extends both <code class="highlighter-rouge">Todo</code> and <code class="highlighter-rouge">Coloured</code>, and it overrides <code class="highlighter-rouge">toHTML</code> from <code class="highlighter-rouge">Todo</code> as well as overriding <code class="highlighter-rouge">getColourRGB</code> from <code class="highlighter-rouge">Coloured</code>.</p>

<p><a href="https://www.flickr.com/photos/jetstarairways/9130160595"><img src="/assets/images/boeing-factory.jpg" alt="Boeing Factory" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="subclass-factories">subclass factories</h3>

<p>However, JavaScript does not have "true" multiple inheritance, and therefore this code does not work. But we can simulate multiple inheritance for cases like this. The way it works is to step back and ask ourselves, "What would we do if we didn't have mixins or multiple inheritance?"</p>

<p>The answer is, we'd force a square multiple inheritance peg into a round single inheritance hole, like this:</p>

<pre><code>class Todo {
  // ...
}

class ColouredTodo extends Todo {
  // ...
}

class TimeSensitiveTodo extends ColouredTodo {
  // ...
}
</code></pre>

<p>By making <code class="highlighter-rouge">ColouredTodo</code> extend <code class="highlighter-rouge">Todo</code>, <code class="highlighter-rouge">TimeSensitiveTodo</code> can extend <code class="highlighter-rouge">ColouredTodo</code> and override methods from both. This is exactly what most programmers do, and we know that it is an anti-pattern, as it leads to duplicated class behaviour and deep class hierarchies.</p>

<p>But.</p>

<p>What if, instead of manually creating this hierarchy, we use our simple mixins to do the work for us? We can take advantage of the fact that <a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">classes are expressions</a>, like this:</p>

<pre><code>let Coloured = mixin({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },

  getColourRGB () {
    return this.colourCode;
  }
});

let ColouredTodo = Coloured(class extends Todo {});
</code></pre>

<p>Thus, we have a <code class="highlighter-rouge">ColouredTodo</code> that we can extend and override, but we also have our <code class="highlighter-rouge">Coloured</code> behaviour in a mixin we can use anywhere we like without duplicating its functionality in our code. The full solution looks like this:</p>

<pre><code>class Todo {
  constructor (name) {
    this.name = name || 'Untitled';
    this.done = false;
  }

  do () {
    this.done = true;
    return this;
  }

  undo () {
    this.done = false;
    return this;
  }

  toHTML () {
    return this.name; // highly insecure
  }
}

let Coloured = mixin({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },

  getColourRGB () {
    return this.colourCode;
  }
});

let ColouredTodo = Coloured(class extends Todo {});

let yellow = {r: 'FF', g: 'FF', b: '00'},
    red    = {r: 'FF', g: '00', b: '00'},
    green  = {r: '00', g: 'FF', b: '00'},
    grey   = {r: '80', g: '80', b: '80'};

let oneDayInMilliseconds = 1000 * 60 * 60 * 24;

class TimeSensitiveTodo extends ColouredTodo {
  constructor (name, deadline) {
    super(name);
    this.deadline = deadline;
  }

  getColourRGB () {
    let slack = this.deadline - Date.now();

    if (this.done) {
      return grey;
    }
    else if (slack &lt;= 0) {
      return red;
    }
    else if (slack &lt;= oneDayInMilliseconds){
      return yellow;
    }
    else return green;
  }

  toHTML () {
    let rgb = this.getColourRGB();

    return `<span style="color: #${rgb.r}${rgb.g}${rgb.b};">${super.toHTML()}</span>`;
  }
}

let task = new TimeSensitiveTodo('Finish blog post', Date.now() + oneDayInMilliseconds);

task.toHTML()
  //=&gt; <span style="color: #FFFF00;">Finish blog post</span>
</code></pre>

<p>The key snippet is <code class="highlighter-rouge">let ColouredTodo = Coloured(class extends Todo {});</code>, it turns behaviour into a subclass that can be extended and overridden. We can turn this pattern into a function:</p>

<pre><code>let subclassFactory = (behaviour) =&gt; {
  let mixBehaviourInto = mixin(behaviour);

  return (superclazz) =&gt; mixBehaviourInto(class extends superclazz {});
}
</code></pre>

<p>Using <code class="highlighter-rouge">subclassFactory</code>, we wrap the class we want to extend, instead of the class we are declaring. Like this:</p>

<pre><code>let subclassFactory = (behaviour) =&gt; {
  let mixBehaviourInto = mixin(behaviour);

  return (superclazz) =&gt; mixBehaviourInto(class extends superclazz {});
}

let ColouredAsWellAs = subclassFactory({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },

  getColourRGB () {
    return this.colourCode;
  }
});

class TimeSensitiveTodo extends ColouredAsWellAs(ToDo) {
  constructor (name, deadline) {
    super(name);
    this.deadline = deadline;
  }

  getColourRGB () {
    let slack = this.deadline - Date.now();

    if (this.done) {
      return grey;
    }
    else if (slack &lt;= 0) {
      return red;
    }
    else if (slack &lt;= oneDayInMilliseconds){
      return yellow;
    }
    else return green;
  }

  toHTML () {
    let rgb = this.getColourRGB();

    return `<span style="color: #${rgb.r}${rgb.g}${rgb.b};">${super.toHTML()}</span>`;
  }
}
</code></pre>

<p>The syntax of <code class="highlighter-rouge">class TimeSensitiveTodo extends ColouredAsWellAs(ToDo)</code> says exactly what we mean: We are extending our <code class="highlighter-rouge">Coloured</code> behaviour as well as extending <code class="highlighter-rouge">ToDo</code>.<sup id="fnref:fagnani"><a href="#fn:fagnani" class="footnote">2</a></sup></p>

<h3 id="another-way-forward">another way forward</h3>

<p>The solution subclass factories offer is emulating inheritance from more than one superclass. That, in turn, makes it possible to override methods from our superclass as well as the behaviour we want to mix in. Which is fine, but we don't actually want multiple inheritance!</p>

<p>It's just that we're looking at an overriding/extending methods problem, but we're holding an inheritance-shaped hammer. So it looks like a multiple-inheritance nail. But what if we address the problem of overriding and extending methods directly, rather than indirectly via multiple inheritance?</p>

<p><a href="https://www.flickr.com/photos/25182350@N03/2981062354"><img src="/assets/images/nail.jpg" alt="Nail" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="simple-overwriting-with-simple-mixins">simple overwriting with simple mixins</h3>

<p>We start by noting that in the first pass of our <code class="highlighter-rouge">mixin</code> function, we blindly copied properties from the mixin into the class's prototype, whether the class defined those properties or not. So if we write:</p>

<pre><code>let RED        = { r: 'FF', g: '00', b: '00' },
    WHITE      = { r: 'FF', g: 'FF', b: 'FF' },
    ROYAL_BLUE = { r: '41', g: '69', b: 'E1' },
    LIGHT_BLUE = { r: 'AD', g: 'D8', b: 'E6' };

let BritishRoundel = mixin({
  shape () {
    return 'round';
  },

  roundels () {
    return [RED, WHITE, ROYAL_BLUE];
  }
})

let CanadianAirForceRoundel = BritishRoundel(class {
  roundels () {
    return [RED, WHITE, LIGHT_BLUE];
  }
});

new CanadianAirForceRoundel().roundels()
  //=&gt; [
    {"r":"FF","g":"00","b":"00"},
    {"r":"FF","g":"FF","b":"FF"},
    {"r":"41","g":"69","b":"E1"}
  ]
</code></pre>

<p>Our <code class="highlighter-rouge">CanadianAirForceRoundel</code>'s third stripe winds up being regular blue instead of light blue, because the <code class="highlighter-rouge">roundels</code> method from the mixin <code class="highlighter-rouge">BritishRoundel</code> overwrites its own. (Yes, this is a ridiculous example, but it gets the point across.)</p>

<p>We can fix this by not overwriting a property if the class already defines it. That's not so hard:</p>

<pre><code>function mixin (behaviour) {
  let instanceKeys = Reflect.ownKeys(behaviour);
  let typeTag = Symbol('isa');

  function _mixin (clazz) {
    for (let property of instanceKeys)
      if (!clazz.prototype.hasOwnProperty(property)) {
        Object.defineProperty(clazz.prototype, property, {
          value: behaviour[property],
          writable: true
        });
      }
    Object.defineProperty(clazz.prototype, typeTag, { value: true });
    return clazz;
  }
  Object.defineProperty(_mixin, Symbol.hasInstance, {
    value: (i) =&gt; !!i[typeTag]
  });
  return _mixin;
}
</code></pre>

<p>Now we can override <code class="highlighter-rouge">roundels</code> in <code class="highlighter-rouge">CanadianAirForceRoundel</code> while mixing <code class="highlighter-rouge">shape</code> in just fine:</p>

<pre><code>new CanadianAirForceRoundel().roundels()
  //=&gt; [
    {"r":"FF","g":"00","b":"00"},
    {"r":"FF","g":"FF","b":"FF"},
    {"r":"AD","g":"D8","b":"E6"}
  ]
</code></pre>

<p>The method defined in the class is now the "definition of record," just as we might expect. But it's not enough in and of itself.</p>

<h3 id="combining-advice-with-simple-mixins">combining advice with simple mixins</h3>

<p>The above adjustment to ‘mixin' is fine for simple overwriting, but what about when we wish to modify or extend a method's behaviour while still invoking the original? Recall that our <code class="highlighter-rouge">TimeSensitiveTodo</code> example performed a simple override of <code class="highlighter-rouge">getColourRGB</code>, but its implementation of <code class="highlighter-rouge">toHTML</code> used <code class="highlighter-rouge">super</code> to invoke the method it was overriding.</p>

<p>Our adjustment will not allow a method in the class to invoke the body of a method in a mixin. So we can't use it to implement <code class="highlighter-rouge">TimeSensitiveTodo</code>. For that, we need a different tool, <a href="http://raganwald.com/2015/08/05/method-advice.html">method advice</a>.</p>

<p>Method advice is a powerful tool in its own right: It allows us to compose method functionality in a declarative way. Here's a simple "override" function that decorates a class:</p>

<pre><code>let override = (behaviour, ...overriddenMethodNames) =&gt;
  (clazz) =&gt; {
    if (typeof behaviour === 'string') {
      behaviour = clazz.prototype[behaviour];
    }
    for (let overriddenMethodName of overriddenMethodNames) {
      let overriddenMethodFunction = clazz.prototype[overriddenMethodName];

      Object.defineProperty(clazz.prototype, overriddenMethodName, {
        value: function (...args) {
          return behaviour.call(this, overriddenMethodFunction.bind(this), ...args);
        },
        writable: true
      });
    }
    return clazz;
  };
</code></pre>

<p>It takes behaviour in the form of a name of a method or a function, and one or more names of methods to override. It overrides each of the methods with the behaviour, which is invoked with the overridden method's function as the first argument.</p>

<p>This allows us to invoke the original without needing to use <code class="highlighter-rouge">super</code>. And although we don't show all the other use cases here, it is handy for far more than overriding mixin methods, it can be used to decompose methods into separate responsibilities.</p>

<p>Using <code class="highlighter-rouge">override</code>, we can decorate methods with any arbitrary functionality. We'd use it like this:</p>

<pre><code>class Todo {
  constructor (name) {
    this.name = name || 'Untitled';
    this.done = false;
  }

  do () {
    this.done = true;
    return this;
  }

  undo () {
    this.done = false;
    return this;
  }

  toHTML () {
    return this.name; // highly insecure
  }
}

let Coloured = mixin({
  setColourRGB ({r, g, b}) {
    this.colourCode = {r, g, b};
    return this;
  },

  getColourRGB () {
    return this.colourCode;
  }
});

let yellow = {r: 'FF', g: 'FF', b: '00'},
    red    = {r: 'FF', g: '00', b: '00'},
    green  = {r: '00', g: 'FF', b: '00'},
    grey   = {r: '80', g: '80', b: '80'};

let oneDayInMilliseconds = 1000 * 60 * 60 * 24;

let TimeSensitiveTodo = override('wrapWithColour', 'toHTML')(
  Coloured(
    class extends Todo {
      constructor (name, deadline) {
        super(name);
        this.deadline = deadline;
      }

      getColourRGB () {
        let slack = this.deadline - Date.now();

        if (this.done) {
          return grey;
        }
        else if (slack &lt;= 0) {
          return red;
        }
        else if (slack &lt;= oneDayInMilliseconds){
          return yellow;
        }
        else return green;
      }

      wrapWithColour (original) {
        let rgb = this.getColourRGB();

        return `<span style="color: #${rgb.r}${rgb.g}${rgb.b};">${original()}</span>`;
      }
    }
  )
);
let task = new TimeSensitiveTodo('Finish blog post', Date.now() + oneDayInMilliseconds);

task.toHTML()
  //=&gt; <span style="color: #FFFF00;">Finish blog post</span>
</code></pre>

<p>With this solution, we've used our revamped mixin function to support <code class="highlighter-rouge">getColourRGB</code> overriding the mixin's definition, and we've used <code class="highlighter-rouge">override</code> to support wrapping functionality around the original <code class="highlighter-rouge">toHTML</code> method.</p>

<p>As a final bonus, if we are using a transpiler that supports ES.who-knows-when, we can use the proposed class decorator syntax:</p>

<pre><code>@override('wrapWithColour', 'toHTML')
@Coloured
class TimeSensitiveTodo extends Todo {
  constructor (name, deadline) {
    super(name);
    this.deadline = deadline;
  }

  getColourRGB () {
    let slack = this.deadline - Date.now();

    if (this.done) {
      return grey;
    }
    else if (slack &lt;= 0) {
      return red;
    }
    else if (slack &lt;= oneDayInMilliseconds){
      return yellow;
    }
    else return green;
  }

  wrapWithColour (original) {
    let rgb = this.getColourRGB();

    return `<span style="color: #${rgb.r}${rgb.g}${rgb.b};">${original()}</span>`;
  }
}
</code></pre>

<p>This is extremely readable.</p>

<p><a href="https://www.flickr.com/photos/kjmniemi/978113662"><img src="/assets/images/a-touch-of-light.jpg" alt="A Touch of Light" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="method-advice-beyond-extending-mixin-methods">method advice beyond extending mixin methods</h3>

<p><code class="highlighter-rouge">override</code> in and of itself is not spectacular. But most functionality that extends the behaviour of a method doesn't process the result of the original. Most extensions do some work <em>before</em> the method is invoked, or do some work <em>after</em> the method is invoked.</p>

<p>So in addition to <code class="highlighter-rouge">override</code>, or toolbox should include <code class="highlighter-rouge">before</code> and <code class="highlighter-rouge">after</code> method advice. <code class="highlighter-rouge">before</code> invokes the behaviour first, and if its return value is <code class="highlighter-rouge">undefined</code> or <code class="highlighter-rouge">truthy</code>, it invokes the decorated method:</p>

<pre><code>let before = (behaviour, ...decoratedMethodNames) =&gt;
  (clazz) =&gt; {
    if (typeof behaviour === 'string') {
      behaviour = clazz.prototype[behaviour];
    }
    for (let decoratedMethodName of decoratedMethodNames) {
      let decoratedMethodFunction = clazz.prototype[decoratedMethodName];

      Object.defineProperty(clazz.prototype, decoratedMethodName, {
        value: function (...args) {
          let behaviourValue = behaviour.apply(this, ...args);

          if (behaviourValue === undefined || !!behaviourValue)
             return decoratedMethodFunction.apply(this, args);
        },
        writable: true
      });
    }
    return clazz;
  };
</code></pre>

<p><code class="highlighter-rouge">before</code> should be used to decorate methods with setup or validation behaviour. Its "partner" is <code class="highlighter-rouge">after</code>, a decorator that runs behaviour after the decorated method is invoked:</p>

<pre><code>let after = (behaviour, ...decoratedMethodNames) =&gt;
  (clazz) =&gt; {
    if (typeof behaviour === 'string') {
      behaviour = clazz.prototype[behaviour];
    }
    for (let decoratedMethodName of decoratedMethodNames) {
      let decoratedMethodFunction = clazz.prototype[decoratedMethodName];

      Object.defineProperty(clazz.prototype, decoratedMethodName, {
        value: function (...args) {
          let decoratedMethodValue = ecoratedMethodFunction.apply(this, args);

          behaviour.apply(this, ...args);
          return decoratedMethodValue;
        },
        writable: true
      });
    }
    return clazz;
  };
</code></pre>

<p>With <code class="highlighter-rouge">before</code>, <code class="highlighter-rouge">after</code>, and <code class="highlighter-rouge">override</code> in hand, we have several advantages over traditional method overriding. First, <code class="highlighter-rouge">before</code> and <code class="highlighter-rouge">after</code> do a better job of declaring our intent when decomposing behaviour. And second, method advice allows us to add behaviour to multiple methods at once, focusing responsibility for cross-cutting concerns, like this:</p>

<pre><code>const mustBeLoggedIn = () =&gt; {
    if (currentUser() == null)
      throw new PermissionsException("Must be logged in!");
  }

const mustBeMe = () =&gt; {
    if (currentUser() == null || !currentUser().person().equals(this))
      throw new PermissionsException("Must be me!");
  }

@HasAge
@before(mustBeMe, 'setName', 'setAge', 'age')
@before(mustBeLoggedIn, 'fullName')
class Person {

  setName (first, last) {
    this.firstName = first;
    this.lastName = last;
  }

  fullName () {
    return this.firstName + " " + this.lastName;
  }

};
</code></pre>

<p>Mixins allow us to have a many-to-many relationship between behaviour and classes. Method advice is similar: It makes a many-to-many relationship between behaviour and methods particularly easy to declare.</p>

<p>After using mixins and method advice on a regular basis, instead of using superclasses for shared behaviour, we use mixins and method advice instead. Superclasses are then relegated to those cases where we need to build behaviour into the constructor.</p>

<h3 id="wrapping-up">wrapping up</h3>

<p>A simple mixin can cover many cases, but when we wish to override or extend method behaviour, we need to either use the subclass factory pattern or incorporate method advice. Method advice offers benefits above and beyond overriding mixin methods, especially if we use <code class="highlighter-rouge">before</code> and <code class="highlighter-rouge">after</code> in addition to <code class="highlighter-rouge">override</code>.</p>

<p>That being said, subclass factories are most convenient of we are comfortable with hierarchies of superclasses and with using <code class="highlighter-rouge">super</code> to extend method behaviour. Subclass factories work best when we don't have a lot of behaviour that needs to be shared between different methods.</p>

<p>Method advice permits us to use a simpler approach to mixins, and makes it easy to have a many-to-many relationship between methods and behaviour, and it makes it easy to factor the responsibility for cross-cutting concerns out of each method.</p>

<p>No matter which approach we use, we find ourselves needing shallower and shallower class hierarchies when we use mixins to their fullest. Which demonstrates the power of working with simple constructs (like mixins and decorators) in JavaScript: We do not need nearly as much of the heavyweight OOP apparatus borrowed from 30 year-old languages, we just need to use the language we already have, in ways that cut with its grain.</p>

<p>(discuss on <a href="https://news.ycombinator.com/item?id=10801425">hacker news</a>)</p>

<hr>

<p>more reading:</p>

<ul>
  <li><a href="http://raganwald.com/2015/06/10/mixins.html">Prototypes are Objects (and why that matters)</a></li>
  <li><a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">Classes are Expressions (and why that matters)</a></li>
  <li><a href="http://raganwald.com/2015/06/17/functional-mixins.html">Functional Mixins in ECMAScript 2015</a></li>
  <li><a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">Using ES.later Decorators as Mixins</a></li>
  <li><a href="http://raganwald.com/2015/08/05/method-advice.html">Method Advice in Modern JavaScript</a></li>
  <li><a href="http://raganwald.com/2015/12/23/super-considered-hmmmful.html"><code class="highlighter-rouge">super()</code> considered hmmm-ful</a></li>
  <li><a href="http://raganwald.com/2015/12/28/mixins-subclass-factories-and-method-advice.html">JavaScript Mixins, Subclass Factories, and Method Advice</a></li>
  <li><a href="http://raganwald.com/2015/12/31/this-is-not-an-essay-about-traits-in-javascript.html">This is not an essay about ‘Traits in Javascript'</a></li>
</ul>

<p>notes:</p>

<div class="footnotes">
  <ol>
    <li id="fn:simplified">
      <p>A production-ready implementation would handle more than just methods. For example, it would allow you to mix getters and setters into a class, and it would allow us to attach properties or methods to the target class itself, and not just instances. But this simplified version handles methods, simple properties, "mixin properties," and <code class="highlighter-rouge">instanceof</code>, and that is enough for the purposes of investigating OO design questions.&nbsp;<a href="#fnref:simplified" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:fagnani">
      <p>Justin Fagnani named this pattern "subclass factory" in his essay <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">"Real" Mixins with JavaScript Classes</a>. It's well worth a read, and his implementation touches on other matters such as optimizing performance on modern JavaScript engines.&nbsp;<a href="#fnref:fagnani" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>

        </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t36" name="t36"></a><h1>36 : Compose me That: Function Composition in JavaScript</h1>
					<span class="ref-site">https://www.linkedin.com/pulse/compose-me-function-composition-javascript-kevin-greene</span>
					<div class="tutorial__content">
<div class="prose" itemprop="articleBody"><p>Source on Github:&nbsp;<a href="https://github.com/kevinbgreene/composition-tutorial" target="_blank" rel="nofollow noopener">Composition Tutorial</a></p> 
<p>Note: This article is the spiritual sibling of my previous post:&nbsp;<a href="https://www.linkedin.com/pulse/curry-me-partial-application-javascript-kevin-greene" target="_blank">Curry me This: Partial Application in JavaScript</a>. Both articles cover fundamental&nbsp;concepts for any functional programmer. If you're not familiar with currying I'd suggest reading that article first as we will be using curried functions here.</p> 
<h2>Are We Painting a Picture Here?</h2> 
<p>Yes, we are painting a picture and functions are the lines we draw. Function composition is a formalized way of thinking about something that is largely considered a good practice is software development, keep your functions short, single purpose and referentially transparent. Doing this&nbsp;makes your functions easy to test, easy to reason about and easy to document for others who will be using your code.</p> 
<p>Function composition is also directly a mathematical concept. In mathematics there is a composition operator, typically an empty circle (°). It should be an empty mid dot, but probably shows up here as a degree symbol. The circle between two functions means take the result of the function on the right and pass it as the argument to the function on the left. The composition of two functions is a new function. If we have some function A such that A(3) = 15&nbsp;and some function B such that B(15) = 22&nbsp;then some function C that is equal to B compose A (C = B ° A)&nbsp;would be a function that given 3 as argument would return 22 (C(3) = 22).</p> 
<p>Short, single purpose functions don't really do much, that's their beauty. So the not so surprising secret as to how we make them do interesting things is that we compose them. Complex functions are compositions of simpler functions.</p> 
<p>This function strips extra white space from a string. This function computes the distance between two points. This function finds the standard deviation of a&nbsp;list&nbsp;of numbers. It should be easy to describe what a function does. If you write a function and can't clearly describe what it is doing in a simple, declarative sentence you probably need to refactor that function into multiple functions, or step back and ask what it is you are actually trying to do. What you are trying to do can be described in a series of logical and declarative steps. We are dealing with computers here. At some point what you are trying to do needs to be translated into binary. Very often these steps will be your functions. Your application is the ultimate composition of these functions.</p> 
<h3>Wouldn't This be Easier to Describe with Examples?</h3> 
<p>Let's start simple. Say we want to create a function that takes a string and capitalizes every word in that string, what do we need to do?</p> 
<ol> 
 <li>Find the words in the string.</li> 
 <li>Capitalize the first character of each word.</li> 
 <li>Return the new string.</li> 
</ol> 
<p>Ignoring that we could do this fairly concisely with a regex (some of us, namely your humble narrator, suck at regexes), let's follow the steps and build this function.&nbsp;Something like this would do:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAcoAAAAJDdkZGYzNGY2LWZmOGYtNDMyZi05MjMyLTRkYTQ2NWVkZThkNw.png" width="640" height="333" draggable="true" data-bukket-ext-bukket-draggable="true">Nothing complicated. Each step follows logically from the previous. There is obviously some room for abstraction there though. There's a lot of implementation details in there that have nothing to do with the basic steps of what we want to do. The first thing we do is break the input string into an array of words. We have room here for a words function.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAiUAAAAJDY1YmI2YWVmLWYxMDItNGQ2OC05NzhjLTdlNGMzOTI5YWIyNg.png" width="640" height="216" draggable="true" data-bukket-ext-bukket-draggable="true">Which turns our titleCase function into this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAfdAAAAJDc4NGVkZWIxLTkyMTQtNDhiOC05YzYwLTY0MzdjYWE2NzZiMw.png" width="640" height="288" draggable="true" data-bukket-ext-bukket-draggable="true">Does our titleCase function really care what it takes to capitalize a word? No. It only needs to know the words are capitalized. We could then break the capitalization of each word out into its own function.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAiAAAAAJGY5NWY1MzBiLTEzODYtNDBkZS05MjlmLTRjYWRmMzRlNjYyZA.png" width="640" height="382" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Then it would follow to create a function that capitalized each of a list of words.&nbsp;The ultimate idea is to strip the titleCase function down into only the steps described in our high-level overview, stripping away the implementation details of those steps and abstracting the implementation into other functions that can be logically described&nbsp;in terms of those implementation details.</p> 
<h3>Hold on There Pokey, We're in Abstraction Hell</h3> 
<p>True, we haven't actually composed anything get. I would argue though that our titleCase function&nbsp;should really be a one-liner, a composition of even simpler functions.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAfRAAAAJGQ0NTJkNDJjLTI3OTMtNDEwOS04ZGNmLWEzMDA1MGJjY2MzNg.png" width="640" height="162" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Ok, so what's going on here? To start, let's look at this without the call to compose:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAd6AAAAJDRkYWJkZmM4LTk5YzItNDBiYy1hMzM0LTFkZjhjMDVjNGE5Nw.png" width="640" height="201" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>You've probably done something like this before, using a function invocation as the argument for another function. That is all function composition really is. We're just dealing with abstractions to make this idea more explicit.</p> 
<p>We can't make our own operators or infix functions in JavaScript, so compose is a function that takes some n number of functions and returns a new function that is the right to left composition of those functions. We'll look at an implementation shortly. In this case, the argument received by titleCase is some string that is given to the words function. Capitalize gets the result of the words function and join gets the result of capitalize. The return value of join is used as the return value of the composition.</p> 
<p>Back when we originally described what this function should do we had three steps. Here we have three functions that correspond to each of those steps. Find the words, capitalize them, return the new string (by joining the capitalized words). The three functions compose together to create our titleCase function.</p> 
<p>Alright, but what exactly do each of these three steps consist of? Our words function did a little more than just split on spaces:</p> 
<ol> 
 <li>Trim leading/trailing white space</li> 
 <li>Split string on spaces</li> 
 <li>Remove empty strings (extra spaces) from words list</li> 
</ol> 
<p>Three more steps. Another composition:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAeOAAAAJGIyN2FhZTY0LTE4MDYtNDZlYS04MGUwLTUxZGMyZjQxYjdmZg.png" width="640" height="165" draggable="true" data-bukket-ext-bukket-draggable="true">The trim and split functions here are simple helpers that allow us to call String.prototype.trim and String.prototype.split as normal functions.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAfBAAAAJDUwYTM4MjJlLWM2NTQtNGVhYS05ZjRmLWQ3ODY0ZTA2NWE4NA.png" width="640" height="165" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Split&nbsp;is a little more interesting in that it is curried. So split(' ') is a new function that splits on spaces:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAe4AAAAJGM5ZjlmZjU3LTE4YTgtNDU4Yi1hNzY2LTAyNDY3YWY4YTY0Yw.png" width="640" height="183" draggable="true" data-bukket-ext-bukket-draggable="true">It follows then that we could make a breakOnSpace function:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAdGAAAAJGNkODJhZGU1LTVkYTktNDA4Yy1iOWM3LWI0NDIwY2UyMjEzMw.png" width="640" height="167" draggable="true" data-bukket-ext-bukket-draggable="true">The removeEmpty function handles the case when we split on a single space if there are extra spaces in our string we end up with empty strings in our words array. We remove these empty strings from our words array. Maybe this isn't desirable in all situations, but it's a wrinkle we'll add to our implementation.</p> 
<p>For completeness, here is removeEmpty:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAhSAAAAJDFkNDQxY2IyLTE1NDctNGZlOC05N2ExLThiMjM1MmU1OWE2Yw.png" width="640" height="165" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p><em>Note: We'll skip the remaining two steps of titleCase (capitalize and join). Their implementations can be found in the linked source code.</em></p> 
<h3>TDD: It's Not All Puppy Dogs and Ice Cream</h3> 
<p>I write most of my JavaScript with heavy use of curry and compose. This allows and pushes me towards a few things. One is micro code reuse. The more of these small function I have, the more ways I can compose them to make more complex functions for use in whatever project I am working on. Two is that it changes the way I look at my code. I look at my code more and more with an eye of how I can abstract, simplify and reuse the code I write. Three is I am a big believer in TDD (Test Driven Development). Even if you don't strictly follow TDD at some point you need to unit test your JavaScript. These tiny functions are impossibly easy to unit test. Then, if my logic is sound, these tiny functions that are thoroughly unit tested are almost certain to work when I compose them together. If they don't work when I compose them together there is a higher level flaw in my reasoning about what a function should be doing, the steps it should be taking. Then once the composition is in place and unit tested I can then use that function in another composition that is more likely to work because its component parts have been correctly reasoned and unit tested.</p> 
<p>Writing unit tests can be a real pain. The easier it is to do the more likely we are to do it. When the logic you are testing is simple and well-reasoned it will be much easier for you to write test. Building functions up through composition forces your functions to be well reasoned because they are simply compositions of the steps they need to perform. Even when I'm code sketching with a larger problem I'm not immediately sure how to tackle I always go back to building it up from smaller functions that are easy for me to test.</p> 
<h2>So, How do we Make This Magic?</h2> 
<p>As I pointed out, function composition is probably something you've already done. You've probably used it a lot. Any time you've written something like this g(f(arg)) you've used function composition. However, if we want the composition of g and f to be a reusable function we need to wrap it in some function that accepts the argument for us.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAleAAAAJDIyNWE0ZjNkLWZiMjctNGJmYi1iMTkzLTAxZTZiNjQ2NjdmYg.png" width="640" height="72" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>There are certainly libraries that offer compose functions. Essentially the same libraries that offer curry functions. I'll list them again at the end. I at least like knowing how the magic works even if I'm going to use a library.</p> 
<p>The examples we looked at above both had 3 steps. We can make a function that takes three functions and composes them.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAlVAAAAJGQyOWNjNGFlLWUxOWEtNGM1Yi1iY2VhLWZiZjlhM2ZmM2FhYQ.png" width="640" height="270" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Obviously not ideal, but gets the job done.&nbsp;We would need compose functions for all the different numbers of functions we would like to compose together (compose2, compose4...).</p> 
<p>How do we make a generic compose function?</p> 
<p>What exactly does a generic compose function need to do?</p> 
<ol> 
 <li>Take some n number of functions</li> 
 <li>Return a new function that takes an argument and returns the result of calling the composition of those functions on that argument</li> 
</ol> 
<p>Well, we start like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAlgAAAAJDcwNmNkNGNmLWZkY2MtNGM1Zi04MDBmLWY2YTk4YjA5OGQ3Mw.png" width="640" height="240" draggable="true" data-bukket-ext-bukket-draggable="true">Using rest parameters it's easy to get the functions we need to call as an array. We return a function that accepts the argument. How do we apply that to our list of functions?&nbsp;If we step back and don't think about function application, just what do we have? We have a list and need to return a result. Don't we have an array method that does something like that? Yep, sounds like a reduce:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAk7AAAAJGE1NzQzNDRmLThkNjMtNDQ3OS1iZGFiLWE1ZTdkMWYzMjI5YQ.png" width="640" height="271" draggable="true" data-bukket-ext-bukket-draggable="true">The argument of the composition is the initial accumulator of reduce. The new accumulator is then the result of applying the next function to the accumulator.</p> 
<p>Why do we use reduceRight? Why not apply the functions left to right? We could make it work either way. Keeping right to left composition keeps us closer to the mathematical roots of function composition. It also makes things read a little more clearly if we immediately invoke a composition:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAe2AAAAJGI0ZDk0YmFjLTU2NWItNGY4Yi1iYjg0LWVkMzE0NjE4MmUwMQ.png" width="640" height="74" draggable="true" data-bukket-ext-bukket-draggable="true">It's a little more clear that 'this is a test' is being passed first as an argument to words. Right to left implies the flow of data through the composition.</p> 
<h3>Library Implementations</h3> 
<ol> 
 <li><a href="http://ramdajs.com/0.21.0/index.html" target="_blank" rel="nofollow noopener">ramda.js</a></li> 
 <li><a href="https://lodash.com/" target="_blank" rel="nofollow noopener">lodash.js</a>&nbsp;(calls their implementation flow/flowRight)</li> 
 <li><a href="http://underscorejs.org/" target="_blank" rel="nofollow noopener">underscore.js</a></li> 
</ol></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t37" name="t37"></a><h1>37 : Curry me This: Partial Application in JavaScript</h1>
					<span class="ref-site">https://www.linkedin.com/pulse/curry-me-partial-application-javascript-kevin-greene</span>
					<div class="tutorial__content">
<div class="prose" itemprop="articleBody"><p>Source on Github: <a href="https://github.com/kevinbgreene/curry-tutorial" target="_blank" rel="nofollow noopener">Curry Tutorial</a></p> 
<h2>Currying vs Partial Application</h2> 
<p>Currying and partial application are related concepts and the terms are often used interchangeably. It boils down to this, we have some function F(a,b,c) that has&nbsp;three parameters, but we don't want to apply all three arguments at the same time. Why on earth would we want to do that? Settle down, we'll get to that.</p> 
<p>The prototypical example of this is an add (+) function:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAfMAAAAJGY2ODljNjEzLTk3YTYtNGEyMC04N2VmLTQ2ODhiMTNiNzZkYQ.png" width="640" height="220" draggable="true" data-bukket-ext-bukket-draggable="true">If we were to partially apply add, we could do something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAiPAAAAJGQ0MzEzMWZlLTkyYjEtNGNiYS04Njk0LWE4ZjE1ZjEzNDI1Mw.png" width="640" height="150" draggable="true" data-bukket-ext-bukket-draggable="true">By partially applying the function we get back a new function with the 'a' parameter bound to the number 1. So we have a function that is just waiting for a 'b', a function that will add 1 to any number given to it. This gives us a great little semantic helper function we can use over and over again.</p> 
<p>Partially applying? What about currying? As I said, these are similar concepts. To illustrate the difference lets look at a slightly different function:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAlxAAAAJDM2OTcyODEyLTg5ZjktNGZiOC1hOWU5LWIwODA3ZDhhNzk5NQ.png" width="640" height="213" draggable="true" data-bukket-ext-bukket-draggable="true">Partial application generally refers to the ability to (surprise) partially apply a function. Just give it less arguments than it requires, as a result you are given back a new function that waits for the remaining arguments.</p> 
<p>Curry can be thought of as a more specific case of this. If a function takes three arguments and is curried it is really three functions. Each function takes one argument&nbsp;and returns a new function that takes the next&nbsp;argument until all arguments are received then it returns the final result. Curried functions only ever take one argument.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAeBAAAAJGQxNjg5ZmMwLWM0MjctNDA0NC1iYzNkLWY3OWQxZGJiNzNmNA.png" width="640" height="208" draggable="true" data-bukket-ext-bukket-draggable="true">Applying two arguments to a curried threeSum returns a result dependent on implementation. It may throw an error, or it may ignore the second argument. If it ignores the second argument in our example we are left with essentially this: threeSum(2)(4), a function waiting on a third argument to bind to 'c'.</p> 
<p>The difference between partial application and currying may not be practically too important, but I make the distinction as a note that there is technically a distinction. In practice you will often see curry used to refer to partial application. Later, in these very typed words, I will slip into that myself.</p> 
<p>Hey, but I know a little JavaScript. I know the functions we've written so far really only do something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAfSAAAAJGI1NjBlOWE2LWQ3MGYtNDJlNy05MDk2LWExZGY4ZGFlNTBkNQ.png" width="640" height="149" draggable="true" data-bukket-ext-bukket-draggable="true">True. NaN is not a function, information for life.</p> 
<h3>Using Function.prototype.bind</h3> 
<p>Native JavaScript already gives us a tool to perform partial application. Function.prototype.bind is a very useful bit of business. It allows us to bind a context and&nbsp;arguments to a function. The context bit can be cool, but we're going to concern ourselves only with binding arguments. Because of this, I will always use null as the first argument to bind.</p> 
<p><em>Note: If you are unfamiliar with Function.prototype.bind I suggest checking out the MDN documentation before continuing:&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="nofollow noopener">Function.prototype.bind</a>.</em></p> 
<p>If we use bind to perform partial application, we end up with something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAi4AAAAJGIyZWZiMjI2LWY0N2YtNDQyYi1iNDI2LWI2MDY5MDYwMDNlNw.png" width="640" height="203" draggable="true" data-bukket-ext-bukket-draggable="true">The first argument (null) is bound to the context of the function. The following arguments are bound to the parameters of the function. If you've used React, you may have used bind to pass arguments to event handlers. Here we are using bind for partial application, to create new functions that are in essence more specific versions of the original function. This is the value of partial application, a subject we'll return to shortly.</p> 
<p>Function.prototype.bind always returns a new function and always takes&nbsp;as many arguments as we care to pass to it. This would be perfectly fine:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAd4AAAAJGU1YjRiNGY0LWRkY2MtNGFhMS1hZmQ0LTRmM2IyZDhjZTY2Yg.png" width="640" height="91" draggable="true" data-bukket-ext-bukket-draggable="true">In this case only the 0 and 'henry' were bound to parameters. The add function only took two parameters so the first two arguments bound to add were bound to those parameters. Then on function invocation (someJunk('haha')) we were returned '0henry'. All the other arguments&nbsp;we gave to add were&nbsp;just thrown away.</p> 
<p>This API is pretty clunky if our main want is to take advantage of partial application. Things were nicer in our theoretical API earlier where add just knew what to do based on the arguments it had so far.</p> 
<h3>Going Our Own Way</h3> 
<p>How would we implement this ourselves? I want functions that allow me to partially apply them, always giving me back new functions until I have provided all the arguments, then I want a result.</p> 
<p>Starting simply, if we were to just write our add function as a curriedAdd function:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAf6AAAAJDk1ZTkzZDI3LTU0ODYtNDdlNy1iOWM3LTNhYWE1ODM5NTMyNA.png" width="640" height="218" draggable="true" data-bukket-ext-bukket-draggable="true">This is a true curried function. It is a composition of two functions that each take one argument.</p> 
<p>Binary functions are incredibly common.&nbsp;Say I want to take advantage of currying, but I don't want to go back and rewrite all the binary functions I've written before. I want something like bind that will allow me to transform those binary functions into curried functions. Write a function that takes as its argument a binary function and returns a curried version of that function.</p> 
<p>It would look something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAiyAAAAJDk5YzQ2NjNmLTFhMTAtNDA3NC1hMDE5LTFiZTQwYzhmOTA1Ng.png" width="640" height="238" draggable="true" data-bukket-ext-bukket-draggable="true">Yes, very similar to our curriedAdd function. It takes a function and returns a function that takes the first argument. When applied that function returns a function to take a second argument. When that function is applied we finally get a result. Now we can rewrite our curriedAdd function like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAf9AAAAJDA3N2I1YzBiLTQ0ZGQtNDU0NC05NGIwLThiMDYyZjc3NTI5Ng.png" width="640" height="99" draggable="true" data-bukket-ext-bukket-draggable="true">Okay, so what do I do if I have a function that takes three arguments, or four? Do I really want to pass all the parameters separately every time? If we're going to take advantage of these patterns in our daily code we are probably more interested in partial application than true currying. We also want a generic version of our binaryCurry function that can turn any function into a function that can be partially applied.</p> 
<p>So, let's write this function. An obvious requirement of this is we need to know how many arguments the function we are transforming expects to receive. I don't see this used often, but functions have a length property which is the number of declared parameters. Like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAesAAAAJGI0OTcwM2UzLTBkMDQtNDFjYy1iMzIwLWJiYWE5ZmM1YzdiZg.png" width="640" height="120" draggable="true" data-bukket-ext-bukket-draggable="true">Note:&nbsp;This doesn't take into account arguments a function may use by accessing the arguments array-like thing we shouldn't really be using anyway.</p> 
<p>Using ES6 rest parameters and the spread operator, writing a generic curry function is rather concise.</p> 
<p><em>Note: Rest parameters allow us to receive a variable number of arguments in our functions. Instead of using the arguments object we get an actual array of arguments that weren't otherwise bound to parameters. For a more detailed description of rest parameters MDN is again the spot:&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="nofollow noopener">Rest Parameters</a>.</em></p> 
<p><em>Note: The spread operator allows us to take an array and very literally spread it out, as in the case where we have an array and want to pass it to a function that takes multiple arguments. Hey, that's what we used to use apply for. Yes, that's what we used to use apply for. Again, here's MDN:&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="nofollow noopener">Spread Operator</a>.</em></p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAkDAAAAJGIyYWNkNjZjLWVkODAtNGFmZi1hMzhhLTNhZDkyOTFlZTNjNw.png" width="640" height="588" draggable="true" data-bukket-ext-bukket-draggable="true">What happens here? The first time this function is called it only expects one argument, a function to curry (to create a new function that can be partially applied). The args parameter will probably be an empty array on first invocation, unless you want to bind any arguments to this function from the beginning. We save the arity (number of arguments it expects) to a local variable. We then return a function we define inside the curry function. We call this function 'curried' to indicate this is the curried function. Yes, yes, the author is an idiot. Moving on. When this function is invoked we concat the new args2 array with the old args array and check if we have received all the arguments yet. If we have, we apply the original function and return the result. If we have not we recursively call the curry function, passing along all the new arguments which puts us back in the original position, returning the curried function to await more arguments. On this second call (and all future calls) to curry the args parameter will be all the arguments we have received so far. New arguments from the client will be bound to args2 and concatenated with args to form locals.</p> 
<p>Play around, test it. Try to solve the problem for yourself. We now have a generic function we can use to transform any function into one that can be partially applied.</p> 
<h2>Subclassing a Function?</h2> 
<p>Currying and partial application are tools like anything else. Their value comes in the form of being able to reuse more code. You can write functions in their&nbsp;most generic form and partially apply them to create functions suited for a specific situation. I've had the most success in explaining the concept to people new to it by describing it as subclassing a function. Most programmers are familiar with the idea of a generic base class that is subclassed for a given situation. Thinking about the abstraction in those terms will probably give you the best idea of what the value is.</p> 
<h3>Can We Have Some Examples?</h3> 
<p>Sure, let's look at a couple situations where using partial application can help us write a little cleaner code. These examples will be simple, but should get you started.</p> 
<p>First, let's write a function to help us test the length of given objects. Not a terribly complex task, but something that's fairly common.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAczAAAAJGEzNWM4YjY3LTk2ZWQtNDBiNS05YWYxLTI3YmQwZTY4NjExMg.png" width="640" height="223" draggable="true" data-bukket-ext-bukket-draggable="true">Simple enough. It returns a boolean letting us know if a given object has a given length. Because this function is curried we can do something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAl1AAAAJDZlNzdmOGIxLTVkYjQtNGNiOS05M2Q5LTEwZGUzYmVkMDk5Mg.png" width="640" height="200" draggable="true" data-bukket-ext-bukket-draggable="true">Because of partial application hasLength(15) returns a new function that waits on the object to test. The array filter method uses this new function as it iterates over the array, on each iteration passing the second argument&nbsp;to hasLength, which upon getting its second argument runs the test and returns a boolean. It makes filter a little more concise. It makes our code more semantic, thus making it a little easier to read. No giant gains, but we're just getting started. We could make this even a little more self-documenting by doing something like this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAeEAAAAJDNhZDg3Y2FmLTVkOGMtNDA3My04NGQ3LTE1NWY5OWM2NjUxZg.png" width="640" height="212" draggable="true" data-bukket-ext-bukket-draggable="true">This is even more code, but illustrates the kind of things you can start doing with utility or helper functions to make them a little easier to read and to make many functions that all use the same code by writing the original (hasLength in this case) in the most generic form, allowing us to create new functions for more specific situations.</p> 
<p>Something else you may want to do is test if a given DOM element matches a given selector.</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAg3AAAAJGE2NDA2OWE0LWY0NTctNDE3MS1iMTIwLTI5ODQzNzBjMjdmZg.png" width="640" height="514" draggable="true" data-bukket-ext-bukket-draggable="true">You'll start to notice. If you are going to take advantage of partial application with your functions, the order in which the parameters are defined restricts how the function can be used. Here, I want the selector to be argument I partially apply to make my more specific function. I want to write these tester functions I can use on any element. If the element was first I could only use this function on one element, probably less useful, but it depends on your use case.</p> 
<p>And to use this:</p> 
<p><img class="center" src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAj2AAAAJDhmZGM2ZjkxLTk3MjAtNDE1Ni1hYzAwLWE4NzcwMzc0OGQ2MQ.png" width="640" height="192" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<h3>Implementations?</h3> 
<p>We've seen how to use bind to perform partial applications. We've seen how to build our own function for creating functions that can be partially applied. However, you really want someone else to deal with the implementation for you. As mentioned in the comments there are libraries that provide curry implementations.</p> 
<p>Some notable libraries:</p> 
<ol> 
 <li><a href="http://ramdajs.com/0.21.0/index.html" target="_blank" rel="nofollow noopener">ramda.js</a></li> 
 <li><a href="https://lodash.com/" target="_blank" rel="nofollow noopener">lodash.js</a></li> 
 <li><a href="http://underscorejs.org/" target="_blank" rel="nofollow noopener">underscore.js</a>&nbsp;(which calls its implementation 'partial')</li> 
</ol> 
<h2>Conclusion</h2> 
<p>Using partial application to reuse code probably won't drastically change things for you in your daily work. However, one of the things we are constantly doing as developers in finding ways to reuse our code and not write the same thing more than once. Something else we all do at times is write functions that are way too large and do way too much. We just get something working. Then, having a clearer picture of what we should do, we refactor that function into several functions, each performing one task. Often while doing this we find pieces of code that are generic, that are performing micro computations that aren't really tied to this specific use case. These smaller computations can often be handled by libraries, or can be moved into utility packages within our application, keeping our main application logic cleaner. All of these situations bring opportunities to take advantage of tools like partial application to build abstractions we might not have seen or considered without this tool in our chest. Like any tool, as you use it more you will become better at wielding it and will change the way you write code as you learn to see abstractions you didn't see previously.</p> 
<h3>Further Reading:</h3> 
<ol> 
 <li><a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="nofollow noopener">Currying on Wikipedia</a></li> 
 <li><a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="nofollow noopener">Partial application on Wikipedia</a></li> 
</ol></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t38" name="t38"></a><h1>38 : Functional Data Structures in JavaScript: The Basics</h1>
					<span class="ref-site">https://www.linkedin.com/pulse/function-data-structures-javascript-basics-kevin-greene</span>
					<div class="tutorial__content">
<div class="prose" itemprop="articleBody"><p>Source on Github: <a href="http://github.com/kevinbgreene/functional-data-js" target="_blank" rel="nofollow noopener">Functional Data Structures</a></p> 
<p><br></p> 
<h2>Once Upon a Time</h2> 
<p>When I was in college I had no interest in thinking about the future, so I was an art major. I did however have an interest in computers and technology so for an elective I took an intro to computer science course. I honestly don't remember much about the course. It was years later that I returned to programming. You know, gave up on my hopes and dreams and got a real job. The thing that stuck with me from the course was recursion. It was early in the semester and the instructor was demonstrating loops by finding the nth Fibonacci number (cringe). He then showed the recursive solution.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAdIAAAAJDEyNjliY2VlLWJjZDktNGM3Mi04ODAxLTAzODBjYTIxMTM1OA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Nothing special, but nice. To my young art-student brain the elegance of recursion was very pleasing and this idea stuck with me. So, years later, when I returned to programming I was very interested in this idea that had stuck with me. That recursion thing was nice. I want to know more about what can be done with that. How do I break large problems down into small problems so I can solve them with recursion?</p> 
<p>A lot of the beauty of recursion comes from how each function call maintains its own state, eliminating the need for temporary variables. If we look at an iterative solution to the same problem we find the need for multiple variable assignments.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAknAAAAJDcwMmZhM2VmLTAzMmYtNGVjOC1iZDIxLThmMzRmZWNiMzdkZA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>This could be reduced, but this illustrates my point. In order to maintain the state of our computation we have to create additional variables. The recursive solution just used the arguments passed into the function. This is the beginning of how we can persist data using only functions.</p> 
<p>When we think about functional programming languages immutable data is one of the things we associate with them. What makes functional data structures immutable? Does the data have to be immutable? How are they different than the data structures we are used to using? A lot of these questions really don't matter practically when you're writing programs. It matters if data is mutable or not. It doesn't matter how it gets that way. In JavaScript we have Object.freeze. We can make immutable data if we want. All data in our programs is really just the location of some bits in memory. Those bits can always be changed. The lower level the programming language you're using, the more you have to be concerned with the specifics of managing those bits and their location. What we will be exploring here is storing data in functions.</p> 
<p>This is a good subject for a book. Actually, the inspiration for this post was translating the Standard ML examples from Chris Okasaki's book <a href="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504" target="_blank" rel="nofollow noopener">Purely Function Data Structures</a> to JavaScript. We'll see how far I want to take this post. I'll probably cover some basic structures, then next week or next month write another post about more complex structures. For now we'll cover numbers, booleans, tuples, lists and binary search trees.</p> 
<p><br></p> 
<h2>Church Numerals</h2> 
<p>A lot of the ideas that form the basis of functional programming languages are derived from lambda calculus. The lambda calculus is a model for computation. If you are interested in functional programming but unfamiliar with lambda calculus I suggest to check it out. I'll include some links to articles and books later. The key idea (specifically in untyped lambda calculus) is that the only data structure we have is a function. Actually, the only piece of syntax we have is a function and the argument bindings to that function. No numbers, strings, lists, conditionals, loops... etc. If you need these things you have to build them yourself with functions. We're going to loosen these restrictions a bit as we go, specifically we are going to use conditionals, but for now let's look at how we might do useful things with only functions.</p> 
<p>How can we do things in an environment that doesn't even have numbers? When we talk about the existence of numbers what we are really talking about is the ability to count some occurrences of a thing. With our given limitations the thing we have to count are functions. Specifically what we are going to count is the number of applications of a function. If a given function isn't applied at all that is 0. If it is applied once that is one. For any number n the equivalent number to us is the nth composition of some function fn with itself.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAfyAAAAJGJlYzY2YTMxLWQwN2EtNGE5Yi1hZmZiLTQ4MTcwNmI3ZTVjMw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>This function takes a function "fn" and some argument "x". The function is applied to x once, thus One. Numbers expressed in this fashion are called Church numerals after Alonzo Church, who introduced the lambda calculus. If this is one what then is Zero?</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAd2AAAAJDBhYjFiOTgyLTUxMWMtNGZmNC05YWZhLTEyZDllNzRkM2EzMA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>The same signature, but the function isn't applied. Moving along we come to Two.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAevAAAAJGY1YWRmMTM5LTdhMWYtNDk4OS1iYzc3LTIzYjllYTdkYTZmNw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Or we call the function fn one extra time on One:</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAiRAAAAJDgxOGQwNGE2LTZjOTQtNDJkYi1hYmEzLWMwNWU1Mjk2ODQzZA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>This leads us to a function to increment any Church numeral:</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAgJAAAAJDg0MTZhOTBkLThkMjktNGVmZi1iZDRiLWU1MGY0ZGIxYWQ1ZA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Now we can write numbers in terms of the number that came before them.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAj8AAAAJGI3YmRiMmFmLWNhYzktNDdkOS05ZmRiLWU5NDdiZTdkZjU0OA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We're placing artificial limitations on ourselves by using only functions to express data. It would be nice to at least have a way to check our work, maintain our sanity and see these things as the Arabic numerals we are used to.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAgvAAAAJDY5MDQ2M2FiLTUzYmMtNGVjZC04NTVmLTE5NWJkMzM5OTczNA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>One of our numbers is just a function that takes two arguments. If we apply these functions correctly we can retrieve the corresponding Arabic numeral. By using 0 as the initial argument for the function we can keep track of how many times one of our numbers call its function. The function we then pass in as the first argument is an accumulator that just needs to increment the number it receives and pass it to the next function invocation.</p> 
<p>If some number n is just a function representing the nth composition of some function fn, how do we express addition?</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAjwAAAAJGJhNDk2MjFjLWYwZWUtNDIwYi1hNGJlLWJkMjY5YTIwN2Y2Ng.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>When this function is applied n calls fn n times and m an additional m times resulting in the addition of m and n.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAmJAAAAJDY2MGU2NGEzLWFhN2YtNGEwNi04ZWJiLTVhMmRjN2UwMzZkYQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We will return to numbers shortly and learn how to perform more operations on Church numerals. It will help to introduce a few more concepts first.</p> 
<p><br></p> 
<h2>Booleans</h2> 
<p>Booleans are where things start to get a little interesting to me. The patterns we start exploring with booleans are going to be the patterns we use to express the rest of the data structures we're going to look at. They also start representing patterns that could actually be used to build useful data structures.</p> 
<p>We have two potential values for booleans. That's it. We know what they are ahead of time. We know logically what they represent. A boolean is really just a fork in the road. Either one thing or another.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAg8AAAAJGNjMGEyMDg2LWIyZDgtNDQ4ZC04NTg5LTEyZjQzZjAzMjc0OQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>An operation that was consuming one of these booleans would call the function with two values and would know wether the boolean was True or False based on the value returned.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAixAAAAJGE5ODE5ODc0LTQ1Y2YtNDNjNi1iZWE4LWFmMDAzZGU2ZWQ0OA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>In essence our boolean is its own if/else. If it's true the first argument is used, else the second argument.</p> 
<p>We could perform a logical NOT, reverse the value, simply enough.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAhjAAAAJDkzODY4Y2JjLTJmNDUtNGQ0NS04NjMwLTRhNGZlYWE2OWUxNA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If this function is given a True it will return the left value of False and if given a False will return the right value of True. We can follow this up with logical AND.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAc8AAAAJGVlYjM5YjY4LTJjZGMtNDc4MC1iZjNjLWVjZWU1YTM5Yzc4Nw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If the leftBool is a True the value of rightBool will be returned as the value of this function. It will evaluate to true only if both are true. If leftBool is False the value of leftBool will be returned as the value of this function.</p> 
<p>Logical OR follows very quickly from this.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAktAAAAJGI2MDlhMjQyLTg4YTctNDk4Zi1iODczLTdjNTU1ZDRjNTMwNA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If leftBool is True leftBool is returned, otherwise we return rightBool. This function returns True if either value is True.</p> 
<p><br></p> 
<h2>Pairs</h2> 
<p>Let's start persisting arbitrary data into functions. If I wanted to persist two values in a pair I would expect that to look something like this:</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAfkAAAAJGRhYTM3ZWJlLWM5YTgtNGNmMy1iMjE5LTc4YzhmYzdhMWY1Nw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We know we are only persisting data as functions. If we pass two values to a function 'Pair' those values will be available to the scope of that function.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAhiAAAAJGJmMDA3OTQ5LTE1NDMtNDQzZS1hNjZiLTM2MmEzZGU0NmUxYg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>The two values 'left' and 'right' are now bound to the scope of this function invocation. How do we retrieve those values later? We return a function that gives us access to this scope.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAg-AAAAJGRiZjk5MjlkLTViMTItNGM0MS1iNGU3LTRkYzZkNWVlZWEwYQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Now the value we receive from calling Pair is a function that gives us access to that inner scope. We invoke this returned function with a function that takes two arguments, the two values we gave to the Pair function.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAlGAAAAJDg4MzY0ZGI0LTljZDAtNGExMC05Njc1LTViYmEyYTk4OWRhZg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We say that the function destructures the Pair because it pulls it apart into its component values. This is somewhat similar to how destructuring assignment works in JavaScript.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAiRAAAAJDI0MmI4ZmFhLWY0YjItNDQwYy1hMzBlLTI1Y2FkMTE3OWFkMQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We can use destructuring to create functions to retrieve the first and second values of the Pair.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAePAAAAJGRiNmViYzI0LTFlZjgtNGEzMy1hMzY1LTI2OTEyM2ExNWQ0NQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p><br></p> 
<h2>Lists</h2> 
<p>Lists follow naturally from Pairs. In our implementation of Pairs we knew exactly how many values our data structure would handle. It would hold two, no more, no less. With Lists we need to handle an arbitrary number of values. The data structure we are actually going to implement is a linked list where a node in our list holds two things the value at that position and some representation of the remainder of the list.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAh0AAAAJGU4MGY2NTc0LWNkYzYtNDMxOS1hYjkzLTJmZmFhNDFmZTUzMA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Hmm, this is identical to our implementation of Pair. This isn't quite going to be good enough. What do we do when we do when we get to the end of a list? How do we represent there is no more list, or that we have an empty list? Do we just let the destructureNode function fail? No. We add a special value to represent the empty list. This is typically called Nil.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAdlAAAAJGQ2N2ZjOTM5LWYwM2QtNDdlOC1iMGIzLWY1ZmEwOTJlOTE2Yw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Now we can also represent the end of a List as Nil. If we're looping through a List we can make a recursive call in the destructureNode function and short-circuit the recursion when we hit the end of the List in our destructureNil function.</p> 
<p>The key thing to remember here is head is a value our list is holding and tail is another List, specifically the remaining List after this node.</p> 
<p>It's easy enough to build on this and write functions to retrieve the head and tail of our Lists. This is almost identical to the first and second functions for Pairs. The only difference is we need to handle the special case of Nil.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAglAAAAJDVlMDI3MGY2LTc4YzUtNDNhOS1iOTgwLTFhZTllOWU3ZjQwNw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Before moving on, let's write a function to transform one of these Lists into a JavaScript array to make it easier to check our work.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAg-AAAAJDY1M2QwYjcwLWJmYjAtNDEzZS04ODEwLTY0Y2RkMDA0NTgzMQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Let's do something more interesting. Let's concatenate two lists. Our data structures are immutable, so we won't be modifying either List in order to perform the concatenation. What we will do is copy the first List and use the second List as the tail of our copy. This will leave our second List in tact, but we will save ourselves from unnecessary copying if the two Lists just share those nodes.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAfuAAAAJDJlYzQ0ZjhlLWQ4N2ItNGE4Yy1hNDc4LWY0Y2YxOGI4NTZhMg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>When our recursion reaches the end of the first List the destructureNil function is used which just returns the second List which is then used as the tail of the last node in our copy.</p> 
<p>I'll take a moment to point out something obvious here. The List constructor is a prepend function.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAeIAAAAJDBlZDZjZmEzLWZkYjEtNGQ0NS1iMjc4LTQ0YjBlYWMzZTlkYg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>The prepend operation is performed in constant O(1) time. Our concat operation however must recurse through every node in the first List, meaning concatenation takes time proportional to the size of the first List O(n). In many functional languages this operation is referred to as 'cons'. There really is no List constructor. Every List is just created by prepending to the Nil value.</p> 
<p>How about appending to a List? Appending to a List is going to be another O(n) operation. We are going to copy the List and just add one extra node to the end.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAdIAAAAJGE3YjhhZWNlLTYzYmItNDMwNS1iYWIyLTJmNzViYWNjZmJmMg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>To make a copy of a List we were using a prepend operation. Could we then use our new append operation to make a reverse copy?</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAh0AAAAJDRlOTk0ZTQzLWY5ZWQtNDFkNC1iOGM1LWQ4NmNlZWM3YTc1ZA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>What other operations do we commonly want to perform on lists? Getting the nth value of a List is pretty common.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAfQAAAAJDVhMTkwY2Q4LTliNzgtNDVkMC05NDU0LWJjYWNjZjUzODM0NA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>I told you, we would eventually get around to using conditionals. We've been able to do a lot with only functions. We could certainly do more, but I'm not that masochistic. Simple enough, we just keep decrementing n until it reaches 0 then we know we're at the correct node. If we get to an Empty node before n reaches 0 we know the requested index is out-of-bounds.</p> 
<p>What follows quickly from this is updating the node at the nth index. Because we are again non-destructively updating our Lists, we are creating a new List with the given node updated. We accomplish this by copying every node until we reach the given index and then use any remaining nodes as the tail of our new List, similar to how we performed concatenation.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAl9AAAAJDE2YjFiNzAzLTI5NmEtNGMyZC05NDAwLTY5YjkxYTc1YmJlYQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>We could obviously fill out all of the common functions for Lists. However, I think we get the idea. All the operations follow the same patterns. In the included source code I have implementations for map, filter, foldl and foldr if you want to take a look.</p> 
<p><br></p> 
<h2>Binary Search Trees</h2> 
<p>Binary Search Trees are going to be the last data structure we look at in this post. Following on from Pairs and Lists we are just going to be adding a little bit of complexity to what we have already seen. A node in a List is singly-linked to the rest of the List. A node in a binary tree is doubly-linked. All nodes in the left sub-tree have values less than the current node and all values in the right sub-tree have values greater than the current node. For this implementation we are going to say all values in the left sub-tree are less than or equal to the value of the current node. As with Lists we are going to have a special type to represent an empty tree.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAgwAAAAJDFlMTc5ZTBhLTAxZTctNDkyMS1iNDJiLWRmMGQ2ZTE1MTVkMg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>As usual, we are going to make a function to turn our Tree into a more easily inspectable JavaScript object.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAf7AAAAJDU2ODQ0NzQzLTIxYjgtNDA4Ni05OTg5LTlkMTM5YmFiZDdkNg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>The first thing we are going to want to do with our Tree is to insert values into it. Like Lists, Trees are built by inserting elements into the empty Tree. With binary search trees new elements are inserted as a new leaf. We just need to find the correct place to insert the new leaf. We compare the value of the new value to the value of the current node and move left or right depending on if it is smaller or larger. Once we find an Empty node we have a place to insert the new node.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAhYAAAAJGMyYzI2ZjdkLWZkYjYtNDk0ZC1iMGM2LTkwMzA5Y2ZiYmU1Ng.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>You will notice this code copies nodes on the path to the new node. Nodes that are not on the insertion path are shared with the new Tree, returned as a result of this insertion, and the old Tree. Just look at the first conditional in the destructureTree branch. The value to insert is less than or equal to the current. The right sub-tree is going to go unaltered. It can be shared. The inverse is true if the value is greater.</p> 
<p>The next thing we want to do with a binary search tree is to search. We will start with the simplest search. Just find the minimum (or maximum) value in our Tree. In the case of finding the minimum value we just keep moving left until we reach the end. We do so by recursively calling the min function on the left child node until we reach a left child node that has an empty left child. If you were to write this code in an object oriented language you would check for an empty left child node by checking a property on the node object. Something like node.left === null. Here we need to destructure the left node to see if it has an empty left child. If it does have an empty left node we return the current node we're on, else we recurse into the left node.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAgrAAAAJDNlYzdhMTdhLWNlZmQtNDU1My1iZjlmLWM5ZDQ5M2MyOWE2Mg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>This code is easily adapted to finding the max by replacing the recursive call with the left node to a recursive call with the right node. I'll leave that out.</p> 
<p>How about more generic searching? I want to know if a given value is already in the tree. This follows fairly directly from finding the min or max. Our code just needs a conditional to know to move left or right based on the search value relative to the current value. If we come to an Empty node we return false, otherwise we return true when we land on a node with a value equal to our search value.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAinAAAAJGIyYjZiMzVlLTIwMTEtNGZiMC05MjIxLTMwNjVhNmJmOWEyNA.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Deleting values is always where binary search trees get a little hairy to implement. However, in a functional data structure deleting values is much more straight forward. Deleting is much more straight forward because we don't have to worry about maintaining the mutated state of our data structure. We are copying all the pieces we are altering. We can be more declarative about saying, 'This is what this structure should look like now'. We will start with removing the minimum value in a Tree. We just need to move left until we reach a node with an empty left child. We then replace that node with its right child.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAe9AAAAJDg1MDVkYTQ4LTUzNjgtNGIxYS1hZjVjLWZkNDA5YWNhN2MyMw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If you look back at our code for finding the minimum value you'll see that this is almost identical. We are just constructing our new data structure as we recurse down to the minimum node. Once a node has no left child, which we know when the inner destructureEmpty is called, we just return the right node. If the initial Tree we pass in is an Empty tree we just return Empty.</p> 
<p>Following on from this we can write a function to delete an arbitrary value from a Tree. This again looks very much like our generic search function, we just build up a new Tree as we recurse down, moving left or right depending on if the value to remove is less than or greater than the value of the current node. However, what happens when we find the node to remove? We need to fill in the hole left by removing a node.</p> 
<p>To keep our remove function clean, we write a helper function to replace the removed node. We replace the removed node with the minimum node in the right sub-tree of the node we are removing. The minimum node in the right sub-tree is guaranteed to not break the correctness of our tree. It will be greater than all of the nodes in the left sub-tree of the node we are removing and it will be less than all of the nodes in what remains of the right sub-tree of the node we are removing. We take the value of the minimum node in the right sub-tree and create a new node to replace the node we are removing. This new node will use the left sub-tree of the node we are removing. Again, sharing this sub-tree with the tree we are deleting from as we are leaving it unaltered. Our new node will also use the right sub-tree of the node we are removing. However, for the right sub-tree we will be using a copy. We need to remove the minimum so we are not including the same node twice. Luckily enough we just made a removeMin function.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAlIAAAAJGM1MDhmZTMxLTIxODQtNGUzZS04YzRhLTE5ODZjY2IwOGUwZg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If you have written this in an object-oriented language, you will notice this is much less code. At each step we are able to be very declarative about what we want our tree to look like at that point.</p> 
<p>In our functional implementation of Lists we noted we were actually implementing a linked list and many of our operations took time proportional to the size of the list. For random input functional binary search trees will still offer logarithmic inserts, deletes and searches. I'm going to follow this post up fairly soon with a look at functional balanced binary search trees, specifically red/black trees. But this was our last data structure for today.</p> 
<p><br></p> 
<h2>A Return to Arithmetic</h2> 
<p>The first thing we covered were Church numerals. Almost certainly the least practical thing we looked at, but we're going to close for today and look at how we can do subtraction on Church numerals. This is an example of how far you can take computation with nothing more than functions. Once we can represent numbers and the operations on numbers we can support anything.</p> 
<p>We are going to solve the problem of subtraction by creating a decrement function and then applying it some n number of times. If we define a number in Church numerals as the number of times a function is applied, how do we get the previous application? The function we are applying must maintain its previous state.</p> 
<p>In our toNumber function we used the function application of our Church numerals to translate them into Arabic numerals. We could use this function application to perform operations between Church numerals.</p> 
<p>We wrote our add function like this:</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAf-AAAAJDRjZjYwNWM2LWJjNTYtNGQ2Yi1hNDM1LTUyMGJlNzg4ZjliNQ.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>The n numeral applies fn n times and then m applies it m more times. However, we also wrote an increment function we called succ.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAkNAAAAJGVmNWUwNDM3LTBmOTUtNDg2Yi1hNmM5LTcxNGJlNThlZGFkNw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>This just applies fn once extra time to num. We could write an addition function in terms of the succ function. Increment the m numeral some n number of times.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAemAAAAJGE2NGE4MTU5LTJhMGMtNDI5ZC1iZDkwLTM1ODI1ZDc1NDM3Mg.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Instead of using another Church numeral as the argument for our function, what if we used a Pair? As we incremented the numeral the first value in the pair would be the previous value and the second value would be the current value. The succ function won't handle this for us, but we can write another function that could operate on Pairs.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAflAAAAJDY4ZGU4ZjllLTA2YjAtNDZiNi04MjhkLTdiM2IxYWM1MWI5Yw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>If slide starts with a pair of zeros, Pair(Zero, Zero), successive calls to slide, slide(slide(Pair(Zero, Zero))), will work like the succ function, except the first value will always be one less. Therefore to implement a decrement function we apply slide some n number of times, starting with Pair(Zero, Zero), and take the first value from the returned Pair.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAemAAAAJGU2YWU4OWVmLTI3YjQtNDVhOC1iNGExLWZiYjBjOWRlNGI2Yw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Subtraction can now be written in terms of pred the same way we wrote our second attempt at add in terms of succ.</p> 
<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAdtAAAAJDBlODBmMTU5LWFlZjgtNDFhOS04OTA1LWQwZjI0MWMxZjhiYw.png" class="center" draggable="true" data-bukket-ext-bukket-draggable="true"></p> 
<p>Cool, that's it for this post. As I said I'll follow up sometime soon with an implementation of red/black trees and maybe some other stuff. We'll see.</p> 
</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t39" name="t39"></a><h1>39 : Model-View-Controller (MVC) with JavaScript</h1>
					<span class="ref-site">https://alexatnet.com/articles/model-view-controller-mvc-javascript</span>
					<div class="tutorial__content">

<p>I like JavaScript because it is one of the most flexible languages in the world.
It supports wide range of the programming styles and techniques, but such
flexibility comes with danger - it is very easy for the JavaScript project to
become a messy heap if the practices or design patterns are applied in a wrong
way or inconsistently.</p>

<p>My goal for this article is to demonstrate how to apply the Model-View-
Controller pattern while developing a simple JavaScript component. The component
is a kind of the HTML ListBox ("select" HTML tag) control with an editable list
of items: the user should be able to select and remove items and add new items
into the list. The component will consist of three classes that corresponds to
the parts of the <a href="http://en.wikipedia.org/wiki/Model-view-controller">Model-View-Controller</a> design pattern.</p>

<p>I hope, this article will be a good reading for you, but it would be much better
if you consider to run the examples and adapt them to you needs. I believe you
have everything to create and run JavaScript programs: brains, hands, text
editor, and an Internet Browser (Google Chrome, for example).</p>

<p>The Model-View-Controller pattern requires some description here. As you may
know, the name of the pattern is based on the names of its main parts: Model,
which stores an application data model; View, which renders Model for an
appropriate representation; and Controller, which updates Model. Wikipedia
defines typical components of the Model-View-Controller architecture as follows:</p>

<ul>
<li><strong>Model</strong> - The domain-specific representation of the information on which the
application operates. The model is another name for the domain layer. Domain
logic adds meaning to raw data (e.g., calculating if today is the user's
birthday, or the totals, taxes and shipping charges for shopping cart items).</li>
<li><strong>View</strong> - Renders the model into a form suitable for interaction, typically a
user interface element. MVC is often seen in web applications, where the view is
the HTML page and the code which gathers dynamic data for the page.</li>
<li><strong>Controller</strong> - Processes and responds to events, typically user actions, and
invokes changes on the model and perhaps the view.</li>
</ul>

<p>The data of the component is just a list of items, in which one particular item
can be selected and deleted. So, the model of the component is very simple - it
consists of an array and a selected item index; and here it is:</p>

<pre><code class="language-js">/**
 * The Model. Model stores items and notifies
 * observers about changes.
 */
function ListModel(items) {
    this._items = items;
    this._selectedIndex = -1;

    this.itemAdded = new Event(this);
    this.itemRemoved = new Event(this);
    this.selectedIndexChanged = new Event(this);
}

ListModel.prototype = {
    getItems : function () {
        return [].concat(this._items);
    },

    addItem : function (item) {
        this._items.push(item);
        this.itemAdded.notify({ item : item });
    },

    removeItemAt : function (index) {
        var item;

        item = this._items[index];
        this._items.splice(index, 1);
        this.itemRemoved.notify({ item : item });
        if (index === this._selectedIndex) {
            this.setSelectedIndex(-1);
        }
    },

    getSelectedIndex : function () {
        return this._selectedIndex;
    },

    setSelectedIndex : function (index) {
        var previousIndex;

        previousIndex = this._selectedIndex;
        this._selectedIndex = index;
        this.selectedIndexChanged.notify({ previous : previousIndex });
    }
};
</code></pre>

<p>Event is a simple class for implementing the Observer pattern:</p>

<pre><code class="language-js">function Event(sender) {
    this._sender = sender;
    this._listeners = [];
}

Event.prototype = {
    attach : function (listener) {
        this._listeners.push(listener);
    },
    notify : function (args) {
        var index;

        for (index = 0; index &lt; this._listeners.length; index += 1) {
            this._listeners[index](this._sender, args);
        }
    }
};
</code></pre>

<p>The View class requires defining controls for interacting with. There are
numerous alternatives of interface for the task, but I prefer a most simple one.
I want my items to be in a Listbox control and two buttons below it: "plus"
button for adding items and "minus" for removing selected item. The support for
selecting an item is provided by Listbox's native functionality. A View class is
tightly bound with a Controller class, which "… handles the input event from
the user interface, often via a registered handler or callback" (from
<a href="http://en.wikipedia.org/wiki/Model-view-controller">wikipedia.org</a>).</p>

<p>Here are the View and Controller classes:</p>

<pre><code class="language-js">/**
 * The View. View presents the model and provides
 * the UI events. The controller is attached to these
 * events to handle the user interraction.
 */
function ListView(model, elements) {
    this._model = model;
    this._elements = elements;

    this.listModified = new Event(this);
    this.addButtonClicked = new Event(this);
    this.delButtonClicked = new Event(this);

    var _this = this;

    // attach model listeners
    this._model.itemAdded.attach(function () {
        _this.rebuildList();
    });
    this._model.itemRemoved.attach(function () {
        _this.rebuildList();
    });

    // attach listeners to HTML controls
    this._elements.list.change(function (e) {
        _this.listModified.notify({ index : e.target.selectedIndex });
    });
    this._elements.addButton.click(function () {
        _this.addButtonClicked.notify();
    });
    this._elements.delButton.click(function () {
        _this.delButtonClicked.notify();
    });
}

ListView.prototype = {
    show : function () {
        this.rebuildList();
    },

    rebuildList : function () {
        var list, items, key;

        list = this._elements.list;
        list.html('');

        items = this._model.getItems();
        for (key in items) {
            if (items.hasOwnProperty(key)) {
                list.append($('&lt;option&gt;' + items[key] + '&lt;/option&gt;'));
            }
        }
        this._model.setSelectedIndex(-1);
    }
};

/**
 * The Controller. Controller responds to user actions and
 * invokes changes on the model.
 */
function ListController(model, view) {
    this._model = model;
    this._view = view;

    var _this = this;

    this._view.listModified.attach(function (sender, args) {
        _this.updateSelected(args.index);
    });

    this._view.addButtonClicked.attach(function () {
        _this.addItem();
    });

    this._view.delButtonClicked.attach(function () {
        _this.delItem();
    });
}

ListController.prototype = {
    addItem : function () {
        var item = window.prompt('Add item:', '');
        if (item) {
            this._model.addItem(item);
        }
    },

    delItem : function () {
        var index;

        index = this._model.getSelectedIndex();
        if (index !== -1) {
            this._model.removeItemAt(this._model.getSelectedIndex());
        }
    },

    updateSelected : function (index) {
        this._model.setSelectedIndex(index);
    }
};
</code></pre>

<p>And of course, the Model, View, and Controller classes should be instantiated.
The sample, which you can below, uses the following code to instantiate and
configure the classes:</p>

<pre><code class="language-js">$(function () {
    var model = new ListModel(['PHP', 'JavaScript']),
        view = new ListView(model, {
            'list' : $('#list'), 
            'addButton' : $('#plusBtn'), 
            'delButton' : $('#minusBtn')
        }),
        controller = new ListController(model, view);
    
    view.show();
});​
</code></pre>

<pre><code class="language-html">&lt;select id="list" size="10"&gt;&lt;/select&gt;
&lt;button id="plusBtn"&gt;  +  &lt;/button&gt;
&lt;button id="minusBtn"&gt;  -  &lt;/button&gt;
</code></pre>

<pre>/*global $ */
/*jslint indent: 4, maxlen: 80, browser: true, nomen: true */

(function () {
    'use strict';

    function Event(sender) {
        this._sender = sender;
        this._listeners = [];
    }

    Event.prototype = {
        attach : function (listener) {
            this._listeners.push(listener);
        },
        notify : function (args) {
            var index;

            for (index = 0; index &lt; this._listeners.length; index += 1) {
                this._listeners[index](this._sender, args);
            }
        }
    };

    /**
     * The Model. Model stores items and notifies
     * observers about changes.
     */
    function ListModel(items) {
        this._items = items;
        this._selectedIndex = -1;

        this.itemAdded = new Event(this);
        this.itemRemoved = new Event(this);
        this.selectedIndexChanged = new Event(this);
    }

    ListModel.prototype = {
        getItems : function () {
            return [].concat(this._items);
        },

        addItem : function (item) {
            this._items.push(item);
            this.itemAdded.notify({ item : item });
        },

        removeItemAt : function (index) {
            var item;

            item = this._items[index];
            this._items.splice(index, 1);
            this.itemRemoved.notify({ item : item });
            if (index === this._selectedIndex) {
                this.setSelectedIndex(-1);
            }
        },

        getSelectedIndex : function () {
            return this._selectedIndex;
        },

        setSelectedIndex : function (index) {
            var previousIndex;

            previousIndex = this._selectedIndex;
            this._selectedIndex = index;
            this.selectedIndexChanged.notify({ previous : previousIndex });
        }
    };

    /**
     * The View. View presents the model and provides
     * the UI events. The controller is attached to these
     * events to handle the user interraction.
     */
    function ListView(model, elements) {
        this._model = model;
        this._elements = elements;

        this.listModified = new Event(this);
        this.addButtonClicked = new Event(this);
        this.delButtonClicked = new Event(this);

        var _this = this;

        // attach model listeners
        this._model.itemAdded.attach(function () {
            _this.rebuildList();
        });
        this._model.itemRemoved.attach(function () {
            _this.rebuildList();
        });

        // attach listeners to HTML controls
        this._elements.list.change(function (e) {
            _this.listModified.notify({ index : e.target.selectedIndex });
        });
        this._elements.addButton.click(function () {
            _this.addButtonClicked.notify();
        });
        this._elements.delButton.click(function () {
            _this.delButtonClicked.notify();
        });
    }

    ListView.prototype = {
        show : function () {
            this.rebuildList();
        },

        rebuildList : function () {
            var list, items, key;

            list = this._elements.list;
            list.html('');

            items = this._model.getItems();
            for (key in items) {
                if (items.hasOwnProperty(key)) {
                    list.append($('<option>' + items[key] + '</option>'));
                }
            }
            this._model.setSelectedIndex(-1);
        }
    };

    /**
     * The Controller. Controller responds to user actions and
     * invokes changes on the model.
     */
    function ListController(model, view) {
        this._model = model;
        this._view = view;

        var _this = this;

        this._view.listModified.attach(function (sender, args) {
            _this.updateSelected(args.index);
        });

        this._view.addButtonClicked.attach(function () {
            _this.addItem();
        });

        this._view.delButtonClicked.attach(function () {
            _this.delItem();
        });
    }

    ListController.prototype = {
        addItem : function () {
            var item = window.prompt('Add item:', '');
            if (item) {
                this._model.addItem(item);
            }
        },

        delItem : function () {
            var index;

            index = this._model.getSelectedIndex();
            if (index !== -1) {
                this._model.removeItemAt(this._model.getSelectedIndex());
            }
        },

        updateSelected : function (index) {
            this._model.setSelectedIndex(index);
        }
    };

    $(function () {
        var model = new ListModel(['PHP', 'JavaScript']),
            view = new ListView(model, {
                'list' : $('#list'),
                'addButton' : $('#plusBtn'),
                'delButton' : $('#minusBtn')
            }),
            controller = new ListController(model, view);

        view.show();
    });
}());
</pre>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t40" name="t40"></a><h1>40 : JavaScript Function Memoization</h1>
					<span class="ref-site">http://inlehmansterms.net/2015/03/01/javascript-memoization/</span>
					<div class="tutorial__content">
<section class="Post-content">
    <p>In this post I am going to walk through when you might want to use memoization for your JavaScript functions and how you can easily memoize any function. Before we can go much further, let's define what memoization is.</p>

<!--more-->

<h2 id="what-is-memoization">What is memoization?</h2>

<p>Memoization is an optimization technique where expensive function calls are cached such that the result can be immediately returned the next time the function is called with the same arguments. This method of optimization is not unique to JavaScript and is quite common in many programming languages. It is especially useful in recursive functions as calls are more likely to call with the same arguments while recursing. Take a recursive <code>factorial</code> function for example:</p>
<pre><code>function factorial(num) {
  if(num === 1) { return 1 };
  return num * factorial(num - 1);
}
</code></pre>
<p>If we call <code>factorial(3)</code>, the function calls <code>factorial(3)</code>, <code>factorial(2)</code>, and <code>factorial(1)</code> will be called. If we memoize this function, another call to <code>factorial(3)</code> will not need to recurse, it can simply return the result that it has cached. The real benefit is if we call <code>factorial(4)</code>, we will short circuit our recursion, because <code>factorial(3)</code> is already cached, so we do not need to recurse any further, we can just use that result.</p>

<h2 id="sounds-great-sign-me-up">Sounds great, sign me up!</h2>

<p>We can simply create a <code>memoize</code> function that takes another function and modifies it to memoize calls.</p>
<pre><code>function memoize(func) {
  var cache = {};
  return function() {
    var key = JSON.stringify(arguments);
    if(cache[key]) {
      return cache[key];
    }
    else {
      var val = func.apply(this, arguments);
      cache[key] = val;
      return val;
    }
  };
}
</code></pre>
<p>Now we can easily memoize any pure function, like our <code>factorial</code> function.</p>
<pre><code>var factorial = memoize(function(num) {
  console.log('working for factorial(' + num + ')');
  if(num === 1) { return 1 };
  return num * factorial(num - 1);
});

// first call
console.log(factorial(3));
//=&gt; working for factorial(3)
//=&gt; working for factorial(2)
//=&gt; working for factorial(1)
//=&gt; 6

// successive calls
console.log(factorial(3)); //=&gt; 6
console.log(factorial(3)); //=&gt; 6

// short circuit higher factorial calls
console.log(factorial(4));
//=&gt; working for factorial(4)
//=&gt; 24
</code></pre>


<h2 id="advanced-usage">Advanced usage</h2>

<p>Right now we have memoization working by simply wrapping a given function with our <code>memoization</code> function. The results are cached for calls with the same arguments. This is great, but what if the arguments are not our only dependencies. What if we are memoizing a method on an object and that method relies on both the arguments AND other properties on the object? How do we account for these other dependencies? If we do not do anything different, memoizing a function might actually cause it to produce incorrect values (if the other dependencies have changed). We need a way to invalidate the cache for these dependencies as well.</p>

<p>The good news is that we can easily take other dependencies into account. Earlier you might have been wondering why I am using <code>JSON.stringify</code> to create my cache keys, and soon you will see how this helps make it extremely easy to add any number of dependencies in addition to a function's arguments.</p>

<p>Let's say we have a <code>Person</code> model with a firstName and lastName as well as a method, <code>fullName</code>, that takes an optional argument, title and outputs the person's full name.</p>
<pre><code>function memoize() { ... }

function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;

  this.fullName = memoize(function(title) {
    return title + ' ' + this.firstName + ' ' + this.lastName;
  });
}
</code></pre>
<p>All we need to do to memoize this function on the <code>Person</code> object, is to update the <code>memoize</code> function to take a second argument, <code>depsFunc</code>. <code>depsFunc</code> will be a function that returns an array of the dependencies. We can then use <code>depsFunc</code> as well as <code>func</code> to calculate the unique key in our hash.</p>
<pre><code>function memoize(func, depsFunc) {
  var cache = {};
  return function() {
    var key = JSON.stringify([depsFunc(), arguments]);
    if(cache[key]) {
      return cache[key];
    }
    else {
      var val = func.apply(this, arguments);
      cache[key] = val;
      return val;
    }
  };
}

function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;

  this.fullName = memoize(
    // calculation
    function(title) {
      console.log('working...');
      return title + ' ' + this.firstName + ' ' + this.lastName;
    },
    // dependencies
    function() {
      return [this.firstName, this.lastName];
    }.bind(this));
}

// create a new Person
var person = new Person('Jonathan', 'Lehman');

// first call to our memoized function does the work
console.log(person.fullName('Mr.'));
//=&gt; working
//=&gt; Mr. Jonathan Lehman

// successive calls
console.log(person.fullName('Mr.'));
//=&gt; Mr. Jonathan Lehman

// work must be done if dependencies or arguments change

// change arguments
console.log(person.fullName('Mister'));
//=&gt; work
//=&gt; Mister Jonathan Lehman

// change deps
person1.firstName = 'Jon';
console.log(person.fullName('Mr.'));
//=&gt; work
//=&gt; Mr. Jon Lehman
</code></pre>

<h2 id="careful-memoization-is-not-a-magic-bullet">Careful, memoization is not a magic bullet</h2>

<p>Keep in mind that memoization does not make sense for all function calls. There is a higher memory overhead since we must store our cached results so that we can later recall them as well as an added complexity of using memoization, so it really only makes sense for functions that are computationally expensive.</p>

<p>Also, memoization does not work well for functions that are not pure, that is functions that have side effects. Memoizing only allows us to cache a result, so any other side effects get lost on successive calls. That said, you can get around this constraint, by returning a function that includes your side effects that you will need to execute after getting the result.</p>

  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t41" name="t41"></a><h1>41 : Javascript Memoization</h1>
					<span class="ref-site">https://www.safaribooksonline.com/library/view/javascript-the-good/9780596517748/ch04s15.html</span>
					<div class="tutorial__content">
<div class="sect1" title="Memoization"><p>Functions can use objects to remember the results of previous operations, making
                it possible to avoid unnecessary work. This optimization is called
                    <span class="emphasis"><em>memoization</em></span>. JavaScript's objects and arrays are very
                convenient for this.<a id="IDX-CHP-4-0244" class="indexterm"></a><a id="IDX-CHP-4-0245" class="indexterm"></a></p><p>Let's say we want a recursive function to compute Fibonacci numbers. A Fibonacci
                number is the sum of the two previous Fibonacci numbers. The first two are 0 and
                    1:<a id="IDX-CHP-4-0246" class="indexterm"></a><a id="IDX-CHP-4-0247" class="indexterm"></a><a id="IDX-CHP-4-0248" class="indexterm"></a></p><a id="I_programlisting4_d1e3564"></a><pre class="programlisting">var fibonacci = function (n) {
    return n &lt; 2 ? n : fibonacci(n − 1) + fibonacci(n − 2);
};

for (var i = 0; i &lt;= 10; i += 1) {
    document.writeln('// ' + i + ': ' + fibonacci(i));
}

// 0: 0
// 1: 1
// 2: 1
// 3: 2
// 4: 3
// 5: 5
// 6: 8
// 7: 13
// 8: 21
// 9: 34
// 10: 55</pre><p>This works, but it is doing a lot of unnecessary work. The <code class="literal">fibonacci</code> function is called 453 times. We call it 11
                times, and it calls itself 442 times in computing values that were probably already
                recently computed. If we <span class="emphasis"><em>memoize</em></span> the function, we can
                significantly reduce its workload.</p><p>We will keep our memoized results in a <code class="literal">memo</code>
                array that we can hide in a closure. When our function is called, it first looks to
                see if it already knows the result. If it does, it can immediately return it:</p><a id="I_programlisting4_d1e3579"></a><pre class="programlisting">var fibonacci = (function (  ) {
    var memo = [0, 1];
    var fib = function (n) {
        var result = memo[n];
        if (typeof result !== 'number') {
            result = fib(n − 1) + fib(n − 2);
            memo[n] = result;
        }
        return result;
    };
    return fib;
}( ));</pre><p>This function returns the same results, but it is called only 29 times. We called
                it 11 times. It called itself 18 times to obtain the previously memoized
                results.</p><p>We can generalize this by making a function that helps us make memoized functions.
                The <code class="literal">memoizer</code> function will take an initial
                    <code class="literal">memo</code> array and the <code class="literal">formula</code> function. It returns a recur function that manages the memo
                store and that calls the <code class="literal">formula</code> function as
                needed. We pass the <code class="literal">recur</code> function and the
                function's parameters to the <code class="literal">formula</code>
                function:</p><a id="I_programlisting4_d1e3604"></a><pre class="programlisting">var memoizer = function (memo, formula) {
    var recur = function (n) {
        var result = memo[n];
        if (typeof result !== 'number') {
            result = formula(recur, n);
            memo[n] = result;
        }
        return result;
    };
    return recur;
};</pre><p>We can now define <code class="literal">fibonacci</code> with the memoizer,
                providing the initial <code class="literal">memo</code> array and <code class="literal">formula</code> function:</p><a id="I_programlisting4_d1e3618"></a><pre class="programlisting">var fibonacci = memoizer([0, 1], function (recur, n) {
    return recur(n − 1) + recur(n − 2);
});</pre><p>By devising functions that produce other functions, we can significantly reduce
                the amount of work we have to do. For example, to produce a memoizing factorial
                function, we only need to supply the basic factorial formula:<a id="IDX-CHP-4-0249" class="indexterm"></a></p><a id="I_programlisting4_d1e3625"></a><pre class="programlisting">var factorial = memoizer([1, 1], function (recur, n) {
    return n * recur(n − 1);
});</pre></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t42" name="t42"></a><h1>42 : Hello World</h1>
					<h3>A "Hello World"-like example of Javascript using the MVC pattern.</h3>
					<span class="ref-site">http://sandbox.thewikies.com/javascript-mvc-hello-world/</span>
					<div class="tutorial__content">
<pre>
/* ==========================================================================
 * A "Hello World"-like example of Javascript using the MVC pattern.
 * ========================================================================== */



/*
 * Model
 */

// a model is where the data object is created.
var ModelExample = function ( data ) {
	// the model instance has a property called "myProperty"
	// created from the data's "yourProperty".
	this.myProperty = data.yourProperty;

	// return the model instance
	return this;
};

// a model constructor might have a function that creates new model instances.
ModelExample.find = function ( id ) {
	// data used to create a new model may come from anywhere
	// but in this example data comes from this inline object.
	var ourData = {
		'123': {
			yourProperty: 'Hello World'
		}
	};

	// get a new model instance containing our data.
	var model = new ModelExample(ourData[id]);

	// return the model.
	return model;
};



/*
 * View
 */

// a view is where the output is created.
var ViewExample = function ( model ) {
	this.model = model;

	return this;
};

// a view might have a function that returns the rendered output.
ViewExample.prototype.output = function () {
	// data used to create a template may come from anywhere
	// but in this example template comes from this inline string.
	var ourData = '&lt;h1&gt;&lt;%= myProperty %&gt;&lt;/h1&gt;';

	// store this instance for reference in the replace function below
	var instance = this;

	// return the template using values from the model.
	return ourData.replace(/&lt;%=\s+(.*?)\s+%&gt;/g, function (m, m1) {
		return instance.model[m1];
	});
};

// a view might have a function that renders the output.
ViewExample.prototype.render = function () {
	// this view renders to the element with the id of "output"
	document.getElementById('output').innerHTML = this.output();
};



/*
 * Controller
 */

// a controller is where the model and the view are used together.
var ControllerExample = function () {
	return this;
};

// this function uses the Model and View together.
ControllerExample.prototype.loadView = function ( id ) {
	// get the model.
	var model = ModelExample.find( id );

	// get a new view.
	var view = new ViewExample(model);

	// run the view's "render" function
	view.render();
};




/*
 * Example
 */

function bootstrapper() {
	var controller = new ControllerExample;
	controller.loadView(123);
}

bootstrapper();


</pre>

<pre>
/* ==========================================================================
 * A "Hello World"-like example of Javascript using the MVC pattern.
 * This time with the addition of events.
 * ========================================================================== */



/*
 * Model
 */

// a model is where the data object is created.
var _Model = function ( data ) {
	// the model instance has a property called "myProperty"
	// created from the data's "yourProperty".
	this.myProperty = data.yourProperty;

	// return the model instance
	return this;
};

// a model constructor might have a function that creates new model instances.
_Model.find = function ( id ) {
	// data used to create a new model may come from anywhere
	// but in this example data comes from this inline object.
	var ourData = {
		'123': {
			yourProperty: 'You clicked.'
		},
		'456': {
			yourProperty: 'You pressed a key.'
		}
	};

	// get a new model instance containing our data.
	var model = new _Model(ourData[id]);

	// return the model.
	return model;
};



/*
 * View
 */

// a view is where the output is created.
var _View = function ( model ) {
	this.model = model;

	return this;
};

// a view might have a function that returns the rendered output.
_View.prototype.output = function () {
	// data used to create a template may come from anywhere
	// but in this example template comes from this inline string.
	var ourData = '&lt;h1&gt;&lt;%= myProperty %&gt;&lt;/h1&gt;';

	// store this instance for reference in the replace function below
	var instance = this;

	// return the template using values from the model.
	return ourData.replace(/&lt;%=\s+(.*?)\s+%&gt;/g, function (m, m1) {
		return instance.model[m1];
	});
};

// a view might have a function that renders the output.
_View.prototype.render = function () {
	// this view renders to the element with the id of "output"
	document.getElementById('output').innerHTML = this.output();
};


/*
 * Controller
 */

// a controller is where the model and the view are used together.
var _Controller = {};

// this function uses the Model and View together.
_Controller.loadView = function ( id ) {
	// get the model.
	var model = _Model.find( id );

	// get a new view.
	var view = new _View(model);

	// run the view's "render" function
	view.render();
};



/*
 * Event
 */

var Event123 = 1 &lt;&lt; 0;
var Event456 = 1 &lt;&lt; 1;

// an event is where something happening is captured.
var _Event = function (flag) {
	// check if Event123 was passed
	if (flag &amp; Event123) {
		// run the controller's show function
		_Controller.loadView(123);
	}

	// check if Event456 was passed
	if (flag &amp; Event456) {
		// run the controller's show function
		_Controller.loadView(456);
	}
};



/*
 * Example
 */

function bootstrapper() {
	document.onclick = function () {
		_Event(Event123);
	};

	document.onkeydown = function () {
		_Event(Event456);
	};
}

bootstrapper();
</pre>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article style="display:none;">
					<a id="t43" name="t43"></a><h1>43 : JavaScript's Magical Tips Every Developer Should Remember</h1>
					<span class="ref-site">https://blog.zipboard.co/javascripts-magical-tips-every-developer-should-remember-631b699fc251</span>
					<div class="tutorial__content">
<div class="section-inner sectionLayout--insetColumn"><p name="f692" id="f692" class="graf graf--p graf-after--figure">Over the course of developing our product at <a href="http://zipboard.co" data-href="http://zipboard.co" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">zipBoard</a>, JavaScript has been our bedrock for all intents and purposes. As per <a href="http://stackoverflow.com/research/developer-survey-2016#developer-profile" data-href="http://stackoverflow.com/research/developer-survey-2016#developer-profile" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this developer survey</a> at Stack Overflow, we're in good company on this front. JavaScript is <em class="markup--em markup--p-em">the</em> most popular technology for full stack development. While I have been focusing mainly on NodeJS, and somewhat AngularJS, I have realized that there are always some tricks and tips involved in every programming language irrespective of its nature of existence.</p><p name="c962" id="c962" class="graf graf--p graf-after--p">I have seen (<em class="markup--em markup--p-em">so many times</em>) that we programmers can tend to make things over complicated, which in-turn leads to problems and chaos in the developing environment. It is beautifully explained by <a href="https://medium.com/@_ericelliott" data-href="https://medium.com/@_ericelliott" data-anchor-type="2" data-user-id="c359511de780" data-action-value="c359511de780" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Eric Elliott</a> in his post.</p><p name="2a87" id="2a87" class="graf graf--p graf-after--mixtapeEmbed">Without further ado let's get started with the cool tips for JavaScript:</p><p name="c940" id="c940" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">1. Use "var" when creating a new variable.</strong><br>Whenever you are creating a new variable always keep in mind to use "var" in front of the variable name unless you want to create a global variable. This is so because if you create a variable without using "var" its scope will automatically be global which sometime creates issues, unless required.</p><p name="4776" id="4776" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Always use "===" as comparator instead of "==" (Strict equal)</strong><br>Use "===" instead of "==" because when you use "==" there is automatic type conversion involved which can lead to undesirable results.</p><pre name="127a" id="127a" class="graf graf--pre graf-after--p">3 == ‘3' // true<br>3 === ‘3' //false</pre><p name="d794" id="d794" class="graf graf--p graf-after--pre">This happens because in "===" the comparison takes place among the value and type.</p><pre name="6b6d" id="6b6d" class="graf graf--pre graf-after--p">[10] == 10   // is true<br>[10] === 10  // is false<br>'10' == 10   // is true<br>'10' === 10  // is false<br>[] == 0      // is true<br>[] === 0     // is false<br>'' == false  // is true<br>'' === false // is false</pre><p name="e2b8" id="e2b8" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. ‘undefined, null, 0, false, NaN, ‘' (empty string)' are all false conditions.</strong></p><p name="a3c4" id="a3c4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Empty an array</strong></p><pre name="a93c" id="a93c" class="graf graf--pre graf-after--p">var sampleArray = [2, 223, 54, 31];<br>sampleArray.length = 0; // sampleArray becomes []</pre><p name="a4ab" id="a4ab" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. Rounding number to N decimal places</strong></p><pre name="c301" id="c301" class="graf graf--pre graf-after--p">var n = 2.4134213123;<br>n = n.toFixed(4); // computes n = "2.4134"</pre><p name="5c55" id="5c55" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. Verify that your computation will produce finite result or not.</strong></p><pre name="0e19" id="0e19" class="graf graf--pre graf-after--p">isFinite(0/0);       // false<br>isFinite('foo');     // true<br>isFinite('10');      // true<br>isFinite(10);        // true<br>isFinite(undefined); // false<br>isFinite();          // false  <br>isFinite(null);      // true</pre><p name="d1db" id="d1db" class="graf graf--p graf-after--pre">Lets take an example to understand the use case of this function, suppose you have written a database query over a table which contains large amount of data and after the execution of query you are not certain about all the possible result values of that query. The data of query changes on something that you put dynamically in the query. In such a case you are not sure about finite property of the result and if you use that result directly it can give you infinite condition, which can break your code.</p><p name="ebba" id="ebba" class="graf graf--p graf-after--p">Hence, it is recommended to use <code class="markup--code markup--p-code">isFinite()</code> before any such operations so that infinite values can be handled properly.</p><p name="de4e" id="de4e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">7. Use a switch/case statement instead of a series of if/else</strong></p><p name="6efb" id="6efb" class="graf graf--p graf-after--p">Using switch/case is faster when there are more than 2 cases, and it is more elegant (better organized code). Avoid using it when you have more than 10 cases.</p><p name="7ccc" id="7ccc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">8. Use of "use strict" inside your file</strong><br>The string "use strict" will keep you from worrying about declaration of a variable which I mentioned in 1st point.</p><pre name="623b" id="623b" class="graf graf--pre graf-after--p"><em class="markup--em markup--pre-em">// This is bad, since you do create a global without having anyone to tell you<br></em>(function () {<br>   a = 42;<br>   console.log(a);<br>   <em class="markup--em markup--pre-em">// → 42</em><br>})();<br>console.log(a);<em class="markup--em markup--pre-em"><br>// → 42</em></pre><p name="c128" id="c128" class="graf graf--p graf--startsWithDoubleQuote graf-after--pre">"use strict" will keep you away from making above mistake. Using "use strict", you can get quite a few more errors:</p><pre name="8c59" id="8c59" class="graf graf--pre graf-after--p">(function () {<br>   "use strict";<br>   a = 42;<em class="markup--em markup--pre-em"><br>   // Error: Uncaught ReferenceError: a is not defined<br></em>})();</pre><p name="0d08" id="0d08" class="graf graf--p graf-after--pre">You could be wondering why you can't put "use strict" outside the wrapping function. Well, you can, but it will be applied globally. That's still not bad; but it will affect if you have code which comes from other libraries, or if you bundle everything in one file.</p><p name="3301" id="3301" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">9. Use &amp;&amp; and || to create magic</strong></p><pre name="cf60" id="cf60" class="graf graf--pre graf--startsWithDoubleQuote graf-after--p">"" || "foo"<em class="markup--em markup--pre-em"><br>// → "foo"</em></pre><pre name="477f" id="477f" class="graf graf--pre graf-after--pre">undefined || 42<em class="markup--em markup--pre-em"><br>// → 42</em></pre><pre name="cbff" id="cbff" class="graf graf--pre graf-after--pre">function doSomething () {<br>   return { foo: "bar" };<br>}<br>var expr = true;<br>var res = expr &amp;&amp; doSomething();<br>res &amp;&amp; console.log(res);<br><em class="markup--em markup--pre-em">// → { foo: "bar" }</em></pre><p name="cced" id="cced" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Additionally, don't forget to use a code beautifier when coding. Use </strong><a href="http://www.jslint.com/" data-href="http://www.jslint.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">JSLint</strong></a><strong class="markup--strong markup--p-strong"> and </strong><a href="https://en.wikipedia.org/wiki/Minification_%28programming%29" data-href="https://en.wikipedia.org/wiki/Minification_(programming)" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">minification</strong></a><strong class="markup--strong markup--p-strong"> (</strong><a href="https://pypi.python.org/pypi/jsmin" data-href="https://pypi.python.org/pypi/jsmin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">JSMin</strong></a><strong class="markup--strong markup--p-strong">, for example) before going live. This will help you maintain a coding standard in your project and make it as standard as possible.</strong></p><p name="b73c" id="b73c" class="graf graf--p graf-after--p">The above is a mere reflection of the power of JavaScript.</p><p name="9db0" id="9db0" class="graf graf--p graf-after--p graf--trailing">Thanks for reading!</p></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t44" name="t44"></a><h1>44 : 5 Features You Can Use in ES6 Today</h1>
					<span class="ref-site">https://scotch.io/bar-talk/five-things-you-can-use-in-es6-today</span>
					<div class="tutorial__content">
<div class="content">
                                <p>In my day job I'm the head of developer evangelism at <a href="https://www.pubnub.com?utm_source=Inbound&amp;utm_medium=scotchio&amp;utm_campaign=IN-CY17-Q1-XXX-XXX-March-14&amp;utm_term=utm-generator&amp;utm_content=utm-example/">PubNub</a>. We use
Javascript heavily in our new product <a href="https://www.pubnub.com/products/blocks/?utm_source=Inbound&amp;utm_medium=scotchio&amp;utm_campaign=IN-CY17-Q1-XXX-XXX-March-14&amp;utm_term=utm-generator&amp;utm_content=utm-example/">BLOCKS</a>, which enables developers
to run massively distributed Javascript code on the edge with very
low latency. </p>
<blockquote>
<p>Needless to say, we care a lot about Javascript performance and features, which is why ES6 is so exciting to us.</p>
</blockquote>
<p><strong>The changes in ES6 have been massive, exciting, and confusing.</strong> In this essay I'll introduce five features of the new JavaScript that you can use right away to supercharge your code, and what features to hold off on. </p>
<h2 id="ecmawhat"><a href="#ecmawhat"><span class="icon">#</span> Ecma-what?</a></h2>
<p>JavaScript has had many versions over the years, but overall
the evolution was slow until recently. I think More changes have
happened in the past two years than in the previous twenty.
ES 6 stands for EcmaScript 6. It's also called EcmaScript 2015,
or ES 2015. These are all different names for the 'new Javascript'.</p>
<p>I'm not entirely sure <em>why</em> JS has changed so much recently,
but it seems to be because the owners of the major JavaScript engines
have finally become interested in pushing the language forward.</p>
<p>Also, the advent of <a href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them">transpilers</a> like <a href="https://scotch.io/tutorials/from-javascript-to-typescript-pt-i-types-variables">TypeScript</a> have made it possible to use new
language features <em>before</em> they are built into the browsers. These
two have combined to push JavaScript forward massively.</p>
<p>JS matters because it's the fabric of the web, and increasingly used
in server side apps with Node, and in mobile and desktop apps with Cordova,
React Native, and Electron. </p>
<blockquote>
<p>In short: JS is everywhere </p>
</blockquote>
<p>So it matters that we push it forward. Languages which don't evolve start to die.
Improving the language means we can improve our code. Our apps can
have fewer bugs. And some of these features enable the runtimes
to actually run code faster. So let's dive in, starting with
variables.</p>
<h2 id="the-problem-with-variables"><a href="#the-problem-with-variables"><span class="icon">#</span> The Problem with Variables</a></h2>
<p>In Javascript when you want to create a variable you use
the <code>var</code> keyword. <code>var</code> is great, but it has a couple of problems.
First, variables always <em>vary</em>. There is no way to make a true
constant in Javascript. You can sorta fake it by creating an object
with an immutable property. You can override the setter of the
property so that it can't be set by outside code, but it's a lot
of extra typing and requires an entire object instead of
a simple variable.</p>
<pre><code>var VARS = {
    foo
        set = function() { }
        get = function() { return 42 }
}
VARS.foo = 42; // now I have a constant</code></pre>
<p>Regular Javascript variables also have a scoping problem. Take a look
at this code.</p>
<pre><code>function badCode() {
    if(foo) {
        var x = 5;
    }
    if(bar) {
        console.log(x);
    }
}</code></pre>
<p>Variables declared with <code>var</code> are global to the function they are
defined in, <em>not the block</em>. You'd think that the log
statement above wouldn't work because
<code>bar</code> is defined in a different block.
and in a language like java or C# you'd be right, but in
Javascript <code>var</code> is global to a function, not a block.</p>
<p>It gets worse when we add in <em>variable hoisting</em>. Consider
this code</p>
<pre><code>function badCode() {
    console.log("foo is",foo);
    var foo = 'bar';
}</code></pre>
<p>I'm using <code>foo</code> before I've defined it. What does this code <em>even mean</em>?
Under the hood the javascript engine will hoist the variable
declaration to the top of the function block. I can sort of see
why you might want to hoist functions, but variable hoisting
makes it very easy to introduce subtle bugs that are a pain
to diagnose.</p>
<p>Look at this <code>for</code> loop:</p>
<pre><code>for(var i=0; i&lt;5; i++) {
    console.log(i);
}
console.log(i);</code></pre>
<p>The variable is only used inside the loop, but I can still
reference it outside. This is just tons of bugs waiting to happen.</p>
<p>The good news is we don't have to use var anymore. Instead we can use const and let.</p>
<h2 id="introducing-const-and-let"><a href="#introducing-const-and-let"><span class="icon">#</span> Introducing const and let</a></h2>
<p>The new keyword <code>const</code> does exactly what the name suggests.
It makes a <em>real</em> constant. If you try to set the constant you'll
get a runtime error. Even better, code linting systems can detect
this kind of bug at compile time now, so you can find bugs earlier
at development time rather than in production.</p>
<p>The other new kind of variable is created with the <code>let</code> keyword.
<code>let</code> is just like <code>var</code> but it is scoped by block
instead of function. Now it does what we expect.</p>
<pre><code>function goodCode() {
    if(foo) {
        let x = 5;
    }
    if(bar) {
        console.log(x); //error
    }
}</code></pre>
<p>Let's revisit the <code>for</code> loop example:</p>
<pre><code>function goodCode() {
    for(let i=0; i&lt;5; i++) {
        console.log(i);
    }
    console.log(i); //error
}
</code></pre>
<p>Now the <code>i</code> variable is restricted to the body of the <code>for</code> loop.
There is no way it can be used outside accidentally.
Also, <code>let</code> isn't hoisted, so all of those magic moving variables
go away.</p>
<p>The new keywords <code>const</code> and <code>let</code> are a complete replacement for
<code>var</code>. With modern browsers and the newest versions of Node,
there is no reason to use <code>var</code> anymore. Good riddance.</p>
<h2 id="super-strings"><a href="#super-strings"><span class="icon">#</span> Super Strings</a></h2>
<p>ES6 introduces a new type of string called <em>Template Literals</em>. I
prefer to call them <em>Super Strings</em>.
You use a super string just like a regular string, but instead of
using single or double quotes, you use the back quote.</p>
<pre><code>var q  = 'foo';
var qq = "foo";

var bq = `foo`;

var qq = "Sally sells \"sea shells\"";
var bq = `Sally sells "sea shells"`;</code></pre>
<p>So far so good, but nothing is very different.  It does have one
immediate advantage. If you need to use double or single quotes
inside of a string you don't have to escape them anymore. However,
super strings have a few other tricks up their sleeves.</p>
<h3>Multiline Strings</h3>
<p>Finally we can have real multi-line strings. Need to quote several
lines of something? You don't have to escape newlines or do join
tricks anymore. Just put in the newlines directly and it works.</p>
<pre><code>var qq = "this is a very long"
  + " piece of text that goes over several lines"
  + " and would require silly hacks";

var bq = `this is a very long
    piece of text that goes over several lines
    and would require silly hacks`;</code></pre>
<h3>Expression escaping</h3>
<p>Another new feature is <em>expression escaping</em>.
Within a super string you can put <code>${}</code> with any valid
Javascript expression inside the brackets. This is much cleaner than
double escaping your quotes, and recent IDEs will
syntax highlight these expressions nicely.</p>
<pre><code>var name = "Alice";
var greeting = `Good morning ${name}`;
var amount = 5;
var price = 3;
var sales = `That costs ${amount*price} dollars`;&lt;/pre&gt;</code></pre>
<p>Combining expression escaping with multiline support gives
us great HTML templates. </p>
<pre><code>var template = `
  &lt;div&gt;
    &lt;h3&gt;Good Morning ${name}&lt;/h3&gt;
    &lt;p&gt;
      That item will cost you
      &lt;b&gt;${amount*price}&lt;/b&gt;
      dollars.
    &lt;/p&gt;
  &lt;/div&gt;`</code></pre>
<h2 id="arrow-functions"><a href="#arrow-functions"><span class="icon">#</span> Arrow Functions</a></h2>
<p>So that was strings and variables, but now let's take a look
at functions. If you've heard anything about ES6 before, it was
probably about <em>arrow functions</em>. These are a different syntax
to write regular functions but with a more compact
syntax. They also have one very important difference:
the <code>this</code> variable means something different. Let's look at some
code.</p>
<p>Suppose you want to loop over an array to double the values
within it, producing a new array. You could do it with the
following <code>for</code> loop,  but that creates extra variables
and it can be easy to accidentially break early or get the
index wrong. plus it's a lot of extra typing.</p>
<pre><code>var output = [];
for(var i=0; i&lt;;input.length; i++) {
    output[i] = input[i] * 2;
}</code></pre>
<p>Javascript arrays have a method called <code>map</code> which calls a
function on every element to generate a new element,
which are then placed into a new array. It works like this:</p>
<pre><code>var output = input.map(function(x) {
    return x * 2;
});</code></pre>
<p>This looks better but it would be nice to make it smaller.
The <code>x*2</code> part is the only thing which actually does any work.
The rest is syntactic overhead. With an arrow function
we can do it like this:</p>
<pre><code>var output = input.map((x)=&gt;x*2);</code></pre>
<p>Woah! That's a lot smaller. Let me explain what happened. An
arrow function lets you rewrite a function without the actual
<code>function</code> word. Instead you put the <code>=&gt;</code> after the parenthesis
containing the function parameters. </p>
<pre><code>//regular
function (x) {
    return x * 2;
}
//arrow style
(x) =&gt; {
    return x * 2;
}</code></pre>
<p>Arrow functions let us write the same thing smaller. But we can
make it event shorter. Let's remove the whitespace. Same code just shorter.</p>
<pre><code>(x) =&gt; { return x * 2; }</code></pre>
<p>But we can make it <em>even</em> shorter still. If the arrow function
contains only a single expression, we can remove the return and
the braces and semicolon, resulting in a tiny one line expression
which automatically returns it's value. This is so much cleaner.</p>
<pre><code>(x) =&gt; x * 2
var output = input.map((x)=&gt;x*2);</code></pre>
<p>Arrow functions can make your code very compact and powerful. But there's
one more trick up it's sleeve. It fixes <code>this</code>.</p>
<h3>The Curse of This</h3>
<p>In Javascript the magic variable <code>this</code> always refers to the object
that the function is called on. So code like the following doesn't
do what you think it does. </p>
<pre><code>function App() {
    this.clicked = false;
    var button = document.getElementById('button');
    button.addEventListener('click', function(evt) {
        this.clicked = true; //won't do what you think
    });
}</code></pre>
<p>When you are using other objects the <code>this</code> context may be
different than what you expect. When you pass a function to
somewhere else to be called back, it may call the function
with a different 'this'. If you add an event
handler to a button the button will be the 'this'. Sometimes
that's what you want, but in the code above it isn't. We want
<code>this</code> to be the surrounding App object, not the button.</p>
<p>This is a long standing problem with Javascript. It's so common
that developers have created something known as the <em>self</em> pattern
where you save the correct <code>this</code> reference using a temporary
variable <code>self</code>. It's yucky but it works.</p>
<pre><code>function App() {
    this.clicked = false;
    var button = document.getElementById('button');
    &lt;b&gt;var self = this;&lt;/b&gt;
    button.addEventListener('click', function(evt) {
        self.clicked = true;
    });
}</code></pre>
<p>Another way to solve the problem is to <em>bind</em> the function.
The <code>bind</code> method forces the <code>this</code> to be a specific object,
regardless of how the function is latter called.</p>
<pre><code>function App() {
    this.clicked = false;
    var button = document.getElementById('button');
    var callback = (function(evt) {
        this.clicked = true
    })&lt;b&gt;.bind(this);&lt;/b&gt;
    button.addEventListener('click',callback);
}</code></pre>
<p>Again, this will <em>work</em> but it's not great. We now
have extra code to write, and underneath doing a bind can create
extra overhead. Arrow functions give us a better way to do it.</p>
<pre><code>function App() {
    this.clicked = false;
    var button = document.getElementById('button');
    button.addEventListener('click',()=&gt;{
        this.clicked = true;
    });
}</code></pre>
<p>Arrow functions automatically capture the <code>this</code> var from the surrounding
context of where the function <em>is defined</em>,
not from where the function <em>is used</em>.
This means you can pass the function to some other place and absolutely
know that right version of <code>this</code> will be used.
In the code above everything works perfectly without any yucky hacks.</p>
<p>In short, arrow functions are really awesome. I try to use them
everywhere I can. They make your code shorter, easier to
read, and <code>this</code> becomes sensible again.</p>
<h2 id="promises"><a href="#promises"><span class="icon">#</span> Promises</a></h2>
<p>Another great feature of arrow functions is that they work well
with Promises. A Promise is a new kind of object in Javascript
designed to help with things that take a long time to execute.
Javascript doesn't have threads so if you want to do something that
might take a long time then you have to use callbacks.</p>
<p>For example, in Node you might want to load a file, parse it,
make a database request, then write a new file. These must all be
done in order, but they are all asynchronous so you have to start
nesting your callbacks. This produces what JS hackers like to
call <em>The Pyramid of Doom</em>. You get massively nested code.</p>
<pre><code>fs.readFile("file.txt", function(err, file) {
    db.fetchNames(function(err, names) {
        processFile(file, names, function(err, outfile) {
            fs.writeFile('file.txt',outfile, function(err, status) {
                console.log("we are done writing the file");
            })
        });
    })
});</code></pre>
<p>This code is ugly, hard to reason about, and has lots of nasty corners
for bugs to hide. Promises help us defeat the pyramid of doom.</p>
<p>A Javascript <code>Promise</code> is an object that represents a value which may not be
available yet. It <em>promises</em> to have the value in the future.
You can add a callback to be invoked when the final value is ready
using the <code>then</code> function.</p>
<pre><code>var prom = makeSomePromise();
//value not ready yet
prom.then((value)=&gt;{
    //do something with the value
})</code></pre>
<p>Promises with <code>then</code> callbacks are much like traditional callbacks,
but promises add an extra twist: they can be <em>chained</em>.  Let's revisit
our code from before. Each of the functions must be called in order,
and each depends on the result of the previous one. Using promises
we can do it like this instead. </p>
<pre><code>    fs.readFile("file.txt")
        .then((file) =&gt; {
            return db.fetchNames().then((names)=&gt;{
                return processFile(file,names)
            })
        })
        .then((outfile)=&gt;{
            return fs.writeFile('file.txt',outfile);
        })
        .then(()=&gt;{
            console.log("we are done writing the file");
        });</code></pre>
<p>Notice how the arrow functions make this nice and clean.
Each <code>then()</code> callback returns a value. This value is passed
to the next one so all of our functions can be easily chained.</p>
<p>Now you'll notice that the <code>processFile</code> command needs the result
of the previous <em>two</em> values however a promise only passes one value.
We also don't care what order <code>readFile</code> and <code>fetchNames</code> happens
in. We just want to know when both are completed. Promise can do this
too.</p>
<h3>Promise.all</h3>
<p>Suppose want to load each file from an array of filenames and be
be notified when they are all done. We can do that with <code>Promise.all()</code>.
<code>all</code> is a utility method on <code>Promise</code> which takes an array of promises and returns a new promise that resolves when all of the sub-promises complete.
Here's how we would load all of the files with <code>Promise.all</code>. (assume that
<code>readFile</code> is a function which returns a promise to read the file).</p>
<pre><code>var proms = filenames.map((name)=&gt; readFile(name));
Promise.all(proms).then((files)=&gt;{
    console.log(`we have ${files.length} files`);
});</code></pre>
<p>Now we can rewrite our original Node example like this:</p>
<pre><code>Promise.all([
    fs.readFile("file.txt"),
    db.fetchNames()
])
.then((vals) =&gt; processFile(vals[0],vals[1]))
.then((outfile)=&gt; fs.writeFile('file.txt',outfile))
.then(()=&gt; console.log("we are done writing the file"));</code></pre>
<p>I've combined the read file and database calls into a
single promise using <code>Promise.all</code>. The value it will
return is an array containing the results of both sub-promises,
so I can then put them into <code>processFile</code>. Notice that I've
also used the abbreviated arrow syntax to make the code smaller
and cleaner.</p>
<h3>Handling Failure</h3>
<p>Now consider what happens if one of these Promises fails?  To
handle the first one failing we could put in a try / catch block,
but the next <code>then</code> will still be called. Really we want everything
to stop if the first one fails. Promises have another trick up
their sleeves: the catch callback.</p>
<p>In the new version below if anything fails it will immediately jump to the
catch callback at the end, skipping the rest. After the catch we
can still add more then clauses.</p>
<pre><code>Promise.all([
    fs.readFile("file.txt"),
    db.fetchNames()
])
.then((vals) =&gt; processFile(vals[0],vals[1]))
.then((outfile)=&gt; fs.writeFile('file.txt',outfile))
.then(()=&gt; console.log("we are done writing the file"))
.catch((e) =&gt; {
    console.log("some error happened");
});</code></pre>
<h3>Making your own Promises</h3>
<p>Of course promises only work if the APIs we call actually use them.
Lots of libraries are starting to switch over to
promises, but while we wait we can make our own promises too.
We do it with the <code>Promise</code> constructor.</p>
<pre><code>function makePromise(foo,bar) {
    return new Promise((resolve, reject) =&gt; {
        try {
            //do long stuff
            resolve(value);
        } catch {
            reject(error);
        }
    });
}</code></pre>
<p>It takes two values: <code>resolve</code> and <code>reject</code>. Each of these are
callback functions. Inside you do whatever you need to do that
takes a long time, even if it involves multiple callbacks.
When you are completely done invoke <code>resolve()</code> with the final
value. This will then be sent the to the first <code>then</code>
clause of whatever uses your promise.</p><p></p>
<p>If something bad happens and you want to reject the value,
instead of throwing an error use the <code>reject()</code>, passing
whatever alternate value you want.</p>
<p>Here's a real-life example. I use AJAX calls all the
time but they can be ugly, like this.</p>
<pre><code>var url = "http://api.silly.io/api/list/e3da7b3b-976d-4de1-a743-e0124ce973b8?format=json";

var xml = new XMLHttpRequest();
xml.addEventListener('load', function() {
    var result = JSON.parse(this.responseText);
    console.log(result);
});
xml.addEventListener('error',function(error) {
    console.log("something bad happened");
});
xml.open("GET",url);
xml.send();</code></pre>
<p>Let's wrap this code up in a promise.</p>
<pre><code>function doGet(url) {
    return new Promise((resolve,rej)=&gt;{
        var xml = new XMLHttpRequest();
        xml.addEventListener('load', function() {
            var result = JSON.parse(this.responseText);
            resolve(result);
        });
        xml.addEventListener('error',function(error) {
            reject(error);
        });
        xml.open("GET",url);
        xml.send();
    });
}</code></pre>
<p>This is still the same basic code, but I can call it like this instead.</p>
<pre><code>var url = "someapi.com/dostuff?foo=bar";
doGet(url).then((obj)=&gt;{
    console.log(obj);
});</code></pre>
<p>Wow, that's <em>so</em> much cleaner. In reality I don't need make my own
AJAX Promise wrapper because there is a new web standard called
Fetch which already does this for me. Fetch isn't quite supported in
all browsers yet, so we can use our own until then.</p>
<p>Promises can be a bit tricky to wrap your head around at
first, but once you start using them I think you'll really like
them. They make it very easy to pull multiple functions together
into a single workflow that makes logical sense, and to
properly catch all errors along the way.</p>
<h2 id="arrays"><a href="#arrays"><span class="icon">#</span> Arrays</a></h2>
<p>Finally I want to show you a bunch of new Array features.
Most of these aren't exactly <em>new</em> for ES6, and in fact some of
them are quite old. However, they are finally supported everywhere
and play nicelly with Arrow Functions and Promises, so I think of them
as new.</p>
<p>Suppose you want to do something to every element of an array. Instead
of using a for loop, use the <code>forEach</code> or <code>map</code> functions.</p>
<pre><code>var values = [1,2,3,4,5,6,7,8,9,10];
values.forEach((x)=&gt;console.log(x));
var doubled = values.map((x) =&gt; x*2);</code></pre>
<p>The <code>forEach</code> function runs the callback on every element of the
array. The <code>map</code> function also runs on each element, but it stores the
results of each callback into a new array.</p>
<p>If you want to transform an array by including only certain values,
use the <code>filter</code> function.</p>
<pre><code>//find all values that match the filter
var evens = values.filter((x)=&gt;x%2==0);</code></pre>
<p>Array also has functions to find single values within the array based
on some criteria.</p>
<pre><code>//find the first that matches
var six = values.find((x) =&gt;  x &gt;= 6);
//find the index of the first that match
var index = values.findIndex((x) =&gt;  x &gt;= 6);
//true if at least one item matches
var any = values.some((x) =&gt; x &gt; 10);</code></pre>
<p>Finally arrays can be reduced to a single value with the <code>reduce</code> function.
<code>reduce</code> is very powerful and can be used to do lots of things like
summing an array or flattening nested arrays</p>
<pre><code>//reduce the array to a single value
var sum = values.reduce((a,b) =&gt; a+b, 0);
//flatten nested arrays
var list1 = [[0, 1], [2, 3], [4, 5]];
var list2 = [0, [1, [2, [3, [4, [5]]]]]];
const flatten = arr =&gt; arr.reduce(
  (acc, val) =&gt; acc.concat(
    Array.isArray(val) ? flatten(val) : val
  ),
  []
);
flatten(list1); // returns [0, 1, 2, 3, 4, 5]
flatten(list2); // returns [0, 1, 2, 3, 4, 5]</code></pre>
<p>To loop over the properties in an object you can use the <code>Object.keys</code>
to get an array of property names, then loop over it with <code>forEach</code></p>
<pre><code>var obj = {
    first:'Alice',
    middle:'N',
    last:'Wonderland',
    age:8,
    height:45,
}
Object.keys(obj).forEach((key)=&gt;{
    console.log("key = ", key);
    console.log("value = ", obj[key]);
});</code></pre>
<h2 id="things-to-avoid"><a href="#things-to-avoid"><span class="icon">#</span> Things to Avoid</a></h2>
<p>The five features I've shown you can be used today, but there's
a lot of other things in ES6 that you should avoid for time being;
either because they don't provide much value or aren't well supported
yet. These include:</p>
<ul>
<li>Destructuring</li>
<li>Modules</li>
<li>Default Parameters</li>
<li>Spread Operator</li>
<li>Symbols</li>
<li>Generators and Iterators</li>
<li>Weak Maps and Weak Sets</li>
<li>Proxies</li>
</ul>
<p>Destructuring allows you to pull values out of an object by name.
It can be useful in a few situations, but the best use I've found is
extracting functions from modules. Unfortunately modules are still a
mess and don't work the same everywhere, so avoid them for now. </p>
<p>Along with destructuring you can do without tricks like default
parameters, and the spread operator. I find these to be more
trouble than they are worth, at least for now.</p>
<p>Symbols, generators, iterators, weak maps and sets, and proxies
are genuinely useful but they aren't supported everywhere yet so I
suggest you wait a while before using them.</p>
<p>There is also a new class syntax. It still uses JavaScript's
prototypical inheritance, but it makes the syntax of defining a
class cleaner and consistent. However, it is also not as valuable
without the new module support so I suggest waiting a bit longer.</p>
<pre><code>class Foo extends Bar {
    constructor(stuff) {
        super(stuff);
        this.first = "first name"
    }
    doStuff() {
    }
    doMoreStuff() {
    }
}</code></pre>
<h2 id="can-i-use-it"><a href="#can-i-use-it"><span class="icon">#</span> Can I Use It?</a></h2>
<p>Most desktop and mobile browsers support everything I've shown you.
However, depending on your audience you may have older
browsers / older mobile OSes that don't.  Whenever you want to know
if something is ready, go to <a href="http://caniuse.com">caniuse.com</a>. It
will tell you what versions of each browser support what.</p>
<p>If you need to support IE &lt; 10, there's a good chance you'll want to use a <a href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them">transpiler</a> like <a href="https://scotch.io/tutorials/from-javascript-to-typescript-pt-i-types-variables">TypeScript</a> or <a href="https://babeljs.io">Babel</a></p>
<p>So those are five awesome features of ES6 that you can start
using right away. More stuff is coming, but you don't need to wait to
use these. Get to codin'. And if you want go use them in
low latency data stream driven Javascript code, go check out
<a href="https://www.pubnub.com/products/blocks/?utm_source=Inbound&amp;utm_medium=scotchio&amp;utm_campaign=IN-CY17-Q1-XXX-XXX-March-14&amp;utm_term=utm-generator&amp;utm_content=utm-example/">PubNub BLOCKS</a>. </p>
<h3>Sample Code</h3>
<p>We've created <a href="https://www.pubnub.com/blocks-catalog/?utm_source=Inbound&amp;utm_medium=scotchio&amp;utm_campaign=IN-CY17-Q1-XXX-XXX-March-14&amp;utm_term=utm-generator&amp;utm_content=utm-example/">a catalog of example code</a> that uses Arrow Functions and Promises
to communicate with lots of useful realtime webservices like
on-the-fly language translation, geo-coding, and chatbot apis.</p>
                                                                    <p>This content is <strong>sponsored</strong> via <a href="https://synd.co/1tbGq6z">Syndicate Ads</a>
                                
                            </p></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t45" name="t45"></a><h1>45 : Asynchronous in the Browser</h1>
					<span class="ref-site">http://www.datchley.name/asynchronous-in-the-browser/</span>
					<div class="tutorial__content">
<section class="post-content">
    <p>Asynchronous programming can be a hard thing to wrap your head around as a programmer if you're used to direct, synchronous style programming. In the browser, the most familiar form of asynchronous programming is likely the DOM event API.  But, asynchronous development in the browser happens in a number of places:</p>

<ul>
<li>DOM Events</li>
<li>Browser API calls like <code>setTimout()</code>, <code>setInterval()</code> and <code>setImmediate()</code></li>
<li>XHR (XML HTTP Requests), or Ajax calls</li>
</ul>

<p>This post will look at the primary mechanism used to handle asynchronous programming in the browser - callbacks.  We'll look at standard callbacks and continuation passing style (CPS); and various patterns used to implement those and keep them efficient. Don't worry, though, in the next part we'll cover a better asynchronous design pattern: Promises.</p>

<h2 id="asyncvssynchronous">Async vs Synchronous</h2>

<p>In direct style, synchronous programming, one task follows another task, and so forth, until all the tasks are complete. Each task completes its work and returns execution before the next task can begin.  This is easy to reason about as a developer - things happen in a sequence.</p>

<pre><code>first();  
second();  
last();  
</code></pre>

<p>Even when the sequence is chained, via the first step calling the second step, which calls the last step.  It's still fairly easy to follow the chain of execution in the sequence.</p>

<p>For example:  </p>

<pre><code>function getList() { return [1,2,3,4,5,6]; }  
function getEvens() {  
  return addFour().filter(function(item) { return item % 2 == 0; });
}
function addFour() {  
  return getList().map(function(item) { return item + 4; });
}
function sum() {  
  return getEvens().reduce(function(sum, n){ return (sum += n); }, 0);
}
console.log("sum =", sum());  
</code></pre>

<p>In the above example the synchronous flow of events looks like this:</p>

<p><a href="http://www.datchley.name/content/images/2015/06/synchronous-chain-sequence-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/06/synchronous-chain-sequence-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>Each function in the chain simply calls the next function in the chain, returning a result.</p>

<p>However, if our <code>getList()</code> function had to fetch the list from a remote resource (<em>asynchronously</em>), how would we handle processing the results?  This is where callbacks come into play.</p>

<h3 id="callbacks">Callbacks</h3>

<p>Many of you are likely already familiar with the concept of callbacks as you use them every time you listen for DOM events, or use jQuery's <code>$.ajax()</code> or even the browser's timer API calls like <code>setTimeout()</code> and its relatives.</p>

<p>At its most basic, a function that performs a task asynchronously will immediately return, so as not to block the main execution thread<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. It will typically use some browser API (setTimeout, XHR) to perform its processing in the background until it finishes. </p>

<p>But, in order to allow you to process the results of that long running task, those functions take an extra argument which is a function to call with that result once it's ready.  That function is termed a <em>callback</em>.</p>

<p>Let's reimplement our <code>getList()</code> method to operate asynchronously and take a callback to allow us to continue processing its results.</p>

<pre><code>function getList(callback) {  
  // runs asynchronously and immediately returns
  setTimeout(function(){ callback([1,2,3,4,5,6]); }, 2000);
}
function getEvens(list) {  
  return list.filter(function(item) { return item % 2 == 0; });
}
function addFour(list) {  
  return list.map(function(item) { return item + 4; });
}
function sum(list) {  
  var res = getEvens(list);
  res = addFour(res);
  console.log(res.reduce(function(sum, n){ return (sum += n); }, 0));
}

getList(sum);  
console.log("waiting...");  
// waiting... (2 seconds pass)
// 24
</code></pre>

<p>Now that <code>getList()</code> immediately returns, we have to wrap our previous synchronous calls in a function that we pass to <code>getList()</code> as the callback.  In this case, we just modified the <code>sum()</code> function to wrap our tasks to perform after receiving the results from <code>getList()</code>. We have to move all of our processing of the results into the callback function, as the callback is the only scope in which the results of the asynchronous process are available.</p>

<p>Here's the control flow for our asynchronous version of <code>getList()</code>.</p>

<p><a href="http://www.datchley.name/content/images/2015/06/async-chain-sequence-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/06/async-chain-sequence-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>Since <code>getList()</code> returns immediately, we see the output from the <code>console.log()</code> statement before our callback completes its processing.</p>

<p>If we have a series of asynchronous tasks that allow you to handle processing via a callback, we have to build up a nested callback structure.</p>

<pre><code>function asyncTask(fn) {  
  return setTimeout(function(){ fn(); }, 2000); 
}

function foo(n, fn) {  
  asyncTask(function(val){ fn(n); });
}
function bar(n, fn) {  
  asyncTask(function(val){ fn(n); });
}
function baz(n, fn) {  
  asyncTask(function(val){ fn(n); });
}

var n = 1;  
foo(n, function(res) {  
  bar(res+1, function(res) {
    baz(res+1, function(res) {
      console.log("result =", res);
    });
  });
});
// 6 seconds pass...
// result = 3
</code></pre>

<p>Even with the simplified code above, you can see why this situation is referred to as <em>callback hell</em>.  Working with numerous asynchronous tasks that are interdependent can be a nightmare to manage with callbacks in this fashion.  Here's the sequence diagram for that flow.</p>

<p><a href="http://www.datchley.name/content/images/2015/06/async-nested-sequence-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/06/async-nested-sequence-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<h3 id="continuationpassingstylecps">Continuation Passing Style (CPS)</h3>

<p>Continuation Passing Style is common in the node API, among other places. The idea behind continuation passing style is:</p>

<ul>
<li>no function is allowed to return to it's caller.</li>
<li>Each function takes a callback or continuation function as its last argument</li>
<li>that continuation function is the last thing to be called</li>
</ul>

<pre><code>function foo() {  
  bar(function (res) {
    console.log("result = " + res);
  });
}
function bar(fn) {  
  baz(fn);
}
function baz(fn) {  
  fn(3);
}
foo();  
</code></pre>

<p>The above code sample shows a set of functions written using CPS. Each function's last (<em>and only in this example</em>) argument is a callback. Once you start writing functions using CPS, everything else must follow suit and become CPS as well.</p>

<p>Here's the control flow sequence for the above example:</p>

<p><a href="http://www.datchley.name/content/images/2015/06/cps-sync-sequence-diagram.png" class="lightbox" data-featherlight="image"><img src="http://www.datchley.name/content/images/2015/06/cps-sync-sequence-diagram.png" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>

<p>CPS works well for systems that are asynchronous by default, like node, where the event loop constantly runs and the API functions as callbacks.  Converting direct style programming to CPS, however, requires some work and some different thinking about how your processing takes place.</p>

<p>Let's take the following expression and convert it to use <em>Continuation Passing Style</em>.</p>

<pre><code>var a=1, b=2, c=3, d=4, e=5;  
(a + ((Math.pow(b, 2)) * c) / d) - e;   // -4
</code></pre>

<p>A simple, direct mathematical expression; and not something you would want or need to convert to CPS; but for this example, it gives us a good view into how functions can be modified to work in this style.  We'll convert each arithmetic operation into it's own function that operates according to CPS rules.</p>

<pre><code>function mul(x, y, cont) { cont(x*y); }  
function add(x, y, cont) { cont(x+y); }  
function sub(x, y, cont) { cont(x-y); }  
function div(x, y, cont) { cont(x/y); }  
function sqr(x, cont) { cont(x^2); }

sqr(b, function(res){  
  mul(res, c, function(res) {
    div(res, d, function(res) {
      add(a, res, function(res) {
        sub(res, e, function(res) {
          console.log(res);  // -4
        });
      });
    });
  });
});
</code></pre>

<p>In order to handle processing, we have to nest each call to retain the scope and results passed to each callback. This gives us another case of the <em>pyramid of doom</em> or callback hell. </p>

<p>However, we can attempt to flatten the nested series of callbacks to make our code easier to read; as well as easier to reason about. </p>

<h3 id="thestacktailcalls">The Stack &amp; Tail Calls</h3>

<p>In stack based languages, like Javascript, function invocations create a new "frame" on the stack which holds the context, scope identifiers, return location and other items necessary to execute the function and return control to the caller.</p>

<p>The stack itself is memory resident, and so the stack is typically a much smaller portion of the memory allocated for the browser.  This means stack space is limited. When a function returns, its stack frame is removed from the stack which frees that memory.</p>

<p>If you've ever written a recursive function, you've likely run up against the infamous <code>Range Error: Maximum call stack size exceeded</code> message.  For example, take a simple factorial function written in recursive style:</p>

<pre><code>function factorial(n) {  
  return n ? n * factorial(n-1) : 1;
}
factorial(10);     // 3628800  
factorial(1000);   // Infinity  (integer overflow!)  
factorial(32768);  // Range Error: stack size exceeded  
</code></pre>

<p>We'll ignore the issue with integer overflow on <code>factorial(1000)</code> causing a result of <code>Infinity</code> (<em>a special value in Javascript</em>)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> as it's out of the scope of our conversation at the moment. It's the <code>Range Error</code> that interests us here.</p>

<p>Because the stack is limited in memory size, there are only so many nested functions you can call - as in the case of our recursive <code>factorial()</code> function.  This could be solved, however, if Javascript's runtime handled "tail call elimination"<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>Tail calls occur when a function returns the result of calling another function.  That function is said to be in <em>tail position</em>. Our <code>factorial</code> function isn't optimized for tail call elimination, since the it returns the result of an expression (<code>n * factorial(n-1)</code>), not a function invocation; </p>

<p>If Javascript had tail call optimization, we could rewrite our <code>factorial()</code> function to take advantage of that feature like so:</p>

<pre><code>function factorial(n) {  
  function _factorial(n, acc) {
    acc || (acc = 1);
      return n ? _factorial(n-1, n*acc) : acc;  // tail call
  }
  return _factorial(n);
}
</code></pre>

<p>Tail call optimization would transform the recursive calls into an iterative loop, which gives us a constant stack space and is much more efficient.</p>

<p>CPS falls into this same category of having tail calls, as each continuation function passed is an explicit tail call; and hence, could be optimized by the language runtime. But without optimization, CPS alone can lead to growing stack problems.</p>

<h3 id="trampolining">Trampolining</h3>

<p>We can optimize for tail calls ourselves by either writing the function in tail position as a loop:</p>

<pre><code>function factorialL(n) {  
    var acc = 1;
    while(n) {
        acc *= n--;
    }
    return acc;
}
</code></pre>

<p>or using a technique called <em>trampolining</em>.  Trampolining is common in functional programming and provides us a way to call our function in tail position without growing the stack.</p>

<p>Here's an implementation of the <code>trampoline()</code> function:  </p>

<pre><code>function trampoline(fn) {  
    var args = [].slice.call(arguments, 1);
    while (fn &amp;&amp; fn instanceof Function) {
        fn = fn.apply(this, args);
    }
    return fn;
}
</code></pre>

<p>The trampoline works by continuously executing a function as long as it continues to return a function. Once it returns a value, the loop terminates and the value is returned.</p>

<p>Here's our <code>factorial()</code> function written to optimize for recursive tail calls by using <code>trampoline()</code>. We simply wrap our call to our internal <code>_factorial()</code> function in a call to <code>trampoline()</code> and ensure that the internal function will return a reference to the next invocation of itself to be executed.  Once done, we simply return our <code>acc</code> value and the trampoline stops.</p>

<pre><code>function factorial(n) {  
  function _factorial(n, acc) {
    acc || (acc = 1);
      return n ? _factorial.bind(this, n-1, n*acc) : acc;
  }
  return trampoline(_factorial, n);
}

factorial(32768);  
// Infinity - no range error now!
</code></pre>

<p>So how does this help us in Continuation Passing Style? Remember, each <em>continuation</em> is a function, that represents the <em>next step in processing</em>. This continuation is executed in tail position by the current phase of processing once it has finished - the callback is now a continuation to more processing.  There is no need to retain the stack frame or context of the current function once it executes the continuation, as everything needed is passed to the continuation callback.</p>

<p>Instead of nesting our continuations and growing the stack, we can use our <code>trampoline()</code> to flatten out the processing steps; and retain a constant stack space.</p>

<pre><code>// CPS functions representing our processing steps
var steps = [  
    function first(cont) {
        cont(1);
    },
    function second(val, cont) {
        cont(val+2);
    },
    function third(val, cont) {
        cont(val+3);
    }
];

// A function to flatten our CPS steps into a series
// passing any values as we go. Takes a callback which
// will receive the result passed to the final continuation
function waterfall(steps, done) {  
    steps.push(done);
    trampoline(function() {
        return steps.length ? 
            function _cb(){
                var args = [].slice.call(arguments),
                    fn = steps.shift(); 
                fn.apply(this, args.concat(_cb));
            } :
            undefined;  // steps complete 
    });
}

waterfall(steps, function(res) {  
    console.log("final = ", res);   // final = 6
});
</code></pre>

<p>This is very similar to the <code>async.waterfall</code> method in the node <a href="https://github.com/caolan/async">async module</a>.  We can define our processing steps individually and allow our <code>waterfall()</code> function to run them, in order, using an anonymous callback as the continuation. </p>

<p>Our <code>waterfall()</code> also takes a final callback continuation, in CPS fashion, that will be passed the result given to the last continuation in the last step. It functions like a pipeline, where we are able to pass each step's result to the next step.</p>

<p>Here's a non-trampolined version of the <code>waterfall()</code> function that uses recursion.</p>

<pre><code>function waterfall(list, final) {  
  var args = [].slice.call(arguments, 2);

  if (list.length) {
    var fn = list.shift(),
        cb = function() {
          var results = [].slice.call(arguments);
          waterfall.apply(this, [list, final].concat(results));
        };
    fn.apply(this, args.concat(cb));
  }
  else {
    final.apply(this, args);
  }
}
</code></pre>

<h2 id="asyncerrorhandlingpatterns">Async Error Handling Patterns</h2>

<p>Error handling in asynchronous programming can be problematic. Because the asynchronous functions aren't running in the main thread, you can't really wrap them in a <code>try..catch</code>.</p>

<pre><code>try {  
    function async(cb) {
        setTimeout(function() {
            throw new Error("woops!");
            cb("done");
        }, 2000);
    }


    async(function(res) {
        console.log("received:", res);
    });
}
catch(e) {  
    console.log(e);
}
// Uncaught Error: woops!
</code></pre>

<p>This doesn't work because the error is thrown in a separate thread of execution, so even wrapping our entire program in a <code>try..catch</code> won't help.  The only way to handle it would be inside the actual asynchronous call and then processing that error a different way.</p>

<p>To get around that, many async library APIs have been built to take two callbacks, one for successful completion and one that gets called on error. We can rework our async function above to allow for this as well.</p>

<pre><code>function async2(cb, err) {  
    setTimeout(function() {
        try {
            if (true)
                throw new Error("woops!");
            else
                cb("done");
        }
        catch(e) {
            err(e);
        }
    }, 2000);
}

async2(function(res) {  
    console.log("received:", res);
}, function(err) {
    console.log("Error: async threw an exception:", err);
});
// Error: async threw an exception: Error: woops!
</code></pre>

<p>Now, we have a way to gracefully handle exceptions and errors encountered in our asynchronous process and can provide a fallback path of execution.</p>

<p>In Continuation Passing Style, a common pattern is the error first design of callbacks which is common in the node API.  In this pattern, you use a single callback and the first argument is reserved for any error response, which would mean the async process didn't complete successfully. </p>

<pre><code>function asyncCPS(continuation) {  
    setTimeout(function() {
        try {
            var res = 42;
            if (true)
                throw new Error("woops!");
            else
                continuation(null, res); // pass 'null' for error
        }
        catch(e) {
            continuation(e, null);
        }
    }, 2000);
}

asyncCPS(function(err, res) {  
    if (err)
        console.log("Error: (cps) failed:", err);
    else
        console.log("(cps) received:", res);
});
// Error: (cps) failed: woops!
</code></pre>

<p>Now, our callbacks simply check if <code>err</code> is defined first, and if so, handle the issue in some graceful way; otherwise, our usual continuation processing occurs.  </p>

<p>We can generalize this type of error handling by writing a function which works as a decorator on a async function that returns a new function that is wrapped in a <code>try..catch</code> for us.</p>

<pre><code>// Function decorator that will give us a new
// function that wraps the invocation of a given function
// in a try catch.
function Try(fn, cont) {  
    return function _tryWrapper(){
        var args = [].slice.call(arguments);
        try {
            fn.apply(this, args);
        }
        catch(e) {
            cont(e);
        }
    };
}

function asyncCPSWrap(continuation) {  
    setTimeout(Try(function _cpsAsync() {
        var res = 42;
        if (true)
            throw new Error("woops!");
        else
            continuation(null, res);

    }, continuation), 2000);
};

asyncCPSWrap(function _callback(err, res) {  
    if (err)
        console.log("(cps) error:", err);
    else
        console.log("(cps) received:", res);
});
// (cps) error: Error: woops!
</code></pre>

<p>Our version of <code>Try()</code> above is written to work with CPS as it takes the async function to wrap and takes the continuation callback as a second parameter.  On any exception, it knows to pass the error as the first argument to the continuation.  </p>

<p>You could also easily re-write this for regular callbacks to accept a <em>success</em> and <em>error</em> callback handler as well and wire them up appropriately in the function returned from <code>Try()</code>.  As we'll see in the next article, <em>Promises</em> make error handling much cleaner and easier to implement than what's available using straight callbacks and CPS.</p>

<h2 id="conclusion">Conclusion</h2>

<p>With node/iojs, XHR/Ajax, DOM Events and so many other asynchronous processes that happen in modern day web applications, understanding how callbacks and patterns like <em>continuation passing</em> work is a must. This post just skimmed the surface of these patterns; but there is more in the world of asynchronous web development you can look into, such as <a href="https://rxjs.codeplex.com/">observable streams</a> and <a href="http://davidwalsh.name/es6-generators">ES6 generators</a>.</p>

<p>In the next piece we'll cover another widely used standard for asynchronous programming on the web, Promises.</p>

<hr>

<div class="footnotes"><ol><li class="footnote" id="fn:1"><p>For the curious (<em>and I hope you are</em>) this might lead you to ponder the workings of Javascript's single execution thread and the event loop in the browser, for which there is a <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">great talk</a> by Philip Roberts you should immediately go watch. <a href="#fnref:1" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:2"><p>Numbers in Javascript are an interesting topic, and you can find out more about <em>Infinity</em>, IEEE 754 Standard in a <a href="http://www.2ality.com/2012/04/number-encoding.html">great post</a> by Axel Rauschmayer. <a href="#fnref:2" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:3"><p>Keep hope alive, and continue to optimize for tail calls since <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls">ES6 will support proper tail call optimizations</a>. Yay! <a href="#fnref:3" title="return to article">↩</a></p></li></ol></div>
        <ul class="tags">
            <li class="tag" id="tag-id-5"><a href="/tag/javascript/">javascript</a></li> 
            <li class="tag" id="tag-id-8"><a href="/tag/asynchronous/">asynchronous</a></li> 
            <li class="tag" id="tag-id-9"><a href="/tag/cps/">cps</a></li> 
            <li class="tag" id="tag-id-10"><a href="/tag/callbacks/">callbacks</a></li> 
            <li class="tag" id="tag-id-11"><a href="/tag/tail-call-optimization/">tail call optimization</a></li> 
        </ul>
  </section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t46" name="t46"></a><h1>46: The Basics of DOM Manipulation in Vanilla JavaScript (No jQuery)</h1>
					<span class="ref-site">https://www.sitepoint.com/dom-manipulation-vanilla-javascript-no-jquery/</span>
					<div class="tutorial__content">
<p class='wp-special'>Whenever we need to perform DOM manipulation, we&#8217;re all quick to reach for jQuery. However, the vanilla JavaScript DOM API is actually quite capable in its own right, and since IE &lt; 11 has been <a href="https://www.microsoft.com/en-us/WindowsForBusiness/End-of-IE-support">officially abandoned</a>, it can now be used without any worries.</p>
<p>In this article, I&#8217;ll demonstrate how to accomplish some of the most common DOM manipulation tasks with plain JavaScript, namely:</p>

<ul>
<li>querying and modifying the DOM,</li>
<li>modifying classes and attributes,</li>
<li>listening to events, and</li>
<li>animation.</li>
</ul>
<p>I&#8217;ll finish off by showing you how to create your own super slim DOM-library that you can drop into any project. Along the way, you&#8217;ll learn that DOM manipulation with VanillaJS is not rocket science and that many jQuery methods in fact have direct equivalents in the native API.</p>
<p>So let&#8217;s get to it &#8230;</p>
<h2 id="dommanipulationqueryingthedom">DOM Manipulation: Querying the DOM</h2>
<p><em>Please note: I won&#8217;t explain the Vanilla DOM API in full detail, but only scratch the surface. In the usage examples, you may encounter methods I haven&#8217;t introduced explicitly. In this case just refer to the excellent <a href="https://developer.mozilla.org/en-US/">Mozilla Developer Network</a> for details.</em></p>
<p>The DOM can be queried using the <code>.querySelector()</code> method, which takes an arbitrary CSS selector as an argument:</p>
<pre><code class="javascript language-javascript">const myElement = document.querySelector('#foo &gt; div.bar')
</code></pre>
<p>This will return the first match (depth first). Conversely, we can check if an element matches a selector:</p>
<pre><code class="javascript language-javascript">myElement.matches('div.bar') === true
</code></pre>
<p>If we want to get all occurrences, we can use:</p>
<pre><code class="javascript language-javascript">const myElements = document.querySelectorAll('.bar')
</code></pre>
<p>If we already have a reference to a parent element, we can just query that element&#8217;s children instead of the whole <code>document</code>. Having narrowed down the context like this, we can simplify selectors and increase performance.</p>
<pre><code class="javascript language-javascript">const myChildElemet = myElement.querySelector('input[type="submit"]')

// Instead of
// document.querySelector('#foo &gt; div.bar input[type="submit"]')
</code></pre>
<p>Then why use those other, less convenient methods like <code>.getElementsByTagName()</code> at all? Well, one important difference is that the result of <code>.querySelector()</code> is <em>not live</em>, so when we dynamically add an element (see <a href="#modifyingthedom">section 3</a> for details) that matches a selector, the collection won&#8217;t update.</p>
<pre><code class="javascript language-javascript">const elements1 = document.querySelectorAll('div')
const elements2 = document.getElementsByTagName('div')
const newElement = document.createElement('div')

document.body.appendChild(newElement)
elements1.length === elements2.length // false
</code></pre>
<p>Another consideration is that such a live collection doesn&#8217;t need to have all of the information up front, whereas <code>.querySelectorAll()</code> immediately gathers everything in a static list, making it <a href="https://www.nczonline.net/blog/2010/09/28/why-is-getelementsbytagname-faster-that-queryselectorall/">less performant</a>.</p>
<h3 id="workingwithnodelists">Working with Nodelists</h3>
<p>Now there are two common gotchas regarding <code>.querySelectorAll()</code>. The first one is that we can&#8217;t call Node methods on the result and propagate them to its elements (like you might be used from jQuery objects). Rather we have to explicitly iterate over those elements. And this is the other gotcha: the return value is a NodeList, not an Array. This means we can&#8217;t call any array methods (e.g. <code>.forEach</code>) on it. We have to convert it to an array first.</p>
<pre><code class="javascript language-javascript">// Using Array.from()
Array.from(myElements).forEach(doSomethingWithEachElement)

// Or prior to ES6
Array.prototype.forEach.call(myElements, doSomethingWithEachElement)

// Shorthand:
[].forEach.call(myElements, doSomethingWithEachElement)
</code></pre>
<p>Each element also has a couple of rather self-explanatory read-only properties referencing the &#8220;family&#8221;, all of which are live:</p>
<pre><code class="javascript language-javascript">myElement.children
myElement.firstElementChild
myElement.lastElementChild
myElement.previousElementSibling
myElement.nextElementSibling
</code></pre>
<p>As the <a href="https://developer.mozilla.org/en-US/docs/Web/API/element">Element</a> interface inherits from the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node">Node</a> interface, the following properties are also available:</p>
<pre><code class="javascript language-javascript">myElement.childNodes
myElement.firstChild
myElement.lastChild
myElement.previousSibling
myElement.nextSibling
myElement.parentNode
myElement.parentElement
</code></pre>
<p>Where the former only reference elements, the latter (except for <code>.parentElement</code>) can be any kind of node, e.g. text nodes. We can then check the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType">type</a> of a given node like e.g.</p>
<pre><code class="javascript language-javascript">myElement.firstChild.nodeType === 3 // this would be a text node
</code></pre>
<p>As with any object, we can check a node&#8217;s prototype chain using the <code>instanceof</code> operator:</p>
<pre><code class="javascript language-javascript">myElement.firstChild.nodeType instanceof Text
</code></pre>
<h2 id="modifyingclassesandattributes">Modifying Classes and Attributes</h2>
<p>Modifying classes of elements is as easy as:</p>
<pre><code class="javascript language-javascript">myElement.classList.add('foo')
myElement.classList.remove('bar')
myElement.classList.toggle('baz')
</code></pre>
<p>You can read a more in-depth disussion of how to modify classes in this <a href="https://www.sitepoint.com/add-remove-css-class-vanilla-js/">quick tip by Yaphi Berhanu</a>. Element properties can be accessed like any other object&#8217;s properties</p>
<pre><code class="javascript language-javascript">// Get an attribute value
const value = myElement.value

// Set an attribute as an element property
myElement.value = 'foo'

// Set multiple properties using Object.assign()
Object.assign(myElement, {
  value: 'foo',
  id: 'bar'
})

// Remove an attribute
myElement.value = null
</code></pre>
<p>Note that there are also the methods <code>.getAttibute()</code>, <code>.setAttribute()</code> and .<code>removeAttribute()</code>. These directly modify the <em>HTML attributes</em> (as opposed to the DOM properties) of an element, thus causing a browser redraw (you can observe the changes by inspecting the element with your browser&#8217;s dev tools). Not only is such a browser redraw more expensive than just setting DOM properties, but  these methods also can have <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute#Notes">unexpected results</a>.</p>
<p>As a rule of thumb, only use them for attributes that don&#8217;t have a corresponding DOM property (such as <code>colspan</code>), or if you really want to &#8220;persist&#8221; those changes to the HTML (e.g. to keep them when cloning an element or modifying its parent&#8217;s <code>.innerHTML</code> — see <a href="#modifyingthedom">section 3</a>).</p>
<h3 id="addingcssstyles">Adding CSS styles</h3>
<p>CSS rules can be applied like any other property; note though that the properties are camel-cased in JavaScript:</p>
<pre><code class="javascript language-javascript">myElement.style.marginLeft = '2em'
</code></pre>
<p>If we want certain values, we can obtain these via the <code>.style</code> property. However, this will only give us styles that have been explicitly applied. To get the computed values, we can use, <code>.window.getComputedStyle()</code>. It takes the element and returns a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration">CSSStyleDeclaration</a> containing all styles from the element itself as well as those inherited from its parents:</p>
<pre><code class="javascript language-javascript">window.getComputedStyle(myElement).getPropertyValue('margin-left')
</code></pre>
<h2 id="modifyingthedom">Modifying the DOM</h2>
<p>We can move elements around like so:</p>
<pre><code class="javascript language-javascript">// Append element1 as the last child of element2
element1.appendChild(element2)

// Insert element2 as child of element 1, right before element3
element1.insertBefore(element2, element3)

// Insert element2 as child of element 1, right after element3
element1.insertAfter(element2, element3)
</code></pre>
<p>If we don&#8217;t want to move the element, but insert a copy, we can clone it like so:</p>
<pre><code class="javascript language-javascript">// Create a clone
const myElementClone = myElement.cloneNode()
myParentElement.appendChild(myElementClone)
</code></pre>
<p>The <code>.cloneNode()</code> method optionally takes a boolean as argument; if set to true, a <em>deep</em> copy will be created, meaning its children are also cloned.</p>
<p>Of course, we can just as well create entirely new elements or text nodes:</p>
<pre><code class="javascript language-javascript">const myNewElement = document.createElement('div')
const myNewTextNode = document.createTextNode('some text')
</code></pre>
<p>which we can then insert as shown above.  If we want to remove an element, we can&#8217;t do so directly, but we <em>can</em> remove children from a parent element, like so:</p>
<pre><code class="javascript language-javascript">myParentElement.removeChild(myElement)
</code></pre>
<p>This gives us a nice little work around, meaning can actually remove an element indirectly, by referencing its parent element:</p>
<pre><code class="javascript language-javascript">myElement.parentNode.removeChild(myElement)
</code></pre>
<h3 id="elementproperties">Element properties</h3>
<p>Every element also has the properties <code>.innerHTML</code> and <code>.textContent</code> (as well as <code>.innerText</code>, which is similar to <code>.textContent</code>, but has some <a href="http://perfectionkills.com/the-poor-misunderstood-innerText/">important differences</a>). These  hold the HTML and plain text content respectively. They are writable properties, meaning we can modify elements and their contents directly:</p>
<pre><code class="javascript language-javascript">// Replace the inner HTML
myElement.innerHTML = `
  &lt;div&gt;
    &lt;h2&gt;New content&lt;/h2&gt;
    &lt;p&gt;beep boop beep boop&lt;/p&gt;
  &lt;/div&gt;
`

// Remove all child nodes
myElement.innerHTML = null

// Append to the inner HTML
myElement.innerHTML += `
  &lt;a href="foo.html"&gt;continue reading...&lt;/a&gt;
  &lt;hr/&gt;
`
</code></pre>
<p>Appending markup to the HTML as shown above is usually a bad idea though, as we&#8217;d lose any previously made property changes on the affected elements (unless we persisted those changes as HTML attributes as shown in <a href="#modifyingclassesandattributes">section 2</a>) and bound event listeners.  Setting the <code>.innerHTML</code> is good for completely throwing away markup and replacing it with something else, e.g. server-rendered markup. So appending elements would better be done like so:</p>
<pre><code class="javascript language-javascript">const link = document.createElement('a')
const text = document.createTextNode('continue reading...')
const hr = document.createElement('hr')

link.href = 'foo.html'
link.appendChild(text)
myElement.appendChild(link)
myElement.appendChild(hr)
</code></pre>
<p>With this approach however we&#8217;d cause two browser redraws — one for each appended element — whereas changing the <code>.innerHTML</code> only causes one. As a way around this performance issue we can first assemble all nodes in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">DocumentFragment</a>, and then just append that single fragment:</p>
<pre><code class="javascript language-javascript">const fragment = document.createDocumentFragment()

fragment.appendChild(text)
fragment.appendChild(hr)
myElement.appendChild(fragment)
</code></pre>
<h2 id="listeningtoevents">Listening to events</h2>
<p>This is possibly the best known way to bind an event listener:</p>
<pre><code class="javascript language-javascript">myElement.onclick = function onclick (event) {
  console.log(event.type + ' got fired')
}
</code></pre>
<p>But this should generally be avoided. Here, <code>.onclick</code> is a property of the element, meaning that you can change it, but you cannot use it to add  additional listeners — by reassigning a new function you&#8217;ll overwrite the reference to the old one.</p>
<p>Instead, we can use the much mightier <code>.addEventListener()</code> method to add as many events of as many types as we like. It takes three arguments: the event type (such as <code>click</code>), a function that gets called whenever the event occurs on the element (this function gets passed an event object), and an optional config object which will be explained further below.</p>
<pre><code class="javascript language-javascript">myElement.addEventListener('click', function (event) {
  console.log(event.type + ' got fired')
})

myElement.addEventListener('click', function (event) {
  console.log(event.type + ' got fired again')
})
</code></pre>
<p>Within the listener function, <code>event.target</code> refers to the element on which the event was triggered (as does <code>this</code>, unless of course we&#8217;re using an <a href="https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/">arrow function</a>). Thus you can easily access its properties like so:</p>
<pre><code class="javascript language-javascript">// The `forms` property of the document is an array holding
// references to all forms
const myForm = document.forms[0]
const myInputElements = myForm.querySelectorAll('input')

Array.from(myInputElements).forEach(el =&gt; {
  el.addEventListener('change', function (event) {
    console.log(event.target.value)
  })
})
</code></pre>
<h3 id="preventingdefaultactions">Preventing default actions</h3>
<p>Note that <code>event</code> is always available within the listener function, but it is good practive to explitly pass it in anyway when needed (and we can name it as we like then, of course). Without elaborating on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">Event</a> interface itself, one particularly noteworthy method is <code>.preventDefault()</code>, which will, well, prevent the browser&#8217;s default behavior, such as following a link. Another common use-case would be to conditionally prevent the submission of a form if the client-side form-validation fails.</p>
<pre><code class="javascript language-javascript">myForm.addEventListener('submit', function (event) {
  const name = this.querySelector('#name')

  if (name.value === 'Donald Duck') {
    alert('You gotta be kidding!')
    event.preventDefault()
  }
})
</code></pre>
<p>Another important event method is <code>.stopPropagation()</code>, which will prevent the event from bubbling up the DOM. This means that if we have a propagation-stopping click listener (say) on an element, and another click listener on one of its parents, a click event that gets triggered on the child element won&#8217;t get triggered on the parent — otherwise, it would get triggered on both.</p>
<p>Now <code>.addEventListener()</code> takes an optional config object as a 3rd argument, which can have any of the following boolean properties (all of which default to <code>false</code>):</p>
<ul>
<li><code>capture</code>: The event will be triggered on the element before any other element beneath it in the DOM (event capturing and bubbling is an article in its own right, for more details have a look <a href="http://javascript.info/tutorial/bubbling-and-capturing">here</a>)</li>
<li><code>once</code>: As you might guess, this indicates that the event will get triggered only once</li>
<li><code>passive</code>: This means that <code>event.preventDefault()</code> will be ignored (and usually yield a warning in the console)</li>
</ul>
<p>The most common option is <code>.capture</code>; in fact, it is so common that there&#8217;s a shorthand for this: instead of specifying it in the config object, you can just pass in a boolean here:</p>
<pre><code class="javascript language-javascript">myElement.addEventListener(type, listener, true)
</code></pre>
<p>Event listeners can be removed using <code>.removeEventListener()</code>, which takes the event type and a reference to the callback function to be removed; for example, the <code>once</code> option could also be implemented like</p>
<pre><code class="javascript language-javascript">myElement.addEventListener('change', function listener (event) {
  console.log(event.type + ' got triggered on ' + this)
  this.removeEventListener('change', listener)
})
</code></pre>
<h3 id="eventdelegation">Event delegation</h3>
<p>Another useful pattern is <em>event delegation</em>: say we have a form and want to add a <code>change</code> event listener to all of its <code>input</code> children. One way to do so would be iterating over them using <code>myForm.querySelectorAll('input')</code> as shown above. However, this is unnecessary when we can just as well add it to the form itself and check the contents of <code>event.target</code>.</p>
<pre><code class="javascript language-javascript">myForm.addEventListener('change', function (event) {
  const target = event.target
  if (target.matches('input')) {
    console.log(target.value)
  }
})
</code></pre>
<p>Another advantage of this pattern is that it automatically accounts for dynamically inserted children as well, without having to bind new listeners to each.</p>
<h2 id="animation">Animation</h2>
<p>Usually, the cleanest way to perform animations is to apply CSS classes with a <code>transition</code> property, or use CSS <code>@keyframes</code>. But if you need more flexibility  (e.g. for a game), this can be done with JavaScript as well.</p>
<p>The naive approach would be to have a <code>window.setTimeout()</code> function call itself until the desired animation is completed. However, this inefficiently forces rapid document reflows; and this <em>layout thrashing</em> can quickly lead to stuttering, expecially on mobile devices. Intead, we can sync the updates using <code>window.requestAnimationFrame()</code> to schedule all current changes to the next browser repaint frame. It takes a callback as argument which receives the current (high res) timestamp:</p>
<pre><code class="javascript language-javascript">const start = window.performance.now()
const duration = 2000

window.requestAnimationFrame(function fadeIn (now)) {
  const progress = now - start
  myElement.style.opacity = progress / duration

  if (progress &lt; duration) {
    window.requestAnimationFrame(fadeIn)
  }
}
</code></pre>
<p>This way we can achieve very smooth animations. For a more detailed discussion, please have a look at <a href="https://www.sitepoint.com/quick-tip-game-loop-in-javascript/">this</a> article by Mark Brown.</p>
<h2 id="writingyourownhelpermethods">Writing your own helper methods</h2>
<p>True, always having to iterate over elements to do something with them may be rather cumbersome compared to jQuery&#8217;s concise and chainable <code>$('.foo').css({color: 'red'})</code> syntax.  So why not simply write our own shorthand methods for things like this?</p>
<pre><code class="javascript language-javascript">const $ = function $ (selector, context = document) {
const elements = Array.from(context.querySelectorAll(selector))

  return {
    elements,

    html (newHtml) {
      this.elements.forEach(element =&gt; {
        element.innerHTML = newHtml
      })

      return this
    },

    css (newCss) {
      this.elements.forEach(element =&gt; {
        Object.assign(element.style, newCss)
      })

      return this
    },

    on (event, handler, options) {
      this.elements.forEach(element =&gt; {
        element.addEventListener(event, handler, options)
      })

      return this
    }

    // etc.
  }
}
</code></pre>
<p>Thus we have a super slim DOM-library with only the methods that we really need, and without all the backwards-compatibility weight. Usually we&#8217;d have those methods in our collection&#8217;s prototype though. Here&#8217;s a (somewhat more elaborate) <a href="https://gist.github.com/SitePointEditors/4f6643d62a87aece860b0784c6eeffd2">gist</a> with some ideas how to implement such helpers. Alternatively, we might keep it as simple as</p>
<pre><code class="javascript language-javascript">const $ = (selector, context = document) =&gt; context.querySelector(selector)
const $$ = (selector, context = document) =&gt; context.querySelectorAll(selector)

const html = (nodeList, newHtml) =&gt; {
  Array.from(nodeList).forEach(element =&gt; {
    element.innerHTML = newHtml
  })
}

// And so on...
</code></pre>
<h2 id="demo">Demo</h2>
<p>To round this article off, here&#8217;s a CodePen which demonstrates many of the concepts explained above to implement a simple lightbox technique. I encourage you to take some time to look through the source code and let me know in the comments below if you have any observations or questions.</p>
<p data-height="360" data-theme-id="6441" data-slug-hash="aJaggB" data-default-tab="result" data-user="SitePoint" data-embed-version="2" data-pen-title="Tightbox" class="codepen">See the Pen <a href="http://codepen.io/SitePoint/pen/aJaggB/">Tightbox</a> by SitePoint (<a href="http://codepen.io/SitePoint">@SitePoint</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope I could show that DOM manipulation with plain JavaScript is not rocket science and that in fact, many jQuery methods have direct equivalents in the native DOM API. This means that for some everyday use cases (such as a navigation menu or a modal popup), the additional overhead of a DOM library may be out of place.</p>
<p>And while it&#8217;s true that some parts of the native API are verbose or inconvenient (such as having to iterate over node lists manually all the time),  we can quite easily write our own small helper functions to abstract away such repetitive tasks.</p>
<p>But now it&#8217;s over to you. What do you think? Do you prefer to avoid third-party libraries where you can, or is rolling your own simply not worth the cognitive overhead? Let me know in the comments below.</p>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t47" name="t47"></a><h1>47 : Functional Programming Jargon</h1>
					<span class="ref-site">https://github.com/hemanth/functional-programming-jargon</span>
					<div class="tutorial__content">
<article class="markdown-body entry-content" itemprop="text">
<p>Functional programming (FP) provides many advantages, and its popularity has been increasing as a result. However, each programming paradigm comes with its own unique jargon and FP is no exception. By providing a glossary, we hope to make learning FP easier.</p>
<p>Examples are presented in JavaScript (ES2015). <a href="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%3F">Why JavaScript?</a></p>
<p><em>This is a <a href="https://github.com/hemanth/functional-programming-jargon/issues/20">WIP</a>; please feel free to send a PR ;)</em></p>
<p>Where applicable, this document uses terms defined in the <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a></p>


<p><strong>Table of Contents</strong></p>

<ul>
<li><a href="#arity">Arity</a></li>
<li><a href="#higher-order-functions-hof">Higher-Order Functions (HOF)</a></li>
<li><a href="#partial-application">Partial Application</a></li>
<li><a href="#currying">Currying</a></li>
<li><a href="#auto-currying">Auto Currying</a></li>
<li><a href="#function-composition">Function Composition</a></li>
<li><a href="#continuation">Continuation</a></li>
<li><a href="#purity">Purity</a></li>
<li><a href="#side-effects">Side effects</a></li>
<li><a href="#idempotent">Idempotent</a></li>
<li><a href="#point-free-style">Point-Free Style</a></li>
<li><a href="#predicate">Predicate</a></li>
<li><a href="#contracts">Contracts</a></li>
<li><a href="#guarded-functions">Guarded Functions</a></li>
<li><a href="#category">Category</a></li>
<li><a href="#value">Value</a></li>
<li><a href="#constant">Constant</a></li>
<li><a href="#functor">Functor</a>
<ul>
<li><a href="#preserves-identity">Preserves identity</a></li>
<li><a href="#composable">Composable</a></li>
</ul>
</li>
<li><a href="#pointed-functor">Pointed Functor</a></li>
<li><a href="#lift">Lift</a></li>
<li><a href="#referential-transparency">Referential Transparency</a></li>
<li><a href="#equational-reasoning">Equational Reasoning</a></li>
<li><a href="#lambda">Lambda</a></li>
<li><a href="#lambda-calculus">Lambda Calculus</a></li>
<li><a href="#lazy-evaluation">Lazy evaluation</a></li>
<li><a href="#monoid">Monoid</a></li>
<li><a href="#monad">Monad</a></li>
<li><a href="#comonad">Comonad</a></li>
<li><a href="#applicative-functor">Applicative Functor</a></li>
<li><a href="#morphism">Morphism</a>
<ul>
<li><a href="#endomorphism">Endomorphism</a></li>
<li><a href="#isomorphism">Isomorphism</a></li>
</ul>
</li>
<li><a href="#setoid">Setoid</a></li>
<li><a href="#semigroup">Semigroup</a></li>
<li><a href="#foldable">Foldable</a></li>
<li><a href="#traversable">Traversable</a></li>
<li><a href="#type-signatures">Type Signatures</a></li>
<li><a href="#union-type">Union type</a></li>
<li><a href="#product-type">Product type</a></li>
<li><a href="#option">Option</a></li>
<li><a href="#functional-programming-libraries-in-javascript">Functional Programming Libraries in JavaScript</a></li>
</ul>

<h2><a id="user-content-arity" class="anchor" href="#arity" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arity</h2>
<p>The number of arguments a function takes. From words like unary, binary, ternary, etc. This word has the distinction of being composed of two suffixes, "-ary" and "-ity." Addition, for example, takes two arguments, and so it is defined as a binary function or a function with an arity of two. Such a function may sometimes be called "dyadic" by people who prefer Greek roots to Latin. Likewise, a function that takes a variable number of arguments is called "variadic," whereas a binary function must be given two and only two arguments, currying and partial application notwithstanding (see below).</p>
<pre><code>const sum = (a, b) =&gt; a + b

const arity = sum.length
console.log(arity) // 2

// The arity of sum is 2
</code></pre>
<h2><a id="user-content-higher-order-functions-hof" class="anchor" href="#higher-order-functions-hof" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Higher-Order Functions (HOF)</h2>
<p>A function which takes a function as an argument and/or returns a function.</p>
<pre><code>const filter = (predicate, xs) =&gt; xs.filter(predicate)
</code></pre>
<pre><code>const is = (type) =&gt; (x) =&gt; Object(x) instanceof type
</code></pre>
<pre><code>filter(is(Number), [0, '1', 2, null]) // [0, 2]
</code></pre>
<h2><a id="user-content-partial-application" class="anchor" href="#partial-application" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Partial Application</h2>
<p>Partially applying a function means creating a new function by pre-filling some of the arguments to the original function.</p>
<pre><code>// Helper to create partially applied functions
// Takes a function and some arguments
const partial = (f, ...args) =&gt;
  // returns a function that takes the rest of the arguments
  (...moreArgs) =&gt;
    // and calls the original function with all of them
    f(...args, ...moreArgs)

// Something to apply
const add3 = (a, b, c) =&gt; a + b + c

// Partially applying `2` and `3` to `add3` gives you a one-argument function
const fivePlus = partial(add3, 2, 3) // (c) =&gt; 2 + 3 + c

fivePlus(4) // 9
</code></pre>
<p>You can also use <code>Function.prototype.bind</code> to partially apply a function in JS:</p>
<pre><code>const add1More = add3.bind(null, 2, 3) // (c) =&gt; 2 + 3 + c
</code></pre>
<p>Partial application helps create simpler functions from more complex ones by baking in data when you have it. <a href="#currying">Curried</a> functions are automatically partially applied.</p>
<h2><a id="user-content-currying" class="anchor" href="#currying" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Currying</h2>
<p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
<pre><code>const sum = (a, b) =&gt; a + b

const curriedSum = (a) =&gt; (b) =&gt; a + b

curriedSum(40)(2) // 42.

const add2 = curriedSum(2) // (b) =&gt; 2 + b

add2(10) // 12
</code></pre>
<h2><a id="user-content-auto-currying" class="anchor" href="#auto-currying" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto Currying</h2>
<p>Transforming a function that takes multiple arguments into one that if given less than its correct number of arguments returns a function that takes the rest. When the function gets the correct number of arguments it is then evaluated.</p>
<p>lodash &amp; ramda have a <code>curry</code> function that works this way.</p>
<pre><code>const add = (x, y) =&gt; x + y

const curriedAdd = _.curry(add)
curriedAdd(1, 2) // 3
curriedAdd(1) // (y) =&gt; 1 + y
curriedAdd(1)(2) // 3
</code></pre>
<p><strong>Further reading</strong></p>
<ul>
<li><a href="http://fr.umio.us/favoring-curry/">Favoring Curry</a></li>
<li><a href="https://www.youtube.com/watch?v=m3svKOdZijA">Hey Underscore, You're Doing It Wrong!</a></li>
</ul>
<h2><a id="user-content-function-composition" class="anchor" href="#function-composition" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Function Composition</h2>
<p>The act of putting two functions together to form a third function where the output of one function is the input of the other.</p>
<pre><code>const compose = (f, g) =&gt; (a) =&gt; f(g(a)) // Definition
const floorAndToString = compose((val) =&gt; val.toString(), Math.floor) // Usage
floorAndToString(121.212121) // '121'
</code></pre>
<h2><a id="user-content-continuation" class="anchor" href="#continuation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Continuation</h2>
<p>At any given point in a program, the part of the code that's yet to be executed is known as a continuation.</p>
<pre><code>const printAsString = (num) =&gt; console.log(`Given ${num}`)

const addOneAndContinue = (num, cc) =&gt; {
  const result = num + 1
  cc(result)
}

addOneAndContinue(2, printAsString) // 'Given 3'
</code></pre>
<p>Continuations are often seen in asynchronous programming when the program needs to wait to receive data before it can continue. The response is often passed off to the rest of the program, which is the continuation, once it's been received.</p>
<pre><code>const continueProgramWith = (data) =&gt; {
  // Continues program with data
}

readFileAsync('path/to/file', (err, response) =&gt; {
  if (err) {
    // handle error
    return
  }
  continueProgramWith(response)
})
</code></pre>
<h2><a id="user-content-purity" class="anchor" href="#purity" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Purity</h2>
<p>A function is pure if the return value is only determined by its
input values, and does not produce side effects.</p>
<pre><code>const greet = (name) =&gt; `Hi, ${name}`

greet('Brianne') // 'Hi, Brianne'
</code></pre>
<p>As opposed to each of the following:</p>
<pre><code>window.name = 'Brianne'

const greet = () =&gt; `Hi, ${window.name}`

greet() // "Hi, Brianne"
</code></pre>
<p>The above example's output is based on data stored outside of the function...</p>
<pre><code>let greeting

const greet = (name) =&gt; {
  greeting = `Hi, ${name}`
}

greet('Brianne')
greeting // "Hi, Brianne"
</code></pre>
<p>... and this one modifies state outside of the function.</p>
<h2><a id="user-content-side-effects" class="anchor" href="#side-effects" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Side effects</h2>
<p>A function or expression is said to have a side effect if apart from returning a value, it interacts with (reads from or writes to) external mutable state.</p>
<pre><code>const differentEveryTime = new Date()
</code></pre>
<pre><code>console.log('IO is a side effect!')
</code></pre>
<h2><a id="user-content-idempotent" class="anchor" href="#idempotent" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Idempotent</h2>
<p>A function is idempotent if reapplying it to its result does not produce a different result.</p>
<pre><code>f(f(x)) ≍ f(x)
</code></pre>
<pre><code>Math.abs(Math.abs(10))
</code></pre>
<pre><code>sort(sort(sort([2, 1])))
</code></pre>
<h2><a id="user-content-point-free-style" class="anchor" href="#point-free-style" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Point-Free Style</h2>
<p>Writing functions where the definition does not explicitly identify the arguments used. This style usually requires <a href="#currying">currying</a> or other <a href="#higher-order-functions-hof">Higher-Order functions</a>. A.K.A Tacit programming.</p>
<pre><code>// Given
const map = (fn) =&gt; (list) =&gt; list.map(fn)
const add = (a) =&gt; (b) =&gt; a + b

// Then

// Not points-free - `numbers` is an explicit argument
const incrementAll = (numbers) =&gt; map(add(1))(numbers)

// Points-free - The list is an implicit argument
const incrementAll2 = map(add(1))
</code></pre>
<p><code>incrementAll</code> identifies and uses the parameter <code>numbers</code>, so it is not points-free.  <code>incrementAll2</code> is written just by combining functions and values, making no mention of its arguments.  It <strong>is</strong> points-free.</p>
<p>Points-free function definitions look just like normal assignments without <code>function</code> or <code>=&gt;</code>.</p>
<h2><a id="user-content-predicate" class="anchor" href="#predicate" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Predicate</h2>
<p>A predicate is a function that returns true or false for a given value. A common use of a predicate is as the callback for array filter.</p>
<pre><code>const predicate = (a) =&gt; a &gt; 2

;[1, 2, 3, 4].filter(predicate) // [3, 4]
</code></pre>
<h2><a id="user-content-contracts" class="anchor" href="#contracts" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Contracts</h2>
<p>A contract specifies the obligations and guarantees of the behavior from a function or expression at runtime. This acts as a set of rules that are expected from the input and output of a function or expression, and errors are generally reported whenever a contract is violated.</p>
<pre><code>// Define our contract : int -&gt; int
const contract = (input) =&gt; {
  if (typeof input === 'number') return true
  throw new Error('Contract violated: expected int -&gt; int')
}

const addOne = (num) =&gt; contract(num) &amp;&amp; num + 1

addOne(2) // 3
addOne('some string') // Contract violated: expected int -&gt; int
</code></pre>
<h2><a id="user-content-guarded-functions" class="anchor" href="#guarded-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Guarded Functions</h2>
<p>TODO</p>
<h2><a id="user-content-category" class="anchor" href="#category" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Category</h2>
<p>A category in category theory is a collection of objects and morphisms between them. In programming, typically types
act as the objects and functions as morphisms.</p>
<p>To be a valid category 3 rules must be met:</p>
<ol>
<li>There must be an identity morphism that maps an object to itself.
Where <code>a</code> is an object in some category,
there must be a function from <code>a -&gt; a</code>.</li>
<li>Morphisms must compose.
Where <code>a</code>, <code>b</code>, and <code>c</code> are objects in some category,
and <code>f</code> is a morphism from <code>a -&gt; b</code>, and <code>g</code> is a morphism from <code>b -&gt; c</code>;
<code>g(f(x))</code> must be equivalent to <code>(g • f)(x)</code>.</li>
<li>Composition must be associative
<code>f • (g • h)</code> is the same as <code>(f • g) • h</code></li>
</ol>
<p>Since these rules govern composition at very abstract level, category theory is great at uncovering new ways of composing things.</p>
<h3><a id="user-content-further-reading" class="anchor" href="#further-reading" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Further reading</h3>
<ul>
<li><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a></li>
</ul>
<h2><a id="user-content-value" class="anchor" href="#value" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Value</h2>
<p>Anything that can be assigned to a variable.</p>
<pre><code>5
Object.freeze({name: 'John', age: 30}) // The `freeze` function enforces immutability.
;(a) =&gt; a
;[1]
undefined
</code></pre>
<h2><a id="user-content-constant" class="anchor" href="#constant" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constant</h2>
<p>A variable that cannot be reassigned once defined.</p>
<pre><code>const five = 5
const john = Object.freeze({name: 'John', age: 30})
</code></pre>
<p>Constants are <a href="#referential-transparency">referentially transparent</a>. That is, they can be replaced with the values that they represent without affecting the result.</p>
<p>With the above two constants the following expression will always return <code>true</code>.</p>
<pre><code>john.age + five === ({name: 'John', age: 30}).age + (5)
</code></pre>
<h2><a id="user-content-functor" class="anchor" href="#functor" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functor</h2>
<p>An object that implements a <code>map</code> function which, while running over each value in the object to produce a new object, adheres to two rules:</p>
<h3><a id="user-content-preserves-identity" class="anchor" href="#preserves-identity" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preserves identity</h3>
<pre><code>object.map(x =&gt; x) ≍ object
</code></pre>
<h3><a id="user-content-composable" class="anchor" href="#composable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Composable</h3>
<pre><code>object.map(compose(f, g)) ≍ object.map(g).map(f)
</code></pre>
<p>(<code>f</code>, <code>g</code> be arbitrary functions)</p>
<p>A common functor in JavaScript is <code>Array</code> since it abides to the two functor rules:</p>
<pre><code>[1, 2, 3].map(x =&gt; x) // = [1, 2, 3]
</code></pre>
<p>and</p>
<pre><code>const f = x =&gt; x + 1
const g = x =&gt; x * 2

;[1, 2, 3].map(x =&gt; f(g(x))) // = [3, 5, 7]
;[1, 2, 3].map(g).map(f)     // = [3, 5, 7]
</code></pre>
<h2><a id="user-content-pointed-functor" class="anchor" href="#pointed-functor" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pointed Functor</h2>
<p>An object with an <code>of</code> function that puts <em>any</em> single value into it.</p>
<p>ES2015 adds <code>Array.of</code> making arrays a pointed functor.</p>
<pre><code>Array.of(1) // [1]
</code></pre>
<h2><a id="user-content-lift" class="anchor" href="#lift" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lift</h2>
<p>Lifting is when you take a value and put it into an object like a <a href="#pointed-functor">functor</a>. If you lift a function into an <a href="#applicative-functor">Applicative Functor</a> then you can make it work on values that are also in that functor.</p>
<p>Some implementations have a function called <code>lift</code>, or <code>liftA2</code> to make it easier to run functions on functors.</p>
<pre><code>const liftA2 = (f) =&gt; (a, b) =&gt; a.map(f).ap(b) // note it's `ap` and not `map`.

const mult = a =&gt; b =&gt; a * b

const liftedMult = liftA2(mult) // this function now works on functors like array

liftedMult([1, 2], [3]) // [3, 6]
liftA2((a, b) =&gt; a + b)([1, 2], [3, 4]) // [4, 5, 5, 6]
</code></pre>
<p>Lifting a one-argument function and applying it does the same thing as <code>map</code>.</p>
<pre><code>const increment = (x) =&gt; x + 1

lift(increment)([2]) // [3]
;[2].map(increment) // [3]
</code></pre>
<h2><a id="user-content-referential-transparency" class="anchor" href="#referential-transparency" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referential Transparency</h2>
<p>An expression that can be replaced with its value without changing the
behavior of the program is said to be referentially transparent.</p>
<p>Say we have function greet:</p>
<pre><code>const greet = () =&gt; 'Hello World!'
</code></pre>
<p>Any invocation of <code>greet()</code> can be replaced with <code>Hello World!</code> hence greet is
referentially transparent.</p>
<h2><a id="user-content-equational-reasoning" class="anchor" href="#equational-reasoning" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Equational Reasoning</h2>
<p>When an application is composed of expressions and devoid of side effects, truths about the system can be derived from the parts.</p>
<h2><a id="user-content-lambda" class="anchor" href="#lambda" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambda</h2>
<p>An anonymous function that can be treated like a value.</p>
<pre><code>;(function (a) {
  return a + 1
})

;(a) =&gt; a + 1
</code></pre>
<p>Lambdas are often passed as arguments to Higher-Order functions.</p>
<pre><code>[1, 2].map((a) =&gt; a + 1) // [2, 3]
</code></pre>
<p>You can assign a lambda to a variable.</p>
<pre><code>const add1 = (a) =&gt; a + 1
</code></pre>
<h2><a id="user-content-lambda-calculus" class="anchor" href="#lambda-calculus" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambda Calculus</h2>
<p>A branch of mathematics that uses functions to create a <a href="https://en.wikipedia.org/wiki/Lambda_calculus">universal model of computation</a>.</p>
<h2><a id="user-content-lazy-evaluation" class="anchor" href="#lazy-evaluation" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lazy evaluation</h2>
<p>Lazy evaluation is a call-by-need evaluation mechanism that delays the evaluation of an expression until its value is needed. In functional languages, this allows for structures like infinite lists, which would not normally be available in an imperative language where the sequencing of commands is significant.</p>
<pre><code>const rand = function*() {
  while (1 &lt; 2) {
    yield Math.random()
  }
}
</code></pre>
<pre><code>const randIter = rand()
randIter.next() // Each execution gives a random value, expression is evaluated on need.
</code></pre>
<h2><a id="user-content-monoid" class="anchor" href="#monoid" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Monoid</h2>
<p>An object with a function that "combines" that object with another of the same type.</p>
<p>One simple monoid is the addition of numbers:</p>
<pre><code>1 + 1 // 2
</code></pre>
<p>In this case number is the object and <code>+</code> is the function.</p>
<p>An "identity" value must also exist that when combined with a value doesn't change it.</p>
<p>The identity value for addition is <code>0</code>.</p>
<pre><code>1 + 0 // 1
</code></pre>
<p>It's also required that the grouping of operations will not affect the result (associativity):</p>
<pre><code>1 + (2 + 3) === (1 + 2) + 3 // true
</code></pre>
<p>Array concatenation also forms a monoid:</p>
<pre><code>;[1, 2].concat([3, 4]) // [1, 2, 3, 4]
</code></pre>
<p>The identity value is empty array <code>[]</code></p>
<pre><code>;[1, 2].concat([]) // [1, 2]
</code></pre>
<p>If identity and compose functions are provided, functions themselves form a monoid:</p>
<pre><code>const identity = (a) =&gt; a
const compose = (f, g) =&gt; (x) =&gt; f(g(x))
</code></pre>
<p><code>foo</code> is any function that takes one argument.</p>
<pre><code>compose(foo, identity) ≍ compose(identity, foo) ≍ foo
</code></pre>
<h2><a id="user-content-monad" class="anchor" href="#monad" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Monad</h2>
<p>A monad is an object with <a href="#pointed-functor"><code>of</code></a> and <code>chain</code> functions. <code>chain</code> is like <a href="#functor"><code>map</code></a> except it un-nests the resulting nested object.</p>
<pre><code>// Implementation
Array.prototype.chain = function (f) {
  return this.reduce((acc, it) =&gt; acc.concat(f(it)), [])
}

// Usage
;Array.of('cat,dog', 'fish,bird').chain((a) =&gt; a.split(',')) // ['cat', 'dog', 'fish', 'bird']

// Contrast to map
;Array.of('cat,dog', 'fish,bird').map((a) =&gt; a.split(',')) // [['cat', 'dog'], ['fish', 'bird']]
</code></pre>
<p><code>of</code> is also known as <code>return</code> in other functional languages.
<code>chain</code> is also known as <code>flatmap</code> and <code>bind</code> in other languages.</p>
<h2><a id="user-content-comonad" class="anchor" href="#comonad" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comonad</h2>
<p>An object that has <code>extract</code> and <code>extend</code> functions.</p>
<pre><code>const CoIdentity = (v) =&gt; ({
  val: v,
  extract () {
    return this.val
  },
  extend (f) {
    return CoIdentity(f(this))
  }
})
</code></pre>
<p>Extract takes a value out of a functor.</p>
<pre><code>CoIdentity(1).extract() // 1
</code></pre>
<p>Extend runs a function on the comonad. The function should return the same type as the comonad.</p>
<pre><code>CoIdentity(1).extend((co) =&gt; co.extract() + 1) // CoIdentity(2)
</code></pre>
<h2><a id="user-content-applicative-functor" class="anchor" href="#applicative-functor" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applicative Functor</h2>
<p>An applicative functor is an object with an <code>ap</code> function. <code>ap</code> applies a function in the object to a value in another object of the same type.</p>
<pre><code>// Implementation
Array.prototype.ap = function (xs) {
  return this.reduce((acc, f) =&gt; acc.concat(xs.map(f)), [])
}

// Example usage
;[(a) =&gt; a + 1].ap([1]) // [2]
</code></pre>
<p>This is useful if you have two objects and you want to apply a binary function to their contents.</p>
<pre><code>// Arrays that you want to combine
const arg1 = [1, 3]
const arg2 = [4, 5]

// combining function - must be curried for this to work
const add = (x) =&gt; (y) =&gt; x + y

const partiallyAppliedAdds = [add].ap(arg1) // [(y) =&gt; 1 + y, (y) =&gt; 3 + y]
</code></pre>
<p>This gives you an array of functions that you can call <code>ap</code> on to get the result:</p>
<pre><code>partiallyAppliedAdds.ap(arg2) // [5, 6, 7, 8]
</code></pre>
<h2><a id="user-content-morphism" class="anchor" href="#morphism" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Morphism</h2>
<p>A transformation function.</p>
<h3><a id="user-content-endomorphism" class="anchor" href="#endomorphism" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Endomorphism</h3>
<p>A function where the input type is the same as the output.</p>
<pre><code>// uppercase :: String -&gt; String
const uppercase = (str) =&gt; str.toUpperCase()

// decrement :: Number -&gt; Number
const decrement = (x) =&gt; x - 1
</code></pre>
<h3><a id="user-content-isomorphism" class="anchor" href="#isomorphism" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Isomorphism</h3>
<p>A pair of transformations between 2 types of objects that is structural in nature and no data is lost.</p>
<p>For example, 2D coordinates could be stored as an array <code>[2,3]</code> or object <code>{x: 2, y: 3}</code>.</p>
<pre><code>// Providing functions to convert in both directions makes them isomorphic.
const pairToCoords = (pair) =&gt; ({x: pair[0], y: pair[1]})

const coordsToPair = (coords) =&gt; [coords.x, coords.y]

coordsToPair(pairToCoords([1, 2])) // [1, 2]

pairToCoords(coordsToPair({x: 1, y: 2})) // {x: 1, y: 2}
</code></pre>
<h2><a id="user-content-setoid" class="anchor" href="#setoid" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setoid</h2>
<p>An object that has an <code>equals</code> function which can be used to compare other objects of the same type.</p>
<p>Make array a setoid:</p>
<pre><code>Array.prototype.equals = function (arr) {
  const len = this.length
  if (len !== arr.length) {
    return false
  }
  for (let i = 0; i &lt; len; i++) {
    if (this[i] !== arr[i]) {
      return false
    }
  }
  return true
}

;[1, 2].equals([1, 2]) // true
;[1, 2].equals([0]) // false
</code></pre>
<h2><a id="user-content-semigroup" class="anchor" href="#semigroup" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Semigroup</h2>
<p>An object that has a <code>concat</code> function that combines it with another object of the same type.</p>
<pre><code>;[1].concat([2]) // [1, 2]
</code></pre>
<h2><a id="user-content-foldable" class="anchor" href="#foldable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Foldable</h2>
<p>An object that has a <code>reduce</code> function that can transform that object into some other type.</p>
<pre><code>const sum = (list) =&gt; list.reduce((acc, val) =&gt; acc + val, 0)
sum([1, 2, 3]) // 6
</code></pre>
<h2><a id="user-content-traversable" class="anchor" href="#traversable" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Traversable</h2>
<p>TODO</p>
<h2><a id="user-content-type-signatures" class="anchor" href="#type-signatures" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Signatures</h2>
<p>Often functions in JavaScript will include comments that indicate the types of their arguments and return values.</p>
<p>There's quite a bit of variance across the community but they often follow the following patterns:</p>
<pre><code>// functionName :: firstArgType -&gt; secondArgType -&gt; returnType

// add :: Number -&gt; Number -&gt; Number
const add = (x) =&gt; (y) =&gt; x + y

// increment :: Number -&gt; Number
const increment = (x) =&gt; x + 1
</code></pre>
<p>If a function accepts another function as an argument it is wrapped in parentheses.</p>
<pre><code>// call :: (a -&gt; b) -&gt; a -&gt; b
const call = (f) =&gt; (x) =&gt; f(x)
</code></pre>
<p>The letters <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> are used to signify that the argument can be of any type. The following version of <code>map</code> takes a function that transforms a value of some type <code>a</code> into another type <code>b</code>, an array of values of type <code>a</code>, and returns an array of values of type <code>b</code>.</p>
<pre><code>// map :: (a -&gt; b) -&gt; [a] -&gt; [b]
const map = (f) =&gt; (list) =&gt; list.map(f)
</code></pre>
<p><strong>Further reading</strong></p>
<ul>
<li><a href="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda's type signatures</a></li>
<li><a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch7.html#whats-your-type">Mostly Adequate Guide</a></li>
<li><a href="http://stackoverflow.com/a/399392/22425">What is Hindley-Milner?</a> on Stack Overflow</li>
</ul>
<h2><a id="user-content-union-type" class="anchor" href="#union-type" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Union type</h2>
<p>A union type is the combination of two types together into another one.</p>
<p>JS doesn't have static types but let's say we invent a type <code>NumOrString</code> which is a sum of <code>String</code> and <code>Number</code>.</p>
<p>The <code>+</code> operator in JS works on strings and numbers so we can use this new type to describe its inputs and outputs:</p>
<pre><code>// add :: (NumOrString, NumOrString) -&gt; NumOrString
const add = (a, b) =&gt; a + b

add(1, 2) // Returns number 3
add('Foo', 2) // Returns string "Foo2"
add('Foo', 'Bar') // Returns string "FooBar"
</code></pre>
<p>Union types are also known as algebraic types, tagged unions, or sum types.</p>
<p>There's a <a href="https://github.com/paldepind/union-type">couple</a> <a href="https://github.com/puffnfresh/daggy">libraries</a> in JS which help with defining and using union types.</p>
<h2><a id="user-content-product-type" class="anchor" href="#product-type" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Product type</h2>
<p>A <strong>product</strong> type combines types together in a way you're probably more familiar with:</p>
<pre><code>// point :: (Number, Number) -&gt; {x: Number, y: Number}
const point = (x, y) =&gt; ({x: x, y: y})
</code></pre>
<p>It's called a product because the total possible values of the data structure is the product of the different values.</p>
<p>See also <a href="https://en.wikipedia.org/wiki/Set_theory">Set theory</a>.</p>
<h2><a id="user-content-option" class="anchor" href="#option" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Option</h2>
<p>Option is a <a href="#union-type">union type</a> with two cases often called <code>Some</code> and <code>None</code>.</p>
<p>Option is useful for composing functions that might not return a value.</p>
<pre><code>// Naive definition

const Some = (v) =&gt; ({
  val: v,
  map (f) {
    return Some(f(this.val))
  },
  chain (f) {
    return f(this.val)
  }
})

const None = () =&gt; ({
  map (f) {
    return this
  },
  chain (f) {
    return this
  }
})

// maybeProp :: (String, {a}) -&gt; Option a
const maybeProp = (key, obj) =&gt; typeof obj[key] === 'undefined' ? None() : Some(obj[key])
</code></pre>
<p>Use <code>chain</code> to sequence functions that return <code>Option</code>s</p>
<pre><code>// getItem :: Cart -&gt; Option CartItem
const getItem = (cart) =&gt; maybeProp('item', cart)

// getPrice :: Item -&gt; Option Number
const getPrice = (item) =&gt; maybeProp('price', item)

// getNestedPrice :: cart -&gt; Option a
const getNestedPrice = (cart) =&gt; getItem(obj).chain(getPrice)

getNestedPrice({}) // None()
getNestedPrice({item: {foo: 1}}) // None()
getNestedPrice({item: {price: 9.99}}) // Some(9.99)
</code></pre>
<p><code>Option</code> is also known as <code>Maybe</code>. <code>Some</code> is sometimes called <code>Just</code>. <code>None</code> is sometimes called <code>Nothing</code>.</p>
<h2><a id="user-content-functional-programming-libraries-in-javascript" class="anchor" href="#functional-programming-libraries-in-javascript" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functional Programming Libraries in JavaScript</h2>


</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t48" name="t48"></a><h1>48 : ES6 Object Destructuring</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
<div class="post"><p>As JavaScript developers you are working a lot with objects and let's face it, manipulating objects wasn't the most convenient thing in JavaScript. ES6 is about to change this. Today we are going to discuss how to destructure objects using ES6.</p>
<p>Before however let's take a look at a sample object and see what we'd do now, using ES5:</p>
<pre><code>var person = {
    name: 'Joe',
    age: 21,
    married: true,
    hobbies: ['football', 'tennis', 'cooking']
};
</code></pre>
<p>In order to extract some information and store them as variables we'd probably do:</p>
<pre><code>var name = person.name;
var age = person.age;
// so on
</code></pre>
<p>This is a slightly laborous exercise, with ES6, utilising object destructuring we can very simply do:</p>
<pre><code>var {name, age} = person;
</code></pre>
<p>The above line will automatically create both a <code>name</code> and an <code>age</code> variable. If we want we can also have different names then the property name from the object for the variables:</p>
<pre><code>var {myName: name, myAge: age} = person;
</code></pre>
<p>This will create <code>myName</code> and <code>myAge</code> variables with the right values.</p>
<p>And finally, we can also desctructure arrays using the same notation:</p>
<pre><code>var {name, age, hobbies: [first, second]} = person;
</code></pre>
<p>You could now easily access these variables, for example <code>console.log(first)</code> would return 'football'.</p>

              </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
			
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-49" name="t-49"></a><h1>49 : ECMAScript 6 equivalents in ES5</h1>
					<span class="ref-site">https://github.com/addyosmani/es6-equivalents-in-es5</span>
					<div class="tutorial__content">
<article class="markdown-body entry-content" itemprop="text">
<p><strong>Table of contents:</strong></p>
<ol>
<li><a href="#arrow-functions">Arrow Functions</a></li>
<li><a href="#block-scoping-functions">Block Scoping Functions</a></li>
<li><a href="#t-emplate-literals">Template Literals</a></li>
<li><a href="#computed-property-names">Computed Property Names</a></li>
<li><a href="#destructuring-assignment">Destructuring Assignment</a></li>
<li><a href="#default-parameters">Default Parameters</a></li>
<li><a href="#iterators-and-for-of">Iterators and For-Of</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#numeric-literals">Numeric Literals</a></li>
<li><a href="#property-method-assignment">Property Method Assignment</a></li>
<li><a href="#object-initializer-shorthand">Object Initializer Shorthand</a></li>
<li><a href="#rest-parameters">Rest Parameters</a></li>
<li><a href="#spread-operator">Spread Operator</a></li>
<li><a href="#proxying-a-function-object">Proxying a function object</a></li>
<li><a href="#array-like-object-to-array">Array-like object to array</a></li>
<li><a href="#about">About</a></li>
<li><a href="#license">License</a></li>
</ol>
<h2><a id="user-content-arrow-functions" class="anchor" href="#arrow-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arrow Functions</h2>
<p>An arrow function expression (also known as fat arrow function) has a shorter syntax compared to function expressions and lexically binds the this value. Arrow functions are always anonymous.</p>
<p>ES6:</p>
<pre><code>[1, 2, 3].map(n =&gt; n * 2);
// -&gt; [ 2, 4, 6 ]
</code></pre>
<p>ES5 equivalent:</p>
<pre><code>[1, 2, 3].map(function(n) { return n * 2; }, this);
// -&gt; [ 2, 4, 6 ]
</code></pre>
<p>ES6:</p>
<pre><code>var evens = [2, 4, 6, 8, 10];

// Expression bodies
var odds = evens.map(v =&gt; v + 1);
var nums = evens.map((v, i) =&gt; v + i);

console.log(odds);
// -&gt; [3, 5, 7, 9, 11]

console.log(nums);
// -&gt; [2, 5, 8, 11, 14]

// Statement bodies
var fives = [];
nums = [1, 2, 5, 15, 25, 32];
nums.forEach(v =&gt; {
  if (v % 5 === 0)
    fives.push(v);
});

console.log(fives);
// -&gt; [5, 15, 25]

// Lexical this
var bob = {
  _name: 'Bob',
  _friends: [],
  printFriends() {
    this._friends.forEach(f =&gt;
      console.log(this._name + ' knows ' + f));
  }
}
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var evens = [2, 4, 6, 8, 10];

// Expression bodies
var odds = evens.map(function (v) {
  return v + 1;
}, this);
var nums = evens.map(function (v, i) {
  return v + i;
}, this);

console.log(odds);
// -&gt; [3, 5, 7, 9, 11]

console.log(nums);
// -&gt; [2, 5, 8, 11, 14]

var fives = [];
nums = [1, 2, 5, 15, 25, 32];

// Statement bodies
nums.forEach(function (v) {
  if (v % 5 === 0) {
    fives.push(v);
  }
}, this);

console.log(fives);
// -&gt; [5, 15, 25]

// Lexical this
var bob = {
  _name: 'Bob',
  _friends: [],
  printFriends: function printFriends() {
    this._friends.forEach(function (f) {
      return console.log(this._name + ' knows ' + f);
    }, this);
  }
};
</code></pre>
<h2><a id="user-content-block-scoping-functions" class="anchor" href="#block-scoping-functions" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Block Scoping Functions</h2>
<p>Block scoped bindings provide scopes other than the function and top level scope. This ensures your variables don't leak out of the scope they're defined:</p>
<p>ES6:</p>
<pre><code>// let declares a block scope local variable,
// optionally initializing it to a value in ES6

'use strict';

var a = 5;
var b = 10;

if (a === 5) {
  let a = 4; // The scope is inside the if-block
  var b = 1; // The scope is inside the function

  console.log(a);  // 4
  console.log(b);  // 1
}

console.log(a); // 5
console.log(b); // 1
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var a = 5;
var b = 10;

if (a === 5) {
  // technically is more like the following
  (function () {
    var a = 4;
    b = 1;

    console.log(a); // 4
    console.log(b); // 1
  })();
}

console.log(a); // 5
console.log(b); // 1
</code></pre>
<p>ES6:</p>
<pre><code>// const creates a read-only named constant in ES6.
'use strict';
// define favorite as a constant and give it the value 7
const favorite = 7;
// Attempt to overwrite the constant
try {
  favorite = 15;
} catch (err) {
  console.log('my favorite number is still: ' + favorite);
  // will still print 7
}
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';
// define favorite as a non-writable `constant` and give it the value 7
Object.defineProperties(window, {
  favorite: {
    value: 7,
    enumerable: true
  }
});
// ^ descriptors are by default false and const are enumerable
var favorite = 7;
// Attempt to overwrite the constant
favorite = 15;
// will still print 7
console.log('my favorite number is still: ' + favorite);
</code></pre>
<h2><a id="user-content-template-literals" class="anchor" href="#t-emplate-literals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Template Literals</h2>
<p>ES6 Template Literals are strings that can include <strong>embedded expressions</strong>. This is sometimes referred to as string interpolation.</p>
<p>ES6:</p>
<pre><code>// Basic usage with an expression placeholder
var person = 'Addy Osmani';
console.log(`Yo! My name is ${person}!`);

// Expressions work just as well with object literals
var user = {name: 'Caitlin Potter'};
console.log(`Thanks for getting this into V8, ${user.name}.`);

// Expression interpolation. One use is readable inline math.
var a = 50;
var b = 100;
console.log(`The number of JS frameworks is ${a + b} and not ${2 * a + b}.`);

// Multi-line strings without needing \n\
console.log(`string text line 1
string text line 2`);

// Functions inside expressions
function fn() { return 'result'; }
console.log(`foo ${fn()} bar`);
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

// Basic usage with an expression placeholder
var person = 'Addy Osmani';
console.log('Yo! My name is ' + person + '!');

// Expressions work just as well with object literals
var user = { name: 'Caitlin Potter' };
console.log('Thanks for getting this into V8, ' + user.name + '.');

// Expression interpolation. One use is readable inline math.
var a = 50;
var b = 100;
console.log('The number of JS frameworks is ' + (a + b) + ' and not ' + (2 * a + b) + '.');

// Multi-line strings:
console.log('string text line 1\nstring text line 2');
// Or, alternatively:
console.log('string text line 1\n\
string text line 2');

// Functions inside expressions
function fn() {
  return 'result';
}
console.log('foo ' + fn() + ' bar');
</code></pre>
<h2><a id="user-content-computed-property-names" class="anchor" href="#computed-property-names" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Computed Property Names</h2>
<p>Computed property names allow you to specify properties in object literals based on expressions:</p>
<p>ES6:</p>
<pre><code>var prefix = 'foo';
var myObject = {
  [prefix + 'bar']: 'hello',
  [prefix + 'baz']: 'world'
};

console.log(myObject['foobar']);
// -&gt; hello
console.log(myObject['foobaz']);
// -&gt; world
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var prefix = 'foo';
var myObject = {};

myObject[prefix + 'bar'] = 'hello';
myObject[prefix + 'baz'] = 'world';

console.log(myObject['foobar']);
// -&gt; hello
console.log(myObject['foobaz']);
// -&gt; world
</code></pre>
<h2><a id="user-content-destructuring-assignment" class="anchor" href="#destructuring-assignment" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Destructuring Assignment</h2>
<p>The destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals.</p>
<p>ES6:</p>
<pre><code>var {foo, bar} = {foo: 'lorem', bar: 'ipsum'};
// foo =&gt; lorem and bar =&gt; ipsum
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var _ref = { foo: 'lorem', bar: 'ipsum' };

// foo =&gt; lorem and bar =&gt; ipsum
var foo = _ref.foo;
var bar = _ref.bar;
</code></pre>
<p>ES3:</p>
<pre><code>with({foo: 'lorem', bar: 'ipsum'}) {
  // foo =&gt; lorem and bar =&gt; ipsum
}
</code></pre>
<p>ES6:</p>
<pre><code>var [a, , b] = [1,2,3];
</code></pre>
<p>ES6 (shimming using <code>Symbol.iterator</code>):</p>
<pre><code>'use strict';

var _slicedToArray = function (arr, i) {
  if (Array.isArray(arr)) {
    return arr;
  } else {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i &amp;&amp; _arr.length === i) {
        break;
      }
    }

    return _arr;
  }
};

var _ref = [1, 2, 3];

var _ref2 = _slicedToArray(_ref, 3);

var a = _ref2[0];
var b = _ref2[2];
</code></pre>
<p>ES5:</p>
<pre><code>String.prototype.asNamedList = function () {
  return this.split(/\s*,\s*/).map(function (name, i) {
    return name ? ('var ' + name + '=slice(' + i + ', ' + (i + 1) + ')[0]') : '';
  }).join(';');
};

with([1,2,3]) {
  eval('a, , b'.asNamedList());
}
</code></pre>
<h2><a id="user-content-default-parameters" class="anchor" href="#default-parameters" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Parameters</h2>
<p>Default parameters allow your functions to have optional arguments without needing to check arguments.length or check for undefined.</p>
<p>ES6:</p>
<pre><code>function greet(msg='hello', name='world') {
  console.log(msg,name);
}

greet();
// -&gt; hello world
greet('hey');
// -&gt; hey world
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function greet() {
  // unfair ... if you access arguments[0] like this you can simply
  // access the msg variable name instead
  var msg = arguments[0] === undefined ? 'hello' : arguments[0];
  var name = arguments[1] === undefined ? 'world' : arguments[1];
  console.log(msg, name);
}

function greet(msg, name) {
  (msg === undefined) &amp;&amp; (msg = 'hello');
  (name === undefined) &amp;&amp; (name = 'world');
  console.log(msg,name);
}

// using basic utility that check against undefined
function greet(msg, name) {
  console.log(
    defaults(msg, 'hello'),
    defaults(name, 'world')
  );
}

greet();
// -&gt; hello world
greet('hey');
// -&gt; hey world
</code></pre>
<p>ES6:</p>
<pre><code>function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}

f(3) === 15;
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x, y) {
  if (y === undefined) {
    y = 12;
  }

  return x + y;
}

f(3) === 15;
</code></pre>
<h2><a id="user-content-iterators-and-for-of" class="anchor" href="#iterators-and-for-of" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterators And For-Of</h2>
<p>Iterators are objects that can traverse a container. It's a useful way to make a class work inside a for of loop.
The interface is similar to the iterators-interface. Iterating with a <code>for..of</code> loop looks like:</p>
<p>ES6:</p>
<pre><code>// Behind the scenes, this will get an iterator from the array and loop through it, getting values from it.
for (let element of [1, 2, 3]) {
  console.log(element);
}
// =&gt; 1 2 3
</code></pre>
<p>ES6 (without using <code>for-of</code>, if <code>Symbol</code> is supported):</p>
<pre><code>'use strict';

for (var _iterator = [1, 2, 3][Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
  var element = _step.value;
  console.log(element);
}

// =&gt; 1 2 3
</code></pre>
<p>ES5 (approximates):</p>
<pre><code>// Using forEach()
// Doesn't require declaring indexing and element variables in your containing
// scope. They get supplied as arguments to the iterator and are scoped to just
// that iteration.
var a = [1,2,3];
a.forEach(function (element) {
    console.log(element);
});

// =&gt; 1 2 3

// Using a for loop
var a = [1,2,3];
for (var i = 0; i &lt; a.length; ++i) {
    console.log(a[i]);
}
// =&gt; 1 2 3
</code></pre>
<p>Note the use of <code>Symbol</code>. The ES5 equivalent would require a Symbol polyfill in order to correctly function.</p>
<h2><a id="user-content-classes" class="anchor" href="#classes" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Classes</h2>
<p>This implements class syntax and semantics as described in the ES6 draft spec. Classes are a great way to reuse code.
Several JS libraries provide classes and inheritance, but they aren't mutually compatible.</p>
<p>ES6:</p>
<pre><code>class Hello {
  constructor(name) {
    this.name = name;
  }

  hello() {
    return 'Hello ' + this.name + '!';
  }

  static sayHelloAll() {
    return 'Hello everyone!';
  }
}

class HelloWorld extends Hello {
  constructor() {
    super('World');
  }

  echo() {
    alert(super.hello());
  }
}

var hw = new HelloWorld();
hw.echo();

alert(Hello.sayHelloAll());
</code></pre>
<p>ES5 (approximate):</p>
<pre><code>function Hello(name) {
  this.name = name;
}

Hello.prototype.hello = function hello() {
  return 'Hello ' + this.name + '!';
};

Hello.sayHelloAll = function () {
  return 'Hello everyone!';
};

function HelloWorld() {
  Hello.call(this, 'World');
}

HelloWorld.prototype = Object.create(Hello.prototype);
HelloWorld.prototype.constructor = HelloWorld;
HelloWorld.sayHelloAll = Hello.sayHelloAll;

HelloWorld.prototype.echo = function echo() {
  alert(Hello.prototype.hello.call(this));
};

var hw = new HelloWorld();
hw.echo();

alert(Hello.sayHelloAll());
</code></pre>
<p>A more faithful (albeit, slightly verbose) interpretation can be found in this <a href="https://goo.gl/ZvEQDq">Babel</a> output.</p>
<h2><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules</h2>
<p>Modules are mostly implemented, with some parts of the Loader API still to be corrected. Modules try to solve many issues in dependencies and deployment, allowing users to create modules with explicit exports, import specific exported names from those modules, and keep these names separate.</p>
<p><em>Assumes an environment using CommonJS</em></p>
<p>app.js - ES6</p>
<pre><code>import math from 'lib/math';
console.log('2π = ' + math.sum(math.pi, math.pi));
</code></pre>
<p>app.js - ES5</p>
<pre><code>var math = require('lib/math');
console.log('2π = ' + math.sum(math.pi, math.pi));
</code></pre>
<p>lib/math.js - ES6</p>
<pre><code>export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
</code></pre>
<p>lib/math.js - ES5</p>
<pre><code>exports.sum = sum;
function sum(x, y) {
  return x + y;
}
var pi = exports.pi = 3.141593;
</code></pre>
<p>lib/mathplusplus.js - ES6</p>
<pre><code>export * from 'lib/math';
export var e = 2.71828182846;
export default function(x) {
  return Math.exp(x);
}
</code></pre>
<p>lib/mathplusplus.js - ES5</p>
<pre><code>var Math = require('lib/math');

var _extends = function (target) {
  for (var i = 1; i &lt; arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }

  return target;
};

var e = exports.e = 2.71828182846;
exports['default'] = function (x) {
  return Math.exp(x);
};

module.exports = _extends(exports['default'], exports);
</code></pre>
<h2><a id="user-content-numeric-literals" class="anchor" href="#numeric-literals" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Numeric Literals</h2>
<p>ES6:</p>
<pre><code>var binary = [
  0b0,
  0b1,
  0b11
];
console.assert(binary === [0, 1, 3]);

var octal = [
  0o0,
  0o1,
  0o10,
  0o77
];
console.assert(octal === [0, 1, 8, 63]);
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var binary = [0, 1, 3];
console.assert(binary === [0, 1, 3]);

var octal = [0, 1, 8, 63];
console.assert(octal === [0, 1, 8, 63]);
</code></pre>
<h2><a id="user-content-property-method-assignment" class="anchor" href="#property-method-assignment" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Property Method Assignment</h2>
<p>Method syntax is supported in object initializers, for example see toString():</p>
<p>ES6:</p>
<pre><code>var object = {
  value: 42,
  toString() {
    return this.value;
  }
};

console.log(object.toString() === 42);
// -&gt; true
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var object = {
  value: 42,
  toString: function toString() {
    return this.value;
  }
};

console.log(object.toString() === 42);
// -&gt; true
</code></pre>
<h2><a id="user-content-object-initializer-shorthand" class="anchor" href="#object-initializer-shorthand" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object Initializer Shorthand</h2>
<p>This allows you to skip repeating yourself when the property name and property value are the same in an object literal.</p>
<p>ES6:</p>
<pre><code>function getPoint() {
  var x = 1;
  var y = 10;

  return {x, y};
}

console.log(getPoint() === {
  x: 1,
  y: 10
});
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function getPoint() {
  var x = 1;
  var y = 10;

  return { x: x, y: y };
}

console.log(getPoint() === {
  x: 1,
  y: 10
});
</code></pre>
<h2><a id="user-content-rest-parameters" class="anchor" href="#rest-parameters" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rest Parameters</h2>
<p>Rest parameters allows your functions to have variable number of arguments without using the arguments object.
The rest parameter is an instance of Array so all the array methods just work.</p>
<p>ES6:</p>
<pre><code>function f(x, ...y) {
  // y is an Array
  return x * y.length;
}

console.log(f(3, 'hello', true) === 6);
// -&gt; true
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x) {
  var y = [];
  y.push.apply(y, arguments) &amp;&amp; y.shift();

  // y is an Array
  return x * y.length;
}

console.log(f(3, 'hello', true) === 6);
// -&gt; true
</code></pre>
<h2><a id="user-content-spread-operator" class="anchor" href="#spread-operator" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spread Operator</h2>
<p>The spread operator is like the reverse of rest parameters. It allows you to expand an array into multiple formal parameters.</p>
<p>ES6:</p>
<pre><code>function add(a, b) {
  return a + b;
}

let nums = [5, 4];

console.log(add(...nums));
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

var _toArray = function (arr) {
  return Array.isArray(arr) ? arr : [].slice.call(arr);
};

function add(a, b) {
  return a + b;
}

var nums = [5, 4];
console.log(add.apply(null, _toArray(nums)));
</code></pre>
<p>ES6:</p>
<pre><code>function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) === 6;
</code></pre>
<p>ES5:</p>
<pre><code>'use strict';

function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f.apply(null, [1, 2, 3]) === 6;
</code></pre>
<h2><a id="user-content-proxying-a-function-object" class="anchor" href="#proxying-a-function-object" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proxying a function object</h2>
<p>ES6:</p>
<pre><code>var target = function () {
  return 'I am the target';
};

var handler = {
  apply: function (receiver, ...args) {
    return 'I am the proxy';
  }
};

var p = new Proxy(target, handler);
console.log(p() === 'I am the proxy');
// -&gt; true
</code></pre>
<p>ES5:</p>
<p>No proxy in ES5, hard to intercept <strong>noSuchMethod</strong> and others.</p>
<h2><a id="user-content-array-like-object-to-array" class="anchor" href="#array-like-object-to-array" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array-like object to array</h2>
<p><strong>Array.from</strong> converts a single argument that is an array-like object or list (eg. <code>arguments</code>, <code>NodeList</code>, <code>DOMTokenList</code> (used by <code>classList</code>), <code>NamedNodeMap</code> (used by attributes property) into a new Array() and returns it.</p>
<p>ES6:</p>
<pre><code>var listFriends = function() {
  var friends = Array.from(arguments);
  friends.forEach(friend =&gt; {
    console.log(friend);
  });
};
listFriends('ann', 'bob');
// -&gt; 'ann'
// -&gt; 'bob'


var divs = document.querySelectorAll('div');
Array.from(divs).forEach(node =&gt; {
    console.log(node);
});
// -&gt; &lt;div&gt;...&lt;/div&gt;
// -&gt; &lt;div&gt;...&lt;/div&gt;
</code></pre>
<p>ES5:</p>
<pre><code>var listFriends = function() {
  var friends = [].slice.call(arguments)
  friends.forEach(function(friend) {
    console.log(friend);
  });
};
listFriends('ann', 'bob');
// -&gt; 'ann'
// -&gt; 'bob'


var divsArray = [].slice.call(document.querySelectorAll('div'));
divsArray.forEach(function(node) {
    console.log(node);
});
// -&gt; &lt;div&gt;...&lt;/div&gt;
// -&gt; &lt;div&gt;...&lt;/div&gt;
</code></pre>
</article>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-50" name="t-50"></a><h1>50 : JavaScript Inheritance Done Right</h1>
					<span class="ref-site">https://ncombo.wordpress.com/2013/07/11/javascript-inheritance-done-right/</span>
					<div class="tutorial__content">
<div class="entry-content">
					<p>One of the worst (and possibly also one of the best) things about JavaScript is that it offers you many ways to do anything. Some tricks are simple and neat while others can be complex and confusing.</p>
<p>If you have done some research, you will likely have come across many ways of implementing inheritance in JavaScript. I have personally used a lot of variations over time in various projects but it's not until recently that I have settled on a particular technique.</p>
<p>I have chosen this particular technique because I feel that it most closely resembles how most OO programming languages implement inheritance. To get it to work properly, you should use the prototype-based method of class definition. Here is an example of the technique in action:</p>
<blockquote><p>
function BaseClass(name) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="skimlinks-unlinked">this.name</span> = name;<br>
}</p>
<p><span class="skimlinks-unlinked">BaseClass.prototype.foo</span> = function (arg) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ‘This is the foo method with argument: ‘ + arg;<br>
};</p>
<p>function SubClass(name) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Call the base class' constructor.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="skimlinks-unlinked">BaseClass.call(this</span>, name);<br>
}</p>
<p>// SubClass' prototype is based on BaseClass' prototype<br>
SubClass.prototype = Object.create(BaseClass.prototype);</p>
<p><span class="skimlinks-unlinked">SubClass.prototype.sub</span> = function () {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return ‘This is the sub method.'<br>
}</p>
<p><span class="skimlinks-unlinked">SubClass.prototype.foo</span> = function (arg) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Call the base class foo method on the current instance<br>
&nbsp;&nbsp;&nbsp;&nbsp;return <span class="skimlinks-unlinked">BaseClass.prototype.foo.call(this</span>, arg) + ‘ SUB';<br>
}</p></blockquote>
<p>Ok, so what stands out the most in this code is this line:</p>
<blockquote><p>SubClass.prototype = Object.create(BaseClass.prototype);</p></blockquote>
<p>When you define a function in JavaScript, initially, its prototype will be an empty object. What we're doing here is setting the SubClass' prototype to be a new instance which shares the BaseClass' prototype. Effectively, this allows us to freely modify the SubClass' extended prototype without messing with the BaseClass' prototype – The advantage of this technique over simply cloning the prototype is that changes in the BaseClass prototype will still be reflected in the SubClass (but not the other way around). The best way to think about the Object.create() method is that it instantiates a class based on a prototype without actually going through its constructor. The Object.create() function may not be supported by older browsers, but thankfully there is a simple polyfill which you can get from this page:<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></p>
<p>The second weird thing about the code above is this line:</p>
<p><span class="skimlinks-unlinked">BaseClass.call(this</span>, name);</p>
<p>Now if you don't know what call or apply do, you should check this:<br>
<a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply">http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply</a></p>
<p>OO languages usually offer a way to explicitly call a super class' constructor or method, JavaScript is no exception. With JavaScript, you just call the constructor/method using either call() or apply() and pass a reference to the current instance as the first argument. This is a neat feature of JavaScript which allows you to effectively borrow methods from any other class to use on the current instance.</p>
<p>If you're used to languages like Java, C# and Python, you might find the class definitions above unusual – In these languages you have an explicit ‘class' keyword and you define the methods INSIDE the class block. If however, you have written C++ before, this might seem a little less confusing because C++ allows you to define methods of a class outside of the class definition block.&nbsp;While JavaScript does let you define methods inside the constructor's function block, this makes inheritance more difficult to achieve and I would strongly recommend that you follow the technique above (I swear you won't regret it).</p>
										</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-51" name="t-51"></a><h1>51 : Javascript Inheritance Done Right</h1>
					<span class="ref-site">http://js-bits.blogspot.com/2010/08/javascript-inheritance-done-right.html</span>
					<div class="tutorial__content">
<div class="post-body entry-content" id="post-body-578868776986553481" itemprop="description articleBody">
I've seen a number of different ways of implementing Javascript inheritance. The real test to see if inheritance is working correctly is that the instanceof operator works correctly. So all the approaches that <a href="http://www.sitepoint.com/blogs/2006/01/17/javascript-inheritance/">copy methods</a> from the base to the subclass are out of the question because they do not correctly setup the prototype chain. Another consequence of inheritance by copying is that if you change the prototype after the object has been instantiated, the object does not magically inherit the added property. <br>
<br>
This leads me to the most common approach which does correctly set up prototype chain but has a few problems:<br>
<br>
<div><pre><code>function Animal(name) {
&nbsp;&nbsp;this.name = name;
}
&nbsp;
// This style of setting the prototype to an object
// works for classes that inherit from Object.
Animal.prototype = {
&nbsp;&nbsp;sayMyName: function() {
&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.getWordsToSay() + " " + this.name);
&nbsp;&nbsp;},
&nbsp;&nbsp;getWordsToSay: function() {
&nbsp;&nbsp;&nbsp;&nbsp;// Abstract
&nbsp;&nbsp;}
}
&nbsp;
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor
&nbsp;&nbsp;Animal.call(this, name);
}
&nbsp;
// Setup the prototype chain mmm... calling
// the Animal without the required params?
Dog.prototype = new Animal();
&nbsp;
Dog.prototype.getWordsToSay = function(){
&nbsp;&nbsp;return "Ruff Ruff";
}
&nbsp;
var dog = new Dog("Lassie");
dog.sayMyName(); // Outputs Ruff Ruff Lassie
console.log(dog instanceof Animal); // true
console.log(dog.constructor); // Animal ???? That's not right
console.log("name" in Dog.prototype)// true, but undefined
</code></pre></div><br>
Alright, what's going on?<br>
<ul><li>Dog.prototype now has a property called "name" that is set to undefined. <br>
That wasn't intentional. I knew that call to Animal's constructor was funny. Though that won't cause a problem, because we add a "name" to the object in the constructor, it's not very elegant</li>
<li>dog (the instance) has a constructor property but it points to Animal,<br>
that's just wrong</li>
</ul><br>
How can we fix that? Here's a first try<br>
<br>
<div><pre><code>// This is a constructor that is used to setup inheritance without
// invoking the base's constructor. It does nothing, so it doesn't
// create properties on the prototype like our previous example did
function surrogateCtor() {}
&nbsp;
function extend(base, sub) {
&nbsp;&nbsp;// Copy the prototype from the base to setup inheritance
&nbsp;&nbsp;surrogateCtor.prototype = base.prototype;
&nbsp;&nbsp;// Tricky huh?
&nbsp;&nbsp;sub.prototype = new surrogateCtor();
&nbsp;&nbsp;// Remember the constructor property was set wrong, let's fix it
&nbsp;&nbsp;sub.prototype.constructor = sub;
}
&nbsp;
// Let's try this
function Animal(name) {
&nbsp;&nbsp;this.name = name;
}
&nbsp;
Animal.prototype = {
&nbsp;&nbsp;sayMyName: function() {
&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.getWordsToSay() + " " + this.name);
&nbsp;&nbsp;},
&nbsp;&nbsp;getWordsToSay: function() {
&nbsp;&nbsp;&nbsp;&nbsp;// Abstract
&nbsp;&nbsp;}
}
&nbsp;
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor
&nbsp;&nbsp;Animal.call(this, name);
}
&nbsp;
// Setup the prototype chain the right way
extend(Animal, Dog);
&nbsp;
Dog.prototype.getWordsToSay = function(){
&nbsp;&nbsp;return "Ruff Ruff";
}
&nbsp;
var dog = new Dog("Lassie");
dog.sayMyName(); // Outputs Ruff Ruff Lassie
console.log(dog instanceof Animal); // true
console.log(dog.constructor); // Dog
console.log("name" in Dog.prototype)// false
</code></pre></div><br>
Nice isn't it? Let's add some syntactic sugar to make it more user friendly.<br>
<ul><li>Add a reference to the base class so we don't have to hard code it</li>
<li>Pass the object's prototype methods into the call</li>
</ul><br>
<br>
<div><pre><code>function surrogateCtor() {}
&nbsp;
function extend(base, sub, methods) {
&nbsp;&nbsp;surrogateCtor.prototype = base.prototype;
&nbsp;&nbsp;sub.prototype = new surrogateCtor();
&nbsp;&nbsp;sub.prototype.constructor = sub;
&nbsp;&nbsp;// Add a reference to the parent's prototype
&nbsp;&nbsp;sub.base = base.prototype;
&nbsp;
&nbsp;&nbsp;// Copy the methods passed in to the prototype
&nbsp;&nbsp;for (var name in methods) {
&nbsp;&nbsp;&nbsp;&nbsp;sub.prototype[name] = methods[name];
&nbsp;&nbsp;}
&nbsp;&nbsp;// so we can define the constructor inline
&nbsp;&nbsp;return sub;
}
&nbsp;
// Use the same animal from above
function Dog(name) {
&nbsp;&nbsp;// Call the parent's constructor without hard coding the parent
&nbsp;&nbsp;Dog.base.constructor.call(this, name);
}
&nbsp;
extend(Animal, Dog, {
&nbsp;&nbsp;getWordsToSay: function(){
&nbsp;&nbsp;&nbsp;&nbsp;return "Ruff Ruff";
&nbsp;&nbsp;}
});
</code></pre></div><br>
One more step, I don't even like hard coding the name of the class in the methods in case I rename it, how can we fix that?<br>
<br>
The solution is to wrap everything in a self executing function and create a reference to the constructor<br>
<br>
<div><pre><code>Dog = (function(){
&nbsp;&nbsp;// $this refers to the constructor
&nbsp;&nbsp;var $this = function (name) {
&nbsp;&nbsp;&nbsp;&nbsp;// Look, no hardcoded reference to this class's name
&nbsp;&nbsp;&nbsp;&nbsp;$this.base.constructor.call(this, name);
&nbsp;&nbsp;};
&nbsp;
&nbsp;&nbsp;extend(Animal, $this, {
&nbsp;&nbsp;&nbsp;&nbsp;getWordsToSay: function(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Ruff Ruff";
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;});
&nbsp;
&nbsp;&nbsp;return $this;
})();
</code></pre></div><br>
With this final approach, renaming the class or changing its parent requires changing a single place (for each change).

<h3>Update</h3>
<p>This article was written a while ago, when <a href="">Object.create</a> wasn't as well supported. The extend function could be simplified to be</p>
<div><pre><code>function extend(base, sub, methods) {
&nbsp;&nbsp;sub.prototype = Object.create(base.prototype);
&nbsp;&nbsp;sub.prototype.constructor = sub;
&nbsp;&nbsp;sub.base = base.prototype;
&nbsp;
&nbsp;&nbsp;// Copy the methods passed in to the prototype
&nbsp;&nbsp;for (var name in methods) {
&nbsp;&nbsp;&nbsp;&nbsp;sub.prototype[name] = methods[name];
&nbsp;&nbsp;}
&nbsp;&nbsp;// so we can define the constructor inline
&nbsp;&nbsp;return sub;
}
</code></pre></div><br>

</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-52" name="t-52"></a><h1>52 : Basic Inheritance with JavaScript Constructors</h1>
					<span class="ref-site">http://adripofjavascript.com/blog/drips/basic-inheritance-with-javascript-constructors.html</span>
					<div class="tutorial__content">
<div class="post">
<p>We've looked before at using JavaScript's constructors to create our own custom object types. But what we didn't look at was how we can create an inheritance hierarchy.</p>

<p>It's important to note that even though constructors are often referred to as "classes," they really aren't the same thing as classes in other languages. In JavaScript, a constructor is just a function invoked by the <code>new</code> operator which builds a new object.</p>

<p>Here's a little refresher:</p>
<pre><code>function SuperHuman (name, superPower) {
    this.name = name;
    this.superPower = superPower;
}

SuperHuman.prototype.usePower = function () {
    console.log(this.superPower + "!");
};

var banshee = new SuperHuman("Silver Banshee", "sonic wail");

// Outputs: "sonic wail!"
banshee.usePower();
</code></pre>
<p>The <code>SuperHuman</code> constructor contains our initialization logic, while <code>SuperHuman.prototype</code> contains the methods that are shared across all <code>SuperHuman</code> instances.</p>

<p>But suppose that we want to create a new type which inherits from <code>SuperHuman</code> while adding its own functionality? What would that look like?</p>
<pre><code>function SuperHero (name, superPower) {
    this.name = name;
    this.superPower = superPower;
    this.allegiance = "Good";
}

SuperHero.prototype.saveTheDay = function () {
    console.log(this.name + " saved the day!");
};

var marvel = new SuperHero("Captain Marvel", "magic");

// Outputs: "Captain Marvel saved the day!"
marvel.saveTheDay();
</code></pre>
<p>While this gets us started, there are a couple of problems. First of all, the <code>SuperHero</code> constructor is repeating some of the logic of the <code>SuperHuman</code> constructor. And more importantly, at this point instances of <code>SuperHero</code> don't have access to <code>SuperHuman</code> methods. For example:</p>
<pre><code>// TypeError: Object &lt;#SuperHero&gt; has no method 'usePower'
marvel.usePower();
</code></pre>
<p>Let's fix those couple of issues.</p>
<pre><code>function SuperHero (name, superPower) {
    // Reuse SuperHuman initialization
    SuperHuman.call(this, name, superPower);

    this.allegiance = "Good";
}

SuperHero.prototype = new SuperHuman();

SuperHero.prototype.saveTheDay = function () {
    console.log(this.name + " saved the day!");
};

var marvel = new SuperHero("Captain Marvel", "magic");

// Outputs: "Captain Marvel saved the day!"
marvel.saveTheDay();

// Outputs: "magic!"
marvel.usePower();
</code></pre>
<p>We've managed to eliminate the repeated constructor logic by calling <code>SuperHuman</code> with <code>SuperHero</code>'s <code>this</code> object and passing along the necessary arguments. That ensures that <code>SuperHuman</code>'s initialization logic will act on the new <code>SuperHero</code> object. And then we tack on the additional logic that is specific to <code>SuperHero</code>.</p>

<p>But where the inheritance comes in is on <code>SuperHero.prototype</code>. In order to ensure that it inherits the methods from <code>SuperHuman.prototype</code>, we actually make it an instance of <code>SuperHuman</code> with <code>new SuperHuman()</code>.</p>

<p>This basic inheritance pattern won't always work, particularly if the parent constructor is complex, but it will handle simple situations quite well.</p>

<p>In future issues we'll take a look at more sophisticated ways of doing inheritance.</p>

    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-53" name="t-53"></a><h1>53 : Call and Apply for Beginners</h1>
					<span class="ref-site">http://ryanchristiani.com/call-and-apply-for-beginners/</span>
					<div class="tutorial__content">
<div class="entry">
	<p>As you advance as a junior front-end developer you will see Javascript code that looks more and more like this.</p>
<pre><code>$.when.apply(null, promiseArray)
 .then(function() {
    var data = arguments;
    ...
 });</code></pre>
<p><span id="more-885"></span></p>
<p>The <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> methods are powerful tools in Javascript, however they can be hard to understand for a young developer, or even for a seasoned developer! The call and apply methods that people will always ask about in interviews, but when you are writing your own Javascript you can never really think of a good reason to use them, or see a need to use them. Lets break down the difference between them, and look at some practical uses for them. We will also look at some new features from ECMAScript2015 (ES6) that can help us simplify the use of these!</p>
<h3 id="i-have-already-read-this-article">I have already read this article!?</h3>
<p>There are a lot of articles out there about this concept. However recently teaching some students, there have been a few cases where <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> has been used to really simplify things. So I wanted to write an article that has some simple break downs and examples of how to use these methods.</p>
<h2 id="scope">Scope</h2>
<p>You can't really talk about <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> without first talking about scope in Javascript. Hopefully the concept of global and local scope is something that you understand, if it is not lets do a quick run down about how that works.</p>
<p>In Javascript if you define anything that is not inside of a function, or something without the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword. This variable is considered to be global, meaning it can be accessed anywhere in your program.</p>
<pre><code>var name = "Ryan";

function sayName() {
    console.log('Hi ' + name + '!');
}
console.log(name); //Ryan
sayName(); //Hi Ryan!</code></pre>
<p>Here we created a variable outside of the function <code class=" language-javascript">sayName</code> so it is accessible inside the function as well as outside of it. If we had done something like this however:</p>
<pre><code>function sayName() {
    name = "Ryan";
    console.log('Hi ' + name + '!');
}
console.log(name); //Ryan
sayName(); //Hi Ryan!</code></pre>
<p>This would still work. Because we have created a variable without the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword, it is by default a global variable. However, when you use the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword and create a variable inside of a function, that is considered to be a local variable. And only accessible inside that function.</p>
<pre><code>function sayName() {
    var name = "Ryan";
    console.log('Hi ' + name + '!');
}
console.log(name); //undefined
sayName(); //Hi Ryan!</code></pre>
<p>So now <code class=" language-javascript">name</code> is scoped locally to just the <code class=" language-javascript">sayName</code> function.</p>
<p>In Javascript we have have the <code class=" language-javascript">this</code> keyword. The context that <code class=" language-javascript">this</code> refers too changes based on a few things. By default if you just open the console in your browser, <code class=" language-javascript">this</code> will refer to the global object. In the case of the browser this is the <code class=" language-javascript">window</code> object, in node it refers to a different global. </p>
<p>When we use the <code class=" language-javascript">this</code> keyword inside of an object, <code class=" language-javascript">this</code> will refer to the object itself.</p>
<pre><code>var person = {
    name: "Ryan Christiani",
    sayName: function() {
        console.log("Hi " + this.name + "!");
    }
}
person.sayName(); //Hi Ryan!</code></pre>
<p>So it is scoped just to that object. Let's see how using <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> can help us change <code class=" language-javascript">this</code>.</p>
<h2 id="call"><code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code></h2>
<p>Functions in JavaScript have a method named <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank"><code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code></a>. It is used to call a function or method, but you are able to determine the context in which it is being called. For example. Assume we have a <code class=" language-javascript">person</code> object that just has a single property on it.</p>
<pre><code>var person = {
    name: "Ryan"
};</code></pre>
<p>Also assume we have a function called <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> that simply prints out a name property from <code class=" language-javascript">this</code>.</p>
<pre><code>function sayName() {
    console.log(this.name);
}</code></pre>
<p>Running <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> like this will not work. It will try to grab a property from the <code class=" language-javascript">window</code> object first. However if we use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can pass in and specify what context we want <code class=" language-javascript">this</code> to be in our function.</p>
<pre><code>sayName.call(person); //Ryan</code></pre>
<p>Great! Now we have the power to call functions and alter the context in which they are executed on the fly!</p>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can also apply our arguments to a function. For example, lets change the <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token punctuation">)</span></code> function to accept a parameter.</p>
<pre><code>function sayName(greetings) {
    console.log(greetings +  ' ' + this.name);
}</code></pre>
<p>Normally we could just call this function like <code class=" language-javascript">sayName<span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span></code>. However our function has no property <code class=" language-javascript">name</code>. So we have to use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> to tell this function to use <code class=" language-javascript">person</code> as the <code class=" language-javascript">this</code> in the function, and with <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can tell it what arguments call uses!</p>
<pre><code>sayName.call(person,'Hello'); //Hello Ryan</code></pre>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we are able to specify the context of <code class=" language-javascript">this</code> in our function, as well as the arguments we want to supply to the function. If you have more than one argument, we just add them to the <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span>context<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span>arg3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code>.</p>
<h2 id="apply"><code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code></h2>
<p>The <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> method is similar to <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> however it allows us to pass an array of arguments instead of one at a time. This is very useful. Lets look at a simple, but very common, example. <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code> only takes a list of arguments, but maybe you are provided with an array of arguments.</p>
<pre><code>var numbers = [12,34,62,54,12];</code></pre>
<p>You could, assuming you know that the length of the array will always be the same, do something like this.</p>
<pre><code>Math.max(numbers[0],numbers[1],numbers[2],numbers[3],numbers[4]);</code></pre>
<p>However there are two things wrong with this code. One is that we are <strong>very</strong> dependent on the length of the array always being the same, what if we have one more or one less? Also we are doing a lot of writing here. And that is just no good.</p>
<p>With <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can simplify this a bit more!</p>
<pre><code>Math.max.apply(null,numbers) // 62</code></pre>
<p>Using the same pattern as with <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we specify a context to call <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code> and supply the arguments. In the case of our arguments it is just our array <code class=" language-javascript">numbers</code>. Our context for this will just be <code class=" language-javascript"><span class="token keyword">null</span></code>, since we do no really care about that from <code class=" language-javascript">Math<span class="token punctuation">.</span>max</code>. Internally the JS engine will do something like this.</p>
<pre><code>Math.max(12,34,62,54,12);</code></pre>
<p>Not that exactly, but something like it. Hopefully this gives you an idea of what it is doing!</p>
<p>Lets write our own function that expects an array of arguments. It will be very simple, just to get the point across. </p>
<pre><code>function printNames() {
    for(var i = 0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    }
}</code></pre>
<p>Here is a simple function that prints out a list of names. But WAIT! What is <code class=" language-javascript">arguments</code>?! Just like the <code class=" language-javascript">this</code> keyword every function has a special key word called <code class=" language-javascript">arguments</code>. This is an <strong>array like</strong>(more on this later) list of the arguments used to call this function. For example.</p>
<pre><code>function printArgs() {
    console.log(arguments);
}
printArgs('hey',32,'Neat'); //['hey',32,'Neat']</code></pre>
<p>Notice how in our function definition we never define parameters for our function to accept. The function we wrote earlier, <code class=" language-javascript">printNames</code> uses the same principle. Lets assume you get an array of names, again you do not know what the length will be. Using <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> we can call this function with this array!</p>
<pre><code>printNames.apply(null,['Ryan','Kristen','Drew']);</code></pre>
<p>This will print out the names! </p>
<h3 id="agruments"><code>agruments</code></h3>
<p>Above I mentioned that <code class=" language-javascript">arguments</code> is an <strong>array like</strong> list, meaning is it not actually an array. What does that mean? Well it means we don't get all the methods you are used to from arrays. Methods like <code class=" language-javascript"><span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>, or <code class=" language-javascript"><span class="token punctuation">.</span>splice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. If you try to call <code class=" language-javascript">arguments<span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code>, you will get <code class=" language-markup">TypeError: arguments.slice is not a function</code>. </p>
<p>However, we have learned how to fix this already! We can use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. These methods from the array live on the <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype</code> so in order for us to use something like slice, we need to use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code>.</p>
<pre><code>function printArgs() {
    var slicedArgs = Array.prototype.slice.call(arguments,1);
    console.log(slicedArgs);
}

printsArgs(['Ryan','Kristen','Drew']) // ['Kristen', 'Drew']</code></pre>
<p>We use <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> on <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice</code>, we set <code class=" language-javascript">arguments</code> as the context of the method and provide our argument to use for <code class=" language-javascript"><span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token punctuation">)</span></code>! Using <code class=" language-javascript"><span class="token punctuation">.</span>call<span class="token punctuation">(</span><span class="token punctuation">)</span></code> to manipulate <code class=" language-javascript">arguments</code> is a very common pattern you will see. But let's now look at a different way of doing this!</p>
<h1 id="a-different-way"><a name="user-content-a-different-way" href="#a-different-way" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>A Different way</h1>
<p><code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> and <code class=" language-javascript">arguments</code> are great, but what if there was a better way to do this? A way that was less verbose? In ECMAScript 2015 (ES6) we get two new features. The Spread Operator and Rest Parameters. Lets look at how we can use these to do something similar to using <code class=" language-javascript"><span class="token punctuation">.</span>apply</code> and <code class=" language-javascript">arguments</code>.</p>
<h2 id="spread-operator"><a name="user-content-spread-operator" href="#spread-operator" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Spread Operator</h2>
<p>The Spread Operator is a new feature that we can use to, well, spread our arguments. The syntax for the Spread Operator is <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arrayName</code>, consider the function below.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print() {
    for(var i = 0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    } 
}

print(...names);</code></pre>
<p>What the Spread Operator is doing, is something similar to <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code>. </p>
<pre><code>print('Ryan','Drew','Kristen','Wes');</code></pre>
<p>You can actually mix and match the use of the Spread Operator.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print() {
    var nameList = Array.prototype.slice.call(arguments,1);
    for(var i = 0; i &lt; nameList.length; i++) {
        console.log(arguments[0] +  ' ' + nameList[i]);
    } 
}

print('Hello',...names);</code></pre>
<p>In this new addition to the function we use a pattern we saw earlier to store a version <code class=" language-javascript">arguments</code> into a new variable called <code class=" language-javascript">nameList</code>. We also use <code class=" language-javascript">arguments</code> to access the string <code class=" language-javascript">Hello</code> from the function call. This is getting a little out there however, there is a lot going on. We are utilizing what we learned earlier, but this can get better! </p>
<p>Before we move on I just want to point out that the Spread Operator is not a replacement for <code class=" language-javascript"><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token punctuation">)</span></code> in all cases, it does not allow us to control the context of a function call, rather it helps us with arrays of values we need to supply to functions.</p>
<h2 id="rest-parameters"><a name="user-content-rest-parameters" href="#rest-parameters" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Rest Parameters</h2>
<p>The flip side of the Spread Operator is Rest Parameters. We can use this as a solution to the array like nature of <code class=" language-javascript">arguments</code>. The syntax looks like this <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args</code>, pretty much exactly like the Spread Operator! The difference here is where you use the syntax. Let's change our function above to work with Rest Parameters.</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print(greetings, ...nameList) {
    for(var i = 0; i &lt; nameList.length; i++) {
        console.log(greetings +  ' ' + nameList[i]);
    } 
}

print('Hello',...names);</code></pre>
<p>Here we add the <code class=" language-javascript">greetings</code> parameter as well as this new <code class=" language-javascript"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>nameList</code>. We now get access to an actual array in the form on <code class=" language-javascript">nameList</code>. Because of this we can change the <code class=" language-javascript"><span class="token keyword">for</span></code> loop to be an <code class=" language-javascript"><span class="token punctuation">.</span>forEach<span class="token punctuation">(</span><span class="token punctuation">)</span></code> loop, since that is an Array method!</p>
<pre><code>var names = ['Ryan','Drew','Kristen','Wes'];
function print(greetings, ...nameList) {
    nameList.forEach(function(name) {
        console.log(greetings +  ' ' + name);
    })
}

print('Hello',...names);</code></pre>
<p>That looks a little nicer!</p>
<p>For more information about these check out <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank">Rest Parameters</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">Spread Operator</a> on MDN. Note that these features are very new and only available in browsers that support ECMASCript 2015. However check out my post on <a href="http://ryanchristiani.com/es6es2015-easy-wins/">ES6 easy wins</a> to find out about some new features and also how you can use them today! (hint, it's <a href="https://babeljs.io" target="_blank">Babel</a>).</p>
<p>Hope that helps!</p>
				</div>
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-54" name="t-54"></a><h1>54 : Understanding JavaScript Constructors</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
<div class="article-content">

                
      
      <p><em class="explanation">The following is a guest post by <a href="http://eloux.com/">Faraz Kelhini</a>. Some of this stuff is out of my comfort zone, so I asked <a href="http://getify.me/">Kyle Simpson</a> to tech check it for me. Kyle's answer (which we did during an <a href="https://css-tricks.com/lodge/office-hours/">Office Hours</a> session) was very interesting. It was: 1) This article is technically sound. JavaScript doesn't really have classes in a traditional sense and this is the way most people shoehorn them in. 2) We may want to stop shoehorning them in. JavaScript has objects and we can use them in the way they are intended to do the same kinds of things. Kyle calls it OLOO (Objects Linked to Other Objects). <a href="http://stackoverflow.com/questions/29788181/kyle-simpsons-oloo-pattern-vs-prototype-design-pattern">Here's an intro.</a> I'd think there is value in learning about both.</em></p>
<p><span id="more-208618"></span></p>
<p>Having a good understanding of constructors is crucial to truly understand the JavaScript language. Unlike many other languages, JavaScript doesn't support classes, but it has constructors to bring similar functionality to JavaScript. In this tutorial, we will explore constructors in detail and see how JavaScript utilizes them to make objects.<br>
Constructors are like regular functions, but we use them with the "new" keyword. There are two types of constructors: native (aka built-in) constructors like <code>Array</code> and <code>Object</code>, which are available automatically in the execution environment at runtime; and custom constructors, which define properties and methods for your own type of object.</p>
<p>A constructor is useful when you want to create multiple similar objects with the same properties and methods. It’s a convention to capitalize the name of constructors to distinguish them from regular functions. Consider the following code:</p>
<pre><code>function Book() { 
  // unfinished code
} 
var myBook = new Book();</code></pre>
<p>The last line of the code creates an instance of Book and assigns it to a variable; even though the Book constructor doesn't do anything, myBook is still an instance of it. As you can see there is no difference between this function and regular functions except that we call it with the <code>new</code> keyword and the function name is capitalized.</p><div class="launchbit-ad-wrapper"><div id="bsa-ad-1" class="launchbit-ad"><a class="launchbit-in-article" href="//srv.buysellads.com/ads/click/x/GTND4237C67I62J7CTSLYKQWF6YI623UCABDPZ3JCEAI4KQUCKSI627KC6BDLKQIC6BDVK3EHJNCLSIZ" target="_blank"><img src="//assets.servedby-buysellads.com/p/manage/asset/id/37874" alt="" class="launchbit-img">See The 3 Use Cases of How Our DevOp Teams Automate Development<img src="https://www.launchbit.com/taz-pixel/11315-6651-111" border="0" height="1" width="1" style="display: none;"></a></div></div>
<h3 id="article-header-id-0" class="has-header-link"><a class="article-headline-link" href="#article-header-id-0">#</a>Determining the Type of an Instance</h3>
<p>To find out whether an object is an instance of another one, we use the instanceof operator:</p>
<pre><code>myBook instanceof Book    // true
myBook instanceof String  // false</code></pre>
<p>Note that if the right side of the instanceof operator isn’t a function, it will throw an error:</p>
<pre><code>myBook instanceof {};
// TypeError: invalid 'instanceof' operand ({})</code></pre>
<p>Another way to find the type of an instance is using the constructor property. All object instances have a constructor property that point to the constructor function that created it.</p>
<p>Consider the following code fragment:</p>
<pre><code>myBook.constructor == Book;   // true</code></pre>
<p>Since the constructor property of myBook points to Book the result is true. All objects inherit a constructor property from their prototype:</p>
<pre><code>var s = new String("text");
s.constructor === String;      // true

"text".constructor === String; // true

var o = new Object();
o.constructor === Object;      // true

var o = {};
o.constructor === Object;      // true

var a = new Array();
a.constructor === Array;       // true

[].constructor === Array;      // true</code></pre>
<p>Although checking constructor property can be used to check the type of an instance, it is recommended to only use the instanceof operator for this purpose, because the constructor property might be overwritten, so it cannot be a reliable method for checking the type of an instance.</p>
<h3 id="article-header-id-1" class="has-header-link"><a class="article-headline-link" href="#article-header-id-1">#</a>Custom Constructor Functions</h3>
<p>A constructor is like a cookie cutter to make more than one object with similar features. In other words, the benefit of using a constructor is that it makes it easy to create multiple objects with the same properties and methods.</p>
<p>Consider the following code:</p>
<pre><code>function Book(name, year) {
  this.name = name;
  this.year = '(' + year + ')';
}</code></pre>
<p>The book constructor expects two parameters: <code>name</code> and <code>year</code>; when it is called with the <code>new</code> keyword it assigns the received parameters to the name and year property of the current instance so the constructor can be used to create objects with initialized <code>name</code> and <code>year</code> properties: </p>
<pre><code>var firstBook = new Book("Pro AngularJS", 2014);
var secondBook = new Book("Secrets Of The JavaScript Ninja", 2013); 
var thirdBook = new Book("JavaScript Patterns", 2010);
 
console.log(firstBook.name, firstBook.year);           
console.log(secondBook.name, secondBook.year);           
console.log(thirdBook.name, thirdBook.year);  </code></pre>
<p>This code logs the following in the console:</p>
<figure id="post-208619" class="align-right media-208619"><img sizes="(min-width: 1850px) calc( (100vw - 555px) / 3 )
       (min-width: 1251px) calc( (100vw - 530px) / 2 )
       (min-width: 1086px) calc(100vw - 480px)
       (min-width: 626px)  calc(100vw - 335px)
                           calc(100vw - 30px)" srcset="https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log.png 744w, https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-300x68.png 300w" src="//cdn.css-tricks.com/wp-content/uploads/2015/09/console-log.png" alt=""></figure>
<p>As you can see, we can quickly build a large number of different book objects by invoking the Book constructor with different arguments. This is exactly the same pattern that JavaScript uses in its built-in constructors like <code>Array()</code> and <code>Date()</code>.</p>
<h3 id="article-header-id-2" class="has-header-link"><a class="article-headline-link" href="#article-header-id-2">#</a>Object.defineProperty Function</h3>
<p>The <code>Object.defineProperty()</code> can be used inside of a constructor to help perform all necessary property setup. Consider the following constructor:</p>
<pre><code>function Book(name) { 
  Object.defineProperty(this, "name", { 
      get: function() { 
        return "Book: " + name;       
      },        
      set: function(newName) {            
        name = newName;        
      },               
      configurable: false     
   }); 
}

var myBook = new Book("Single Page Web Applications");
console.log(myBook.name);    // Book: Single Page Web Applications

// we cannot delete the name property because "configurable" is set to false
delete myBook.name;    
console.log(myBook.name);    // Book: Single Page Web Applications

// but we can change the value of the name property
myBook.name = "Testable JavaScript";
console.log(myBook.name);    // Book: Testable JavaScript</code></pre>
<p>In this code we used accessor properties inside the <code>Object.defineProperty()</code>. Accessor properties don’t include any properties or methods, but they define a getter to call when the property is read, and a setter to call when the property is written to.</p>
<p>A getter is expected to return a value, while a setter receives the value being assigned to the property as an argument. This constructor allows us to set or change the name property of instances, but we are not allowed to delete it, and when we get the value of name, the getter prepends the string "Book: " to the name and returns it.</p>
<h3 id="article-header-id-3" class="has-header-link"><a class="article-headline-link" href="#article-header-id-3">#</a>Object Literal Notations are Preferred to Constructors</h3>
<p>The JavaScript language has nine built-in constructors: <code>Object()</code>, <code>Array()</code>, <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>, <code>Date()</code>, <code>Function()</code>, <code>Error()</code> and <code>RegExp()</code>. When creating values we are free to use either object literals or constructors, but object literals are not only easier to read but also faster to run because they can be optimize at parse time. Whenever we need simple objects it's best to stick with literals:</p>
<pre><code>// a number object
// numbers have a toFixed() method
var obj = new Object(5);
obj.toFixed(2);     // 5.00

// we can achieve the same result using literals
var num = 5;
num.toFixed(2);     // 5.00

// a string object
// strings have a slice() method 
var obj = new String("text");
obj.slice(0,2);     // "te"

// same as above
var string = "text";
string.slice(0,2);  // "te"</code></pre>
<p>As you can see there's hardly any difference between these object literals and constructors and we can still call methods on literals. It's because when we call a method on a literal, behind the scene JavaScript converts the literal to a temporary object so that it's possible to use object methods for primitive values, then JavaScript discards the temporary object. </p>
<h3 id="article-header-id-4" class="has-header-link"><a class="article-headline-link" href="#article-header-id-4">#</a>Using the "new" Keyword is Essential</h3>
<p>It's important to remember to use the <code>new</code> keyword before all constructors, if we accidentally forget "new" we will be modifying the global object instead of the newly created object. Consider the following example:</p>
<pre><code>function Book(name, year) {
  console.log(this);
  this.name = name;
  this.year = year;
}

var myBook = Book("js book", 2014);  
console.log(myBook instanceof Book);  
console.log(window.name, window.year);

var myBook = new Book("js book", 2014);  
console.log(myBook instanceof Book);  
console.log(myBook.name, myBook.year);</code></pre>
<p>When we call the Book constructor without <code>new</code> keyword, in fact we are just calling a function without a return statement and "this" inside the Book constructor will be equal to Window (instead of myBook), in other words we have unintentionally created two global variables which causes the code to produce unintended results, but when we call the function with the "new" keyword the context is switched from global (window) to the instance, therefore "this" points to myBook. Here is what the above code logs in browser console:</p>
<figure id="post-208621" class="align-right media-208621"><img sizes="(min-width: 1850px) calc( (100vw - 555px) / 3 )
       (min-width: 1251px) calc( (100vw - 530px) / 2 )
       (min-width: 1086px) calc(100vw - 480px)
       (min-width: 626px)  calc(100vw - 335px)
                           calc(100vw - 30px)" srcset="https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2.png 766w, https://cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2-300x91.png 300w" src="//cdn.css-tricks.com/wp-content/uploads/2015/09/console-log-2.png" alt=""></figure>
<p>Note that in strict mode this code throws an error because strict mode protects us from accidentally calling a constructor without the <code>new</code> keyword.</p>
<h3 id="article-header-id-5" class="has-header-link"><a class="article-headline-link" href="#article-header-id-5">#</a>Scope-Safe Constructors</h3>
<p>Since a constructor is just a function, it can be called without the <code>new</code> keyword, but this leads to unexpected results and errors especially for inexperienced programmers. The solution to this problem is scope-safe constructors.  We can call Scope-safe constructors with or without new keyword and they return the same result in either form.</p>
<p>Most of built-in constructors, such as Object, Regex and Array, are scope-safe. They use a pattern to determine whether the constructor is called with <code>new</code> or not.</p>
<p>If new isn't used, a proper instance of the object is created by calling the constructor again with <code>new</code> keyword. Consider the following code:</p>
<pre><code>function Book(name) { 
  if (!(this instanceof Book)) { 
    
    // the constructor was called without "new".
    return new Book(name);
  } 
}</code></pre>
<p>So using this pattern we can easily rewrite a scope-safe version of our constructor:</p>
<pre><code>function Book(name, year) { 
  if (!(this instanceof Book)) { 
    return new Book(name, year);
  }
  this.name = name;
  this.year = year;
}

var person1 = new Book("js book", 2014);
var person2 = Book("js book", 2014);
console.log(person1 instanceof Book);    // true
console.log(person2 instanceof Book);    // true</code></pre>
<p>The fact that "this" is an instance of the custom type allows us to determine if <code>new</code> is not used as soon as the constructor begins to execute and run the constructor again with <code>new</code> keyword.</p>
<h3 id="article-header-id-6" class="has-header-link"><a class="article-headline-link" href="#article-header-id-6">#</a>Conclusion</h3>
<p>JavaScript has no class statement, which is baffling for coders who are used to languages with a class statement; However, JavaScript has constructors to bring similar functionality. Constructors are just regular functions which are used with <code>new</code> keyword. They come in handy when we need to make multiple similar objects with the same properties and methods.</p>
     
    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-55" name="t-55"></a><h1>55 : Functions as First Class Citizens in Javascript</h1>
					<span class="ref-site">http://ryanchristiani.com/functions-as-first-class-citizens-in-javascript/</span>
					<div class="tutorial__content">
<div class="entry">
					<p>In Javascript we are lucky. We get the ability to pass functions around, our functions can even return functions. And this is great. As a teacher, one thing I find is that this idea confuses people learning the language. Functions are a bit of an abstract concept. So I wanted to go over a few things we can do with functions in regards to passing them around and playing with them! </p>
<p>This is focused for people just learning the language. Yet if you have been writing JS for a while, you might learn a thing of two as well!</p>
<p><span id="more-855"></span></p>
<h2 id="first-class-citizens"><a name="user-content-first-class-citizens" href="#first-class-citizens" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>First Class Citizens?!</h2>
<p>In programming languages, when you are able to pass, return and assign a type, that type is considered to be a first class citizen <cite><a href="https://en.wikipedia.org/wiki/First-class_citizen" target="_blank">[source]</a></cite>. This is one reason Javascript is becoming a popular destination for functional programming. Since we are able to create functions that can accept functions as well as return functions. This allows us to create Higher Order Functions. Higher Order Functions are functions that accept a function, and/or return a function <cite><a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank">[source]</a></cite>.</p>
<p>Types inside of Javascript are first class citizens, we are able to assign, pass and return all the different types in JS.</p>
<h2 id="assigning-functions"><a name="user-content-assigning-functions" href="#assigning-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Assigning functions.</h2>
<p>In Javascript we can assign a function to a variable in many ways.</p>
<h3 id="using-var"><a name="user-content-using-var" href="#using-var" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Using var</h3>
<pre><code>var myFunction = function() {
    //...function body here 
};</code></pre>
<p>A common pattern is to define a function using the <code class=" language-javascript"><span class="token keyword">var</span></code> keyword to store a function in a variable. We use an anonymous function here, but you could also use a named function if you desired.</p>
<pre><code>var myFunction = function functionName() {
    //...function body here 
};</code></pre>
<p>This will give you a reference to the function inside of the function, useful for recursion. It allows you to call the function inside of itself!</p>
<pre><code>var myFunction = function functionName(n) {
    if(n &lt; 10)   {
        n++;
        ...some code
        functionName(n);
    }
};</code></pre>
<h3 id="methods"><a name="user-content-methods" href="#methods" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Methods</h3>
<p>Assigning a method in Javascript is super easy as well. Similar to how we can assign a function to a variable we can assign a function as a value to a key in an object.</p>
<pre><code>var warrior = {
    hp: 100,
    strength: 20,
    attack: function(target) {
        target.hp -= this.strength;
    }
}</code></pre>
<p>One thing to remember here is that when we create a function like:</p>
<pre><code>var add = function(a,b) {
    return a + b;
}</code></pre>
<p>The value stored inside the <code class=" language-javascript">add</code> variable is a function, so we can pass that value around without calling the function.</p>
<pre><code>var newAdd = add;
newAdd(2,3) //5</code></pre>
<h2 id="passing-functions"><a name="user-content-passing-functions" href="#passing-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Passing functions.</h2>
<p>Since functions are first class citizens in Javascript, we are able to pass them. A common use case as a beginner might be something like this. Lets assume we have some sort of analytics we need to preform on various types of events.</p>
<p>You could do something like this.</p>
<pre><code>$('form').on('submit',function() {
    //perform some analytics.
});

$('a[href$=".pdf"]').on('click', function() {
    //perform same analytics.
});</code></pre>
<p>There is a bit of repetition here, and we want to prevent that as much as possible. With the ability to pass functions, we can reduce repetition, and pass one function to be run when the user interacts with those elements.</p>
<pre><code>function analyticsHandler(e) {
    ...//perform some analytics.
}

$('form').on('submit',analyticsHandler);

$('a[href$=".pdf"]').on('click',analyticsHandler);</code></pre>
<p>This way, jQuery will just see the function as a value and call it when the event is fired. Which, if you think about it, is all you are doing when you provide a callback function.</p>
<pre><code>$('a').on('click', function() {
    //...
});</code></pre>
<p>Internally jQuery will call the callback function when it sees that the <code class="language-html">&lt;a&gt;</code> tag is clicked. In our <code class=" language-javascript">analyticsHandler</code> example, we are simply storing the function in an easy to use variable for later use. And it is helping us keep things DRY.</p>
<h2 id="returning-functions"><a name="user-content-returning-functions" href="#returning-functions" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Returning functions.</h2>
<p>Something else we will look at is returning functions from functions. This can be a powerful concept if you master it, and this is a key concept when it comes to functional programming. </p>
<p>Consider the process of writing a gulp file. We use the <code class="langauge-javascript">require</code> statement from Node.js to get scripts into our file. </p>
<pre><code>var cssNext = require('gulp-cssnext');</code></pre>
<p>When you write module in Node you are able to return multiple things, however it is fairly common to simply return a function. That is why when you require something, especially a gulp plug in, you have to able to call that function later, the value returned from the <code class=" language-javascript">require</code> call is a function.</p>
<p>Here is an example from the <a href="https://github.com/cssnext/gulp-cssnext">gulp-cssnext</a> plug-in.</p>
<pre><code>module.exports = function(options) {
  return through.obj(transform(options))
}</code></pre>
<p>
This is a line from <a href="https://github.com/cssnext/gulp-cssnext/blob/master/index.js#L39-L41">index.js</a> in gulp-cssnext. They use <code class="langauge-javascript">module.exports</code> to return a function, which itself returns the results of a function call. This way we can use the returned function in our gulp files like this.</p>
<pre><code>gulp.task('css',function() {
    gulp.src('*.css')
        .pipe(cssnext())
        .pipe(dist.);
});</code></pre>
<p>A common pattern you will see when working with a Node app, especially an <a href="http://expressjs.com/">express</a> app is a line similar to this.</p>
<pre><code>var app = require('express')();</code></pre>
<p>In express you need to require it and then execute the function to create your express application. It is very common to shorten this process down to one line.</p>
<p>Another place you will see this is when using postcss. In postcss you require all of your packs in the postcss module, like this:</p>
<pre><code>postcss([ require('cssnext')(), require('cssnano')() ])</code></pre>
<p>Note the cssnext referred to here is not the gulp-cssnext plugin, but to original <a href="http://cssnext.io/" target="_blank">cssnext</a> package. In this implementation the cssnext package returns a function, that when run, sets itself up to work with postcss.</p>
<h3 id="partial-application"><a name="user-content-partial-application" href="#partial-application" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Partial application</h3>
<p>Another common use for returning a function, is for partial application. Partial application is used to set up a function that returns a function. Calling the first function saves the first argument or arguments that were passed in. What?! Let’s look at a simple example.</p>
<p>Example:</p>
<pre><code>function add(a) {
    return function(b) {
        return a + b;
    }   
}</code></pre>
<p>This function takes an <code class=" language-javascript">a</code> parameter and returns a function that will then take the second parameter <code class=" language-javascript">b</code>. The <code class=" language-javascript">a</code> is remembered inside of the second function because of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank">closure</a> that the returned function created. Lets look at an example of how to use it.</p>
<pre><code>var add5 = add(5);</code></pre>
<p>The value now saved in <code>add5</code> is the function. Inside of that function it references <code class=" language-javascript">a</code> and it remembers that because when it was created, <code class=" language-javascript">a</code> was available to it.</p>
<pre><code>function(b) {
    return a + b;
}</code></pre>
<p>What way we can go ahead and call it with new values that will always add 5 to the new value.</p>
<pre><code>add5(5); // 10
add5(8); // 13</code></pre>
<p>For a more in depth article on partial application and currying check out this article by <a href="http://www.datchley.name/currying-vs-partial-application/" target="_blank">Dave Atchley</a> and this one by <a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8" target="_blank">Eric Elliott</a>.</p>
<p>Javascript is a powerful fun language to learn and work with, and with functions as first class citizens we are very lucky! I hope this helped with your understanding of functions, learning a language like Javascript can be draughting to a beginner, but with practice you can start to chip away at it! </p>
				</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t-56" name="t-56"></a><h1>56 : Quick Tip: How JavaScript References Work</h1>
					<span class="ref-site">https://www.sitepoint.com/how-javascript-references-work/</span>
					<div class="tutorial__content">
<div class="ArticleCopy language-javascript">
      

<p><strong>TL;DR:</strong> There are NO pointers in JavaScript and references work differently from what we would normally see in most other popular programming languages. In JavaScript, it’s just NOT possible to have a reference from one variable to another variable. And, only compound values (e.g.. Object or Array) can be assigned by reference.</p>

<blockquote>
<p>The following terms are used throughout the article:</p>
<ul>
<li>scalar –  a singe value or unit of data (e.g. integer, boolean, string)</li>
<li>compound – comprised of multiple values (e.g. array, object, set)</li>
<li>primitive – a direct value, as opposed to a reference to something that contains the real value. </li>
</ul>
<p>JavaScript’s scalar types are primitives, but some languages, such as Ruby, have scalar reference types. Note that in JavaScript, the scalar primitive values are immutable while compound values are mutable.</p>
</blockquote>
<h2 id="bottomline">Bottom Line:</h2>
<ol>
<li>The <code class=" language-javascript"><span class="token keyword">typeof</span></code> value assigned to a variable decides whether the value is stored with assign-by-value or assign-by-reference.</li>
<li>On variable assignment, the scalar primitive values (Number, String, Boolean, undefined, null, Symbol) are assigned-by-value and compound values are assigned-by-reference.</li>
<li>The references in JavaScript only point at contained values and NOT at other variables, or references.</li>
<li>In JavaScript, scalar primitive values  are immutable and compound values are mutable.</li>
</ol>
<h2 id="quickexampleofassignbyvalue">Quick Example of Assign-by-Value:</h2>
<p>In the code snippet below, we are assigning a scalar primitive value (a number) to a variable and thus assign-by-value applies here. Firstly, the variable <code class=" language-javascript">batman</code> is initialized and when the variable <code class=" language-javascript">superman</code> is assigned with the value stored in <code class=" language-javascript">batman</code>, it creates a new copy of the value and stores it. When the variable <code class=" language-javascript">superman</code> is modified, <code class=" language-javascript">batman</code> is left unaffected, as they point to distinct values.</p>
<pre><code>var batman = 7;
var superman = batman;   //assign-by-value
superman++;
console.log(batman);     //7
console.log(superman);   //8
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365230diagram1.png" alt="Assign-by-value example"></p>
<h2 id="quickexampleofassignbyreference">Quick Example of Assign-by-Reference:</h2>
<p>In the code snippet below, we are assigning a compound value (an array) to a variable and thus assign-by-reference applies here. The variables <code class=" language-javascript">flash</code> and <code class=" language-javascript">quicksilver</code> are references to the same value (aka shared value). The references will point to the updated value when the shared value is modified .</p>
<pre><code>var flash = [8,8,8];
var quicksilver = flash;   //assign-by-reference
quicksilver.push(0);
console.log(flash);        //[8,8,8,0]
console.log(quicksilver);  //[8,8,8,0]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365235diagram2.png" alt="Assign-by-reference example"></p>
<h2 id="howtocreateanewreference">How to Create a New Reference</h2>
<p>When the compound value in a variable is reassigned, a new reference is created. In JavaScript, unlike in most other popular programming languages, the references are pointers to values stored in variables and NOT pointers to other variables, or references.</p>
<pre><code>var firestorm = [3,6,3];
var atom = firestorm;   //assign-by-reference
console.log(firestorm); //[3,6,3]
console.log(atom);      //[3,6,3]
atom = [9,0,9];         //value is reassigned (create new reference)
console.log(firestorm); //[3,6,3]
console.log(atom);      //[9,0,9]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365240diagram3.png" alt="Creating a new reference"></p>
<h2 id="howreferencesworkwhenvaluesarepassedasfunctionparameters">How References Work When Values Are Passed as Function Parameters</h2>
<p>In the code snippet below, the variable <code class=" language-javascript">magneto</code> is a compound value (an Array), thus it is assigned to variable (function argument) <code class=" language-javascript">x</code> as a reference. </p>
<p>The <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push</code> method invoked inside the IIFE mutates the value in the variable <code class=" language-javascript">magneto</code> via a JavaScript reference. But, the reassignment of variable <code class=" language-javascript">x</code> creates a new reference and further modifications to it do NOT affect the reference to the variable <code class=" language-javascript">magneto</code>.</p>
<pre><code>var magneto = [8,4,8];
(function(x) {        //IIFE
    x.push(99);
    console.log(x);   //[8,4,8,99]
    x = [1,4,1];      //reassign variable (create new reference)
    x.push(88);
    console.log(x);   //[1,4,1,88]
})(magneto);
console.log(magneto); //[8,4,8,99]
</code></pre>
<h2 id="howtochangetheoriginalvalueinacompoundvariablepassedasafunctionargumentviaajavascriptreference">How to Change the Original Value in a Compound Variable, Passed as a Function Argument via a JavaScript Reference</h2>
<p>The solution here would be to modify the existing compound value that the reference is pointing to. In the code snippet below, variable <code class=" language-javascript">wolverine</code> is a compound value (an Array) and, on IIFE invocation, the variable (function argument) <code class=" language-javascript">x</code> is assigned by reference. </p>
<p>The <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>length</code> property can be used to create an empty array by setting its value to <code class=" language-javascript"><span class="token number">0</span></code>. Thus, the variable wolverine is changed to the new value set in variable <code class=" language-javascript">x</code> via a JavaScript reference.</p>
<pre><code>var wolverine = [8,7,8];
(function(x) {              //IIFE
    x.length = 0;           //make empty array object
    x.push(1,4,7,2);
    console.log(x);         //[1,4,7,2]
})(wolverine);
console.log(wolverine);     //[1,4,7,2]
</code></pre>
<h2 id="howtostoreacompoundvaluethroughassignbyvalue">How to Store a Compound Value through Assign-by-Value</h2>
<p>The solution here would be to make a manual copy of the compound value and then assign the copied value to a variable. Therefore, the reference of assigned value does NOT point back to the original value. </p>
<p>The recommended approach to create a (shallow) copy of the compound value (Array object) is to invoke <code class=" language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice</code> method on it with no arguments passed.</p>
<pre><code>var cisco = [7,4,7];
var zoom = cisco.slice();  //create shallow copy
cisco.push(77,33);
console.log(zoom);         //[7,4,7]
console.log(cisco);        //[7,4,7,77,33]
</code></pre>
<p><img src="https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2017/03/1488365242diagram4.png" alt="Diagram4"></p>
<h2 id="howtostoreascalarprimitivevaluethroughassignbyreference">How to Store a Scalar Primitive Value Through Assign-by-Reference?</h2>
<p>The solution here would be to wrap scalar primitive value in a compound value (i.e. an Object or Array) as its property value. Thus, it can be assigned-by-reference. In the code snippet below, scalar primitive value in variable <code class=" language-javascript">speed</code> is set as a property on object <code class=" language-javascript">flash</code>. Therefore, it is assigned-by-reference on IIFE invocation to variable (function argument) <code class=" language-javascript">x</code>.</p>
<pre><code>var flash = { speed: 88 };
(function (x) {             //IIFE
    x.speed = 55;
})(flash);
console.log(flash.speed);   //55
</code></pre>
<h2 id="summary">Summary</h2>

<p>A good understanding of references in JavaScript can help developers to avoid many common mistakes and write better code.</p>

    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				
				<!--================= START :: Tutorial =================-->
				<article style="display:none;">
					<a id="t1" name="t1"></a><h1>Index</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
						
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
			</section>
			
		</main>
	
			</body></html>