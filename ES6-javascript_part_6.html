<html><head>
		<meta charset="utf-8">
		<title>6 - Javascript Book ES6 :: Part 6</title>
		<meta name="title" content="">
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!--<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
		<link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i|PT+Serif:400,700" rel="stylesheet">-->
		<style>
			* { box-sizing: border-box; }
			figure { margin: 0; }
			body { 
			font-family: 'Open Sans', Arial, sans-serif;
			font-size: 14px;
			line-height: 1.8;
			padding: 0.5em;
			font-family: 'PT Sans', Arial, sans-serif;
			
			}
			img { display: block; margin: 0 auto; max-width: 100%; }
			pre { 
			border: 1px dashed #333; 
			padding: 1em 2em; 
			font-family: Consolas,monospace; 
			background-color: #EEE; 
			overflow-x: scroll; 
			font-size: 14px;  
			white-space: pre-wrap; 
			word-wrap: break-word; 
			}
			pre {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    margin: 1em auto;
    border: 1px dashed #333;
    width: 100%;
    padding: 1em 1.5em;
    font-family: Inconsolata, Consolas, monospace, sans-serif;
    font-size: 1em;
	line-height: 1.5;
    overflow: auto;
    background: #F7FAFB;
    border-radius: 3px;
	position:relative;
}
			code { background-color: #EEE; padding: 3px; font-family: Consolas,monospace; }
			pre code { background-color: transparent; padding: 0; display: block; }
			
			.tutorial-index {
			counter-reset: section;
			}
			.tutorial-index h1:before {
    /*counter-increment: section;
    content: counter(section) " : ";*/
}
.tutorial-index h1 {font-size: 1.2em; padding: 5px 0; font-family: 'Open Sans', Arial, sans-serif; line-height: normal;}
.tutorial-index a { display: block; float: left; width: 50%;}
			.tutorial-index a { text-decoration: none; }
			h1 { font-size: 1.6em; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			
			.main { counter-reset: mainsection; }
			.main h1 { font-size: 1.6em; border-bottom: 2px solid #000; font-family: 'PT Serif', Arial, serif; padding: 10px 0; margin: 0; }
			/*.main h1:before {
    counter-increment: mainsection;
    content: counter(mainsection) " : ";
}*/
			
			
			
			h2, h3, h6 { 
			font-size: 1.2em;
			font-family: 'PT Serif', Arial, serif;
			padding-left: 1em;
			border-left: 2px solid #868686; 
			}
			.cf:before,
.cf:after {
    content: " ";
    display: table;
}
.cf:after {
    clear: both;
}
table { border-collapse: collapse;}
table td { border: 1px solid #999; padding: 5px;}

@media print {
    .main h1 {page-break-before: always;}
}
.tc { text-align: center}
.home-screen { border: 1px solid #777; padding: 4em 0; }
.home-screen * {    font-family: 'PT Sans', Arial, sans-serif;
    font-size: 3em;
    font-weight: normal;}
	
		</style>
	</head>
	<body>
		<div class="home-screen tc">
			<h1>ES6 ( ES2015 ) JavaScript Tutorials</h1>
			<h4>- Part 6-</h4>
		</div>
		<!--================= START :: Tutorial Index =================-->
<div class="tutorial-index cf">
	<a href="#t01"><h1>01 : Understanding ECMAScript 6</h1></a>
	<a href="#t02"><h1>02 : Let's Learn ES2015</h1></a>
	<a href="#t03"><h1>03 : ES6 Symbols in Depth</h1></a>
	<a href="#t04"><h1>04 : ES6 Overview in 350 Bullet Points</h1></a>
	<a href="#t05"><h1>05 : Metaprogramming in ES6: Symbols and why they're awesome</h1></a>
	<a href="#t06"><h1>06 : Metaprogramming in ES6: Part 2 - Reflect</h1></a>
	<a href="#t07"><h1>07 : Metaprogramming in ES6: Part 3 - Proxies</h1></a>
	<a href="#t08"><h1>08 : ES6 Spread and Butter in Depth</h1></a>
	<a href="#t09"><h1>09 : ES6 Reflection in Depth</h1></a>
	<a href="#t10"><h1>10 : ES6 Object Literal Features in Depth</h1></a>
	<a href="#t11"><h1>11 : ES6 WeakMaps, Sets, and WeakSets in Depth</h1></a>
	<a href="#t12"><h1>12 : JavaScript ES2015 Classes and Prototype Inheritance (Part 1 of 2)</h1></a>
	
	<a href="#t13"><h1>13 : JavaScript ES2015 Classes and Properties (Part 2 of 2)</h1></a>
	<a href="#t14"><h1>14 : ES6 - classes and inheritance</h1></a>
	<a href="#t15"><h1>15 : Learning ES6: Classes</h1></a>
	<a href="#t16"><h1>16 : Classes in ECMAScript 6 (final semantics)</h1></a>
	<a href="#t17"><h1>17 : ECMAScript 6: merging objects via Object.assign()</h1></a>
</div>
		<!--================= END :: Tutorial Index =================-->
		
		<main class="main">
			
			<section class="section__one">
			
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t01" name="t01"></a><h1>01 : Understanding ECMAScript 6</h1>
					<span class="ref-site">https://leanpub.com/understandinges6/read</span>
					<div class="tutorial__content">
<section class="read">
	<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="#leanpub-auto-introduction">Introduction</a>
    <ul>
      <li>
        <a href="#leanpub-auto-the-road-to-ecmascript-6">The Road to ECMAScript 6</a>
      </li>
      <li>
        <a href="#leanpub-auto-about-this-book">About This Book</a>
      </li>
      <li>
        <a href="#leanpub-auto-acknowledgments">Acknowledgments</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-block-bindings">Block Bindings</a>
    <ul>
      <li>
        <a href="#leanpub-auto-var-declarations-and-hoisting">Var Declarations and Hoisting</a>
      </li>
      <li>
        <a href="#leanpub-auto-block-level-declarations">Block-Level Declarations</a>
      </li>
      <li>
        <a href="#leanpub-auto-block-binding-in-loops">Block Binding in Loops</a>
      </li>
      <li>
        <a href="#leanpub-auto-global-block-bindings">Global Block Bindings</a>
      </li>
      <li>
        <a href="#leanpub-auto-emerging-best-practices-for-block-bindings">Emerging Best Practices for Block Bindings</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-strings-and-regular-expressions">Strings and Regular Expressions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-better-unicode-support">Better Unicode Support</a>
      </li>
      <li>
        <a href="#leanpub-auto-other-string-changes">Other String Changes</a>
      </li>
      <li>
        <a href="#leanpub-auto-other-regular-expression-changes">Other Regular Expression Changes</a>
      </li>
      <li>
        <a href="#leanpub-auto-template-literals">Template Literals</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-1">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-functions">Functions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-functions-with-default-parameter-values">Functions with Default Parameter Values</a>
      </li>
      <li>
        <a href="#leanpub-auto-working-with-unnamed-parameters">Working with Unnamed Parameters</a>
      </li>
      <li>
        <a href="#leanpub-auto-increased-capabilities-of-the-function-constructor">Increased Capabilities of the Function Constructor</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-spread-operator">The Spread Operator</a>
      </li>
      <li>
        <a href="#leanpub-auto-ecmascript-6s-name-property">ECMAScript 6's name Property</a>
      </li>
      <li>
        <a href="#leanpub-auto-clarifying-the-dual-purpose-of-functions">Clarifying the Dual Purpose of Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-block-level-functions">Block-Level Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-arrow-functions">Arrow Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-tail-call-optimization">Tail Call Optimization</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-2">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-expanded-object-functionality">Expanded Object Functionality</a>
    <ul>
      <li>
        <a href="#leanpub-auto-object-categories">Object Categories</a>
      </li>
      <li>
        <a href="#leanpub-auto-object-literal-syntax-extensions">Object Literal Syntax Extensions</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-methods">New Methods</a>
      </li>
      <li>
        <a href="#leanpub-auto-duplicate-object-literal-properties">Duplicate Object Literal Properties</a>
      </li>
      <li>
        <a href="#leanpub-auto-own-property-enumeration-order">Own Property Enumeration Order</a>
      </li>
      <li>
        <a href="#leanpub-auto-more-powerful-prototypes">More Powerful Prototypes</a>
      </li>
      <li>
        <a href="#leanpub-auto-a-formal-method-definition">A Formal Method Definition</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-3">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-destructuring-for-easier-data-access">Destructuring for Easier Data Access</a>
    <ul>
      <li>
        <a href="#leanpub-auto-why-is-destructuring-useful">Why is Destructuring Useful?</a>
      </li>
      <li>
        <a href="#leanpub-auto-object-destructuring">Object Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-array-destructuring">Array Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-mixed-destructuring">Mixed Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-destructured-parameters">Destructured Parameters</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-4">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-symbols-and-symbol-properties">Symbols and Symbol Properties</a>
    <ul>
      <li>
        <a href="#leanpub-auto-creating-symbols">Creating Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-using-symbols">Using Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-sharing-symbols">Sharing Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-symbol-coercion">Symbol Coercion</a>
      </li>
      <li>
        <a href="#leanpub-auto-retrieving-symbol-properties">Retrieving Symbol Properties</a>
      </li>
      <li>
        <a href="#leanpub-auto-exposing-internal-operations-with-well-known-symbols">Exposing Internal Operations with Well-Known Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-5">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-sets-and-maps">Sets and Maps</a>
    <ul>
      <li>
        <a href="#leanpub-auto-sets-and-maps-in-ecmascript-5">Sets and Maps in ECMAScript 5</a>
      </li>
      <li>
        <a href="#leanpub-auto-problems-with-workarounds">Problems with Workarounds</a>
      </li>
      <li>
        <a href="#leanpub-auto-sets-in-ecmascript-6">Sets in ECMAScript 6</a>
      </li>
      <li>
        <a href="#leanpub-auto-maps-in-ecmascript-6">Maps in ECMAScript 6</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-6">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-iterators-and-generators">Iterators and Generators</a>
    <ul>
      <li>
        <a href="#leanpub-auto-the-loop-problem">The Loop Problem</a>
      </li>
      <li>
        <a href="#leanpub-auto-what-are-iterators">What are Iterators?</a>
      </li>
      <li>
        <a href="#leanpub-auto-what-are-generators">What Are Generators?</a>
      </li>
      <li>
        <a href="#leanpub-auto-iterables-and-for-of">Iterables and for-of</a>
      </li>
      <li>
        <a href="#leanpub-auto-built-in-iterators">Built-in Iterators</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-spread-operator-and-non-array-iterables">The Spread Operator and Non-Array Iterables</a>
      </li>
      <li>
        <a href="#leanpub-auto-advanced-iterator-functionality">Advanced Iterator Functionality</a>
      </li>
      <li>
        <a href="#leanpub-auto-asynchronous-task-running">Asynchronous Task Running</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-7">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-introducing-javascript-classes">Introducing JavaScript Classes</a>
    <ul>
      <li>
        <a href="#leanpub-auto-class-like-structures-in-ecmascript-5">Class-Like Structures in ECMAScript 5</a>
      </li>
      <li>
        <a href="#leanpub-auto-class-declarations">Class Declarations</a>
      </li>
      <li>
        <a href="#leanpub-auto-class-expressions">Class Expressions</a>
      </li>
      <li>
        <a href="#leanpub-auto-classes-as-first-class-citizens">Classes as First-Class Citizens</a>
      </li>
      <li>
        <a href="#leanpub-auto-accessor-properties">Accessor Properties</a>
      </li>
      <li>
        <a href="#leanpub-auto-computed-member-names">Computed Member Names</a>
      </li>
      <li>
        <a href="#leanpub-auto-generator-methods">Generator Methods</a>
      </li>
      <li>
        <a href="#leanpub-auto-static-members">Static Members</a>
      </li>
      <li>
        <a href="#leanpub-auto-inheritance-with-derived-classes">Inheritance with Derived Classes</a>
      </li>
      <li>
        <a href="#leanpub-auto-using-newtarget-in-class-constructors">Using new.target in Class Constructors</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-8">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-improved-array-capabilities">Improved Array Capabilities</a>
    <ul>
      <li>
        <a href="#leanpub-auto-creating-arrays">Creating Arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-methods-on-all-arrays">New Methods on All Arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-typed-arrays">Typed Arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-similarities-between-typed-and-regular-arrays">Similarities Between Typed and Regular Arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-differences-between-typed-and-regular-arrays">Differences Between Typed and Regular Arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-9">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-promises-and-asynchronous-programming">Promises and Asynchronous Programming</a>
    <ul>
      <li>
        <a href="#leanpub-auto-asynchronous-programming-background">Asynchronous Programming Background</a>
      </li>
      <li>
        <a href="#leanpub-auto-promise-basics">Promise Basics</a>
      </li>
      <li>
        <a href="#leanpub-auto-global-promise-rejection-handling">Global Promise Rejection Handling</a>
      </li>
      <li>
        <a href="#leanpub-auto-chaining-promises">Chaining Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-responding-to-multiple-promises">Responding to Multiple Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-inheriting-from-promises">Inheriting from Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-10">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-proxies-and-the-reflection-api">Proxies and the Reflection API</a>
    <ul>
      <li>
        <a href="#leanpub-auto-the-array-problem">The Array Problem</a>
      </li>
      <li>
        <a href="#leanpub-auto-what-are-proxies-and-reflection">What are Proxies and Reflection?</a>
      </li>
      <li>
        <a href="#leanpub-auto-creating-a-simple-proxy">Creating a Simple Proxy</a>
      </li>
      <li>
        <a href="#leanpub-auto-validating-properties-using-the-set-trap">Validating Properties Using the <code>set</code> Trap</a>
      </li>
      <li>
        <a href="#leanpub-auto-object-shape-validation-using-the-get-trap">Object Shape Validation Using the <code>get</code> Trap</a>
      </li>
      <li>
        <a href="#leanpub-auto-hiding-property-existence-using-the-has-trap">Hiding Property Existence Using the <code>has</code> Trap</a>
      </li>
      <li>
        <a href="#leanpub-auto-preventing-property-deletion-with-the-deleteproperty-trap">Preventing Property Deletion with the <code>deleteProperty</code> Trap</a>
      </li>
      <li>
        <a href="#leanpub-auto-prototype-proxy-traps">Prototype Proxy Traps</a>
      </li>
      <li>
        <a href="#leanpub-auto-object-extensibility-traps">Object Extensibility Traps</a>
      </li>
      <li>
        <a href="#leanpub-auto-property-descriptor-traps">Property Descriptor Traps</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-ownkeys-trap">The <code>ownKeys</code> Trap</a>
      </li>
      <li>
        <a href="#leanpub-auto-function-proxies-with-the-apply-and-construct-traps">Function Proxies with the <code>apply</code> and <code>construct</code> Traps</a>
      </li>
      <li>
        <a href="#leanpub-auto-revocable-proxies">Revocable Proxies</a>
      </li>
      <li>
        <a href="#leanpub-auto-solving-the-array-problem">Solving the Array Problem</a>
      </li>
      <li>
        <a href="#leanpub-auto-using-a-proxy-as-a-prototype">Using a Proxy as a Prototype</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-11">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-encapsulating-code-with-modules">Encapsulating Code With Modules</a>
    <ul>
      <li>
        <a href="#leanpub-auto-what-are-modules">What are Modules?</a>
      </li>
      <li>
        <a href="#leanpub-auto-basic-exporting">Basic Exporting</a>
      </li>
      <li>
        <a href="#leanpub-auto-basic-importing">Basic Importing</a>
      </li>
      <li>
        <a href="#leanpub-auto-renaming-exports-and-imports">Renaming Exports and Imports</a>
      </li>
      <li>
        <a href="#leanpub-auto-default-values-in-modules">Default Values in Modules</a>
      </li>
      <li>
        <a href="#leanpub-auto-re-exporting-a-binding">Re-exporting a Binding</a>
      </li>
      <li>
        <a href="#leanpub-auto-importing-without-bindings">Importing Without Bindings</a>
      </li>
      <li>
        <a href="#leanpub-auto-loading-modules">Loading Modules</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-12">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-appendix-a-smaller-changes">Appendix A: Smaller Changes</a>
    <ul>
      <li>
        <a href="#leanpub-auto-working-with-integers">Working with Integers</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-math-methods">New Math Methods</a>
      </li>
      <li>
        <a href="#leanpub-auto-unicode-identifiers">Unicode Identifiers</a>
      </li>
      <li>
        <a href="#leanpub-auto-formalizing-the-proto-property">Formalizing the <code>__proto__</code> Property</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-appendix-b-understanding-ecmascript-7-2016">Appendix B: Understanding ECMAScript 7 (2016)</a>
    <ul>
      <li>
        <a href="#leanpub-auto-the-exponentiation-operator">The Exponentiation Operator</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-arrayprototypeincludes-method">The Array.prototype.includes() Method</a>
      </li>
      <li>
        <a href="#leanpub-auto-change-to-function-scoped-strict-mode">Change to Function-Scoped Strict Mode</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main" class="kramdown">
<h2 id="leanpub-auto-introduction">Introduction</h2>

<p>The JavaScript core language features are defined in a standard called ECMA-262. The language defined in this standard is called ECMAScript. What you know as JavaScript in browsers and Node.js is actually a superset of ECMAScript. Browsers and Node.js add more functionality through additional objects and methods, but the core of the language remains as defined in ECMAScript. The ongoing development of ECMA-262 is vital to the success of JavaScript as a whole, and this book covers the changes brought about by the most recent major update to the language: ECMAScript 6.</p>

<h3 id="leanpub-auto-the-road-to-ecmascript-6">The Road to ECMAScript 6</h3>

<p>In 2007, JavaScript was at a crossroads. The popularity of Ajax was ushering in a new age of dynamic web applications, while JavaScript hadn't changed since the third edition of ECMA-262 was published in 1999. TC-39, the committee responsible for driving the ECMAScript development process, put together a large draft specification for ECMAScript 4. ECMAScript 4 was massive in scope, introducing changes both small and large to the language. Updated features included new syntax, modules, classes, classical inheritance, private object members, optional type annotations, and more.</p>

<p>The scope of the ECMAScript 4 changes caused a rift to form in TC-39, with some members feeling that the fourth edition was trying to accomplish too much. A group of leaders from Yahoo, Google, and Microsoft created an alternate proposal for the next version of ECMAScript that they initially called ECMAScript 3.1. The "3.1" was intended to show that this was an incremental change to the existing standard.</p>

<p>ECMAScript 3.1 introduced very few syntax changes, instead focusing on property attributes, native JSON support, and adding methods to already-existing objects. Although there was an early attempt to reconcile ECMAScript 3.1 and ECMAScript 4, this ultimately failed as the two camps had difficulty with the very different perspectives on how the language should grow.</p>

<p>In 2008, Brendan Eich, the creator of JavaScript, announced that TC-39 would focus its efforts on standardizing ECMAScript 3.1. They would table the major syntax and feature changes of ECMAScript 4 until after the next version of ECMAScript was standardized, and all members of the committee would work to bring the best pieces of ECMAScript 3.1 and 4 together after that point into an effort initially nicknamed ECMAScript Harmony.</p>

<p>ECMAScript 3.1 was eventually standardized as the fifth edition of ECMA-262, also described as ECMAScript 5. The committee never released an ECMAScript 4 standard to avoid confusion with the now-defunct effort of the same name. Work then began on ECMAScript Harmony, with ECMAScript 6 being the first standard released in this new "harmonious" spirit.</p>

<p>ECMAScript 6 reached feature complete status in 2015 and was formally dubbed "ECMAScript 2015." (But this text still refers to it as ECMAScript 6, the name most familiar to developers.) The features vary widely from completely new objects and patterns to syntax changes to new methods on existing objects. The exciting thing about ECMAScript 6 is that all of its changes are geared toward solving problems that developers actually face.</p>

<h3 id="leanpub-auto-about-this-book">About This Book</h3>

<p>A good understanding of ECMAScript 6 features is key for all JavaScript developers going forward. The language features introduced in ECMAScript 6 represent the foundation upon which JavaScript applications will be built for the foreseeable future. That's where this book comes in. My hope is that you'll read this book to learn about ECMAScript 6 features so that you'll be ready to start using them as soon as you need to.</p>

<h4 id="leanpub-auto-browser-and-nodejs-compatibility">Browser and Node.js Compatibility</h4>

<p>Many JavaScript environments, such as web browsers and Node.js, are actively working on implementing ECMAScript 6. This book doesn't attempt to address the inconsistencies between implementations and instead focuses on what the specification defines as the correct behavior. As such, it's possible that your JavaScript environment may not conform to the behavior described in this book.</p>

<h4 id="leanpub-auto-who-this-book-is-for">Who This Book is For</h4>

<p>This book is intended as a guide for those who are already familiar with JavaScript and ECMAScript 5. While a deep understanding of the language isn't necessary to use this book, it will help you understand the differences between ECMAScript 5 and 6. In particular, this book is aimed at intermediate-to-advanced JavaScript developers programming for a browser or Node.js environment who want to learn about the latest developments in the language.</p>

<p>This book is not for beginners who have never written JavaScript. You will need to have a good basic understanding of the language to make use of this book.</p>

<h4 id="leanpub-auto-overview">Overview</h4>

<p>Each of this book's thirteen chapters covers a different aspect of ECMAScript 6. Many chapters start by discussing problems that ECMAScript 6 changes were made to solve, to give you a broader context for those changes, and all chapters include code examples to help you learn new syntax and concepts.</p>

<p><strong>Chapter 1: How Block Bindings Work</strong> talks about <code>let</code> and <code>const</code>, the block-level replacement for <code>var</code>.</p>

<p><strong>Chapter 2: Strings and Regular Expressions</strong> covers additional functionality for string manipulation and inspection as well as the introduction of template strings.</p>

<p><strong>Chapter 3: Functions in ECMAScript 6</strong> discusses the various changes to functions. This includes the arrow function form, default parameters, rest parameters, and more.</p>

<p><strong>Chapter 4: Expanded Object Functionality</strong> explains the changes to how objects are created, modified, and used. Topics include changes to object literal syntax, and new reflection methods.</p>

<p><strong>Chapter 5: Destructuring for Easier Data Access</strong> introduces object and array destructuring, which allow you to decompose objects and arrays using a concise syntax.</p>

<p><strong>Chapter 6: Symbols and Symbol Properties</strong> introduces the concept of symbols, a new way to define properties. Symbols are a new primitive type that can be used to obscure (but not hide) object properties and methods.</p>

<p><strong>Chapter 7: Sets and Maps</strong> details the new collection types of <code>Set</code>, <code>WeakSet</code>, <code>Map</code>, and <code>WeakMap</code>. These types expand on the usefulness of arrays by adding semantics, de-duping, and memory management designed specifically for JavaScript.</p>

<p><strong>Chapter 8: Iterators and Generators</strong> discusses the addition of iterators and generators to the language. These features allow you to work with collections of data in powerful ways that were not possible in previous versions of JavaScript.</p>

<p><strong>Chapter 9: Introducing JavaScript Classes</strong> introduces the first formal concept of classes in JavaScript. Often a point of confusion for those coming from other languages, the addition of class syntax in JavaScript makes the language more approachable to others and more concise for enthusiasts.</p>

<p><strong>Chapter 10: Improved Array Capabilities</strong> details the changes to native arrays and the interesting new ways they can be used in JavaScript.</p>

<p><strong>Chapter 11: Promises and Asynchronous Programming</strong> introduces promises as a new part of the language. Promises were a grassroots effort that eventually took off and gained in popularity due to extensive library support. ECMAScript 6 formalizes promises and makes them available by default.</p>

<p><strong>Chapter 12: Proxies and the Reflection API</strong> introduces the formalized reflection API for JavaScript and the new proxy object that allows you to intercept every operation performed on an object. Proxies give developers unprecedented control over objects and, as such, unlimited possibilities for defining new interaction patterns.</p>

<p><strong>Chapter 13: Encapsulating Code with Modules</strong> details the official module format for JavaScript. The intent is that these modules can replace the numerous ad-hoc module definition formats that have appeared over the years.</p>

<p><strong>Appendix A: Smaller ECMAScript 6 Changes</strong> covers other changes implemented in ECMAScript 6 that you'll use less frequently or that didn't quite fit into the broader major topics covered in each chapter.</p>

<p><strong>Appendix B: Understanding ECMAScript 7 (2016)</strong> describes the two additions to the standard that were implemented for ECMAScript 7, which didn't impact JavaScript nearly as much as ECMAScript 6.</p>

<h4 id="leanpub-auto-conventions-used">Conventions Used</h4>

<p>The following typographical conventions are used in this book:</p>

<ul>
  <li>
<em>Italics</em> introduces new terms</li>
  <li>
<code>Constant width</code> indicates a piece of code or filename</li>
</ul>

<p>Additionally, longer code examples are contained in constant width code blocks such as:</p>

<figure class="code">
<pre><code>function doSomething() {
    // empty
}
</code></pre>

</figure>

<p>Within a code block, comments to the right of a <code>console.log()</code> statement indicate the output you'll see in the browser or Node.js console when the code is executed, for example:</p>

<figure class="code">
<pre><code>console.log("Hi");      // "Hi"
</code></pre>

</figure>

<p>If a line of code in a code block throws an error, this is also indicated to the right of the code:</p>

<figure class="code">
<pre><code>doSomething();          // error!
</code></pre>

</figure>

<h4 id="leanpub-auto-help-and-support">Help and Support</h4>

<p>You can file issues, suggest changes, and open pull requests against this book by visiting: <a href="https://github.com/nzakas/understandinges6">https://github.com/nzakas/understandinges6</a></p>


<p>If you have questions as you read this book, please send a message to my mailing list: <a href="http://groups.google.com/group/zakasbooks">http://groups.google.com/group/zakasbooks</a>.</p>

<h3 id="leanpub-auto-acknowledgments">Acknowledgments</h3>

<p>Thanks to Jennifer Griffith-Delgado, Alison Law, and everyone at No Starch Press for their support and help with this book. Their understanding and patience as my productivity slowed to a crawl during my extended illness is something I will never forget.</p>

<p>I'm grateful for the watchful eye of Juriy Zaytsev as tech editor and to Dr. Axel Rauschmayer for his feedback and several conversations that helped to clarify some of the concepts discussed in this book.</p>

<p>Thanks to everyone who submitted fixes to the version of this book that is hosted on GitHub: ShMcK, Ronen Elster, Rick Waldron, blacktail, Paul Salaets, Lonniebiz, Igor Skuhar, jakub-g, David Chang, Kevin Sweeney, Kyle Simpson, Peter Bakondy, Philip Borisov, Shaun Hickson, Steven Foote, kavun, Dan Kielp, Darren Huskie, Jakub Narębski, Jamund Ferguson, Josh Lubaway, Marián Rusnák, Nikolas Poniros, Robin Pokorný, Roman Lo, Yang Su, alexyans, robertd, 404, Aaron Dandy, AbdulFattah Popoola, Adam Richeimer, Ahmad Ali, Aleksandar Djindjic, Arjunkumar, Ben Regenspan, Carlo Costantini, Dmitri Suvorov, Kyle Pollock, Mallory, Erik Sundahl, Ethan Brown, Eugene Zubarev, Francesco Pongiluppi, Jake Champion, Jeremy Caney, Joe Eames, Juriy Zaytsev, Kale Worsley, Kevin Lozandier, Lewis Ellis, Mohsen Azimi, Navaneeth Kesavan, Nick Bottomley, Niels Dequeker, Pahlevi Fikri Auliya, Prayag Verma, Raj Anand, Ross Gerbasi, Roy Ling, Sarbbottam Bandyopadhyay, and Shidhin.</p>

<p>Also, thanks to everyone who supported this book on Patreon: Casey Visco.</p>


<h2 id="leanpub-auto-block-bindings">Block Bindings</h2>

<p>Traditionally, the way variable declarations work has been one tricky part of programming in JavaScript. In most C-based languages, variables (or <em>bindings</em>) are created at the spot where the declaration occurs. In JavaScript, however, this is not the case. Where your variables are actually created depends on how you declare them, and ECMAScript 6 offers options to make controlling scope easier. This chapter demonstrates why classic <code>var</code> declarations can be confusing, introduces block-level bindings in ECMAScript 6, and then offers some best practices for using them.</p>

<h3 id="leanpub-auto-var-declarations-and-hoisting">Var Declarations and Hoisting</h3>

<p>Variable declarations using <code>var</code> are treated as if they are at the top of the function (or global scope, if declared outside of a function) regardless of where the actual declaration occurs; this is called <em>hoisting</em>. For a demonstration of what hoisting does, consider the following function definition:</p>

<figure class="code">
<pre><code>function getValue(condition) {

    if (condition) {
        var value = "blue";

        // other code

        return value;
    } else {

        // value exists here with a value of undefined

        return null;
    }

    // value exists here with a value of undefined
}
</code></pre>

</figure>

<p>If you are unfamiliar with JavaScript, then you might expect the variable <code>value</code> to only be created if <code>condition</code> evaluates to true. In fact, the variable <code>value</code> is created regardless. Behind the scenes, the JavaScript engine changes the <code>getValue</code> function to look like this:</p>

<figure class="code">
<pre><code>function getValue(condition) {

    var value;

    if (condition) {
        value = "blue";

        // other code

        return value;
    } else {

        return null;
    }
}
</code></pre>

</figure>

<p>The declaration of <code>value</code> is hoisted to the top, while the initialization remains in the same spot. That means the variable <code>value</code> is actually still accessible from within the <code>else</code> clause. If accessed from there, the variable would just have a value of <code>undefined</code> because it hasn't been initialized.</p>

<p>It often takes new JavaScript developers some time to get used to declaration hoisting, and misunderstanding this unique behavior can end up causing bugs. For this reason, ECMAScript 6 introduces block level scoping options to make the controlling a variable's lifecycle a little more powerful.</p>

<h3 id="leanpub-auto-block-level-declarations">Block-Level Declarations</h3>

<p>Block-level declarations are those that declare variables that are inaccessible outside of a given block scope. Block scopes, also called lexical scopes, are created:</p>

<ol class="numeric">
  <li>Inside of a function</li>
  <li>Inside of a block (indicated by the <code>{</code> and <code>}</code> characters)</li>
</ol>

<p>Block scoping is how many C-based languages work, and the introduction of block-level declarations in ECMAScript 6 is intended to bring that same flexibility (and uniformity) to JavaScript.</p>

<h4 id="leanpub-auto-let-declarations">Let Declarations</h4>

<p>The <code>let</code> declaration syntax is the same as the syntax for <code>var</code>. You can basically replace <code>var</code> with <code>let</code> to declare a variable, but limit the variable's scope to only the current code block (there are a few other subtle differences discussed a bit later, as well). Since <code>let</code> declarations are not hoisted to the top of the enclosing block, you may want to always place <code>let</code> declarations first in the block, so that they are available to the entire block. Here's an example:</p>

<figure class="code">
<pre><code>function getValue(condition) {

    if (condition) {
        let value = "blue";

        // other code

        return value;
    } else {

        // value doesn't exist here

        return null;
    }

    // value doesn't exist here
}
</code></pre>

</figure>

<p>This version of the <code>getValue</code> function behaves much closer to how you'd expect it to in other C-based languages. Since the variable <code>value</code> is declared using <code>let</code> instead of <code>var</code>, the declaration isn't hoisted to the top of the function definition, and the variable <code>value</code> is no longer accessible once execution flows out of the <code>if</code> block. If <code>condition</code> evaluates to false, then <code>value</code> is never declared or initialized.</p>

<h4 id="leanpub-auto-no-redeclaration">No Redeclaration</h4>

<p>If an identifier has already been defined in a scope, then using the identifier in a <code>let</code> declaration inside that scope causes an error to be thrown. For example:</p>

<figure class="code">
<pre><code>var count = 30;

// Syntax error
let count = 40;
</code></pre>

</figure>

<p>In this example, <code>count</code> is declared twice: once with <code>var</code> and once with <code>let</code>. Because <code>let</code> will not redefine an identifier that already exists in the same scope, the <code>let</code> declaration will throw an error. On the other hand, no error is thrown if a <code>let</code> declaration creates a new variable with the same name as a variable in its containing scope, as demonstrated in the following code:</p>

<figure class="code">
<pre><code>var count = 30;

// Does not throw an error
if (condition) {

    let count = 40;

    // more code
}
</code></pre>

</figure>

<p>This <code>let</code> declaration doesn't throw an error because it creates a new variable called <code>count</code> within the <code>if</code> statement, instead of creating <code>count</code> in the surrounding block. Inside the <code>if</code> block, this new variable shadows the global <code>count</code>, preventing access to it until execution leaves the block.</p>

<h4 id="leanpub-auto-constant-declarations">Constant Declarations</h4>

<p>You can also define variables in ECMAScript 6 with the <code>const</code> declaration syntax. Variables declared using <code>const</code> are considered <em>constants</em>, meaning their values cannot be changed once set. For this reason, every <code>const</code> variable must be initialized on declaration, as shown in this example:</p>

<figure class="code">
<pre><code>// Valid constant
const maxItems = 30;

// Syntax error: missing initialization
const name;
</code></pre>

</figure>

<p>The <code>maxItems</code> variable is initialized, so its <code>const</code> declaration should work without a problem. The <code>name</code> variable, however, would cause a syntax error if you tried to run the program containing this code, because <code>name</code> is not initialized.</p>

<h5 id="leanpub-auto-constants-vs-let-declarations">Constants vs Let Declarations</h5>

<p>Constants, like <code>let</code> declarations, are block-level declarations. That means constants are no longer accessible once execution flows out of the block in which they were declared, and declarations are not hoisted, as demonstrated in this example:</p>

<figure class="code">
<pre><code>if (condition) {
    const maxItems = 5;

    // more code
}

// maxItems isn't accessible here
</code></pre>

</figure>

<p>In this code, the constant <code>maxItems</code> is declared within an <code>if</code> statement. Once the statement finishes executing, <code>maxItems</code> is not accessible outside of that block.</p>

<p>In another similarity to <code>let</code>, a <code>const</code> declaration throws an error when made with an identifier for an already-defined variable in the same scope. It doesn't matter if that variable was declared using <code>var</code> (for global or function scope) or <code>let</code> (for block scope). For example, consider this code:</p>

<figure class="code">
<pre><code>var message = "Hello!";
let age = 25;

// Each of these would throw an error.
const message = "Goodbye!";
const age = 30;
</code></pre>

</figure>

<p>The two <code>const</code> declarations would be valid alone, but given the previous <code>var</code> and <code>let</code> declarations in this case, neither will work as intended.</p>

<p>Despite those similarities, there is one big difference between <code>let</code> and <code>const</code> to remember. Attempting to assign a <code>const</code> to a previously defined constant will throw an error, in both strict and non-strict modes:</p>

<figure class="code">
<pre><code>const maxItems = 5;

maxItems = 6;      // throws error
</code></pre>

</figure>

<p>Much like constants in other languages, the <code>maxItems</code> variable can't be assigned a new value later on. However, unlike constants in other languages, the value a constant holds may be modified if it is an object.</p>

<h5 id="leanpub-auto-declaring-objects-with-const">Declaring Objects with Const</h5>

<p>A <code>const</code> declaration prevents modification of the binding and not of the value itself. That means <code>const</code> declarations for objects do not prevent modification of those objects. For example:</p>

<figure class="code">
<pre><code>const person = {
    name: "Nicholas"
};

// works
person.name = "Greg";

// throws an error
person = {
    name: "Greg"
};
</code></pre>

</figure>

<p>Here, the binding <code>person</code> is created with an initial value of an object with one property. It's possible to change <code>person.name</code> without causing an error because this changes what <code>person</code> contains and doesn't change the value that <code>person</code> is bound to. When this code attempts to assign a value to <code>person</code> (thus attempting to change the binding), an error will be thrown. This subtlety in how <code>const</code> works with objects is easy to misunderstand. Just remember: <code>const</code> prevents modification of the binding, not modification of the bound value.</p>

<h4 id="leanpub-auto-the-temporal-dead-zone">The Temporal Dead Zone</h4>

<p>A variable declared with either <code>let</code> or <code>const</code> cannot be accessed until after the declaration. Attempting to do so results in a reference error, even when using normally safe operations such as the <code>typeof</code> operation in this example:</p>

<figure class="code">
<pre><code>if (condition) {
    console.log(typeof value);  // ReferenceError!
    let value = "blue";
}
</code></pre>

</figure>

<p>Here, the variable <code>value</code> is defined and initialized using <code>let</code>, but that statement is never executed because the previous line throws an error. The issue is that <code>value</code> exists in what the JavaScript community has dubbed the <em>temporal dead zone</em> (TDZ). The TDZ is never named explicitly in the ECMAScript specification, but the term is often used to describe why <code>let</code> and <code>const</code> declarations are not accessible before their declaration. This section covers some subtleties of declaration placement that the TDZ causes, and although the examples shown all use <code>let</code>, note that the same information applies to <code>const</code>.</p>

<p>When a JavaScript engine looks through an upcoming block and finds a variable declaration, it either hoists the declaration to the top of the function or global scope (for <code>var</code>) or places the declaration in the TDZ (for <code>let</code> and <code>const</code>). Any attempt to access a variable in the TDZ results in a runtime error. That variable is only removed from the TDZ, and therefore safe to use, once execution flows to the variable declaration.</p>

<p>This is true anytime you attempt to use a variable declared with <code>let</code> or <code>const</code>  before it's been defined. As the previous example demonstrated, this even applies to the normally safe <code>typeof</code> operator. You can, however, use <code>typeof</code> on a variable outside of the block where that variable is declared, though it may not give the results you're after. Consider this code:</p>

<figure class="code">
<pre><code>console.log(typeof value);     // "undefined"

if (condition) {
    let value = "blue";
}
</code></pre>

</figure>

<p>The variable <code>value</code> isn't in the TDZ when the <code>typeof</code> operation executes because it occurs outside of the block in which <code>value</code> is declared. That means there is no <code>value</code> binding, and <code>typeof</code> simply returns <code>"undefined"</code>.</p>

<p>The TDZ is just one unique aspect of block bindings. Another unique aspect has to do with their use inside of loops.</p>

<h3 id="leanpub-auto-block-binding-in-loops">Block Binding in Loops</h3>

<p>Perhaps one area where developers most want block level scoping of variables is within <code>for</code> loops, where the throwaway counter variable is meant to be used only inside the loop. For instance, it's not uncommon to see code like this in JavaScript:</p>

<figure class="code">
<pre><code>for (var i = 0; i &lt; 10; i++) {
    process(items[i]);
}

// i is still accessible here
console.log(i);                     // 10
</code></pre>

</figure>

<p>In other languages, where block level scoping is the default, this example should work as intended, and only the <code>for</code> loop should have access to the <code>i</code> variable. In JavaScript, however, the variable <code>i</code> is still accessible after the loop is completed because the <code>var</code> declaration gets hoisted. Using <code>let</code> instead, as in the following code, should give the intended behavior:</p>

<figure class="code">
<pre><code>for (let i = 0; i &lt; 10; i++) {
    process(items[i]);
}

// i is not accessible here - throws an error
console.log(i);
</code></pre>

</figure>

<p>In this example, the variable <code>i</code> only exists within the <code>for</code> loop. Once the loop is complete, the variable is no longer accessible elsewhere.</p>

<h4 id="leanpub-auto-functions-in-loops">Functions in Loops</h4>

<p>The characteristics of <code>var</code> have long made creating functions inside of loops problematic, because the loop variables are accessible from outside the scope of the loop. Consider the following code:</p>

<figure class="code">
<pre><code>var funcs = [];

for (var i = 0; i &lt; 10; i++) {
    funcs.push(function() { console.log(i); });
}

funcs.forEach(function(func) {
    func();     // outputs the number "10" ten times
});
</code></pre>

</figure>

<p>You might ordinarily expect this code to print the numbers 0 to 9, but it outputs the number 10 ten times in a row. That's because <code>i</code> is shared across each iteration of the loop, meaning the functions created inside the loop all hold a reference to the same variable. The variable <code>i</code> has a value of <code>10</code> once the loop completes, and so when <code>console.log(i)</code> is called, that value prints each time.</p>

<p>To fix this problem, developers use immediately-invoked function expressions (IIFEs) inside of loops to force a new copy of the variable they want to iterate over to be created, as in this example:</p>

<figure class="code">
<pre><code>var funcs = [];

for (var i = 0; i &lt; 10; i++) {
    funcs.push((function(value) {
        return function() {
            console.log(value);
        }
    }(i)));
}

funcs.forEach(function(func) {
    func();     // outputs 0, then 1, then 2, up to 9
});
</code></pre>

</figure>

<p>This version uses an IIFE inside of the loop. The <code>i</code> variable is passed to the IIFE, which creates its own copy and stores it as <code>value</code>. This is the value used by the function for that iteration, so calling each function returns the expected value as the loop counts up from 0 to 9. Fortunately, block-level binding with <code>let</code> and <code>const</code> in ECMAScript 6 can simplify this loop for you.</p>

<h4 id="leanpub-auto-let-declarations-in-loops">Let Declarations in Loops</h4>

<p>A <code>let</code> declaration simplifies loops by effectively mimicking what the IIFE does in the previous example. On each iteration, the loop creates a new variable and initializes it to the value of the variable with the same name from the previous iteration. That means you can omit the IIFE altogether and get the results you expect, like this:</p>

<figure class="code">
<pre><code>var funcs = [];

for (let i = 0; i &lt; 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}

funcs.forEach(function(func) {
    func();     // outputs 0, then 1, then 2, up to 9
})
</code></pre>

</figure>

<p>This loop works exactly like the loop that used <code>var</code> and an IIFE but is, arguably, cleaner. The <code>let</code> declaration creates a new variable <code>i</code> each time through the loop, so each function created inside the loop gets its own copy of <code>i</code>. Each copy of <code>i</code> has the value it was assigned at the beginning of the loop iteration in which it was created. The same is true for <code>for-in</code> and <code>for-of</code> loops, as shown here:</p>

<figure class="code">
<pre><code>var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

for (let key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // outputs "a", then "b", then "c"
});
</code></pre>

</figure>

<p>In this example, the <code>for-in</code> loop shows the same behavior as the <code>for</code> loop. Each time through the loop, a new <code>key</code> binding is created, and so each function has its own copy of the <code>key</code> variable. The result is that each function outputs a different value. If <code>var</code> were used to declare <code>key</code>, all functions would output <code>"c"</code>.</p>

<aside class="information blurb">
    <p>It's important to understand that the behavior of <code>let</code> declarations in loops is a specially-defined behavior in the specification and is not necessarily related to the non-hoisting characteristics of <code>let</code>. In fact, early implementations of <code>let</code> did not have this behavior, as it was added later on in the process.</p>

</aside>

<h4 id="leanpub-auto-constant-declarations-in-loops">Constant Declarations in Loops</h4>

<p>The ECMAScript 6 specification doesn't explicitly disallow <code>const</code> declarations in loops; however, there are different behaviors based on the type of loop you're using. For a normal <code>for</code> loop, you can use <code>const</code> in the initializer, but the loop will throw a warning if you attempt to change the value. For example:</p>

<figure class="code">
<pre><code>var funcs = [];

// throws an error after one iteration
for (const i = 0; i &lt; 10; i++) {
    funcs.push(function() {
        console.log(i);
    });
}
</code></pre>

</figure>

<p>In this code, the <code>i</code> variable is declared as a constant. The first iteration of the loop, where <code>i</code> is 0, executes successfully. An error is thrown when <code>i++</code> executes because it's attempting to modify a constant. As such, you can only use <code>const</code> to declare a variable in the loop initializer if you are not modifying that variable.</p>

<p>When used in a <code>for-in</code> or <code>for-of</code> loop, on the other hand, a <code>const</code> variable behaves the same as a <code>let</code> variable. So the following should not cause an error:</p>

<figure class="code">
<pre><code>var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

// doesn't cause an error
for (const key in object) {
    funcs.push(function() {
        console.log(key);
    });
}

funcs.forEach(function(func) {
    func();     // outputs "a", then "b", then "c"
});
</code></pre>

</figure>

<p>This code functions almost exactly the same as the second example in the "Let Declarations in Loops" section. The only difference is that the value of <code>key</code> cannot be changed inside the loop. The <code>for-in</code> and <code>for-of</code> loops work with <code>const</code> because the loop initializer creates a new binding on each iteration through the loop rather than attempting to modify the value of an existing binding (as was the case with the previous example using <code>for</code> instead of <code>for-in</code>).</p>

<h3 id="leanpub-auto-global-block-bindings">Global Block Bindings</h3>

<p>Another way in which <code>let</code> and <code>const</code> are different from <code>var</code> is in their global scope behavior. When <code>var</code> is used in the global scope, it creates a new global variable, which is a property on the global object (<code>window</code> in browsers). That means you can accidentally overwrite an existing global using <code>var</code>, such as:</p>

<figure class="code">
<pre><code>// in a browser
var RegExp = "Hello!";
console.log(window.RegExp);     // "Hello!"

var ncz = "Hi!";
console.log(window.ncz);        // "Hi!"
</code></pre>

</figure>

<p>Even though the <code>RegExp</code> global is defined on <code>window</code>, it is not safe from being overwritten by a <code>var</code> declaration. This example declares a new global variable <code>RegExp</code> that overwrites the original. Similarly, <code>ncz</code> is defined as a global variable and immediately defined as a property on <code>window</code>. This is the way JavaScript has always worked.</p>

<p>If you instead use <code>let</code> or <code>const</code> in the global scope, a new binding is created in the global scope but no property is added to the global object. That also means you cannot overwrite a global variable using <code>let</code> or <code>const</code>, you can only shadow it. Here's an example:</p>

<figure class="code">
<pre><code>// in a browser
let RegExp = "Hello!";
console.log(RegExp);                    // "Hello!"
console.log(window.RegExp === RegExp);  // false

const ncz = "Hi!";
console.log(ncz);                       // "Hi!"
console.log("ncz" in window);           // false
</code></pre>

</figure>

<p>Here, a new <code>let</code> declaration for <code>RegExp</code> creates a binding that shadows the global <code>RegExp</code>. That means <code>window.RegExp</code> and <code>RegExp</code> are not the same, so there is no disruption to the global scope. Also, the <code>const</code> declaration for <code>ncz</code> creates a binding but does not create a property on the global object. This capability makes <code>let</code> and <code>const</code> a lot safer to use in the global scope when you don't want to create properties on the global object.</p>

<aside class="information blurb">
    <p>You may still want to use <code>var</code> in the global scope if you have a code that should be available from the global object. This is most common in a browser when you want to access code across frames or windows.</p>

</aside>

<h3 id="leanpub-auto-emerging-best-practices-for-block-bindings">Emerging Best Practices for Block Bindings</h3>

<p>While ECMAScript 6 was in development, there was widespread belief you should use <code>let</code> by default instead of <code>var</code> for variable declarations. For many JavaScript developers, <code>let</code> behaves exactly the way they thought <code>var</code> should have behaved, and so the direct replacement makes logical sense. In this case, you would use <code>const</code> for variables that needed modification protection.</p>

<p>However, as more developers migrated to ECMAScript 6, an alternate approach gained popularity: use <code>const</code> by default and only use <code>let</code> when you know a variable's value needs to change. The rationale is that most variables should not change their value after initialization because unexpected value changes are a source of bugs. This idea has a significant amount of traction and is worth exploring in your code as you adopt ECMAScript 6.</p>

<h3 id="leanpub-auto-summary">Summary</h3>

<p>The <code>let</code> and <code>const</code> block bindings introduce lexical scoping to JavaScript. These declarations are not hoisted and only exist within the block in which they are declared. This offers behavior that is more like other languages and less likely to cause unintentional errors, as variables can now be declared exactly where they are needed. As a side effect, you cannot access variables before they are declared, even with safe operators such as <code>typeof</code>. Attempting to access a block binding before its declaration results in an error due to the binding's presence in the temporal dead zone (TDZ).</p>

<p>In many cases, <code>let</code> and <code>const</code> behave in a manner similar to <code>var</code>; however, this is not true for loops. For both <code>let</code> and <code>const</code>, <code>for-in</code> and <code>for-of</code> loops create a new binding with each iteration through the loop. That means functions created inside the loop body can access the loop bindings values as they are during the current iteration, rather than as they were after the loop's final iteration (the behavior with <code>var</code>). The same is true for <code>let</code> declarations in <code>for</code> loops, while attempting to use <code>const</code> declarations in a <code>for</code> loop may result in an error.</p>

<p>The current best practice for block bindings is to use <code>const</code> by default and only use <code>let</code> when you know a variable's value needs to change. This ensures a basic level of immutability in code that can help prevent certain types of errors.</p>


<h2 id="leanpub-auto-strings-and-regular-expressions">Strings and Regular Expressions</h2>

<p>Strings are arguably one of the most important data types in programming. They're in nearly every higher-level programming language, and being able to work with them effectively is fundamental for developers to create useful programs. By extension, regular expressions are important because of the extra power they give developers to wield on strings. With these facts in mind, the creators of ECMAScript 6 improved strings and regular expressions by adding new capabilities and long-missing functionality. This chapter gives a tour of both types of changes.</p>

<h3 id="leanpub-auto-better-unicode-support">Better Unicode Support</h3>

<p>Before ECMAScript 6, JavaScript strings revolved around 16-bit character encoding (UTF-16). Each 16-bit sequence is a <em>code unit</em> representing a character. All string properties and methods, like the <code>length</code> property and the <code>charAt()</code> method, were based on these 16-bit code units. Of course, 16 bits used to be enough to contain any character. That's no longer true thanks to the expanded character set introduced by Unicode.</p>

<h4 id="leanpub-auto-utf-16-code-points">UTF-16 Code Points</h4>

<p>Limiting character length to 16 bits wasn't possible for Unicode's stated goal of providing a globally unique identifier to every character in the world. These globally unique identifiers, called <em>code points</em>, are simply numbers starting at 0. Code points are what you may think of as character codes, where a number represents a character. A character encoding must encode code points into code units that are internally consistent. For UTF-16, code points can be made up of many code units.</p>

<p>The first 2<sup>16</sup> code points in UTF-16 are represented as single 16-bit code units. This range is called the <em>Basic Multilingual Plane</em> (BMP). Everything beyond that is considered to be in one of the <em>supplementary planes</em>, where the code points can no longer be represented in just 16-bits. UTF-16 solves this problem by introducing <em>surrogate pairs</em> in which a single code point is represented by two 16-bit code units. That means any single character in a string can be either one code unit for BMP characters, giving a total of 16 bits, or two units for supplementary plane characters, giving a total of 32 bits.</p>

<p>In ECMAScript 5, all string operations work on 16-bit code units, meaning that you can get unexpected results from UTF-16 encoded strings containing surrogate pairs, as in this example:</p>

<figure class="code">
<pre><code>var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""
console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
</code></pre>

</figure>

<p>The single Unicode character <code>"𠮷"</code> is represented using surrogate pairs, and as such, the JavaScript string operations above treat the string as having two 16-bit characters. That means:</p>

<ul>
  <li>The <code>length</code> of <code>text</code> is 2, when it should be 1.</li>
  <li>A regular expression trying to match a single character fails because it thinks there are two characters.</li>
  <li>The <code>charAt()</code> method is unable to return a valid character string, because neither set of 16 bits corresponds to a printable character.</li>
</ul>

<p>The <code>charCodeAt()</code> method also just can't identify the character properly. It returns the appropriate 16-bit number for each code unit, but that is the closest you could get to the real value of <code>text</code> in ECMAScript 5.</p>

<p>ECMAScript 6, on the other hand, enforces UTF-16 string encoding to address problems like these. Standardizing string operations based on this character encoding means that JavaScript can support functionality designed to work specifically with surrogate pairs. The rest of this section discusses a few key examples of that functionality.</p>

<h4 id="leanpub-auto-the-codepointat-method">The codePointAt() Method</h4>

<p>One method ECMAScript 6 added to fully support UTF-16 is the <code>codePointAt()</code> method, which retrieves the Unicode code point that maps to a given position in a string. This method accepts the code unit position rather than the character position and returns an integer value, as these <code>console.log()</code> examples show:</p>

<figure class="code">
<pre><code>var text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
</code></pre>

</figure>

<p>The <code>codePointAt()</code> method returns the same value as the <code>charCodeAt()</code> method unless it operates on non-BMP characters. The first character in <code>text</code> is non-BMP and is therefore comprised of two code units, meaning the <code>length</code> property is 3 rather than 2. The <code>charCodeAt()</code> method returns only the first code unit for position 0, but <code>codePointAt()</code> returns the full code point even though the code point spans multiple code units. Both methods return the same value for positions 1 (the second code unit of the first character) and 2 (the <code>"a"</code> character).</p>

<p>Calling the <code>codePointAt()</code> method on a character is the easiest way to determine if that character is represented by one or two code points. Here's a function you could write to check:</p>

<figure class="code">
<pre><code>function is32Bit(c) {
    return c.codePointAt(0) &gt; 0xFFFF;
}

console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false
</code></pre>

</figure>

<p>The upper bound of 16-bit characters is represented in hexadecimal as <code>FFFF</code>, so any code point above that number must be represented by two code units, for a total of 32 bits.</p>

<h4 id="leanpub-auto-the-stringfromcodepoint-method">The String.fromCodePoint() Method</h4>

<p>When ECMAScript provides a way to do something, it also tends to provide a way to do the reverse. You can use <code>codePointAt()</code> to retrieve the code point for a character in a string, while <code>String.fromCodePoint()</code> produces a single-character string from a given code point. For example:</p>

<figure class="code">
<pre><code>console.log(String.fromCodePoint(134071));  // "𠮷"
</code></pre>

</figure>

<p>Think of <code>String.fromCodePoint()</code> as a more complete version of the <code>String.fromCharCode()</code> method. Both give the same result for all characters in the BMP. There's only a difference when you pass code points for characters outside of the BMP.</p>

<h4 id="leanpub-auto-the-normalize-method">The normalize() Method</h4>

<p>Another interesting aspect of Unicode is that different characters may be considered equivalent for the purpose of sorting or other comparison-based operations. There are two ways to define these relationships. First, <em>canonical equivalence</em> means that two sequences of code points are considered interchangeable in all respects. For example, a combination of two characters can be canonically equivalent to one character. The second relationship is <em>compatibility</em>. Two compatible sequences of code points look different but can be used interchangeably in certain situations.</p>

<p>Due to these relationships, two strings representing fundamentally the same text can contain different code point sequences. For example, the character "æ" and the two-character string "ae" may be used interchangeably but are strictly not equivalent unless normalized in some way.</p>

<p>ECMAScript 6 supports Unicode normalization forms by giving strings a <code>normalize()</code> method. This method optionally accepts a single string parameter indicating one of the  following Unicode normalization forms to apply:</p>

<ul>
  <li>Normalization Form Canonical Composition (<code>"NFC"</code>), which is the default</li>
  <li>Normalization Form Canonical Decomposition (<code>"NFD"</code>)</li>
  <li>Normalization Form Compatibility Composition (<code>"NFKC"</code>)</li>
  <li>Normalization Form Compatibility Decomposition (<code>"NFKD"</code>)</li>
</ul>

<p>It's beyond the scope of this book to explain the differences between these four forms. Just keep in mind that when comparing strings, both strings must be normalized to the same form. For example:</p>

<figure class="code">
<pre><code>var normalized = values.map(function(text) {
    return text.normalize();
});

normalized.sort(function(first, second) {
    if (first &lt; second) {
        return -1;
    } else if (first === second) {
        return 0;
    } else {
        return 1;
    }
});
</code></pre>

</figure>

<p>This code converts the strings in the <code>values</code> array into a normalized form so that the array can be sorted appropriately. You can also sort the original array by calling <code>normalize()</code> as part of the comparator, as follows:</p>

<figure class="code">
<pre><code>values.sort(function(first, second) {
    var firstNormalized = first.normalize(),
        secondNormalized = second.normalize();

    if (firstNormalized &lt; secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
</code></pre>

</figure>

<p>Once again, the most important thing to note about this code is that both <code>first</code> and <code>second</code> are normalized in the same way. These examples have used the default, NFC, but you can just as easily specify one of the others, like this:</p>

<figure class="code">
<pre><code>values.sort(function(first, second) {
    var firstNormalized = first.normalize("NFD"),
        secondNormalized = second.normalize("NFD");

    if (firstNormalized &lt; secondNormalized) {
        return -1;
    } else if (firstNormalized === secondNormalized) {
        return 0;
    } else {
        return 1;
    }
});
</code></pre>

</figure>

<p>If you've never worried about Unicode normalization before, then you probably won't have much use for this method now. But if you ever work on an internationalized application, you'll definitely find the <code>normalize()</code> method helpful.</p>

<p>Methods aren't the only improvements that ECMAScript 6 provides for working with Unicode strings, though. The standard also adds two useful syntax elements.</p>

<h4 id="leanpub-auto-the-regular-expression-u-flag">The Regular Expression u Flag</h4>

<p>You can accomplish many common string operations through regular expressions. But remember, regular expressions assume 16-bit code units, where each represents a single character. To address this problem, ECMAScript 6 defines a <code>u</code> flag for regular expressions, which stands for Unicode.</p>

<h5 id="leanpub-auto-the-u-flag-in-action">The u Flag in Action</h5>

<p>When a regular expression has the <code>u</code> flag set, it switches modes to work on characters, not code units. That means the regular expression should no longer get confused about surrogate pairs in strings and should behave as expected. For example, consider this code:</p>

<figure class="code">
<pre><code>var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(/^.$/u.test(text));     // true
</code></pre>

</figure>

<p>The regular expression <code>/^.$/</code> matches any input string with a single character. When used without the <code>u</code> flag, this regular expression matches on code units, and so the Japanese character (which is represented by two code units) doesn't match the regular expression. When used with the <code>u</code> flag, the regular expression compares characters instead of code units and so the Japanese character matches.</p>

<h5 id="leanpub-auto-counting-code-points">Counting Code Points</h5>

<p>Unfortunately, ECMAScript 6 doesn't add a method to determine how many code points a string has, but with the <code>u</code> flag, you can use regular expressions to figure it out as follows:</p>

<figure class="code">
<pre><code>function codePointLength(text) {
    var result = text.match(/[\s\S]/gu);
    return result ? result.length : 0;
}

console.log(codePointLength("abc"));    // 3
console.log(codePointLength("𠮷bc"));   // 3
</code></pre>

</figure>

<p>This example calls <code>match()</code> to check <code>text</code> for both whitespace and non-whitespace characters (using <code>[\s\S]</code> to ensure the pattern matches newlines), using a regular expression that is applied globally with Unicode enabled. The <code>result</code> contains an array of matches when there's at least one match, so the array length is the number of code points in the string. In Unicode, the strings <code>"abc"</code> and <code>"𠮷bc"</code> both have three characters, so the array length is three.</p>

<aside class="warning blurb">
    <p>Although this approach works, it's not very fast, especially when applied to long strings. You can use a string iterator (discussed in Chapter 8) as well. In general, try to minimize counting code points whenever possible.</p>

</aside>

<h5 id="leanpub-auto-determining-support-for-the-u-flag">Determining Support for the u Flag</h5>

<p>Since the <code>u</code> flag is a syntax change, attempting to use it in JavaScript engines that aren't compatible with ECMAScript 6 throws a syntax error. The safest way to determine if the <code>u</code> flag is supported is with a function, like this one:</p>

<figure class="code">
<pre><code>function hasRegExpU() {
    try {
        var pattern = new RegExp(".", "u");
        return true;
    } catch (ex) {
        return false;
    }
}
</code></pre>

</figure>

<p>This function uses the <code>RegExp</code> constructor to pass in the <code>u</code> flag as an argument. This syntax is valid even in older JavaScript engines, but the constructor will throw an error if <code>u</code> isn't supported.</p>

<aside class="information blurb">
    <p>If your code still needs to work in older JavaScript engines, always use the <code>RegExp</code> constructor when using the <code>u</code> flag. This will prevent syntax errors and allow you to optionally detect and use the <code>u</code> flag without aborting execution.</p>

</aside>

<h3 id="leanpub-auto-other-string-changes">Other String Changes</h3>

<p>JavaScript strings have always lagged behind similar features of other languages. It was only in ECMAScript 5 that strings finally gained a <code>trim()</code> method, for example, and ECMAScript 6 continues extending JavaScript's capacity to parse strings with new functionality.</p>

<h4 id="leanpub-auto-methods-for-identifying-substrings">Methods for Identifying Substrings</h4>

<p>Developers have used the <code>indexOf()</code> method to identify strings inside other strings since JavaScript was first introduced. ECMAScript 6 includes the following three methods, which are designed to do just that:</p>

<ul>
  <li>The <code>includes()</code> method returns true if the given text is found anywhere within the string. It returns false if not.</li>
  <li>The <code>startsWith()</code> method returns true if the given text is found at the beginning of the string. It returns false if not.</li>
  <li>The <code>endsWith()</code> method returns true if the given text is found at the end of the string. It returns false if not.</li>
</ul>

<p>Each methods accept two arguments: the text to search for and an optional index from which to start the search. When the second argument is provided, <code>includes()</code> and <code>startsWith()</code> start the match from that index while <code>endsWith()</code> starts the match from the length of the string minus the second argument; when the second argument is omitted, <code>includes()</code> and <code>startsWith()</code> search from the beginning of the string, while <code>endsWith()</code> starts from the end. In effect, the second argument minimizes the amount of the string being searched. Here are some examples showing these three methods in action:</p>

<figure class="code">
<pre><code>var msg = "Hello world!";

console.log(msg.startsWith("Hello"));       // true
console.log(msg.endsWith("!"));             // true
console.log(msg.includes("o"));             // true

console.log(msg.startsWith("o"));           // false
console.log(msg.endsWith("world!"));        // true
console.log(msg.includes("x"));             // false

console.log(msg.startsWith("o", 4));        // true
console.log(msg.endsWith("o", 8));          // true
console.log(msg.includes("o", 8));          // false
</code></pre>

</figure>

<p>The first six calls don't include a second parameter, so they'll search the whole string if needed. The last three calls only check part of the string. The call to <code>msg.startsWith("o", 4)</code> starts the match by looking at index 4 of the <code>msg</code> string, which is the "o" in "Hello". The call to <code>msg.endsWith("o", 8)</code> starts the match at index 4 as well, because the <code>8</code> argument is subtracted from the string length (12). The call to <code>msg.includes("o", 8)</code> starts the match from index 8, which is the "r" in "world".</p>

<p>While these three methods make identifying the existence of substrings easier, each only returns a boolean value. If you need to find the actual position of one string within another, use the <code>indexOf()</code> or <code>lastIndexOf()</code> methods.</p>

<aside class="warning blurb">
    <p>The <code>startsWith()</code>, <code>endsWith()</code>, and <code>includes()</code> methods will throw an error if you pass a regular expression instead of a string. This stands in contrast to <code>indexOf()</code> and <code>lastIndexOf()</code>, which both convert a regular expression argument into a string and then search for that string.</p>

</aside>

<h4 id="leanpub-auto-the-repeat-method">The repeat() Method</h4>

<p>ECMAScript 6 also adds a <code>repeat()</code> method to strings, which accepts the number of times to repeat the string as an argument. It returns a new string containing the original string repeated the specified number of times. For example:</p>

<figure class="code">
<pre><code>console.log("x".repeat(3));         // "xxx"
console.log("hello".repeat(2));     // "hellohello"
console.log("abc".repeat(4));       // "abcabcabcabc"
</code></pre>

</figure>

<p>This method is a convenience function above all else, and it can be especially useful when manipulating text. It's particularly useful in code formatting utilities that need to create indentation levels, like this:</p>

<figure class="code">
<pre><code>// indent using a specified number of spaces
var indent = " ".repeat(4),
    indentLevel = 0;

// whenever you increase the indent
var newIndent = indent.repeat(++indentLevel);
</code></pre>

</figure>

<p>The first <code>repeat()</code> call creates a string of four spaces, and the <code>indentLevel</code> variable keeps track of the indent level. Then, you can just call <code>repeat()</code> with an incremented <code>indentLevel</code> to change the number of spaces.</p>

<p>ECMAScript 6 also makes some useful changes to regular expression functionality that don't fit into a particular category. The next section highlights a few.</p>

<h3 id="leanpub-auto-other-regular-expression-changes">Other Regular Expression Changes</h3>

<p>Regular expressions are an important part of working with strings in JavaScript, and like many parts of the language, they haven't changed much in recent versions. ECMAScript 6, however, makes several improvements to regular expressions to go along with the updates to strings.</p>

<h4 id="leanpub-auto-the-regular-expression-y-flag">The Regular Expression y Flag</h4>

<p>ECMAScript 6 standardized the <code>y</code> flag after it was implemented in Firefox as a proprietary extension to regular expressions. The <code>y</code> flag affects a regular expression search's <code>sticky</code> property, and it tells the search to start matching characters in a string at the position specified by the regular expression's <code>lastIndex</code> property. If there is no match at that location, then the regular expression stops matching. To see how this works, consider the following code:</p>

<figure class="code">
<pre><code>var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // Error! stickyResult is null
</code></pre>

</figure>

<p>This example has three regular expressions. The expression in <code>pattern</code> has no flags, the one in <code>globalPattern</code> uses the <code>g</code> flag, and the one in <code>stickyPattern</code> uses the <code>y</code> flag. In the first trio of <code>console.log()</code> calls, all three regular expressions should return <code>"hello1 "</code> with a space at the end.</p>

<p>After that, the <code>lastIndex</code> property is changed to 1 on all three patterns, meaning that the regular expression should start matching from the second character on all of them. The regular expression with no flags completely ignores the change to <code>lastIndex</code> and still matches <code>"hello1 "</code> without incident. The regular expression with the <code>g</code> flag goes on to match <code>"hello2 "</code> because it is searching forward from the second character of the string (<code>"e"</code>). The sticky regular expression doesn't match anything beginning at the second character so <code>stickyResult</code> is <code>null</code>.</p>

<p>The sticky flag saves the index of the next character after the last match in <code>lastIndex</code> whenever an operation is performed. If an operation results in no match, then <code>lastIndex</code> is set back to 0. The global flag behaves the same way, as demonstrated here:</p>

<figure class="code">
<pre><code>var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 7
console.log(stickyPattern.lastIndex);   // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // "hello2 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 14
console.log(stickyPattern.lastIndex);   // 14
</code></pre>

</figure>

<p>The value of <code>lastIndex</code> changes to 7 after the first call to <code>exec()</code> and to 14 after the second call, for both the <code>stickyPattern</code> and <code>globalPattern</code> variables.</p>

<p>There are two more subtle details about the sticky flag to keep in mind:</p>

<ol class="numeric">
  <li>The <code>lastIndex</code> property is only honored when calling methods that exist on the regular expression object, like the <code>exec()</code> and <code>test()</code> methods. Passing the regular expression to a string method, such as <code>match()</code>, will not result in the sticky behavior.</li>
  <li>When using the <code>^</code> character to match the start of a string, sticky regular expressions only match from the start of the string (or the start of the line in multiline mode). While <code>lastIndex</code> is 0, the <code>^</code> makes a sticky regular expression no different from a non-sticky one. If <code>lastIndex</code> doesn't correspond to the beginning of the string in single-line mode or the beginning of a line in multiline mode, the sticky regular expression will never match.</li>
</ol>

<p>As with other regular expression flags, you can detect the presence of <code>y</code> by using a property. In this case, you'd check the <code>sticky</code> property, as follows:</p>

<figure class="code">
<pre><code>var pattern = /hello\d/y;

console.log(pattern.sticky);    // true
</code></pre>

</figure>

<p>The <code>sticky</code> property is set to true if the sticky flag is present, and the property is false if not. The <code>sticky</code> property is read-only based on the presence of the flag and cannot be changed in code.</p>

<p>Similar to the <code>u</code> flag, the <code>y</code> flag is a syntax change, so it will cause a syntax error in older JavaScript engines. You can use the following approach to detect support:</p>

<figure class="code">
<pre><code>function hasRegExpY() {
    try {
        var pattern = new RegExp(".", "y");
        return true;
    } catch (ex) {
        return false;
    }
}
</code></pre>

</figure>

<p>Just like the <code>u</code> check, this returns false if it's unable to create a regular expression with the <code>y</code> flag. In one final similarity to <code>u</code>, if you need to use <code>y</code> in code that runs in older JavaScript engines, be sure to use the <code>RegExp</code> constructor when defining those regular expressions to avoid a syntax error.</p>

<h4 id="leanpub-auto-duplicating-regular-expressions">Duplicating Regular Expressions</h4>

<p>In ECMAScript 5, you can duplicate regular expressions by passing them into the <code>RegExp</code> constructor like this:</p>

<figure class="code">
<pre><code>var re1 = /ab/i,
    re2 = new RegExp(re1);
</code></pre>

</figure>

<p>The <code>re2</code> variable is just a copy of the <code>re1</code> variable. But if you provide the second argument to the <code>RegExp</code> constructor, which specifies the flags for the regular expression, your code won't work, as in this example:</p>

<figure class="code">
<pre><code>var re1 = /ab/i,

    // throws an error in ES5, okay in ES6
    re2 = new RegExp(re1, "g");
</code></pre>

</figure>

<p>If you execute this code in an ECMAScript 5 environment, you'll get an error stating that the second argument cannot be used when the first argument is a regular expression. ECMAScript 6 changed this behavior such that the second argument is allowed and overrides any flags present on the first argument. For example:</p>

<figure class="code">
<pre><code>var re1 = /ab/i,

    // throws an error in ES5, okay in ES6
    re2 = new RegExp(re1, "g");


console.log(re1.toString());            // "/ab/i"
console.log(re2.toString());            // "/ab/g"

console.log(re1.test("ab"));            // true
console.log(re2.test("ab"));            // true

console.log(re1.test("AB"));            // true
console.log(re2.test("AB"));            // false
</code></pre>

</figure>

<p>In this code, <code>re1</code> has the case-insensitive <code>i</code> flag while <code>re2</code> has only the global <code>g</code> flag. The <code>RegExp</code> constructor duplicated the pattern from <code>re1</code> and substituted the <code>g</code> flag for the <code>i</code> flag. Without the second argument, <code>re2</code> would have the same flags as <code>re1</code>.</p>

<h4 id="leanpub-auto-the-flags-property">The <code>flags</code> Property</h4>

<p>Along with adding a new flag and changing how you can work with flags, ECMAScript 6 added a property associated with them. In ECMAScript 5, you could get the text of a regular expression by using the <code>source</code> property, but to get the flag string, you'd have to parse the output of  the <code>toString()</code> method as shown below:</p>

<figure class="code">
<pre><code>function getFlags(re) {
    var text = re.toString();
    return text.substring(text.lastIndexOf("/") + 1, text.length);
}

// toString() is "/ab/g"
var re = /ab/g;

console.log(getFlags(re));          // "g"
</code></pre>

</figure>

<p>This converts a regular expression into a string and then returns the characters found after the last <code>/</code>. Those characters are the flags.</p>

<p>ECMAScript 6 makes fetching flags easier by adding a <code>flags</code> property to go along with the <code>source</code> property. Both properties are prototype accessor properties with only a getter assigned, making them read-only. The <code>flags</code> property makes inspecting regular expressions easier for both debugging and inheritance purposes.</p>

<p>A late addition to ECMAScript 6, the <code>flags</code> property returns the string representation of any flags applied to a regular expression. For example:</p>

<figure class="code">
<pre><code>var re = /ab/g;

console.log(re.source);     // "ab"
console.log(re.flags);      // "g"
</code></pre>

</figure>

<p>This fetches all flags on <code>re</code> and prints them to the console with far fewer lines of code than the <code>toString()</code> technique can. Using <code>source</code> and <code>flags</code> together allows you to extract the pieces of the regular expression that you need without parsing the regular expression string directly.</p>

<p>The changes to strings and regular expressions that this chapter has covered so far are definitely powerful, but ECMAScript 6 improves your power over strings in a much bigger way. It brings a type of literal to the table that makes strings more flexible.</p>

<h3 id="leanpub-auto-template-literals">Template Literals</h3>

<p>JavaScript's strings have always had limited functionality compared to strings in other languages. For instance, until ECMAScript 6, strings lacked the methods covered so far in this chapter, and string concatenation is as simple as possible. To allow developers to solve more complex problems, ECMAScript 6's <em>template literals</em> provide syntax for creating domain-specific languages (DSLs) for working with content in a safer way than the solutions available in ECMAScript 5 and earlier. (A DSL is a programming language designed for a specific, narrow purpose, as opposed to general-purpose languages like JavaScript.) The ECMAScript wiki offers the following description on the <a href="http://wiki.ecmascript.org/doku.php?id=harmony:quasis">template literal strawman</a>:</p>

<blockquote>
  <p>This scheme extends ECMAScript syntax with syntactic sugar to allow libraries to provide DSLs that easily produce, query, and manipulate content from other languages that are immune or resistant to injection attacks such as XSS, SQL Injection, etc.</p>
</blockquote>

<p>In reality, though, template literals are ECMAScript 6's answer to the following features that JavaScript lacked all the way through ECMAScript 5:</p>

<ul>
  <li>
<strong>Multiline strings</strong> A formal concept of multiline strings.</li>
  <li>
<strong>Basic string formatting</strong> The ability to substitute parts of the string for values contained in variables.</li>
  <li>
<strong>HTML escaping</strong> The ability to transform a string such that it is safe to insert into HTML.</li>
</ul>

<p>Rather than trying to add more functionality to JavaScript's already-existing strings, template literals represent an entirely new approach to solving these problems.</p>

<h4 id="leanpub-auto-basic-syntax">Basic Syntax</h4>

<p>At their simplest, template literals act like regular strings delimited by backticks (<code>`</code>) instead of double or single quotes. For example, consider the following:</p>

<figure class="code">
<pre><code>let message = `Hello world!`;

console.log(message);               // "Hello world!"
console.log(typeof message);        // "string"
console.log(message.length);        // 12
</code></pre>

</figure>

<p>This code demonstrates that the variable <code>message</code> contains a normal JavaScript string. The template literal syntax is used to create the string value, which is then assigned to the <code>message</code> variable.</p>

<p>If you want to use a backtick in your string, then just escape it with a backslash (<code>\</code>), as in this version of the <code>message</code> variable:</p>

<figure class="code">
<pre><code>let message = `\`Hello\` world!`;

console.log(message);               // "`Hello` world!"
console.log(typeof message);        // "string"
console.log(message.length);        // 14
</code></pre>

</figure>

<p>There's no need to escape either double or single quotes inside of template literals.</p>

<h4 id="leanpub-auto-multiline-strings">Multiline Strings</h4>

<p>JavaScript developers have wanted a way to create multiline strings since the first version of the language. But when using double or single quotes, strings must be completely contained on a single line.</p>

<h5 id="leanpub-auto-pre-ecmascript-6-workarounds">Pre-ECMAScript 6 Workarounds</h5>

<p>Thanks to a long-standing syntax bug, JavaScript does have a workaround. You can create multiline strings if there's a backslash (<code>\</code>) before a newline. Here's an example:</p>

<figure class="code">
<pre><code>var message = "Multiline \
string";

console.log(message);       // "Multiline string"
</code></pre>

</figure>

<p>The <code>message</code> string has no newlines present when printed to the console because the backslash is treated as a continuation rather than a newline. In order to show a newline in output, you'd need to manually include it:</p>

<figure class="code">
<pre><code>var message = "Multiline \n\
string";

console.log(message);       // "Multiline
                            //  string"
</code></pre>

</figure>

<p>This should print <code>Multiline String</code> on two separate lines in all major JavaScript engines, but the behavior is defined as a bug and many developers recommend avoiding it.</p>

<p>Other pre-ECMAScript 6 attempts to create multiline strings usually relied on arrays or string concatenation, such as:</p>

<figure class="code">
<pre><code>var message = [
    "Multiline ",
    "string"
].join("\n");

let message = "Multiline \n" +
    "string";
</code></pre>

</figure>

<p>All of the ways developers worked around JavaScript's lack of multiline strings left something to be desired.</p>

<h5 id="leanpub-auto-multiline-strings-the-easy-way">Multiline Strings the Easy Way</h5>

<p>ECMAScript 6's template literals make multiline strings easy because there's no special syntax. Just include a newline where you want, and it shows up in the result. For example:</p>

<figure class="code">
<pre><code>let message = `Multiline
string`;

console.log(message);           // "Multiline
                                //  string"
console.log(message.length);    // 16
</code></pre>

</figure>

<p>All whitespace inside the backticks is part of the string, so be careful with indentation. For example:</p>

<figure class="code">
<pre><code>let message = `Multiline
               string`;

console.log(message);           // "Multiline
                                //                 string"
console.log(message.length);    // 31
</code></pre>

</figure>

<p>In this code, all whitespace before the second line of the template literal is considered part of the string itself. If making the text line up with proper indentation is important to you, then consider leaving nothing on the first line of a multiline template literal and then indenting after that, as follows:</p>

<figure class="code">
<pre><code>let html = `
&lt;div&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
&lt;/div&gt;`.trim();
</code></pre>

</figure>

<p>This code begins the template literal on the first line but doesn't have any text until the second. The HTML tags are indented to look correct and then the <code>trim()</code> method is called to remove the initial empty line.</p>

<aside>
  <p>If you prefer, you can also use <code>\n</code> in a template literal to indicate where a newline should be inserted:</p>
  <figure class="code">
<pre><code>let message = `Multiline\nstring`;

console.log(message);           // "Multiline
                                //  string"
console.log(message.length);    // 16
</code></pre>

  </figure>

</aside>

<h4 id="leanpub-auto-making-substitutions">Making Substitutions</h4>

<p>At this point, template literals may look like fancier versions of normal JavaScript strings. The real difference between the two lies in template literal <em>substitutions</em>. Substitutions allow you to embed any valid JavaScript expression inside a template literal and output the result as part of the string.</p>

<p>Substitutions are delimited by an opening <code>${</code> and a closing <code>}</code> that can have any JavaScript expression inside. The simplest substitutions let you embed local variables directly into a resulting string, like this:</p>

<figure class="code">
<pre><code>let name = "Nicholas",
    message = `Hello, ${name}.`;

console.log(message);       // "Hello, Nicholas."
</code></pre>

</figure>

<p>The substitution <code>${name}</code> accesses the local variable <code>name</code> to insert <code>name</code> into the <code>message</code> string. The <code>message</code> variable then holds the result of the substitution immediately.</p>

<aside class="information blurb">
    <p>A template literal can access any variable accessible in the scope in which it is defined. Attempting to use an undeclared variable in a template literal throws an error in both strict and non-strict modes.</p>

</aside>

<p>Since all substitutions are JavaScript expressions, you can substitute more than just simple variable names. You can easily embed calculations, function calls, and more. For example:</p>

<figure class="code">
<pre><code>let count = 10,
    price = 0.25,
    message = `${count} items cost $${(count * price).toFixed(2)}.`;

console.log(message);       // "10 items cost $2.50."
</code></pre>

</figure>

<p>This code performs a calculation as part of the template literal. The variables <code>count</code> and <code>price</code> are multiplied together to get a result, and then formatted to two decimal places using <code>.toFixed()</code>. The dollar sign before the second substitution is output as-is because it's not followed by an opening curly brace.</p>

<p>Template literals are also JavaScript expressions, which means you can place a template literal inside of another template literal, as in this example:</p>

<figure class="code">
<pre><code>let name = "Nicholas",
    message = `Hello, ${
        `my name is ${ name }`
    }.`;

console.log(message);        // "Hello, my name is Nicholas."
</code></pre>

</figure>

<p>This example nests a second template literal inside the first. After the first <code>${</code>, another template literal begins. The second <code>${</code> indicates the beginning of an embedded expression inside the inner template literal. That expression is the variable <code>name</code>, which is inserted into the result.</p>

<h4 id="leanpub-auto-tagged-templates">Tagged Templates</h4>

<p>Now you've seen how template literals can create multiline strings and insert values into strings without concatenation. But the real power of template literals comes from tagged templates. A <em>template tag</em> performs a transformation on the template literal and returns the final string value. This tag is specified at the start of the template, just before the first <code>`</code> character, as shown here:</p>

<figure class="code">
<pre><code>let message = tag`Hello world`;
</code></pre>

</figure>

<p>In this example, <code>tag</code> is the template tag to apply to the <code>`Hello world`</code> template literal.</p>

<h5 id="leanpub-auto-defining-tags">Defining Tags</h5>

<p>A <em>tag</em> is simply a function that is called with the processed template literal data. The tag receives data about the template literal as individual pieces and must combine the pieces to create the result. The first argument is an array containing the literal strings as interpreted by JavaScript. Each subsequent argument is the interpreted value of each substitution.</p>

<p>Tag functions are typically defined using rest arguments as follows, to make dealing with the data easier:</p>

<figure class="code">
<pre><code>function tag(literals, ...substitutions) {
    // return a string
}
</code></pre>

</figure>

<p>To better understand what gets passed to tags, consider the following:</p>

<figure class="code">
<pre><code>let count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;
</code></pre>

</figure>

<p>If you had a function called <code>passthru()</code>, that function would receive three arguments. First, it would get a <code>literals</code> array, containing the following elements:</p>

<ul>
  <li>The empty string before the first substitution (<code>""</code>)</li>
  <li>The string after the first substitution and before the second (<code>" items cost $"</code>)</li>
  <li>The string after the second substitution (<code>"."</code>)</li>
</ul>

<p>The next argument would be <code>10</code>, which is the interpreted value for the <code>count</code> variable. This becomes the first element in a <code>substitutions</code> array. The final argument would be <code>"2.50"</code>, which is the interpreted value for <code>(count * price).toFixed(2)</code> and the second element in the <code>substitutions</code> array.</p>

<p>Note that the first item in <code>literals</code> is an empty string. This ensures that <code>literals[0]</code> is always the start of the string, just like <code>literals[literals.length - 1]</code> is always the end of the string. There is always one fewer substitution than literal, which means the expression <code>substitutions.length === literals.length - 1</code> is always true.</p>

<p>Using this pattern, the <code>literals</code> and <code>substitutions</code> arrays can be interwoven to create a resulting string. The first item in <code>literals</code> comes first, the first item in <code>substitutions</code> is next, and so on, until the string is complete. As an example, you can mimic the default behavior of a template literal by alternating values from these two arrays:</p>

<figure class="code">
<pre><code>function passthru(literals, ...substitutions) {
    let result = "";

    // run the loop only for the substitution count
    for (let i = 0; i &lt; substitutions.length; i++) {
        result += literals[i];
        result += substitutions[i];
    }

    // add the last literal
    result += literals[literals.length - 1];

    return result;
}

let count = 10,
    price = 0.25,
    message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;

console.log(message);       // "10 items cost $2.50."
</code></pre>

</figure>

<p>This example defines a <code>passthru</code> tag that performs the same transformation as the default template literal behavior. The only trick is to use <code>substitutions.length</code> for the loop rather than <code>literals.length</code> to avoid accidentally going past the end of the <code>substitutions</code> array. This works because the relationship between <code>literals</code> and <code>substitutions</code> is well-defined in ECMAScript 6.</p>

<aside class="information blurb">
    <p>The values contained in <code>substitutions</code> are not necessarily strings. If an expression evaluates to a number, as in the previous example, then the numeric value is passed in. Determining how such values should output in the result is part of the tag's job.</p>

</aside>

<h5 id="leanpub-auto-using-raw-values-in-template-literals">Using Raw Values in Template Literals</h5>

<p>Template tags also have access to raw string information, which primarily means access to character escapes before they are transformed into their character equivalents. The simplest way to work with raw string values is to use the built-in <code>String.raw()</code> tag. For example:</p>

<figure class="code">
<pre><code>let message1 = `Multiline\nstring`,
    message2 = String.raw`Multiline\nstring`;

console.log(message1);          // "Multiline
                                //  string"
console.log(message2);          // "Multiline\\nstring"
</code></pre>

</figure>

<p>In this code, the <code>\n</code> in <code>message1</code> is interpreted as a newline while the <code>\n</code> in <code>message2</code> is returned in its raw form of <code>"\\n"</code> (the slash and <code>n</code> characters). Retrieving the raw string information like this allows for more complex processing when necessary.</p>

<p>The raw string information is also passed into template tags. The first argument in a tag function is an array with an extra property called <code>raw</code>. The <code>raw</code> property is an array containing the raw equivalent of each literal value. For example, the value in <code>literals[0]</code> always has an equivalent <code>literals.raw[0]</code> that contains the raw string information. Knowing that, you can mimic <code>String.raw()</code> using the following code:</p>

<figure class="code">
<pre><code>function raw(literals, ...substitutions) {
    let result = "";

    // run the loop only for the substitution count
    for (let i = 0; i &lt; substitutions.length; i++) {
        result += literals.raw[i];      // use raw values instead
        result += substitutions[i];
    }

    // add the last literal
    result += literals.raw[literals.length - 1];

    return result;
}

let message = raw`Multiline\nstring`;

console.log(message);           // "Multiline\\nstring"
console.log(message.length);    // 17
</code></pre>

</figure>

<p>This uses <code>literals.raw</code> instead of <code>literals</code> to output the string result. That means any character escapes, including Unicode code point escapes, should be returned in their raw form. Raw strings are helpful when you want to output a string containing code in which you'll need to include the character escaping (for instance, if you want to generate documentation about some code, you may want to output the actual code as it appears).</p>

<h3 id="leanpub-auto-summary-1">Summary</h3>

<p>Full Unicode support allows JavaScript to deal with UTF-16 characters in logical ways. The ability to transfer between code point and character via <code>codePointAt()</code> and <code>String.fromCodePoint()</code> is an important step for string manipulation. The addition of the regular expression <code>u</code> flag makes it possible to operate on code points instead of 16-bit characters, and the <code>normalize()</code> method allows for more appropriate string comparisons.</p>

<p>ECMAScript 6 also added new methods for working with strings, allowing you to more easily identify a substring regardless of its position in the parent string. More functionality was added to regular expressions, too.</p>

<p>Template literals are an important addition to ECMAScript 6 that allows you to create domain-specific languages (DSLs) to make creating strings easier. The ability to embed variables directly into template literals means that developers have a safer tool than string concatenation for composing long strings with variables.</p>

<p>Built-in support for multiline strings also makes template literals a useful upgrade over normal JavaScript strings, which have never had this ability. Despite allowing newlines directly inside the template literal, you can still use <code>\n</code> and other character escape sequences.</p>

<p>Template tags are the most important part of this feature for creating DSLs. Tags are functions that receive the pieces of the template literal as arguments. You can then use that data to return an appropriate string value. The data provided includes literals, their raw equivalents, and any substitution values. These pieces of information can then be used to determine the correct output for the tag.</p>


<h2 id="leanpub-auto-functions">Functions</h2>

<p>Functions are an important part of any programming language, and prior to ECMAScript 6, JavaScript functions hadn't changed much since the language was created. This left a backlog of problems and nuanced behavior that made making mistakes easy and often required more code just to achieve very basic behaviors.</p>

<p>ECMAScript 6 functions make a big leap forward, taking into account years of complaints and requests from JavaScript developers. The result is a number of incremental improvements on top of ECMAScript 5 functions that make programming in JavaScript less error-prone and more powerful.</p>

<h3 id="leanpub-auto-functions-with-default-parameter-values">Functions with Default Parameter Values</h3>

<p>Functions in JavaScript are unique in that they allow any number of parameters to be passed, regardless of the number of parameters declared in the function definition. This allows you to define functions that can handle different numbers of parameters, often by just filling in default values when parameters aren't provided. This section covers how default parameters work both in and prior to ECMAScript 6, along with some important information on the <code>arguments</code> object, using expressions as parameters, and another TDZ.</p>

<h4 id="leanpub-auto-simulating-default-parameter-values-in-ecmascript-5">Simulating Default Parameter Values in ECMAScript 5</h4>

<p>In ECMAScript 5 and earlier, you would likely use the following pattern to create a function with default parameters values:</p>

<figure class="code">
<pre><code>function makeRequest(url, timeout, callback) {

    timeout = timeout || 2000;
    callback = callback || function() {};

    // the rest of the function

}
</code></pre>

</figure>

<p>In this example, both <code>timeout</code> and <code>callback</code> are actually optional because they are given a default value if a parameter isn't provided. The logical OR operator (<code>||</code>) always returns the second operand when the first is falsy. Since named function parameters that are not explicitly provided are set to <code>undefined</code>, the logical OR operator is frequently used to provide default values for missing parameters. There is a flaw with this approach, however, in that a valid value for <code>timeout</code> might actually be <code>0</code>, but this would replace it with <code>2000</code> because <code>0</code> is falsy.</p>

<p>In that case, a safer alternative is to check the type of the argument using <code>typeof</code>, as in this example:</p>

<figure class="code">
<pre><code>function makeRequest(url, timeout, callback) {

    timeout = (typeof timeout !== "undefined") ? timeout : 2000;
    callback = (typeof callback !== "undefined") ? callback : function() {};

    // the rest of the function

}
</code></pre>

</figure>

<p>While this approach is safer, it still requires a lot of extra code for a very basic operation. Popular JavaScript libraries are filled with similar patterns, as this represents a common pattern.</p>

<h4 id="leanpub-auto-default-parameter-values-in-ecmascript-6">Default Parameter Values in ECMAScript 6</h4>

<p>ECMAScript 6 makes it easier to provide default values for parameters by providing initializations that are used when the parameter isn't formally passed. For example:</p>

<figure class="code">
<pre><code>function makeRequest(url, timeout = 2000, callback = function() {}) {

    // the rest of the function

}
</code></pre>

</figure>

<p>This function only expects the first parameter to always be passed. The other two parameters have default values, which makes the body of the function much smaller because you don't need to add any code to check for a missing value.</p>

<p>When <code>makeRequest()</code> is called with all three parameters, the defaults are not used. For example:</p>

<figure class="code">
<pre><code>// uses default timeout and callback
makeRequest("/foo");

// uses default callback
makeRequest("/foo", 500);

// doesn't use defaults
makeRequest("/foo", 500, function(body) {
    doSomething(body);
});
</code></pre>

</figure>

<p>ECMAScript 6 considers <code>url</code> to be required, which is why <code>"/foo"</code> is passed in all three calls to <code>makeRequest()</code>. The two parameters with a default value are considered optional.</p>

<p>It's possible to specify default values for any arguments, including those that appear before arguments without default values in the function declaration. For example, this is fine:</p>

<figure class="code">
<pre><code>function makeRequest(url, timeout = 2000, callback) {

    // the rest of the function

}
</code></pre>

</figure>

<p>In this case, the default value for <code>timeout</code> will only be used if there is no second argument passed in or if the second argument is explicitly passed in as <code>undefined</code>, as in this example:</p>

<figure class="code">
<pre><code>// uses default timeout
makeRequest("/foo", undefined, function(body) {
    doSomething(body);
});

// uses default timeout
makeRequest("/foo");

// doesn't use default timeout
makeRequest("/foo", null, function(body) {
    doSomething(body);
});
</code></pre>

</figure>

<p>In the case of default parameter values, a value of <code>null</code> is considered to be valid, meaning that in the third call to <code>makeRequest()</code>, the default value for <code>timeout</code> will not be used.</p>

<h4 id="leanpub-auto-how-default-parameter-values-affect-the-arguments-object">How Default Parameter Values Affect the arguments Object</h4>

<p>Just keep in mind that the behavior of the <code>arguments</code> object is different when default parameter values are present. In ECMAScript 5 nonstrict mode, the <code>arguments</code> object reflects changes in the named parameters of a function. Here's some code that illustrates how this works:</p>

<figure class="code">
<pre><code>function mixArgs(first, second) {
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d";
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
</code></pre>

</figure>

<p>This outputs:</p>

<figure class="code">
<pre><code>true
true
true
true
</code></pre>

</figure>

<p>The <code>arguments</code> object is always updated in nonstrict mode to reflect changes in the named parameters. Thus, when <code>first</code> and <code>second</code> are assigned new values, <code>arguments[0]</code> and <code>arguments[1]</code> are updated accordingly, making all of the <code>===</code> comparisons resolve to <code>true</code>.</p>

<p>ECMAScript 5's strict mode, however, eliminates this confusing aspect of the <code>arguments</code> object. In strict mode, the <code>arguments</code> object does not reflect changes to the named parameters. Here's the <code>mixArgs()</code> function again, but in strict mode:</p>

<figure class="code">
<pre><code>function mixArgs(first, second) {
    "use strict";

    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a", "b");
</code></pre>

</figure>

<p>The call to <code>mixArgs()</code> outputs:</p>

<figure class="code">
<pre><code>true
true
false
false
</code></pre>

</figure>

<p>This time, changing <code>first</code> and <code>second</code> doesn't affect <code>arguments</code>, so the output behaves as you'd normally expect it to.</p>

<p>The <code>arguments</code> object in a function using ECMAScript 6 default parameter values, however, will always behave in the same manner as ECMAScript 5 strict mode, regardless of whether the function is explicitly running in strict mode. The presence of default parameter values triggers the <code>arguments</code> object to remain detached from the named parameters. This is a subtle but important detail because of how the <code>arguments</code> object may be used. Consider the following:</p>

<figure class="code">
<pre><code>// not in strict mode
function mixArgs(first, second = "b") {
    console.log(arguments.length);
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
    first = "c";
    second = "d"
    console.log(first === arguments[0]);
    console.log(second === arguments[1]);
}

mixArgs("a");
</code></pre>

</figure>

<p>This outputs:</p>

<figure class="code">
<pre><code>1
true
false
false
false
</code></pre>

</figure>

<p>In this example, <code>arguments.length</code> is 1 because only one argument was passed to <code>mixArgs()</code>. That also means <code>arguments[1]</code> is <code>undefined</code>, which is the expected behavior when only one argument is passed to a function. That means <code>first</code> is equal to <code>arguments[0]</code> as well. Changing <code>first</code> and <code>second</code> has no effect on <code>arguments</code>. This behavior occurs in both nonstrict and strict mode, so you can rely on <code>arguments</code> to always reflect the initial call state.</p>

<h4 id="leanpub-auto-default-parameter-expressions">Default Parameter Expressions</h4>

<p>Perhaps the most interesting feature of default parameter values is that the default value need not be a primitive value. You can, for example, execute a function to retrieve the default parameter value, like this:</p>

<figure class="code">
<pre><code>function getValue() {
    return 5;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
</code></pre>

</figure>

<p>Here, if the last argument isn't provided, the function <code>getValue()</code> is called to retrieve the correct default value. Keep in mind that <code>getValue()</code> is only called when <code>add()</code> is called without a second parameter, not when the function declaration is first parsed. That means if <code>getValue()</code> were written differently, it could potentially return a different value. For instance:</p>

<figure class="code">
<pre><code>let value = 5;

function getValue() {
    return value++;
}

function add(first, second = getValue()) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 6
console.log(add(1));        // 7
</code></pre>

</figure>

<p>In this example, <code>value</code> begins as five and increments each time <code>getValue()</code> is called. The first call to <code>add(1)</code> returns 6, while the second call to <code>add(1)</code> returns 7 because <code>value</code> was incremented. Because the default value for <code>second</code> is only evaluated when the function is called, changes to that value can be made at any time.</p>

<aside class="warning blurb">
    <p>Be careful when using function calls as default parameter values. If you forget the parentheses, such as <code>second = getValue</code> in the last example, you are passing a reference to the function rather than the result of the function call.</p>

</aside>

<p>This behavior introduces another interesting capability. You can use a previous parameter as the default for a later parameter. Here's an example:</p>

<figure class="code">
<pre><code>function add(first, second = first) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
</code></pre>

</figure>

<p>In this code, the parameter <code>second</code> is given a default value of <code>first</code>, meaning that passing in just one argument leaves both arguments with the same value. So <code>add(1, 1)</code> returns 2 just as <code>add(1)</code> returns 2. Taking this a step further, you can pass <code>first</code> into a function to get the value for <code>second</code> as follows:</p>

<figure class="code">
<pre><code>function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
</code></pre>

</figure>

<p>This example sets <code>second</code> equal to the value returned by <code>getValue(first)</code>, so while <code>add(1, 1)</code> still returns 2, <code>add(1)</code> returns 7 (1 + 6).</p>

<p>The ability to reference parameters from default parameter assignments works only for previous arguments, so earlier arguments do not have access to later arguments. For example:</p>

<figure class="code">
<pre><code>function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // throws error
</code></pre>

</figure>

<p>The call to <code>add(undefined, 1)</code> throws an error because <code>second</code> is defined after <code>first</code> and is therefore unavailable as a default value. To understand why that happens, it's important to revisit temporal dead zones.</p>

<h4 id="leanpub-auto-default-parameter-value-temporal-dead-zone">Default Parameter Value Temporal Dead Zone</h4>

<p>Chapter 1 introduced the temporal dead zone (TDZ) as it relates to <code>let</code> and <code>const</code>, and default parameter values also have a TDZ where parameters cannot be accessed. Similar to a <code>let</code> declaration, each parameter creates a new identifier binding that can't be referenced before initialization without throwing an error. Parameter initialization happens when the function is called, either by passing a value for the parameter or by using the default parameter value.</p>

<p>To explore the default parameter value TDZ, consider this example from "Default Parameter Expressions" again:</p>

<figure class="code">
<pre><code>function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
</code></pre>

</figure>

<p>The calls to <code>add(1, 1)</code> and <code>add(1)</code> effectively execute the following code to create the <code>first</code> and <code>second</code> parameter values:</p>

<figure class="code">
<pre><code>// JavaScript representation of call to add(1, 1)
let first = 1;
let second = 1;

// JavaScript representation of call to add(1)
let first = 1;
let second = getValue(first);
</code></pre>

</figure>

<p>When the function <code>add()</code> is first executed, the bindings <code>first</code> and <code>second</code> are added to a parameter-specific TDZ (similar to how <code>let</code> behaves). So while <code>second</code> can be initialized with the value of <code>first</code> because <code>first</code> is always initialized at that time, the reverse is not true. Now, consider this rewritten <code>add()</code> function:</p>

<figure class="code">
<pre><code>function add(first = second, second) {
    return first + second;
}

console.log(add(1, 1));         // 2
console.log(add(undefined, 1)); // throws error
</code></pre>

</figure>

<p>The calls to <code>add(1, 1)</code> and <code>add(undefined, 1)</code> in this example now map to this code behind the scenes:</p>

<figure class="code">
<pre><code>// JavaScript representation of call to add(1, 1)
let first = 1;
let second = 1;

// JavaScript representation of call to add(undefined, 1)
let first = second;
let second = 1;
</code></pre>

</figure>

<p>In this example, the call to <code>add(undefined, 1)</code> throws an error because <code>second</code> hasn't yet been initialized when <code>first</code> is initialized. At that point, <code>second</code> is in the TDZ and therefore any references to <code>second</code> throw an error. This mirrors the behavior of <code>let</code> bindings discussed in Chapter 1.</p>

<aside class="information blurb">
    <p>Function parameters have their own scope and their own TDZ that is separate from the function body scope. That means the default value of a parameter cannot access any variables declared inside the function body.</p>

</aside>

<h3 id="leanpub-auto-working-with-unnamed-parameters">Working with Unnamed Parameters</h3>

<p>So far, the examples in this chapter have only covered parameters that have been named in the function definition. However, JavaScript functions don't limit the number of parameters that can be passed to the number of named parameters defined. You can always pass fewer or more parameters than formally specified. Default parameter values make it clear when a function can accept fewer parameters, and ECMAScript 6 sought to make the problem of passing more parameters than defined better as well.</p>

<h4 id="leanpub-auto-unnamed-parameters-in-ecmascript-5">Unnamed Parameters in ECMAScript 5</h4>

<p>Early on, JavaScript provided the <code>arguments</code> object as a way to inspect all function parameters that are passed without necessarily defining each parameter individually. While inspecting <code>arguments</code> works fine in most cases, this object can be a little cumbersome to work with. For example, examine this code, which inspects the <code>arguments</code> object:</p>

<figure class="code">
<pre><code>function pick(object) {
    let result = Object.create(null);

    // start at the second parameter
    for (let i = 1, len = arguments.length; i &lt; len; i++) {
        result[arguments[i]] = object[arguments[i]];
    }

    return result;
}

let book = {
    title: "Understanding ECMAScript 6",
    author: "Nicholas C. Zakas",
    year: 2015
};

let bookData = pick(book, "author", "year");

console.log(bookData.author);   // "Nicholas C. Zakas"
console.log(bookData.year);     // 2015
</code></pre>

</figure>

<p>This function mimics the <code>pick()</code> method from the <em>Underscore.js</em> library, which returns a copy of a given object with some specified subset of the original object's properties. This example defines only one argument and expects the first argument to be the object from which to copy properties. Every other argument passed is the name of a property that should be copied on the result.</p>

<p>There are a couple of things to notice about this <code>pick()</code> function. First, it's not at all obvious that the function can handle more than one parameter. You could define several more parameters, but you would always fall short of indicating that this function can take any number of parameters. Second, because the first parameter is named and used directly, when you look for the properties to copy, you have to start in the <code>arguments</code> object at index 1 instead of index 0. Remembering to use the appropriate indices with <code>arguments</code> isn't necessarily difficult, but it's one more thing to keep track of.</p>

<p>ECMAScript 6 introduces rest parameters to help with these issues.</p>

<h4 id="leanpub-auto-rest-parameters">Rest Parameters</h4>

<p>A <em>rest parameter</em> is indicated by three dots (<code>...</code>) preceding a named parameter. That named parameter becomes an <code>Array</code> containing the rest of the parameters passed to the function, which is where the name "rest" parameters originates. For example, <code>pick()</code> can be rewritten using rest parameters, like this:</p>

<figure class="code">
<pre><code>function pick(object, ...keys) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i &lt; len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
</code></pre>

</figure>

<p>In this version of the function, <code>keys</code> is a rest parameter that contains all parameters passed after <code>object</code> (unlike <code>arguments</code>, which contains all parameters including the first one). That means you can iterate over <code>keys</code> from beginning to end without worry. As a bonus, you can tell by looking at the function that it is capable of handling any number of parameters.</p>

<aside class="information blurb">
    <p>Rest parameters do not affect a function's <code>length</code> property, which indicates the number of named parameters for the function. The value of <code>length</code> for <code>pick()</code> in this example is 1 because only <code>object</code> counts towards this value.</p>

</aside>

<h5 id="leanpub-auto-rest-parameter-restrictions">Rest Parameter Restrictions</h5>

<p>There are two restrictions on rest parameters. The first restriction is that there can be only one rest parameter, and the rest parameter must be last. For example, this code won't work:</p>

<figure class="code">
<pre><code>// Syntax error: Can't have a named parameter after rest parameters
function pick(object, ...keys, last) {
    let result = Object.create(null);

    for (let i = 0, len = keys.length; i &lt; len; i++) {
        result[keys[i]] = object[keys[i]];
    }

    return result;
}
</code></pre>

</figure>

<p>Here, the parameter <code>last</code> follows the rest parameter <code>keys</code>, which would cause a syntax error.</p>

<p>The second restriction is that rest parameters cannot be used in an object literal setter. That means this code would also cause a syntax error:</p>

<figure class="code">
<pre><code>let object = {

    // Syntax error: Can't use rest param in setter
    set name(...value) {
        // do something
    }
};
</code></pre>

</figure>

<p>This restriction exists because object literal setters are restricted to a single argument. Rest parameters are, by definition, an infinite number of arguments, so they're not allowed in this context.</p>

<h5 id="leanpub-auto-how-rest-parameters-affect-the-arguments-object">How Rest Parameters Affect the arguments Object</h5>

<p>Rest parameters were designed to replace <code>arguments</code> in ECMAScript. Originally, ECMAScript 4 did away with <code>arguments</code> and added rest parameters to allow an unlimited number of arguments to be passed to functions. ECMAScript 4 never came into being, but this idea was kept around and reintroduced in ECMAScript 6, despite <code>arguments</code> not being removed from the language.</p>

<p>The <code>arguments</code> object works together with rest parameters by reflecting the arguments that were passed to the function when called, as illustrated in this program:</p>

<figure class="code">
<pre><code>function checkArgs(...args) {
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0], arguments[0]);
    console.log(args[1], arguments[1]);
}

checkArgs("a", "b");
</code></pre>

</figure>

<p>The call to <code>checkArgs()</code> outputs:</p>

<figure class="code">
<pre><code>2
2
a a
b b
</code></pre>

</figure>

<p>The <code>arguments</code> object always correctly reflects the parameters that were passed into a function regardless of rest parameter usage.</p>

<p>That's all you really need to know about rest parameters to get started using them.</p>

<h3 id="leanpub-auto-increased-capabilities-of-the-function-constructor">Increased Capabilities of the Function Constructor</h3>

<p>The <code>Function</code> constructor is an infrequently used part of JavaScript that allows you to dynamically create a new function. The arguments to the constructor are the parameters for the function and the function body, all as strings. Here's an example:</p>

<figure class="code">
<pre><code>var add = new Function("first", "second", "return first + second");

console.log(add(1, 1));     // 2
</code></pre>

</figure>

<p>ECMAScript 6 augments the capabilities of the <code>Function</code> constructor to allow default parameters and rest parameters. You need only add an equals sign and a value to the parameter names, as follows:</p>

<figure class="code">
<pre><code>var add = new Function("first", "second = first",
        "return first + second");

console.log(add(1, 1));     // 2
console.log(add(1));        // 2
</code></pre>

</figure>

<p>In this example, the parameter <code>second</code> is assigned the value of <code>first</code> when only one parameter is passed. The syntax is the same as for function declarations that don't use <code>Function</code>.</p>

<p>For rest parameters, just add the <code>...</code> before the last parameter, like this:</p>

<figure class="code">
<pre><code>var pickFirst = new Function("...args", "return args[0]");

console.log(pickFirst(1, 2));   // 1
</code></pre>

</figure>

<p>This code creates a function that uses only a single rest parameter and returns the first argument that was passed in.</p>

<p>The addition of default and rest parameters ensures that <code>Function</code> has all of the same capabilities as the declarative form of creating functions.</p>

<h3 id="leanpub-auto-the-spread-operator">The Spread Operator</h3>

<p>Closely related to rest parameters is the spread operator. While rest parameters allow you to specify that multiple independent arguments should be combined into an array, the spread operator allows you to specify an array that should be split and have its items passed in as separate arguments to a function. Consider the <code>Math.max()</code> method, which accepts any number of arguments and returns the one with the highest value. Here's a simple use case for this method:</p>

<figure class="code">
<pre><code>let value1 = 25,
    value2 = 50;

console.log(Math.max(value1, value2));      // 50
</code></pre>

</figure>

<p>When you're dealing with just two values, as in this example, <code>Math.max()</code> is very easy to use. The two values are passed in, and the higher value is returned. But what if you've been tracking values in an array, and now you want to find the highest value? The <code>Math.max()</code> method doesn't allow you to pass in an array, so in ECMAScript 5 and earlier, you'd be stuck either searching the array yourself or using <code>apply()</code> as follows:</p>

<figure class="code">
<pre><code>let values = [25, 50, 75, 100]

console.log(Math.max.apply(Math, values));  // 100
</code></pre>

</figure>

<p>This solution works, but using <code>apply()</code> in this manner is a bit confusing. It actually seems to obfuscate the true meaning of the code with additional syntax.</p>

<p>The ECMAScript 6 spread operator makes this case very simple. Instead of calling <code>apply()</code>, you can pass the array to <code>Math.max()</code> directly and prefix it with the same <code>...</code> pattern used with rest parameters. The JavaScript engine then splits the array into individual arguments and passes them in, like this:</p>

<figure class="code">
<pre><code>let values = [25, 50, 75, 100]

// equivalent to
// console.log(Math.max(25, 50, 75, 100));
console.log(Math.max(...values));           // 100
</code></pre>

</figure>

<p>Now the call to <code>Math.max()</code> looks a bit more conventional and avoids the complexity of specifying a <code>this</code>-binding (the first argument to <code>Math.max.apply()</code> in the previous example) for a simple mathematical operation.</p>

<p>You can mix and match the spread operator with other arguments as well. Suppose you want the smallest number returned from <code>Math.max()</code> to be 0 (just in case negative numbers sneak into the array). You can pass that argument separately and still use the spread operator for the other arguments, as follows:</p>

<figure class="code">
<pre><code>let values = [-25, -50, -75, -100]

console.log(Math.max(...values, 0));        // 0
</code></pre>

</figure>

<p>In this example, the last argument passed to <code>Math.max()</code> is <code>0</code>, which comes after the other arguments are passed in using the spread operator.</p>

<p>The spread operator for argument passing makes using arrays for function arguments much easier. You'll likely find it to be a suitable replacement for the <code>apply()</code> method in most circumstances.</p>

<p>In addition to the uses you've seen for default and rest parameters so far, in ECMAScript 6, you can also apply both parameter types to JavaScript's <code>Function</code> constructor.</p>

<h3 id="leanpub-auto-ecmascript-6s-name-property">ECMAScript 6's name Property</h3>

<p>Identifying functions can be challenging in JavaScript given the various ways a function can be defined. Additionally, the prevalence of anonymous function expressions makes debugging a bit more difficult, often resulting in stack traces that are hard to read and decipher. For these reasons, ECMAScript 6 adds the <code>name</code> property to all functions.</p>

<h4 id="leanpub-auto-choosing-appropriate-names">Choosing Appropriate Names</h4>

<p>All functions in an ECMAScript 6 program will have an appropriate value for their <code>name</code> property. To see this in action, look at the following example, which shows a function and function expression, and prints the <code>name</code> properties for both:</p>

<figure class="code">
<pre><code>function doSomething() {
    // ...
}

var doAnotherThing = function() {
    // ...
};

console.log(doSomething.name);          // "doSomething"
console.log(doAnotherThing.name);       // "doAnotherThing"
</code></pre>

</figure>

<p>In this code, <code>doSomething()</code> has a <code>name</code> property equal to <code>"doSomething"</code> because it's a function declaration. The anonymous function expression <code>doAnotherThing()</code> has a <code>name</code> of <code>"doAnotherThing"</code> because that's the name of the variable to which it is assigned.</p>

<h4 id="leanpub-auto-special-cases-of-the-name-property">Special Cases of the name Property</h4>

<p>While appropriate names for function declarations and function expressions are easy to find, ECMAScript 6 goes further to ensure that <em>all</em> functions have appropriate names. To illustrate this, consider the following program:</p>

<figure class="code">
<pre><code>var doSomething = function doSomethingElse() {
    // ...
};

var person = {
    get firstName() {
        return "Nicholas"
    },
    sayName: function() {
        console.log(this.name);
    }
}

console.log(doSomething.name);      // "doSomethingElse"
console.log(person.sayName.name);   // "sayName"

var descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
console.log(descriptor.get.name); // "get firstName"
</code></pre>

</figure>

<p>In this example, <code>doSomething.name</code> is <code>"doSomethingElse"</code> because the function expression itself has a name, and that name takes priority over the variable to which the function was assigned. The <code>name</code> property of <code>person.sayName()</code> is <code>"sayName"</code>, as the value was interpreted from the object literal. Similarly, <code>person.firstName</code> is actually a getter function, so its name is <code>"get firstName"</code> to indicate this difference. Setter functions are prefixed with <code>"set"</code> as well. (Both getter and setter functions must be retrieved using <code>Object.getOwnPropertyDescriptor()</code>.)</p>

<p>There are a couple of other special cases for function names, too. Functions created using <code>bind()</code> will have their names prefixed with <code>"bound"</code> and functions created using the <code>Function</code> constructor have a name of <code>"anonymous"</code>, as in this example:</p>

<figure class="code">
<pre><code>var doSomething = function() {
    // ...
};

console.log(doSomething.bind().name);   // "bound doSomething"

console.log((new Function()).name);     // "anonymous"
</code></pre>

</figure>

<p>The <code>name</code> of a bound function will always be the <code>name</code> of the function being bound prefixed with the string <code>"bound "</code>, so the bound version of <code>doSomething()</code> is <code>"bound doSomething"</code>.</p>

<p>Keep in mind that the value of <code>name</code> for any function does not necessarily refer to a variable of the same name. The <code>name</code> property is meant to be informative, to help with debugging, so there's no way to use the value of <code>name</code> to get a reference to the function.</p>

<h3 id="leanpub-auto-clarifying-the-dual-purpose-of-functions">Clarifying the Dual Purpose of Functions</h3>

<p>In ECMAScript 5 and earlier, functions serve the dual purpose of being callable with or without <code>new</code>. When used with <code>new</code>, the <code>this</code> value inside a function is a new object and that new object is returned, as illustrated in this example:</p>

<figure class="code">
<pre><code>function Person(name) {
    this.name = name;
}

var person = new Person("Nicholas");
var notAPerson = Person("Nicholas");

console.log(person);        // "[Object object]"
console.log(notAPerson);    // "undefined"
</code></pre>

</figure>

<p>When creating <code>notAPerson</code>, calling <code>Person()</code> without <code>new</code> results in <code>undefined</code> (and sets a <code>name</code> property on the global object in nonstrict mode). The capitalization of <code>Person</code> is the only real indicator that the function is meant to be called using <code>new</code>, as is common in JavaScript programs. This confusion over the dual roles of functions led to some changes in ECMAScript 6.</p>

<p>JavaScript has two different internal-only methods for functions: <code>[[Call]]</code> and <code>[[Construct]]</code>. When a function is called without <code>new</code>, the <code>[[Call]]</code> method is executed, which executes the body of the function as it appears in the code. When a function is called with <code>new</code>, that's when the <code>[[Construct]]</code> method is called. The <code>[[Construct]]</code> method is responsible for creating a new object, called the <em>new target</em>, and then executing the function body with <code>this</code> set to the new target. Functions that have a <code>[[Construct]]</code> method are called <em>constructors</em>.</p>

<aside class="information blurb">
    <p>Keep in mind that not all functions have <code>[[Construct]]</code>, and therefore not all functions can be called with <code>new</code>. Arrow functions, discussed in the "Arrow Functions" section, do not have a <code>[[Construct]]</code> method.</p>

</aside>

<h4 id="leanpub-auto-determining-how-a-function-was-called-in-ecmascript-5">Determining How a Function was Called in ECMAScript 5</h4>

<p>The most popular way to determine if a function was called with <code>new</code> (and hence, with constructor) in ECMAScript 5 is to use <code>instanceof</code>, for example:</p>

<figure class="code">
<pre><code>function Person(name) {
    if (this instanceof Person) {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person("Nicholas");  // throws error
</code></pre>

</figure>

<p>Here, the <code>this</code> value is checked to see if it's an instance of the constructor, and if so, execution continues as normal. If <code>this</code> isn't an instance of <code>Person</code>, then an error is thrown. This works because the <code>[[Construct]]</code> method creates a new instance of <code>Person</code> and assigns it to <code>this</code>. Unfortunately, this approach is not completely reliable because <code>this</code> can be an instance of <code>Person</code> without using <code>new</code>, as in this example:</p>

<figure class="code">
<pre><code>function Person(name) {
    if (this instanceof Person) {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael");    // works!
</code></pre>

</figure>

<p>The call to <code>Person.call()</code> passes the <code>person</code> variable as the first argument, which means <code>this</code> is set to <code>person</code> inside of the <code>Person</code> function. To the function, there's no way to distinguish this from being called with <code>new</code>.</p>

<h4 id="leanpub-auto-the-newtarget-metaproperty">The new.target MetaProperty</h4>

<p>To solve this problem, ECMAScript 6 introduces the <code>new.target</code> <em>metaproperty</em>. A metaproperty is a property of a non-object that provides additional information related to its target (such as <code>new</code>). When a function's <code>[[Construct]]</code> method is called, <code>new.target</code> is filled with the target of the <code>new</code> operator. That target is typically the constructor of the newly created object instance that will become <code>this</code> inside the function body. If <code>[[Call]]</code> is executed, then <code>new.target</code> is <code>undefined</code>.</p>

<p>This new metaproperty allows you to safely detect if a function is called with <code>new</code> by checking whether <code>new.target</code> is defined as follows:</p>

<figure class="code">
<pre><code>function Person(name) {
    if (typeof new.target !== "undefined") {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

var person = new Person("Nicholas");
var notAPerson = Person.call(person, "Michael");    // error!
</code></pre>

</figure>

<p>By using <code>new.target</code> instead of <code>this instanceof Person</code>, the <code>Person</code> constructor is now correctly throwing an error when used without <code>new</code>.</p>

<p>You can also check that <code>new.target</code> was called with a specific constructor. For instance, look at this example:</p>

<figure class="code">
<pre><code>function Person(name) {
    if (new.target === Person) {
        this.name = name;   // using new
    } else {
        throw new Error("You must use new with Person.")
    }
}

function AnotherPerson(name) {
    Person.call(this, name);
}

var person = new Person("Nicholas");
var anotherPerson = new AnotherPerson("Nicholas");  // error!
</code></pre>

</figure>

<p>In this code, <code>new.target</code> must be <code>Person</code> in order to work correctly. When <code>new AnotherPerson("Nicholas")</code> is called, the subsequent call to <code>Person.call(this, name)</code> will throw an error because <code>new.target</code> is <code>undefined</code> inside of the <code>Person</code> constructor (it was called without <code>new</code>).</p>

<aside class="warning blurb">
    <p>Warning: Using <code>new.target</code> outside of a function is a syntax error.</p>

</aside>

<p>By adding <code>new.target</code>, ECMAScript 6 helped to clarify some ambiguity around functions calls. Following on this theme, ECMAScript 6 also addresses another previously ambiguous part of the language: declaring functions inside of blocks.</p>

<h3 id="leanpub-auto-block-level-functions">Block-Level Functions</h3>

<p>In ECMAScript 3 and earlier, a function declaration occurring inside of a block (a <em>block-level function</em>) was technically a syntax error, but all browsers still supported it. Unfortunately, each browser that allowed the syntax behaved in a slightly different way, so it is considered a best practice to avoid function declarations inside of blocks (the best alternative is to use a function expression).</p>

<p>In an attempt to rein in this incompatible behavior, ECMAScript 5 strict mode introduced an error whenever a function declaration was used inside of a block in this way:</p>

<figure class="code">
<pre><code>"use strict";

if (true) {

    // Throws a syntax error in ES5, not so in ES6
    function doSomething() {
        // ...
    }
}
</code></pre>

</figure>

<p>In ECMAScript 5, this code throws a syntax error. In ECMAScript 6, the <code>doSomething()</code> function is considered a block-level declaration and can be accessed and called within the same block in which it was defined. For example:</p>

<figure class="code">
<pre><code>"use strict";

if (true) {

    console.log(typeof doSomething);        // "function"

    function doSomething() {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);            // "undefined"
</code></pre>

</figure>

<p>Block level functions are hoisted to the top of the block in which they are defined, so <code>typeof doSomething</code> returns <code>"function"</code> even though it appears before the function declaration in the code. Once the <code>if</code> block is finished executing, <code>doSomething()</code> no longer exists.</p>

<h4 id="leanpub-auto-deciding-when-to-use-block-level-functions">Deciding When to Use Block-Level Functions</h4>

<p>Block level functions are similar to <code>let</code> function expressions in that the function definition is removed once execution flows out of the block in which it's defined. The key difference is that block level functions are hoisted to the top of the containing block. Function expressions that use <code>let</code> are not hoisted, as this example illustrates:</p>

<figure class="code">
<pre><code>"use strict";

if (true) {

    console.log(typeof doSomething);        // throws error

    let doSomething = function () {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);
</code></pre>

</figure>

<p>Here, code execution stops when <code>typeof doSomething</code> is executed, because the <code>let</code> statement hasn't been executed yet, leaving <code>doSomething()</code> in the TDZ. Knowing this difference, you can choose whether to use block level functions or <code>let</code> expressions based on whether or not you want the hoisting behavior.</p>

<h4 id="leanpub-auto-block-level-functions-in-nonstrict-mode">Block-Level Functions in Nonstrict Mode</h4>

<p>ECMAScript 6 also allows block-level functions in nonstrict mode, but the behavior is slightly different. Instead of hoisting these declarations to the top of the block, they are hoisted all the way to the containing function or global environment. For example:</p>

<figure class="code">
<pre><code>// ECMAScript 6 behavior
if (true) {

    console.log(typeof doSomething);        // "function"

    function doSomething() {
        // ...
    }

    doSomething();
}

console.log(typeof doSomething);            // "function"
</code></pre>

</figure>

<p>In this example, <code>doSomething()</code> is hoisted into the global scope so that it still exists outside of the <code>if</code> block. ECMAScript 6 standardized this behavior to remove the incompatible browser behaviors that previously existed, so all ECMAScript 6 runtimes should behave in the same way.</p>

<p>Allowing block-level functions improves your ability to declare functions in JavaScript, but ECMAScript 6 also introduced a completely new way to declare functions.</p>

<h3 id="leanpub-auto-arrow-functions">Arrow Functions</h3>

<p>One of the most interesting new parts of ECMAScript 6 is the <em>arrow function</em>. Arrow functions are, as the name suggests, functions defined with a new syntax that uses an "arrow" (<code>=&gt;</code>). But arrow functions behave differently than traditional JavaScript functions in a number of important ways:</p>

<ul>
  <li>
<strong>No <code>this</code>, <code>super</code>, <code>arguments</code>, and <code>new.target</code> bindings</strong> - The value of <code>this</code>, <code>super</code>, <code>arguments</code>, and <code>new.target</code> inside of the function is by the closest containing nonarrow function. (<code>super</code> is covered in Chapter 4.)</li>
  <li>
<strong>Cannot be called with <code>new</code></strong> - Arrow functions do not have a <code>[[Construct]]</code> method and therefore cannot be used as constructors. Arrow functions throw an error when used with <code>new</code>.</li>
  <li>
<strong>No prototype</strong> - since you can't use <code>new</code> on an arrow function, there's no need for a prototype. The <code>prototype</code> property of an arrow function doesn't exist.</li>
  <li>
<strong>Can't change <code>this</code></strong> - The value of <code>this</code> inside of the function can't be changed. It remains the same throughout the entire lifecycle of the function.</li>
  <li>
<strong>No <code>arguments</code> object</strong> - Since arrow functions have no <code>arguments</code> binding, you must rely on named and rest parameters to access function arguments.</li>
  <li>
<strong>No duplicate named parameters</strong> - arrow functions cannot have duplicate named parameters in strict or nonstrict mode, as opposed to nonarrow functions that cannot have duplicate named parameters only in strict mode.</li>
</ul>

<p>There are a few reasons for these differences. First and foremost, <code>this</code> binding is a common source of error in JavaScript. It's very easy to lose track of the <code>this</code> value inside a function, which can result in unintended program behavior, and arrow functions eliminate this confusion. Second, by limiting arrow functions to simply executing code with a single <code>this</code> value, JavaScript engines can more easily optimize these operations, unlike regular functions, which might be used as a constructor or otherwise modified.</p>

<p>The rest of the differences are also focused on reducing errors and ambiguities inside of arrow functions. By doing so, JavaScript engines are better able to optimize arrow function execution.</p>

<aside class="information blurb">
    <p>Note: Arrow functions also have a <code>name</code> property that follows the same rule as other functions.</p>

</aside>

<h4 id="leanpub-auto-arrow-function-syntax">Arrow Function Syntax</h4>

<p>The syntax for arrow functions comes in many flavors depending upon what you're trying to accomplish. All variations begin with function arguments, followed by the arrow, followed by the body of the function. Both the arguments and the body can take different forms depending on usage. For example, the following arrow function takes a single argument and simply returns it:</p>

<figure class="code">
<pre><code>var reflect = value =&gt; value;

// effectively equivalent to:

var reflect = function(value) {
    return value;
};
</code></pre>

</figure>

<p>When there is only one argument for an arrow function, that one argument can be used directly without any further syntax. The arrow comes next and the expression to the right of the arrow is evaluated and returned. Even though there is no explicit <code>return</code> statement, this arrow function will return the first argument that is passed in.</p>

<p>If you are passing in more than one argument, then you must include parentheses around those arguments, like this:</p>

<figure class="code">
<pre><code>var sum = (num1, num2) =&gt; num1 + num2;

// effectively equivalent to:

var sum = function(num1, num2) {
    return num1 + num2;
};
</code></pre>

</figure>

<p>The <code>sum()</code> function simply adds two arguments together and returns the result. The only difference between this arrow function and the <code>reflect()</code> function is that the arguments are enclosed in parentheses with a comma separating them (like traditional functions).</p>

<p>If there are no arguments to the function, then you must include an empty set of parentheses in the declaration, as follows:</p>

<figure class="code">
<pre><code>var getName = () =&gt; "Nicholas";

// effectively equivalent to:

var getName = function() {
    return "Nicholas";
};
</code></pre>

</figure>

<p>When you want to provide a more traditional function body, perhaps consisting of more than one expression, then you need to wrap the function body in braces and explicitly define a return value, as in this version of <code>sum()</code>:</p>

<figure class="code">
<pre><code>var sum = (num1, num2) =&gt; {
    return num1 + num2;
};

// effectively equivalent to:

var sum = function(num1, num2) {
    return num1 + num2;
};
</code></pre>

</figure>

<p>You can more or less treat the inside of the curly braces the same as you would in a traditional function, with the exception that <code>arguments</code> is not available.</p>

<p>If you want to create a function that does nothing, then you need to include curly braces, like this:</p>

<figure class="code">
<pre><code>var doNothing = () =&gt; {};

// effectively equivalent to:

var doNothing = function() {};
</code></pre>

</figure>

<p>Curly braces are used to denote the function's body, which works just fine in the cases you've seen so far. But an arrow function that wants to return an object literal outside of a function body must wrap the literal in parentheses. For example:</p>

<figure class="code">
<pre><code>var getTempItem = id =&gt; ({ id: id, name: "Temp" });

// effectively equivalent to:

var getTempItem = function(id) {

    return {
        id: id,
        name: "Temp"
    };
};
</code></pre>

</figure>

<p>Wrapping the object literal in parentheses signals that the braces are an object literal instead of the function body.</p>

<h4 id="leanpub-auto-creating-immediately-invoked-function-expressions">Creating Immediately-Invoked Function Expressions</h4>

<p>One popular use of functions in JavaScript is creating immediately-invoked function expressions (IIFEs). IIFEs allow you to define an anonymous function and call it immediately without saving a reference. This pattern comes in handy when you want to create a scope that is shielded from the rest of a program. For example:</p>

<figure class="code">
<pre><code>let person = function(name) {

    return {
        getName: function() {
            return name;
        }
    };

}("Nicholas");

console.log(person.getName());      // "Nicholas"
</code></pre>

</figure>

<p>In this code, the IIFE is used to create an object with a <code>getName()</code> method. The method uses the <code>name</code> argument as the return value, effectively making <code>name</code> a private member of the returned object.</p>

<p>You can accomplish the same thing using arrow functions, so long as you wrap the arrow function in parentheses:</p>

<figure class="code">
<pre><code>let person = ((name) =&gt; {

    return {
        getName: function() {
            return name;
        }
    };

})("Nicholas");

console.log(person.getName());      // "Nicholas"
</code></pre>

</figure>

<p>Note that the parentheses are only around the arrow function definition, and not around <code>("Nicholas")</code>. This is different from a formal function, where the parentheses can be placed outside of the passed-in parameters as well as just around the function definition.</p>

<h4 id="leanpub-auto-no-this-binding">No this Binding</h4>

<p>One of the most common areas of error in JavaScript is the binding of <code>this</code> inside of functions. Since the value of <code>this</code> can change inside a single function depending on the context in which the function is called, it's possible to mistakenly affect one object when you meant to affect another. Consider the following example:</p>

<figure class="code">
<pre><code>var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", function(event) {
            this.doSomething(event.type);     // error
        }, false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
</code></pre>

</figure>

<p>In this code, the object <code>PageHandler</code> is designed to handle interactions on the page. The <code>init()</code> method is called to set up the interactions, and that method in turn assigns an event handler to call <code>this.doSomething()</code>. However, this code doesn't work exactly as intended.</p>

<p>The call to <code>this.doSomething()</code> is broken because <code>this</code> is a reference to the object that was the target of the event (in this case <code>document</code>), instead of being bound to <code>PageHandler</code>. If you tried to run this code, you'd get an error when the event handler fires because <code>this.doSomething()</code> doesn't exist on the target <code>document</code> object.</p>

<p>You could fix this by binding the value of <code>this</code> to <code>PageHandler</code> explicitly using the <code>bind()</code> method on the function instead, like this:</p>

<figure class="code">
<pre><code>var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click", (function(event) {
            this.doSomething(event.type);     // no error
        }).bind(this), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
</code></pre>

</figure>

<p>Now the code works as expected, but it may look a little bit strange. By calling <code>bind(this)</code>, you're actually creating a new function whose <code>this</code> is bound to the current <code>this</code>, which is <code>PageHandler</code>. To avoid creating an extra function, a better way to fix this code is to use an arrow function.</p>

<p>Arrow functions have no <code>this</code> binding, which means the value of <code>this</code> inside an arrow function can only be determined by looking up the scope chain. If the arrow function is contained within a nonarrow function, <code>this</code> will be the same as the containing function; otherwise, <code>this</code> is equivalent to the value of <code>this</code> in the global scope. Here's one way you could write this code using an arrow function:</p>

<figure class="code">
<pre><code>var PageHandler = {

    id: "123456",

    init: function() {
        document.addEventListener("click",
                event =&gt; this.doSomething(event.type), false);
    },

    doSomething: function(type) {
        console.log("Handling " + type  + " for " + this.id);
    }
};
</code></pre>

</figure>

<p>The event handler in this example is an arrow function that calls <code>this.doSomething()</code>. The value of <code>this</code> is the same as it is within <code>init()</code>, so this version of the code works similarly to the one using <code>bind(this)</code>. Even though the <code>doSomething()</code> method doesn't return a value, it's still the only statement executed in the function body, and so there is no need to include braces.</p>

<p>Arrow functions are designed to be "throwaway" functions, and so cannot be used to define new types; this is evident from the missing <code>prototype</code> property, which regular functions have. If you try to use the <code>new</code> operator with an arrow function, you'll get an error, as in this example:</p>

<figure class="code">
<pre><code>var MyType = () =&gt; {},
    object = new MyType();  // error - you can't use arrow functions with 'ne\
w'
</code></pre>

</figure>

<p>In this code, the call to <code>new MyType()</code> fails because <code>MyType</code> is an arrow function and therefore has no <code>[[Construct]]</code> behavior. Knowing that arrow functions cannot be used with <code>new</code> allows JavaScript engines to further optimize their behavior.</p>

<p>Also, since the <code>this</code> value is determined by the containing function in which the arrow function is defined, you cannot change the value of <code>this</code> using <code>call()</code>, <code>apply()</code>, or <code>bind()</code>.</p>

<h4 id="leanpub-auto-arrow-functions-and-arrays">Arrow Functions and Arrays</h4>

<p>The concise syntax for arrow functions makes them ideal for use with array processing, too. For example, if you want to sort an array using a custom comparator, you'd typically write something like this:</p>

<figure class="code">
<pre><code>var result = values.sort(function(a, b) {
    return a - b;
});
</code></pre>

</figure>

<p>That's a lot of syntax for a very simple procedure. Compare that to the more terse arrow function version:</p>

<figure class="code">
<pre><code>var result = values.sort((a, b) =&gt; a - b);
</code></pre>

</figure>

<p>The array methods that accept callback functions such as <code>sort()</code>, <code>map()</code>, and <code>reduce()</code> can all benefit from simpler arrow function syntax, which changes seemingly complex processes into simpler code.</p>

<h4 id="leanpub-auto-no-arguments-binding">No arguments Binding</h4>

<p>Even though arrow functions don't have their own <code>arguments</code> object, it's possible for them to access the <code>arguments</code> object from a containing function. That <code>arguments</code> object is then available no matter where the arrow function is executed later on. For example:</p>

<figure class="code">
<pre><code>function createArrowFunctionReturningFirstArg() {
    return () =&gt; arguments[0];
}

var arrowFunction = createArrowFunctionReturningFirstArg(5);

console.log(arrowFunction());       // 5
</code></pre>

</figure>

<p>Inside <code>createArrowFunctionReturningFirstArg()</code>, the <code>arguments[0]</code> element is referenced by the created arrow function. That reference contains the first argument passed to the <code>createArrowFunctionReturningFirstArg()</code> function. When the arrow function is later executed, it returns <code>5</code>, which was the first argument passed to <code>createArrowFunctionReturningFirstArg()</code>. Even though the arrow function is no longer in the scope of the function that created it, <code>arguments</code> remains accessible due to scope chain resolution of the <code>arguments</code> identifier.</p>

<h4 id="leanpub-auto-identifying-arrow-functions">Identifying Arrow Functions</h4>

<p>Despite the different syntax, arrow functions are still functions, and are identified as such. Consider the following code:</p>

<figure class="code">
<pre><code>var comparator = (a, b) =&gt; a - b;

console.log(typeof comparator);                 // "function"
console.log(comparator instanceof Function);    // true
</code></pre>

</figure>

<p>The <code>console.log()</code> output reveals that both <code>typeof</code> and <code>instanceof</code> behave the same with arrow functions as they do with other functions.</p>

<p>Also like other functions, you can still use <code>call()</code>, <code>apply()</code>, and <code>bind()</code> on arrow functions, although the <code>this</code>-binding of the function will not be affected. Here are some examples:</p>

<figure class="code">
<pre><code>var sum = (num1, num2) =&gt; num1 + num2;

console.log(sum.call(null, 1, 2));      // 3
console.log(sum.apply(null, [1, 2]));   // 3

var boundSum = sum.bind(null, 1, 2);

console.log(boundSum());                // 3
</code></pre>

</figure>

<p>The <code>sum()</code> function is called using <code>call()</code> and <code>apply()</code> to pass arguments, as you'd do with any function. The <code>bind()</code> method is used to create <code>boundSum()</code>, which has its two arguments bound to <code>1</code> and <code>2</code> so that they don't need to be passed directly.</p>

<p>Arrow functions are appropriate to use anywhere you're currently using an anonymous function expression, such as with callbacks. The next section covers another major ECMAScript 6 development, but this one is all internal, and has no new syntax.</p>

<h3 id="leanpub-auto-tail-call-optimization">Tail Call Optimization</h3>

<p>Perhaps the most interesting change to functions in ECMAScript 6 is an engine optimization, which changes the tail call system. A <em>tail call</em> is when a function is called as the last statement in another function, like this:</p>

<figure class="code">
<pre><code>function doSomething() {
    return doSomethingElse();   // tail call
}
</code></pre>

</figure>

<p>Tail calls as implemented in ECMAScript 5 engines are handled just like any other function call: a new stack frame is created and pushed onto the call stack to represent the function call. That means every previous stack frame is kept in memory, which is problematic when the call stack gets too large.</p>

<h4 id="leanpub-auto-whats-different">What's Different?</h4>

<p>ECMAScript 6 seeks to reduce the size of the call stack for certain tail calls in strict mode (nonstrict mode tail calls are left untouched). With this optimization, instead of creating a new stack frame for a tail call, the current stack frame is cleared and reused so long as the following conditions are met:</p>

<ol class="numeric">
  <li>The tail call does not require access to variables in the current stack frame (meaning the function is not a closure)</li>
  <li>The function making the tail call has no further work to do after the tail call returns</li>
  <li>The result of the tail call is returned as the function value</li>
</ol>

<p>As an example, this code can easily be optimized because it fits all three criteria:</p>

<figure class="code">
<pre><code>"use strict";

function doSomething() {
    // optimized
    return doSomethingElse();
}
</code></pre>

</figure>

<p>This function makes a tail call to <code>doSomethingElse()</code>, returns the result immediately, and doesn't access any variables in the local scope. One small change, not returning the result, results in an unoptimized function:</p>

<figure class="code">
<pre><code>"use strict";

function doSomething() {
    // not optimized - no return
    doSomethingElse();
}
</code></pre>

</figure>

<p>Similarly, if you have a function that performs an operation after returning from the tail call, then the function can't be optimized:</p>

<figure class="code">
<pre><code>"use strict";

function doSomething() {
    // not optimized - must add after returning
    return 1 + doSomethingElse();
}
</code></pre>

</figure>

<p>This example adds the result of <code>doSomethingElse()</code> with 1 before returning the value, and that's enough to turn off optimization.</p>

<p>Another common way to inadvertently turn off optimization is to store the result of a function call in a variable and then return the result, such as:</p>

<figure class="code">
<pre><code>"use strict";

function doSomething() {
    // not optimized - call isn't in tail position
    var result = doSomethingElse();
    return result;
}
</code></pre>

</figure>

<p>This example cannot be optimized because the value of <code>doSomethingElse()</code> isn't immediately returned.</p>

<p>Perhaps the hardest situation to avoid is in using closures. Because a closure has access to variables in the containing scope, tail call optimization may be turned off. For example:</p>

<figure class="code">
<pre><code>"use strict";

function doSomething() {
    var num = 1,
        func = () =&gt; num;

    // not optimized - function is a closure
    return func();
}
</code></pre>

</figure>

<p>The closure <code>func()</code> has access to the local variable <code>num</code> in this example. Even though the call to <code>func()</code> immediately returns the result, optimization can't occur due to referencing the variable <code>num</code>.</p>

<h4 id="leanpub-auto-how-to-harness-tail-call-optimization">How to Harness Tail Call Optimization</h4>

<p>In practice, tail call optimization happens behind-the-scenes, so you don't need to think about it unless you're trying to optimize a function. The primary use case for tail call optimization is in recursive functions, as that is where the optimization has the greatest effect. Consider this function, which computes factorials:</p>

<figure class="code">
<pre><code>function factorial(n) {

    if (n &lt;= 1) {
        return 1;
    } else {

        // not optimized - must multiply after returning
        return n * factorial(n - 1);
    }
}
</code></pre>

</figure>

<p>This version of the function cannot be optimized, because multiplication must happen after the recursive call to <code>factorial()</code>. If <code>n</code> is a very large number, the call stack size will grow and could potentially cause a stack overflow.</p>

<p>In order to optimize the function, you need to ensure that the multiplication doesn't happen after the last function call. To do this, you can use a default parameter to move the multiplication operation outside of the <code>return</code> statement. The resulting function carries along the temporary result into the next iteration, creating a function that behaves the same but <em>can</em> be optimized by an ECMAScript 6 engine. Here's the new code:</p>

<figure class="code">
<pre><code>function factorial(n, p = 1) {

    if (n &lt;= 1) {
        return 1 * p;
    } else {
        let result = n * p;

        // optimized
        return factorial(n - 1, result);
    }
}
</code></pre>

</figure>

<p>In this rewritten version of <code>factorial()</code>, a second argument <code>p</code> is added as a parameter with a default value of 1. The <code>p</code> parameter holds the previous multiplication result so that the next result can be computed without another function call. When <code>n</code> is greater than 1, the multiplication is done first and then passed in as the second argument to <code>factorial()</code>. This allows the ECMAScript 6 engine to optimize the recursive call.</p>

<p>Tail call optimization is something you should think about whenever you're writing a recursive function, as it can provide a significant performance improvement, especially when applied in a computationally-expensive function.</p>

<h3 id="leanpub-auto-summary-2">Summary</h3>

<p>Functions haven't undergone a huge change in ECMAScript 6, but rather, a series of incremental changes that make them easier to work with.</p>

<p>Default function parameters allow you to easily specify what value to use when a particular argument isn't passed. Prior to ECMAScript 6, this would require some extra code inside the function, to both check for the presence of arguments and assign a different value.</p>

<p>Rest parameters allow you to specify an array into which all remaining parameters should be placed. Using a real array and letting you indicate which parameters to include makes rest parameters a much more flexible solution than <code>arguments</code>.</p>

<p>The spread operator is a companion to rest parameters, allowing you to deconstruct an array into separate parameters when calling a function. Prior to ECMAScript 6, there were only two ways to pass individual parameters contained in an array: by manually specifying each parameter or using <code>apply()</code>. With the spread operator, you can easily pass an array to any function without worrying about the <code>this</code> binding of the function.</p>

<p>The addition of the <code>name</code> property should help you more easily identify functions for debugging and evaluation purposes. Additionally, ECMAScript 6 formally defines the behavior of block-level functions so they are no longer a syntax error in strict mode.</p>

<p>In ECMAScript 6, the behavior of a function is defined by <code>[[Call]]</code>, normal function execution, and <code>[[Construct]]</code>, when a function is called with <code>new</code>. The <code>new.target</code> metaproperty also allows you to determine if a function was called using <code>new</code> or not.</p>

<p>The biggest change to functions in ECMAScript 6 was the addition of arrow functions. Arrow functions are designed to be used in place of anonymous function expressions. Arrow functions have a more concise syntax, lexical <code>this</code> binding, and no <code>arguments</code> object. Additionally, arrow functions can't change their <code>this</code> binding, and so can't be used as constructors.</p>

<p>Tail call optimization allows some function calls to be optimized in order to keep a smaller call stack, use less memory, and prevent stack overflow errors. This optimization is applied by the engine automatically when it is safe to do so, however, you may decide to rewrite recursive functions in order to take advantage of this optimization.</p>


<h2 id="leanpub-auto-expanded-object-functionality">Expanded Object Functionality</h2>

<p>ECMAScript 6 focuses heavily on improving the utility of objects, which makes sense because nearly every value in JavaScript is some type of object. Additionally, the number of objects used in an average JavaScript program continues to increase as the complexity of JavaScript applications increases, meaning that programs are creating more objects all the time. With more objects comes the necessity to use them more effectively.</p>

<p>ECMAScript 6 improves objects in a number of ways, from simple syntax extensions to options for manipulating and interacting with them.</p>

<h3 id="leanpub-auto-object-categories">Object Categories</h3>

<p>JavaScript uses a mix of terminology to describe objects found in the standard as opposed to those added by execution environments such as the browser or Node.js, and the ECMAScript 6 specification has clear definitions for each category of object. It's important to understand this terminology to have a good understanding of the language as a whole. The object categories are:</p>

<ul>
  <li>
<em>Ordinary objects</em> Have all the default internal behaviors for objects in JavaScript.</li>
  <li>
<em>Exotic objects</em> Have internal behavior that differs from the default in some way.</li>
  <li>
<em>Standard objects</em> Are those defined by ECMAScript 6, such as <code>Array</code>, <code>Date</code>, and so on. Standard objects may be ordinary or exotic.</li>
  <li>
<em>Built-in objects</em> Are present in a JavaScript execution environment when a script begins to execute. All standard objects are built-in objects.</li>
</ul>

<p>I will use these terms throughout the book to explain the various objects defined by ECMAScript 6.</p>

<h3 id="leanpub-auto-object-literal-syntax-extensions">Object Literal Syntax Extensions</h3>

<p>The object literal is one of the most popular patterns in JavaScript. JSON is built upon its syntax, and it's in nearly every JavaScript file on the Internet. The object literal is so popular because it's a succinct syntax for creating objects that otherwise would take several lines of code. Luckily for developers, ECMAScript 6 makes object literals more powerful and even more succinct by extending the syntax in several ways.</p>

<h4 id="leanpub-auto-property-initializer-shorthand">Property Initializer Shorthand</h4>

<p>In ECMAScript 5 and earlier, object literals were simply collections of name-value pairs. That meant there could be some duplication when property values are initialized. For example:</p>

<figure class="code">
<pre><code>function createPerson(name, age) {
    return {
        name: name,
        age: age
    };
}
</code></pre>

</figure>

<p>The <code>createPerson()</code> function creates an object whose property names are the same as the function parameter names. The result appears to be duplication of <code>name</code> and <code>age</code> even though one is the name of an object property while the other provides the value for that property. The key <code>name</code> in the returned object is assigned the value contained in the variable <code>name</code>, and the key <code>age</code> in the returned object is assigned the value contained in the variable <code>age</code>.</p>

<p>In ECMAScript 6, you can eliminate the duplication that exists around property names and local variables by using the <em>property initializer</em> shorthand. When an object property name is the same as the local variable name, you can simply include the name without a colon and value. For example, <code>createPerson()</code> can be rewritten for ECMAScript 6 as follows:</p>

<figure class="code">
<pre><code>function createPerson(name, age) {
    return {
        name,
        age
    };
}
</code></pre>

</figure>

<p>When a property in an object literal only has a name, the JavaScript engine looks into the surrounding scope for a variable of the same name. If it finds one, that variable's value is assigned to the same name on the object literal. In this example, the object literal property <code>name</code> is assigned the value of the local variable <code>name</code>.</p>

<p>This extension makes object literal initialization even more succinct and helps to eliminate naming errors. Assigning a property with the same name as a local variable is a very common pattern in JavaScript, making this extension a welcome addition.</p>

<h4 id="leanpub-auto-concise-methods">Concise Methods</h4>

<p>ECMAScript 6 also improves the syntax for assigning methods to object literals. In ECMAScript 5 and earlier, you must specify a name and then the full function definition to add a method to an object, as follows:</p>

<figure class="code">
<pre><code>var person = {
    name: "Nicholas",
    sayName: function() {
        console.log(this.name);
    }
};
</code></pre>

</figure>

<p>In ECMAScript 6, the syntax is made more concise by eliminating the colon and the <code>function</code> keyword. That means you can rewrite the previous example like this:</p>

<figure class="code">
<pre><code>var person = {
    name: "Nicholas",
    sayName() {
        console.log(this.name);
    }
};
</code></pre>

</figure>

<p>This shorthand syntax, also called <em>concise method</em> syntax, creates a method on the <code>person</code> object just as the previous example did. The <code>sayName()</code> property is assigned an anonymous function and has all the same characteristics as the ECMAScript 5 <code>sayName()</code> function. The one difference is that concise methods may use <code>super</code> (discussed later in the "Easy Prototype Access with Super References" section), while the nonconcise methods may not.</p>

<aside class="information blurb">
    <p>The <code>name</code> property of a method created using concise method shorthand is the name used before the parentheses. In the last example, the <code>name</code> property for <code>person.sayName()</code> is <code>"sayName"</code>.</p>

</aside>

<h4 id="leanpub-auto-computed-property-names">Computed Property Names</h4>

<p>ECMAScript 5 and earlier could compute property names on object instances when those properties were set with square brackets instead of dot notation. The square brackets allow you to specify property names using variables and string literals that may contain characters that would cause a syntax error if used in an identifier. Here's an example:</p>

<figure class="code">
<pre><code>var person = {},
    lastName = "last name";

person["first name"] = "Nicholas";
person[lastName] = "Zakas";

console.log(person["first name"]);      // "Nicholas"
console.log(person[lastName]);          // "Zakas"
</code></pre>

</figure>

<p>Since <code>lastName</code> is assigned a value of <code>"last name"</code>, both property names in this example use a space, making it impossible to reference them using dot notation. However, bracket notation allows any string value to be used as a property name, so assigning <code>"first name"</code> to <code>"Nicholas"</code> and "<code>last name"</code> to <code>"Zakas"</code> works.</p>

<p>Additionally, you can use string literals directly as property names in object literals, like this:</p>

<figure class="code">
<pre><code>var person = {
    "first name": "Nicholas"
};

console.log(person["first name"]);      // "Nicholas"
</code></pre>

</figure>

<p>This pattern works for property names that are known ahead of time and can be represented with a string literal. If, however, the property name <code>"first name"</code> were contained in a variable (as in the previous example) or had to be calculated, then there would be no way to define that property using an object literal in ECMAScript 5.</p>

<p>In ECMAScript 6, computed property names are part of the object literal syntax, and they use the same square bracket notation that has been used to reference computed property names in object instances. For example:</p>

<figure class="code">
<pre><code>var lastName = "last name";

var person = {
    "first name": "Nicholas",
    [lastName]: "Zakas"
};

console.log(person["first name"]);      // "Nicholas"
console.log(person[lastName]);          // "Zakas"
</code></pre>

</figure>

<p>The square brackets inside the object literal indicate that the property name is computed, so its contents are evaluated as a string. That means you can also include expressions such as:</p>

<figure class="code">
<pre><code>var suffix = " name";

var person = {
    ["first" + suffix]: "Nicholas",
    ["last" + suffix]: "Zakas"
};

console.log(person["first name"]);      // "Nicholas"
console.log(person["last name"]);       // "Zakas"
</code></pre>

</figure>

<p>These properties evaluate to <code>"first name"</code> and <code>"last name"</code>, and those strings can be used to reference the properties later. Anything you would put inside square brackets while using bracket notation on object instances will also work for computed property names inside object literals.</p>

<h3 id="leanpub-auto-new-methods">New Methods</h3>

<p>One of the design goals of ECMAScript beginning with ECMAScript 5 was to avoid creating new global functions or methods on <code>Object.prototype</code>, and instead try to find objects on which new methods should be available. As a result, the <code>Object</code> global has received an increasing number of methods when no other objects are more appropriate. ECMAScript 6 introduces a couple new methods on the <code>Object</code> global that are designed to make certain tasks easier.</p>

<h4 id="leanpub-auto-the-objectis-method">The Object.is() Method</h4>

<p>When you want to compare two values in JavaScript, you're probably used to using either the equals operator (<code>==</code>) or the identically equals operator (<code>===</code>). Many developers prefer the latter, to avoid type coercion during comparison. But even the identically equals operator isn't entirely accurate. For example, the values +0 and -0 are considered equal by <code>===</code> even though they are represented differently in the JavaScript engine. Also <code>NaN === NaN</code> returns <code>false</code>, which necessitates using <code>isNaN()</code> to detect <code>NaN</code> properly.</p>

<p>ECMAScript 6 introduces the <code>Object.is()</code> method to make up for the remaining quirks of the identically equals operator. This method accepts two arguments and returns <code>true</code> if the values are equivalent. Two values are considered equivalent when they are of the same type and have the same value. Here are some examples:</p>

<figure class="code">
<pre><code>console.log(+0 == -0);              // true
console.log(+0 === -0);             // true
console.log(Object.is(+0, -0));     // false

console.log(NaN == NaN);            // false
console.log(NaN === NaN);           // false
console.log(Object.is(NaN, NaN));   // true

console.log(5 == 5);                // true
console.log(5 == "5");              // true
console.log(5 === 5);               // true
console.log(5 === "5");             // false
console.log(Object.is(5, 5));       // true
console.log(Object.is(5, "5"));     // false
</code></pre>

</figure>

<p>In many cases, <code>Object.is()</code> works the same as the <code>===</code> operator. The only differences are that +0 and -0 are considered not equivalent and <code>NaN</code> is considered equivalent to <code>NaN</code>. But there's no need to stop using equality operators altogether. Choose whether to use <code>Object.is()</code> instead of <code>==</code> or <code>===</code> based on how those special cases affect your code.</p>

<h4 id="leanpub-auto-the-objectassign-method">The Object.assign() Method</h4>

<p><em>Mixins</em> are among the most popular patterns for object composition in JavaScript. In a mixin, one object receives properties and methods from another object. Many JavaScript libraries have a mixin method similar to this:</p>

<figure class="code">
<pre><code>function mixin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
        receiver[key] = supplier[key];
    });

    return receiver;
}
</code></pre>

</figure>

<p>The <code>mixin()</code> function iterates over the own properties of <code>supplier</code> and copies them onto <code>receiver</code> (a shallow copy, where object references are shared when property values are objects). This allows the <code>receiver</code> to gain new properties without inheritance, as in this code:</p>

<figure class="code">
<pre><code>function EventTarget() { /*...*/ }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() { /*...*/ },
    on: function() { /*...*/ }
};

var myObject = {};
mixin(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
</code></pre>

</figure>

<p>Here, <code>myObject</code> receives behavior from the <code>EventTarget.prototype</code> object. This gives <code>myObject</code> the ability to publish events and subscribe to them using the <code>emit()</code> and <code>on()</code> methods, respectively.</p>

<p>This pattern became popular enough that ECMAScript 6 added the <code>Object.assign()</code> method, which behaves the same way, accepting a receiver and any number of suppliers, and then returning the receiver. The name change from <code>mixin()</code> to <code>assign()</code> reflects the actual operation that occurs. Since the <code>mixin()</code> function uses the assignment operator (<code>=</code>), it cannot copy accessor properties to the receiver as accessor properties. The name <code>Object.assign()</code> was chosen to reflect this distinction.</p>

<aside class="information blurb">
    <p>Similar methods in various libraries may have other names for the same basic functionality; popular alternates include the <code>extend()</code> and <code>mix()</code> methods. There was also, briefly, an <code>Object.mixin()</code> method in ECMAScript 6 in addition to the <code>Object.assign()</code> method. The primary difference was that <code>Object.mixin()</code> also copied over accessor properties, but the method was removed due to concerns over the use of <code>super</code> (discussed in the "Easy Prototype Access with Super References" section of this chapter).</p>

</aside>

<p>You can use <code>Object.assign()</code> anywhere the <code>mixin()</code> function would have been used. Here's an example:</p>

<figure class="code">
<pre><code>function EventTarget() { /*...*/ }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() { /*...*/ },
    on: function() { /*...*/ }
}

var myObject = {}
Object.assign(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
</code></pre>

</figure>

<p>The <code>Object.assign()</code> method accepts any number of suppliers, and the receiver receives the properties in the order in which the suppliers are specified. That means the second supplier might overwrite a value from the first supplier on the receiver, which is what happens in this snippet:</p>

<figure class="code">
<pre><code>var receiver = {};

Object.assign(receiver,
    {
        type: "js",
        name: "file.js"
    },
    {
        type: "css"
    }
);

console.log(receiver.type);     // "css"
console.log(receiver.name);     // "file.js"
</code></pre>

</figure>

<p>The value of <code>receiver.type</code> is <code>"css"</code> because the second supplier overwrote the value of the first.</p>

<p>The <code>Object.assign()</code> method isn't a big addition to ECMAScript 6, but it does formalize a common function found in many JavaScript libraries.</p>

<aside>
  <h4 id="leanpub-auto-working-with-accessor-properties">Working with Accessor Properties</h4>

  <p>Keep in mind that <code>Object.assign()</code> doesn't create accessor properties on the receiver when a supplier has accessor properties. Since <code>Object.assign()</code> uses the assignment operator, an accessor property on a supplier will become a data property on the receiver. For example:</p>

  <figure class="code">
<pre><code>var receiver = {},
    supplier = {
        get name() {
            return "file.js"
        }
    };

Object.assign(receiver, supplier);

var descriptor = Object.getOwnPropertyDescriptor(receiver, "name");

console.log(descriptor.value);      // "file.js"
console.log(descriptor.get);        // undefined
</code></pre>

  </figure>

  <p>In this code, the <code>supplier</code> has an accessor property called <code>name</code>. After using the <code>Object.assign()</code> method, <code>receiver.name</code> exists as a data property with a value of <code>"file.js"</code> because <code>supplier.name</code> returned <code>"file.js"</code> when <code>Object.assign()</code> was called.</p>

</aside>

<h3 id="leanpub-auto-duplicate-object-literal-properties">Duplicate Object Literal Properties</h3>

<p>ECMAScript 5 strict mode introduced a check for duplicate object literal properties that would throw an error if a duplicate was found. For example, this code was problematic:</p>

<figure class="code">
<pre><code>"use strict";

var person = {
    name: "Nicholas",
    name: "Greg"        // syntax error in ES5 strict mode
};
</code></pre>

</figure>

<p>When running in ECMAScript 5 strict mode, the second <code>name</code> property causes a syntax error. But in ECMAScript 6, the duplicate property check was removed. Both strict and nonstrict mode code no longer check for duplicate properties. Instead, the last property of the given name becomes the property's actual value, as shown here:</p>

<figure class="code">
<pre><code>"use strict";

var person = {
    name: "Nicholas",
    name: "Greg"        // no error in ES6 strict mode
};

console.log(person.name);       // "Greg"
</code></pre>

</figure>

<p>In this example, the value of <code>person.name</code> is <code>"Greg"</code> because that's the last value assigned to the property.</p>

<h3 id="leanpub-auto-own-property-enumeration-order">Own Property Enumeration Order</h3>

<p>ECMAScript 5 didn't define the enumeration order of object properties, as it left this up to the JavaScript engine vendors. However, ECMAScript 6 strictly defines the order in which own properties must be returned when they are enumerated. This affects how properties are returned using <code>Object.getOwnPropertyNames()</code> and <code>Reflect.ownKeys</code> (covered in Chapter 12). It also affects the order in which properties are processed by <code>Object.assign()</code>.</p>

<p>The basic order for own property enumeration is:</p>

<ol class="numeric">
  <li>All numeric keys in ascending order</li>
  <li>All string keys in the order in which they were added to the object</li>
  <li>All symbol keys (covered in Chapter 6) in the order in which they were added to the object</li>
</ol>

<p>Here's an example:</p>

<figure class="code">
<pre><code>var obj = {
    a: 1,
    0: 1,
    c: 1,
    2: 1,
    b: 1,
    1: 1
};

obj.d = 1;

console.log(Object.getOwnPropertyNames(obj).join(""));     // "012acbd"
</code></pre>

</figure>

<p>The <code>Object.getOwnPropertyNames()</code> method returns the properties in <code>obj</code> in the order <code>0</code>, <code>1</code>, <code>2</code>, <code>a</code>, <code>c</code>, <code>b</code>, <code>d</code>. Note that the numeric keys are grouped together and sorted, even though they appear out of order in the object literal. The string keys come after the numeric keys and appear in the order that they were added to <code>obj</code>. The keys in the object literal itself come first, followed by any dynamic keys that were added later (in this case, <code>d</code>).</p>

<aside class="warning blurb">
    <p>The <code>for-in</code> loop still has an unspecified enumeration order because not all JavaScript engines implement it the same way. The <code>Object.keys()</code> method and <code>JSON.stringify()</code> are both specified to use the same (unspecified) enumeration order as <code>for-in</code>.</p>

</aside>

<p>While enumeration order is a subtle change to how JavaScript works, it's not uncommon to find programs that rely on a specific enumeration order to work correctly. ECMAScript 6, by defining the enumeration order, ensures that JavaScript code relying on enumeration will work correctly regardless of where it is executed.</p>

<h3 id="leanpub-auto-more-powerful-prototypes">More Powerful Prototypes</h3>

<p>Prototypes are the foundation of inheritance in JavaScript, and ECMAScript 6 continues to make prototypes more powerful. Early versions of JavaScript severely limited what could be done with prototypes. However, as the language matured and developers became more familiar with how prototypes work, it became clear that developers wanted more control over prototypes and easier ways to work with them. As a result, ECMAScript 6 introduced some improvements to prototypes.</p>

<h4 id="leanpub-auto-changing-an-objects-prototype">Changing an Object's Prototype</h4>

<p>Normally, the prototype of an object is specified when the object is created, via either a constructor or the <code>Object.create()</code> method. The idea that an object's prototype remains unchanged after instantiation was one of the biggest assumptions in JavaScript programming through ECMAScript 5. ECMAScript 5 did add the <code>Object.getPrototypeOf()</code> method for retrieving the prototype of any given object, but it still lacked a standard way to change an object's prototype after instantiation.</p>

<p>ECMAScript 6 changes that assumption by adding the <code>Object.setPrototypeOf()</code> method, which allows you to change the prototype of any given object. The <code>Object.setPrototypeOf()</code> method accepts two arguments: the object whose prototype should change and the object that should become the first argument's prototype. For example:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

let dog = {
    getGreeting() {
        return "Woof";
    }
};

// prototype is person
let friend = Object.create(person);
console.log(friend.getGreeting());                      // "Hello"
console.log(Object.getPrototypeOf(friend) === person);  // true

// set prototype to dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting());                      // "Woof"
console.log(Object.getPrototypeOf(friend) === dog);     // true
</code></pre>

</figure>

<p>This code defines two base objects: <code>person</code> and <code>dog</code>. Both objects have a <code>getGreeting()</code> method that returns a string. The object <code>friend</code> first inherits from the <code>person</code> object, meaning that <code>getGreeting()</code> outputs <code>"Hello"</code>. When the prototype becomes the <code>dog</code> object, <code>person.getGreeting()</code> outputs <code>"Woof"</code> because the original relationship to <code>person</code> is broken.</p>

<p>The actual value of an object's prototype is stored in an internal-only property called <code>[[Prototype]]</code>. The <code>Object.getPrototypeOf()</code> method returns the value stored in <code>[[Prototype]]</code> and <code>Object.setPrototypeOf()</code> changes the value stored in <code>[[Prototype]]</code>. However, these aren't the only ways to work with the value of <code>[[Prototype]]</code>.</p>

<h4 id="leanpub-auto-easy-prototype-access-with-super-references">Easy Prototype Access with Super References</h4>

<p>As previously mentioned, prototypes are very important for JavaScript and a lot of work went into making them easier to use in ECMAScript 6. Another improvement is the introduction of <code>super</code> references, which make accessing functionality on an object's prototype easier. For example, to override a method on an object instance such that it also calls the prototype method of the same name, you'd do the following:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

let dog = {
    getGreeting() {
        return "Woof";
    }
};


let friend = {
    getGreeting() {
        return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";
    }
};

// set prototype to person
Object.setPrototypeOf(friend, person);
console.log(friend.getGreeting());                      // "Hello, hi!"
console.log(Object.getPrototypeOf(friend) === person);  // true

// set prototype to dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting());                      // "Woof, hi!"
console.log(Object.getPrototypeOf(friend) === dog);     // true
</code></pre>

</figure>

<p>In this example, <code>getGreeting()</code> on <code>friend</code> calls the prototype method of the same name. The <code>Object.getPrototypeOf()</code> method ensures the correct prototype is called, and then an additional string is appended to the output. The additional <code>.call(this)</code> ensures that the <code>this</code> value inside the prototype method is set correctly.</p>

<p>Remembering to use <code>Object.getPrototypeOf()</code> and <code>.call(this)</code> to call a method on the prototype is a bit involved, so ECMAScript 6 introduced <code>super</code>. At its simplest, <code>super</code> is a pointer to the current object's prototype, effectively the <code>Object.getPrototypeOf(this)</code> value. Knowing that, you can simplify the <code>getGreeting()</code> method as follows:</p>

<figure class="code">
<pre><code>let friend = {
    getGreeting() {
        // in the previous example, this is the same as:
        // Object.getPrototypeOf(this).getGreeting.call(this)
        return super.getGreeting() + ", hi!";
    }
};
</code></pre>

</figure>

<p>The call to <code>super.getGreeting()</code> is the same as <code>Object.getPrototypeOf(this).getGreeting.call(this)</code> in this context. Similarly, you can call any method on an object's prototype by using a <code>super</code> reference, so long as it's inside a concise method. Attempting to use <code>super</code> outside of concise methods results in a syntax error, as in this example:</p>

<figure class="code">
<pre><code>let friend = {
    getGreeting: function() {
        // syntax error
        return super.getGreeting() + ", hi!";
    }
};
</code></pre>

</figure>

<p>This example uses a named property with a function, and the call to <code>super.getGreeting()</code> results in a syntax error because <code>super</code> is invalid in this context.</p>

<p>The <code>super</code> reference is really powerful when you have multiple levels of inheritance, because in that case, <code>Object.getPrototypeOf()</code> no longer works in all circumstances. For example:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

// prototype is person
let friend = {
    getGreeting() {
        return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";
    }
};
Object.setPrototypeOf(friend, person);


// prototype is friend
let relative = Object.create(friend);

console.log(person.getGreeting());                  // "Hello"
console.log(friend.getGreeting());                  // "Hello, hi!"
console.log(relative.getGreeting());                // error!
</code></pre>

</figure>

<p>The call to <code>Object.getPrototypeOf()</code> results in an error when <code>relative.getGreeting()</code> is called. That's because <code>this</code> is <code>relative</code>, and the prototype of <code>relative</code> is the <code>friend</code> object. When <code>friend.getGreeting().call()</code> is called with <code>relative</code> as <code>this</code>, the process starts over again and continues to call recursively until a stack overflow error occurs.</p>

<p>That problem is difficult to solve in ECMAScript 5, but with ECMAScript 6 and <code>super</code>, it's easy:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

// prototype is person
let friend = {
    getGreeting() {
        return super.getGreeting() + ", hi!";
    }
};
Object.setPrototypeOf(friend, person);


// prototype is friend
let relative = Object.create(friend);

console.log(person.getGreeting());                  // "Hello"
console.log(friend.getGreeting());                  // "Hello, hi!"
console.log(relative.getGreeting());                // "Hello, hi!"
</code></pre>

</figure>

<p>Because <code>super</code> references are not dynamic, they always refer to the correct object. In this case, <code>super.getGreeting()</code> always refers to <code>person.getGreeting()</code>, regardless of how many other objects inherit the method.</p>

<h3 id="leanpub-auto-a-formal-method-definition">A Formal Method Definition</h3>

<p>Prior to ECMAScript 6, the concept of a "method" wasn't formally defined. Methods were just object properties that contained functions instead of data. ECMAScript 6 formally defines a method as a function that has an internal <code>[[HomeObject]]</code> property containing the object to which the method belongs. Consider the following:</p>

<figure class="code">
<pre><code>let person = {

    // method
    getGreeting() {
        return "Hello";
    }
};

// not a method
function shareGreeting() {
    return "Hi!";
}
</code></pre>

</figure>

<p>This example defines <code>person</code> with a single method called <code>getGreeting()</code>. The <code>[[HomeObject]]</code> for <code>getGreeting()</code> is <code>person</code> by virtue of assigning the function directly to an object. The <code>shareGreeting()</code> function, on the other hand, has no <code>[[HomeObject]]</code> specified because it wasn't assigned to an object when it was created. In most cases, this difference isn't important, but it becomes very important when using <code>super</code> references.</p>

<p>Any reference to <code>super</code> uses the <code>[[HomeObject]]</code> to determine what to do. The first step is to call <code>Object.getPrototypeOf()</code> on the <code>[[HomeObject]]</code> to retrieve a reference to the prototype. Then, the prototype is searched for a function with the same name. Last, the <code>this</code> binding is set and the method is called. Here's an example:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

// prototype is person
let friend = {
    getGreeting() {
        return super.getGreeting() + ", hi!";
    }
};
Object.setPrototypeOf(friend, person);

console.log(friend.getGreeting());  // "Hello, hi!"
</code></pre>

</figure>

<p>Calling <code>friend.getGreeting()</code> returns a string, which combines the value from <code>person.getGreeting()</code> with <code>", hi!"</code>. The <code>[[HomeObject]]</code> of <code>friend.getGreeting()</code> is <code>friend</code>, and the prototype of <code>friend</code> is <code>person</code>, so <code>super.getGreeting()</code> is equivalent to <code>person.getGreeting.call(this)</code>.</p>

<h3 id="leanpub-auto-summary-3">Summary</h3>

<p>Objects are the center of programming in JavaScript, and ECMAScript 6 made some helpful changes to objects that both make them easier to deal with and more powerful.</p>

<p>ECMAScript 6 makes several changes to object literals. Shorthand property definitions make assigning properties with the same names as in-scope variables easier. Computed property names allow you to specify non-literal values as property names, which you've already been able to do in other areas of the language. Shorthand methods let you type a lot fewer characters in order to define methods on object literals, by completely omitting the colon and <code>function</code> keyword. ECMAScript 6 loosens the strict mode check for duplicate object literal property names as well, meaning you can have two properties with the same name in a single object literal without throwing an error.</p>

<p>The <code>Object.assign()</code> method makes it easier to change multiple properties on a single object at once. This can be very useful if you use the mixin pattern. The <code>Object.is()</code> method performs strict equality on any value, effectively becoming a safer version of <code>===</code> when dealing with special JavaScript values.</p>

<p>Enumeration order for own properties is now clearly defined in ECMAScript 6. When enumerating properties, numeric keys always come first in ascending order followed by string keys in insertion order and symbol keys in insertion order.</p>

<p>It's now possible to modify an object's prototype after it's already created, thanks to ECMAScript 6's <code>Object.setPrototypeOf()</code> method.</p>

<p>Finally, you can use the <code>super</code> keyword to call methods on an object's prototype. The <code>this</code> binding inside a method invoked using <code>super</code> is set up to automatically work with the current value of <code>this</code>.</p>


<h2 id="leanpub-auto-destructuring-for-easier-data-access">Destructuring for Easier Data Access</h2>

<p>Object and array literals are two of the most frequently used notations in JavaScript, and thanks to the popular JSON data format, they've become a particularly important part of the language. It's quite common to define objects and arrays, and then systematically pull out relevant pieces of information from those structures. ECMAScript 6 simplifies this task by adding <em>destructuring</em>, which is the process of breaking a data structure down into smaller parts. This chapter shows you how to harness destructuring for both objects and arrays.</p>

<h3 id="leanpub-auto-why-is-destructuring-useful">Why is Destructuring Useful?</h3>

<p>In ECMAScript 5 and earlier, the need to fetch information from objects and arrays could lead to a lot of code that looks the same, just to get certain data into local variables. For example:</p>

<figure class="code">
<pre><code>let options = {
        repeat: true,
        save: false
    };

// extract data from the object
let repeat = options.repeat,
    save = options.save;
</code></pre>

</figure>

<p>This code extracts the values of <code>repeat</code> and <code>save</code> from the <code>options</code> object and stores that data in local variables with the same names. While this code looks simple, imagine if you had a large number of variables to assign; you would have to assign them all one by one. And if there was a nested data structure to traverse to find the information instead, you might have to dig through the entire structure just to find one piece of data.</p>

<p>That's why ECMAScript 6 adds destructuring for both objects and arrays. When you break a data structure into smaller parts, getting the information you need out of it becomes much easier. Many languages implement destructuring with a minimal amount of syntax to make the process simpler to use. The ECMAScript 6 implementation actually makes use of syntax you're already familiar with: the syntax for object and array literals.</p>

<h3 id="leanpub-auto-object-destructuring">Object Destructuring</h3>

<p>Object destructuring syntax uses an object literal on the left side of an assignment operation. For example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    };

let { type, name } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
</code></pre>

</figure>

<p>In this code, the value of <code>node.type</code> is stored in a variable called <code>type</code> and the value of <code>node.name</code> is stored in a variable called <code>name</code>. This syntax is the same as the object literal property initializer shorthand introduced in Chapter 4. The identifiers <code>type</code> and <code>name</code> are both declarations of local variables and the properties to read the value from on the <code>node</code> object.</p>

<aside>
  <h5 id="leanpub-auto-dont-forget-the-initializer">Don't Forget the Initializer</h5>

  <p>When using destructuring to declare variables using <code>var</code>, <code>let</code>, or <code>const</code>, you must supply an initializer (the value after the equals sign). The following lines of code will all throw syntax errors due to a missing initializer:</p>

  <figure class="code">
<pre><code>// syntax error!
var { type, name };

// syntax error!
let { type, name };

// syntax error!
const { type, name };
</code></pre>

  </figure>

  <p>While <code>const</code> always requires an initializer, even when using nondestructured variables, <code>var</code> and <code>let</code> only require initializers when using destructuring.</p>

</aside>

<h5 id="leanpub-auto-destructuring-assignment">Destructuring Assignment</h5>

<p>The object destructuring examples so far have used variable declarations. However, it's also possible to use destructuring in assignments. For instance, you may decide to change the values of variables after they are defined, as follows:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    },
    type = "Literal",
    name = 5;

// assign different values using destructuring
({ type, name } = node);

console.log(type);      // "Identifier"
console.log(name);      // "foo"
</code></pre>

</figure>

<p>In this example, <code>type</code> and <code>name</code> are initialized with values when declared, and then two variables with the same names are initialized with different values. The next line uses destructuring assignment to change those values by reading from the <code>node</code> object. Note that you must put parentheses around a destructuring assignment statement. That's because an opening curly brace is expected to a be a block statement, and a block statement cannot appear on the left side of an assignment. The parentheses signal that the next curly brace is not a block statement and should be interpreted as an expression, allowing the assignment to complete.</p>

<p>A destructuring assignment expression evaluates to the right side of the expression (after the <code>=</code>). That means you can use a destructuring assignment expression anywhere a value is expected. For instance, passing a value to a function:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    },
    type = "Literal",
    name = 5;

function outputInfo(value) {
    console.log(value === node);        // true
}

outputInfo({ type, name } = node);

console.log(type);      // "Identifier"
console.log(name);      // "foo"
</code></pre>

</figure>

<p>The <code>outputInfo()</code> function is called with a destructuring assignment expression. The expression evaluates to <code>node</code> because that is the value of the right side of the expression. The assignment to <code>type</code> and <code>name</code> both behave as normal and <code>node</code> is passed into <code>outputInfo()</code>.</p>

<aside class="warning blurb">
    <p>An error is thrown when the right side of the destructuring assignment expression (the expression after <code>=</code>) evaluates to <code>null</code> or <code>undefined</code>. This happens because any attempt to read a property of <code>null</code> or <code>undefined</code> results in a runtime error.</p>

</aside>

<h5 id="leanpub-auto-default-values">Default Values</h5>

<p>When you use a destructuring assignment statement, if you specify a local variable with a property name that doesn't exist on the object, then that local variable is assigned a value of <code>undefined</code>. For example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    };

let { type, name, value } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
console.log(value);     // undefined
</code></pre>

</figure>

<p>This code defines an additional local variable called <code>value</code> and attempts to assign it a value. However, there is no corresponding <code>value</code> property on the <code>node</code> object, so the variable is assigned the value of <code>undefined</code> as expected.</p>

<p>You can optionally define a default value to use when a specified property doesn't exist. To do so, insert an equals sign (<code>=</code>) after the property name and specify the default value, like this:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    };

let { type, name, value = true } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
console.log(value);     // true
</code></pre>

</figure>

<p>In this example, the variable <code>value</code> is given <code>true</code> as a default value. The default value is only used if the property is missing on <code>node</code> or has a value of <code>undefined</code>. Since there is no <code>node.value</code> property, the variable <code>value</code> uses the default value. This works similarly to the default parameter values for functions, as discussed in Chapter 3.</p>

<h5 id="leanpub-auto-assigning-to-different-local-variable-names">Assigning to Different Local Variable Names</h5>

<p>Up to this point, each example destructuring assignment has used the object property name as the local variable name; for example, the value of <code>node.type</code> was stored in a <code>type</code> variable. That works well when you want to use the same name, but what if you don't? ECMAScript 6 has an extended syntax that allows you to assign to a local variable with a different name, and that syntax looks like the object literal nonshorthand property initializer syntax. Here's an example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo"
    };

let { type: localType, name: localName } = node;

console.log(localType);     // "Identifier"
console.log(localName);     // "foo"
</code></pre>

</figure>

<p>This code uses destructuring assignment to declare the <code>localType</code> and <code>localName</code> variables, which contain the values from the <code>node.type</code> and <code>node.name</code> properties, respectively. The syntax <code>type: localType</code> says to read the property named <code>type</code> and store its value in the <code>localType</code> variable. This syntax is effectively the opposite of traditional object literal syntax, where the name is on the left of the colon and the value is on the right. In this case, the name is on the right of the colon and the location of the value to read is on the left.</p>

<p>You can add default values when using a different variable name, as well. The equals sign and default value are  still placed after the local variable name. For example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier"
    };

let { type: localType, name: localName = "bar" } = node;

console.log(localType);     // "Identifier"
console.log(localName);     // "bar"
</code></pre>

</figure>

<p>Here, the <code>localName</code> variable has a default value of <code>"bar"</code>. The variable is assigned its default value because there's no <code>node.name</code> property.</p>

<p>So far, you've seen how to deal with destructuring of an object whose properties are primitive values. Object destructuring can also be used to retrieve values in nested object structures.</p>

<h5 id="leanpub-auto-nested-object-destructuring">Nested Object Destructuring</h5>

<p>By using a syntax similar to object literals, you can navigate into a nested object structure to retrieve just the information you want. Here's an example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        }
    };

let { loc: { start }} = node;

console.log(start.line);        // 1
console.log(start.column);      // 1
</code></pre>

</figure>

<p>The destructuring pattern in this example uses curly braces to indicate that the pattern should descend into the property named <code>loc</code> on <code>node</code> and look for the <code>start</code> property. Remember from the last section that whenever there's a colon in a destructuring pattern, it means the identifier before the colon is giving a location to inspect, and the right side assigns a value. When there's a curly brace after the colon, that indicates that the destination is nested another level into the object.</p>

<p>You can go one step further and use a different name for the local variable as well:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        }
    };

// extract node.loc.start
let { loc: { start: localStart }} = node;

console.log(localStart.line);   // 1
console.log(localStart.column); // 1
</code></pre>

</figure>

<p>In this version of the code, <code>node.loc.start</code> is stored in a new local variable called <code>localStart</code>. Destructuring patterns can be nested to an arbitrary level of depth, with all capabilities available at each level.</p>

<p>Object destructuring is very powerful and has a lot of options, but array destructuring offers some unique capabilities that allow you to extract information from arrays.</p>

<aside>
  <h5 id="leanpub-auto-syntax-gotcha">Syntax Gotcha</h5>

  <p>Be careful when using nested destructuring because you can inadvertently create a statement that has no effect. Empty curly braces are legal in object destructuring, however, they don't do anything. For example:</p>

  <figure class="code">
<pre><code>// no variables declared!
let { loc: {} } = node;
</code></pre>

  </figure>

  <p>There are no bindings declared in this statement. Due to the curly braces on the right, <code>loc</code> is used as a location to inspect rather than a binding to create. In such a case, it's likely that the intent was to use <code>=</code> to define a default value rather than <code>:</code> to define a location. It's possible that this syntax will be made illegal in the future, but for now, this is a gotcha to look out for.</p>

</aside>

<h3 id="leanpub-auto-array-destructuring">Array Destructuring</h3>

<p>Array destructuring syntax is very similar to object destructuring; it just uses array literal syntax instead of object literal syntax. The destructuring operates on positions within an array, rather than the named properties that are available in objects. For example:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];

let [ firstColor, secondColor ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
</code></pre>

</figure>

<p>Here, array destructuring pulls out the values <code>"red"</code> and <code>"green"</code> from the <code>colors</code> array and stores them in  the <code>firstColor</code> and <code>secondColor</code> variables. Those values are chosen because of their position in the array; the actual variable names could be anything. Any items not explicitly mentioned in the destructuring pattern are ignored. Keep in mind that the array itself isn't changed in any way.</p>

<p>You can also omit items in the destructuring pattern and only provide variable names for the items you're interested in. If, for example, you just want the third value of an array, you don't need to supply variable names for the first and second items. Here's how that works:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];

let [ , , thirdColor ] = colors;

console.log(thirdColor);        // "blue"
</code></pre>

</figure>

<p>This code uses a destructuring assignment to retrieve the third item in <code>colors</code>. The commas preceding <code>thirdColor</code> in the pattern are placeholders for the array items that come before it. By using this approach, you can easily pick out values from any number of slots in the middle of an array without needing to provide variable names for them.</p>

<aside class="warning blurb">
    <p>Similar to object destructuring, you must always provide an initializer when using array destructuring with <code>var</code>, <code>let</code>, or <code>const</code>.</p>

</aside>

<h5 id="leanpub-auto-destructuring-assignment-1">Destructuring Assignment</h5>

<p>You can use array destructuring in the context of an assignment, but unlike object destructuring, there is no need to wrap the expression in parentheses. For example:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ],
    firstColor = "black",
    secondColor = "purple";

[ firstColor, secondColor ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
</code></pre>

</figure>

<p>The destructured assignment in this code works in a similar manner to the last array destructuring example. The only difference is that <code>firstColor</code> and <code>secondColor</code> have already been defined. Most of the time, that's probably all you'll need to know about array destructuring assignment, but there's a little bit more to it that you will probably find useful.</p>

<p>Array destructuring assignment has a very unique use case that makes it easier to swap the values of two variables. Value swapping is a common operation in sorting algorithms, and the ECMAScript 5 way of swapping variables involves a third, temporary variable, as in this example:</p>

<figure class="code">
<pre><code>// Swapping variables in ECMAScript 5
let a = 1,
    b = 2,
    tmp;

tmp = a;
a = b;
b = tmp;

console.log(a);     // 2
console.log(b);     // 1
</code></pre>

</figure>

<p>The intermediate variable <code>tmp</code> is necessary in order to swap the values of <code>a</code> and <code>b</code>. Using array destructuring assignment, however, there's no need for that extra variable. Here's how you can swap variables in ECMAScript 6:</p>

<figure class="code">
<pre><code>// Swapping variables in ECMAScript 6
let a = 1,
    b = 2;

[ a, b ] = [ b, a ];

console.log(a);     // 2
console.log(b);     // 1
</code></pre>

</figure>

<p>The array destructuring assignment in this example looks like a mirror image. The left side of the assignment (before the equals sign) is a destructuring pattern just like those in the other array destructuring examples. The right side is an array literal that is temporarily created for the swap. The destructuring happens on the temporary array, which has the values of <code>b</code> and <code>a</code> copied into its first and second positions. The effect is that the variables have swapped values.</p>

<aside class="warning blurb">
    <p>Like object destructuring assignment, an error is thrown when the right side of an array destructured assignment expression evaluates to <code>null</code> or <code>undefined</code>.</p>

</aside>

<h5 id="leanpub-auto-default-values-1">Default Values</h5>

<p>Array destructuring assignment allows you to specify a default value for any position in the array, too. The default value is used when the property at the given position either doesn't exist or has the value <code>undefined</code>. For example:</p>

<figure class="code">
<pre><code>let colors = [ "red" ];

let [ firstColor, secondColor = "green" ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
</code></pre>

</figure>

<p>In this code, the <code>colors</code> array has only one item, so there is nothing for <code>secondColor</code> to match. Since there is a default value, <code>secondColor</code> is set to <code>"green"</code> instead of <code>undefined</code>.</p>

<h5 id="leanpub-auto-nested-destructuring">Nested Destructuring</h5>

<p>You can destructure nested arrays in a manner similar to destructuring nested objects. By inserting another array pattern into the overall pattern, the destructuring will descend into a nested array, like this:</p>

<figure class="code">
<pre><code>let colors = [ "red", [ "green", "lightgreen" ], "blue" ];

// later

let [ firstColor, [ secondColor ] ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
</code></pre>

</figure>

<p>Here, the <code>secondColor</code> variable refers to the <code>"green"</code> value inside the <code>colors</code> array. That item is contained within a second array, so the extra square brackets around <code>secondColor</code> in the destructuring pattern are necessary. As with objects, you can nest arrays arbitrarily deep.</p>

<h5 id="leanpub-auto-rest-items">Rest Items</h5>

<p>Chapter 3 introduced rest parameters for functions, and array destructuring has a similar concept called <em>rest items</em>. Rest items use the <code>...</code> syntax to assign the remaining items in an array to a particular variable. Here's an example:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];

let [ firstColor, ...restColors ] = colors;

console.log(firstColor);        // "red"
console.log(restColors.length); // 2
console.log(restColors[0]);     // "green"
console.log(restColors[1]);     // "blue"
</code></pre>

</figure>

<p>The first item in <code>colors</code> is assigned to <code>firstColor</code>, and the rest are assigned into a new <code>restColors</code> array. The <code>restColors</code> array, therefore, has two items: <code>"green"</code> and <code>"blue"</code>. Rest items are useful for extracting certain items from an array and keeping the rest available, but there's another helpful use.</p>

<p>A glaring omission from JavaScript arrays is the ability to easily create a clone. In ECMAScript 5, developers frequently used the <code>concat()</code> method as an easy way to clone an array. For example:</p>

<figure class="code">
<pre><code>// cloning an array in ECMAScript 5
var colors = [ "red", "green", "blue" ];
var clonedColors = colors.concat();

console.log(clonedColors);      //"[red,green,blue]"
</code></pre>

</figure>

<p>While the <code>concat()</code> method is intended to concatenate two arrays together, calling it without an argument returns a clone of the array. In ECMAScript 6, you can use rest items to achieve the same thing through syntax intended to function that way. It works like this:</p>

<figure class="code">
<pre><code>// cloning an array in ECMAScript 6
let colors = [ "red", "green", "blue" ];
let [ ...clonedColors ] = colors;

console.log(clonedColors);      //"[red,green,blue]"
</code></pre>

</figure>

<p>In this example, rest items are used to copy values from the <code>colors</code> array into the <code>clonedColors</code> array. While it's a matter of perception as to whether this technique makes the developer's intent clearer than using the <code>concat()</code> method, this is a useful ability to be aware of.</p>

<aside class="warning blurb">
    <p>Rest items must be the last entry in the destructured array and cannot be followed by a comma. Including a comma after rest items is a syntax error.</p>

</aside>

<h3 id="leanpub-auto-mixed-destructuring">Mixed Destructuring</h3>

<p>Object and array destructuring can be used together to create more complex expressions. In doing so, you are able to extract just the pieces of information you want from any mixture of objects and arrays. For example:</p>

<figure class="code">
<pre><code>let node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        },
        range: [0, 3]
    };

let {
    loc: { start },
    range: [ startIndex ]
} = node;

console.log(start.line);        // 1
console.log(start.column);      // 1
console.log(startIndex);        // 0
</code></pre>

</figure>

<p>This code extracts <code>node.loc.start</code> and <code>node.range[0]</code> into <code>start</code> and <code>startIndex</code>, respectively. Keep in mind that <code>loc:</code> and <code>range:</code> in the destructured pattern are just locations that correspond to properties in the <code>node</code> object. There is no part of <code>node</code> that cannot be extracted using destructuring when you use a mix of object and array destructuring. This approach is particularly useful for pulling values out of JSON configuration structures without navigating the entire structure.</p>

<h3 id="leanpub-auto-destructured-parameters">Destructured Parameters</h3>

<p>Destructuring has one more particularly helpful use case, and that is when passing function arguments. When a JavaScript function takes a large number of optional parameters, one common pattern is to create an <code>options</code> object whose properties specify the additional parameters, like this:</p>

<figure class="code">
<pre><code>// properties on options represent additional parameters
function setCookie(name, value, options) {

    options = options || {};

    let secure = options.secure,
        path = options.path,
        domain = options.domain,
        expires = options.expires;

    // code to set the cookie
}

// third argument maps to options
setCookie("type", "js", {
    secure: true,
    expires: 60000
});
</code></pre>

</figure>
<p>Many JavaScript libraries contain <code>setCookie()</code> functions that look similar to this one. In this function, the <code>name</code> and <code>value</code> arguments are required, but <code>secure</code>, <code>path</code>, <code>domain</code>, and <code>expires</code> are not. And since there is no priority order for the other data, it's efficient to just have an <code>options</code> object with named properties, rather than list extra named parameters. This approach works, but now you can't tell what input the function expects just by looking at the function definition; you need to read the function body.</p>

<p>Destructured parameters offer an alternative that makes it clearer what arguments a function expects. A destructured parameter uses an object or array destructuring pattern in place of a named parameter. To see this in action, look at this rewritten version of the <code>setCookie()</code> function from the last example:</p>

<figure class="code">
<pre><code>function setCookie(name, value, { secure, path, domain, expires }) {

    // code to set the cookie
}

setCookie("type", "js", {
    secure: true,
    expires: 60000
});
</code></pre>

</figure>

<p>This function behaves similarly to the previous example, but now, the third argument uses destructuring to pull out the necessary data. The parameters outside the destructured parameter are clearly expected, and at the same time, it's clear to someone using <code>setCookie()</code> what options are available in terms of extra arguments. And of course, if the third argument is required, the values it should contain are crystal clear. The destructured parameters also act like regular parameters in that they are set to <code>undefined</code> if they are not passed.</p>

<aside>
  <p>Destructured parameters have all of the capabilities of destructuring that you've learned so far in this chapter. You can use default values, mix object and array patterns, and use variable names that differ from the properties you're reading from.</p>

</aside>

<h4 id="leanpub-auto-destructured-parameters-are-required">Destructured Parameters are Required</h4>

<p>One quirk of using destructured parameters is that, by default, an error is thrown when they are not provided in a function call. For instance, this call to the <code>setCookie()</code> function in the last example throws an error:</p>

<figure class="code">
<pre><code>// Error!
setCookie("type", "js");
</code></pre>

</figure>

<p>The third argument is missing, and so it evaluates to <code>undefined</code> as expected. This causes an error because destructured parameters are really just a shorthand for destructured declaration. When the <code>setCookie()</code> function is called, the JavaScript engine actually does this:</p>

<figure class="code">
<pre><code>function setCookie(name, value, options) {

    let { secure, path, domain, expires } = options;

    // code to set the cookie
}
</code></pre>

</figure>

<p>Since destructuring throws an error when the right side expression evaluates to <code>null</code> or <code>undefined</code>, the same is true when the third argument isn't passed to the <code>setCookie()</code> function.</p>

<p>If you want the destructured parameter to be required, then this behavior isn't all that troubling. But if you want the destructured parameter to be optional, you can work around this behavior by providing a default value for the destructured parameter, like this:</p>

<figure class="code">
<pre><code>function setCookie(name, value, { secure, path, domain, expires } = {}) {

    // ...
}
</code></pre>

</figure>

<p>This example provides a new object as the default value for the third parameter. Providing a default value for the destructured parameter means that the <code>secure</code>, <code>path</code>, <code>domain</code>, and <code>expires</code> will all be <code>undefined</code> if the third argument to <code>setCookie()</code> isn't provided, and no error will be thrown.</p>

<h4 id="leanpub-auto-default-values-for-destructured-parameters">Default Values for Destructured Parameters</h4>

<p>You can specify destructured default values for destructured parameters just as you would in destructured assignment. Just add the equals sign after the parameter and specify the default value. For example:</p>

<figure class="code">
<pre><code>function setCookie(name, value,
    {
        secure = false,
        path = "/",
        domain = "example.com",
        expires = new Date(Date.now() + 360000000)
    } = {}
) {

    // ...
}
</code></pre>

</figure>

<p>Each property in the destructured parameter has a default value in this code, so you can avoid checking to see if a given property has been included in order to use the correct value. Also, the entire destructured parameter has a default value of an empty object, making the parameter optional. This does make the function declaration look a bit more complicated than usual, but that's a small price to pay for ensuring each argument has a usable value.</p>

<h3 id="leanpub-auto-summary-4">Summary</h3>

<p>Destructuring makes working with objects and arrays in JavaScript easier. Using the familiar object literal and array literal syntax, you can pick data structures apart to get at just the information you're interested in. Object patterns allow you to extract data from objects while array patterns let you extract data from arrays.</p>

<p>Both object and array destructuring can specify default values for any property or item that is <code>undefined</code> and both throw errors when the right side of an assignment evaluates to <code>null</code> or <code>undefined</code>. You can also navigate deeply nested data structures with object and array destructuring, descending to any arbitrary depth.</p>

<p>Destructuring declarations use <code>var</code>, <code>let</code>, or <code>const</code> to create variables and must always have an initializer. Destructuring assignments are used in place of other assignments and allow you to destructure into object properties and already-existing variables.</p>

<p>Destructured parameters use the destructuring syntax to make "options" objects more transparent when used as function parameters. The actual data you're interested in can be listed out along with other named parameters. Destructured parameters can be array patterns, object patterns, or a mixture, and you can use all of the features of destructuring.</p>


<h2 id="leanpub-auto-symbols-and-symbol-properties">Symbols and Symbol Properties</h2>

<p>Symbols are a primitive type introduced in ECMAScript 6, joining the existing primitive types: strings, numbers, booleans, <code>null</code>, and <code>undefined</code>. Symbols began as a way to create private object members, a feature JavaScript developers wanted for a long time. Before symbols, any property with a string name was easy to access regardless of the obscurity of the name, and the "private names" feature was meant to let developers create non-string property names. That way, normal techniques for detecting these private names wouldn't work.</p>

<p>The private names proposal eventually evolved into ECMAScript 6 symbols, and this chapter will teach you how to use symbols effectively. While the implementation details remained the same (that is, they added non-string values for property names), the goal of privacy was dropped. Instead, symbol properties are categorized separately from other object properties.</p>

<h3 id="leanpub-auto-creating-symbols">Creating Symbols</h3>

<p>Symbols are unique among JavaScript primitives in that they don't have a literal form, like <code>true</code> for booleans or <code>42</code> for numbers. You can create a symbol by using the global <code>Symbol</code> function, as in this example:</p>

<figure class="code">
<pre><code>let firstName = Symbol();
let person = {};

person[firstName] = "Nicholas";
console.log(person[firstName]);     // "Nicholas"
</code></pre>

</figure>

<p>Here, the symbol <code>firstName</code> is created and used to assign a new property on the <code>person</code> object. That symbol must be used each time you want to access that same property. Naming the symbol variable appropriately is a good idea, so you can easily tell what the symbol represents.</p>

<aside class="warning blurb">
    <p>Because symbols are primitive values, calling <code>new Symbol()</code> throws an error when called. You can create an instance of <code>Symbol</code> via <code>new Object(yourSymbol)</code> as well, but it's unclear when this capability would be useful.</p>

</aside>

<p>The <code>Symbol</code> function also accepts an optional argument that is the description of the symbol. The description itself cannot be used to access the property, but is used for debugging purposes. For example:</p>

<figure class="code">
<pre><code>let firstName = Symbol("first name");
let person = {};

person[firstName] = "Nicholas";

console.log("first name" in person);        // false
console.log(person[firstName]);             // "Nicholas"
console.log(firstName);                     // "Symbol(first name)"
</code></pre>

</figure>

<p>A symbol's description is stored internally in the <code>[[Description]]</code> property. This property is read whenever the symbol's <code>toString()</code> method is called either explicitly or implicitly. The <code>firstName</code> symbol's <code>toString()</code> method is called implictly by <code>console.log()</code> in this example, so the description gets printed to the log. It is not otherwise possible to access <code>[[Description]]</code> directly from code. I recommended always providing a description to make both reading and debugging symbols easier.</p>

<aside>
  <h4 id="leanpub-auto-identifying-symbols">Identifying Symbols</h4>

  <p>Since symbols are primitive values, you can use the <code>typeof</code> operator to determine if a variable contains a symbol. ECMAScript 6 extends <code>typeof</code> to return <code>"symbol"</code> when used on a symbol. For example:</p>

  <figure class="code">
<pre><code>let symbol = Symbol("test symbol");
console.log(typeof symbol);         // "symbol"
</code></pre>

  </figure>

  <p>While there are other indirect ways of determining whether a variable is a symbol, the <code>typeof</code> operator is the most accurate and preferred technique.</p>

</aside>

<h3 id="leanpub-auto-using-symbols">Using Symbols</h3>

<p>You can use symbols anywhere you'd use a computed property name. You've already seen bracket notation used with symbols in this chapter, but you can use symbols in computed object literal property names as well as with <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code> calls, such as:</p>

<figure class="code">
<pre><code>let firstName = Symbol("first name");

// use a computed object literal property
let person = {
    [firstName]: "Nicholas"
};

// make the property read only
Object.defineProperty(person, firstName, { writable: false });

let lastName = Symbol("last name");

Object.defineProperties(person, {
    [lastName]: {
        value: "Zakas",
        writable: false
    }
});

console.log(person[firstName]);     // "Nicholas"
console.log(person[lastName]);      // "Zakas"
</code></pre>

</figure>

<p>This example first uses a computed object literal property to create the <code>firstName</code> symbol property. The following line then sets the property to be read-only. Later, a read-only <code>lastName</code> symbol property is created using the <code>Object.defineProperties()</code> method. A computed object literal property is used once again, but this time, it's part of the second argument to the <code>Object.defineProperties()</code> call.</p>

<p>While symbols can be used in any place that computed property names are allowed, you'll need to have a system for sharing these symbols between different pieces of code in order to use them effectively.</p>

<h3 id="leanpub-auto-sharing-symbols">Sharing Symbols</h3>

<p>You may find that you want different parts of your code to use the same symbols. For example, suppose you have two different object types in your application that should use the same symbol property to represent a unique identifier. Keeping track of symbols across files or large codebases can be difficult and error-prone. That's why ECMAScript 6 provides a global symbol registry that you can access at any point in time.</p>

<p>When you want to create a symbol to be shared, use the <code>Symbol.for()</code> method instead of calling the <code>Symbol()</code> method. The <code>Symbol.for()</code> method accepts a single parameter, which is a string identifier for the symbol you want to create. That parameter is also used as the symbol's description. For example:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid");
let object = {};

object[uid] = "12345";

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"
</code></pre>

</figure>

<p>The <code>Symbol.for()</code> method first searches the global symbol registry to see if a symbol with the key <code>"uid"</code> exists. If so, the method returns the existing symbol. If no such symbol exists, then a new symbol is created and registered to the global symbol registry using the specified key. The new symbol is then returned. That means subsequent calls to <code>Symbol.for()</code> using the same key will return the same symbol, as follows:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid");
let object = {
    [uid]: "12345"
};

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"

let uid2 = Symbol.for("uid");

console.log(uid === uid2);      // true
console.log(object[uid2]);      // "12345"
console.log(uid2);              // "Symbol(uid)"
</code></pre>

</figure>

<p>In this example, <code>uid</code> and <code>uid2</code> contain the same symbol and so they can be used interchangeably. The first call to <code>Symbol.for()</code> creates the symbol, and the second call retrieves the symbol from the global symbol registry.</p>

<p>Another unique aspect of shared symbols is that you can retrieve the key associated with a symbol in the global symbol registry by calling the <code>Symbol.keyFor()</code> method. For example:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid");
console.log(Symbol.keyFor(uid));    // "uid"

let uid2 = Symbol.for("uid");
console.log(Symbol.keyFor(uid2));   // "uid"

let uid3 = Symbol("uid");
console.log(Symbol.keyFor(uid3));   // undefined
</code></pre>

</figure>

<p>Notice that both <code>uid</code> and <code>uid2</code> return the <code>"uid"</code> key. The symbol <code>uid3</code> doesn't exist in the global symbol registry, so it has no key associated with it and <code>Symbol.keyFor()</code> returns <code>undefined</code>.</p>

<aside class="warning blurb">
    <p>The global symbol registry is a shared environment, just like the global scope. That means you can't make assumptions about what is or is not already present in that environment. Use namespacing of symbol keys to reduce the likelihood of naming collisions when using third-party components. For example, jQuery code might use <code>"jquery."</code> to prefix all keys, for keys like <code>"jquery.element"</code> or similar.</p>

</aside>

<h3 id="leanpub-auto-symbol-coercion">Symbol Coercion</h3>

<p>Type coercion is a significant part of JavaScript, and there's a lot of flexibility in the language's ability to coerce one data type into another. Symbols, however, are quite inflexible when it comes to coercion because other types lack a logical equivalent to a symbol. Specifically, symbols cannot be coerced into strings or numbers so that they cannot accidentally be used as properties that would otherwise be expected to behave as symbols.</p>

<p>The examples in this chapter have used <code>console.log()</code> to indicate the output for symbols, and that works because <code>console.log()</code> calls <code>String()</code> on symbols to create useful output. You can use <code>String()</code> directly to get the same result. For instance:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid"),
    desc = String(uid);

console.log(desc);              // "Symbol(uid)"
</code></pre>

</figure>

<p>The <code>String()</code> function calls <code>uid.toString()</code> and the symbol's string description is returned. If you try to concatenate the symbol directly with a string, however, an error will be thrown:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid"),
    desc = uid + "";            // error!
</code></pre>

</figure>

<p>Concatenating <code>uid</code> with an empty string requires that <code>uid</code> first be coerced into a string. An error is thrown when the coercion is detected, preventing its use in this manner.</p>

<p>Similarly, you cannot coerce a symbol to a number. All mathematical operators cause an error when applied to a symbol. For example:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid"),
    sum = uid / 1;            // error!
</code></pre>

</figure>

<p>This example attempts to divide the symbol by 1, which causes an error. Errors are thrown regardless of the mathematical operator used (logical operators do not throw an error because all symbols are considered equivalent to <code>true</code>, just like any other non-empty value in JavaScript).</p>

<h3 id="leanpub-auto-retrieving-symbol-properties">Retrieving Symbol Properties</h3>

<p>The <code>Object.keys()</code> and <code>Object.getOwnPropertyNames()</code> methods can retrieve all property names in an object. The former method returns all enumerable property names, and the latter returns all properties regardless of enumerability. Neither method returns symbol properties, however, to preserve their ECMAScript 5 functionality. Instead, the <code>Object.getOwnPropertySymbols()</code> method was added in ECMAScript 6 to allow you to retrieve property symbols from an object.</p>

<p>The return value of <code>Object.getOwnPropertySymbols()</code> is an array of own property symbols. For example:</p>

<figure class="code">
<pre><code>let uid = Symbol.for("uid");
let object = {
    [uid]: "12345"
};

let symbols = Object.getOwnPropertySymbols(object);

console.log(symbols.length);        // 1
console.log(symbols[0]);            // "Symbol(uid)"
console.log(object[symbols[0]]);    // "12345"
</code></pre>

</figure>

<p>In this code, <code>object</code> has a single symbol property called <code>uid</code>. The array returned from <code>Object.getOwnPropertySymbols()</code> is an array containing just that symbol.</p>

<p>All objects start with zero own symbol properties, but objects can inherit symbol properties from their prototypes. ECMAScript 6 predefines several such properties, implemented using what are called well-known symbols.</p>

<h3 id="leanpub-auto-exposing-internal-operations-with-well-known-symbols">Exposing Internal Operations with Well-Known Symbols</h3>

<p>A central theme for ECMAScript 5 was exposing and defining some of the "magic" parts of JavaScript, the parts that developers couldn't emulate at the time. ECMAScript 6 carries on that tradition by exposing even more of the previously internal logic of the language, primarily by using symbol prototype properties to define the basic behavior of certain objects.</p>

<p>ECMAScript 6 has predefined symbols called <em>well-known symbols</em> that represent common behaviors in JavaScript that were previously considered internal-only operations. Each well-known symbol is represented by a property on the <code>Symbol</code> object, such as <code>Symbol.create</code>.</p>

<p>The well-known symbols are:</p>

<ul>
  <li>
<code>Symbol.hasInstance</code> - A method used by <code>instanceof</code> to determine an object's inheritance.</li>
  <li>
<code>Symbol.isConcatSpreadable</code> - A Boolean value indicating that <code>Array.prototype.concat()</code> should flatten the collection's elements if the collection is passed as a parameter to <code>Array.prototype.concat()</code>.</li>
  <li>
<code>Symbol.iterator</code> - A method that returns an iterator. (Iterators are covered in Chapter 7.)</li>
  <li>
<code>Symbol.match</code> - A method used by <code>String.prototype.match()</code> to compare strings.</li>
  <li>
<code>Symbol.replace</code> - A method used by <code>String.prototype.replace()</code> to replace substrings.</li>
  <li>
<code>Symbol.search</code> - A method used by <code>String.prototype.search()</code> to locate substrings.</li>
  <li>
<code>Symbol.species</code> - The constructor for making derived objects. (Derived objects are covered in Chapter 8.)</li>
  <li>
<code>Symbol.split</code> - A method used by <code>String.prototype.split()</code> to split up strings.</li>
  <li>
<code>Symbol.toPrimitive</code> - A method that returns a primitive value representation of an object.</li>
  <li>
<code>Symbol.toStringTag</code> - A string used by <code>Object.prototype.toString()</code> to create an object description.</li>
  <li>
<code>Symbol.unscopables</code> - An object whose properties are the names of object properties that should not be included in a <code>with</code> statement.</li>
</ul>

<p>Some commonly used well-known symbols are discussed in the following sections, while others are discussed throughout the rest of the book to keep them in the correct context.</p>

<aside class="information blurb">
    <p>Overwriting a method defined with a well-known symbol changes an ordinary object to an exotic object because this changes some internal default behavior. There is no practical impact to your code as a result, it just changes the way the specification describes the object.</p>

</aside>

<h4 id="leanpub-auto-the-symbolhasinstance-property">The Symbol.hasInstance Property</h4>

<p>Every function has a <code>Symbol.hasInstance</code> method that determines whether or not a given object is an instance of that function. The method is defined on <code>Function.prototype</code> so that all functions inherit the default behavior for the <code>instanceof</code> property and the method is nonwritable and nonconfigurable as well as nonenumerable, to ensure it doesn't get overwritten by mistake.</p>

<p>The <code>Symbol.hasInstance</code> method accepts a single argument: the value to check. It returns true if the value passed is an instance of the function. To understand how <code>Symbol.hasInstance</code> works, consider the following code:</p>

<figure class="code">
<pre><code>obj instanceof Array;
</code></pre>

</figure>

<p>This code is equivalent to:</p>

<figure class="code">
<pre><code>Array[Symbol.hasInstance](obj);
</code></pre>

</figure>

<p>ECMAScript 6 essentially redefined the <code>instanceof</code> operator as shorthand syntax for this method call. And now that there's a method call involved, you can actually change how <code>instanceof</code> works.</p>

<p>For instance, suppose you want to define a function that claims no object as an instance. You can do so by hardcoding the return value of <code>Symbol.hasInstance</code> to <code>false</code>, such as:</p>

<figure class="code">
<pre><code>function MyObject() {
    // ...
}

Object.defineProperty(MyObject, Symbol.hasInstance, {
    value: function(v) {
        return false;
    }
});

let obj = new MyObject();

console.log(obj instanceof MyObject);       // false
</code></pre>

</figure>

<p>You must use <code>Object.defineProperty()</code> to overwrite a nonwritable property, so this example uses that method to overwrite the <code>Symbol.hasInstance</code> method with a new function. The new function always returns <code>false</code>, so even though <code>obj</code> is actually an instance of the <code>MyObject</code> class, the <code>instanceof</code> operator returns <code>false</code> after the <code>Object.defineProperty()</code> call.</p>

<p>Of course, you can also inspect the value and decide whether or not a value should be considered an instance based on any arbitrary condition. For instance, maybe numbers with values between 1 and 100 are to be considered instances of a special number type. To achieve that behavior, you might write code like this:</p>

<figure class="code">
<pre><code>function SpecialNumber() {
    // empty
}

Object.defineProperty(SpecialNumber, Symbol.hasInstance, {
    value: function(v) {
        return (v instanceof Number) &amp;&amp; (v &gt;=1 &amp;&amp; v &lt;= 100);
    }
});

let two = new Number(2),
    zero = new Number(0);

console.log(two instanceof SpecialNumber);    // true
console.log(zero instanceof SpecialNumber);   // false
</code></pre>

</figure>

<p>This code defines a <code>Symbol.hasInstance</code> method that returns <code>true</code> if the value is an instance of <code>Number</code> and also has a value between 1 and 100. Thus, <code>SpecialNumber</code> will claim <code>two</code> as an instance even though there is no directly defined relationship between the <code>SpecialNumber</code> function and the <code>two</code> variable. Note that the left operand to <code>instanceof</code> must be an object to trigger the <code>Symbol.hasInstance</code> call, as nonobjects cause <code>instanceof</code> to simply return <code>false</code> all the time.</p>

<aside class="warning blurb">
    <p>You can also overwrite the default <code>Symbol.hasInstance</code> property for all builtin functions such as the <code>Date</code> and <code>Error</code> functions. This isn't recommended, however, as the effects on your code can be unexpected and confusing. It's a good idea to only overwrite <code>Symbol.hasInstance</code> on your own functions and only when necessary.</p>

</aside>

<h4 id="leanpub-auto-the-symbolisconcatspreadable-symbol">The Symbol.isConcatSpreadable Symbol</h4>

<p>JavaScript arrays have a <code>concat()</code> method designed to concatenate two arrays together. Here's how that method is used:</p>

<figure class="code">
<pre><code>let colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ]);

console.log(colors2.length);    // 4
console.log(colors2);           // ["red","green","blue","black"]
</code></pre>

</figure>

<p>This code concatenates a new array to the end of <code>colors1</code> and creates <code>colors2</code>, a single array with all items from both arrays. However, the <code>concat()</code> method can also accept nonarray arguments and, in that case, those arguments are simply added to the end of the array. For example:</p>

<figure class="code">
<pre><code>let colors1 = [ "red", "green" ],
    colors2 = colors1.concat([ "blue", "black" ], "brown");

console.log(colors2.length);    // 5
console.log(colors2);           // ["red","green","blue","black","brown"]
</code></pre>

</figure>

<p>Here, the extra argument <code>"brown"</code> is passed to <code>concat()</code> and it becomes the fifth item in the <code>colors2</code> array. Why is an array argument treated differently than a string argument? The JavaScript specification says that arrays are automatically split into their individual items and all other types are not. Prior to ECMAScript 6, there was no way to adjust this behavior.</p>

<p>The <code>Symbol.isConcatSpreadable</code> property is a boolean value indicating that an object has a <code>length</code> property and numeric keys, and that its numeric property values should be added individually to the result of a <code>concat()</code> call. Unlike other well-known symbols, this symbol property doesn't appear on any standard objects by default. Instead, the symbol is available as a way to augment how <code>concat()</code> works on certain types of objects, effectively short-circuiting the default behavior. You can define any type to behave like arrays do in a <code>concat()</code> call, like this:</p>

<figure class="code">
<pre><code>let collection = {
    0: "Hello",
    1: "world",
    length: 2,
    [Symbol.isConcatSpreadable]: true
};

let messages = [ "Hi" ].concat(collection);

console.log(messages.length);    // 3
console.log(messages);           // ["Hi","Hello","world"]
</code></pre>

</figure>

<p>The <code>collection</code> object in this example is set up to look like an array: it has a <code>length</code> property and two numeric keys. The <code>Symbol.isConcatSpreadable</code> property is set to <code>true</code> to indicate that the property values should be added as individual items to an array. When <code>collection</code> is passed to the <code>concat()</code> method, the resulting array has <code>"Hello"</code> and <code>"world"</code> as separate items after the <code>"Hi"</code> element.</p>

<aside class="information blurb">
    <p>You can also set <code>Symbol.isConcatSpreadable</code> to <code>false</code> on array subclasses to prevent items from being separated by <code>concat()</code> calls. Subclassing is discussed in Chapter 8.</p>

</aside>

<h4 id="leanpub-auto-the-symbolmatch-symbolreplace-symbolsearch-and-symbolsplit-symbols">The Symbol.match, Symbol.replace, Symbol.search, and Symbol.split Symbols</h4>

<p>Strings and regular expressions have always had a close relationship in JavaScript. The string type, in particular, has several methods that accept regular expressions as arguments:</p>

<ul>
  <li>
<code>match(regex)</code> - Determines whether the given string matches a regular expression</li>
  <li>
<code>replace(regex, replacement)</code> - Replaces regular expression matches with a <code>replacement</code>
</li>
  <li>
<code>search(regex)</code> - Locates a regular expression match inside the string</li>
  <li>
<code>split(regex)</code> - Splits a string into an array on a regular expression match</li>
</ul>

<p>Prior to ECMAScript 6, the way these methods interacted with regular expressions was hidden from developers, leaving no way to mimic regular expressions using developer-defined objects. ECMAScript 6 defines four symbols that correspond to these four methods, effectively outsourcing the native behavior to the <code>RegExp</code> builtin object.</p>

<p>The <code>Symbol.match</code>, <code>Symbol.replace</code>, <code>Symbol.search</code>, and <code>Symbol.split</code> symbols represent methods on the regular expression argument that should be called on the first argument to the <code>match()</code> method, the <code>replace()</code> method, the <code>search()</code> method, and the <code>split()</code> method, respectively. The four symbol properties are defined on <code>RegExp.prototype</code> as the default implementation that the string methods should use.</p>

<p>Knowing this, you can create an object to use with the string methods in a way that is similar to regular expressions. To do, you can use the following symbol functions in code:</p>

<ul>
  <li>
<code>Symbol.match</code> - A function that accepts a string argument and returns an array of matches, or <code>null</code> if no match is found.</li>
  <li>
<code>Symbol.replace</code> - A function that accepts a string argument and a replacement string, and returns a string.</li>
  <li>
<code>Symbol.search</code> - A function that accepts a string argument and returns the numeric index of the match, or -1 if no match is found.</li>
  <li>
<code>Symbol.split</code> - A function that accepts a string argument and returns an array containing pieces of the string split on the match.</li>
</ul>

<p>The ability to define these properties on an object allows you to create objects that implement pattern matching without regular expressions and use them in methods that expect regular expressions. Here's an example that shows these symbols in action:</p>

<figure class="code">
<pre><code>// effectively equivalent to /^.{10}$/
let hasLengthOf10 = {
    [Symbol.match]: function(value) {
        return value.length === 10 ? [value] : null;
    },
    [Symbol.replace]: function(value, replacement) {
        return value.length === 10 ? replacement : value;
    },
    [Symbol.search]: function(value) {
        return value.length === 10 ? 0 : -1;
    },
    [Symbol.split]: function(value) {
        return value.length === 10 ? ["", ""] : [value];
    }
};

let message1 = "Hello world",   // 11 characters
    message2 = "Hello John";    // 10 characters


let match1 = message1.match(hasLengthOf10),
    match2 = message2.match(hasLengthOf10);

console.log(match1);            // null
console.log(match2);            // ["Hello John"]

let replace1 = message1.replace(hasLengthOf10, "Howdy!"),
    replace2 = message2.replace(hasLengthOf10, "Howdy!");

console.log(replace1);          // "Hello world"
console.log(replace2);          // "Howdy!"

let search1 = message1.search(hasLengthOf10),
    search2 = message2.search(hasLengthOf10);

console.log(search1);           // -1
console.log(search2);           // 0

let split1 = message1.split(hasLengthOf10),
    split2 = message2.split(hasLengthOf10);

console.log(split1);            // ["Hello world"]
console.log(split2);            // ["", ""]
</code></pre>

</figure>

<p>The <code>hasLengthOf10</code> object is intended to work like a regular expression that matches whenever the string length is exactly 10. Each of the four methods on <code>hasLengthOf10</code> is implemented using the appropriate symbol, and then the corresponding methods on two strings are called. The first string, <code>message1</code>, has 11 characters and so it will not match; the second string, <code>message2</code>, has 10 characters and so it will match. Despite not being a regular expression, <code>hasLengthOf10</code> is passed to each string method and used correctly due to the additional methods.</p>

<p>While this is a simple example, the ability to perform more complex matches than are currently possible with regular expressions opens up a lot of possibilities for custom pattern matchers.</p>

<h4 id="leanpub-auto-the-symboltoprimitive-method">The Symbol.toPrimitive Method</h4>

<p>JavaScript frequently attempts to convert objects into primitive values implicitly when certain operations are applied. For instance, when you compare a string to an object using the double equals (<code>==</code>) operator, the object is converted into a primitive value before comparing. Exactly what primitive value should be used was previously an internal operation, but ECMAScript 6 exposes that value (making it changeable) through the <code>Symbol.toPrimitive</code> method.</p>

<p>The <code>Symbol.toPrimitive</code> method is defined on the prototype of each standard type and prescribes what should happen when the object is converted into a primitive. When a primitive conversion is needed, <code>Symbol.toPrimitive</code> is called with a single argument, referred to as <code>hint</code> in the specification. The <code>hint</code> argument is one of three string values. If <code>hint</code> is <code>"number"</code> then <code>Symbol.toPrimitive</code> should return a number. If <code>hint</code> is <code>"string"</code> then a string should be returned, and if it's <code>"default"</code> then the operation has no preference as to the type.</p>

<p>For most standard objects, number mode has the following behaviors, in order by priority:</p>

<ol class="numeric">
  <li>Call the <code>valueOf()</code> method, and if the result is a primitive value, return it.</li>
  <li>Otherwise, call the <code>toString()</code> method, and if the result is a primitive value, return it.</li>
  <li>Otherwise, throw an error.</li>
</ol>

<p>Similarly, for most standard objects, the behaviors of string mode have the following priority:</p>

<ol class="numeric">
  <li>Call the <code>toString()</code> method, and if the result is a primitive value, return it.</li>
  <li>Otherwise, call the <code>valueOf()</code> method, and if the result is a primitive value, return it.</li>
  <li>Otherwise, throw an error.</li>
</ol>

<p>In many cases, standard objects treat default mode as equivalent to number mode (except for <code>Date</code>, which treats default mode as equivalent to string mode). By defining an <code>Symbol.toPrimitive</code> method, you can override these default coercion behaviors.</p>

<aside class="information blurb">
    <p>Default mode is only used for the <code>==</code> operator, the <code>+</code> operator, and when passing a single argument to the <code>Date</code> constructor. Most operations use string or number mode.</p>

</aside>

<p>To override the default conversion behaviors, use <code>Symbol.toPrimitive</code> and assign a function as its value. For example:</p>

<figure class="code">
<pre><code>function Temperature(degrees) {
    this.degrees = degrees;
}

Temperature.prototype[Symbol.toPrimitive] = function(hint) {

    switch (hint) {
        case "string":
            return this.degrees + "\u00b0"; // degrees symbol

        case "number":
            return this.degrees;

        case "default":
            return this.degrees + " degrees";
    }
};

let freezing = new Temperature(32);

console.log(freezing + "!");            // "32 degrees!"
console.log(freezing / 2);              // 16
console.log(String(freezing));          // "32째"
</code></pre>

</figure>

<p>This script defines a <code>Temperature</code> constructor and overrides the default <code>Symbol.toPrimitive</code> method on the prototype. A different value is returned depending on whether the <code>hint</code> argument indicates string, number, or default mode (the <code>hint</code> argument is filled in by the JavaScript engine). In string mode, the <code>Symbol.toPrimitive</code> method returns the temperature with the Unicode degrees symbol. In number mode, it returns just the numeric value, and in default mode, it appends the word "degrees" after the number.</p>

<p>Each of the log statements triggers a different <code>hint</code> argument value. The <code>+</code> operator triggers default mode by setting <code>hint</code> to <code>"default"</code>, the <code>/</code> operator triggers number mode by setting <code>hint</code> to <code>"number"</code>, and the <code>String()</code> function triggers string mode by setting <code>hint</code> to <code>"string"</code>. Returning different values for all three modes is possible, it's much more common to set the default mode to be the same as string or number mode.</p>

<h4 id="leanpub-auto-the-symboltostringtag-symbol">The Symbol.toStringTag Symbol</h4>

<p>One of the most interesting problems in JavaScript has been the availability of multiple global execution environments. This occurs in web browsers when a page includes an iframe, as the page and the iframe each have their own execution environments. In most cases, this isn't a problem, as data can be passed back and forth between the environments with little cause for concern. The problem arises when trying to identify what type of object you're dealing with after the object has been passed between different objects.</p>

<p>The canonical example of this issue is passing an array from an iframe into the containing page or vice-versa. In ECMAScript 6 terminology, the iframe and the containing page each represent a different <em>realm</em> which is an execution environment for JavaScript. Each realm has its own global scope with its own copy of global objects. In whichever realm the array is created, it is definitely an array. When it's passed to a different realm, however, an <code>instanceof Array</code> call returns <code>false</code> because the array was created with a constructor from a different realm and <code>Array</code> represents the constructor in the current realm.</p>

<h5 id="leanpub-auto-a-workaround-for-the-identification-problem">A Workaround for the Identification Problem</h5>

<p>Faced with this problem, developers soon found a good way to identify arrays. They discovered that by calling the standard <code>toString()</code> method on the object, a predictable string was always returned. Thus, many JavaScript libraries began including a function like this:</p>

<figure class="code">
<pre><code>function isArray(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
}

console.log(isArray([]));   // true
</code></pre>

</figure>

<p>This may look a bit roundabout, but it worked quite well for identifying arrays in all browsers. The <code>toString()</code> method on arrays isn't useful for identifying an object because it returns a string representation of the items the object contains. But the <code>toString()</code> method on <code>Object.prototype</code> had a quirk: it included internally-defined name called <code>[[Class]]</code> in the returned result. Developers could use this method on an object to retrieve what the JavaScript environment thought the object's data type was.</p>

<p>Developers quickly realized that since there was no way to change this behavior, it was possible to use the same approach to distinguish between native objects and those created by developers. The most important case of this was the ECMAScript 5 <code>JSON</code> object.</p>

<p>Prior to ECMAScript 5, many developers used Douglas Crockford's <em>json2.js</em>, which creates a global <code>JSON</code> object. As browsers started to implement the <code>JSON</code> global object, figuring out whether the global <code>JSON</code> was provided by the JavaScript environment itself or through some other library became necessary. Using the same technique I showed with the <code>isArray()</code> function, many developers created functions like this:</p>

<figure class="code">
<pre><code>function supportsNativeJSON() {
    return typeof JSON !== "undefined" &amp;&amp;
        Object.prototype.toString.call(JSON) === "[object JSON]";
}
</code></pre>

</figure>

<p>The same characteristic of <code>Object.prototype</code> that allowed developers to identify arrays across iframe boundaries also provided a way to tell if <code>JSON</code> was the native <code>JSON</code> object or not. A non-native <code>JSON</code> object would return <code>[object Object]</code> while the native version returned <code>[object JSON]</code> instead. This approach became the de facto standard for identifying native objects.</p>

<h5 id="leanpub-auto-the-ecmascript-6-answer">The ECMAScript 6 Answer</h5>

<p>ECMAScript 6 redefines this behavior through the <code>Symbol.toStringTag</code> symbol. This symbol represents a property on each object that defines what value should be produced when <code>Object.prototype.toString.call()</code> is called on it. For an array, the value that function returns is explained by storing <code>"Array"</code> in the <code>Symbol.toStringTag</code> property.</p>

<p>Likewise, you can define the <code>Symbol.toStringTag</code> value for your own objects:</p>

<figure class="code">
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

let me = new Person("Nicholas");

console.log(me.toString());                         // "[object Person]"
console.log(Object.prototype.toString.call(me));    // "[object Person]"
</code></pre>

</figure>

<p>In this example, a <code>Symbol.toStringTag</code> property is defined on <code>Person.prototype</code> to provide the default behavior for creating a string representation. Since <code>Person.prototype</code> inherits the <code>Object.prototype.toString()</code> method, the value returned from <code>Symbol.toStringTag</code> is also used when calling the <code>me.toString()</code> method. However, you can still define your own <code>toString()</code> method that provides a different behavior without affecting the use of the <code>Object.prototype.toString.call()</code> method. Here's how that might look:</p>

<figure class="code">
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = "Person";

Person.prototype.toString = function() {
    return this.name;
};

let me = new Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(Object.prototype.toString.call(me));    // "[object Person]"
</code></pre>

</figure>

<p>This code defines <code>Person.prototype.toString()</code> to return the value of the <code>name</code> property. Since <code>Person</code> instances no longer inherit the <code>Object.prototype.toString()</code> method, calling <code>me.toString()</code> exhibits a different behavior.</p>

<aside class="information blurb">
    <p>All objects inherit <code>Symbol.toStringTag</code> from <code>Object.prototype</code> unless otherwise specified. The string <code>"Object"</code> is the default property value.</p>

</aside>

<p>There is no restriction on which values can be used for <code>Symbol.toStringTag</code> on developer-defined objects. For example, nothing prevents you from using <code>"Array"</code> as the value of the <code>Symbol.toStringTag</code> property, such as:</p>

<figure class="code">
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = "Array";

Person.prototype.toString = function() {
    return this.name;
};

let me = new Person("Nicholas");

console.log(me.toString());                         // "Nicholas"
console.log(Object.prototype.toString.call(me));    // "[object Array]"
</code></pre>

</figure>

<p>The result of calling <code>Object.prototype.toString()</code> is <code>"[object Array]"</code> in this code, which is the same result you'd get from an actual array. This highlights the fact that <code>Object.prototype.toString()</code> is no longer a completely reliable way of identifying an object's type.</p>

<p>Changing the string tag for native objects is also possible. Just assign to <code>Symbol.toStringTag</code> on the object's prototype, like this:</p>

<figure class="code">
<pre><code>Array.prototype[Symbol.toStringTag] = "Magic";

let values = [];

console.log(Object.prototype.toString.call(values));    // "[object Magic]"
</code></pre>

</figure>

<p>Even though <code>Symbol.toStringTag</code> is overwritten for arrays in this example, the call to <code>Object.prototype.toString()</code> results in <code>"[object Magic]"</code> instead. While I recommended not changing built-in objects in this way, there's nothing in the language that forbids doing so.</p>

<h4 id="leanpub-auto-the-symbolunscopables-symbol">The Symbol.unscopables Symbol</h4>

<p>The <code>with</code> statement is one of the most controversial parts of JavaScript. Originally designed to avoid repetitive typing, the <code>with</code> statement later became roundly criticized for making code harder to understand and for negative performance implications as well as being error-prone.</p>

<p>As a result, the <code>with</code> statement is not allowed in strict mode; that restriction also affects classes and modules, which are strict mode by default and have no opt-out.</p>

<p>While future code will undoubtedly not use the <code>with</code> statement, ECMAScript 6 still supports <code>with</code> in nonstrict mode for backwards compatibility and, as such, had to find ways to allow code that does use <code>with</code> to continue to work properly.</p>

<p>To understand the complexity of this task, consider the following code:</p>

<figure class="code">
<pre><code>let values = [1, 2, 3],
    colors = ["red", "green", "blue"],
    color = "black";

with(colors) {
    push(color);
    push(...values);
}

console.log(colors);    // ["red", "green", "blue", "black", 1, 2, 3]
</code></pre>

</figure>

<p>In this example, the two calls to <code>push()</code> inside the <code>with</code> statement are equivalent to <code>colors.push()</code> because the <code>with</code> statement added <code>push</code> as a local binding. The <code>color</code> reference refers to the variable created outside the <code>with</code> statement, as does the <code>values</code> reference.</p>

<p>But ECMAScript 6 added a <code>values</code> method to arrays. (The <code>values</code> method is discussed in detail in Chapter 7, "Iterators and Generators.") That would mean in an ECMAScript 6 environment, the <code>values</code> reference inside the <code>with</code> statement should refer not to the local variable <code>values</code>, but to the array's <code>values</code> method, which would break the code. This is why the <code>Symbol.unscopables</code> symbol exists.</p>

<p>The <code>Symbol.unscopables</code> symbol is used on <code>Array.prototype</code> to indicate which properties shouldn't create bindings inside of a <code>with</code> statement. When present, <code>Symbol.unscopables</code> is an object whose keys are the identifiers to omit from <code>with</code> statement bindings and whose values are <code>true</code> to enforce the block. Here's the default <code>Symbol.unscopables</code> property for arrays:</p>

<figure class="code">
<pre><code>// built into ECMAScript 6 by default
Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null), {
    copyWithin: true,
    entries: true,
    fill: true,
    find: true,
    findIndex: true,
    keys: true,
    values: true
});
</code></pre>

</figure>

<p>The <code>Symbol.unscopables</code> object has a <code>null</code> prototype, which is created by the <code>Object.create(null)</code> call, and contains all of the new array methods in ECMAScript 6. (These methods are covered in detail in Chapter 7, "Iterators and Generators," and Chapter 9, "Arrays.") Bindings for these methods are not created inside a <code>with</code> statement, allowing old code to continue working without any problem.</p>

<p>In general, you shouldn't need to define <code>Symbol.unscopables</code> for your objects unless you use the <code>with</code> statement and are making changes to an existing object in your code base.</p>

<h3 id="leanpub-auto-summary-5">Summary</h3>

<p>Symbols are a new type of primitive value in JavaScript and are used to create properties that can't be accessed without referencing the symbol.</p>

<p>While not truly private, these properties are harder to accidentally change or overwrite and are therefore suitable for functionality that needs a level of protection from developers.</p>

<p>You can provide descriptions for symbols that allow for easier identification of symbol values. There is a global symbol registry that allows you to use shared symbols in different parts of code by using the same description. In this way, the same symbol can be used for the same reason in multiple places.</p>

<p>Methods like <code>Object.keys()</code> or <code>Object.getOwnPropertyNames()</code> don't return symbols, so a new method called <code>Object.getOwnPropertySymbols()</code> was added in ECMAScript 6 to allow retrieval of symbol properties. You can still make changes to symbol properties by calling the <code>Object.defineProperty()</code> and <code>Object.defineProperties()</code> methods.</p>

<p>Well-known symbols define previously internal-only functionality for standard objects and use globally-available symbol constants, such as the <code>Symbol.hasInstance</code> property. These symbols use the prefix <code>Symbol.</code> in the specification and allow developers to modify standard object behavior in a variety of ways.</p>


<h2 id="leanpub-auto-sets-and-maps">Sets and Maps</h2>

<p>JavaScript only had one type of collection, represented by the <code>Array</code> type, for most of its history (though some may argue all non-array objects are just collections of key-value pairs, their intended use was, originally quite different from arrays). Arrays are used in JavaScript just like arrays in other languages, but the lack of other collection options meant arrays were often used as queues and stacks, as well. Since arrays only use numeric indices, developers used non-array objects whenever a non-numeric index was necessary. That technique led to custom implementations of sets and maps using non-array objects.</p>

<p>A <em>set</em> is a list of values that cannot contain duplicates. You typically don't access individual items in a set like you would items in an array; instead, it's much more common to just check a set to see if a value is present. A <em>map</em> is a collection of keys that correspond to specific values. As such, each item in a map stores two pieces of data, and values are retrieved by specifying the key to read from. Maps are frequently used as caches, for storing data to be quickly retrieved later. While ECMAScript 5 didn't formally have sets and maps, developers worked around this limitation using non-array objects, too.</p>

<p>ECMAScript 6 added sets and maps to JavaScript, and this chapter discusses everything you need to know about these two collection types.</p>

<p>First, I will discuss the workarounds developers used to implement sets and maps before ECMAScript 6, and why those implementations were problematic. After that important background information, I will cover how sets and maps work in ECMAScript 6.</p>

<h3 id="leanpub-auto-sets-and-maps-in-ecmascript-5">Sets and Maps in ECMAScript 5</h3>

<p>In ECMAScript 5, developers mimicked sets and maps by using object properties, like this:</p>

<figure class="code">
<pre><code>let set = Object.create(null);

set.foo = true;

// checking for existence
if (set.foo) {

    // do something
}
</code></pre>

</figure>

<p>The <code>set</code> variable in this example is an object with a <code>null</code> prototype, ensuring that there are no inherited properties on the object. Using object properties as unique values to be checked is a common approach in ECMAScript 5. When a property is added to the <code>set</code> object, it is set to <code>true</code> so conditional statements (such as the <code>if</code> statement in this example) can easily check whether the value is present.</p>

<p>The only real difference between an object used as a set and an object used as a map is the value being stored. For instance, this example uses an object as a map:</p>

<figure class="code">
<pre><code>let map = Object.create(null);

map.foo = "bar";

// retrieving a value
let value = map.foo;

console.log(value);         // "bar"
</code></pre>

</figure>

<p>This code stores a string value <code>"bar"</code> under the key <code>foo</code>. Unlike sets, maps are mostly used to retrieve information, rather than just checking for the key's existence.</p>

<h3 id="leanpub-auto-problems-with-workarounds">Problems with Workarounds</h3>

<p>While using objects as sets and maps works okay in simple situations, the approach can get more complicated once you run into the limitations of object properties. For example, since all object properties must be strings, you must be certain no two keys evaluate to the same string. Consider the following:</p>

<figure class="code">
<pre><code>let map = Object.create(null);

map[5] = "foo";

console.log(map["5"]);      // "foo"
</code></pre>

</figure>

<p>This example assigns the string value <code>"foo"</code> to a numeric key of <code>5</code>. Internally, that numeric value is converted to a string, so <code>map["5"]</code> and <code>map[5]</code> actually reference the same property. That internal conversion can cause problems when you want to use both numbers and strings as keys. Another problem arises when using objects as keys, like this:</p>

<figure class="code">
<pre><code>let map = Object.create(null),
    key1 = {},
    key2 = {};

map[key1] = "foo";

console.log(map[key2]);     // "foo"
</code></pre>

</figure>

<p>Here, <code>map[key2]</code> and <code>map[key1]</code> reference the same value. The objects <code>key1</code> and <code>key2</code> are converted to strings because object properties must be strings. Since <code>"[object Object]"</code> is the default string representation for objects, both <code>key1</code> and <code>key2</code> are converted to that string. This can cause errors that may not be obvious because it's logical to assume that different object keys would, in fact, be different.</p>

<p>The conversion to the default string representation makes it difficult to use objects as keys. (The same problem exists when trying to use an object as a set.)</p>

<p>Maps with a key whose value is falsy present their own particular problem, too. A falsy value is automatically converted to false when used in situations where a boolean value is required, such as in the condition of an <code>if</code> statement. This conversion alone isn't a problem–so long as you're careful as to how you use values. For instance, look at this code:</p>

<figure class="code">
<pre><code>let map = Object.create(null);

map.count = 1;

// checking for the existence of "count" or a nonzero value?
if (map.count) {
    // ...
}
</code></pre>

</figure>

<p>This example has some ambiguity as to how <code>map.count</code> should be used. Is the <code>if</code> statement intended to check for the existence of <code>map.count</code> or that the value is nonzero? The code inside the <code>if</code> statement will execute because the value 1 is truthy. However, if <code>map.count</code> is 0, or if <code>map.count</code> doesn't exist, the code inside the <code>if</code> statement would not be executed.</p>

<p>These are difficult problems to identify and debug when they occur in large applications, which is a prime reason that ECMAScript 6 adds both sets and maps to the language.</p>

<aside class="information blurb">
    <p>JavaScript has the <code>in</code> operator that returns <code>true</code> if a property exists in an object without reading the value of the object. However, the <code>in</code> operator also searches the prototype of an object, which makes it only safe to use when an object has a <code>null</code> prototype. Even so, many developers still incorrectly use code as in the last example rather than using <code>in</code>.</p>

</aside>

<h3 id="leanpub-auto-sets-in-ecmascript-6">Sets in ECMAScript 6</h3>

<p>ECMAScript 6 adds a <code>Set</code> type that is an ordered list of values without duplicates. Sets allow fast access to the data they contain, adding a more efficient manner of tracking discrete values.</p>

<h4 id="leanpub-auto-creating-sets-and-adding-items">Creating Sets and Adding Items</h4>

<p>Sets are created using <code>new Set()</code> and items are added to a set by calling the <code>add()</code> method. You can see how many items are in a set by checking the <code>size</code> property:</p>

<figure class="code">
<pre><code>let set = new Set();
set.add(5);
set.add("5");

console.log(set.size);    // 2
</code></pre>

</figure>

<p>Sets do not coerce values to determine whether they are the same. That means a set can contain both the number <code>5</code> and the string <code>"5"</code> as two separate items. (The only exception is that -0 and +0 are considered to be the same.) You can also add multiple objects to the set, and those objects will remain distinct:</p>

<figure class="code">
<pre><code>let set = new Set(),
    key1 = {},
    key2 = {};

set.add(key1);
set.add(key2);

console.log(set.size);    // 2
</code></pre>

</figure>

<p>Because <code>key1</code> and <code>key2</code> are not converted to strings, they count as two unique items in the set. (Remember, if they were converted to strings, they would both be equal to <code>"[Object object]"</code>.)</p>

<p>If the <code>add()</code> method is called more than once with the same value, all calls after the first one are effectively ignored:</p>

<figure class="code">
<pre><code>let set = new Set();
set.add(5);
set.add("5");
set.add(5);     // duplicate - this is ignored

console.log(set.size);    // 2
</code></pre>

</figure>

<p>You can initialize a set using an array, and the <code>Set</code> constructor will ensure that only unique values are used. For instance:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
console.log(set.size);    // 5
</code></pre>

</figure>

<p>In this example, an array with duplicate values is used to initialize the set. The number <code>5</code> only appears once in the set even though it appears four times in the array. This functionality makes converting existing code or JSON structures to use sets easy.</p>

<aside class="information blurb">
    <p>The <code>Set</code> constructor actually accepts any iterable object as an argument. Arrays work because they are iterable by default, as are sets and maps. The <code>Set</code> constructor uses an iterator to extract values from the argument. (Iterables and iterators are discussed in detail in Chapter 8.)</p>

</aside>

<p>You can test which values are in a set using the <code>has()</code> method, like this:</p>

<figure class="code">
<pre><code>let set = new Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true
console.log(set.has(6));    // false
</code></pre>

</figure>

<p>Here, <code>set.has(6)</code> would return false because the set doesn't have that value.</p>

<h4 id="leanpub-auto-removing-values">Removing Values</h4>

<p>It's also possible to remove values from a set. You can remove single value by using the <code>delete()</code> method, or you can remove all values from the set by calling the <code>clear()</code> method. This code shows both in action:</p>

<figure class="code">
<pre><code>let set = new Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true

set.delete(5);

console.log(set.has(5));    // false
console.log(set.size);      // 1

set.clear();

console.log(set.has("5"));  // false
console.log(set.size);      // 0
</code></pre>

</figure>

<p>After the <code>delete()</code> call, only <code>5</code> is gone; after the <code>clear()</code> method executes, <code>set</code> is empty.</p>

<p>All of this amounts to a very easy mechanism for tracking unique ordered values. However, what if you want to add items to a set and then perform some operation on each item? That's where the <code>forEach()</code> method comes in.</p>

<h4 id="leanpub-auto-the-foreach-method-for-sets">The forEach() Method for Sets</h4>

<p>If you're used to working with arrays, then you may already be familiar with the <code>forEach()</code> method. ECMAScript 5 added <code>forEach()</code> to arrays to make working on each item in an array without setting up a <code>for</code> loop easier. The method proved popular among developers, and so the same method is available on sets and works the same way.</p>

<p>The <code>forEach()</code> method is passed a callback function that accepts three arguments:</p>

<ol class="numeric">
  <li>The value from the next position in the set</li>
  <li>The same value as the first argument</li>
  <li>The set from which the value is read</li>
</ol>

<p>The strange difference between the set version of <code>forEach()</code> and the array version is that the first and second arguments to the callback function are the same. While this might look like a mistake, there's a good reason for the behavior.</p>

<p>The other objects that have <code>forEach()</code> methods (arrays and maps) pass three arguments to their callback functions. The first two arguments for arrays and maps are the value and the key (the numeric index for arrays).</p>

<p>Sets do not have keys, however. The people behind the ECMAScript 6 standard could have made the callback function in the set version of <code>forEach()</code> accept two arguments, but that would have made it different from the other two. Instead, they found a way to keep the callback function the same and accept three arguments: each value in a set is considered to be both the key and the value. As such, the first and second argument are always the same in <code>forEach()</code> on sets to keep this functionality consistent with the other <code>forEach()</code> methods on arrays and maps.</p>

<p>Other than the difference in arguments, using <code>forEach()</code> is basically the same for a set as it is for an array. Here's some code that shows the method at work:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2]);

set.forEach(function(value, key, ownerSet) {
    console.log(key + " " + value);
    console.log(ownerSet === set);
});
</code></pre>

</figure>

<p>This code iterates over each item in the set and outputs the values passed to the <code>forEach()</code> callback function. Each time the callback function executes, <code>key</code> and <code>value</code> are the same, and <code>ownerSet</code> is always equal to <code>set</code>. This code outputs:</p>

<figure class="code">
<pre><code>1 1
true
2 2
true
</code></pre>

</figure>

<p>Also the same as arrays, you can pass a <code>this</code> value as the second argument to <code>forEach()</code> if you need to use <code>this</code> in your callback function:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach(function(value) {
            this.output(value);
        }, this);
    }
};

processor.process(set);
</code></pre>

</figure>

<p>In this example, the <code>processor.process()</code> method calls <code>forEach()</code> on the set and passes <code>this</code> as the <code>this</code> value for the callback. That's necessary so <code>this.output()</code> will correctly resolve to the <code>processor.output()</code> method. The <code>forEach()</code> callback function only makes use of the first argument, <code>value</code>, so the others are omitted. You can also use an arrow function to get the same effect without passing the second argument, like this:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach((value) =&gt; this.output(value));
    }
};

processor.process(set);
</code></pre>

</figure>

<p>The arrow function in this example reads <code>this</code> from the containing <code>process()</code> function, and so it should correctly resolve <code>this.output()</code> to a <code>processor.output()</code> call.</p>

<p>Keep in mind that while sets are great for tracking values and <code>forEach()</code> lets you work on each value sequentially, you can't directly access a value by index like you can with an array. If you need to do so, then the best option is to convert the set into an array.</p>

<h4 id="leanpub-auto-converting-a-set-to-an-array">Converting a Set to an Array</h4>

<p>It's easy to convert an array into a set because you can pass the array to the <code>Set</code> constructor. It's also easy to convert a set back into an array using the spread operator. Chapter 3 introduced the spread operator (<code>...</code>) as a way to split items in an array into separate function parameters. You can also use the spread operator to work on iterable objects, such as sets, to convert them into arrays. For example:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             // [1,2,3,4,5]
</code></pre>

</figure>

<p>Here, a set is initially loaded with an array that contains duplicates. The set removes the duplicates, and then the items are placed into a new array using the spread operator. The set itself still contains the same items (<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>) it received when it was created. They've just been copied to a new array.</p>

<p>This approach is useful when you already have an array and want to create an array without duplicates. For example:</p>

<figure class="code">
<pre><code>function eliminateDuplicates(items) {
    return [...new Set(items)];
}

let numbers = [1, 2, 3, 3, 3, 4, 5],
    noDuplicates = eliminateDuplicates(numbers);

console.log(noDuplicates);      // [1,2,3,4,5]
</code></pre>

</figure>

<p>In the <code>eliminateDuplicates()</code> function, the set is just a temporary intermediary used to filter out duplicate values before creating a new array that has no duplicates.</p>

<h4 id="leanpub-auto-weak-sets">Weak Sets</h4>

<p>The <code>Set</code> type could alternately be called a strong set, because of the way it stores object references. An object stored in an instance of <code>Set</code> is effectively the same as storing that object inside a variable. As long as a reference to that <code>Set</code> instance exists, the object cannot be garbage collected to free memory. For example:</p>

<figure class="code">
<pre><code>let set = new Set(),
    key = {};

set.add(key);
console.log(set.size);      // 1

// eliminate original reference
key = null;

console.log(set.size);      // 1

// get the original reference back
key = [...set][0];
</code></pre>

</figure>

<p>In this example, setting <code>key</code> to <code>null</code> clears one reference of the <code>key</code> object, but another remains inside <code>set</code>. You can still retrieve <code>key</code> by converting the set to an array with the spread operator and accessing the first item. That result is fine for most programs, but sometimes, it's better for references in a set to disappear when all other references disappear. For instance, if your JavaScript code is running in a web page and wants to keep track of DOM elements that might be removed by another script, you don't want your code holding onto the last reference to a DOM element. (That situation is called a <em>memory leak</em>.)</p>

<p>To alleviate such issues, ECMAScript 6 also includes <em>weak sets</em>, which only store weak object references and cannot store primitive values. A <em>weak reference</em> to an object does not prevent garbage collection if it is the only remaining reference.</p>

<h5 id="leanpub-auto-creating-a-weak-set">Creating a Weak Set</h5>

<p>Weak sets are created using the <code>WeakSet</code> constructor and have an <code>add()</code> method, a <code>has()</code> method, and a <code>delete()</code> method. Here's an example that uses all three:</p>

<figure class="code">
<pre><code>let set = new WeakSet(),
    key = {};

// add the object to the set
set.add(key);

console.log(set.has(key));      // true

set.delete(key);

console.log(set.has(key));      // false
</code></pre>

</figure>

<p>Using a weak set is a lot like using a regular set. You can add, remove, and check for references in the weak set. You can also seed a weak set with values by passing an iterable to the constructor:</p>

<figure class="code">
<pre><code>let key1 = {},
    key2 = {},
    set = new WeakSet([key1, key2]);

console.log(set.has(key1));     // true
console.log(set.has(key2));     // true
</code></pre>

</figure>

<p>In this example, an array is passed to the <code>WeakSet</code> constructor. Since this array contains two objects, those objects are added into the weak set. Keep in mind that an error will be thrown if the array contains any non-object values, since <code>WeakSet</code> can't accept primitive values.</p>

<h5 id="leanpub-auto-key-differences-between-set-types">Key Differences Between Set Types</h5>

<p>The biggest difference between weak sets and regular sets is the weak reference held to the object value. Here's an example that demonstrates that difference:</p>

<figure class="code">
<pre><code>let set = new WeakSet(),
    key = {};

// add the object to the set
set.add(key);

console.log(set.has(key));      // true

// remove the last strong reference to key, also removes from weak set
key = null;
</code></pre>

</figure>

<p>After this code executes, the reference to <code>key</code> in the weak set is no longer accessible. It is not possible to verify its removal because you would need one reference to that object to pass to the <code>has()</code> method. This can make testing weak sets a little confusing, but you can trust that the reference has been properly removed by the JavaScript engine.</p>

<p>These examples show that weak sets share some characteristics with regular sets, but there are some key differences. Those are:</p>

<ol class="numeric">
  <li>In a <code>WeakSet</code> instance, the <code>add()</code> method throws an error when passed a non-object (<code>has()</code> and <code>delete()</code> always return <code>false</code> for non-object arguments).</li>
  <li>Weak sets are not iterables and therefore cannot be used in a <code>for-of</code> loop.</li>
  <li>Weak sets do not expose any iterators (such as the <code>keys()</code> and <code>values()</code> methods), so there is no way to programmatically determine the contents of a weak set.</li>
  <li>Weak sets do not have a <code>forEach()</code> method.</li>
  <li>Weak sets do not have a <code>size</code> property.</li>
</ol>

<p>The seemingly limited functionality of weak sets is necessary in order to properly handle memory. In general, if you only need to track object references, then you should use a weak set instead of a regular set.</p>

<p>Sets give you a new way to handle lists of values, but they aren't useful when you need to associate additional information with those values. That's why ECMAScript 6 also adds maps.</p>

<h3 id="leanpub-auto-maps-in-ecmascript-6">Maps in ECMAScript 6</h3>

<p>The ECMAScript 6 <code>Map</code> type is an ordered list of key-value pairs, where both the key and the value can have any type. Keys equivalence is determined by using the same approach as <code>Set</code> objects, so you can have both a key of <code>5</code> and a key of <code>"5"</code> because they are different types. This is quite different from using object properties as keys, as object properties always coerce values into strings.</p>

<p>You can add items to maps by calling the <code>set()</code> method and passing it a key and the value to associate with the key. You can later retrieve a value by passing the key to the <code>get()</code> method. For example:</p>

<figure class="code">
<pre><code>let map = new Map();
map.set("title", "Understanding ES6");
map.set("year", 2016);

console.log(map.get("title"));      // "Understanding ES6"
console.log(map.get("year"));       // 2016
</code></pre>

</figure>

<p>In this example, two key-value pairs are stored. The <code>"title"</code> key stores a string while the <code>"year"</code> key stores a number. The <code>get()</code> method is called later to retrieve the values for both keys. If either key didn't exist in the map, then <code>get()</code> would have returned the special value <code>undefined</code> instead of a value.</p>

<p>You can also use objects as keys, which isn't possible when using object properties to create a map in the old workaround approach. Here's an example:</p>

<figure class="code">
<pre><code>let map = new Map(),
    key1 = {},
    key2 = {};

map.set(key1, 5);
map.set(key2, 42);

console.log(map.get(key1));         // 5
console.log(map.get(key2));         // 42
</code></pre>

</figure>

<p>This code uses the objects <code>key1</code> and <code>key2</code> as keys in the map to store two different values. Because these keys are not coerced into another form, each object is considered unique. This allows you to associate additional data with an object without modifying the object itself.</p>

<h4 id="leanpub-auto-map-methods">Map Methods</h4>

<p>Maps share several methods with sets. That is intentional, and it allows you to interact with maps and sets in similar ways. These three methods are available on both maps and sets:</p>

<ul>
  <li>
<code>has(key)</code> - Determines if the given key exists in the map</li>
  <li>
<code>delete(key)</code> - Removes the key and its associated value from the map</li>
  <li>
<code>clear()</code> - Removes all keys and values from the map</li>
</ul>

<p>Maps also have a <code>size</code> property that indicates how many key-value pairs it contains. This code uses all three methods and <code>size</code> in different ways:</p>

<figure class="code">
<pre><code>let map = new Map();
map.set("name", "Nicholas");
map.set("age", 25);

console.log(map.size);          // 2

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"

console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25

map.delete("name");
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.size);          // 1

map.clear();
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.has("age"));    // false
console.log(map.get("age"));    // undefined
console.log(map.size);          // 0
</code></pre>

</figure>

<p>As with sets, the <code>size</code> property always contains the number of key-value pairs in the map. The <code>Map</code> instance in this example starts with the <code>"name"</code> and <code>"age"</code> keys, so <code>has()</code> returns <code>true</code> when passed either key. After the <code>"name"</code> key is removed by the <code>delete()</code> method, the <code>has()</code> method returns <code>false</code> when passed <code>"name"</code> and the <code>size</code> property indicates one less item. The <code>clear()</code> method then removes the remaining key, as indicated by <code>has()</code> returning <code>false</code> for both keys and <code>size</code> being 0.</p>

<p>The <code>clear()</code> method is a fast way to remove a lot of data from a map, but there's also a way to add a lot of data to a map at one time.</p>

<h4 id="leanpub-auto-map-initialization">Map Initialization</h4>

<p>Also similar to sets, you can initialize a map with data by passing an array to the <code>Map</code> constructor. Each item in the array must itself be an array where the first item is the key and the second is that key's corresponding value. The entire map, therefore, is an array of these two-item arrays, for example:</p>

<figure class="code">
<pre><code>let map = new Map([["name", "Nicholas"], ["age", 25]]);

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"
console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25
console.log(map.size);          // 2
</code></pre>

</figure>

<p>The keys <code>"name"</code> and <code>"age"</code> are added into <code>map</code> through initialization in the constructor. While the array of arrays may look a bit strange, it's necessary to accurately represent keys, as keys can be any data type. Storing the keys in an array is the only way to ensure they aren't coerced into another data type before being stored in the map.</p>

<h4 id="leanpub-auto-the-foreach-method-on-maps">The forEach Method on Maps</h4>

<p>The <code>forEach()</code> method for maps is similar to <code>forEach()</code> for sets and arrays, in that it accepts a callback function that receives three arguments:</p>

<ol class="numeric">
  <li>The value from the next position in the map</li>
  <li>The key for that value</li>
  <li>The map from which the value is read</li>
</ol>

<p>These callback arguments more closely match the <code>forEach()</code> behavior in arrays, where the first argument is the value and the second is the key (corresponding to a numeric index in arrays). Here's an example:</p>

<figure class="code">
<pre><code>let map = new Map([ ["name", "Nicholas"], ["age", 25]]);

map.forEach(function(value, key, ownerMap) {
    console.log(key + " " + value);
    console.log(ownerMap === map);
});
</code></pre>

</figure>

<p>The <code>forEach()</code> callback function outputs the information that is passed to it. The <code>value</code> and <code>key</code> are output directly, and <code>ownerMap</code> is compared to <code>map</code> to show that the values are equivalent. This outputs:</p>

<figure class="code">
<pre><code>name Nicholas
true
age 25
true
</code></pre>

</figure>

<p>The callback passed to <code>forEach()</code> receives each key-value pair in the order in which the pairs were inserted into the map. This behavior differs slightly from calling <code>forEach()</code> on arrays, where the callback receives each item in order of numeric index.</p>

<aside class="information blurb">
    <p>You can also provide a second argument to <code>forEach()</code> to specify the <code>this</code> value inside the callback function. A call like that behaves the same as the set version of the <code>forEach()</code> method.</p>

</aside>

<h4 id="leanpub-auto-weak-maps">Weak Maps</h4>

<p>Weak maps are to maps what weak sets are to sets: they're a way to store weak object references. In <em>weak maps</em>, every key must be an object (an error is thrown if you try to use a non-object key), and those object references are held weakly so they don't interfere with garbage collection. When there are no references to a weak map key outside a weak map, the key-value pair is removed from the weak map.</p>

<p>The most useful place to employ weak maps is when creating an object related to a particular DOM element in a web page. For example, some JavaScript libraries for web pages maintain one custom object for every DOM element referenced in the library, and that mapping is stored in a cache of objects internally.</p>

<p>The difficult part of this approach is determining when a DOM element no longer exists in the web page, so that the library can remove its associated object. Otherwise, the library would hold onto the DOM element reference past the reference's usefulness and cause a memory leak. Tracking the DOM elements with a weak map would still allow the library to associate a custom object with every DOM element, and it could automatically destroy any object in the map when that object's DOM element no longer exists.</p>

<aside class="information blurb">
    <p>It's important to note that only weak map keys, and not weak map values, are weak references. An object stored as a weak map value will prevent garbage collection if all other references are removed.</p>

</aside>

<h5 id="leanpub-auto-using-weak-maps">Using Weak Maps</h5>

<p>The ECMAScript 6 <code>WeakMap</code> type is an unordered list of key-value pairs, where a key must be a non-null object and a value can be of any type. The interface for <code>WeakMap</code> is very similar to that of <code>Map</code> in that <code>set()</code> and <code>get()</code> are used to add and retrieve data, respectively:</p>

<figure class="code">
<pre><code>let map = new WeakMap(),
    element = document.querySelector(".element");

map.set(element, "Original");

let value = map.get(element);
console.log(value);             // "Original"

// remove the element
element.parentNode.removeChild(element);
element = null;

// the weak map is empty at this point
</code></pre>

</figure>

<p>In this example, one key-value pair is stored. The <code>element</code> key is a DOM element used to store a corresponding string value. That value is then retrieved by passing in the DOM element to the <code>get()</code> method. When the DOM element is later removed from the document and the variable referencing it is set to <code>null</code>, the data is also removed from the weak map.</p>

<p>Similar to weak sets, there is no way to verify that a weak map is empty, because it doesn't have a <code>size</code> property. Because there are no remaining references to the key, you can't retrieve the value by calling the <code>get()</code> method, either. The weak map has cut off access to the value for that key, and when the garbage collector runs, the memory occupied by the value will be freed.</p>

<h5 id="leanpub-auto-weak-map-initialization">Weak Map Initialization</h5>

<p>To initialize a weak map, pass an array of arrays to the <code>WeakMap</code> constructor. Just like initializing a regular map, each array inside the containing array should have two items, where the first item is the non-null object key and the second item is the value (any data type). For example:</p>

<figure class="code">
<pre><code>let key1 = {},
    key2 = {},
    map = new WeakMap([[key1, "Hello"], [key2, 42]]);

console.log(map.has(key1));     // true
console.log(map.get(key1));     // "Hello"
console.log(map.has(key2));     // true
console.log(map.get(key2));     // 42
</code></pre>

</figure>

<p>The objects <code>key1</code> and <code>key2</code> are used as keys in the weak map, and the <code>get()</code> and <code>has()</code> methods can access them. An error is thrown if the <code>WeakMap</code> constructor receives a non-object key in any of the key-value pairs.</p>

<h5 id="leanpub-auto-weak-map-methods">Weak Map Methods</h5>

<p>Weak maps have only two additional methods available to interact with key-value pairs. There is a <code>has()</code> method to determine if a given key exists in the map and a <code>delete()</code> method to remove a specific key-value pair. There is no <code>clear()</code> method because that would require enumerating keys, and like weak sets, that isn't possible with weak maps. This example uses both the <code>has()</code> and <code>delete()</code> methods:</p>

<figure class="code">
<pre><code>let map = new WeakMap(),
    element = document.querySelector(".element");

map.set(element, "Original");

console.log(map.has(element));   // true
console.log(map.get(element));   // "Original"

map.delete(element);
console.log(map.has(element));   // false
console.log(map.get(element));   // undefined
</code></pre>

</figure>

<p>Here, a DOM element is once again used as the key in a weak map. The <code>has()</code> method is useful for checking to see if a reference is currently being used as a key in the weak map. Keep in mind that this only works when you have a non-null reference to a key. The key is forcibly removed from the weak map by the <code>delete()</code> method, at which point <code>has()</code> returns <code>false</code> and <code>get()</code> returns <code>undefined</code>.</p>

<h5 id="leanpub-auto-private-object-data">Private Object Data</h5>

<p>While most developers consider the main use case of weak maps to be associated data with DOM elements, there are many other possible uses (and no doubt, some that have yet to be discovered). One practical use of weak maps is to store data that is private to object instances. All object properties are public in ECMAScript 6, and so you need to use some creativity to make data accessible to objects, but not accessible to everything. Consider the following example:</p>

<figure class="code">
<pre><code>function Person(name) {
    this._name = name;
}

Person.prototype.getName = function() {
    return this._name;
};
</code></pre>

</figure>

<p>This code uses the common convention of a leading underscore to indicate that a property is considered private and should not be modified outside the object instance. The intent is to use <code>getName()</code> to read <code>this._name</code> and not allow the <code>_name</code> value to change. However, there is nothing standing in the way of someone writing to the <code>_name</code> property, so it can be overwritten either intentionally or accidentally.</p>

<p>In ECMAScript 5, it's possible to get close to having truly private data, by creating an object using a pattern such as this:</p>

<figure class="code">
<pre><code>var Person = (function() {

    var privateData = {},
        privateId = 0;

    function Person(name) {
        Object.defineProperty(this, "_id", { value: privateId++ });

        privateData[this._id] = {
            name: name
        };
    }

    Person.prototype.getName = function() {
        return privateData[this._id].name;
    };

    return Person;
}());
</code></pre>

</figure>

<p>This example wraps the definition of <code>Person</code> in an IIFE that contains two private variables, <code>privateData</code> and <code>privateId</code>. The <code>privateData</code> object stores private information for each instance while <code>privateId</code> is used to generate a unique ID for each instance. When the <code>Person</code> constructor is called, a nonenumerable, nonconfigurable, and nonwritable <code>_id</code> property is added.</p>

<p>Then, an entry is made into the <code>privateData</code> object that corresponds to the ID for the object instance; that's where the <code>name</code> is stored. Later, in the <code>getName()</code> function, the name can be retrieved by using <code>this._id</code> as the key into <code>privateData</code>. Because <code>privateData</code> is not accessible outside of the IIFE, the actual data is safe, even though <code>this._id</code> is exposed publicly.</p>

<p>The big problem with this approach is that the data in <code>privateData</code> never disappears because there is no way to know when an object instance is destroyed; the <code>privateData</code> object will always contain extra data. This problem can be solved by using a weak map instead, as follows:</p>

<figure class="code">
<pre><code>let Person = (function() {

    let privateData = new WeakMap();

    function Person(name) {
        privateData.set(this, { name: name });
    }

    Person.prototype.getName = function() {
        return privateData.get(this).name;
    };

    return Person;
}());
</code></pre>

</figure>

<p>This version of the <code>Person</code> example uses a weak map for the private data instead of an object. Because the <code>Person</code> object instance itself can be used as a key, there's no need to keep track of a separate ID. When the <code>Person</code> constructor is called, a new entry is made into the weak map with a key of <code>this</code> and a value of an object containing private information. In this case, that value is an object containing only <code>name</code>. The <code>getName()</code> function retrieves that private information by passing <code>this</code> to the <code>privateData.get()</code> method, which fetches the value object and accesses the <code>name</code> property. This technique keeps the private information private, and destroys that information whenever an object instance associated with it is destroyed.</p>

<h5 id="leanpub-auto-weak-map-uses-and-limitations">Weak Map Uses and Limitations</h5>

<p>When deciding whether to use a weak map or a regular map, the primary decision to consider is whether you want to use only object keys. Anytime you're going to use only object keys, then the best choice is a weak map. That will allow you to optimize memory usage and avoid memory leaks by ensuring that extra data isn't kept around after it's no longer accessible.</p>

<p>Keep in mind that weak maps give you very little visibility into their contents, so you can't use the <code>forEach()</code> method, the <code>size</code> property, or the <code>clear()</code> method to manage the items. If you need some inspection capabilities, then regular maps are a better choice. Just be sure to keep an eye on memory usage.</p>

<p>Of course, if you only want to use non-object keys, then regular maps are your only choice.</p>

<h3 id="leanpub-auto-summary-6">Summary</h3>

<p>ECMAScript 6 formally introduces sets and maps into JavaScript. Prior to this, developers frequently used objects to mimic both sets and maps, often running into problems due to the limitations associated with object properties.</p>

<p>Sets are ordered lists of unique values. Values are not coerced to determine equivalence. Sets automatically remove duplicate values, so you can use a set to filter an array for duplicates and return the result. Sets aren't subclasses of arrays, so you cannot randomly access a set's values. Instead, you can use the <code>has()</code> method to determine if a value is contained in the set and the <code>size</code> property to inspect the number of values in the set. The <code>Set</code> type also has a <code>forEach()</code> method to process each set value.</p>

<p>Weak sets are special sets that can contain only objects. The objects are stored with weak references, meaning that an item in a weak set will not block garbage collection if that item is the only remaining reference to an object. Weak set contents can't be inspected due to the complexities of memory management, so it's best to use weak sets only for tracking objects that need to be grouped together.</p>

<p>Maps are ordered key-value pairs where the key can be any data type. Similar to sets, keys are not coerced to determine equivalence, which means you can have a numeric key <code>5</code> and a string <code>"5"</code> as two separate keys. A value of any data type can be associated with a key using the <code>set()</code> method, and that value can later be retrieved by using the <code>get()</code> method. Maps also have a <code>size</code> property and a <code>forEach()</code> method to allow for easier item access.</p>

<p>Weak maps are a special type of map that can only have object keys. As with weak sets, an object key reference is weak and doesn't prevent garbage collection when it's the only remaining reference to an object. When a key is garbage collected, the value associated with the key is also removed from the weak map. This memory management aspect makes weak maps uniquely suited for correlating additional information with objects whose lifecycles are managed outside of the code accessing them.</p>


<h2 id="leanpub-auto-iterators-and-generators">Iterators and Generators</h2>

<p>Many programming languages have shifted from iterating over data with <code>for</code> loops, which require initializing variables to track position in a collection, to using iterator objects that programmatically return the next item in a collection. Iterators make working with collections of data easier, and ECMAScript 6 adds iterators to JavaScript. When coupled with new array methods and new types of collections (such as sets and maps), iterators are key for efficient data processing, and you will find them in many parts of the language. There's a new <code>for-of</code> loop that works with iterators, the spread (<code>...</code>) operator uses iterators, and iterators even make asynchronous programming easier.</p>

<p>This chapter covers the many uses of iterators, but first, it's important to understand the history behind why iterators were added to JavaScript.</p>

<h3 id="leanpub-auto-the-loop-problem">The Loop Problem</h3>

<p>If you've ever programmed in JavaScript, you've probably written code that looks like this:</p>

<figure class="code">
<pre><code>var colors = ["red", "green", "blue"];

for (var i = 0, len = colors.length; i &lt; len; i++) {
    console.log(colors[i]);
}
</code></pre>

</figure>

<p>This standard <code>for</code> loop tracks the index into the <code>colors</code> array with the <code>i</code> variable. The value of <code>i</code> increments each time the loop executes if <code>i</code> isn't larger than the length of the array (stored in <code>len</code>).</p>

<p>While this loop is fairly straightforward, loops grow in complexity when you nest them and need to keep track of multiple variables. Additional complexity can lead to errors, and the boilerplate nature of the <code>for</code> loop lends itself to more errors as similar code is written in multiple places. Iterators are meant to solve that problem.</p>

<h3 id="leanpub-auto-what-are-iterators">What are Iterators?</h3>

<p>Iterators are just objects with a specific interface designed for iteration. All iterator objects have a <code>next()</code> method that returns a result object. The result object has two properties: <code>value</code>, which is the next value, and <code>done</code>, which is a boolean that's <code>true</code> when there are no more values to return. The iterator keeps an internal pointer to a location within a collection of values and with each call to the <code>next()</code> method, it returns the next appropriate value.</p>

<p>If you call <code>next()</code> after the last value has been returned, the method returns <code>done</code> as <code>true</code> and <code>value</code> contains the <em>return value</em> for the iterator. That return value is not part of the data set, but rather a final piece of related data, or <code>undefined</code> if no such data exists. An iterator's return value is similar to a function's return value in that it's a final way to pass information to the caller.</p>

<p>With that in mind, creating an iterator using ECMAScript 5 is fairly straightforward:</p>

<figure class="code">
<pre><code>function createIterator(items) {

    var i = 0;

    return {
        next: function() {

            var done = (i &gt;= items.length);
            var value = !done ? items[i++] : undefined;

            return {
                done: done,
                value: value
            };

        }
    };
}

var iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// for all further calls
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>The <code>createIterator()</code> function returns an object with a <code>next()</code> method. Each time the method is called, the next value in the <code>items</code> array is returned as <code>value</code>. When <code>i</code> is 3, <code>done</code> becomes <code>true</code> and the ternary conditional operator that sets <code>value</code> evaluates to <code>undefined</code>. These two results fulfill the special last case for iterators in ECMAScript 6, where <code>next()</code> is called on an iterator after the last piece of data has been used.</p>

<p>As this example shows, writing iterators that behave according to the rules laid out in ECMAScript 6 is a bit complex.</p>

<p>Fortunately, ECMAScript 6 also provides generators, which make creating iterator objects much simpler.</p>

<h3 id="leanpub-auto-what-are-generators">What Are Generators?</h3>

<p>A <em>generator</em> is a function that returns an iterator. Generator functions are indicated by a star character (<code>*</code>) after the <code>function</code> keyword and use the new <code>yield</code> keyword. It doesn't matter if the star is directly next to <code>function</code> or if there's some whitespace between it and the <code>*</code> character, as in this example:</p>

<figure class="code">
<pre><code>// generator
function *createIterator() {
    yield 1;
    yield 2;
    yield 3;
}

// generators are called like regular functions but return an iterator
let iterator = createIterator();

console.log(iterator.next().value);     // 1
console.log(iterator.next().value);     // 2
console.log(iterator.next().value);     // 3
</code></pre>

</figure>

<p>The <code>*</code> before <code>createIterator()</code> makes this function a generator. The <code>yield</code> keyword, also new to ECMAScript 6, specifies values the resulting iterator should return when <code>next()</code> is called, in the order they should be returned. The iterator generated in this example has three different values to return on successive calls to the <code>next()</code> method: first <code>1</code>, then <code>2</code>, and finally <code>3</code>. A generator gets called like any other function, as shown when <code>iterator</code> is created.</p>

<p>Perhaps the most interesting aspect of generator functions is that they stop execution after each <code>yield</code> statement. For instance, after <code>yield 1</code> executes in this code, the function doesn't execute anything else until the iterator's <code>next()</code> method is called. At that point, <code>yield 2</code> executes. This ability to stop execution in the middle of a function is extremely powerful and leads to some interesting uses of generator functions (discussed in the "Advanced Iterator Functionality" section).</p>

<p>The <code>yield</code> keyword can be used with any value or expression, so you can write generator functions that add items to iterators without just listing the items one by one. For example, here's one way you could use <code>yield</code> inside a <code>for</code> loop:</p>

<figure class="code">
<pre><code>function *createIterator(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items[i];
    }
}

let iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// for all further calls
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>This example passes an array called <code>items</code> to the <code>createIterator()</code> generator function. Inside the function, a <code>for</code> loop yields the elements from the array into the iterator as the loop progresses. Each time <code>yield</code> is encountered, the loop stops, and each time <code>next()</code> is called on <code>iterator</code>, the loop picks up with the next <code>yield</code> statement.</p>

<p>Generator functions are an important feature of ECMAScript 6, and since they are just functions, they can be used in all the same places. The rest of this section focuses on other useful ways to write generators.</p>

<aside class="warning blurb">
    <p>The <code>yield</code> keyword can only be used inside of generators. Use of <code>yield</code> anywhere else is a syntax error, including functions that are inside of generators, such as:</p>

  <figure class="code">
<pre><code>function *createIterator(items) {

    items.forEach(function(item) {

        // syntax error
        yield item + 1;
    });
}
</code></pre>

  </figure>

  <p>Even though <code>yield</code> is technically inside of <code>createIterator()</code>, this code is a syntax error because <code>yield</code> cannot cross function boundaries. In this way, <code>yield</code> is similar to <code>return</code>, in that a nested function cannot return a value for its containing function.</p>

</aside>

<h4 id="leanpub-auto-generator-function-expressions">Generator Function Expressions</h4>

<p>You can use function expressions to create generators by just including a star (<code>*</code>) character between the <code>function</code> keyword and the opening parenthesis. For example:</p>

<figure class="code">
<pre><code>let createIterator = function *(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items[i];
    }
};

let iterator = createIterator([1, 2, 3]);

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"

// for all further calls
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>In this code, <code>createIterator()</code> is a generator function expression instead of a function declaration. The asterisk goes between the <code>function</code> keyword and the opening parentheses because the function expression is anonymous. Otherwise, this example is the same as the previous version of the <code>createIterator()</code> function, which also used a <code>for</code> loop.</p>

<aside class="information blurb">
    <p>Creating an arrow function that is also a generator is not possible.</p>

</aside>

<h4 id="leanpub-auto-generator-object-methods">Generator Object Methods</h4>

<p>Because generators are just functions, they can be added to objects, too. For example, you can make a generator in an ECMAScript 5-style object literal with a function expression:</p>

<figure class="code">
<pre><code>var o = {

    createIterator: function *(items) {
        for (let i = 0; i &lt; items.length; i++) {
            yield items[i];
        }
    }
};

let iterator = o.createIterator([1, 2, 3]);
</code></pre>

</figure>

<p>You can also use the ECMAScript 6 method shorthand by prepending the method name with a star (<code>*</code>):</p>

<figure class="code">
<pre><code>var o = {

    *createIterator(items) {
        for (let i = 0; i &lt; items.length; i++) {
            yield items[i];
        }
    }
};

let iterator = o.createIterator([1, 2, 3]);
</code></pre>

</figure>

<p>These examples are functionally equivalent to the example in the "Generator Function Expressions" section; they just use different syntax. In the shorthand version, because the <code>createIterator()</code> method is defined with no <code>function</code> keyword, the star is placed immediately before the method name, though you can leave whitespace between the star and the method name.</p>

<h3 id="leanpub-auto-iterables-and-for-of">Iterables and for-of</h3>

<p>Closely related to iterators, an <em>iterable</em> is an object with a <code>Symbol.iterator</code> property. The well-known <code>Symbol.iterator</code> symbol specifies a function that returns an iterator for the given object. All collection objects (arrays, sets, and maps) and strings are iterables in ECMAScript 6 and so they have a default iterator specified. Iterables are designed to be used with a new addition to ECMAScript: the <code>for-of</code> loop.</p>

<aside class="information blurb">
    <p>All iterators created by generators are also iterables, as generators assign the <code>Symbol.iterator</code> property by default.</p>

</aside>

<p>At the beginning of this chapter, I mentioned the problem of tracking an index inside a <code>for</code> loop. Iterators are the first part of the solution to that problem. The <code>for-of</code> loop is the second part: it removes the need to track an index into a collection entirely, leaving you free to focus on working with the contents of the collection.</p>

<p>A <code>for-of</code> loop calls <code>next()</code> on an iterable each time the loop executes and stores the <code>value</code> from the result object in a variable. The loop continues this process until the returned object's <code>done</code> property is <code>true</code>. Here's an example:</p>

<figure class="code">
<pre><code>let values = [1, 2, 3];

for (let num of values) {
    console.log(num);
}
</code></pre>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<pre><code>1
2
3
</code></pre>

</figure>

<p>This <code>for-of</code> loop first calls the <code>Symbol.iterator</code> method on the <code>values</code> array to retrieve an iterator. (The call to <code>Symbol.iterator</code> happens behind the scenes in the JavaScript engine itself.) Then <code>iterator.next()</code> is called, and the <code>value</code> property on the iterator's result object is read into <code>num</code>. The <code>num</code> variable is first 1, then 2, and finally 3. When <code>done</code> on the result object is <code>true</code>, the loop exits, so <code>num</code> is never assigned the value of <code>undefined</code>.</p>

<p>If you are simply iterating over values in an array or collection, then it's a good idea to use a <code>for-of</code> loop instead of a <code>for</code> loop. The <code>for-of</code> loop is generally less error-prone because there are fewer conditions to keep track of. Save the traditional <code>for</code> loop for more complex control conditions.</p>

<aside class="warning blurb">
    <p>The <code>for-of</code> statement will throw an error when used on, a non-iterable object, <code>null</code>, or <code>undefined</code>.</p>

</aside>

<h4 id="leanpub-auto-accessing-the-default-iterator">Accessing the Default Iterator</h4>

<p>You can use <code>Symbol.iterator</code> to access the default iterator for an object, like this:</p>

<figure class="code">
<pre><code>let values = [1, 2, 3];
let iterator = values[Symbol.iterator]();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>This code gets the default iterator for <code>values</code> and uses that to iterate over the items in the array. This is the same process that happens behind-the-scenes when using a <code>for-of</code> loop.</p>

<p>Since <code>Symbol.iterator</code> specifies the default iterator, you can use it to detect whether an object is iterable as follows:</p>

<figure class="code">
<pre><code>function isIterable(object) {
    return typeof object[Symbol.iterator] === "function";
}

console.log(isIterable([1, 2, 3]));     // true
console.log(isIterable("Hello"));       // true
console.log(isIterable(new Map()));     // true
console.log(isIterable(new Set()));     // true
console.log(isIterable(new WeakMap())); // false
console.log(isIterable(new WeakSet())); // false
</code></pre>

</figure>

<p>The <code>isIterable()</code> function simply checks to see if a default iterator exists on the object and is a function. The <code>for-of</code> loop does a similar check before executing.</p>

<p>So far, the examples in this section have shown ways to use <code>Symbol.iterator</code> with built-in iterable types, but you can also use the <code>Symbol.iterator</code> property to create your own iterables.</p>

<h4 id="leanpub-auto-creating-iterables">Creating Iterables</h4>

<p>Developer-defined objects are not iterable by default, but you can make them iterable by creating a <code>Symbol.iterator</code> property containing a generator. For example:</p>

<figure class="code">
<pre><code>let collection = {
    items: [],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item;
        }
    }

};

collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
    console.log(x);
}
</code></pre>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<pre><code>1
2
3
</code></pre>

</figure>

<p>First, the example defines a default iterator for an object called <code>collection</code>. The default iterator is created by the <code>Symbol.iterator</code> method, which is a generator (note the star still comes before the name). The generator then uses a <code>for-of</code> loop to iterate over the values in <code>this.items</code> and uses <code>yield</code> to return each one. Instead of manually iterating to define values for the default iterator of <code>collection</code> to return, the <code>collection</code> object relies on the default iterator of <code>this.items</code> to do the work.</p>

<aside class="information blurb">
    <p>"Delegating Generators" later in this chapter describes a different approach to using the iterator of another object.</p>

</aside>

<p>Now you've seen some uses for the default array iterator, but there are many more iterators built in to ECMAScript 6 to make working with collections of data easy.</p>

<h3 id="leanpub-auto-built-in-iterators">Built-in Iterators</h3>

<p>Iterators are an important part of ECMAScript 6, and as such, you don't need to create your own iterators for many built-in types; the language includes them by default. You only need to create iterators when the built-in iterators don't serve your purpose, which will most frequently be when defining your own objects or classes. Otherwise, you can rely on built-in iterators to do your work. Perhaps the most common iterators to use are those that work on collections.</p>

<h4 id="leanpub-auto-collection-iterators">Collection Iterators</h4>

<p>ECMAScript 6 has three types of collection objects: arrays, maps, and sets. All three have the following built-in iterators to help you navigate their content:</p>

<ul>
  <li>
<code>entries()</code> - Returns an iterator whose values are a key-value pair</li>
  <li>
<code>values()</code> - Returns an iterator whose values are the values of the collection</li>
  <li>
<code>keys()</code> - Returns an iterator whose values are the keys contained in the collection</li>
</ul>

<p>You can retrieve an iterator for a collection by calling one of these methods.</p>

<h5 id="leanpub-auto-the-entries-iterator">The entries() Iterator</h5>

<p>The <code>entries()</code> iterator returns a two-item array each time <code>next()</code> is called. The two-item array represents the key and value for each item in the collection. For arrays, the first item is the numeric index; for sets, the first item is also the value (since values double as keys in sets); for maps, the first item is the key.</p>

<p>Here are some examples that use this iterator:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];
let tracking = new Set([1234, 5678, 9012]);
let data = new Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

for (let entry of colors.entries()) {
    console.log(entry);
}

for (let entry of tracking.entries()) {
    console.log(entry);
}

for (let entry of data.entries()) {
    console.log(entry);
}
</code></pre>

</figure>

<p>The <code>console.log()</code> calls give the following output:</p>

<figure class="code">
<pre><code>[0, "red"]
[1, "green"]
[2, "blue"]
[1234, 1234]
[5678, 5678]
[9012, 9012]
["title", "Understanding ECMAScript 6"]
["format", "ebook"]
</code></pre>

</figure>

<p>This code uses the <code>entries()</code> method on each type of collection to retrieve an iterator, and it uses <code>for-of</code> loops to iterate the items. The console output shows how the keys and values are returned in pairs for each object.</p>

<h5 id="leanpub-auto-the-values-iterator">The values() Iterator</h5>

<p>The <code>values()</code> iterator simply returns values as they are stored in the collection. For example:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];
let tracking = new Set([1234, 5678, 9012]);
let data = new Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

for (let value of colors.values()) {
    console.log(value);
}

for (let value of tracking.values()) {
    console.log(value);
}

for (let value of data.values()) {
    console.log(value);
}
</code></pre>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<pre><code>"red"
"green"
"blue"
1234
5678
9012
"Understanding ECMAScript 6"
"ebook"
</code></pre>

</figure>

<p>Calling the <code>values()</code> iterator, as in this example, returns the exact data contained in each collection without any information about that data's location in the collection.</p>

<h5 id="leanpub-auto-the-keys-iterator">The keys() Iterator</h5>

<p>The <code>keys()</code> iterator returns each key present in a collection. For arrays, it only returns numeric keys, never other own properties of the array. For sets, the keys are the same as the values, and so <code>keys()</code> and <code>values()</code> return the same iterator. For maps, the <code>keys()</code> iterator returns each unique key. Here's an example that demonstrates all three:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];
let tracking = new Set([1234, 5678, 9012]);
let data = new Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

for (let key of colors.keys()) {
    console.log(key);
}

for (let key of tracking.keys()) {
    console.log(key);
}

for (let key of data.keys()) {
    console.log(key);
}
</code></pre>

</figure>

<p>This example outputs the following:</p>

<figure class="code">
<pre><code>0
1
2
1234
5678
9012
"title"
"format"
</code></pre>

</figure>

<p>The <code>keys()</code> iterator fetches each key in <code>colors</code>, <code>tracking</code>, and <code>data</code>, and those keys are printed from inside the three <code>for-of</code> loops. For the array object, only numeric indices are printed, which would still happen even if you added named properties to the array. This is different from the way the <code>for-in</code> loop works with arrays, because the <code>for-in</code> loop iterates over properties rather than just the numeric indices.</p>

<h5 id="leanpub-auto-default-iterators-for-collection-types">Default Iterators for Collection Types</h5>

<p>Each collection type also has a default iterator that is used by <code>for-of</code> whenever an iterator isn't explicitly specified. The <code>values()</code> method is the default iterator for arrays and sets, while the <code>entries()</code> method is the default iterator for maps. These defaults make using collection objects in <code>for-of</code> loops a little easier. For instance, consider this example:</p>

<figure class="code">
<pre><code>let colors = [ "red", "green", "blue" ];
let tracking = new Set([1234, 5678, 9012]);
let data = new Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "print");

// same as using colors.values()
for (let value of colors) {
    console.log(value);
}

// same as using tracking.values()
for (let num of tracking) {
    console.log(num);
}

// same as using data.entries()
for (let entry of data) {
    console.log(entry);
}
</code></pre>

</figure>

<p>No iterator is specified, so the default iterator functions will be used. The default iterators for arrays, sets, and maps are designed to reflect how these objects are initialized, so this code outputs the following:</p>

<figure class="code">
<pre><code>"red"
"green"
"blue"
1234
5678
9012
["title", "Understanding ECMAScript 6"]
["format", "print"]
</code></pre>

</figure>

<p>Arrays and sets return their values by default, while maps return the same array format that can be passed into the <code>Map</code> constructor. Weak sets and weak maps, on the other hand, do not have built-in iterators. Managing weak references means there's no way to know exactly how many values are in these collections, which also means there's no way to iterate over them.</p>

<aside>
  <h4 id="leanpub-auto-destructuring-and-for-of-loops">Destructuring and for-of Loops</h4>

  <p>The behavior of the default iterator for maps is also helpful when used in <code>for-of</code> loops with destructuring, as in this example:</p>

  <figure class="code">
<pre><code>let data = new Map();

data.set("title", "Understanding ECMAScript 6");
data.set("format", "ebook");

// same as using data.entries()
for (let [key, value] of data) {
    console.log(key + "=" + value);
}
</code></pre>

  </figure>

  <p>The <code>for-of</code> loop in this code uses a destructured array to assign <code>key</code> and <code>value</code> for each entry in the map. In this way, you can easily work with keys and values at the same time without needing to access a two-item array or going back to the map to fetch either the key or the value. Using a destructured array for maps makes the <code>for-of</code> loop equally useful for maps as it is for sets and arrays.</p>

</aside>

<h4 id="leanpub-auto-string-iterators">String Iterators</h4>

<p>JavaScript strings have slowly become more like arrays since ECMAScript 5 was released. For example, ECMAScript 5 formalized bracket notation for accessing characters in strings (that is, using <code>text[0]</code> to get the first character, and so on). But bracket notation works on code units rather than characters, so it cannot be used to access double-byte characters correctly, as this example demonstrates:</p>

<figure class="code">
<pre><code>var message = "A ð ®· B";

for (let i=0; i &lt; message.length; i++) {
    console.log(message[i]);
}
</code></pre>

</figure>

<p>This code uses bracket notation and the <code>length</code> property to iterate over and print a string containing a Unicode character. The output is a bit unexpected:</p>

<figure class="code">
<pre><code>A
(blank)
(blank)
(blank)
(blank)
B
</code></pre>

</figure>

<p>Since the double-byte character is treated as two separate code units, there are four empty lines between <code>A</code> and <code>B</code> in the output.</p>

<p>Fortunately, ECMAScript 6 aims to fully support Unicode (see Chapter 2), and the default string iterator is an attempt to solve the string iteration problem. As such, the default iterator for strings works on characters rather than code units. Changing this example to use the default string iterator with a <code>for-of</code> loop results in more appropriate output. Here's the tweaked code:</p>

<figure class="code">
<pre><code>var message = "A ð ®· B";

for (let c of message) {
    console.log(c);
}
</code></pre>

</figure>

<p>This outputs the following:</p>

<figure class="code">
<pre><code>A
(blank)
ð ®·
(blank)
B
</code></pre>

</figure>

<p>This result is more in line with what you'd expect when working with characters: the loop successfully prints the Unicode character, as well as all the rest.</p>

<h4 id="leanpub-auto-nodelist-iterators">NodeList Iterators</h4>

<p>The Document Object Model (DOM) has a <code>NodeList</code> type that represents a collection of elements in a document. For those who write JavaScript to run in web browsers, understanding the difference between <code>NodeList</code> objects and arrays has always been a bit difficult. Both <code>NodeList</code> objects and arrays use the <code>length</code> property to indicate the number of items, and both use bracket notation to access individual items. Internally, however, a <code>NodeList</code> and an array behave quite differently, which has led to a lot of confusion.</p>

<p>With the addition of default iterators in ECMAScript 6, the DOM definition of <code>NodeList</code> (included in the HTML specification rather than ECMAScript 6 itself) includes a default iterator that behaves in the same manner as the array default iterator. That means you can use <code>NodeList</code> in a <code>for-of</code> loop or any other place that uses an object's default iterator. For example:</p>

<figure class="code">
<pre><code>var divs = document.getElementsByTagName("div");

for (let div of divs) {
    console.log(div.id);
}
</code></pre>

</figure>

<p>This code calls <code>getElementsByTagName()</code> to retrieve a <code>NodeList</code> that represents all of the <code>&lt;div&gt;</code> elements in the <code>document</code> object. The <code>for-of</code> loop then iterates over each element and outputs the element IDs, effectively making the code the same as it would be for a standard array.</p>

<h3 id="leanpub-auto-the-spread-operator-and-non-array-iterables">The Spread Operator and Non-Array Iterables</h3>

<p>Recall from Chapter 7 that the spread operator (<code>...</code>) can be used to convert a set into an array. For example:</p>

<figure class="code">
<pre><code>let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             // [1,2,3,4,5]
</code></pre>

</figure>

<p>This code uses the spread operator inside an array literal to fill in that array with the values from <code>set</code>. The spread operator works on all iterables and uses the default iterator to determine which values to include. All values are read from the iterator and inserted into the array in the order in which values were returned from the iterator. This example works because sets are iterables, but it can work equally well on any iterable. Here's another example:</p>

<figure class="code">
<pre><code>let map = new Map([ ["name", "Nicholas"], ["age", 25]]),
    array = [...map];

console.log(array);         // [ ["name", "Nicholas"], ["age", 25]]
</code></pre>

</figure>

<p>Here, the spread operator converts <code>map</code> into an array of arrays. Since the default iterator for maps returns key-value pairs, the resulting array looks like the array that was passed during the <code>new Map()</code> call.</p>

<p>You can use the spread operator in an array literal as many times as you want, and you can use it wherever you want to insert multiple items from an iterable. Those items will just appear in order in the new array at the location of the spread operator. For example:</p>

<figure class="code">
<pre><code>let smallNumbers = [1, 2, 3],
    bigNumbers = [100, 101, 102],
    allNumbers = [0, ...smallNumbers, ...bigNumbers];

console.log(allNumbers.length);     // 7
console.log(allNumbers);    // [0, 1, 2, 3, 100, 101, 102]
</code></pre>

</figure>

<p>The spread operator is used to create <code>allNumbers</code> from the values in <code>smallNumbers</code> and <code>bigNumbers</code>. The values are placed in <code>allNumbers</code> in the same order the arrays are added when <code>allNumbers</code> is created: <code>0</code> is first, followed by the values from <code>smallNumbers</code>, followed by the values from <code>bigNumbers</code>. The original arrays are unchanged, though, as their values have just been copied into <code>allNumbers</code>.</p>

<p>Since the spread operator can be used on any iterable, it's the easiest way to convert an iterable into an array. You can convert strings into arrays of characters (not code units) and <code>NodeList</code> objects in the browser into arrays of nodes.</p>

<p>Now that you understand the basics of how iterators work, including <code>for-of</code> and the spread operator, it's time to look at some more complex uses of iterators.</p>

<h3 id="leanpub-auto-advanced-iterator-functionality">Advanced Iterator Functionality</h3>

<p>You can accomplish a lot with the basic functionality of iterators and the convenience of creating them using generators. However, iterators are much more powerful when used for tasks other than simply iterating over a collection of values. During the development of ECMAScript 6, a lot of unique ideas and patterns emerged that encouraged the creators to add more functionality. Some of those additions are subtle, but when used together, can accomplish some interesting interactions.</p>

<h4 id="leanpub-auto-passing-arguments-to-iterators">Passing Arguments to Iterators</h4>

<p>Throughout this chapter, examples have shown iterators passing values out via the <code>next()</code> method or by using <code>yield</code> in a generator. But you can also pass arguments to the iterator through the <code>next()</code> method. When an argument is passed to the <code>next()</code> method, that argument becomes the value of the <code>yield</code> statement inside a generator. This capability is important for more advanced functionality such as asynchronous programming. Here's a basic example:</p>

<figure class="code">
<pre><code>function *createIterator() {
    let first = yield 1;
    let second = yield first + 2;       // 4 + 2
    yield second + 3;                   // 5 + 3
}

let iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next(4));          // "{ value: 6, done: false }"
console.log(iterator.next(5));          // "{ value: 8, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>The first call to <code>next()</code> is a special case where any argument passed to it is lost. Since arguments passed to <code>next()</code> become the values returned by <code>yield</code>, an argument from the first call to <code>next()</code> could only replace the first yield statement in the generator function if it could be accessed before that <code>yield</code> statement. That's not possible, so there's no reason to pass an argument the first time <code>next()</code> is called.</p>

<p>On the second call to <code>next()</code>, the value <code>4</code> is passed as the argument. The <code>4</code> ends up assigned to the variable <code>first</code> inside the generator function. In a <code>yield</code> statement including an assignment, the right side of the expression is evaluated on the first call to <code>next()</code> and the left side is evaluated on the second call to <code>next()</code> before the function continues executing. Since the second call to <code>next()</code> passes in <code>4</code>, that value is assigned to <code>first</code> and then execution continues.</p>

<p>The second <code>yield</code> uses the result of the first <code>yield</code> and adds two, which means it returns a value of six. When <code>next()</code> is called a third time, the value <code>5</code> is passed as an argument. That value is assigned to the variable <code>second</code> and then used in the third <code>yield</code> statement to return <code>8</code>.</p>

<p>It's a bit easier to think about what's happening by considering which code is executing each time execution continues inside the generator function. Figure 8-1 uses colors to show the code being executed before yielding.</p>


<figure class="image center">
  <img src="/site_images/understandinges6/fg0601.png" alt="Figure 8-1: Code execution inside a generator" draggable="true" data-bukket-ext-bukket-draggable="true">
  <figcaption>Figure 8-1: Code execution inside a generator</figcaption>
</figure>


<p>The color yellow represents the first call to <code>next()</code> and all the code executed inside of the generator as a result. The color aqua represents the call to <code>next(4)</code> and the code that is executed with that call. The color purple represents the call to <code>next(5)</code> and the code that is executed as a result. The tricky part is how the code on the right side of each expression executes and stops before the left side is executed. This makes debugging complicated generators a bit more involved than debugging regular functions.</p>

<p>So far, you've seen that <code>yield</code> can act like <code>return</code> when a value is passed to the <code>next()</code> method. However, that's not the only execution trick you can do inside a generator. You can also cause iterators throw an error.</p>

<h4 id="leanpub-auto-throwing-errors-in-iterators">Throwing Errors in Iterators</h4>

<p>It's possible to pass not just data into iterators but also error conditions. Iterators can choose to implement a <code>throw()</code> method that instructs the iterator to throw an error when it resumes. This is an important capability for asynchronous programming, but also for flexibility inside generators, where you want to be able to mimic both return values and thrown errors (the two ways of exiting a function). You can pass an error object to <code>throw()</code> that should be thrown when the iterator continues processing. For example:</p>

<figure class="code">
<pre><code>function *createIterator() {
    let first = yield 1;
    let second = yield first + 2;       // yield 4 + 2, then throw
    yield second + 3;                   // never is executed
}

let iterator = createIterator();

console.log(iterator.next());                   // "{ value: 1, done: false }"
console.log(iterator.next(4));                  // "{ value: 6, done: false }"
console.log(iterator.throw(new Error("Boom"))); // error thrown from generator
</code></pre>

</figure>

<p>In this example, the first two <code>yield</code> expressions are evaluated as normal, but when <code>throw()</code> is called, an error is thrown before <code>let second</code> is evaluated. This effectively halts code execution similar to directly throwing an error. The only difference is the location in which the error is thrown. Figure 8-2 shows which code is executed at each step.</p>


<figure class="image center">
  <img src="/site_images/understandinges6/fg0602.png" alt="Figure 8-2: Throwing an error inside a generator" draggable="true" data-bukket-ext-bukket-draggable="true">
  <figcaption>Figure 8-2: Throwing an error inside a generator</figcaption>
</figure>


<p>In this figure, the color red represents the code executed when <code>throw()</code> is called, and the red star shows approximately when the error is thrown inside the generator. The first two <code>yield</code> statements are executed, and when <code>throw()</code> is called, an error is thrown before any other code executes.</p>

<p>Knowing this, you can catch such errors inside the generator using a <code>try-catch</code> block:</p>

<figure class="code">
<pre><code>function *createIterator() {
    let first = yield 1;
    let second;

    try {
        second = yield first + 2;       // yield 4 + 2, then throw
    } catch (ex) {
        second = 6;                     // on error, assign a different value
    }
    yield second + 3;
}

let iterator = createIterator();

console.log(iterator.next());                   // "{ value: 1, done: false }"
console.log(iterator.next(4));                  // "{ value: 6, done: false }"
console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }"
console.log(iterator.next());                   // "{ value: undefined, done:\
 true }"
</code></pre>

</figure>

<p>In this example, a <code>try-catch</code> block is wrapped around the second <code>yield</code> statement. While this <code>yield</code> executes without error, the error is thrown before any value can be assigned to <code>second</code>, so the <code>catch</code> block assigns it a value of six. Execution then flows to the next <code>yield</code> and returns nine.</p>

<p>Notice that something interesting happened: the <code>throw()</code> method returned a result object just like the <code>next()</code> method. Because the error was caught inside the generator, code execution continued on to the next <code>yield</code> and returned the next value, <code>9</code>.</p>

<p>It helps to think of <code>next()</code> and <code>throw()</code> as both being instructions to the iterator. The <code>next()</code> method instructs the iterator to continue executing (possibly with a given value) and <code>throw()</code> instructs the iterator to continue executing by throwing an error. What happens after that point depends on the code inside the generator.</p>

<p>The <code>next()</code> and <code>throw()</code> methods control execution inside an iterator when using <code>yield</code>, but you can also use the <code>return</code> statement. But <code>return</code> works a bit differently than it does in regular functions, as you will see in the next section.</p>

<h4 id="leanpub-auto-generator-return-statements">Generator Return Statements</h4>

<p>Since generators are functions, you can use the <code>return</code> statement both to exit early and  specify a return value for the last call to the <code>next()</code> method. In most examples in this chapter, the last call to <code>next()</code> on an iterator returns <code>undefined</code>, but you can specify an alternate value by using <code>return</code> as you would in any other function. In a generator, <code>return</code> indicates that all processing is done, so the <code>done</code> property is set to <code>true</code> and the value, if provided, becomes the <code>value</code> field. Here's an example that simply exits early using <code>return</code>:</p>

<figure class="code">
<pre><code>function *createIterator() {
    yield 1;
    return;
    yield 2;
    yield 3;
}

let iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>In this code, the generator has a <code>yield</code> statement followed by a <code>return</code> statement. The <code>return</code> indicates that there are no more values to come, and so the rest of the <code>yield</code> statements will not execute (they are unreachable).</p>

<p>You can also specify a return value that will end up in the <code>value</code> field of the returned object. For example:</p>

<figure class="code">
<pre><code>function *createIterator() {
    yield 1;
    return 42;
}

let iterator = createIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 42, done: true }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>Here, the value <code>42</code> is returned in the <code>value</code> field on the second call to the <code>next()</code> method (which is the first time that <code>done</code> is <code>true</code>). The third call to <code>next()</code> returns an object whose <code>value</code> property is once again <code>undefined</code>. Any value you specify with <code>return</code> is only available on the returned object one time before the <code>value</code> field is reset to <code>undefined</code>.</p>

<aside class="information blurb">
    <p>The spread operator and <code>for-of</code> ignore any value specified by a <code>return</code> statement. As soon as they see <code>done</code> is <code>true</code>, they stop without reading the <code>value</code>. Iterator return values are helpful, however, when delegating generators.</p>

</aside>

<h4 id="leanpub-auto-delegating-generators">Delegating Generators</h4>

<p>In some cases, combining the values from two iterators into one is useful. Generators can delegate to other iterators using a special form of <code>yield</code> with a star (<code>*</code>) character. As with generator definitions, where the star appears doesn't matter, as long as the star falls between the <code>yield</code> keyword and the generator function name. Here's an example:</p>

<figure class="code">
<pre><code>function *createNumberIterator() {
    yield 1;
    yield 2;
}

function *createColorIterator() {
    yield "red";
    yield "green";
}

function *createCombinedIterator() {
    yield *createNumberIterator();
    yield *createColorIterator();
    yield true;
}

var iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: "red", done: false }"
console.log(iterator.next());           // "{ value: "green", done: false }"
console.log(iterator.next());           // "{ value: true, done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>In this example, the <code>createCombinedIterator()</code> generator delegates first to the iterator returned from <code>createNumberIterator()</code> and then to the iterator returned from <code>createColorIterator()</code>. The iterator returned from <code>createCombinedIterator()</code> appears, from the outside, to be one consistent iterator that has produced all of the values. Each call to <code>next()</code> is delegated to the appropriate iterator until the iterators created by <code>createNumberIterator()</code> and <code>createColorIterator()</code> are empty. Then the final <code>yield</code> is executed to return <code>true</code>.</p>

<p>Generator delegation also lets you make further use of generator return values. This is the easiest way to access such returned values and can be quite useful in performing complex tasks. For example:</p>

<figure class="code">
<pre><code>function *createNumberIterator() {
    yield 1;
    yield 2;
    return 3;
}

function *createRepeatingIterator(count) {
    for (let i=0; i &lt; count; i++) {
        yield "repeat";
    }
}

function *createCombinedIterator() {
    let result = yield *createNumberIterator();
    yield *createRepeatingIterator(result);
}

var iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>Here, the <code>createCombinedIterator()</code> generator delegates to <code>createNumberIterator()</code> and assigns the return value to <code>result</code>. Since <code>createNumberIterator()</code> contains <code>return 3</code>, the returned value is <code>3</code>. The <code>result</code> variable is then passed to <code>createRepeatingIterator()</code> as an argument indicating how many times to yield the same string (in this case, three times).</p>

<p>Notice that the value <code>3</code> was never output from any call to the <code>next()</code> method. Right now, it exists solely inside the <code>createCombinedIterator()</code> generator. But you can output that value as well by adding another <code>yield</code> statement, such as:</p>

<figure class="code">
<pre><code>function *createNumberIterator() {
    yield 1;
    yield 2;
    return 3;
}

function *createRepeatingIterator(count) {
    for (let i=0; i &lt; count; i++) {
        yield "repeat";
    }
}

function *createCombinedIterator() {
    let result = yield *createNumberIterator();
    yield result;
    yield *createRepeatingIterator(result);
}

var iterator = createCombinedIterator();

console.log(iterator.next());           // "{ value: 1, done: false }"
console.log(iterator.next());           // "{ value: 2, done: false }"
console.log(iterator.next());           // "{ value: 3, done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: "repeat", done: false }"
console.log(iterator.next());           // "{ value: undefined, done: true }"
</code></pre>

</figure>

<p>In this code, the extra <code>yield</code> statement explicitly outputs the returned value from the <code>createNumberIterator()</code> generator.</p>

<p>Generator delegation using the return value is a very powerful paradigm that allows for some very interesting possibilities, especially when used in conjunction with asynchronous operations.</p>

<aside class="information blurb">
    <p>You can use <code>yield *</code> directly on strings (such as <code>yield * "hello"</code>) and the string's default iterator will be used.</p>

</aside>

<h3 id="leanpub-auto-asynchronous-task-running">Asynchronous Task Running</h3>

<p>A lot of the excitement around generators is directly related to asynchronous programming. Asynchronous programming in JavaScript is a double-edged sword: simple tasks are easy to do asynchronously, while complex tasks become an errand in code organization. Since generators allow you to effectively pause code in the middle of execution, they open up a lot of possibilities related to asynchronous processing.</p>

<p>The traditional way to perform asynchronous operations is to call a function that has a callback. For example, consider reading a file from the disk in Node.js:</p>

<figure class="code">
<pre><code>let fs = require("fs");

fs.readFile("config.json", function(err, contents) {
    if (err) {
        throw err;
    }

    doSomethingWith(contents);
    console.log("Done");
});
</code></pre>

</figure>

<p>The <code>fs.readFile()</code> method is called with the filename to read and a callback function. When the operation is finished, the callback function is called. The callback checks to see if there's an error, and if not, processes the returned <code>contents</code>. This works well when you have a small, finite number of asynchronous tasks to complete, but gets complicated when you need to nest callbacks or otherwise sequence a series of asynchronous tasks. This is where generators and <code>yield</code> are helpful.</p>

<h4 id="leanpub-auto-a-simple-task-runner">A Simple Task Runner</h4>

<p>Because <code>yield</code> stops execution and waits for the <code>next()</code> method to be called before starting again, you can implement asynchronous calls without managing callbacks. To start, you need a function that can call a generator and start the iterator, such as this:</p>

<figure class="code">
<pre><code>function run(taskDef) {

    // create the iterator, make available elsewhere
    let task = taskDef();

    // start the task
    let result = task.next();

    // recursive function to keep calling next()
    function step() {

        // if there's more to do
        if (!result.done) {
            result = task.next();
            step();
        }
    }

    // start the process
    step();

}
</code></pre>

</figure>

<p>The <code>run()</code> function accepts a task definition (a generator function) as an argument. It calls the generator to create an iterator and stores the iterator in <code>task</code>. The <code>task</code> variable is outside the function so it can be accessed by other functions; I will explain why later in this section. The first call to <code>next()</code> begins the iterator and the result is stored for later use. The <code>step()</code> function checks to see if <code>result.done</code> is false and, if so, calls <code>next()</code> before recursively calling itself. Each call to <code>next()</code> stores the return value in <code>result</code>, which is always overwritten to contain the latest information. The initial call to <code>step()</code> starts the process of looking at the <code>result.done</code> variable to see whether there's more to do.</p>

<p>With this implementation of <code>run()</code>, you can run a generator containing multiple <code>yield</code> statements, such as:</p>

<figure class="code">
<pre><code>run(function*() {
    console.log(1);
    yield;
    console.log(2);
    yield;
    console.log(3);
});
</code></pre>

</figure>

<p>This example just outputs three numbers to the console, which simply shows that all calls to <code>next()</code> are being made. However, just yielding a couple of times isn't very useful. The next step is to pass values into and out of the iterator.</p>

<h4 id="leanpub-auto-task-running-with-data">Task Running With Data</h4>

<p>The easiest way to pass data through the task runner is to pass the value specified by <code>yield</code> into the next call to the <code>next()</code> method. To do so, you need only pass <code>result.value</code>, as in this code:</p>

<figure class="code">
<pre><code>function run(taskDef) {

    // create the iterator, make available elsewhere
    let task = taskDef();

    // start the task
    let result = task.next();

    // recursive function to keep calling next()
    function step() {

        // if there's more to do
        if (!result.done) {
            result = task.next(result.value);
            step();
        }
    }

    // start the process
    step();

}
</code></pre>

</figure>

<p>Now that <code>result.value</code> is passed to <code>next()</code> as an argument, it's possible to pass data between <code>yield</code> calls, like this:</p>

<figure class="code">
<pre><code>run(function*() {
    let value = yield 1;
    console.log(value);         // 1

    value = yield value + 3;
    console.log(value);         // 4
});
</code></pre>

</figure>

<p>This example outputs two values to the console: 1 and 4. The value 1 comes from <code>yield 1</code>, as the 1 is passed right back into the <code>value</code> variable. The 4 is calculated by adding 3 to <code>value</code> and passing that result back to <code>value</code>. Now that data is flowing between calls to <code>yield</code>, you just need one small change to allow asynchronous calls.</p>

<h4 id="leanpub-auto-asynchronous-task-runner">Asynchronous Task Runner</h4>

<p>The previous example passed static data back and forth between <code>yield</code> calls, but waiting for an asynchronous process is slightly different. The task runner needs to know about callbacks and how to use them. And since <code>yield</code> expressions pass their values into the task runner, that means any function call must return a value that somehow indicates the call is an asynchronous operation that the task runner should wait for.</p>

<p>Here's one way you might signal that a value is an asynchronous operation:</p>

<figure class="code">
<pre><code>function fetchData() {
    return function(callback) {
        callback(null, "Hi!");
    };
}
</code></pre>

</figure>

<p>For the purposes of this example, any function meant to be called by the task runner will return a function that executes a callback. The <code>fetchData()</code> function returns a function that accepts a callback function as an argument. When the returned function is called, it executes the callback function with a single piece of data (the <code>"Hi!"</code> string). The <code>callback</code> argument needs to come from the task runner to ensure executing the callback correctly interacts with the underlying iterator. While the <code>fetchData()</code> function is synchronous, you can easily extend it to be asynchronous by calling the callback with a slight delay, such as:</p>

<figure class="code">
<pre><code>function fetchData() {
    return function(callback) {
        setTimeout(function() {
            callback(null, "Hi!");
        }, 50);
    };
}
</code></pre>

</figure>

<p>This version of <code>fetchData()</code> introduces a 50ms delay before calling the callback, demonstrating that this pattern works equally well for synchronous and asynchronous code. You just have to make sure each function that wants to be called using <code>yield</code> follows the same pattern.</p>

<p>With a good understanding of how a function can signal that it's an asynchronous process, you can modify the task runner to take that fact into account. Anytime <code>result.value</code> is a function, the task runner will execute it instead of just passing that value to the <code>next()</code> method. Here's the updated code:</p>

<figure class="code">
<pre><code>function run(taskDef) {

    // create the iterator, make available elsewhere
    let task = taskDef();

    // start the task
    let result = task.next();

    // recursive function to keep calling next()
    function step() {

        // if there's more to do
        if (!result.done) {
            if (typeof result.value === "function") {
                result.value(function(err, data) {
                    if (err) {
                        result = task.throw(err);
                        return;
                    }

                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }

        }
    }

    // start the process
    step();

}
</code></pre>

</figure>

<p>When <code>result.value</code> is a function (checked with the <code>===</code> operator), it is called with a callback function. That callback function follows the Node.js convention of passing any possible error as the first argument (<code>err</code>) and the result as the second argument. If <code>err</code> is present, then that means an error occurred and <code>task.throw()</code> is called with the error object instead of <code>task.next()</code> so an error is thrown at the correct location. If there is no error, then <code>data</code> is passed into <code>task.next()</code> and the result is stored. Then, <code>step()</code> is called to continue the process. When <code>result.value</code> is not a function, it is directly passed to the <code>next()</code> method.</p>

<p>This new version of the task runner is ready for all asynchronous tasks. To read data from a file in Node.js, you need to create a wrapper around <code>fs.readFile()</code> that returns a function similar to the <code>fetchData()</code> function from the beginning of this section. For example:</p>

<figure class="code">
<pre><code>let fs = require("fs");

function readFile(filename) {
    return function(callback) {
        fs.readFile(filename, callback);
    };
}
</code></pre>

</figure>

<p>The <code>readFile()</code> method accepts a single argument, the filename, and returns a function that calls a callback. The callback is passed directly to the <code>fs.readFile()</code> method, which will execute the callback upon completion. You can then run this task using <code>yield</code> as follows:</p>

<figure class="code">
<pre><code>run(function*() {
    let contents = yield readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
</code></pre>

</figure>

<p>This example is performing the asynchronous <code>readFile()</code> operation without making any callbacks visible in the main code. Aside from <code>yield</code>, the code looks the same as synchronous code. As long as the functions performing asynchronous operations all conform to the same interface, you can write logic that reads like synchronous code.</p>

<p>Of course, there are downsides to the pattern used in these examples–namely that you can't always be sure a function that returns a function is asynchronous. For now, though, it's only important that you understand the theory behind the task running. Using promises offers more powerful ways of scheduling asynchronous tasks, and Chapter 11 covers this topic further.</p>

<h3 id="leanpub-auto-summary-7">Summary</h3>

<p>Iterators are an important part of ECMAScript 6 and are at the root of several key language elements. On the surface, iterators provide a simple way to return a sequence of values using a simple API. However, there are far more complex ways to use iterators in ECMAScript 6.</p>

<p>The <code>Symbol.iterator</code> symbol is used to define default iterators for objects. Both built-in objects and developer-defined objects can use this symbol to provide a method that returns an iterator. When <code>Symbol.iterator</code> is provided on an object, the object is considered an iterable.</p>

<p>The <code>for-of</code> loop uses iterables to return a series of values in a loop. Using <code>for-of</code> is easier than iterating with a traditional <code>for</code> loop because you no longer need to track values and control when the loop ends. The <code>for-of</code> loop automatically reads all values from the iterator until there are no more, and then it exits.</p>

<p>To make <code>for-of</code> easier to use, many values in ECMAScript 6 have default iterators. All the collection types–that is, arrays, maps, and sets–have iterators designed to make their contents easy to access. Strings also have a default iterator, which makes iterating over the characters of the string (rather than the code units) easy.</p>

<p>The spread operator works with any iterable and makes converting iterables into arrays easy, too. The conversion works by reading values from an iterator and inserting them individually into an array.</p>

<p>A generator is a special function that automatically creates an iterator when called. Generator definitions are indicated by a star (<code>*</code>) character and use of the <code>yield</code> keyword to indicate which value to return for each successive call to the <code>next()</code> method.</p>

<p>Generator delegation encourages good encapsulation of iterator behavior by letting you reuse existing generators in new generators. You can use an existing generator inside another generator by calling <code>yield *</code> instead of <code>yield</code>. This process allows you to create an iterator that returns values from multiple iterators.</p>

<p>Perhaps the most interesting and exciting aspect of generators and iterators is the possibility of creating cleaner-looking asynchronous code. Instead of needing to use callbacks everywhere, you can set up code that looks synchronous but in fact uses <code>yield</code> to wait for asynchronous operations to complete.</p>


<h2 id="leanpub-auto-introducing-javascript-classes">Introducing JavaScript Classes</h2>

<p>Unlike most formal object-oriented programming languages, JavaScript didn't support classes and classical inheritance as the primary way of defining similar and related objects when it was created. This left many developers confused, and from pre-ECMAScript 1 all the way through ECMAScript 5, many libraries created utilities to make JavaScript look like it supports classes. While some JavaScript developers do feel strongly that the language doesn't need classes, the number of libraries created specifically for this purpose led to the inclusion of classes in ECMAScript 6.</p>

<p>While exploring ECMAScript 6 classes, it's helpful to understand the underlying mechanisms that classes use, so this chapter starts by discussing how ECMAScript 5 developers achieved class-like behavior. As you will see after that, however, ECMAScript 6 classes aren't exactly the same as classes in other languages. There's a uniqueness about them that embraces the dynamic nature of JavaScript.</p>

<h3 id="leanpub-auto-class-like-structures-in-ecmascript-5">Class-Like Structures in ECMAScript 5</h3>

<p>In ECMAScript 5 and earlier, JavaScript had no classes. The closest equivalent to a class was creating a constructor and then assigning methods to the constructor's prototype, an approach typically called creating a custom type. For example:</p>

<figure class="code">
<pre><code>function PersonType(name) {
    this.name = name;
}

PersonType.prototype.sayName = function() {
    console.log(this.name);
};

let person = new PersonType("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person instanceof PersonType);  // true
console.log(person instanceof Object);      // true
</code></pre>

</figure>

<p>In this code, <code>PersonType</code> is a constructor function that creates a single property called <code>name</code>. The <code>sayName()</code> method is assigned to the prototype so the same function is shared by all instances of the <code>PersonType</code> object. Then, a new instance of <code>PersonType</code> is created via the <code>new</code> operator. The resulting <code>person</code> object is considered an instance of <code>PersonType</code> and of <code>Object</code> through prototypal inheritance.</p>

<p>This basic pattern underlies a lot of the class-mimicking JavaScript libraries, and that's where ECMAScript 6 classes start.</p>

<h3 id="leanpub-auto-class-declarations">Class Declarations</h3>

<p>The simplest class form in ECMAScript 6 is the class declaration, which looks similar to classes in other languages.</p>

<h4 id="leanpub-auto-a-basic-class-declaration">A Basic Class Declaration</h4>

<p>Class declarations begin with the <code>class</code> keyword followed by the name of the class. The rest of the syntax looks similar to concise methods in object literals, without requiring commas between them. For example, here's a simple class declaration:</p>

<figure class="code">
<pre><code>class PersonClass {

    // equivalent of the PersonType constructor
    constructor(name) {
        this.name = name;
    }

    // equivalent of PersonType.prototype.sayName
    sayName() {
        console.log(this.name);
    }
}

let person = new PersonClass("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person instanceof PersonClass);     // true
console.log(person instanceof Object);          // true

console.log(typeof PersonClass);                    // "function"
console.log(typeof PersonClass.prototype.sayName);  // "function"
</code></pre>

</figure>

<p>The class declaration <code>PersonClass</code> behaves quite similarly to <code>PersonType</code> from the previous example. But instead of defining a function as the constructor, class declarations allow you to define the constructor directly inside the class with the special <code>constructor</code> method name. Since class methods use the concise syntax, there's no need to use the <code>function</code> keyword. All other method names have no special meaning, so you can add as many methods as you want.</p>

<aside class="information blurb">
    <p><em>Own properties</em>, properties that occur on the instance rather than the prototype, can only be created inside a class constructor or method. In this example, <code>name</code> is an own property. I recommend creating all possible own properties inside the constructor function so a single place in the class is responsible for all of them.</p>

</aside>

<p>Interestingly, class declarations are just syntactic sugar on top of the existing custom type declarations. The <code>PersonClass</code> declaration actually creates a function that has the behavior of the <code>constructor</code> method, which is why <code>typeof PersonClass</code> gives <code>"function"</code> as the result. The <code>sayName()</code> method also ends up as a method on <code>PersonClass.prototype</code> in this example, similar to the relationship between <code>sayName()</code> and <code>PersonType.prototype</code> in the previous example. These similarities allow you to mix custom types and classes without worrying too much about which you're using.</p>

<h4 id="leanpub-auto-why-to-use-the-class-syntax">Why to Use the Class Syntax</h4>

<p>Despite the similarities between classes and custom types, there are some important differences to keep in mind:</p>

<ol class="numeric">
  <li>Class declarations, unlike function declarations, are not hoisted. Class declarations act like <code>let</code> declarations and so exist in the temporal dead zone until execution reaches the declaration.</li>
  <li>All code inside of class declarations runs in strict mode automatically. There's no way to opt-out of strict mode inside of classes.</li>
  <li>All methods are non-enumerable. This is a significant change from custom types, where you need to use <code>Object.defineProperty()</code> to make a method non-enumerable.</li>
  <li>All methods lack an internal <code>[[Construct]]</code> method and will throw an error if you try to call them with <code>new</code>.</li>
  <li>Calling the class constructor without <code>new</code> throws an error.</li>
  <li>Attempting to overwrite the class name within a class method throws an error.</li>
</ol>

<p>With all of this in mind, the <code>PersonClass</code> declaration from the previous example is directly equivalent to the following code, which doesn't use the class syntax:</p>

<figure class="code">
<pre><code>// direct equivalent of PersonClass
let PersonType2 = (function() {

    "use strict";

    const PersonType2 = function(name) {

        // make sure the function was called with new
        if (typeof new.target === "undefined") {
            throw new Error("Constructor must be called with new.");
        }

        this.name = name;
    }

    Object.defineProperty(PersonType2.prototype, "sayName", {
        value: function() {

            // make sure the method wasn't called with new
            if (typeof new.target !== "undefined") {
                throw new Error("Method cannot be called with new.");
            }

            console.log(this.name);
        },
        enumerable: false,
        writable: true,
        configurable: true
    });

    return PersonType2;
}());
</code></pre>

</figure>

<p>First, notice that there are two <code>PersonType2</code> declarations: a <code>let</code> declaration in the outer scope and a <code>const</code> declaration inside the IIFE. This is how class methods are forbidden from overwriting the class name while code outside the class is allowed to do so. The constructor function checks <code>new.target</code> to ensure that it's being called with <code>new</code>; if not, an error is thrown. Next, the <code>sayName()</code> method is defined as nonenumerable, and the method checks <code>new.target</code> to ensure that it wasn't called with <code>new</code>. The final step returns the constructor function.</p>

<p>This example shows that while it's possible to do everything classes do without using the new syntax, the class syntax simplifies all of the functionality significantly.</p>

<aside>
  <h4 id="leanpub-auto-constant-class-names">Constant Class Names</h4>

  <p>The name of a class is only specified as if using <code>const</code> inside of the class itself. That means you can overwrite the class name outside of the class but not inside a class method. For example:</p>

  <figure class="code">
<pre><code>class Foo {
   constructor() {
       Foo = "bar";    // throws an error when executed
   }
}

// but this is okay after the class declaration
Foo = "baz";
</code></pre>

  </figure>

  <p>In this code, the <code>Foo</code> inside the class constructor is a separate binding from the <code>Foo</code> outside the class. The internal <code>Foo</code> is defined as if it's a <code>const</code> and cannot be overwritten. An error is thrown when the constructor attempts to overwrite <code>Foo</code> with any value. But since the external <code>Foo</code> is defined as if it's a <code>let</code> declaration, you can overwrite its value at any time.</p>

</aside>

<h3 id="leanpub-auto-class-expressions">Class Expressions</h3>

<p>Classes and functions are similar in that they have two forms: declarations and expressions. Function and class declarations begin with an appropriate keyword (<code>function</code> or <code>class</code>, respectively) followed by an identifier. Functions have an expression form that doesn't require an identifier after <code>function</code>, and similarly, classes have an expression form that doesn't require an identifier after <code>class</code>. These <em>class expressions</em> are designed to be used in variable declarations or passed into functions as arguments.</p>

<h4 id="leanpub-auto-a-basic-class-expression">A Basic Class Expression</h4>

<p>Here's the class expression equivalent of the previous <code>PersonClass</code> examples, followed by some code that uses it:</p>

<figure class="code">
<pre><code>let PersonClass = class {

    // equivalent of the PersonType constructor
    constructor(name) {
        this.name = name;
    }

    // equivalent of PersonType.prototype.sayName
    sayName() {
        console.log(this.name);
    }
};

let person = new PersonClass("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person instanceof PersonClass);     // true
console.log(person instanceof Object);          // true

console.log(typeof PersonClass);                    // "function"
console.log(typeof PersonClass.prototype.sayName);  // "function"
</code></pre>

</figure>

<p>As this example demonstrates, class expressions do not require identifiers after <code>class</code>. Aside from the syntax, class expressions are functionally equivalent to class declarations.</p>

<p>Whether you use class declarations or class expressions is mostly a matter of style. Unlike function declarations and function expressions, both class declarations and class expressions are not hoisted, and so the choice has little bearing on the runtime behavior of the code.</p>

<h4 id="leanpub-auto-named-class-expressions">Named Class Expressions</h4>

<p>The previous section used an anonymous class expression in the example, but just like function expressions, you can also name class expressions. To do so, include an identifier after the <code>class</code> keyword like this:</p>

<figure class="code">
<pre><code>let PersonClass = class PersonClass2 {

    // equivalent of the PersonType constructor
    constructor(name) {
        this.name = name;
    }

    // equivalent of PersonType.prototype.sayName
    sayName() {
        console.log(this.name);
    }
};

console.log(typeof PersonClass);        // "function"
console.log(typeof PersonClass2);       // "undefined"
</code></pre>

</figure>

<p>In this example, the class expression is named <code>PersonClass2</code>. The <code>PersonClass2</code> identifier exists only within the class definition so that it can be used inside the class methods (such as the <code>sayName()</code> method in this example). Outside the class, <code>typeof PersonClass2</code> is <code>"undefined"</code> because no <code>PersonClass2</code> binding exists there. To understand why this is, look at an equivalent declaration that doesn't use classes:</p>

<figure class="code">
<pre><code>// direct equivalent of PersonClass named class expression
let PersonClass = (function() {

    "use strict";

    const PersonClass2 = function(name) {

        // make sure the function was called with new
        if (typeof new.target === "undefined") {
            throw new Error("Constructor must be called with new.");
        }

        this.name = name;
    }

    Object.defineProperty(PersonClass2.prototype, "sayName", {
        value: function() {

            // make sure the method wasn't called with new
            if (typeof new.target !== "undefined") {
                throw new Error("Method cannot be called with new.");
            }

            console.log(this.name);
        },
        enumerable: false,
        writable: true,
        configurable: true
    });

    return PersonClass2;
}());
</code></pre>

</figure>

<p>Creating a named class expression slightly changes what's happening in the JavaScript engine. For class declarations, the outer binding (defined with <code>let</code>) has the same name as the inner binding (defined with <code>const</code>). A named class expression uses its name in the <code>const</code> definition, so <code>PersonClass2</code> is defined for use only inside the class.</p>

<p>While named class expressions behave differently from named function expressions, there are still a lot of similarities between the two. Both can be used as values, and that opens up a lot of possibilities, which I'll cover next.</p>

<h3 id="leanpub-auto-classes-as-first-class-citizens">Classes as First-Class Citizens</h3>

<p>In programming, something is said to be a <em>first-class citizen</em> when it can be used as a value, meaning it can be passed into a function, returned from a function, and assigned to a variable. JavaScript functions are first-class citizens (sometimes they're just called first class functions), and that's part of what makes JavaScript unique.</p>

<p>ECMAScript 6 continues this tradition by making classes first-class citizens as well. That allows classes to be used in a lot of different ways. For example, they can be passed into functions as arguments:</p>

<figure class="code">
<pre><code>function createObject(classDef) {
    return new classDef();
}

let obj = createObject(class {

    sayHi() {
        console.log("Hi!");
    }
});

obj.sayHi();        // "Hi!"
</code></pre>

</figure>

<p>In this example, the <code>createObject()</code> function is called with an anonymous class expression as an argument, creates an instance of that class with <code>new</code>, and returns the instance. The variable <code>obj</code> then stores the returned instance.</p>

<p>Another interesting use of class expressions is creating singletons by immediately invoking the class constructor. To do so, you must use <code>new</code> with a class expression and include parentheses at the end. For example:</p>

<figure class="code">
<pre><code>let person = new class {

    constructor(name) {
        this.name = name;
    }

    sayName() {
        console.log(this.name);
    }

}("Nicholas");

person.sayName();       // "Nicholas"
</code></pre>

</figure>

<p>Here, an anonymous class expression is created and then executed immediately. This pattern allows you to use the class syntax for creating singletons without leaving a class reference available for inspection. (Remember that <code>PersonClass</code> only creates a binding inside of the class, not outside.) The parentheses at the end of the class expression are the indicator that you're calling a function while also allowing you to pass in an argument.</p>

<p>The examples in this chapter so far have focused on classes with methods. But you can also create accessor properties on classes using a syntax similar to object literals.</p>

<h3 id="leanpub-auto-accessor-properties">Accessor Properties</h3>

<p>While own properties should be created inside class constructors, classes allow you to define accessor properties on the prototype. To create a getter, use the keyword <code>get</code> followed by a space, followed by an identifier; to create a setter, do the same using the keyword <code>set</code>. For example:</p>

<figure class="code">
<pre><code>class CustomHTMLElement {

    constructor(element) {
        this.element = element;
    }

    get html() {
        return this.element.innerHTML;
    }

    set html(value) {
        this.element.innerHTML = value;
    }
}

var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype,\
 "html");
console.log("get" in descriptor);   // true
console.log("set" in descriptor);   // true
console.log(descriptor.enumerable); // false
</code></pre>

</figure>

<p>In this code, the <code>CustomHTMLElement</code> class is made as a wrapper around an existing DOM element. It has both a getter and setter for <code>html</code> that delegates to the <code>innerHTML</code> method on the element itself. This accessor property is created on the <code>CustomHTMLElement.prototype</code> and, just like any other method would be, is created as non-enumerable. The equivalent non-class representation is:</p>

<figure class="code">
<pre><code>// direct equivalent to previous example
let CustomHTMLElement = (function() {

    "use strict";

    const CustomHTMLElement = function(element) {

        // make sure the function was called with new
        if (typeof new.target === "undefined") {
            throw new Error("Constructor must be called with new.");
        }

        this.element = element;
    }

    Object.defineProperty(CustomHTMLElement.prototype, "html", {
        enumerable: false,
        configurable: true,
        get: function() {
            return this.element.innerHTML;
        },
        set: function(value) {
            this.element.innerHTML = value;
        }
    });

    return CustomHTMLElement;
}());
</code></pre>

</figure>

<p>As with previous examples, this one shows just how much code you can save by using a class instead of the non-class equivalent. The <code>html</code> accessor property definition alone is almost the size of the equivalent class declaration.</p>

<h3 id="leanpub-auto-computed-member-names">Computed Member Names</h3>

<p>The similarities between object literals and classes aren't quite over yet. Class methods and accessor properties can also have computed names. Instead of using an identifier, use square brackets around an expression, which is the same syntax used for object literal computed names. For example:</p>

<figure class="code">
<pre><code>let methodName = "sayName";

class PersonClass {

    constructor(name) {
        this.name = name;
    }

    [methodName]() {
        console.log(this.name);
    }
}

let me = new PersonClass("Nicholas");
me.sayName();           // "Nicholas"
</code></pre>

</figure>

<p>This version of <code>PersonClass</code> uses a variable to assign a name to a method inside its definition. The string <code>"sayName"</code> is assigned to the <code>methodName</code> variable, and then <code>methodName</code> is used to declare the method. The <code>sayName()</code> method is later accessed directly.</p>

<p>Accessor properties can use computed names in the same way, like this:</p>

<figure class="code">
<pre><code>let propertyName = "html";

class CustomHTMLElement {

    constructor(element) {
        this.element = element;
    }

    get [propertyName]() {
        return this.element.innerHTML;
    }

    set [propertyName](value) {
        this.element.innerHTML = value;
    }
}
</code></pre>

</figure>

<p>Here, the getter and setter for <code>html</code> are set using the <code>propertyName</code> variable. Accessing the property by using <code>.html</code> only affects the definition.</p>

<p>You've seen that there are a lot of similarities between classes and object literals, with methods, accessor properties, and computed names. There's just one more similarity to cover: generators.</p>

<h3 id="leanpub-auto-generator-methods">Generator Methods</h3>

<p>When Chapter 8 introduced generators, you learned how to define a generator on an object literal by prepending a star (<code>*</code>) to the method name. The same syntax works for classes as well, allowing any method to be a generator. Here's an example:</p>

<figure class="code">
<pre><code>class MyClass {

    *createIterator() {
        yield 1;
        yield 2;
        yield 3;
    }

}

let instance = new MyClass();
let iterator = instance.createIterator();
</code></pre>

</figure>

<p>This code creates a class called <code>MyClass</code> with a <code>createIterator()</code> generator method. The method returns an iterator whose values are hardcoded into the generator. Generator methods are useful when you have an object that represents a collection of values and you'd like to iterate over those values easily. Arrays, sets, and maps all have multiple generator methods to account for the different ways developers need to interact with their items.</p>

<p>While generator methods are useful, defining a default iterator for your class is much more helpful if the class represents a collection of values. You can define the default iterator for a class by using <code>Symbol.iterator</code> to define a generator method, such as:</p>

<figure class="code">
<pre><code>class Collection {

    constructor() {
        this.items = [];
    }

    *[Symbol.iterator]() {
        yield *this.items.values();
    }
}

var collection = new Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
    console.log(x);
}

// Output:
// 1
// 2
// 3
</code></pre>

</figure>

<p>This example uses a computed name for a generator method that delegates to the <code>values()</code> iterator of the <code>this.items</code> array. Any class that manages a collection of values should include a default iterator because some collection-specific operations require collections they operate on to have an iterator. Now, any instance of <code>Collection</code> can be used directly in a <code>for-of</code> loop or with the spread operator.</p>

<p>Adding methods and accessor properties to a class prototype is useful when you want those to show up on object instances. If, on the other hand, you'd like methods or accessor properties on the class itself, then you'll need to use static members.</p>

<h3 id="leanpub-auto-static-members">Static Members</h3>

<p>Adding additional methods directly onto constructors to simulate static members is another common pattern in ECMAScript 5 and earlier. For example:</p>

<figure class="code">
<pre><code>function PersonType(name) {
    this.name = name;
}

// static method
PersonType.create = function(name) {
    return new PersonType(name);
};

// instance method
PersonType.prototype.sayName = function() {
    console.log(this.name);
};

var person = PersonType.create("Nicholas");
</code></pre>

</figure>

<p>In other programming languages, the factory method called <code>PersonType.create()</code> would be considered a static method, as it doesn't depend on an instance of <code>PersonType</code> for its data. ECMAScript 6 classes simplify the creation of static members by using the formal <code>static</code> annotation before the method or accessor property name. For instance, here's the class equivalent of the last example:</p>

<figure class="code">
<pre><code>class PersonClass {

    // equivalent of the PersonType constructor
    constructor(name) {
        this.name = name;
    }

    // equivalent of PersonType.prototype.sayName
    sayName() {
        console.log(this.name);
    }

    // equivalent of PersonType.create
    static create(name) {
        return new PersonClass(name);
    }
}

let person = PersonClass.create("Nicholas");
</code></pre>

</figure>

<p>The <code>PersonClass</code> definition has a single static method called <code>create()</code>. The method syntax is the same used for <code>sayName()</code> except for the <code>static</code> keyword. You can use the <code>static</code> keyword on any method or accessor property definition within a class. The only restriction is that you can't use <code>static</code> with the <code>constructor</code> method definition.</p>

<aside class="warning blurb">
    <p>Static members are not accessible from instances. You must always access static members from the class directly.</p>

</aside>

<h3 id="leanpub-auto-inheritance-with-derived-classes">Inheritance with Derived Classes</h3>

<p>Prior to ECMAScript 6, implementing inheritance with custom types was an extensive process. Proper inheritance required multiple steps. For instance, consider this example:</p>

<figure class="code">
<pre><code>function Rectangle(length, width) {
    this.length = length;
    this.width = width;
}

Rectangle.prototype.getArea = function() {
    return this.length * this.width;
};

function Square(length) {
    Rectangle.call(this, length, length);
}

Square.prototype = Object.create(Rectangle.prototype, {
    constructor: {
        value:Square,
        enumerable: true,
        writable: true,
        configurable: true
    }
});

var square = new Square(3);

console.log(square.getArea());              // 9
console.log(square instanceof Square);      // true
console.log(square instanceof Rectangle);   // true
</code></pre>

</figure>

<p><code>Square</code> inherits from <code>Rectangle</code>, and to do so, it must overwrite <code>Square.prototype</code> with a new object created from <code>Rectangle.prototype</code> as well as call the <code>Rectangle.call()</code> method. These steps often confused JavaScript newcomers and were a source of errors for experienced developers.</p>

<p>Classes make inheritance easier to implement by using the familiar <code>extends</code> keyword to specify the function from which the class should inherit. The prototypes are automatically adjusted, and you can access the base class constructor by calling the <code>super()</code> method. Here's the ECMAScript 6 equivalent of the previous example:</p>

<figure class="code">
<pre><code>class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }
}

class Square extends Rectangle {
    constructor(length) {

        // same as Rectangle.call(this, length, length)
        super(length, length);
    }
}

var square = new Square(3);

console.log(square.getArea());              // 9
console.log(square instanceof Square);      // true
console.log(square instanceof Rectangle);   // true
</code></pre>

</figure>

<p>This time, the <code>Square</code> class inherits from <code>Rectangle</code> using the <code>extends</code> keyword. The <code>Square</code> constructor uses <code>super()</code> to call the <code>Rectangle</code> constructor with the specified arguments. Note that unlike the ECMAScript 5 version of the code, the identifier <code>Rectangle</code> is only used within the class declaration (after <code>extends</code>).</p>

<p>Classes that inherit from other classes are referred to as <em>derived classes</em>. Derived classes require you to use <code>super()</code> if you specify a constructor; if you don't, an error will occur. If you choose not to use a constructor, then <code>super()</code> is automatically called for you with all arguments upon creating a new instance of the class. For instance, the following two classes are identical:</p>

<figure class="code">
<pre><code>class Square extends Rectangle {
    // no constructor
}

// Is equivalent to

class Square extends Rectangle {
    constructor(...args) {
        super(...args);
    }
}
</code></pre>

</figure>

<p>The second class in this example shows the equivalent of the default constructor for all derived classes. All of the arguments are passed, in order, to the base class constructor. In this case, the functionality isn't quite correct because the <code>Square</code> constructor needs only one argument, and so it's best to manually define the constructor.</p>

<aside class="warning blurb">
    <p>There are a few things to keep in mind when using <code>super()</code>:</p>

  <ol class="numeric">
    <li>You can only use <code>super()</code> in a derived class. If you try to use it in a non-derived class (a class that doesn't use <code>extends</code>) or a function, it will throw an error.</li>
    <li>You must call <code>super()</code> before accessing <code>this</code> in the constructor. Since <code>super()</code> is responsible for initializing <code>this</code>, attempting to access <code>this</code> before calling <code>super()</code> results in an error.</li>
    <li>The only way to avoid calling <code>super()</code> is to return an object from the class constructor.</li>
  </ol>

</aside>

<h4 id="leanpub-auto-shadowing-class-methods">Shadowing Class Methods</h4>

<p>The methods on derived classes always shadow methods of the same name on the base class. For instance, you can add <code>getArea()</code> to <code>Square</code> to redefine that functionality:</p>

<figure class="code">
<pre><code>class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }

    // override and shadow Rectangle.prototype.getArea()
    getArea() {
        return this.length * this.length;
    }
}
</code></pre>

</figure>

<p>Since <code>getArea()</code> is defined as part of <code>Square</code>, the <code>Rectangle.prototype.getArea()</code> method will no longer be called by any instances of <code>Square</code>. Of course, you can always decide to call the base class version of the method by using the <code>super.getArea()</code> method, like this:</p>

<figure class="code">
<pre><code>class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }

    // override, shadow, and call Rectangle.prototype.getArea()
    getArea() {
        return super.getArea();
    }
}
</code></pre>

</figure>

<p>Using <code>super</code> in this way works the same as the the super references discussed in Chapter 4 (see "Easy Prototype Access With Super References"). The <code>this</code> value is automatically set correctly so you can make a simple method call.</p>

<h4 id="leanpub-auto-inherited-static-members">Inherited Static Members</h4>

<p>If a base class has static members, then those static members are also available on the derived class. Inheritance works like that in other languages, but this is a new concept for JavaScript. Here's an example:</p>

<figure class="code">
<pre><code>class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }

    static create(length, width) {
        return new Rectangle(length, width);
    }
}

class Square extends Rectangle {
    constructor(length) {

        // same as Rectangle.call(this, length, length)
        super(length, length);
    }
}

var rect = Square.create(3, 4);

console.log(rect instanceof Rectangle);     // true
console.log(rect.getArea());                // 12
console.log(rect instanceof Square);        // false
</code></pre>

</figure>

<p>In this code, a new static <code>create()</code> method is added to the <code>Rectangle</code> class. Through inheritance, that method is available as <code>Square.create()</code> and behaves in the same manner as the <code>Rectangle.create()</code> method.</p>

<h4 id="leanpub-auto-derived-classes-from-expressions">Derived Classes from Expressions</h4>

<p>Perhaps the most powerful aspect of derived classes in ECMAScript 6 is the ability to derive a class from an expression. You can use <code>extends</code> with any expression as long as the expression resolves to a function with <code>[[Construct]]</code> and a prototype. For instance:</p>

<figure class="code">
<pre><code>function Rectangle(length, width) {
    this.length = length;
    this.width = width;
}

Rectangle.prototype.getArea = function() {
    return this.length * this.width;
};

class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }
}

var x = new Square(3);
console.log(x.getArea());               // 9
console.log(x instanceof Rectangle);    // true
</code></pre>

</figure>

<p><code>Rectangle</code> is defined as an ECMAScript 5-style constructor while <code>Square</code> is a class. Since <code>Rectangle</code> has <code>[[Construct]]</code> and a prototype, the <code>Square</code> class can still inherit directly from it.</p>

<p>Accepting any type of expression after <code>extends</code> offers powerful possibilities, such as dynamically determining what to inherit from. For example:</p>

<figure class="code">
<pre><code>function Rectangle(length, width) {
    this.length = length;
    this.width = width;
}

Rectangle.prototype.getArea = function() {
    return this.length * this.width;
};

function getBase() {
    return Rectangle;
}

class Square extends getBase() {
    constructor(length) {
        super(length, length);
    }
}

var x = new Square(3);
console.log(x.getArea());               // 9
console.log(x instanceof Rectangle);    // true
</code></pre>

</figure>

<p>The <code>getBase()</code> function is called directly as part of the class declaration. It returns <code>Rectangle</code>, making this example is functionally equivalent to the previous one. And since you can determine the base class dynamically, it's possible to create different inheritance approaches. For instance, you can effectively create mixins:</p>

<figure class="code">
<pre><code>let SerializableMixin = {
    serialize() {
        return JSON.stringify(this);
    }
};

let AreaMixin = {
    getArea() {
        return this.length * this.width;
    }
};

function mixin(...mixins) {
    var base = function() {};
    Object.assign(base.prototype, ...mixins);
    return base;
}

class Square extends mixin(AreaMixin, SerializableMixin) {
    constructor(length) {
        super();
        this.length = length;
        this.width = length;
    }
}

var x = new Square(3);
console.log(x.getArea());               // 9
console.log(x.serialize());             // "{"length":3,"width":3}"
</code></pre>

</figure>

<p>In this example, mixins are used instead of classical inheritance. The <code>mixin()</code> function takes any number of arguments that represent mixin objects. It creates a function called <code>base</code> and assigns the properties of each mixin object to the prototype. The function is then returned so <code>Square</code> can use <code>extends</code>. Keep in mind that since <code>extends</code> is still used, you are required to call <code>super()</code> in the constructor.</p>

<p>The instance of <code>Square</code> has both <code>getArea()</code> from <code>AreaMixin</code> and <code>serialize</code> from <code>SerializableMixin</code>. This is accomplished through prototypal inheritance. The <code>mixin()</code> function dynamically populates the prototype of a new function with all of the own properties of each mixin. (Keep in mind that if multiple mixins have the same property, only the last property added will remain.)</p>

<aside class="warning blurb">
    <p>Any expression can be used after <code>extends</code>, but not all expressions result in a valid class. Specifically, the following expression types cause errors:</p>

  <ul>
    <li><code>null</code></li>
    <li>generator functions (covered in Chapter 8)</li>
  </ul>

  <p>In these cases, attempting to create a new instance of the class will throw an error because there is no <code>[[Construct]]</code> to call.</p>

</aside>

<h4 id="leanpub-auto-inheriting-from-built-ins">Inheriting from Built-ins</h4>

<p>For almost as long as JavaScript arrays have existed, developers have wanted to create their own special array types through inheritance. In ECMAScript 5 and earlier, this wasn't possible. Attempting to use classical inheritance didn't result in functioning code. For example:</p>

<figure class="code">
<pre><code>// built-in array behavior
var colors = [];
colors[0] = "red";
console.log(colors.length);         // 1

colors.length = 0;
console.log(colors[0]);             // undefined

// trying to inherit from array in ES5

function MyArray() {
    Array.apply(this, arguments);
}

MyArray.prototype = Object.create(Array.prototype, {
    constructor: {
        value: MyArray,
        writable: true,
        configurable: true,
        enumerable: true
    }
});

var colors = new MyArray();
colors[0] = "red";
console.log(colors.length);         // 0

colors.length = 0;
console.log(colors[0]);             // "red"
</code></pre>

</figure>

<p>The <code>console.log()</code> output at the end of this code shows how using the classical form of JavaScript inheritance on an array results in unexpected behavior. The <code>length</code> and numeric properties on an instance of <code>MyArray</code> don't behave the same as they do for the built-in array because this functionality isn't covered either by <code>Array.apply()</code> or by assigning the prototype.</p>

<p>One goal of ECMAScript 6 classes is to allow inheritance from all built-ins. In order to accomplish this, the inheritance model of classes is slightly different than the classical inheritance model found in ECMAScript 5 and earlier:</p>

<p>In ECMAScript 5 classical inheritance, the value of <code>this</code> is first created by the derived type (for example, <code>MyArray</code>), and then the base type constructor (like the <code>Array.apply()</code> method) is called. That means <code>this</code> starts out as an instance of <code>MyArray</code> and then is decorated with additional properties from <code>Array</code>.</p>

<p>In ECMAScript 6 class-based inheritance, the value of <code>this</code> is first created by the base (<code>Array</code>) and then modified by the derived class constructor (<code>MyArray</code>). The result is that <code>this</code> starts with all the built-in functionality of the base and correctly receives all functionality related to it.</p>

<p>The following example shows a class-based special array in action:</p>

<figure class="code">
<pre><code>class MyArray extends Array {
    // empty
}

var colors = new MyArray();
colors[0] = "red";
console.log(colors.length);         // 1

colors.length = 0;
console.log(colors[0]);             // undefined
</code></pre>

</figure>

<p><code>MyArray</code> inherits directly from <code>Array</code> and therefore works like <code>Array</code>. Interacting with numeric properties updates the <code>length</code> property, and manipulating the <code>length</code> property updates the numeric properties. That means you can both properly inherit from <code>Array</code> to create your own derived array classes and inherit from other built-ins as well. With all this added functionality, ECMAScript 6 and derived classes have effectively removed the last special case of inheriting from built-ins, but that case is still worth exploring.</p>

<h4 id="leanpub-auto-the-symbolspecies-property">The Symbol.species Property</h4>

<p>An interesting aspect of inheriting from built-ins is that any method that returns an instance of the built-in will automatically return a derived class instance instead. So, if you have a derived class called <code>MyArray</code> that inherits from <code>Array</code>, methods such as <code>slice()</code> return an instance of <code>MyArray</code>. For example:</p>

<figure class="code">
<pre><code>class MyArray extends Array {
    // empty
}

let items = new MyArray(1, 2, 3, 4),
    subitems = items.slice(1, 3);

console.log(items instanceof MyArray);      // true
console.log(subitems instanceof MyArray);   // true
</code></pre>

</figure>

<p>In this code, the <code>slice()</code> method returns a <code>MyArray</code> instance. The <code>slice()</code> method is inherited from <code>Array</code> and returns an instance of <code>Array</code> normally. Behind the scenes, it's the <code>Symbol.species</code> property that is making this change.</p>

<p>The <code>Symbol.species</code> well-known symbol is used to define a static accessor property that returns a function. That function is a constructor to use whenever an instance of the class must be created inside of an instance method (instead of using the constructor). The following builtin types have <code>Symbol.species</code> defined:</p>

<ul>
  <li><code>Array</code></li>
  <li>
<code>ArrayBuffer</code> (discussed in Chapter 10)</li>
  <li><code>Map</code></li>
  <li><code>Promise</code></li>
  <li><code>RegExp</code></li>
  <li><code>Set</code></li>
  <li>Typed Arrays (discussed in Chapter 10)</li>
</ul>

<p>Each of these types has a default <code>Symbol.species</code> property that returns <code>this</code>, meaning the property will always return the constructor function. If you were to implement that functionality on a custom class, the code would look like this:</p>

<figure class="code">
<pre><code>// several builtin types use species similar to this
class MyClass {
    static get [Symbol.species]() {
        return this;
    }

    constructor(value) {
        this.value = value;
    }

    clone() {
        return new this.constructor[Symbol.species](this.value);
    }
}
</code></pre>

</figure>

<p>In this example, the <code>Symbol.species</code> well-known symbol is used to assign a static accessor property to <code>MyClass</code>. Note that there's only a getter without a setter, because changing the species of a class isn't possible. Any call to <code>this.constructor[Symbol.species]</code> returns <code>MyClass</code>. The <code>clone()</code> method uses that definition to return a new instance rather than directly using <code>MyClass</code>, which allows derived classes to override that value. For example:</p>

<figure class="code">
<pre><code>class MyClass {
    static get [Symbol.species]() {
        return this;
    }

    constructor(value) {
        this.value = value;
    }

    clone() {
        return new this.constructor[Symbol.species](this.value);
    }
}

class MyDerivedClass1 extends MyClass {
    // empty
}

class MyDerivedClass2 extends MyClass {
    static get [Symbol.species]() {
        return MyClass;
    }
}

let instance1 = new MyDerivedClass1("foo"),
    clone1 = instance1.clone(),
    instance2 = new MyDerivedClass2("bar"),
    clone2 = instance2.clone();

console.log(clone1 instanceof MyClass);             // true
console.log(clone1 instanceof MyDerivedClass1);     // true
console.log(clone2 instanceof MyClass);             // true
console.log(clone2 instanceof MyDerivedClass2);     // false
</code></pre>

</figure>

<p>Here, <code>MyDerivedClass1</code> inherits from <code>MyClass</code> and doesn't change the <code>Symbol.species</code> property. When <code>clone()</code> is called, it returns an instance of <code>MyDerivedClass1</code> because <code>this.constructor[Symbol.species]</code> returns <code>MyDerivedClass1</code>. The <code>MyDerivedClass2</code> class inherits from <code>MyClass</code> and overrides <code>Symbol.species</code> to return <code>MyClass</code>. When <code>clone()</code> is called on an instance of <code>MyDerivedClass2</code>, the return value is an instance of <code>MyClass</code>. Using <code>Symbol.species</code>, any derived class can determine what type of value should be returned when a method returns an instance.</p>

<p>For instance, <code>Array</code> uses <code>Symbol.species</code> to specify the class to use for methods that return an array. In a class derived from <code>Array</code>, you can determine the type of object returned from the inherited methods, such as:</p>

<figure class="code">
<pre><code>class MyArray extends Array {
    static get [Symbol.species]() {
        return Array;
    }
}

let items = new MyArray(1, 2, 3, 4),
    subitems = items.slice(1, 3);

console.log(items instanceof MyArray);      // true
console.log(subitems instanceof Array);     // true
console.log(subitems instanceof MyArray);   // false
</code></pre>

</figure>

<p>This code overrides <code>Symbol.species</code> on <code>MyArray</code>, which inherits from <code>Array</code>. All of the inherited methods that return arrays will now use an instance of <code>Array</code> instead of <code>MyArray</code>.</p>

<p>In general, you should use the <code>Symbol.species</code> property whenever you might want to use <code>this.constructor</code> in a class method. Doing so allows derived classes to override the return type easily. Additionally, if you are creating derived classes from a class that has <code>Symbol.species</code> defined, be sure to use that value instead of the constructor.</p>

<h3 id="leanpub-auto-using-newtarget-in-class-constructors">Using new.target in Class Constructors</h3>

<p>In Chapter 3, you learned about <code>new.target</code> and how its value changes depending on how a function is called. You can also use <code>new.target</code> in class constructors to determine how the class is being invoked. In the simple case, <code>new.target</code> is equal to the constructor function for the class, as in this example:</p>

<figure class="code">
<pre><code>class Rectangle {
    constructor(length, width) {
        console.log(new.target === Rectangle);
        this.length = length;
        this.width = width;
    }
}

// new.target is Rectangle
var obj = new Rectangle(3, 4);      // outputs true
</code></pre>

</figure>

<p>This code shows that <code>new.target</code> is equivalent to <code>Rectangle</code> when <code>new Rectangle(3, 4)</code> is called. Class constructors can't be called without <code>new</code>, so the <code>new.target</code> property is always defined inside of class constructors. But the value may not always be the same. Consider this code:</p>

<figure class="code">
<pre><code>class Rectangle {
    constructor(length, width) {
        console.log(new.target === Rectangle);
        this.length = length;
        this.width = width;
    }
}

class Square extends Rectangle {
    constructor(length) {
        super(length, length)
    }
}

// new.target is Square
var obj = new Square(3);      // outputs false
</code></pre>

</figure>

<p><code>Square</code> is calling the <code>Rectangle</code> constructor, so <code>new.target</code> is equal to <code>Square</code> when the <code>Rectangle</code> constructor is called. This is important because it gives each constructor the ability to alter its behavior based on how it's being called. For instance, you can create an abstract base class (one that can't be instantiated directly) by using <code>new.target</code> as follows:</p>

<figure class="code">
<pre><code>// abstract base class
class Shape {
    constructor() {
        if (new.target === Shape) {
            throw new Error("This class cannot be instantiated directly.")
        }
    }
}

class Rectangle extends Shape {
    constructor(length, width) {
        super();
        this.length = length;
        this.width = width;
    }
}

var x = new Shape();                // throws error

var y = new Rectangle(3, 4);        // no error
console.log(y instanceof Shape);    // true
</code></pre>

</figure>

<p>In this example, the <code>Shape</code> class constructor throws an error whenever <code>new.target</code> is <code>Shape</code>, meaning that <code>new Shape()</code> always throws an error. However, you can still use <code>Shape</code> as a base class, which is what <code>Rectangle</code> does. The <code>super()</code> call executes the <code>Shape</code> constructor and <code>new.target</code> is equal to <code>Rectangle</code> so the constructor continues without error.</p>

<aside class="information blurb">
    <p>Since classes can't be called without <code>new</code>, the <code>new.target</code> property is never <code>undefined</code> inside of a class constructor.</p>

</aside>

<h3 id="leanpub-auto-summary-8">Summary</h3>

<p>ECMAScript 6 classes make inheritance in JavaScript easier to use, so you don't need to throw away any existing understanding of inheritance you might have from other languages. ECMAScript 6 classes start out as syntactic sugar for the classical inheritance model of ECMAScript 5, but add a lot of features to reduce mistakes.</p>

<p>ECMAScript 6 classes work with prototypal inheritance by defining non-static methods on the class prototype, while static methods end up on the constructor itself. All methods are non-enumerable, a feature that better matches the behavior of built-in objects for which methods are typically non-enumerable by default. Additionally, class constructors can't be called without <code>new</code>, ensuring that you can't accidentally call a class as a function.</p>

<p>Class-based inheritance allows you to derive a class from another class, function, or expression. This ability means you can call a function to determine the correct base to inherit from, allowing you to use mixins and other different composition patterns to create a new class. Inheritance works in such a way that inheriting from built-in objects like <code>Array</code> is now possible and works as expected.</p>

<p>You can use <code>new.target</code> in class constructors to behave differently depending on how the class is called. The most common use is to create an abstract base class that throws an error when instantiated directly but still allows inheritance via other classes.</p>

<p>Overall, classes are an important addition to JavaScript. They provide a more concise syntax and better functionality for defining custom object types in a safe, consistent manner.</p>


<h2 id="leanpub-auto-improved-array-capabilities">Improved Array Capabilities</h2>

<p>The array is a foundational JavaScript object. But while other aspects of JavaScript have evolved over time, arrays remained the same until ECMAScript 5 introduced several methods to make them easier to use. ECMAScript 6 continues to improve arrays by adding a lot more functionality, like new creation methods, several useful convenience methods, and the ability to make typed arrays.</p>

<h3 id="leanpub-auto-creating-arrays">Creating Arrays</h3>

<p>Prior to ECMAScript 6, there were two primary ways to create arrays: the <code>Array</code> constructor and array literal syntax. Both approaches require listing array items individually and are otherwise fairly limited. Options for converting an array-like object (that is, an object with numeric indices and a <code>length</code> property) into an array were also limited and often required extra code. To make JavaScript arrays easier to create, ECMAScript 6 adds the <code>Array.of()</code> and <code>Array.from()</code> methods.</p>

<h4 id="leanpub-auto-the-arrayof-method">The Array.of() Method</h4>

<p>One reason ECMAScript 6 adds new creation methods to JavaScript is to help developers avoid a quirk of creating arrays with the <code>Array</code> constructor. The <code>new Array()</code> constructor actually behaves differently based on the type and number of arguments passed to it. For example:</p>

<figure class="code">
<pre><code>let items = new Array(2);
console.log(items.length);          // 2
console.log(items[0]);              // undefined
console.log(items[1]);              // undefined

items = new Array("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"

items = new Array(1, 2);
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = new Array(3, "2");
console.log(items.length);          // 2
console.log(items[0]);              // 3
console.log(items[1]);              // "2"
</code></pre>

</figure>

<p>When the <code>Array</code> constructor is passed a single numeric value, the <code>length</code> property of the array is set to that value. If a single non-numeric value is passed, then that value becomes the one and only item in the array. If multiple values are passed (numeric or not), then those values become items in the array. This behavior is both confusing and risky, as you may not always be aware of the type of data being passed.</p>

<p>ECMAScript 6 introduces <code>Array.of()</code> to solve this problem. The <code>Array.of()</code> method works similarly to the <code>Array</code> constructor but has no special case regarding a single numeric value. The <code>Array.of()</code> method always creates an array containing its arguments regardless of the number of arguments or the argument types. Here are some examples that use the <code>Array.of()</code> method:</p>

<figure class="code">
<pre><code>let items = Array.of(1, 2);
console.log(items.length);          // 2
console.log(items[0]);              // 1
console.log(items[1]);              // 2

items = Array.of(2);
console.log(items.length);          // 1
console.log(items[0]);              // 2

items = Array.of("2");
console.log(items.length);          // 1
console.log(items[0]);              // "2"
</code></pre>

</figure>

<p>To create an array with the <code>Array.of()</code> method, just pass it the values you want in your array. The first example here creates an array containing two numbers, the second array contains one number, and the last array contains one string. This is similar to using an array literal, and you can use an array literal instead of <code>Array.of()</code> for native arrays most of the time. But if you ever need to pass the <code>Array</code> constructor into a function, then you might want to pass <code>Array.of()</code> instead to ensure consistent behavior. For example:</p>

<figure class="code">
<pre><code>function createArray(arrayCreator, value) {
    return arrayCreator(value);
}

let items = createArray(Array.of, value);
</code></pre>

</figure>

<p>In this code, the <code>createArray()</code> function accepts an array creator function and a value to insert into the array. You can pass <code>Array.of()</code> as the first argument to <code>createArray()</code> to create a new array. It would be dangerous to pass <code>Array</code> directly if you cannot guarantee that <code>value</code> won't be a number.</p>

<aside class="information blurb">
    <p>The <code>Array.of()</code> method does not use the <code>Symbol.species</code> property (discussed in Chapter 9) to determine the type of return value. Instead, it uses the current constructor (<code>this</code> inside the <code>of()</code> method) to determine the correct data type to return.</p>

</aside>

<h4 id="leanpub-auto-the-arrayfrom-method">The Array.from() Method</h4>

<p>Converting non-array objects into actual arrays has always been cumbersome in JavaScript. For instance, if you have an <code>arguments</code> object (which is array-like) and want to use it like an array, then you'd need to convert it first. To convert an array-like object to an array in ECMAScript 5, you'd write a function like the one in this example:</p>

<figure class="code">
<pre><code>function makeArray(arrayLike) {
    var result = [];

    for (var i = 0, len = arrayLike.length; i &lt; len; i++) {
        result.push(arrayLike[i]);
    }

    return result;
}

function doSomething() {
    var args = makeArray(arguments);

    // use args
}
</code></pre>

</figure>

<p>This approach manually creates a <code>result</code> array and copies each item from <code>arguments</code> into the new array. That works but takes a decent amount of code to perform a relatively simple operation. Eventually, developers discovered they could reduce the amount of code by calling the native <code>slice()</code> method for arrays on array-like objects, like this:</p>

<figure class="code">
<pre><code>function makeArray(arrayLike) {
    return Array.prototype.slice.call(arrayLike);
}

function doSomething() {
    var args = makeArray(arguments);

    // use args
}
</code></pre>

</figure>

<p>This code is functionally equivalent to the previous example, and it works because it sets the <code>this</code> value for <code>slice()</code> to the array-like object. Since <code>slice()</code> needs only numeric indices and a <code>length</code> property to function correctly, any array-like object will work.</p>

<p>Even though this technique requires less typing, calling <code>Array.prototype.slice.call(arrayLike)</code> doesn't obviously translate to, "Convert <code>arrayLike</code> to an array." Fortunately, ECMAScript 6 added the <code>Array.from()</code> method as an obvious, yet clean, way to convert objects into arrays.</p>

<p>Given either an iterable or an array-like object as the first argument, the <code>Array.from()</code> method returns an array. Here's a simple example:</p>

<figure class="code">
<pre><code>function doSomething() {
    var args = Array.from(arguments);

    // use args
}
</code></pre>

</figure>

<p>The <code>Array.from()</code> call creates a new array based on the items in <code>arguments</code>. So <code>args</code> is an instance of <code>Array</code> that contains the same values in the same positions as <code>arguments</code>.</p>

<aside class="information blurb">
    <p>The <code>Array.from()</code> method also uses <code>this</code> to determine the type of array to return.</p>

</aside>

<h5 id="leanpub-auto-mapping-conversion">Mapping Conversion</h5>

<p>If you want to take array conversion a step further, you can provide <code>Array.from()</code> with a mapping function as a second argument. That function operates on each value from the array-like object and converts it to some final form before storing the result at the appropriate index in the final array. For example:</p>

<figure class="code">
<pre><code>function translate() {
    return Array.from(arguments, (value) =&gt; value + 1);
}

let numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
</code></pre>

</figure>

<p>Here, <code>Array.from()</code> is passed <code>(value) =&gt; value + 1</code> as a mapping function, so it adds 1 to each item in the array before storing the item. If the mapping function is on an object, you can also optionally pass a third argument to <code>Array.from()</code> that represents the <code>this</code> value for the mapping function:</p>

<figure class="code">
<pre><code>let helper = {
    diff: 1,

    add(value) {
        return value + this.diff;
    }
};

function translate() {
    return Array.from(arguments, helper.add, helper);
}

let numbers = translate(1, 2, 3);

console.log(numbers);               // 2,3,4
</code></pre>

</figure>

<p>This example passes <code>helper.add()</code> as the mapping function for the conversion. Since <code>helper.add()</code> uses the <code>this.diff</code> property, you need to provide the third argument to <code>Array.from()</code> specifying the value of <code>this</code>. Thanks to the third argument, <code>Array.from()</code> can easily convert data without calling <code>bind()</code> or specifying the <code>this</code> value in some other way.</p>

<h5 id="leanpub-auto-use-on-iterables">Use on Iterables</h5>

<p>The <code>Array.from()</code> method works on both array-like objects and iterables. That means the method can convert any object with a <code>Symbol.iterator</code> property into an array. For example:</p>

<figure class="code">
<pre><code>let numbers = {
    *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
    }
};

let numbers2 = Array.from(numbers, (value) =&gt; value + 1);

console.log(numbers2);              // 2,3,4
</code></pre>

</figure>

<p>Since the <code>numbers</code> object is an iterable, you can pass <code>numbers</code> directly to <code>Array.from()</code> to convert its values into an array. The mapping function adds one to each number so the resulting array contains 2, 3, and 4 instead of 1, 2, and 3.</p>

<aside class="information blurb">
    <p>If an object is both array-like and iterable, then the iterator is used by <code>Array.from()</code> to determine the values to convert.</p>

</aside>

<h3 id="leanpub-auto-new-methods-on-all-arrays">New Methods on All Arrays</h3>

<p>Continuing the trend from ECMAScript 5, ECMAScript 6 adds several new methods to arrays. The <code>find()</code> and <code>findIndex()</code> methods are meant to aid developers using arrays with any values, while <code>fill()</code> and <code>copyWithin()</code> are inspired by use cases for <em>typed arrays</em>, a form of array introduced in ECMAScript 6 that uses only numbers.</p>

<h4 id="leanpub-auto-the-find-and-findindex-methods">The find() and findIndex() Methods</h4>

<p>Prior to ECMAScript 5, searching through arrays was cumbersome because there were no built-in methods for doing so. ECMAScript 5 added the <code>indexOf()</code> and <code>lastIndexOf()</code> methods, finally allowing developers to search for specific values inside an array. These two methods were a big improvement, yet they were still fairly limited because you could only search for one value at a time. For example, if you wanted to find the first even number in a series of numbers, you'd need to write your own code to do so. ECMAScript 6 solved that problem by introducing the <code>find()</code> and <code>findIndex()</code> methods.</p>

<p>Both <code>find()</code> and <code>findIndex()</code> accept two arguments: a callback function and an optional value to use for <code>this</code> inside the callback function. The callback function is passed an array element, the index of that element in the array, and the array itself–the same arguments passed to methods like <code>map()</code> and <code>forEach()</code>. The callback should return <code>true</code> if the given value matches some criteria you define. Both <code>find()</code> and <code>findIndex()</code> also stop searching the array the first time the callback function returns <code>true</code>.</p>

<p>The only difference between these methods is that <code>find()</code> returns the value whereas <code>findIndex()</code> returns the index at which the value was found. Here's an example to demonstrate:</p>

<figure class="code">
<pre><code>let numbers = [25, 30, 35, 40, 45];

console.log(numbers.find(n =&gt; n &gt; 33));         // 35
console.log(numbers.findIndex(n =&gt; n &gt; 33));    // 2
</code></pre>

</figure>

<p>This code calls <code>find()</code> and <code>findIndex()</code> to locate the first value in the <code>numbers</code> array that is greater than 33. The call to <code>find()</code> returns 35 and <code>findIndex()</code> returns 2, the location of 35 in the <code>numbers</code> array.</p>

<p>Both <code>find()</code> and <code>findIndex()</code> are useful to find an array element that matches a condition rather than a value. If you only want to find a value, then <code>indexOf()</code> and <code>lastIndexOf()</code> are better choices.</p>

<h4 id="leanpub-auto-the-fill-method">The fill() Method</h4>

<p>The <code>fill()</code> method fills one or more array elements with a specific value. When passed a value, <code>fill()</code> overwrites all of the values in an array with that value. For example:</p>

<figure class="code">
<pre><code>let numbers = [1, 2, 3, 4];

numbers.fill(1);

console.log(numbers.toString());    // 1,1,1,1
</code></pre>

</figure>

<p>Here, the call to <code>numbers.fill(1)</code> changes all values in <code>numbers</code> to <code>1</code>. If you only want to change some of the elements, rather than all of them, you can optionally include a start index and an exclusive end index, like this:</p>

<figure class="code">
<pre><code>let numbers = [1, 2, 3, 4];

numbers.fill(1, 2);

console.log(numbers.toString());    // 1,2,1,1

numbers.fill(0, 1, 3);

console.log(numbers.toString());    // 1,0,0,1
</code></pre>

</figure>

<p>In the <code>numbers.fill(1,2)</code> call, the <code>2</code> indicates to start filling elements at index 2. The exclusive end index isn't specified with a third argument, so <code>numbers.length</code> is used as the end index, meaning the last two elements in <code>numbers</code> are filled with <code>1</code>. The <code>numbers.fill(0, 1, 3)</code> operation fills array elements at indices 1 and 2 with <code>0</code>. Calling <code>fill()</code> with the second and third arguments allows you to fill multiple array elements at once without overwriting the entire array.</p>

<aside class="information blurb">
    <p>If either the start or end index are negative, then those values are added to the array's length to determine the final location. For instance, a start location of <code>-1</code> gives <code>array.length - 1</code> as the index, where <code>array</code> is the array on which <code>fill()</code> is called.</p>

</aside>

<h4 id="leanpub-auto-the-copywithin-method">The copyWithin() Method</h4>

<p>The <code>copyWithin()</code> method is similar to <code>fill()</code> in that it changes multiple array elements at the same time. However, instead of specifying a single value to assign to array elements, <code>copyWithin()</code> lets you copy array element values from the array itself. To accomplish that, you need to pass two arguments to the <code>copyWithin()</code> method: the index where the method should start filling values and the index where the values to be copied begin.</p>

<p>For instance, to copy the values from the first two elements in an array to the last two items in the array, you can do the following:</p>

<figure class="code">
<pre><code>let numbers = [1, 2, 3, 4];

// paste values into array starting at index 2
// copy values from array starting at index 0
numbers.copyWithin(2, 0);

console.log(numbers.toString());    // 1,2,1,2
</code></pre>

</figure>

<p>This code pastes values into <code>numbers</code> beginning from index 2, so both indices 2 and 3 will be overwritten. Passing <code>0</code> as the second argument to <code>copyWithin()</code> indicates to start copying values from index 0 and continue until there are no more elements to copy into.</p>

<p>By default, <code>copyWithin()</code> always copies values up to the end of the array, but you can provide an optional third argument to limit how many elements will be overwritten. That third argument is an exclusive end index at which copying of values stops. Here's an example:</p>

<figure class="code">
<pre><code>let numbers = [1, 2, 3, 4];

// paste values into array starting at index 2
// copy values from array starting at index 0
// stop copying values when you hit index 1
numbers.copyWithin(2, 0, 1);

console.log(numbers.toString());    // 1,2,1,4
</code></pre>

</figure>

<p>In this example, only the value in index 0 is copied because the optional end index is set to <code>1</code>. The last element in the array remains unchanged.</p>

<aside class="information blurb">
    <p>As with the <code>fill()</code> method, if you pass a negative number for any argument to the <code>copyWithin()</code> method, the array's length is automatically added to that value to determine the index to use.</p>

</aside>

<p>The use cases for <code>fill()</code> and <code>copyWithin()</code> may not be obvious to you at this point. That's because these methods originated on typed arrays and were added to regular arrays for consistency. As you'll learn in the next section, however, if you use typed arrays for manipulating the bits of a number, these methods become a lot more useful.</p>

<h3 id="leanpub-auto-typed-arrays">Typed Arrays</h3>

<p>Typed arrays are special-purpose arrays designed to work with numeric types (not all types, as the name might imply). The origin of typed arrays can be traced to WebGL, a port of Open GL ES 2.0 designed for use in web pages with the <code>&lt;canvas&gt;</code> element. Typed arrays were created as part of the port to provide fast bitwise arithmetic in JavaScript.</p>

<p>Arithmetic on native JavaScript numbers was too slow for WebGL because the numbers were stored in a 64-bit floating-point format and converted to 32-bit integers as needed. Typed arrays were introduced to circumvent this limitation and provide better performance for arithmetic operations. The concept is that any single number can be treated like an array of bits and thus can use the familiar methods available on JavaScript arrays.</p>

<p>ECMAScript 6 adopted typed arrays as a formal part of the language to ensure better compatibility across JavaScript engines and interoperability with JavaScript arrays. While the ECMAScript 6 version of typed arrays is not exactly the same as the WebGL version, there are enough similarities to make the ECMAScript 6 version an evolution of the WebGL version rather than a different approach.</p>

<h4 id="leanpub-auto-numeric-data-types">Numeric Data Types</h4>

<p>JavaScript numbers are stored in IEEE 754 format, which uses 64 bits to store a floating-point representation of the number. This format represents both integers and floats in JavaScript, with conversion between the two formats happening frequently as numbers change. Typed arrays allow the storage and manipulation of eight different numeric types:</p>

<ol class="numeric">
  <li>Signed 8-bit integer (int8)</li>
  <li>Unsigned 8-bit integer (uint8)</li>
  <li>Signed 16-bit integer (int16)</li>
  <li>Unsigned 16-bit integer (uint16)</li>
  <li>Signed 32-bit integer (int32)</li>
  <li>Unsigned 32-bit integer (uint32)</li>
  <li>32-bit float (float32)</li>
  <li>64-bit float (float64)</li>
</ol>

<p>If you represent a number that fits in an int8 as a normal JavaScript number, you'll waste 56 bits. Those bits might better be used to store additional int8 values or any other number that requires less than 56 bits. Using bits more efficiently is one of the use cases typed arrays address.</p>

<p>All of the operations and objects related to typed arrays are centered around these eight data types. In order to use them, though, you'll need to create an array buffer to store the data.</p>

<aside class="information blurb">
    <p>In this book, I will refer to these types by the abbreviations I showed in parentheses. Those abbreviations don't appear in actual JavaScript code; they're just a shorthand for the much longer descriptions.</p>

</aside>

<h4 id="leanpub-auto-array-buffers">Array Buffers</h4>

<p>The foundation for all typed arrays is an <em>array buffer</em>, which is a memory location that can contain a specified number of bytes. Creating an array buffer is akin to calling <code>malloc()</code> in C to allocate memory without specifying what the memory block contains. You can create an array buffer by using the <code>ArrayBuffer</code> constructor as follows:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10);   // allocate 10 bytes
</code></pre>

</figure>

<p>Just pass the number of bytes the array buffer should contain when you call the constructor. This <code>let</code> statement creates an array buffer 10 bytes long. Once an array buffer is created, you can retrieve the number of bytes in it by checking the <code>byteLength</code> property:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10);   // allocate 10 bytes
console.log(buffer.byteLength);     // 10
</code></pre>

</figure>

<p>You can also use the <code>slice()</code> method to create a new array buffer that contains part of an existing array buffer. The <code>slice()</code> method works like the <code>slice()</code> method on arrays: you pass it the start index and end index as arguments, and it returns a new <code>ArrayBuffer</code> instance comprised of those elements from the original. For example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10);   // allocate 10 bytes


let buffer2 = buffer.slice(4, 6);
console.log(buffer2.byteLength);    // 2
</code></pre>

</figure>

<p>In this code, <code>buffer2</code> is created by extracting the bytes at indices 4 and 5. Just like when you call the array version of this method, the second argument to <code>slice()</code> is exclusive.</p>

<p>Of course, creating a storage location isn't very helpful without being able to write data into that location. To do so, you'll need to create a view.</p>

<aside class="information blurb">
    <p>An array buffer always represents the exact number of bytes specified when it was created. You can change the data contained within an array buffer, but never the size of the array buffer itself.</p>

</aside>

<h4 id="leanpub-auto-manipulating-array-buffers-with-views">Manipulating Array Buffers with Views</h4>

<p>Array buffers represent memory locations, and <em>views</em> are the interfaces you'll use to manipulate that memory. A view operates on an array buffer or a subset of an array buffer's bytes, reading and writing data in one of the numeric data types. The <code>DataView</code> type is a generic view on an array buffer that allows you to operate on all eight numeric data types.</p>

<p>To use a <code>DataView</code>, first create an instance of <code>ArrayBuffer</code> and use it to create a new <code>DataView</code>. Here's an example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10),
    view = new DataView(buffer);
</code></pre>

</figure>

<p>The <code>view</code> object in this example has access to all 10 bytes in <code>buffer</code>. You can also create a view over just a portion of a buffer. Just provide a byte offset and, optionally, the number of bytes to include from that offset. When a number of bytes isn't included, the<code>DataView</code> will go from the offset to the end of the buffer by default. For example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10),
    view = new DataView(buffer, 5, 2);      // cover bytes 5 and 6
</code></pre>

</figure>

<p>Here, <code>view</code> operates only on the bytes at indices 5 and 6. This approach allows you to create several views over the same array buffer, which can be useful if you want to use a single memory location for an entire application rather than dynamically allocating space as needed.</p>

<h5 id="leanpub-auto-retrieving-view-information">Retrieving View Information</h5>

<p>You can retrieve information about a view by fetching the following read-only properties:</p>

<ul>
  <li>
<code>buffer</code> - The array buffer that the view is tied to</li>
  <li>
<code>byteOffset</code> - The second argument to the <code>DataView</code> constructor, if provided (0 by default)</li>
  <li>
<code>byteLength</code> - The third argument to the <code>DataView</code> constructor, if provided (the buffer's <code>byteLength</code> by default)</li>
</ul>

<p>Using these properties, you can inspect exactly where a view is operating, like this:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10),
    view1 = new DataView(buffer),           // cover all bytes
    view2 = new DataView(buffer, 5, 2);     // cover bytes 5 and 6

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
</code></pre>

</figure>

<p>This code creates <code>view1</code>, a view over the entire array buffer, and <code>view2</code>, which operates on a small section of the array buffer. These views have equivalent <code>buffer</code> properties because both work on the same array buffer. The <code>byteOffset</code> and <code>byteLength</code> are different for each view, however. They reflect the portion of the array buffer where each view operates.</p>

<p>Of course, reading information about memory isn't very useful on its own. You need to write data into and read data out of that memory to get any benefit.</p>

<h5 id="leanpub-auto-reading-and-writing-data">Reading and Writing Data</h5>

<p>For each of JavaScript's eight numeric data types, the <code>DataView</code> prototype has a method to write data and a method to read data from an array buffer. The method names all begin with either "set" or "get" and are followed by the data type abbreviation. For instance, here's a list of the read and write methods that can operate on int8 and uint8 values:</p>

<ul>
  <li>
<code>getInt8(byteOffset, littleEndian)</code> - Read an int8 starting at <code>byteOffset</code>
</li>
  <li>
<code>setInt8(byteOffset, value, littleEndian)</code> - Write an int8 starting at <code>byteOffset</code>
</li>
  <li>
<code>getUint8(byteOffset, littleEndian)</code> - Read an uint8 starting at <code>byteOffset</code>
</li>
  <li>
<code>setUint8(byteOffset, value, littleEndian)</code> - Write an uint8 starting at <code>byteOffset</code>
</li>
</ul>

<p>The "get" methods accept two arguments: the byte offset to read from and an optional boolean indicating whether the value should be read as little-endian. (<em>Little-endian</em> means the least significant byte is at byte 0, instead of in the last byte.) The "set" methods accept three arguments: the byte offset to write at, the value to write, and an optional boolean indicating whether the value should be stored in little-endian format.</p>

<p>Though I've only shown the methods you can use with 8-bit values, the same methods exist for operating on 16- and 32-bit values. Just replace the <code>8</code> in each name with <code>16</code> or <code>32</code>. Alongside all those integer methods, <code>DataView</code> also has the following read and write methods for floating point numbers:</p>

<ul>
  <li>
<code>getFloat32(byteOffset, littleEndian)</code> - Read a float32 starting at <code>byteOffset</code>
</li>
  <li>
<code>setFloat32(byteOffset, value, littleEndian)</code> - Write a float32 starting at <code>byteOffset</code>
</li>
  <li>
<code>getFloat64(byteOffset, littleEndian)</code> - Read a float64 starting at <code>byteOffset</code>
</li>
  <li>
<code>setFloat64(byteOffset, value, littleEndian)</code> - Write a float64 starting at <code>byteOffset</code>
</li>
</ul>

<p>To see a "set" and a "get" method in action, consider the following example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(2),
    view = new DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1
</code></pre>

</figure>

<p>This code uses a two-byte array buffer to store two int8 values. The first value is set at offset 0 and the second is at offset 1, reflecting that each value spans a full byte (8 bits). Those values are later retrieved from their positions with the <code>getInt8()</code> method. While this example uses int8 values, you can use any of the eight numeric types with their corresponding methods.</p>

<p>Views are interesting because they allow you to read and write in any format at any point in time, regardless of how data was previously stored. For instance, writing two int8 values and reading the buffer with an int16 method works just fine, as in this example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(2),
    view = new DataView(buffer);

view.setInt8(0, 5);
view.setInt8(1, -1);

console.log(view.getInt16(0));      // 1535
console.log(view.getInt8(0));       // 5
console.log(view.getInt8(1));       // -1
</code></pre>

</figure>

<p>The call to <code>view.getInt16(0)</code> reads all bytes in the view and interprets those bytes as the number 1535. To understand why this happens, take a look at Figure 10-1, which shows what each <code>setInt8()</code> line does to the array buffer.</p>


<figure class="code">
<pre><code>new ArrayBuffer(2)      0000000000000000
view.setInt8(0, 5);     0000010100000000
view.setInt8(1, -1);    0000010111111111
</code></pre>

</figure>

<p>The array buffer starts with 16 bits that are all zero. Writing <code>5</code> to the first byte with <code>setInt8()</code> introduces a couple of 1s (in 8-bit representation, 5 is 00000101). Writing -1 to the second byte sets all bits in that byte to 1, which is the two's complement representation of -1. After the second <code>setInt8()</code> call, the array buffer contains 16 bits, and <code>getInt16()</code> reads those bits as a single 16-bit integer, which is 1535 in decimal.</p>

<p>The <code>DataView</code> object is perfect for use cases that mix different data types in this way. However, if you're only using one specific data type, then the type-specific views are a better choice.</p>

<h5 id="leanpub-auto-typed-arrays-are-views">Typed Arrays Are Views</h5>

<p>ECMAScript 6 typed arrays are actually type-specific views for array buffers. Instead of using a generic <code>DataView</code> object to operate on an array buffer, you can use objects that enforce specific data types. There are eight type-specific views corresponding to the eight numeric data types, plus an additional option for <code>uint8</code> values.</p>

<p>Table 10-1 shows an abbreviated version of the complete list of type-specific views from section 22.2 of the ECMAScript 6 specification.</p>



<table>
  <thead>
    <tr>
      <th>Constructor Name</th>
      <th>Element Size (in bytes)</th>
      <th>Description</th>
      <th>Equivalent C Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Int8Array</code></td>
      <td>1</td>
      <td>8-bit two's complement signed integer</td>
      <td><code>signed char</code></td>
    </tr>
    <tr>
      <td><code>Uint8Array</code></td>
      <td>1</td>
      <td>8-bit unsigned integer</td>
      <td><code>unsigned char</code></td>
    </tr>
    <tr>
      <td><code>Uint8ClampedArray</code></td>
      <td>1</td>
      <td>8-bit unsigned integer (clamped conversion)</td>
      <td><code>unsigned char</code></td>
    </tr>
    <tr>
      <td><code>Int16Array</code></td>
      <td>2</td>
      <td>16-bit two's complement signed integer</td>
      <td><code>short</code></td>
    </tr>
    <tr>
      <td><code>Uint16Array</code></td>
      <td>2</td>
      <td>16-bit unsigned integer</td>
      <td><code>unsigned short</code></td>
    </tr>
    <tr>
      <td><code>Int32Array</code></td>
      <td>4</td>
      <td>32-bit two's complement signed integer</td>
      <td><code>int</code></td>
    </tr>
    <tr>
      <td><code>Uint32Array</code></td>
      <td>4</td>
      <td>32-bit unsigned integer</td>
      <td><code>int</code></td>
    </tr>
    <tr>
      <td><code>Float32Array</code></td>
      <td>4</td>
      <td>32-bit IEEE floating point</td>
      <td><code>float</code></td>
    </tr>
    <tr>
      <td><code>Float64Array</code></td>
      <td>8</td>
      <td>64-bit IEEE floating point</td>
      <td><code>double</code></td>
    </tr>
  </tbody>

</table>

<p>The left column lists the typed array constructors, and the other columns describe the data each typed array can contain. A <code>Uint8ClampedArray</code> is the same as a <code>Uint8Array</code> unless values in the array buffer are less than 0 or greater than 255. A <code>Uint8ClampedArray</code> converts values lower than 0 to 0 (-1 becomes 0, for instance) and converts values higher than 255 to 255 (so 300 becomes 255).</p>

<p>Typed array operations only work on a particular type of data. For example, all operations on <code>Int8Array</code> use <code>int8</code> values. The size of an element in a typed array also depends on the type of array. While an element in an <code>Int8Array</code> is a single byte long, <code>Float64Array</code> uses eight bytes per element. Fortunately, the elements are accessed using numeric indices just like regular arrays, allowing you to avoid the somewhat awkward calls to the "set" and "get" methods of <code>DataView</code>.</p>

<aside>
  <h4 id="leanpub-auto-element-size">Element Size</h4>

  <p>Each typed array is made up of a number of elements, and the element size is the number of bytes each element represents. This value is stored on a <code>BYTES_PER_ELEMENT</code> property on each constructor and each instance, so you can easily query the element size:</p>

  <figure class="code">
<pre><code>console.log(UInt8Array.BYTES_PER_ELEMENT);      // 1
console.log(UInt16Array.BYTES_PER_ELEMENT);     // 2

let ints = new Int8Array(5);
console.log(ints.BYTES_PER_ELEMENT);            // 1
</code></pre>

  </figure>

</aside>

<h5 id="leanpub-auto-creating-type-specific-views">Creating Type-Specific Views</h5>

<p>Typed array constructors accept multiple types of arguments, so there are a few ways to create typed arrays. First, you can create a new typed array by passing the same arguments <code>DataView</code> takes (an array buffer, an optional byte offset, and an optional byte length). For example:</p>

<figure class="code">
<pre><code>let buffer = new ArrayBuffer(10),
    view1 = new Int8Array(buffer),
    view2 = new Int8Array(buffer, 5, 2);

console.log(view1.buffer === buffer);       // true
console.log(view2.buffer === buffer);       // true
console.log(view1.byteOffset);              // 0
console.log(view2.byteOffset);              // 5
console.log(view1.byteLength);              // 10
console.log(view2.byteLength);              // 2
</code></pre>

</figure>

<p>In this code, the two views are both <code>Int8Array</code> instances that use <code>buffer</code>. Both <code>view1</code> and <code>view2</code> have the same <code>buffer</code>, <code>byteOffset</code>, and <code>byteLength</code> properties that exist on <code>DataView</code> instances. It's easy to switch to using a typed array wherever you use a <code>DataView</code> so long as you only work with one numeric type.</p>

<p>The second way to create a typed array is to pass a single number to the constructor. That number represents the number of elements (not bytes) to allocate to the array. The constructor will create a new buffer with the correct number of bytes to represent that number of array elements, and you can access the number of elements in the array by using the <code>length</code> property. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array(2),
    floats = new Float32Array(5);

console.log(ints.byteLength);       // 4
console.log(ints.length);           // 2

console.log(floats.byteLength);     // 20
console.log(floats.length);         // 5
</code></pre>

</figure>

<p>The <code>ints</code> array is created with space for two elements. Each 16-bit integer requires two bytes per value, so the array is allocated four bytes. The <code>floats</code> array is created to hold five elements, so the number of bytes required is 20 (four bytes per element). In both cases, a new buffer is created and can be accessed using the <code>buffer</code> property if necessary.</p>

<aside class="warning blurb">
    <p>If no argument is passed to a typed array constructor, the constructor acts as if <code>0</code> was passed. This creates a typed array that cannot hold data because zero bytes are allocated to the buffer.</p>

</aside>

<p>The third way to create a typed array is to pass an object as the only argument to the constructor. The object can be any of the following:</p>

<ul>
  <li>
<strong>A Typed Array</strong> - Each element is copied into a new element on the new typed array. For example, if you pass an int8 to the <code>Int16Array</code> constructor, the int8 values would be copied into an int16 array. The new typed array has a different array buffer than the one that was passed in.</li>
  <li>
<strong>An Iterable</strong> - The object's iterator is called to retrieve the items to insert into the typed array. The constructor will throw an error if any elements are invalid for the view type.</li>
  <li>
<strong>An Array</strong> - The elements of the array are copied into a new typed array. The constructor will throw an error if any elements are invalid for the type.</li>
  <li>
<strong>An Array-Like Object</strong> - Behaves the same as an array.</li>
</ul>

<p>In each of these cases, a new typed array is created with the data from the source object. This can be especially useful when you want to initialize a typed array with some values, like this:</p>

<figure class="code">
<pre><code>let ints1 = new Int16Array([25, 50]),
    ints2 = new Int32Array(ints1);

console.log(ints1.buffer === ints2.buffer);     // false

console.log(ints1.byteLength);      // 4
console.log(ints1.length);          // 2
console.log(ints1[0]);              // 25
console.log(ints1[1]);              // 50

console.log(ints2.byteLength);      // 8
console.log(ints2.length);          // 2
console.log(ints2[0]);              // 25
console.log(ints2[1]);              // 50
</code></pre>

</figure>

<p>This example creates an <code>Int16Array</code> and initializes it with an array of two values. Then, an <code>Int32Array</code> is created and passed the <code>Int16Array</code>. The values 25 and 50 are copied from <code>ints1</code> into <code>ints2</code> as the two typed arrays have completely separate buffers. The same numbers are represented in both typed arrays, but <code>ints2</code> has eight bytes to represent the data while <code>ints1</code> has only four.</p>

<h3 id="leanpub-auto-similarities-between-typed-and-regular-arrays">Similarities Between Typed and Regular Arrays</h3>

<p>Typed arrays and regular arrays are similar in several ways, and as you've already seen in this chapter, typed arrays can be used like regular arrays in many situations. For instance, you can check how many elements are in a typed array using the <code>length</code> property, and you can access a typed array's elements directly using numeric indices. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[0] = 1;
ints[1] = 2;

console.log(ints[0]);              // 1
console.log(ints[1]);              // 2
</code></pre>

</figure>

<p>In this code, a new <code>Int16Array</code> with two items is created. The items are read from and written to using their numeric indices, and those values are automatically stored and converted into int16 values as part of the operation. The similarities don't end there, though.</p>

<aside class="information blurb">
    <p>Unlike regular arrays, you cannot change the size of a typed array using the <code>length</code> property. The <code>length</code> property is not writable, so any attempt to change it is ignored in non-strict mode and throws an error in strict mode.</p>

</aside>

<h4 id="leanpub-auto-common-methods">Common Methods</h4>

<p>Typed arrays also include a large number of methods that are functionally equivalent to regular array methods. You can use the following array methods on typed arrays:</p>

<ul>
  <li><code>copyWithin()</code></li>
  <li><code>entries()</code></li>
  <li><code>fill()</code></li>
  <li><code>filter()</code></li>
  <li><code>find()</code></li>
  <li><code>findIndex()</code></li>
  <li><code>forEach()</code></li>
  <li><code>indexOf()</code></li>
  <li><code>join()</code></li>
  <li><code>keys()</code></li>
  <li><code>lastIndexOf()</code></li>
  <li><code>map()</code></li>
  <li><code>reduce()</code></li>
  <li><code>reduceRight()</code></li>
  <li><code>reverse()</code></li>
  <li><code>slice()</code></li>
  <li><code>some()</code></li>
  <li><code>sort()</code></li>
  <li><code>values()</code></li>
</ul>

<p>Keep in mind that while these methods act like their counterparts on <code>Array.prototype</code>, they are not exactly the same. The typed array methods have additional checks for numeric type safety and, when an array is returned, will return a typed array instead of a regular array (due to <code>Symbol.species</code>). Here's a simple example to demonstrate the difference:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]),
    mapped = ints.map(v =&gt; v * 2);

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 50
console.log(mapped[1]);            // 100

console.log(mapped instanceof Int16Array);  // true
</code></pre>

</figure>

<p>This code uses the <code>map()</code> method to create a new array based on the values in <code>ints</code>. The mapping function doubles each value in the array and returns a new <code>Int16Array</code>.</p>

<h4 id="leanpub-auto-the-same-iterators">The Same Iterators</h4>

<p>Typed arrays have the same three iterators as regular arrays, too. Those are the <code>entries()</code> method, the <code>keys()</code> method, and the <code>values()</code> method. That means you can use the spread operator and <code>for-of</code> loops with typed arrays just like you would with regular arrays. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]),
    intsArray = [...ints];

console.log(intsArray instanceof Array);    // true
console.log(intsArray[0]);                  // 25
console.log(intsArray[1]);                  // 50
</code></pre>

</figure>

<p>This code creates a new array called <code>intsArray</code> containing the same data as the typed array <code>ints</code>. As with other iterables, the spread operator makes converting typed arrays into regular arrays easy.</p>

<h4 id="leanpub-auto-of-and-from-methods">of() and from() Methods</h4>

<p>Lastly, all typed arrays have static <code>of()</code> and <code>from()</code> methods that work like the <code>Array.of()</code> and <code>Array.from()</code> methods. The difference is that the methods on typed arrays return a typed array instead of a regular array. Here are some examples that use these methods to create typed arrays:</p>

<figure class="code">
<pre><code>let ints = Int16Array.of(25, 50),
    floats = Float32Array.from([1.5, 2.5]);

console.log(ints instanceof Int16Array);        // true
console.log(floats instanceof Float32Array);    // true

console.log(ints.length);       // 2
console.log(ints[0]);           // 25
console.log(ints[1]);           // 50

console.log(floats.length);     // 2
console.log(floats[0]);         // 1.5
console.log(floats[1]);         // 2.5
</code></pre>

</figure>

<p>The <code>of()</code> and <code>from()</code> methods in this example are used to create an <code>Int16Array</code> and a <code>Float32Array</code>, respectively. These methods ensure that typed arrays can be created just as easily as regular arrays.</p>

<h3 id="leanpub-auto-differences-between-typed-and-regular-arrays">Differences Between Typed and Regular Arrays</h3>

<p>The most importance difference between typed arrays and regular arrays is that typed arrays are not regular arrays. Typed arrays don't inherit from <code>Array</code> and <code>Array.isArray()</code> returns <code>false</code> when passed a typed array. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]);

console.log(ints instanceof Array);     // false
console.log(Array.isArray(ints));       // false
</code></pre>

</figure>

<p>Since the <code>ints</code> variable is a typed array, it isn't an instance of <code>Array</code> and cannot otherwise be identified as an array. This distinction is important because while typed arrays and regular arrays are similar, there are many ways in which typed arrays behave differently.</p>

<h4 id="leanpub-auto-behavioral-differences">Behavioral Differences</h4>

<p>While regular arrays can grow and shrink as you interact with them, typed arrays always remain the same size. You cannot assign a value to a nonexistent numeric index in a typed array like you can with regular arrays, as typed arrays ignore the operation. Here's an example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]);

console.log(ints.length);          // 2
console.log(ints[0]);              // 25
console.log(ints[1]);              // 50

ints[2] = 5;

console.log(ints.length);          // 2
console.log(ints[2]);              // undefined
</code></pre>

</figure>

<p>Despite assigning <code>5</code> to the numeric index <code>2</code> in this example, the <code>ints</code> array does not grow at all. The <code>length</code> remains the same and the value is thrown away.</p>

<p>Typed arrays also have checks to ensure that only valid data types are used. Zero is used in place of any invalid values. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array(["hi"]);

console.log(ints.length);       // 1
console.log(ints[0]);           // 0
</code></pre>

</figure>

<p>This code attempts to use the string value <code>"hi"</code> in an <code>Int16Array</code>. Of course, strings are invalid data types in typed arrays, so the value is inserted as <code>0</code> instead. The <code>length</code> of the array is still one, and even though the <code>ints[0]</code> slot exists, it just contains <code>0</code>.</p>

<p>All methods that modify values in a typed array enforce the same restriction. For example, if the function passed to <code>map()</code> returns an invalid value for the typed array, then <code>0</code> is used instead:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50]),
    mapped = ints.map(v =&gt; "hi");

console.log(mapped.length);        // 2
console.log(mapped[0]);            // 0
console.log(mapped[1]);            // 0

console.log(mapped instanceof Int16Array);  // true
console.log(mapped instanceof Array);       // false
</code></pre>

</figure>

<p>Since the string value <code>"hi"</code> isn't a 16-bit integer, it's replaced with <code>0</code> in the resulting array. Thanks to this error correction behavior, typed array methods don't have to worry about throwing errors when invalid data is present, because there will never be invalid data in the array.</p>

<h4 id="leanpub-auto-missing-methods">Missing Methods</h4>

<p>While typed arrays do have many of the same methods as regular arrays, they also lack several array methods. The following methods are not available on typed arrays:</p>

<ul>
  <li><code>concat()</code></li>
  <li><code>pop()</code></li>
  <li><code>push()</code></li>
  <li><code>shift()</code></li>
  <li><code>splice()</code></li>
  <li><code>unshift()</code></li>
</ul>

<p>Except for the <code>concat()</code> method, the methods in this list can change the size of an array. Typed arrays can't change size, which is why these aren't available for typed arrays. The <code>concat()</code> method isn't available because the result of concatenating two typed arrays (especially if they deal with different data types) would be uncertain, and that would go against the reason for using typed arrays in the first place.</p>

<h4 id="leanpub-auto-additional-methods">Additional Methods</h4>

<p>Finally, typed arrays methods have two methods not present on regular arrays: the <code>set()</code> and <code>subarray()</code> methods. These two methods are opposites in that <code>set()</code> copies another array into an existing typed array, whereas <code>subarray()</code> extracts part of an existing typed array into a new typed array.</p>

<p>The <code>set()</code> method accepts an array (either typed or regular) and an optional offset at which to insert the data; if you pass nothing, the offset defaults to zero. The data from the array argument is copied into the destination typed array while ensuring only valid data types are used. Here's an example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array(4);

ints.set([25, 50]);
ints.set([75, 100], 2);

console.log(ints.toString());   // 25,50,75,100
</code></pre>

</figure>

<p>This code creates an <code>Int16Array</code> with four elements. The first call to <code>set()</code> copies two values to the first and second elements in the array. The second call to <code>set()</code> uses an offset of <code>2</code> to indicate that the values should be placed in the array starting at the third element.</p>

<p>The <code>subarray()</code> method accepts an optional start and end index (the end index is exclusive, as in the <code>slice()</code> method) and returns a new typed array. You can also omit both arguments to create a clone of the typed array. For example:</p>

<figure class="code">
<pre><code>let ints = new Int16Array([25, 50, 75, 100]),
    subints1 = ints.subarray(),
    subints2 = ints.subarray(2),
    subints3 = ints.subarray(1, 3);

console.log(subints1.toString());   // 25,50,75,100
console.log(subints2.toString());   // 75,100
console.log(subints3.toString());   // 50,75
</code></pre>

</figure>

<p>Three typed arrays are created from the original <code>ints</code> array in this example. The <code>subints1</code> array is a clone of <code>ints</code> that contains the same information. Since the <code>subints2</code> array copies data starting from index 2, it only contains the last two elements of the <code>ints</code> array (75 and 100). The <code>subints3</code> array contains only the middle two elements of the <code>ints</code> array, as <code>subarray()</code> was called with both a start and an end index.</p>

<h3 id="leanpub-auto-summary-9">Summary</h3>

<p>ECMAScript 6 continues the work of ECMAScript 5 by making arrays more useful. There are two more ways to create arrays: the <code>Array.of()</code> and <code>Array.from()</code> methods. The <code>Array.from()</code> method can also convert iterables and array-like objects into arrays. Both methods are inherited by derived array classes and use the <code>Symbol.species</code> property to determine what type of value should be returned (other inherited methods also use <code>Symbol.species</code> when returning an array).</p>

<p>There are also several new methods on arrays. The <code>fill()</code> and <code>copyWithin()</code> methods allow you to alter array elements in-place. The <code>find()</code> and <code>findIndex()</code> methods are useful for finding the first element in an array that matches some criteria. The former returns the first element that fits the criteria, and the latter returns the element's index.</p>

<p>Typed arrays are not technically arrays, as they do not inherit from <code>Array</code>, but they do look and behave a lot like arrays. Typed arrays contain one of eight different numeric data types and are built upon <code>ArrayBuffer</code> objects that represent the underlying bits of a number or series of numbers. Typed arrays are a more efficient way of doing bitwise arithmetic because the values are not converted back and forth between formats, as is the case with the JavaScript number type.</p>


<h2 id="leanpub-auto-promises-and-asynchronous-programming">Promises and Asynchronous Programming</h2>

<p>One of the most powerful aspects of JavaScript is how easily it handles asynchronous programming. As a language created for the Web, JavaScript needed to be able to respond to asynchronous user interactions such as clicks and key presses from the beginning. Node.js further popularized asynchronous programming in JavaScript by using callbacks as an alternative to events. As more and more programs started using asynchronous programming, events and callbacks were no longer powerful enough to support everything developers wanted to do. <em>Promises</em> are the solution to this problem.</p>

<p>Promises are another option for asynchronous programming, and they work like futures and deferreds do in other languages. A promise specifies some code to be executed later (as with events and callbacks) and also explicitly indicates whether the code succeeded or failed at its job. You can chain promises together based on success or failure in ways that make your code easier to understand and debug.</p>

<p>To have a good understanding of how promises work, however, it's important to understand some of the basic concepts upon which they are built.</p>

<h3 id="leanpub-auto-asynchronous-programming-background">Asynchronous Programming Background</h3>

<p>JavaScript engines are built on the concept of a single-threaded event loop. <em>Single-threaded</em> means that only one piece of code is ever executed at a time. Contrast this with languages like Java or C++, where threads can allow multiple different pieces of code to execute at the same time. Maintaining and protecting state when multiple pieces of code can access and change that state is a difficult problem and a frequent source of bugs in thread-based software.</p>

<p>JavaScript engines can only execute one piece of code at a time, so they need to keep track of code that is meant to run. That code is kept in a <em>job queue</em>. Whenever a piece of code is ready to be executed, it is added to the job queue. When the JavaScript engine is finished executing code, the event loop executes the next job in the queue. The <em>event loop</em> is a process inside the JavaScript engine that monitors code execution and manages the job queue. Keep in mind that as a queue, job execution runs from the first job in the queue to the last.</p>

<h4 id="leanpub-auto-the-event-model">The Event Model</h4>

<p>When a user clicks a button or presses a key on the keyboard, an <em>event</em> like <code>onclick</code> is triggered. That event might respond to the interaction by adding a new job to the back of the job queue. This is JavaScript's most basic form of asynchronous programming. The event handler code doesn't execute until the event fires, and when it does execute, it has the appropriate context. For example:</p>

<figure class="code">
<pre><code>let button = document.getElementById("my-btn");
button.onclick = function(event) {
    console.log("Clicked");
};
</code></pre>

</figure>

<p>In this code, <code>console.log("Clicked")</code> will not be executed until <code>button</code> is clicked. When <code>button</code> is clicked, the function assigned to <code>onclick</code> is added to the back of the job queue and will be executed when all other jobs ahead of it are complete.</p>

<p>Events work well for simple interactions, but chaining multiple separate asynchronous calls together is more complicated because you must keep track of the event target (<code>button</code> in the previous example) for each event. Additionally, you need to ensure all appropriate event handlers are added before the first time an event occurs. For instance, if <code>button</code> were clicked before <code>onclick</code> is assigned, nothing would happen. So while events are useful for responding to user interactions and similar infrequent functionality, they aren't very flexible for more complex needs.</p>

<h4 id="leanpub-auto-the-callback-pattern">The Callback Pattern</h4>

<p>When Node.js was created, it advanced the asynchronous programming model by popularizing the callback pattern of programming. The callback pattern is similar to the event model because the asynchronous code doesn't execute until a later point in time. It's different because the function to call is passed in as an argument, as shown here:</p>

<figure class="code">
<pre><code>readFile("example.txt", function(err, contents) {
    if (err) {
        throw err;
    }

    console.log(contents);
});
console.log("Hi!");
</code></pre>

</figure>

<p>This example uses the traditional Node.js <em>error-first</em> callback style. The <code>readFile()</code> function is intended to read from a file on disk (specified as the first argument) and then execute the callback (the second argument) when complete. If there's an error, the <code>err</code> argument of the callback is an error object; otherwise, the <code>contents</code> argument contains the file contents as a string.</p>

<p>Using the callback pattern, <code>readFile()</code> begins executing immediately and pauses when it starts reading from the disk. That means <code>console.log("Hi!")</code> is output immediately after <code>readFile()</code> is called, before <code>console.log(contents)</code> prints anything. When <code>readFile()</code> finishes, it adds a new job to the end of the job queue with the callback function and its arguments. That job is then executed upon completion of all other jobs ahead of it.</p>

<p>The callback pattern is more flexible than events because chaining multiple calls together is easier with callbacks. For example:</p>

<figure class="code">
<pre><code>readFile("example.txt", function(err, contents) {
    if (err) {
        throw err;
    }

    writeFile("example.txt", function(err) {
        if (err) {
            throw err;
        }

        console.log("File was written!");
    });
});
</code></pre>

</figure>

<p>In this code, a successful call to <code>readFile()</code> results in another asynchronous call, this time to the <code>writeFile()</code> function. Note that the same basic pattern of checking <code>err</code> is present in both functions. When <code>readFile()</code> is complete, it adds a job to the job queue that results in <code>writeFile()</code> being called (assuming no errors). Then, <code>writeFile()</code> adds a job to the job queue when it finishes.</p>

<p>This pattern works fairly well, but you can quickly find yourself in <em>callback hell</em>. Callback hell occurs when you nest too many callbacks, like this:</p>

<figure class="code">
<pre><code>method1(function(err, result) {

    if (err) {
        throw err;
    }

    method2(function(err, result) {

        if (err) {
            throw err;
        }

        method3(function(err, result) {

            if (err) {
                throw err;
            }

            method4(function(err, result) {

                if (err) {
                    throw err;
                }

                method5(result);
            });

        });

    });

});
</code></pre>

</figure>

<p>Nesting multiple method calls as this example does creates a tangled web of code that is hard to understand and debug. Callbacks also present problems when you want to implement more complex functionality. What if you want two asynchronous operations to run in parallel and notify you when they're both complete? What if you'd like to start two asynchronous operations at a time but only take the result of the first one to complete?</p>

<p>In these cases, you'd need to track multiple callbacks and cleanup operations, and promises greatly improve such situations.</p>

<h3 id="leanpub-auto-promise-basics">Promise Basics</h3>

<p>A promise is a placeholder for the result of an asynchronous operation. Instead of subscribing to an event or passing a callback to a function, the function can return a promise, like this:</p>

<figure class="code">
<pre><code>// readFile promises to complete at some point in the future
let promise = readFile("example.txt");
</code></pre>

</figure>

<p>In this code, <code>readFile()</code> doesn't actually start reading the file immediately; that will happen later. Instead, the function returns a promise object representing the asynchronous read operation so you can work with it in the future. Exactly when you'll be able to work with that result depends entirely on how the promise's lifecycle plays out.</p>

<h4 id="leanpub-auto-the-promise-lifecycle">The Promise Lifecycle</h4>

<p>Each promise goes through a short lifecycle starting in the <em>pending</em> state, which indicates that the asynchronous operation hasn't completed yet. A pending promise is considered <em>unsettled</em>. The promise in the last example is in the pending state as soon as the <code>readFile()</code> function returns it. Once the asynchronous operation completes, the promise is considered <em>settled</em> and enters one of two possible states:</p>

<ol class="numeric">
  <li>
<em>Fulfilled</em>: The promise's asynchronous operation has completed successfully.</li>
  <li>
<em>Rejected</em>: The promise's asynchronous operation didn't complete successfully due to either an error or some other cause.</li>
</ol>

<p>An internal <code>[[PromiseState]]</code> property is set to <code>"pending"</code>, <code>"fulfilled"</code>, or <code>"rejected"</code> to reflect the promise's state. This property isn't exposed on promise objects, so you can't determine which state the promise is in programmatically. But you can take a specific action when a promise changes state by using the <code>then()</code> method.</p>

<p>The <code>then()</code> method is present on all promises and takes two arguments. The first argument is a function to call when the promise is fulfilled. Any additional data related to the asynchronous operation is passed to this fulfillment function. The second argument is a function to call when the promise is rejected. Similar to the fulfillment function, the rejection function is passed any additional data related to the rejection.</p>

<aside class="information blurb">
    <p>Any object that implements the <code>then()</code> method in this way is called a <em>thenable</em>. All promises are thenables, but not all thenables are promises.</p>

</aside>

<p>Both arguments to <code>then()</code> are optional, so you can listen for any combination of fulfillment and rejection. For example, consider this set of <code>then()</code> calls:</p>

<figure class="code">
<pre><code>let promise = readFile("example.txt");

promise.then(function(contents) {
    // fulfillment
    console.log(contents);
}, function(err) {
    // rejection
    console.error(err.message);
});

promise.then(function(contents) {
    // fulfillment
    console.log(contents);
});

promise.then(null, function(err) {
    // rejection
    console.error(err.message);
});
</code></pre>

</figure>

<p>All three <code>then()</code> calls operate on the same promise. The first call listens for both fulfillment and rejection. The second only listens for fulfillment; errors won't be reported. The third just listens for rejection and doesn't report success.</p>

<p>Promises also have a <code>catch()</code> method that behaves the same as <code>then()</code> when only a rejection handler is passed. For example, the following <code>catch()</code> and <code>then()</code> calls are functionally equivalent:</p>

<figure class="code">
<pre><code>promise.catch(function(err) {
    // rejection
    console.error(err.message);
});

// is the same as:

promise.then(null, function(err) {
    // rejection
    console.error(err.message);
});
</code></pre>

</figure>

<p>The intent behind <code>then()</code> and <code>catch()</code> is for you to use them in combination to properly handle the result of asynchronous operations. This system is better than events and callbacks because it makes whether the operation succeeded or failed completely clear. (Events tend not to fire when there's an error, and in callbacks you must always remember to check the error argument.) Just know that if you don't attach a rejection handler to a promise, all failures will happen silently. Always attach a rejection handler, even if the handler just logs the failure.</p>

<p>A fulfillment or rejection handler will still be executed even if it is added to the job queue after the promise is already settled. This allows you to add new fulfillment and rejection handlers at any time and guarantee that they will be called. For example:</p>

<figure class="code">
<pre><code>let promise = readFile("example.txt");

// original fulfillment handler
promise.then(function(contents) {
    console.log(contents);

    // now add another
    promise.then(function(contents) {
        console.log(contents);
    });
});
</code></pre>

</figure>

<p>In this code, the fulfillment handler adds another fulfillment handler to the same promise. The promise is already fulfilled at this point, so the new fulfillment handler is added to the job queue and called when ready. Rejection handlers work the same way.</p>

<aside class="information blurb">
    <p>Each call to <code>then()</code> or <code>catch()</code> creates a new job to be executed when the promise is resolved. But these jobs end up in a separate job queue that is reserved strictly for promises. The precise details of this second job queue aren't important for understanding how to use promises so long as you understand how job queues work in general.</p>

</aside>

<h4 id="leanpub-auto-creating-unsettled-promises">Creating Unsettled Promises</h4>

<p>New promises are created using the <code>Promise</code> constructor. This constructor accepts a single argument: a function called the <em>executor</em>, which contains the code to initialize the promise. The executor is passed two functions named <code>resolve()</code> and <code>reject()</code> as arguments. The <code>resolve()</code> function is called when the executor has finished successfully to signal that the promise is ready to be resolved, while the <code>reject()</code> function indicates that the executor has failed.</p>

<p>Here's an example that uses a promise in Node.js to implement the <code>readFile()</code> function from earlier in this chapter:</p>

<figure class="code">
<pre><code>// Node.js example

let fs = require("fs");

function readFile(filename) {
    return new Promise(function(resolve, reject) {

        // trigger the asynchronous operation
        fs.readFile(filename, { encoding: "utf8" }, function(err, contents) {

            // check for errors
            if (err) {
                reject(err);
                return;
            }

            // the read succeeded
            resolve(contents);

        });
    });
}

let promise = readFile("example.txt");

// listen for both fulfillment and rejection
promise.then(function(contents) {
    // fulfillment
    console.log(contents);
}, function(err) {
    // rejection
    console.error(err.message);
});
</code></pre>

</figure>

<p>In this example, the native Node.js <code>fs.readFile()</code> asynchronous call is wrapped in a promise. The executor either passes the error object to the <code>reject()</code> function or passes the file contents to the <code>resolve()</code> function.</p>

<p>Keep in mind that the executor runs immediately when <code>readFile()</code> is called. When either <code>resolve()</code> or <code>reject()</code> is called inside the executor, a job is added to the job queue to resolve the promise. This is called <em>job scheduling</em>, and if you've ever used the <code>setTimeout()</code> or <code>setInterval()</code> functions, then you're already familiar with it. In job scheduling, you add a new job to the job queue to say, "Don't execute this right now, but execute it later." For instance, the <code>setTimeout()</code> function lets you specify a delay before a job is added to the queue:</p>

<figure class="code">
<pre><code>// add this function to the job queue after 500ms have passed
setTimeout(function() {
    console.log("Timeout");
}, 500);

console.log("Hi!");
</code></pre>

</figure>

<p>This code schedules a job to be added to the job queue after 500ms. The two <code>console.log()</code> calls produce the following output:</p>

<figure class="code">
<pre><code>Hi!
Timeout
</code></pre>

</figure>

<p>Thanks to the 500ms delay, the output that the function passed to <code>setTimeout()</code> was shown after the output from the <code>console.log("Hi!")</code> call.</p>

<p>Promises work similarly. The promise executor executes immediately, before anything that appears after it in the source code. For instance:</p>

<figure class="code">
<pre><code>let promise = new Promise(function(resolve, reject) {
    console.log("Promise");
    resolve();
});

console.log("Hi!");
</code></pre>

</figure>

<p>The output for this code is:</p>

<figure class="code">
<pre><code>Promise
Hi!
</code></pre>

</figure>

<p>Calling <code>resolve()</code> triggers an asynchronous operation. Functions passed to <code>then()</code> and <code>catch()</code> are executed asynchronously, as these are also added to the job queue. Here's an example:</p>

<figure class="code">
<pre><code>let promise = new Promise(function(resolve, reject) {
    console.log("Promise");
    resolve();
});

promise.then(function() {
    console.log("Resolved.");
});

console.log("Hi!");
</code></pre>

</figure>

<p>The output for this example is:</p>

<figure class="code">
<pre><code>Promise
Hi!
Resolved
</code></pre>

</figure>

<p>Note that even though the call to <code>then()</code> appears before the <code>console.log("Hi!")</code> line, it doesn't actually execute until later (unlike the executor). That's because fulfillment and rejection handlers are always added to the end of the job queue after the executor has completed.</p>

<h4 id="leanpub-auto-creating-settled-promises">Creating Settled Promises</h4>

<p>The <code>Promise</code> constructor is the best way to create unsettled promises due to the dynamic nature of what the promise executor does. But if you want a promise to represent just a single known value, then it doesn't make sense to schedule a job that simply passes a value to the <code>resolve()</code> function. Instead, there are two methods that create settled promises given a specific value.</p>

<h5 id="leanpub-auto-using-promiseresolve">Using Promise.resolve()</h5>

<p>The <code>Promise.resolve()</code> method accepts a single argument and returns a promise in the fulfilled state. That means no job scheduling occurs, and you need to add one or more fulfillment handlers to the promise to retrieve the value. For example:</p>

<figure class="code">
<pre><code>let promise = Promise.resolve(42);

promise.then(function(value) {
    console.log(value);         // 42
});
</code></pre>

</figure>

<p>This code creates a fulfilled promise so the fulfillment handler receives 42 as <code>value</code>. If a rejection handler were added to this promise, the rejection handler would never be called because the promise will never be in the rejected state.</p>

<h5 id="leanpub-auto-using-promisereject">Using Promise.reject()</h5>

<p>You can also create rejected promises by using the <code>Promise.reject()</code> method. This works like <code>Promise.resolve()</code> except the created promise is in the rejected state, as follows:</p>

<figure class="code">
<pre><code>let promise = Promise.reject(42);

promise.catch(function(value) {
    console.log(value);         // 42
});
</code></pre>

</figure>

<p>Any additional rejection handlers added to this promise would be called, but not fulfillment handlers.</p>

<aside class="information blurb">
    <p>If you pass a promise to either the <code>Promise.resolve()</code> or <code>Promise.reject()</code> methods, the promise is returned without modification.</p>

</aside>

<h5 id="leanpub-auto-non-promise-thenables">Non-Promise Thenables</h5>

<p>Both <code>Promise.resolve()</code> and <code>Promise.reject()</code> also accept non-promise thenables as arguments. When passed a non-promise thenable, these methods create a new promise that is called after the <code>then()</code> function.</p>

<p>A non-promise thenable is created when an object has a <code>then()</code> method that accepts a <code>resolve</code> and a <code>reject</code> argument, like this:</p>

<figure class="code">
<pre><code>let thenable = {
    then: function(resolve, reject) {
        resolve(42);
    }
};
</code></pre>

</figure>

<p>The <code>thenable</code> object in this example has no characteristics associated with a promise other than the <code>then()</code> method. You can call <code>Promise.resolve()</code> to convert <code>thenable</code> into a fulfilled promise:</p>

<figure class="code">
<pre><code>let thenable = {
    then: function(resolve, reject) {
        resolve(42);
    }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
    console.log(value);     // 42
});
</code></pre>

</figure>

<p>In this example, <code>Promise.resolve()</code> calls <code>thenable.then()</code> so that a promise state can be determined. The promise state for <code>thenable</code> is fulfilled because <code>resolve(42)</code> is called inside the <code>then()</code> method. A new promise called <code>p1</code> is created in the fulfilled state with the value passed from <code>thenable</code> (that is, 42), and the fulfillment handler for <code>p1</code> receives 42 as the value.</p>

<p>The same process can be used with <code>Promise.resolve()</code> to create a rejected promise from a thenable:</p>

<figure class="code">
<pre><code>let thenable = {
    then: function(resolve, reject) {
        reject(42);
    }
};

let p1 = Promise.resolve(thenable);
p1.catch(function(value) {
    console.log(value);     // 42
});
</code></pre>

</figure>

<p>This example is similar to the last except that <code>thenable</code> is rejected. When <code>thenable.then()</code> executes, a new promise is created in the rejected state with a value of 42. That value is then passed to the rejection handler for <code>p1</code>.</p>

<p><code>Promise.resolve()</code> and <code>Promise.reject()</code> work like this to allow you to easily work with non-promise thenables. A lot of libraries used thenables prior to promises being introduced in ECMAScript 6, so the ability to convert thenables into formal promises is important for backwards-compatibility with previously existing libraries. When you're unsure if an object is a promise, passing the object through <code>Promise.resolve()</code> or <code>Promise.reject()</code> (depending on your anticipated result) is the best way to find out because promises just pass through unchanged.</p>

<h4 id="leanpub-auto-executor-errors">Executor Errors</h4>

<p>If an error is thrown inside an executor, then the promise's rejection handler is called. For example:</p>

<figure class="code">
<pre><code>let promise = new Promise(function(resolve, reject) {
    throw new Error("Explosion!");
});

promise.catch(function(error) {
    console.log(error.message);     // "Explosion!"
});
</code></pre>

</figure>

<p>In this code, the executor intentionally throws an error. There is an implicit <code>try-catch</code> inside every executor such that the error is caught and then passed to the rejection handler. The previous example is equivalent to:</p>

<figure class="code">
<pre><code>let promise = new Promise(function(resolve, reject) {
    try {
        throw new Error("Explosion!");
    } catch (ex) {
        reject(ex);
    }
});

promise.catch(function(error) {
    console.log(error.message);     // "Explosion!"
});
</code></pre>

</figure>

<p>The executor handles catching any thrown errors to simplify this common use case, but an error thrown in the executor is only reported when a rejection handler is present. Otherwise, the error is suppressed. This became a problem for developers early on in the use of promises, and JavaScript environments address it by providing hooks for catching rejected promises.</p>

<h3 id="leanpub-auto-global-promise-rejection-handling">Global Promise Rejection Handling</h3>

<p>One of the most controversial aspects of promises is the silent failure that occurs when a promise is rejected without a rejection handler. Some consider this the biggest flaw in the specification as it's the only part of the JavaScript language that doesn't make errors apparent.</p>

<p>Determining whether a promise rejection was handled isn't straightforward due to the nature of promises. For instance, consider this example:</p>

<figure class="code">
<pre><code>let rejected = Promise.reject(42);

// at this point, rejected is unhandled

// some time later...
rejected.catch(function(value) {
    // now rejected has been handled
    console.log(value);
});
</code></pre>

</figure>

<p>You can call <code>then()</code> or <code>catch()</code> at any point and have them work correctly regardless of whether the promise is settled or not, making it hard to know precisely when a promise is going to be handled. In this case, the promise is rejected immediately but isn't handled until later.</p>

<p>While it's possible that the next version of ECMAScript will address this problem, both browsers and Node.js have implemented changes to address this developer pain point. They aren't part of the ECMAScript 6 specification but are valuable tools when using promises.</p>

<h4 id="leanpub-auto-nodejs-rejection-handling">Node.js Rejection Handling</h4>

<p>In Node.js, there are two events on the <code>process</code> object related to promise rejection handling:</p>

<ul>
  <li>
<code>unhandledRejection</code>: Emitted when a promise is rejected and no rejection handler is called within one turn of the event loop</li>
  <li>
<code>rejectionHandled</code>: Emitted when a promise is rejected and a rejection handler is called after one turn of the event loop</li>
</ul>

<p>These events are designed to work together to help identify promises that are rejected and not handled.</p>

<p>The <code>unhandledRejection</code> event handler is passed the rejection reason (frequently an error object) and the promise that was rejected as arguments. The following code shows <code>unhandledRejection</code> in action:</p>

<figure class="code">
<pre><code>let rejected;

process.on("unhandledRejection", function(reason, promise) {
    console.log(reason.message);            // "Explosion!"
    console.log(rejected === promise);      // true
});

rejected = Promise.reject(new Error("Explosion!"));
</code></pre>

</figure>

<p>This example creates a rejected promise with an error object and listens for the <code>unhandledRejection</code> event. The event handler receives the error object as the first argument and the promise as the second.</p>

<p>The <code>rejectionHandled</code> event handler has only one argument, which is the promise that was rejected. For example:</p>

<figure class="code">
<pre><code>let rejected;

process.on("rejectionHandled", function(promise) {
    console.log(rejected === promise);              // true
});

rejected = Promise.reject(new Error("Explosion!"));

// wait to add the rejection handler
setTimeout(function() {
    rejected.catch(function(value) {
        console.log(value.message);     // "Explosion!"
    });
}, 1000);
</code></pre>

</figure>

<p>Here, the <code>rejectionHandled</code> event is emitted when the rejection handler is finally called. If the rejection handler were attached directly to <code>rejected</code> after <code>rejected</code> is created, then the event wouldn't be emitted. The rejection handler would instead be called during the same turn of the event loop where <code>rejected</code> was created, which isn't useful.</p>

<p>To properly track potentially unhandled rejections, use the <code>rejectionHandled</code> and <code>unhandledRejection</code> events to keep a list of potentially unhandled rejections. Then wait some period of time to inspect the list. For example:</p>

<figure class="code">
<pre><code>let possiblyUnhandledRejections = new Map();

// when a rejection is unhandled, add it to the map
process.on("unhandledRejection", function(reason, promise) {
    possiblyUnhandledRejections.set(promise, reason);
});

process.on("rejectionHandled", function(promise) {
    possiblyUnhandledRejections.delete(promise);
});

setInterval(function() {

    possiblyUnhandledRejections.forEach(function(reason, promise) {
        console.log(reason.message ? reason.message : reason);

        // do something to handle these rejections
        handleRejection(promise, reason);
    });

    possiblyUnhandledRejections.clear();

}, 60000);
</code></pre>

</figure>

<p>This is a simple unhandled rejection tracker. It uses a map to store promises and their rejection reasons. Each promise is a key, and the promise's reason is the associated value. Each time <code>unhandledRejection</code> is emitted, the promise and its rejection reason are added to the map. Each time <code>rejectionHandled</code> is emitted, the handled promise is removed from the map. As a result, <code>possiblyUnhandledRejections</code> grows and shrinks as events are called. The <code>setInterval()</code> call periodically checks the list of possible unhandled rejections and outputs the information to the console (in reality, you'll probably want to do something else to log or otherwise handle the rejection). A map is used in this example instead of a weak map because you need to inspect the map periodically to see which promises are present, and that's not possible with a weak map.</p>

<p>While this example is specific to Node.js, browsers have implemented a similar mechanism for notifying developers about unhandled rejections.</p>

<h4 id="leanpub-auto-browser-rejection-handling">Browser Rejection Handling</h4>

<p>Browsers also emit two events to help identify unhandled rejections. These events are emitted by the <code>window</code> object and are effectively the same as their Node.js equivalents:</p>

<ul>
  <li>
<code>unhandledrejection</code>: Emitted when a promise is rejected and no rejection handler is called within one turn of the event loop.</li>
  <li>
<code>rejectionhandled</code>: Emitted when a promise is rejected and a rejection handler is called after one turn of the event loop.</li>
</ul>

<p>While the Node.js implementation passes individual parameters to the event handler, the event handler for these browser events receives an event object with the following properties:</p>

<ul>
  <li>
<code>type</code>: The name of the event (<code>"unhandledrejection"</code> or <code>"rejectionhandled"</code>).</li>
  <li>
<code>promise</code>: The promise object that was rejected.</li>
  <li>
<code>reason</code>: The rejection value from the promise.</li>
</ul>

<p>The other difference in the browser implementation is that the rejection value (<code>reason</code>) is available for both events. For example:</p>

<figure class="code">
<pre><code>let rejected;

window.onunhandledrejection = function(event) {
    console.log(event.type);                    // "unhandledrejection"
    console.log(event.reason.message);          // "Explosion!"
    console.log(rejected === event.promise);    // true
};

window.onrejectionhandled = function(event) {
    console.log(event.type);                    // "rejectionhandled"
    console.log(event.reason.message);          // "Explosion!"
    console.log(rejected === event.promise);    // true
};

rejected = Promise.reject(new Error("Explosion!"));
</code></pre>

</figure>

<p>This code assigns both event handlers using the DOM Level 0 notation of <code>onunhandledrejection</code> and <code>onrejectionhandled</code>. (You can also use <code>addEventListener("unhandledrejection")</code> and <code>addEventListener("rejectionhandled")</code> if you prefer.) Each event handler receives an event object containing information about the rejected promise. The <code>type</code>, <code>promise</code>, and <code>reason</code> properties are all available in both event handlers.</p>

<p>The code to keep track of unhandled rejections in the browser is very similar to the code for Node.js, too:</p>

<figure class="code">
<pre><code>let possiblyUnhandledRejections = new Map();

// when a rejection is unhandled, add it to the map
window.onunhandledrejection = function(event) {
    possiblyUnhandledRejections.set(event.promise, event.reason);
};

window.onrejectionhandled = function(event) {
    possiblyUnhandledRejections.delete(event.promise);
};

setInterval(function() {

    possiblyUnhandledRejections.forEach(function(reason, promise) {
        console.log(reason.message ? reason.message : reason);

        // do something to handle these rejections
        handleRejection(promise, reason);
    });

    possiblyUnhandledRejections.clear();

}, 60000);
</code></pre>

</figure>

<p>This implementation is almost exactly the same as the Node.js implementation. It uses the same approach of storing promises and their rejection values in a map and then inspecting them later. The only real difference is where the information is retrieved from in the event handlers.</p>

<p>Handling promise rejections can be tricky, but you've just begun to see how powerful promises can really be. It's time to take the next step and chain several promises together.</p>

<h3 id="leanpub-auto-chaining-promises">Chaining Promises</h3>

<p>To this point, promises may seem like little more than an incremental improvement over using some combination of a callback and the <code>setTimeout()</code> function, but there is much more to promises than meets the eye. More specifically, there are a number of ways to chain promises together to accomplish more complex asynchronous behavior.</p>

<p>Each call to <code>then()</code> or <code>catch()</code> actually creates and returns another promise. This second promise is resolved only once the first has been fulfilled or rejected. Consider this example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

p1.then(function(value) {
    console.log(value);
}).then(function() {
    console.log("Finished");
});
</code></pre>

</figure>

<p>The code outputs:</p>

<figure class="code">
<pre><code>42
Finished
</code></pre>

</figure>

<p>The call to <code>p1.then()</code> returns a second promise on which <code>then()</code> is called. The second <code>then()</code> fulfillment handler is only called after the first promise has been resolved. If you unchain this example, it looks like this:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = p1.then(function(value) {
    console.log(value);
})

p2.then(function() {
    console.log("Finished");
});
</code></pre>

</figure>

<p>In this unchained version of the code, the result of <code>p1.then()</code> is stored in <code>p2</code>, and then <code>p2.then()</code> is called to add the final fulfillment handler. As you might have guessed, the call to <code>p2.then()</code> also returns a promise. This example just doesn't use that promise.</p>

<h4 id="leanpub-auto-catching-errors">Catching Errors</h4>

<p>Promise chaining allows you to catch errors that may occur in a fulfillment or rejection handler from a previous promise. For example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

p1.then(function(value) {
    throw new Error("Boom!");
}).catch(function(error) {
    console.log(error.message);     // "Boom!"
});
</code></pre>

</figure>

<p>In this code, the fulfillment handler for <code>p1</code> throws an error. The chained call to the <code>catch()</code> method, which is on a second promise, is able to receive that error through its rejection handler. The same is true if a rejection handler throws an error:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    throw new Error("Explosion!");
});

p1.catch(function(error) {
    console.log(error.message);     // "Explosion!"
    throw new Error("Boom!");
}).catch(function(error) {
    console.log(error.message);     // "Boom!"
});
</code></pre>

</figure>

<p>Here, the executor throws an error then triggers the <code>p1</code> promise's rejection handler. That handler then throws another error that is caught by the second promise's rejection handler. The chained promise calls are aware of errors in other promises in the chain.</p>

<aside class="information blurb">
    <p>Always have a rejection handler at the end of a promise chain to ensure that you can properly handle any errors that may occur.</p>

</aside>

<h4 id="leanpub-auto-returning-values-in-promise-chains">Returning Values in Promise Chains</h4>

<p>Another important aspect of promise chains is the ability to pass data from one promise to the next. You've already seen that a value passed to the <code>resolve()</code> handler inside an executor is passed to the fulfillment handler for that promise. You can continue passing data along a chain by specifying a return value from the fulfillment handler. For example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

p1.then(function(value) {
    console.log(value);         // "42"
    return value + 1;
}).then(function(value) {
    console.log(value);         // "43"
});
</code></pre>

</figure>

<p>The fulfillment handler for <code>p1</code> returns <code>value + 1</code> when executed. Since <code>value</code> is 42 (from the executor), the fulfillment handler returns 43. That value is then passed to the fulfillment handler of the second promise, which outputs it to the console.</p>

<p>You could do the same thing with the rejection handler. When a rejection handler is called, it may return a value. If it does, that value is used to fulfill the next promise in the chain, like this:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    reject(42);
});

p1.catch(function(value) {
    // first fulfillment handler
    console.log(value);         // "42"
    return value + 1;
}).then(function(value) {
    // second fulfillment handler
    console.log(value);         // "43"
});
</code></pre>

</figure>

<p>Here, the executor calls <code>reject()</code> with 42. That value is passed into the rejection handler for the promise, where <code>value + 1</code> is returned. Even though this return value is coming from a rejection handler, it is still used in the fulfillment handler of the next promise in the chain. The failure of one promise can allow recovery of the entire chain if necessary.</p>

<h4 id="leanpub-auto-returning-promises-in-promise-chains">Returning Promises in Promise Chains</h4>

<p>Returning primitive values from fulfillment and rejection handlers allows passing of data between promises, but what if you return an object? If the object is a promise, then there's an extra step that's taken to determine how to proceed. Consider the following example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    resolve(43);
});

p1.then(function(value) {
    // first fulfillment handler
    console.log(value);     // 42
    return p2;
}).then(function(value) {
    // second fulfillment handler
    console.log(value);     // 43
});
</code></pre>

</figure>

<p>In this code, <code>p1</code> schedules a job that resolves to 42. The fulfillment handler for <code>p1</code> returns <code>p2</code>, a promise already in the resolved state. The second fulfillment handler is called because <code>p2</code> has been fulfilled. If <code>p2</code> were rejected, a rejection handler (if present) would be called instead of the second fulfillment handler.</p>

<p>The important thing to recognize about this pattern is that the second fulfillment handler is not added to <code>p2</code>, but rather to a third promise. The second fulfillment handler is therefore attached to that third promise, making the previous example equivalent to this:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    resolve(43);
});

let p3 = p1.then(function(value) {
    // first fulfillment handler
    console.log(value);     // 42
    return p2;
});

p3.then(function(value) {
    // second fulfillment handler
    console.log(value);     // 43
});
</code></pre>

</figure>

<p>Here, it's clear that the second fulfillment handler is attached to <code>p3</code> rather than <code>p2</code>. This is a subtle but important distinction, as the second fulfillment handler will not be called if <code>p2</code> is rejected. For instance:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    reject(43);
});

p1.then(function(value) {
    // first fulfillment handler
    console.log(value);     // 42
    return p2;
}).then(function(value) {
    // second fulfillment handler
    console.log(value);     // never called
});
</code></pre>

</figure>

<p>In this example, the second fulfillment handler is never called because <code>p2</code> is rejected. You could, however, attach a rejection handler instead:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    reject(43);
});

p1.then(function(value) {
    // first fulfillment handler
    console.log(value);     // 42
    return p2;
}).catch(function(value) {
    // rejection handler
    console.log(value);     // 43
});
</code></pre>

</figure>

<p>Here, the rejection handler is called as a result of <code>p2</code> being rejected. The rejected value 43 from <code>p2</code> is passed into that rejection handler.</p>

<p>Returning thenables from fulfillment or rejection handlers doesn't change when the promise executors are executed. The first defined promise will run its executor first, then the second promise executor will run, and so on. Returning thenables simply allows you to define additional responses to the promise results. You defer the execution of fulfillment handlers by creating a new promise within a fulfillment handler. For example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

p1.then(function(value) {
    console.log(value);     // 42

    // create a new promise
    let p2 = new Promise(function(resolve, reject) {
        resolve(43);
    });

    return p2
}).then(function(value) {
    console.log(value);     // 43
});
</code></pre>

</figure>

<p>In this example, a new promise is created within the fulfillment handler for <code>p1</code>. That means the second fulfillment handler won't execute until after <code>p2</code> is fulfilled. This pattern is useful when you want to wait until a previous promise has been settled before triggering another promise.</p>

<h3 id="leanpub-auto-responding-to-multiple-promises">Responding to Multiple Promises</h3>

<p>Up to this point, each example in this chapter has dealt with responding to one promise at a time. Sometimes, however, you'll want to monitor the progress of multiple promises in order to determine the next action. ECMAScript 6 provides two methods that monitor multiple promises: <code>Promise.all()</code> and <code>Promise.race()</code>.</p>

<h4 id="leanpub-auto-the-promiseall-method">The Promise.all() Method</h4>

<p>The <code>Promise.all()</code> method accepts a single argument, which is an iterable (such as an array) of promises to monitor, and returns a promise that is resolved only when every promise in the iterable is resolved. The returned promise is fulfilled when every promise in the iterable is fulfilled, as in this example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    resolve(43);
});

let p3 = new Promise(function(resolve, reject) {
    resolve(44);
});

let p4 = Promise.all([p1, p2, p3]);

p4.then(function(value) {
    console.log(Array.isArray(value));  // true
    console.log(value[0]);              // 42
    console.log(value[1]);              // 43
    console.log(value[2]);              // 44
});
</code></pre>

</figure>

<p>Each promise here resolves with a number. The call to <code>Promise.all()</code> creates promise <code>p4</code>, which is ultimately fulfilled when promises <code>p1</code>, <code>p2</code>, and <code>p3</code> are fulfilled. The result passed to the fulfillment handler for <code>p4</code> is an array containing each resolved value: 42, 43, and 44. The values are stored in the order the promises were passed to <code>Promise.all</code>, so you can match promise results to the promises that resolved to them.</p>

<p>If any promise passed to <code>Promise.all()</code> is rejected, the returned promise is immediately rejected without waiting for the other promises to complete:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = new Promise(function(resolve, reject) {
    reject(43);
});

let p3 = new Promise(function(resolve, reject) {
    resolve(44);
});

let p4 = Promise.all([p1, p2, p3]);

p4.catch(function(value) {
    console.log(Array.isArray(value))   // false
    console.log(value);                 // 43
});
</code></pre>

</figure>

<p>In this example, <code>p2</code> is rejected with a value of 43. The rejection handler for <code>p4</code> is called immediately without waiting for <code>p1</code> or <code>p3</code> to finish executing (They do still finish executing; <code>p4</code> just doesn't wait.)</p>

<p>The rejection handler always receives a single value rather than an array, and the value is the rejection value from the promise that was rejected. In this case, the rejection handler is passed 43 to reflect the rejection from <code>p2</code>.</p>

<h4 id="leanpub-auto-the-promiserace-method">The Promise.race() Method</h4>

<p>The <code>Promise.race()</code> method provides a slightly different take on monitoring multiple promises. This method also accepts an iterable of promises to monitor and returns a promise, but the returned promise is settled as soon as the first promise is settled. Instead of waiting for all promises to be fulfilled like the <code>Promise.all()</code> method, the <code>Promise.race()</code> method returns an appropriate promise as soon as any promise in the array is fulfilled. For example:</p>

<figure class="code">
<pre><code>let p1 = Promise.resolve(42);

let p2 = new Promise(function(resolve, reject) {
    resolve(43);
});

let p3 = new Promise(function(resolve, reject) {
    resolve(44);
});

let p4 = Promise.race([p1, p2, p3]);

p4.then(function(value) {
    console.log(value);     // 42
});
</code></pre>

</figure>

<p>In this code, <code>p1</code> is created as a fulfilled promise while the others schedule jobs. The fulfillment handler for <code>p4</code> is then called with the value of 42 and ignores the other promises. The promises passed to <code>Promise.race()</code> are truly in a race to see which is settled first. If the first promise to settle is fulfilled, then the returned promise is fulfilled; if the first promise to settle is rejected, then the returned promise is rejected. Here's an example with a rejection:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = Promise.reject(43);

let p3 = new Promise(function(resolve, reject) {
    resolve(44);
});

let p4 = Promise.race([p1, p2, p3]);

p4.catch(function(value) {
    console.log(value);     // 43
});
</code></pre>

</figure>

<p>Here, <code>p4</code> is rejected because <code>p2</code> is already in the rejected state when <code>Promise.race()</code> is called. Even though <code>p1</code> and <code>p3</code> are fulfilled, those results are ignored because they occur after <code>p2</code> is rejected.</p>

<h3 id="leanpub-auto-inheriting-from-promises">Inheriting from Promises</h3>

<p>Just like other built-in types, you can use a promise as the base for a derived class. This allows you to define your own variation of promises to extend what built-in promises can do. Suppose, for instance, you'd like to create a promise that can use methods named <code>success()</code> and <code>failure()</code> in addition to the usual <code>then()</code> and <code>catch()</code> methods. You could create that promise type as follows:</p>

<figure class="code">
<pre><code>class MyPromise extends Promise {

    // use default constructor

    success(resolve, reject) {
        return this.then(resolve, reject);
    }

    failure(reject) {
        return this.catch(reject);
    }

}

let promise = new MyPromise(function(resolve, reject) {
    resolve(42);
});

promise.success(function(value) {
    console.log(value);             // 42
}).failure(function(value) {
    console.log(value);
});
</code></pre>

</figure>

<p>In this example, <code>MyPromise</code> is derived from <code>Promise</code> and has two additional methods. The <code>success()</code> method mimics <code>resolve()</code> and <code>failure()</code> mimics the <code>reject()</code> method.</p>

<p>Each added method uses <code>this</code> to call the method it mimics. The derived promise functions the same as a built-in promise, except now you can call <code>success()</code> and <code>failure()</code> if you want.</p>

<p>Since static methods are inherited, the <code>MyPromise.resolve()</code> method, the <code>MyPromise.reject()</code> method, the <code>MyPromise.race()</code> method, and the <code>MyPromise.all()</code> method are also present on derived promises. The last two methods behave the same as the built-in methods, but the first two are slightly different.</p>

<p>Both <code>MyPromise.resolve()</code> and <code>MyPromise.reject()</code> will return an instance of <code>MyPromise</code> regardless of the value passed because those methods use the <code>Symbol.species</code> property (covered under in Chapter 9) to determine the type of promise to return. If a built-in promise is passed to either method, the promise will be resolved or rejected, and the method will return a new <code>MyPromise</code> so you can assign fulfillment and rejection handlers. For example:</p>

<figure class="code">
<pre><code>let p1 = new Promise(function(resolve, reject) {
    resolve(42);
});

let p2 = MyPromise.resolve(p1);
p2.success(function(value) {
    console.log(value);         // 42
});

console.log(p2 instanceof MyPromise);   // true
</code></pre>

</figure>

<p>Here, <code>p1</code> is a built-in promise that is passed to the <code>MyPromise.resolve()</code> method. The result, <code>p2</code>, is an instance of <code>MyPromise</code> where the resolved value from <code>p1</code> is passed into the fulfillment handler.</p>

<p>If an instance of <code>MyPromise</code> is passed to the <code>MyPromise.resolve()</code> or <code>MyPromise.reject()</code> methods, it will just be returned directly without being resolved. In all other ways these two methods behave the same as <code>Promise.resolve()</code> and <code>Promise.reject()</code>.</p>

<h4 id="leanpub-auto-asynchronous-task-running-1">Asynchronous Task Running</h4>

<p>In Chapter 8, I introduced generators and showed you how you can use them for asynchronous task running, like this:</p>

<figure class="code">
<pre><code>let fs = require("fs");

function run(taskDef) {

    // create the iterator, make available elsewhere
    let task = taskDef();

    // start the task
    let result = task.next();

    // recursive function to keep calling next()
    function step() {

        // if there's more to do
        if (!result.done) {
            if (typeof result.value === "function") {
                result.value(function(err, data) {
                    if (err) {
                        result = task.throw(err);
                        return;
                    }

                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }

        }
    }

    // start the process
    step();

}

// Define a function to use with the task runner

function readFile(filename) {
    return function(callback) {
        fs.readFile(filename, callback);
    };
}

// Run a task

run(function*() {
    let contents = yield readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
</code></pre>

</figure>

<p>There are some pain points to this implementation. First, wrapping every function in a function that returns a function is a bit confusing (even this sentence was confusing). Second, there is no way to distinguish between a function return value intended as a callback for the task runner and a return value that isn't a callback.</p>

<p>With promises, you can greatly simplify and generalize this process by ensuring that each asynchronous operation returns a promise. That common interface means you can greatly simplify asynchronous code. Here's one way you could simplify that task runner:</p>

<figure class="code">
<pre><code>let fs = require("fs");

function run(taskDef) {

    // create the iterator
    let task = taskDef();

    // start the task
    let result = task.next();

    // recursive function to iterate through
    (function step() {

        // if there's more to do
        if (!result.done) {

            // resolve to a promise to make it easy
            let promise = Promise.resolve(result.value);
            promise.then(function(value) {
                result = task.next(value);
                step();
            }).catch(function(error) {
                result = task.throw(error);
                step();
            });
        }
    }());
}

// Define a function to use with the task runner

function readFile(filename) {
    return new Promise(function(resolve, reject) {
        fs.readFile(filename, function(err, contents) {
            if (err) {
                reject(err);
            } else {
                resolve(contents);
            }
        });
    });
}

// Run a task

run(function*() {
    let contents = yield readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
</code></pre>

</figure>

<p>In this version of the code, a generic <code>run()</code> function executes a generator to create an iterator. It calls <code>task.next()</code> to start the task and recursively calls <code>step()</code> until the iterator is complete.</p>

<p>Inside the <code>step()</code> function, if there's more work to do, then <code>result.done</code> is <code>false</code>. At that point, <code>result.value</code> should be a promise, but <code>Promise.resolve()</code> is called just in case the function in question didn't return a promise. (Remember, <code>Promise.resolve()</code> just passes through any promise passed in and wraps any non-promise in a promise.) Then, a fulfillment handler is added that retrieves the promise value and passes the value back to the iterator. After that, <code>result</code> is assigned to the next yield result before the <code>step()</code> function calls itself.</p>

<p>A rejection handler stores any rejection results in an error object. The <code>task.throw()</code> method passes that error object back into the iterator, and if an error is caught in the task, <code>result</code> is assigned to the next yield result. Finally, <code>step()</code> is called inside <code>catch()</code> to continue.</p>

<p>This <code>run()</code> function can run any generator that uses <code>yield</code> to achieve asynchronous code without exposing promises (or callbacks) to the developer. In fact, since the return value of the function call is always coverted into a promise, the function can even return something other than a promise. That means both synchronous and asynchronous methods work correctly when called using <code>yield</code>, and you never have to check that the return value is a promise.</p>

<p>The only concern is ensuring that asynchronous functions like <code>readFile()</code> return a promise that correctly identifies its state. For Node.js built-in methods, that means you'll have to convert those methods to return promises instead of using callbacks.</p>

<aside>
  <h4 id="leanpub-auto-future-asynchronous-task-running">Future Asynchronous Task Running</h4>

  <p>At the time of my writing, there is ongoing work around bringing a simpler syntax to asynchronous task running in JavaScript. Work is progressing on an <code>await</code> syntax that would closely mirror the promise-based example in the preceding section. The basic idea is to use a function marked with <code>async</code> instead of a generator and use <code>await</code> instead of <code>yield</code> when calling a function, such as:</p>

  <figure class="code">
<pre><code>(async function() {
    let contents = await readFile("config.json");
    doSomethingWith(contents);
    console.log("Done");
});
</code></pre>

  </figure>

  <p>The <code>async</code> keyword before <code>function</code> indicates that the function is meant to run in an asynchronous manner. The <code>await</code> keyword signals that the function call to <code>readFile("config.json")</code> should return a promise, and if it doesn't, the response should be wrapped in a promise. Just as with the implementation of <code>run()</code> in the preceding section, <code>await</code> will throw an error if the promise is rejected and otherwise return the value from the promise. The end result is that you get to write asynchronous code as if it were synchronous without the overhead of managing an iterator-based state machine.</p>

  <p>The <code>await</code> syntax is expected to be finalized in ECMAScript 2017 (ECMAScript 8).</p>

</aside>

<h3 id="leanpub-auto-summary-10">Summary</h3>

<p>Promises are designed to improve asynchronous programming in JavaScript by giving you more control and composability over asynchronous operations than events and callbacks can. Promises schedule jobs to be added to the JavaScript engine's job queue for execution later, while a second job queue tracks promise fulfillment and rejection handlers to ensure proper execution.</p>

<p>Promises have three states: pending, fulfilled, and rejected. A promise starts in a pending state and becomes fulfilled on a successful execution or rejected on a failure. In either case, handlers can be added to indicate when a promise is settled. The <code>then()</code> method allows you to assign a fulfillment and rejection handler and the <code>catch()</code> method allows you to assign only a rejection handler.</p>

<p>You can chain promises together in a variety of ways and pass information between them. Each call to <code>then()</code> creates and returns a new promise that is resolved when the previous one is resolved. Such chains can be used to trigger responses to a series of asynchronous events. You can also use <code>Promise.race()</code> and <code>Promise.all()</code> to monitor the progress of multiple promises and respond accordingly.</p>

<p>Asynchronous task running is easier when you combine generators and promises, as promises give a common interface that asynchronous operations can return. You can then use generators and the <code>yield</code> operator to wait for asynchronous responses and respond appropriately.</p>

<p>Most new web APIs are being built on top of promises, and you can expect many more to follow suit in the future.</p>


<h2 id="leanpub-auto-proxies-and-the-reflection-api">Proxies and the Reflection API</h2>

<p>ECMAScript 5 and ECMAScript 6 were both developed with demystifying JavaScript functionality in mind. For example, JavaScript environments contained nonenumerable and nonwritable object properties before ECMAScript 5, but developers couldn't define their own nonenumerable or nonwritable properties. ECMAScript 5 included the <code>Object.defineProperty()</code> method to allow developers to do what JavaScript engines could do already.</p>

<p>ECMAScript 6 gives developers further access to JavaScript engine capabilities previously available only to built-in objects. The language exposes the inner workings of objects through <em>proxies</em>, which are wrappers that can intercept and alter low-level operations of the JavaScript engine. This chapter starts by describing the problem that proxies are meant to address in detail, and then discusses how you can create and use proxies effectively.</p>

<h3 id="leanpub-auto-the-array-problem">The Array Problem</h3>

<p>The JavaScript array object behaves in ways that developers couldn't mimic in their own objects before ECMASCript 6. An array's <code>length</code> property is affected when you assign values to specific array items, and you can modify array items by modifying the <code>length</code> property. For example:</p>

<figure class="code">
<pre><code>let colors = ["red", "green", "blue"];

console.log(colors.length);         // 3

colors[3] = "black";

console.log(colors.length);         // 4
console.log(colors[3]);             // "black"

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
</code></pre>

</figure>

<p>The <code>colors</code> array starts with three items. Assigning <code>"black"</code> to <code>colors[3]</code> automatically increments the <code>length</code> property to <code>4</code>. Setting the <code>length</code> property to <code>2</code> removes the last two items in the array, leaving only the first two items. Nothing in ECMAScript 5 allows developers to achieve this behavior, but proxies change that.</p>

<aside class="information blurb">
    <p>This nonstandard behavior is why arrays are considered exotic objects in ECMAScript 6.</p>

</aside>

<h3 id="leanpub-auto-what-are-proxies-and-reflection">What are Proxies and Reflection?</h3>

<p>You can create a proxy to use in place of another object (called the <em>target</em>) by calling <code>new Proxy()</code>. The proxy <em>virtualizes</em> the target so that the proxy and the target appear to be the same object to functionality using the proxy.</p>

<p>Proxies allow you to intercept low-level object operations on the target that are otherwise internal to the JavaScript engine. These low-level operations are intercepted using a <em>trap</em>, which is a function that responds to a specific operation.</p>

<p>The reflection API, represented by the <code>Reflect</code> object, is a collection of methods that provide the default behavior for the same low-level operations that proxies can override. There is a <code>Reflect</code> method for every proxy trap. Those methods have the same name and are passed the same arguments as their respective proxy traps. Table 11-1 summarizes this behavior.</p>

<table class="with-caption">
<caption>Table 11-1: Proxy traps in JavaScript</caption>

  <thead>
    <tr>
      <th>Proxy Trap</th>
      <th>Overrides the Behavior Of</th>
      <th>Default Behavior</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>get</code></td>
      <td>Reading a property value</td>
      <td><code>Reflect.get()</code></td>
    </tr>
    <tr>
      <td><code>set</code></td>
      <td>Writing to a property</td>
      <td><code>Reflect.set()</code></td>
    </tr>
    <tr>
      <td><code>has</code></td>
      <td>The <code>in</code> operator</td>
      <td><code>Reflect.has()</code></td>
    </tr>
    <tr>
      <td><code>deleteProperty</code></td>
      <td>The <code>delete</code> operator</td>
      <td><code>Reflect.deleteProperty()</code></td>
    </tr>
    <tr>
      <td><code>getPrototypeOf</code></td>
      <td><code>Object.getPrototypeOf()</code></td>
      <td><code>Reflect.getPrototypeOf()</code></td>
    </tr>
    <tr>
      <td><code>setPrototypeOf</code></td>
      <td><code>Object.setPrototypeOf()</code></td>
      <td><code>Reflect.setPrototypeOf()</code></td>
    </tr>
    <tr>
      <td><code>isExtensible</code></td>
      <td><code>Object.isExtensible()</code></td>
      <td><code>Reflect.isExtensible()</code></td>
    </tr>
    <tr>
      <td><code>preventExtensions</code></td>
      <td><code>Object.preventExtensions()</code></td>
      <td><code>Reflect.preventExtensions()</code></td>
    </tr>
    <tr>
      <td><code>getOwnPropertyDescriptor</code></td>
      <td><code>Object.getOwnPropertyDescriptor()</code></td>
      <td><code>Reflect.getOwnPropertyDescriptor()</code></td>
    </tr>
    <tr>
      <td><code>defineProperty</code></td>
      <td><code>Object.defineProperty()</code></td>
      <td><code>Reflect.defineProperty</code></td>
    </tr>
    <tr>
      <td><code>ownKeys</code></td>
      <td>
<code>Object.keys</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>
</td>
      <td><code>Reflect.ownKeys()</code></td>
    </tr>
    <tr>
      <td><code>apply</code></td>
      <td>Calling a function</td>
      <td><code>Reflect.apply()</code></td>
    </tr>
    <tr>
      <td><code>construct</code></td>
      <td>Calling a function with <code>new</code>
</td>
      <td><code>Reflect.construct()</code></td>
    </tr>
  </tbody>

</table>

<p>Each trap overrides some built-in behavior of JavaScript objects, allowing you to intercept and modify the behavior. If you still need to use the built-in behavior, then you can use the corresponding reflection API method. The relationship between proxies and the reflection API becomes clear when you start creating proxies, so it's best to dive in and look at some examples.</p>

<aside class="information blurb">
    <p>The original ECMAScript 6 specification had an additional trap called <code>enumerate</code> that was designed to alter how <code>for-in</code> and <code>Object.keys()</code> enumerated properties on an object. However, the <code>enumerate</code> trap was removed in ECMAScript 7 (also called ECMAScript 2016) as difficulties were discovered during implementation. The <code>enumerate</code> trap no longer exists in any JavaScript environment and is therefore not covered in this chapter.</p>

</aside>

<h3 id="leanpub-auto-creating-a-simple-proxy">Creating a Simple Proxy</h3>

<p>When you use the <code>Proxy</code> constructor to make a proxy, you'll pass it two arguments: the target and a handler. A <em>handler</em> is an object that defines one or more traps. The proxy uses the default behavior for all operations except when traps are defined for that operation. To create a simple forwarding proxy, you can use a handler without any traps:</p>

<figure class="code">
<pre><code>let target = {};

let proxy = new Proxy(target, {});

proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);       // "proxy"

target.name = "target";
console.log(proxy.name);        // "target"
console.log(target.name);       // "target"
</code></pre>

</figure>

<p>In this example, <code>proxy</code> forwards all operations directly to <code>target</code>. When <code>"proxy"</code> is assigned to the <code>proxy.name</code> property, <code>name</code> is created on <code>target</code>. The proxy itself is not storing this property; it's simply forwarding the operation to <code>target</code>. Similarly, the values of <code>proxy.name</code> and <code>target.name</code> are the same because they are both references to <code>target.name</code>. That also means setting <code>target.name</code> to a new value causes <code>proxy.name</code> to reflect the same change. Of course, proxies without traps aren't very interesting, so what happens when you define a trap?</p>

<h3 id="leanpub-auto-validating-properties-using-the-set-trap">Validating Properties Using the <code>set</code> Trap</h3>

<p>Suppose you want to create an object whose property values must be numbers. That means every new property added to the object must be validated, and an error must be thrown if the value isn't a number. To accomplish this, you could define a <code>set</code> trap that overrides the default behavior of setting a value. The <code>set</code> trap receives four arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object that will receive the property (the proxy's target)</li>
  <li>
<code>key</code> - the property key (string or symbol) to write to</li>
  <li>
<code>value</code> - the value being written to the property</li>
  <li>
<code>receiver</code> - the object on which the operation took place (usually the proxy)</li>
</ol>

<p><code>Reflect.set()</code> is the <code>set</code> trap's corresponding reflection method, and it's the default behavior for this operation. The <code>Reflect.set()</code> method accepts the same four arguments as the <code>set</code> proxy trap, making the method easy to use inside of the trap. The trap should return <code>true</code> if the property was set or <code>false</code> if not. (The <code>Reflect.set()</code> method returns the correct value based on whether the operation succeeded.)</p>

<p>To validate the values of properties, you'd use the <code>set</code> trap and inspect the <code>value</code> that is passed in. Here's an example:</p>

<figure class="code">
<pre><code>let target = {
    name: "target"
};

let proxy = new Proxy(target, {
    set(trapTarget, key, value, receiver) {

        // ignore existing properties so as not to affect them
        if (!trapTarget.hasOwnProperty(key)) {
            if (isNaN(value)) {
                throw new TypeError("Property must be a number.");
            }
        }

        // add the property
        return Reflect.set(trapTarget, key, value, receiver);
    }
});

// adding a new property
proxy.count = 1;
console.log(proxy.count);       // 1
console.log(target.count);      // 1

// you can assign to name because it exists on target already
proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);       // "proxy"

// throws an error
proxy.anotherName = "proxy";
</code></pre>

</figure>

<p>This code defines a proxy trap that validates the value of any new property added to <code>target</code>. When <code>proxy.count = 1</code> is executed, the <code>set</code> trap is called. The <code>trapTarget</code> value is equal to <code>target</code>, <code>key</code> is <code>"count"</code>, <code>value</code> is <code>1</code>, and <code>receiver</code> (not used in this example) is <code>proxy</code>. There is no existing property named <code>count</code> in <code>target</code>, so the proxy validates <code>value</code> by passing it to <code>isNaN()</code>. If the result is <code>NaN</code>, then the property value is not numeric and an error is thrown. Since this code sets <code>count</code> to <code>1</code>, the proxy calls <code>Reflect.set()</code> with the same four arguments that were passed to the trap to add the new property.</p>

<p>When <code>proxy.name</code> is assigned a string, the operation completes successfully. Since <code>target</code> already has a <code>name</code> property, that property is omitted from the validation check by calling the <code>trapTarget.hasOwnProperty()</code> method. This ensures that previously-existing non-numeric property values are still supported.</p>

<p>When <code>proxy.anotherName</code> is assigned a string, however, an error is thrown. The <code>anotherName</code> property doesn't exist on the target, so its value needs to be validated. During validation, the error is thrown because <code>"proxy"</code> isn't a numeric value.</p>

<p>Where the <code>set</code> proxy trap lets you intercept when properties are being written to, the <code>get</code> proxy trap lets you intercept when properties are being read.</p>

<h3 id="leanpub-auto-object-shape-validation-using-the-get-trap">Object Shape Validation Using the <code>get</code> Trap</h3>

<p>One of the interesting, and sometimes confusing, aspects of JavaScript is that reading nonexistent properties doesn't throw an error. Instead, the value <code>undefined</code> is used for the property value, as in this example:</p>

<figure class="code">
<pre><code>let target = {};

console.log(target.name);       // undefined
</code></pre>

</figure>

<p>In most other languages, attempting to read <code>target.name</code> throws an error because the property doesn't exist. But JavaScript just uses <code>undefined</code> for the value of the <code>target.name</code> property. If you've ever worked on a large code base, you've probably seen how this behavior can cause significant problems, especially when there's a typo in the property name. Proxies can help you save yourself from this problem by having object shape validation.</p>

<p>An <em>object shape</em> is the collection of properties and methods available on the object. JavaScript engines use object shapes to optimize code, often creating classes to represent the objects. If you can safely assume an object will always have the same properties and methods it began with (a behavior you can enforce with the <code>Object.preventExtensions()</code> method, the <code>Object.seal()</code> method, or the <code>Object.freeze()</code> method), then throwing an error on attempts to access nonexistent properties can be helpful. Proxies make object shape validation easy.</p>

<p>Since property validation only has to happen when a property is read, you'd use the <code>get</code> trap. The <code>get</code> trap is called when a property is read, even if that property doesn't exist on the object, and it takes three arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object from which the property is read (the proxy's target)</li>
  <li>
<code>key</code> - the property key (a string or symbol) to read</li>
  <li>
<code>receiver</code> - the object on which the operation took place (usually the proxy)</li>
</ol>

<p>These arguments mirror the <code>set</code> trap's arguments, with one noticeable difference. There's no <code>value</code> argument here because <code>get</code> traps don't write values. The <code>Reflect.get()</code> method accepts the same three arguments as the <code>get</code> trap and returns the property's default value.</p>

<p>You can use the <code>get</code> trap and <code>Reflect.get()</code> to throw an error when a property doesn't exist on the target, as follows:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
        get(trapTarget, key, receiver) {
            if (!(key in receiver)) {
                throw new TypeError("Property " + key + " doesn't exist.");
            }

            return Reflect.get(trapTarget, key, receiver);
        }
    });

// adding a property still works
proxy.name = "proxy";
console.log(proxy.name);            // "proxy"

// nonexistent properties throw an error
console.log(proxy.nme);             // throws error
</code></pre>

</figure>

<p>In this example, the <code>get</code> trap intercepts property read operations. The <code>in</code> operator is used to determine if the property already exists on the <code>receiver</code>. The <code>receiver</code> is used with <code>in</code> instead of <code>trapTarget</code> in case <code>receiver</code> is a proxy with a <code>has</code> trap, a type I'll cover in the next section. Using <code>trapTarget</code> in this case would sidestep the <code>has</code> trap and potentially give you the wrong result. An error is thrown if the property doesn't exist, and otherwise, the default behavior is used.</p>

<p>This code allows new properties like <code>proxy.name</code> to be added, written to, and read from with no problems. The last line contains a typo: <code>proxy.nme</code> should probably be <code>proxy.name</code> instead. This throws an error because <code>nme</code> doesn't exist as a property.</p>

<h3 id="leanpub-auto-hiding-property-existence-using-the-has-trap">Hiding Property Existence Using the <code>has</code> Trap</h3>

<p>The <code>in</code> operator determines whether a property exists on a given object and returns <code>true</code> if there is either an own property or a prototype property matching the name or symbol. For example:</p>

<figure class="code">
<pre><code>let target = {
    value: 42;
}

console.log("value" in target);     // true
console.log("toString" in target);  // true
</code></pre>

</figure>

<p>Both <code>value</code> and <code>toString</code> exist on <code>object</code>, so in both cases the <code>in</code> operator returns <code>true</code>. The <code>value</code> property is an own property while <code>toString</code> is a prototype property (inherited from <code>Object</code>). Proxies allow you to intercept this operation and return a different value for <code>in</code> with the <code>has</code> trap.</p>

<p>The <code>has</code> trap is called whenever the <code>in</code> operator is used. When called, two arguments are passed to the <code>has</code> trap:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object the property is read from (the proxy's target)</li>
  <li>
<code>key</code> - the property key (string or symbol) to check</li>
</ol>

<p>The <code>Reflect.has()</code> method accepts these same arguments and returns the default response for the <code>in</code> operator. Using the <code>has</code> trap and <code>Reflect.has()</code> allows you to alter the behavior of <code>in</code> for some properties while falling back to default behavior for others. For instance, suppose you just want to hide the <code>value</code> property. You can do so like this:</p>

<figure class="code">
<pre><code>let target = {
    name: "target",
    value: 42
};

let proxy = new Proxy(target, {
    has(trapTarget, key) {

        if (key === "value") {
            return false;
        } else {
            return Reflect.has(trapTarget, key);
        }
    }
});


console.log("value" in proxy);      // false
console.log("name" in proxy);       // true
console.log("toString" in proxy);   // true
</code></pre>

</figure>

<p>The <code>has</code> trap for <code>proxy</code> checks to see if <code>key</code> is <code>"value"</code> returns <code>false</code> if so. Otherwise, the default behavior is used via a call to the <code>Reflect.has()</code> method. As a result, the <code>in</code> operator returns <code>false</code> for the <code>value</code> property even though <code>value</code> actually exists on the target. The other properties, <code>name</code> and <code>toString</code>, correctly return <code>true</code> when used with the <code>in</code> operator.</p>

<h3 id="leanpub-auto-preventing-property-deletion-with-the-deleteproperty-trap">Preventing Property Deletion with the <code>deleteProperty</code> Trap</h3>

<p>The <code>delete</code> operator removes a property from an object and returns <code>true</code> when successful and <code>false</code> when unsuccessful. In strict mode, <code>delete</code> throws an error when you attempt to delete a nonconfigurable property; in nonstrict mode, <code>delete</code> simply returns <code>false</code>. Here's an example:</p>

<figure class="code">
<pre><code>let target = {
    name: "target",
    value: 42
};

Object.defineProperty(target, "name", { configurable: false });

console.log("value" in target);     // true

let result1 = delete target.value;
console.log(result1);               // true

console.log("value" in target);     // false

// Note: The following line throws an error in strict mode
let result2 = delete target.name;
console.log(result2);               // false

console.log("name" in target);      // true
</code></pre>

</figure>

<p>The <code>value</code> property is deleted using the <code>delete</code> operator and, as a result, the <code>in</code> operator returns <code>false</code> in the third <code>console.log()</code> call. The nonconfigurable <code>name</code> property can't be deleted so the <code>delete</code> operator simply returns <code>false</code> (if this code is run in strict mode, an error is thrown instead). You can alter this behavior by using the <code>deleteProperty</code> trap in a proxy.</p>

<p>The <code>deleteProperty</code> trap is called whenever the <code>delete</code> operator is used on an object property. The trap is passed two arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object from which the property should be deleted (the proxy's target)</li>
  <li>
<code>key</code> - the property key (string or symbol) to delete</li>
</ol>

<p>The <code>Reflect.deleteProperty()</code> method provides the default implementation of the <code>deleteProperty</code> trap and accepts the same two arguments. You can combine <code>Reflect.deleteProperty()</code> and the <code>deleteProperty</code> trap to change how the <code>delete</code> operator behaves. For instance, you could ensure that the <code>value</code> property can't be deleted:</p>

<figure class="code">
<pre><code>let target = {
    name: "target",
    value: 42
};

let proxy = new Proxy(target, {
    deleteProperty(trapTarget, key) {

        if (key === "value") {
            return false;
        } else {
            return Reflect.deleteProperty(trapTarget, key);
        }
    }
});

// Attempt to delete proxy.value

console.log("value" in proxy);      // true

let result1 = delete proxy.value;
console.log(result1);               // false

console.log("value" in proxy);      // true

// Attempt to delete proxy.name

console.log("name" in proxy);       // true

let result2 = delete proxy.name;
console.log(result2);               // true

console.log("name" in proxy);       // false
</code></pre>

</figure>

<p>This code is very similar to the <code>has</code> trap example in that the <code>deleteProperty</code> trap checks to see if the <code>key</code> is <code>"value"</code> and returns <code>false</code> if so. Otherwise, the default behavior is used by calling the <code>Reflect.deleteProperty()</code> method. The <code>value</code> property can't be deleted through <code>proxy</code> because the operation is trapped, but the <code>name</code> property is deleted as expected. This approach is especially useful when you want to protect properties from deletion without throwing an error in strict mode.</p>

<h3 id="leanpub-auto-prototype-proxy-traps">Prototype Proxy Traps</h3>

<p>Chapter 4 introduced the <code>Object.setPrototypeOf()</code> method that ECMAScript 6 added to complement the ECMAScript 5 <code>Object.getPrototypeOf()</code> method. Proxies allow you to intercept execution of both methods through the <code>setPrototypeOf</code> and <code>getPrototypeOf</code> traps. In both cases, the method on <code>Object</code> calls the trap of the corresponding name on the proxy, allowing you to alter the methods' behavior.</p>

<p>Since there are two traps associated with prototype proxies, there's a set of methods associated with each type of trap. The <code>setPrototypeOf</code> trap receives these arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object for which the prototype should be set (the proxy's target)</li>
  <li>
<code>proto</code> - the object to use for as the prototype</li>
</ol>

<p>These are the same arguments passed to the <code>Object.setPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods. The <code>getPrototypeOf</code> trap, on the other hand, only receives the <code>trapTarget</code> argument, which is the argument passed to the <code>Object.getPrototypeOf()</code> and <code>Reflect.getPrototypeOf()</code> methods.</p>

<h4 id="leanpub-auto-how-prototype-proxy-traps-work">How Prototype Proxy Traps Work</h4>

<p>There are some restrictions on these traps. First, the <code>getPrototypeOf</code> trap must return an object or <code>null</code>, and any other return value results in a runtime error. The return value check ensures that <code>Object.getPrototypeOf()</code> will always return an expected value. Similarly, the return value of the <code>setPrototypeOf</code> trap must be <code>false</code> if the operation doesn't succeed. When <code>setPrototypeOf</code> returns <code>false</code>, <code>Object.setPrototypeOf()</code> throws an error. If <code>setPrototypeOf</code> returns any value other than <code>false</code>, then <code>Object.setPrototypeOf()</code> assumes the operation succeeded.</p>

<p>The following example hides the prototype of the proxy by always returning <code>null</code> and also doesn't allow the prototype to be changed:</p>

<figure class="code">
<pre><code>let target = {};
let proxy = new Proxy(target, {
    getPrototypeOf(trapTarget) {
        return null;
    },
    setPrototypeOf(trapTarget, proto) {
        return false;
    }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);      // true
console.log(proxyProto === Object.prototype);       // false
console.log(proxyProto);                            // null

// succeeds
Object.setPrototypeOf(target, {});

// throws error
Object.setPrototypeOf(proxy, {});
</code></pre>

</figure>

<p>This code emphasizes the difference between the behavior of <code>target</code> and <code>proxy</code>. While <code>Object.getPrototypeOf()</code> returns a value for <code>target</code>, it returns <code>null</code> for <code>proxy</code> because the <code>getPrototypeOf</code> trap is called. Similarly, <code>Object.setPrototypeOf()</code> succeeds when used on <code>target</code> but throws an error when used on <code>proxy</code> due to the <code>setPrototypeOf</code> trap.</p>

<p>If you want to use the default behavior for these two traps, you can use the corresponding methods on <code>Reflect</code>. For instance, this code implements the default behavior for the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> traps:</p>

<figure class="code">
<pre><code>let target = {};
let proxy = new Proxy(target, {
    getPrototypeOf(trapTarget) {
        return Reflect.getPrototypeOf(trapTarget);
    },
    setPrototypeOf(trapTarget, proto) {
        return Reflect.setPrototypeOf(trapTarget, proto);
    }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);      // true
console.log(proxyProto === Object.prototype);       // true

// succeeds
Object.setPrototypeOf(target, {});

// also succeeds
Object.setPrototypeOf(proxy, {});
</code></pre>

</figure>

<p>In this example, you can use <code>target</code> and <code>proxy</code> interchangeably and get the same results because the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> traps are just passing through to use the default implementation. It's important that this example use the <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods rather than the methods of the same name on <code>Object</code> due to some important differences.</p>

<h4 id="leanpub-auto-why-two-sets-of-methods">Why Two Sets of Methods?</h4>

<p>The confusing aspect of <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> is that they look suspiciously similar to the <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> methods. While both sets of methods perform similar operations, there are some distinct differences between the two.</p>

<p>To begin, <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> are higher-level operations that were created for developer use from the start. The <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods are lower-level operations that give developers access to the previously internal-only <code>[[GetPrototypeOf]]</code> and <code>[[SetPrototypeOf]]</code> operations. The <code>Reflect.getPrototypeOf()</code> method is the wrapper for the internal <code>[[GetPrototypeOf]]</code> operation (with some input validation). The <code>Reflect.setPrototypeOf()</code> method and <code>[[SetPrototypeOf]]</code> have the same relationship. The corresponding methods on <code>Object</code> also call <code>[[GetPrototypeOf]]</code> and <code>[[SetPrototypeOf]]</code> but perform a few steps before the call and inspect the return value to determine how to behave.</p>

<p>The <code>Reflect.getPrototypeOf()</code> method throws an error if its argument is not an object, while <code>Object.getPrototypeOf()</code> first coerces the value into an object before performing the operation. If you were to pass a number into each method, you'd get a different result:</p>

<figure class="code">
<pre><code>let result1 = Object.getPrototypeOf(1);
console.log(result1 === Number.prototype);  // true

// throws an error
Reflect.getPrototypeOf(1);
</code></pre>

</figure>

<p>The <code>Object.getPrototypeOf()</code> method allows you retrieve a prototype for the number <code>1</code> because it first coerces the value into a <code>Number</code> object and then returns <code>Number.prototype</code>. The <code>Reflect.getPrototypeOf()</code> method doesn't coerce the value, and since <code>1</code> isn't an object, it throws an error.</p>

<p>The <code>Reflect.setPrototypeOf()</code> method also has a few more differences from the <code>Object.setPrototypeOf()</code> method. First, <code>Reflect.setPrototypeOf()</code> returns a boolean value indicating whether the operation was successful. A <code>true</code> value is returned for success, and <code>false</code> is returned for failure. If <code>Object.setPrototypeOf()</code> fails, it throws an error.</p>

<p>As the first example under "How Prototype Proxy Traps Work" showed, when the <code>setPrototypeOf</code> proxy trap returns <code>false</code>, it causes <code>Object.setPrototypeOf()</code> to throw an error. The <code>Object.setPrototypeOf()</code> method returns the first argument as its value and therefore isn't suitable for implementing the default behavior of the <code>setPrototypeOf</code> proxy trap. The following code demonstrates these differences:</p>

<figure class="code">
<pre><code>let target1 = {};
let result1 = Object.setPrototypeOf(target1, {});
console.log(result1 === target1);                   // true

let target2 = {};
let result2 = Reflect.setPrototypeOf(target2, {});
console.log(result2 === target2);                   // false
console.log(result2);                               // true
</code></pre>

</figure>

<p>In this example, <code>Object.setPrototypeOf()</code> returns <code>target1</code> as its value, but <code>Reflect.setPrototypeOf()</code> returns <code>true</code>. This subtle difference is very important. You'll see more seemingly duplicate methods on <code>Object</code> and <code>Reflect</code>, but always be sure to use the method on <code>Reflect</code> inside any proxy traps.</p>

<aside class="information blurb">
    <p>Both sets of methods will call the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> proxy traps when used on a proxy.</p>

</aside>

<h3 id="leanpub-auto-object-extensibility-traps">Object Extensibility Traps</h3>

<p>ECMAScript 5 added object extensibility modification through the <code>Object.preventExtensions()</code> and <code>Object.isExtensible()</code> methods, and ECMAScript 6 allows proxies to intercept those method calls to the underlying objects through the <code>preventExtensions</code> and <code>isExtensible</code> traps. Both traps receive a single argument called <code>trapTarget</code> that is the object on which the method was called. The <code>isExtensible</code> trap must return a boolean value indicating whether the object is extensible while the <code>preventExtensions</code> trap must return a boolean value indicating if the operation succeeded.</p>

<p>There are also <code>Reflect.preventExtensions()</code> and <code>Reflect.isExtensible()</code> methods to implement the default behavior. Both return boolean values, so they can be used directly in their corresponding traps.</p>

<h4 id="leanpub-auto-two-basic-examples">Two Basic Examples</h4>

<p>To see object extensibility traps in action, consider the following code, which implements the default behavior for the <code>isExtensible</code> and <code>preventExtensions</code> traps:</p>

<figure class="code">
<pre><code>let target = {};
let proxy = new Proxy(target, {
    isExtensible(trapTarget) {
        return Reflect.isExtensible(trapTarget);
    },
    preventExtensions(trapTarget) {
        return Reflect.preventExtensions(trapTarget);
    }
});


console.log(Object.isExtensible(target));       // true
console.log(Object.isExtensible(proxy));        // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));       // false
console.log(Object.isExtensible(proxy));        // false
</code></pre>

</figure>

<p>This example shows that both <code>Object.preventExtensions()</code> and <code>Object.isExtensible()</code> correctly pass through from <code>proxy</code> to <code>target</code>. You can, of course, also change the behavior. For example, if you don't want to allow <code>Object.preventExtensions()</code> to succeed on your proxy, you could return <code>false</code> from the <code>preventExtensions</code> trap:</p>

<figure class="code">
<pre><code>let target = {};
let proxy = new Proxy(target, {
    isExtensible(trapTarget) {
        return Reflect.isExtensible(trapTarget);
    },
    preventExtensions(trapTarget) {
        return false
    }
});


console.log(Object.isExtensible(target));       // true
console.log(Object.isExtensible(proxy));        // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));       // true
console.log(Object.isExtensible(proxy));        // true
</code></pre>

</figure>

<p>Here, the call to <code>Object.preventExtensions(proxy)</code> is effectively ignored because the <code>preventExtensions</code> trap returns <code>false</code>. The operation isn't forwarded to the underlying <code>target</code>, so <code>Object.isExtensible()</code> returns <code>true</code>.</p>

<h4 id="leanpub-auto-duplicate-extensibility-methods">Duplicate Extensibility Methods</h4>

<p>You may have noticed that, once again, there are seemingly duplicate methods on <code>Object</code> and <code>Reflect</code>. In this case, they're more similar than not. The methods <code>Object.isExtensible()</code> and <code>Reflect.isExtensible()</code> are similar except when passed a non-object value. In that case, <code>Object.isExtensible()</code> always returns <code>false</code> while <code>Reflect.isExtensible()</code> throws an error. Here's an example of that behavior:</p>

<figure class="code">
<pre><code>let result1 = Object.isExtensible(2);
console.log(result1);                       // false

// throws error
let result2 = Reflect.isExtensible(2);
</code></pre>

</figure>

<p>This restriction is similar to the difference between the <code>Object.getPrototypeOf()</code> and <code>Reflect.getPrototypeOf()</code> methods, as the method with lower-level functionality has stricter error checks than its higher-level counterpart.</p>

<p>The <code>Object.preventExtensions()</code> and <code>Reflect.preventExtensions()</code> methods are also very similar. The <code>Object.preventExtensions()</code> method always returns the value that was passed to it as an argument even if the value isn't an object. The <code>Reflect.preventExtensions()</code> method, on the other hand, throws an error if the argument isn't an object; if the argument is an object, then <code>Reflect.preventExtensions()</code> returns <code>true</code> when the operation succeeds or <code>false</code> if not. For example:</p>

<figure class="code">
<pre><code>let result1 = Object.preventExtensions(2);
console.log(result1);                               // 2

let target = {};
let result2 = Reflect.preventExtensions(target);
console.log(result2);                               // true

// throws error
let result3 = Reflect.preventExtensions(2);
</code></pre>

</figure>

<p>Here, <code>Object.preventExtensions()</code> passes through the value <code>2</code> as its return value even though <code>2</code> isn't an object. The <code>Reflect.preventExtensions()</code> method returns <code>true</code> when an object is passed to it and throws an error when <code>2</code> is passed to it.</p>

<h3 id="leanpub-auto-property-descriptor-traps">Property Descriptor Traps</h3>

<p>One of the most important features of ECMAScript 5 was the ability to define property attributes using the <code>Object.defineProperty()</code> method. In previous versions of JavaScript, there was no way to define an accessor property, make a property read-only, or make a property nonenumerable. All of these are possible with the <code>Object.defineProperty()</code> method, and you can retrieve those attributes with the <code>Object.getOwnPropertyDescriptor()</code> method.</p>

<p>Proxies let you intercept calls to <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> using the <code>defineProperty</code> and <code>getOwnPropertyDescriptor</code> traps, respectively. The <code>defineProperty</code> trap receives the following arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the object on which the property should be defined (the proxy's target)</li>
  <li>
<code>key</code> - the string or symbol for the property</li>
  <li>
<code>descriptor</code> - the descriptor object for the property</li>
</ol>

<p>The <code>defineProperty</code> trap requires you to return <code>true</code> if the operation is successful and <code>false</code> if not. The <code>getOwnPropertyDescriptor</code> traps receives only <code>trapTarget</code> and <code>key</code>, and you are expected to return the descriptor. The corresponding <code>Reflect.defineProperty()</code> and <code>Reflect.getOwnPropertyDescriptor()</code> methods accept the same arguments as their proxy trap counterparts. Here's an example that just implements the default behavior for each trap:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
    defineProperty(trapTarget, key, descriptor) {
        return Reflect.defineProperty(trapTarget, key, descriptor);
    },
    getOwnPropertyDescriptor(trapTarget, key) {
        return Reflect.getOwnPropertyDescriptor(trapTarget, key);
    }
});


Object.defineProperty(proxy, "name", {
    value: "proxy"
});

console.log(proxy.name);            // "proxy"

let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");

console.log(descriptor.value);      // "proxy"
</code></pre>

</figure>

<p>This code defines a property called <code>"name"</code> on the proxy with the <code>Object.defineProperty()</code> method. The property descriptor for that property is then retrieved by the <code>Object.getOwnPropertyDescriptor()</code> method.</p>

<h4 id="leanpub-auto-blocking-objectdefineproperty">Blocking Object.defineProperty()</h4>

<p>The <code>defineProperty</code> trap requires you to return a boolean value to indicate whether the operation was successful. When <code>true</code> is returned, <code>Object.defineProperty()</code> succeeds as usual; when <code>false</code> is returned, <code>Object.defineProperty()</code> throws an error. You can use this functionality to restrict the kinds of properties that the <code>Object.defineProperty()</code> method can define. For instance, if you want to prevent symbol properties from being defined, you could check that the key is a string and return <code>false</code> if not, like this:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
    defineProperty(trapTarget, key, descriptor) {

        if (typeof key === "symbol") {
            return false;
        }

        return Reflect.defineProperty(trapTarget, key, descriptor);
    }
});


Object.defineProperty(proxy, "name", {
    value: "proxy"
});

console.log(proxy.name);                    // "proxy"

let nameSymbol = Symbol("name");

// throws error
Object.defineProperty(proxy, nameSymbol, {
    value: "proxy"
});
</code></pre>

</figure>

<p>The <code>defineProperty</code> proxy trap returns <code>false</code> when <code>key</code> is a symbol and otherwise proceeds with the default behavior. When <code>Object.defineProperty()</code> is called with <code>"name"</code> as the key, the method succeeds because the key is a string. When <code>Object.defineProperty()</code> is called with <code>nameSymbol</code>, it throws an error because the <code>defineProperty</code> trap returns <code>false</code>.</p>

<aside class="information blurb">
    <p>You can also have <code>Object.defineProperty()</code> silently fail by returning <code>true</code> and not calling the <code>Reflect.defineProperty()</code> method. That will suppress the error while not actually defining the property.</p>

</aside>

<h4 id="leanpub-auto-descriptor-object-restrictions">Descriptor Object Restrictions</h4>

<p>To ensure consistent behavior when using the <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> methods, descriptor objects passed to the <code>defineProperty</code> trap are normalized. Objects returned from <code>getOwnPropertyDescriptor</code> trap are always validated for the same reason.</p>

<p>No matter what object is passed as the third argument to the <code>Object.defineProperty()</code> method, only the properties <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code>, and <code>set</code> will be on the descriptor object passed to the <code>defineProperty</code> trap. For example:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
    defineProperty(trapTarget, key, descriptor) {
        console.log(descriptor.value);              // "proxy"
        console.log(descriptor.name);               // undefined

        return Reflect.defineProperty(trapTarget, key, descriptor);
    }
});


Object.defineProperty(proxy, "name", {
    value: "proxy",
    name: "custom"
});
</code></pre>

</figure>

<p>Here, <code>Object.defineProperty()</code> is called with a nonstandard <code>name</code> property on the third argument. When the <code>defineProperty</code> trap is called, the <code>descriptor</code> object doesn't have a <code>name</code> property but does have a <code>value</code> property. That's because <code>descriptor</code> isn't a reference to the actual third argument passed to the <code>Object.defineProperty()</code> method, but rather a new object that contains only the allowable properties. The <code>Reflect.defineProperty()</code> method also ignores any nonstandard properties on the descriptor.</p>

<p>The <code>getOwnPropertyDescriptor</code> trap has a slightly different restriction that requires the return value to be <code>null</code>, <code>undefined</code>, or an object. If an object is returned, only <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code>, and <code>set</code> are allowed as own properties of the object. An error is thrown if you return an object with an own property that isn't allowed, as this code shows:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
    getOwnPropertyDescriptor(trapTarget, key) {
        return {
            name: "proxy"
        };
    }
});

// throws error
let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");
</code></pre>

</figure>

<p>The property <code>name</code> isn't allowable on property descriptors, so when <code>Object.getOwnPropertyDescriptor()</code> is called, the <code>getOwnPropertyDescriptor</code> return value triggers an error. This restriction ensures that the value returned by <code>Object.getOwnPropertyDescriptor()</code> always has a reliable structure regardless of use on proxies.</p>

<h4 id="leanpub-auto-duplicate-descriptor-methods">Duplicate Descriptor Methods</h4>

<p>Once again, ECMAScript 6 has some confusingly similar methods, as the <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> methods appear to do the same thing as the <code>Reflect.defineProperty()</code> and <code>Reflect.getOwnPropertyDescriptor()</code> methods, respectively. Like other method pairs discussed earlier in this chapter, these have some subtle but important differences.</p>

<h5 id="leanpub-auto-defineproperty-methods">defineProperty() Methods</h5>

<p>The <code>Object.defineProperty()</code> and <code>Reflect.defineProperty()</code> methods are exactly the same except for their return values. The <code>Object.defineProperty()</code> method returns the first argument, while <code>Reflect.defineProperty()</code> returns <code>true</code> if the operation succeeded and <code>false</code> if not. For example:</p>

<figure class="code">
<pre><code>let target = {};

let result1 = Object.defineProperty(target, "name", { value: "target "});

console.log(target === result1);        // true

let result2 = Reflect.defineProperty(target, "name", { value: "reflect" });

console.log(result2);                   // true
</code></pre>

</figure>

<p>When <code>Object.defineProperty()</code> is called on <code>target</code>, the return value is <code>target</code>. When <code>Reflect.defineProperty()</code> is called on <code>target</code>, the return value is <code>true</code>, indicating that the operation succeeded. Since the <code>defineProperty</code> proxy trap requires a boolean value to be returned, it's better to use <code>Reflect.defineProperty()</code> to implement the default behavior when necessary.</p>

<h5 id="leanpub-auto-getownpropertydescriptor-methods">getOwnPropertyDescriptor() Methods</h5>

<p>The <code>Object.getOwnPropertyDescriptor()</code> method coerces its first argument into an object when a primitive value is passed and then continues the operation. On the other hand, the <code>Reflect.getOwnPropertyDescriptor()</code> method throws an error if the first argument is a primitive value. Here's an example showing both:</p>

<figure class="code">
<pre><code>let descriptor1 = Object.getOwnPropertyDescriptor(2, "name");
console.log(descriptor1);       // undefined

// throws an error
let descriptor2 = Reflect.getOwnPropertyDescriptor(2, "name");
</code></pre>

</figure>

<p>The <code>Object.getOwnPropertyDescriptor()</code> method returns <code>undefined</code> because it coerces <code>2</code> into an object, and that object has no <code>name</code> property. This is the standard behavior of the method when a property with the given name isn't found on an object. When <code>Reflect.getOwnPropertyDescriptor()</code> is called, however, an error is thrown immediately because that method doesn't accept primitive values for the first argument.</p>

<h3 id="leanpub-auto-the-ownkeys-trap">The <code>ownKeys</code> Trap</h3>

<p>The <code>ownKeys</code> proxy trap intercepts the internal method <code>[[OwnPropertyKeys]]</code> and allows you to override that behavior by returning an array of values. This array is used in four methods: the <code>Object.keys()</code> method, the <code>Object.getOwnPropertyNames()</code> method, the <code>Object.getOwnPropertySymbols()</code> method, and the <code>Object.assign()</code> method. (The <code>Object.assign()</code> method uses the array to determine which properties to copy.)</p>

<p>The default behavior for the <code>ownKeys</code> trap is implemented by the <code>Reflect.ownKeys()</code> method and returns an array of all own property keys, including both strings and symbols. The <code>Object.getOwnProperyNames()</code> method and the <code>Object.keys()</code> method filter symbols out of the array and returns the result while <code>Object.getOwnPropertySymbols()</code> filters the strings out of the array and returns the result. The <code>Object.assign()</code> method uses the array with both strings and symbols.</p>

<p>The <code>ownKeys</code> trap receives a single argument, the target, and must always return an array or array-like object; otherwise, an error is thrown. You can use the <code>ownKeys</code> trap to, for example, filter out certain property keys that you don't want used when the <code>Object.keys()</code>, the <code>Object.getOwnPropertyNames()</code> method, the <code>Object.getOwnPropertySymbols()</code> method, or the <code>Object.assign()</code> method is used. Suppose you don't want to include any property names that begin with an underscore character, a common notation in JavaScript indicating that a field is private. You can use the <code>ownKeys</code> trap to filter out those keys as follows:</p>

<figure class="code">
<pre><code>let proxy = new Proxy({}, {
    ownKeys(trapTarget) {
        return Reflect.ownKeys(trapTarget).filter(key =&gt; {
            return typeof key !== "string" || key[0] !== "_";
        });
    }
});

let nameSymbol = Symbol("name");

proxy.name = "proxy";
proxy._name = "private";
proxy[nameSymbol] = "symbol";

let names = Object.getOwnPropertyNames(proxy),
    keys = Object.keys(proxy);
    symbols = Object.getOwnPropertySymbols(proxy);

console.log(names.length);      // 1
console.log(names[0]);          // "name"

console.log(keys.length);      // 1
console.log(keys[0]);          // "name"

console.log(symbols.length);    // 1
console.log(symbols[0]);        // "Symbol(name)"
</code></pre>

</figure>

<p>This example uses an <code>ownKeys</code> trap that first calls <code>Reflect.ownKeys()</code> to get the default list of keys for the target. Then, the <code>filter()</code> method is used to filter out keys that are strings and begin with an underscore character. Then, three properties are added to the <code>proxy</code> object: <code>name</code>, <code>_name</code>, and <code>nameSymbol</code>. When <code>Object.getOwnPropertyNames()</code> and <code>Object.keys()</code> is called on <code>proxy</code>, only the <code>name</code> property is returned. Similarly, only <code>nameSymbol</code> is returned when <code>Object.getOwnPropertySymbols()</code> is called on <code>proxy</code>. The <code>_name</code> property doesn't appear in either result because it is filtered out.</p>

<aside class="information blurb">
    <p>The <code>ownKeys</code> trap also affects the <code>for-in</code> loop, which calls the trap to determine which keys to use inside of the loop.</p>

</aside>

<h3 id="leanpub-auto-function-proxies-with-the-apply-and-construct-traps">Function Proxies with the <code>apply</code> and <code>construct</code> Traps</h3>

<p>Of all the proxy traps, only <code>apply</code> and <code>construct</code> require the proxy target to be a function. Recall from Chapter 3 that functions have two internal methods called <code>[[Call]]</code> and <code>[[Construct]]</code> that are executed when a function is called without and with the <code>new</code> operator, respectively. The <code>apply</code> and <code>construct</code> traps correspond to and let you override those internal methods. When a function is called without <code>new</code>, the <code>apply</code> trap receives, and <code>Reflect.apply()</code> expects, the following arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the function being executed (the proxy's target)</li>
  <li>
<code>thisArg</code> - the value of <code>this</code> inside of the function during the call</li>
  <li>
<code>argumentsList</code> - an array of arguments passed to the function</li>
</ol>

<p>The <code>construct</code> trap, which is called when the function is executed using <code>new</code>, receives the following arguments:</p>

<ol class="numeric">
  <li>
<code>trapTarget</code> - the function being executed (the proxy's target)</li>
  <li>
<code>argumentsList</code> - an array of arguments passed to the function</li>
</ol>

<p>The <code>Reflect.construct()</code> method also accepts these two arguments and has an optional third argument called <code>newTarget</code>. When given, the <code>newTarget</code> argument specifies the value of <code>new.target</code> inside of the function.</p>

<p>Together, the <code>apply</code> and <code>construct</code> traps completely control the behavior of any proxy target function. To mimic the default behavior of a function, you can do this:</p>

<figure class="code">
<pre><code>let target = function() { return 42 },
    proxy = new Proxy(target, {
        apply: function(trapTarget, thisArg, argumentList) {
            return Reflect.apply(trapTarget, thisArg, argumentList);
        },
        construct: function(trapTarget, argumentList) {
            return Reflect.construct(trapTarget, argumentList);
        }
    });

// a proxy with a function as its target looks like a function
console.log(typeof proxy);                  // "function"

console.log(proxy());                       // 42

var instance = new proxy();
console.log(instance instanceof proxy);     // true
console.log(instance instanceof target);    // true
</code></pre>

</figure>

<p>This example has a function that returns the number 42. The proxy for that function uses the <code>apply</code> and <code>construct</code> traps to delegate those behaviors to the <code>Reflect.apply()</code> and <code>Reflect.construct()</code> methods, respectively. The end result is that the proxy function works exactly like the target function, including identifying itself as a function when <code>typeof</code> is used. The proxy is called without <code>new</code> to return 42 and then is called with <code>new</code> to create an object called <code>instance</code>. The <code>instance</code> object is considered an instance of both <code>proxy</code> and <code>target</code> because <code>instanceof</code> uses the prototype chain to determine this information. Prototype chain lookup is not affected by this proxy, which is why <code>proxy</code> and <code>target</code> appear to have the same prototype to the JavaScript engine.</p>

<h4 id="leanpub-auto-validating-function-parameters">Validating Function Parameters</h4>

<p>The <code>apply</code> and <code>construct</code> traps open up a lot of possibilities for altering the way a function is executed. For instance, suppose you want to validate that all arguments are of a specific type. You can check the arguments in the <code>apply</code> trap:</p>

<figure class="code">
<pre><code>// adds together all arguments
function sum(...values) {
    return values.reduce((previous, current) =&gt; previous + current, 0);
}

let sumProxy = new Proxy(sum, {
        apply: function(trapTarget, thisArg, argumentList) {

            argumentList.forEach((arg) =&gt; {
                if (typeof arg !== "number") {
                    throw new TypeError("All arguments must be numbers.");
                }
            });

            return Reflect.apply(trapTarget, thisArg, argumentList);
        },
        construct: function(trapTarget, argumentList) {
            throw new TypeError("This function can't be called with new.");
        }
    });

console.log(sumProxy(1, 2, 3, 4));          // 10

// throws error
console.log(sumProxy(1, "2", 3, 4));

// also throws error
let result = new sumProxy();
</code></pre>

</figure>

<p>This example uses the <code>apply</code> trap to ensure that all arguments are numbers. The <code>sum()</code> function adds up all of the arguments that are passed. If a non-number value is passed, the function will still attempt the operation, which can cause unexpected results. By wrapping <code>sum()</code> inside the <code>sumProxy()</code> proxy, this code intercepts function calls and ensures that each argument is a number before allowing the call to proceed. To be safe, the code also uses the <code>construct</code> trap to ensure that the function can't be called with <code>new</code>.</p>

<p>You can also do the opposite, ensuring that a function must be called with <code>new</code> and validating its arguments to be numbers:</p>

<figure class="code">
<pre><code>function Numbers(...values) {
    this.values = values;
}

let NumbersProxy = new Proxy(Numbers, {

        apply: function(trapTarget, thisArg, argumentList) {
            throw new TypeError("This function must be called with new.");
        },

        construct: function(trapTarget, argumentList) {
            argumentList.forEach((arg) =&gt; {
                if (typeof arg !== "number") {
                    throw new TypeError("All arguments must be numbers.");
                }
            });

            return Reflect.construct(trapTarget, argumentList);
        }
    });

let instance = new NumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]

// throws error
NumbersProxy(1, 2, 3, 4);
</code></pre>

</figure>

<p>Here, the <code>apply</code> trap throws an error while the <code>construct</code> trap uses the <code>Reflect.construct()</code> method to validate input and return a new instance. Of course, you can accomplish the same thing without proxies using <code>new.target</code> instead.</p>

<h4 id="leanpub-auto-calling-constructors-without-new">Calling Constructors Without new</h4>

<p>Chapter 3 introduced the <code>new.target</code> metaproperty. To review, <code>new.target</code> is a reference to the function on which <code>new</code> is called, meaning that you can tell if a function was called using <code>new</code> or not by checking the value of <code>new.target</code> like this:</p>

<figure class="code">
<pre><code>function Numbers(...values) {

    if (typeof new.target === "undefined") {
        throw new TypeError("This function must be called with new.");
    }

    this.values = values;
}

let instance = new Numbers(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]

// throws error
Numbers(1, 2, 3, 4);
</code></pre>

</figure>

<p>This example throws an error when <code>Numbers</code> is called without using <code>new</code>, which is similar to the example in the "Validating Function Parameters" section but doesn't use a proxy. Writing code like this is much simpler than using a proxy and is preferable if your only goal is to prevent calling the function without <code>new</code>. But sometimes you aren't in control of the function whose behavior needs to be modified. In that case, using a proxy makes sense.</p>

<p>Suppose the <code>Numbers</code> function is defined in code you can't modify. You know that the code relies on <code>new.target</code> and want to avoid that check while still calling the function. The behavior when using <code>new</code> is already set, so you can just use the <code>apply</code> trap:</p>

<figure class="code">
<pre><code>function Numbers(...values) {

    if (typeof new.target === "undefined") {
        throw new TypeError("This function must be called with new.");
    }

    this.values = values;
}


let NumbersProxy = new Proxy(Numbers, {
        apply: function(trapTarget, thisArg, argumentsList) {
            return Reflect.construct(trapTarget, argumentsList);
        }
    });


let instance = NumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]
</code></pre>

</figure>

<p>The <code>NumbersProxy</code> function allows you to call <code>Numbers</code> without using <code>new</code> and have it behave as if <code>new</code> were used. To do so, the <code>apply</code> trap calls <code>Reflect.construct()</code> with the arguments passed into <code>apply</code>. The <code>new.target</code> inside of <code>Numbers</code> is equal to <code>Numbers</code> itself, and no error is thrown. While this is a simple example of modifying <code>new.target</code>, you can also do so more directly.</p>

<h4 id="leanpub-auto-overriding-abstract-base-class-constructors">Overriding Abstract Base Class Constructors</h4>

<p>You can go one step further and specify the third argument to <code>Reflect.construct()</code> as the specific value to assign to <code>new.target</code>. This is useful when a function is checking <code>new.target</code> against a known value, such as when creating an abstract base class constructor (discussed in Chapter 9). In an abstract base class constructor, <code>new.target</code> is expected to be something other than the class constructor itself, as in this example:</p>

<figure class="code">
<pre><code>class AbstractNumbers {

    constructor(...values) {
        if (new.target === AbstractNumbers) {
            throw new TypeError("This function must be inherited from.");
        }

        this.values = values;
    }
}

class Numbers extends AbstractNumbers {}

let instance = new Numbers(1, 2, 3, 4);
console.log(instance.values);           // [1,2,3,4]

// throws error
new AbstractNumbers(1, 2, 3, 4);
</code></pre>

</figure>

<p>When <code>new AbstractNumbers()</code> is called, <code>new.target</code> is equal to <code>AbstractNumbers</code> and an error is thrown. Calling <code>new Numbers()</code> still works because <code>new.target</code> is equal to <code>Numbers</code>. You can bypass this restriction by manually assigning <code>new.target</code> with a proxy:</p>

<figure class="code">
<pre><code>class AbstractNumbers {

    constructor(...values) {
        if (new.target === AbstractNumbers) {
            throw new TypeError("This function must be inherited from.");
        }

        this.values = values;
    }
}

let AbstractNumbersProxy = new Proxy(AbstractNumbers, {
        construct: function(trapTarget, argumentList) {
            return Reflect.construct(trapTarget, argumentList, function() {});
        }
    });


let instance = new AbstractNumbersProxy(1, 2, 3, 4);
console.log(instance.values);               // [1,2,3,4]
</code></pre>

</figure>

<p>The <code>AbstractNumbersProxy</code> uses the <code>construct</code> trap to intercept the call to the <code>new AbstractNumbersProxy()</code> method. Then, the <code>Reflect.construct()</code> method is called with arguments from the trap and adds an empty function as the third argument. That empty function is used as the value of <code>new.target</code> inside of the constructor. Because <code>new.target</code> is not equal to <code>AbstractNumbers</code>, no error is thrown and the constructor executes completely.</p>

<h4 id="leanpub-auto-callable-class-constructors">Callable Class Constructors</h4>

<p>Chapter 9 explained that class constructors must always be called with <code>new</code>. That happens because the internal <code>[[Call]]</code> method for class constructors is specified to throw an error. But proxies can intercept calls to the <code>[[Call]]</code> method, meaning you can effectively create callable class constructors by using a proxy. For instance, if you want a class constructor to work without using <code>new</code>, you can use the <code>apply</code> trap to create a new instance. Here's some sample code:</p>

<figure class="code">
<pre><code>class Person {
    constructor(name) {
        this.name = name;
    }
}

let PersonProxy = new Proxy(Person, {
        apply: function(trapTarget, thisArg, argumentList) {
            return new trapTarget(...argumentList);
        }
    });


let me = PersonProxy("Nicholas");
console.log(me.name);                   // "Nicholas"
console.log(me instanceof Person);      // true
console.log(me instanceof PersonProxy); // true
</code></pre>

</figure>

<p>The <code>PersonProxy</code> object is a proxy of the <code>Person</code> class constructor. Class constructors are just functions, so they behave like functions when used in proxies. The <code>apply</code> trap overrides the default behavior and instead returns a new instance of <code>trapTarget</code> that's equal to <code>Person</code>. (I used <code>trapTarget</code> in this example to show that you don't need to manually specify the class.) The <code>argumentList</code> is passed to <code>trapTarget</code> using the spread operator to pass each argument separately. Calling <code>PersonProxy()</code> without using <code>new</code> returns an instance of <code>Person</code>; if you attempt to call <code>Person()</code> without <code>new</code>, the constructor will still throw an error. Creating callable class constructors is something that is only possible using proxies.</p>

<h3 id="leanpub-auto-revocable-proxies">Revocable Proxies</h3>

<p>Normally, a proxy can't be unbound from its target once the proxy has been created. All of the examples to this point in this chapter have used nonrevocable proxies. But there may be situations when you want to revoke a proxy so that it can no longer be used. You'll find it most helpful to revoke proxies when you want to provide an object through an API for security purposes and maintain the ability to cut off access to some functionality at any point in time.</p>

<p>You can create revocable proxies with the <code>Proxy.revocable()</code> method, which takes the same arguments as the <code>Proxy</code> constructor–a target object and the proxy handler. The return value is an object with the following properties:</p>

<ol class="numeric">
  <li>
<code>proxy</code> - the proxy object that can be revoked</li>
  <li>
<code>revoke</code> - the function to call to revoke the proxy</li>
</ol>

<p>When the <code>revoke()</code> function is called, no further operations can be performed through the <code>proxy</code>. Any attempt to interact with the proxy object in a way that would trigger a proxy trap throws an error. For example:</p>

<figure class="code">
<pre><code>let target = {
    name: "target"
};

let { proxy, revoke } = Proxy.revocable(target, {});

console.log(proxy.name);        // "target"

revoke();

// throws error
console.log(proxy.name);
</code></pre>

</figure>

<p>This example creates a revocable proxy. It uses destructuring to assign the <code>proxy</code> and <code>revoke</code> variables to the properties of the same name on the object returned by the <code>Proxy.revocable()</code> method. After that, the <code>proxy</code> object can be used just like a nonrevocable proxy object, so <code>proxy.name</code> returns <code>"target"</code> because it passes through to <code>target.name</code>. Once the <code>revoke()</code> function is called, however, <code>proxy</code> no longer functions. Attempting to access <code>proxy.name</code> throws an error, as will any other operation that would trigger a trap on <code>proxy</code>.</p>

<h3 id="leanpub-auto-solving-the-array-problem">Solving the Array Problem</h3>

<p>At the beginning of this chapter, I explained how developers couldn't mimic the behavior of an array accurately in JavaScript prior to ECMAScript 6. Proxies and the reflection API allow you to create an object that behaves in the same manner as the built-in <code>Array</code> type when properties are added and removed. To refresh your memory, here's an example showing the behavior that proxies help to mimick:</p>

<figure class="code">
<pre><code>let colors = ["red", "green", "blue"];

console.log(colors.length);         // 3

colors[3] = "black";

console.log(colors.length);         // 4
console.log(colors[3]);             // "black"

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
</code></pre>

</figure>

<p>There are two particularly important behaviors to notice in this example:</p>

<ol class="numeric">
  <li>The <code>length</code> property is increased to 4 when <code>colors[3]</code> is assigned a value.</li>
  <li>The last two items in the array are deleted when the <code>length</code> property is set to 2.</li>
</ol>

<p>These two behaviors are the only ones that need to be mimicked to accurately recreate how built-in arrays work. The next few sections describe how to make an object that correctly mimics them.</p>

<h4 id="leanpub-auto-detecting-array-indices">Detecting Array Indices</h4>

<p>Keep in mind that assigning to an integer property key is a special case for arrays, as those are treated differently from non-integer keys. The ECMAScript 6 specification gives these instructions on how to determine if a property key is an array index:</p>

<blockquote>
  <p>A String property name <code>P</code> is an array index if and only if <code>ToString(ToUint32(P))</code> is equal to <code>P</code> and <code>ToUint32(P)</code> is not equal to 2<sup>32</sup>-1.</p>
</blockquote>

<p>This operation can be implemented in JavaScript as follows:</p>

<figure class="code">
<pre><code>function toUint32(value) {
    return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);
}

function isArrayIndex(key) {
    let numericKey = toUint32(key);
    return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);
}
</code></pre>

</figure>

<p>The <code>toUint32()</code> function converts a given value into an unsigned 32-bit integer using an algorithm described in the specification. The <code>isArrayIndex()</code> function first converts the key into a uint32 and then performs the comparisons to determine if the key is an array index or not. With these utility functions available, you can start to implement an object that will mimic a built-in array.</p>

<h4 id="leanpub-auto-increasing-length-when-adding-new-elements">Increasing length when Adding New Elements</h4>

<p>You might have noticed that both array behaviors I described rely on the assignment of a property. That means you really only need to use the <code>set</code> proxy trap to accomplish both behaviors. To get started, here's an example that implements the first of the two behaviors by incrementing the <code>length</code> property when an array index larger than <code>length - 1</code> is used:</p>

<figure class="code">
<pre><code>function toUint32(value) {
    return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);
}

function isArrayIndex(key) {
    let numericKey = toUint32(key);
    return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);
}

function createMyArray(length=0) {
    return new Proxy({ length }, {
        set(trapTarget, key, value) {

            let currentLength = Reflect.get(trapTarget, "length");

            // the special case
            if (isArrayIndex(key)) {
                let numericKey = Number(key);

                if (numericKey &gt;= currentLength) {
                    Reflect.set(trapTarget, "length", numericKey + 1);
                }
            }

            // always do this regardless of key type
            return Reflect.set(trapTarget, key, value);
        }
    });
}

let colors = createMyArray(3);
console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";

console.log(colors.length);         // 3

colors[3] = "black";

console.log(colors.length);         // 4
console.log(colors[3]);             // "black"
</code></pre>

</figure>

<p>This example uses the <code>set</code> proxy trap to intercept the setting of an array index. If the key is an array index, then it is converted into a number because keys are always passed as strings. Next, if that numeric value is greater than or equal to the current <code>length</code> property, then the <code>length</code> property is updated to be one more than the numeric key (setting an item in position 3 means the <code>length</code> must be 4). After that, the default behavior for setting a property is used via <code>Reflect.set()</code>, since you do want the property to receive the value as specified.</p>

<p>The initial custom array is created by calling <code>createMyArray()</code> with a <code>length</code> of 3 and the values for those three items are added immediately afterward. The <code>length</code> property correctly remains 3 until the value <code>"black"</code> is assigned to position 3. At that point, <code>length</code> is set to 4.</p>

<p>With the first behavior working, it's time to move on to the second.</p>

<h4 id="leanpub-auto-deleting-elements-on-reducing-length">Deleting Elements on Reducing length</h4>

<p>The first array behavior to mimic is used only when an array index is greater than or equal to the <code>length</code> property. The second behavior does the opposite and removes array items when the <code>length</code> property is set to a smaller value than it previously contained. That involves not only changing the <code>length</code> property, but also deleting all items that might otherwise exist. For instance, if an array with a <code>length</code> of 4 has <code>length</code> set to 2, the items in positions 2 and 3 are deleted. You can accomplish this inside the <code>set</code> proxy trap alongside the first behavior. Here's the previous example again, with an updated <code>createMyArray</code> method:</p>

<figure class="code">
<pre><code>function toUint32(value) {
    return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);
}

function isArrayIndex(key) {
    let numericKey = toUint32(key);
    return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);
}

function createMyArray(length=0) {
    return new Proxy({ length }, {
        set(trapTarget, key, value) {

            let currentLength = Reflect.get(trapTarget, "length");

            // the special case
            if (isArrayIndex(key)) {
                let numericKey = Number(key);

                if (numericKey &gt;= currentLength) {
                    Reflect.set(trapTarget, "length", numericKey + 1);
                }
            } else if (key === "length") {

                if (value &lt; currentLength) {
                    for (let index = currentLength - 1; index &gt;= value; index\
--) {
                        Reflect.deleteProperty(trapTarget, index);
                    }
                }

            }

            // always do this regardless of key type
            return Reflect.set(trapTarget, key, value);
        }
    });
}

let colors = createMyArray(3);
console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";
colors[3] = "black";

console.log(colors.length);         // 4

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
console.log(colors[0]);             // "red"
</code></pre>

</figure>

<p>The <code>set</code> proxy trap in this code checks to see if <code>key</code> is <code>"length"</code> in order to adjust the rest of the object correctly. When that happens, the current length is first retrieved using <code>Reflect.get()</code> and compared against the new value. If the new value is less than the current length, then a <code>for</code> loop deletes all properties on the target that should no longer be available. The <code>for</code> loop goes backward from the current array length (<code>currentLength</code>) and deletes each property until it reaches the new array length (<code>value</code>).</p>

<p>This example adds four colors to <code>colors</code> and then sets the <code>length</code> property to 2. That effectively removes the items in positions 2 and 3, so they now return <code>undefined</code> when you attempt to access them. The <code>length</code> property is correctly set to 2 and the items in positions 0 and 1 are still accessible.</p>

<p>With both behaviors implemented, you can easily create an object that mimics the behavior of built-in arrays. But doing so with a function isn't as desirable as creating a class to encapsulate this behavior, so the next step is to implement this functionality as a class.</p>

<h4 id="leanpub-auto-implementing-the-myarray-class">Implementing the MyArray Class</h4>

<p>The simplest way to create a class that uses a proxy is to define the class as usual and then return a proxy from the constructor. That way, the object returned when a class is instantiated will be the proxy instead of the instance. (The instance is the value of <code>this</code> inside the constructor.) The instance becomes the target of the proxy and the proxy is returned as if it were the instance. The instance will be completely private and you won't be able to access it directly, though you'll be able to access it indirectly through the proxy.</p>

<p>Here's a simple example of returning a proxy from a class constructor:</p>

<figure class="code">
<pre><code>class Thing {
    constructor() {
        return new Proxy(this, {});
    }
}

let myThing = new Thing();
console.log(myThing instanceof Thing);      // true
</code></pre>

</figure>

<p>In this example, the class <code>Thing</code> returns a proxy from its constructor. The proxy target is <code>this</code> and the proxy is returned from the constructor. That means <code>myThing</code> is actually a proxy even though it was created by calling the <code>Thing</code> constructor. Because proxies pass through their behavior to their targets, <code>myThing</code> is still considered an instance of <code>Thing</code>, making the proxy completely transparent to anyone using the <code>Thing</code> class.</p>

<p>With that in mind, creating a custom array class using a proxy in relatively straightforward. The code is mostly the same as the code in the "Deleting Elements on Reducing Length" section. The same proxy code is used, but this time, it's inside a class constructor. Here's the complete example:</p>

<figure class="code">
<pre><code>function toUint32(value) {
    return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);
}

function isArrayIndex(key) {
    let numericKey = toUint32(key);
    return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);
}

class MyArray {
    constructor(length=0) {
        this.length = length;

        return new Proxy(this, {
            set(trapTarget, key, value) {

                let currentLength = Reflect.get(trapTarget, "length");

                // the special case
                if (isArrayIndex(key)) {
                    let numericKey = Number(key);

                    if (numericKey &gt;= currentLength) {
                        Reflect.set(trapTarget, "length", numericKey + 1);
                    }
                } else if (key === "length") {

                    if (value &lt; currentLength) {
                        for (let index = currentLength - 1; index &gt;= value; i\
ndex--) {
                            Reflect.deleteProperty(trapTarget, index);
                        }
                    }

                }

                // always do this regardless of key type
                return Reflect.set(trapTarget, key, value);
            }
        });

    }
}


let colors = new MyArray(3);
console.log(colors instanceof MyArray);     // true

console.log(colors.length);         // 3

colors[0] = "red";
colors[1] = "green";
colors[2] = "blue";
colors[3] = "black";

console.log(colors.length);         // 4

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
console.log(colors[0]);             // "red"
</code></pre>

</figure>

<p>This code creates a <code>MyArray</code> class that returns a proxy from its constructor. The <code>length</code> property is added in the constructor (initialized to either the value that is passed in or to a default value of 0) and then a proxy is created and returned. This gives the <code>colors</code> variable the appearance of being just an instance of <code>MyArray</code> and implements both of the key array behaviors.</p>

<p>Although returning a proxy from a class constructor is easy, it does mean that a new proxy is created for every instance. There is, however, a way to have all instances share one proxy: you can use the proxy as a prototype.</p>

<h3 id="leanpub-auto-using-a-proxy-as-a-prototype">Using a Proxy as a Prototype</h3>

<p>Proxies can be used as prototypes, but doing so is a bit more involved than the previous examples in this chapter. When a proxy is a prototype, the proxy traps are only called when the default operation would normally continue on to the prototype, which does limit a proxy's capabilities as a prototype. Consider this example:</p>

<figure class="code">
<pre><code>let target = {};
let newTarget = Object.create(new Proxy(target, {

    // never called
    defineProperty(trapTarget, name, descriptor) {

        // would cause an error if called
        return false;
    }
}));

Object.defineProperty(newTarget, "name", {
    value: "newTarget"
});

console.log(newTarget.name);                    // "newTarget"
console.log(newTarget.hasOwnProperty("name"));  // true
</code></pre>

</figure>

<p>The <code>newTarget</code> object is created with a proxy as the prototype. Making <code>target</code> the proxy target effectively makes <code>target</code> the prototype of <code>newTarget</code> because the proxy is transparent. Now, proxy traps will only be called if an operation on <code>newTarget</code> would pass the operation through to happen on <code>target</code>.</p>

<p>The <code>Object.defineProperty()</code> method is called on <code>newTarget</code> to create an own property called <code>name</code>. Defining a property on an object isn't an operation that normally continues to the object's prototype, so the <code>defineProperty</code> trap on the proxy is never called and the <code>name</code> property is added to <code>newTarget</code> as an own property.</p>

<p>While proxies are severely limited when used as prototypes, there are a few traps that are still useful.</p>

<h4 id="leanpub-auto-using-the-get-trap-on-a-prototype">Using the <code>get</code> Trap on a Prototype</h4>

<p>When the internal <code>[[Get]]</code> method is called to read a property, the operation looks for own properties first. If an own property with the given name isn't found, then the operation continues to the prototype and looks for a property there. The process continues until there are no further prototypes to check.</p>

<p>Thanks to that process, if you set up a <code>get</code> proxy trap, the trap will be called on a prototype whenever an own property of the given name doesn't exist. You can use the <code>get</code> trap to prevent unexpected behavior when accessing properties that you can't guarantee will exist. Just create an object that throws an error whenever you try to access a property that doesn't exist:</p>

<figure class="code">
<pre><code>let target = {};
let thing = Object.create(new Proxy(target, {
    get(trapTarget, key, receiver) {
        throw new ReferenceError(`${key} doesn't exist`);
    }
}));

thing.name = "thing";

console.log(thing.name);        // "thing"

// throw an error
let unknown = thing.unknown;
</code></pre>

</figure>

<p>In this code, the <code>thing</code> object is created with a proxy as its prototype. The <code>get</code> trap throws an error when called to indicate that the given key doesn't exist on the <code>thing</code> object. When <code>thing.name</code> is read, the operation never calls the <code>get</code> trap on the prototype because the property exists on <code>thing</code>. The <code>get</code> trap is called only when the <code>thing.unknown</code> property, which doesn't exist, is accessed.</p>

<p>When the last line executes, <code>unknown</code> isn't an own property of <code>thing</code>, so the operation continues to the prototype. The <code>get</code> trap then throws an error. This type of behavior can be very useful in JavaScript, where unknown properties silently return <code>undefined</code> instead of throwing an error (as happens in other languages).</p>

<p>It's important to understand that in this example, <code>trapTarget</code> and <code>receiver</code> are different objects. When a proxy is used as a prototype, the <code>trapTarget</code> is the prototype object itself while the <code>receiver</code> is the instance object. In this case, that means <code>trapTarget</code> is equal to <code>target</code> and <code>receiver</code> is equal to <code>thing</code>. That allows you access both to the original target of the proxy and the object on which the operation is meant to take place.</p>

<h4 id="leanpub-auto-using-the-set-trap-on-a-prototype">Using the <code>set</code> Trap on a Prototype</h4>

<p>The internal <code>[[Set]]</code> method also checks for own properties and then continues to the prototype if needed. When you assign a value to an object property, the value is assigned to the own property with the same name if it exists. If no own property with the given name exists, then the operation continues to the prototype. The tricky part is that even though the assignment operation continues to the prototype, assigning a value to that property will create a property on the instance (not the prototype) by default, regardless of whether a property of that name exists on the prototype.</p>

<p>To get a better idea of when the <code>set</code> trap will be called on a prototype and when it won't, consider the following example showing the default behavior:</p>

<figure class="code">
<pre><code>let target = {};
let thing = Object.create(new Proxy(target, {
    set(trapTarget, key, value, receiver) {
        return Reflect.set(trapTarget, key, value, receiver);
    }
}));

console.log(thing.hasOwnProperty("name"));      // false

// triggers the `set` proxy trap
thing.name = "thing";

console.log(thing.name);                        // "thing"
console.log(thing.hasOwnProperty("name"));      // true

// does not trigger the `set` proxy trap
thing.name = "boo";

console.log(thing.name);                        // "boo"
</code></pre>

</figure>

<p>In this example, <code>target</code> starts with no own properties. The <code>thing</code> object has a proxy as its prototype that defines a <code>set</code> trap to catch the creation of any new properties. When <code>thing.name</code> is assigned <code>"thing"</code> as its value, the <code>set</code> proxy trap is called because <code>thing</code> doesn't have an own property called <code>name</code>. Inside the <code>set</code> trap, <code>trapTarget</code> is equal to <code>target</code> and <code>receiver</code> is equal to <code>thing</code>. The operation should ultimately create a new property on <code>thing</code>, and fortunately <code>Reflect.set()</code> implements this default behavior for you if you pass in <code>receiver</code> as the fourth argument.</p>

<p>Once the <code>name</code> property is created on <code>thing</code>, setting <code>thing.name</code> to a different value will no longer call the <code>set</code> proxy trap. At that point, <code>name</code> is an own property so the <code>[[Set]]</code> operation never continues on to the prototype.</p>

<h4 id="leanpub-auto-using-the-has-trap-on-a-prototype">Using the <code>has</code> Trap on a Prototype</h4>

<p>Recall that the <code>has</code> trap intercepts the use of the <code>in</code> operator on objects. The <code>in</code> operator searches first for an object's own property with the given name. If an own property with that name doesn't exist, the operation continues to the prototype. If there's no own property on the prototype, then the search continues through the prototype chain until the own property is found or there are no more prototypes to search.</p>

<p>The <code>has</code> trap is therefore only called when the search reaches the proxy object in the prototype chain. When using a proxy as a prototype, that only happens when there's no own property of the given name. For example:</p>

<figure class="code">
<pre><code>let target = {};
let thing = Object.create(new Proxy(target, {
    has(trapTarget, key) {
        return Reflect.has(trapTarget, key);
    }
}));

// triggers the `has` proxy trap
console.log("name" in thing);                   // false

thing.name = "thing";

// does not trigger the `has` proxy trap
console.log("name" in thing);                   // true
</code></pre>

</figure>

<p>This code creates a <code>has</code> proxy trap on the prototype of <code>thing</code>. The <code>has</code> trap isn't passed a <code>receiver</code> object like the <code>get</code> and <code>set</code> traps are because searching the prototype happens automatically when the <code>in</code> operator is used. Instead, the <code>has</code> trap must operate only on <code>trapTarget</code>, which is equal to <code>target</code>. The first time the <code>in</code> operator is used in this example, the <code>has</code> trap is called because the property <code>name</code> doesn't exist as an own property of <code>thing</code>. When <code>thing.name</code> is given a value and then the <code>in</code> operator is used again, the <code>has</code> trap isn't called because the operation stops after finding the own property <code>name</code> on <code>thing</code>.</p>

<p>The prototype examples to this point have centered around objects created using the  <code>Object.create()</code> method. But if you want to create a class that has a proxy as a prototype, the process is a bit more involved.</p>

<h4 id="leanpub-auto-proxies-as-prototypes-on-classes">Proxies as Prototypes on Classes</h4>

<p>Classes cannot be directly modified to use a proxy as a prototype because their <code>prototype</code> property is non-writable. You can, however, use a bit of misdirection to create a class that has a proxy as its prototype by using inheritance. To start, you need to create an ECMAScript 5-style type definition using a constructor function. You can then overwrite the prototype to be a proxy. Here's an example:</p>

<figure class="code">
<pre><code>function NoSuchProperty() {
    // empty
}

NoSuchProperty.prototype = new Proxy({}, {
    get(trapTarget, key, receiver) {
        throw new ReferenceError(`${key} doesn't exist`);
    }
});

let thing = new NoSuchProperty();

// throws error due to `get` proxy trap
let result = thing.name;
</code></pre>

</figure>

<p>The <code>NoSuchProperty</code> function represents the base from which the class will inherit. There are no restrictions on the <code>prototype</code> property of functions, so you can overwrite it with a proxy. The <code>get</code> trap is used to throw an error when the property doesn't exist. The <code>thing</code> object is created as an instance of <code>NoSuchProperty</code> and throws an error when the nonexistent <code>name</code> property is accessed.</p>

<p>The next step is to create a class that inherits from <code>NoSuchProperty</code>. You can simply use the <code>extends</code> syntax discussed in Chapter 9 to introduce the proxy into the class' prototype chain, like this:</p>

<figure class="code">
<pre><code>function NoSuchProperty() {
    // empty
}

NoSuchProperty.prototype = new Proxy({}, {
    get(trapTarget, key, receiver) {
        throw new ReferenceError(`${key} doesn't exist`);
    }
});

class Square extends NoSuchProperty {
    constructor(length, width) {
        super();
        this.length = length;
        this.width = width;
    }
}

let shape = new Square(2, 6);

let area1 = shape.length * shape.width;
console.log(area1);                         // 12

// throws an error because "wdth" doesn't exist
let area2 = shape.length * shape.wdth;
</code></pre>

</figure>

<p>The <code>Square</code> class inherits from <code>NoSuchProperty</code> so the proxy is in the <code>Square</code> class' prototype chain. The <code>shape</code> object is then created as a new instance of <code>Square</code> and has two own properties: <code>length</code> and <code>width</code>. Reading the values of those properties succeeds because the <code>get</code> proxy trap is never called. Only when a property that doesn't exist on <code>shape</code> is accessed (<code>shape.wdth</code>, an obvious typo) does the <code>get</code> proxy trap trigger and throw an error.</p>

<p>That proves the proxy is in the prototype chain of <code>shape</code>, but it might not be obvious that the proxy is not the direct prototype of <code>shape</code>. In fact, the proxy is a couple of steps up the prototype chain from <code>shape</code>. You can see this more clearly by slightly altering the preceding example:</p>

<figure class="code">
<pre><code>function NoSuchProperty() {
    // empty
}

// store a reference to the proxy that will be the prototype
let proxy = new Proxy({}, {
    get(trapTarget, key, receiver) {
        throw new ReferenceError(`${key} doesn't exist`);
    }
});

NoSuchProperty.prototype = proxy;

class Square extends NoSuchProperty {
    constructor(length, width) {
        super();
        this.length = length;
        this.width = width;
    }
}

let shape = new Square(2, 6);

let shapeProto = Object.getPrototypeOf(shape);

console.log(shapeProto === proxy);                  // false

let secondLevelProto = Object.getPrototypeOf(shapeProto);

console.log(secondLevelProto === proxy);            // true
</code></pre>

</figure>

<p>This version of the code stores the proxy in a variable called <code>proxy</code> so it's easy to identify later. The prototype of <code>shape</code> is <code>Shape.prototype</code>, which is not a proxy. But the prototype of <code>Shape.prototype</code> is the proxy that was inherited from <code>NoSuchProperty</code>.</p>

<p>The inheritance adds another step in the prototype chain, and that matters because operations that might result in calling the <code>get</code> trap on <code>proxy</code> need to go through one extra step before getting there. If there's a property on <code>Shape.prototype</code>, then that will prevent the <code>get</code> proxy trap from being called, as in this example:</p>

<figure class="code">
<pre><code>function NoSuchProperty() {
    // empty
}

NoSuchProperty.prototype = new Proxy({}, {
    get(trapTarget, key, receiver) {
        throw new ReferenceError(`${key} doesn't exist`);
    }
});

class Square extends NoSuchProperty {
    constructor(length, width) {
        super();
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }
}

let shape = new Square(2, 6);

let area1 = shape.length * shape.width;
console.log(area1);                         // 12

let area2 = shape.getArea();
console.log(area2);                         // 12

// throws an error because "wdth" doesn't exist
let area3 = shape.length * shape.wdth;
</code></pre>

</figure>

<p>Here, the <code>Square</code> class has a <code>getArea()</code> method. The <code>getArea()</code> method is automatically added to <code>Square.prototype</code> so when <code>shape.getArea()</code> is called, the search for the method <code>getArea()</code> starts on the <code>shape</code> instance and then proceeds to its prototype. Because <code>getArea()</code> is found on the prototype, the search stops and the proxy is never called. That is actually the behavior you want in this situation, as you wouldn't want to incorrectly throw an error when <code>getArea()</code> was called.</p>

<p>Even though it takes a little bit of extra code to create a class with a proxy in its prototype chain, it can be worth the effort if you need such functionality.</p>

<h3 id="leanpub-auto-summary-11">Summary</h3>

<p>Prior to ECMAScript 6, certain objects (such as arrays) displayed nonstandard behavior that developers couldn't replicate. Proxies change that. They let you define your own nonstandard behavior for several low-level JavaScript operations, so you can replicate all behaviors of built-in JavaScript objects through proxy traps. These traps are called behind the scenes when various operations take place, like a use of the <code>in</code> operator.</p>

<p>A reflection API was also introduced in ECMAScript 6 to allow developers to implement the default behavior for each proxy trap. Each proxy trap has a corresponding method of the same name on the <code>Reflect</code> object, another ECMAScript 6 addition. Using a combination of proxy traps and reflection API methods, it's possible to filter some operations to behave differently only in certain conditions while defaulting to the built-in behavior.</p>

<p>Revocable proxies are a special proxies that can be effectively disabled by using a <code>revoke()</code> function. The <code>revoke()</code> function terminates all functionality on the proxy, so any attempt to interact with the proxy's properties throws an error after <code>revoke()</code> is called. Revocable proxies are important for application security where third-party developers may need access to certain objects for a specified amount of time.</p>

<p>While using proxies directly is the most powerful use case, you can also use a proxy as the prototype for another object. In that case, you are severely limited in the number of proxy traps you can effectively use. Only the <code>get</code>, <code>set</code>, and <code>has</code> proxy traps will ever be called on a proxy when it's used as a prototype, making the set of use cases much smaller.</p>


<h2 id="leanpub-auto-encapsulating-code-with-modules">Encapsulating Code With Modules</h2>

<p>JavaScript's "shared everything" approach to loading code is one of the most error-prone and confusing aspects of the language. Other languages use concepts such as packages to define code scope, but before ECMAScript 6, everything defined in every JavaScript file of an application shared one global scope. As web applications became more complex and started using even more JavaScript code, that approach caused problems like naming collisions and security concerns. One goal of ECMAScript 6 was to solve the scope problem and bring some order to JavaScript applications. That's where modules come in.</p>

<h3 id="leanpub-auto-what-are-modules">What are Modules?</h3>

<p><em>Modules</em> are JavaScript files that are loaded in a different mode (as opposed to <em>scripts</em>, which are loaded in the original way JavaScript worked). This different mode is necessary because modules have very different semantics than scripts:</p>

<ol class="numeric">
  <li>Module code automatically runs in strict mode, and there's no way to opt-out of strict mode.</li>
  <li>Variables created in the top level of a module aren't automatically added to the shared global scope. They exist only within the top-level scope of the module.</li>
  <li>The value of <code>this</code> in the top level of a module is <code>undefined</code>.</li>
  <li>Modules don't allow HTML-style comments within code (a leftover feature from JavaScript's early browser days).</li>
  <li>Modules must export anything that should be available to code outside of the module.</li>
  <li>Modules may import bindings from other modules.</li>
</ol>

<p>These differences may seem small at first glance, but they represent a significant change in how JavaScript code is loaded and evaluated, which I will discuss over the course of this chapter. The real power of modules is the ability to export and import only bindings you need, rather than everything in a file. A good understanding of exporting and importing is fundamental to understanding how modules differ from scripts.</p>

<h3 id="leanpub-auto-basic-exporting">Basic Exporting</h3>

<p>You can use the <code>export</code> keyword to expose parts of published code to other modules. In the simplest case, you can place <code>export</code> in front of any variable, function, or class declaration to export it from the module, like this:</p>

<figure class="code">
<pre><code>// export data
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// export function
export function sum(num1, num2) {
    return num1 + num1;
}

// export class
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

// this function is private to the module
function subtract(num1, num2) {
    return num1 - num2;
}

// define a function...
function multiply(num1, num2) {
    return num1 * num2;
}

// ...and then export it later
export { multiply };
</code></pre>

</figure>

<p>There are a few things to notice in this example. First, apart from the <code>export</code> keyword, every declaration is exactly the same as it would be otherwise. Each exported function or class also has a name; that's because exported function and class declarations require a name. You can't export anonymous functions or classes using this syntax unless you use the <code>default</code> keyword (discussed in detail in the "Default Values in Modules" section).</p>

<p>Next, consider the <code>multiply()</code> function, which isn't exported when it's defined. That works because you need not always export a declaration: you can also export references. Finally, notice that this example doesn't export the <code>subtract()</code> function. That function won't be accessible from outside this module because any variables, functions, or classes that are not explicitly exported remain private to the module.</p>

<h3 id="leanpub-auto-basic-importing">Basic Importing</h3>

<p>Once you have a module with exports, you can access the functionality in another module by using the <code>import</code> keyword. The two parts of an <code>import</code> statement are the identifiers you're importing and the module from which those identifiers should be imported. This is the statement's basic form:</p>

<figure class="code">
<pre><code>import { identifier1, identifier2 } from "./example.js";
</code></pre>

</figure>

<p>The curly braces after <code>import</code> indicate the bindings to import from a given module. The keyword <code>from</code> indicates the module from which to import the given binding. The module is specified by a string representing the path to the module (called the <em>module specifier</em>). Browsers use the same path format you might pass to the <code>&lt;script&gt;</code> element, which means you must include a file extension. Node.js, on the other hand, follows its traditional convention of differentiating between local files and packages based on a filesystem prefix. For example, <code>example</code> would be a package and <code>./example.js</code> would be a local file.</p>

<aside class="information blurb">
    <p>The list of bindings to import looks similar to a destructured object, but it isn't one.</p>

</aside>

<p>When importing a binding from a module, the binding acts as if it were defined using <code>const</code>. That means you can't define another variable with the same name (including importing another binding of the same name), use the identifier before the <code>import</code> statement, or change its value.</p>

<h4 id="leanpub-auto-importing-a-single-binding">Importing a Single Binding</h4>

<p>Suppose that the first example in the "Basic Exporting" section is in a module with the filename <code>example.js</code>. You can import and use bindings from that module in a number of ways. For instance, you can just import one identifier:</p>

<figure class="code">
<pre><code>// import just one
import { sum } from "./example.js";

console.log(sum(1, 2));     // 3

sum = 1;        // error
</code></pre>

</figure>

<p>Even though <code>example.js</code> exports more than just that one function this example imports only the <code>sum()</code> function. If you try to assign a new value to <code>sum</code>, the result is an error, as you can't reassign imported bindings.</p>

<aside class="warning blurb">
    <p>Make sure to include <code>/</code>, <code>./</code>, or <code>../</code> at the beginning of the file you're importing for best compatibility across browsers and Node.js.</p>

</aside>

<h4 id="leanpub-auto-importing-multiple-bindings">Importing Multiple Bindings</h4>

<p>If you want to import multiple bindings from the example module, you can explicitly list them out as follows:</p>

<figure class="code">
<pre><code>// import multiple
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber));   // 8
console.log(multiply(1, 2));        // 2
</code></pre>

</figure>

<p>Here, three bindings are imported from the example module: <code>sum</code>, <code>multiply</code>, and <code>magicNumber</code>. They are then used as if they were locally defined.</p>

<h4 id="leanpub-auto-importing-all-of-a-module">Importing All of a Module</h4>

<p>There's also a special case that allows you to import the entire module as a single object. All of the exports are then available on that object as properties. For example:</p>

<figure class="code">
<pre><code>// import everything
import * as example from "./example.js";
console.log(example.sum(1,
        example.magicNumber));          // 8
console.log(example.multiply(1, 2));    // 2
</code></pre>

</figure>

<p>In this code, all exported bindings in <code>example.js</code> are loaded into an object called <code>example</code>. The named exports (the <code>sum()</code> function, the <code>multiple()</code> function, and <code>magicNumber</code>) are then accessible as properties on <code>example</code>. This import format is called a <em>namespace import</em> because the <code>example</code> object doesn't exist inside of the <code>example.js</code> file and is instead created to be used as a namespace object for all of the exported members of <code>example.js</code>.</p>

<p>Keep in mind, however, that no matter how many times you use a module in <code>import</code> statements, the module will only be executed once. After the code to import the module executes, the instantiated module is kept in memory and reused whenever another <code>import</code> statement references it. Consider the following:</p>

<figure class="code">
<pre><code>import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
</code></pre>

</figure>

<p>Even though there are three <code>import</code> statements in this module, <code>example.js</code> will only be executed once. If other modules in the same application were to import bindings from <code>example.js</code>, those modules would use the same module instance this code uses.</p>

<aside>
  <h4 id="leanpub-auto-module-syntax-limitations">Module Syntax Limitations</h4>

  <p>An important limitation of both <code>export</code> and <code>import</code> is that they must be used outside other statements and functions. For instance, this code will give a syntax error:</p>

  <figure class="code">
<pre><code>if (flag) {
    export flag;    // syntax error
}
</code></pre>

  </figure>
  <p>The <code>export</code> statement is inside an <code>if</code> statement, which isn't allowed. Exports cannot be conditional or done dynamically in any way. One reason module syntax exists is to let the JavaScript engine staticly determine what will be exported. As such, you can only use <code>export</code> at the top-level of a module.</p>

  <p>Similarly, you can't use <code>import</code> inside of a statement; you can only use it at the top-level. That means this code also gives a syntax error:</p>

  <figure class="code">
<pre><code>function tryImport() {
    import flag from "./example.js";    // syntax error
}
</code></pre>

  </figure>

  <p>You can't dynamically import bindings for the same reason you can't dynamically export bindings. The <code>export</code> and <code>import</code> keywords are designed to be static so that tools like text editors can easily tell what information is available from a module.</p>

</aside>

<h4 id="leanpub-auto-a-subtle-quirk-of-imported-bindings">A Subtle Quirk of Imported Bindings</h4>

<p>ECMAScript 6's <code>import</code> statements create read-only bindings to variables, functions, and classes rather than simply referencing the original bindings like normal variables. Even though the module that imports the binding can't change its value, the module that exports that identifier can. For example, suppose you want to use this module:</p>

<figure class="code">
<pre><code>export var name = "Nicholas";
export function setName(newName) {
    name = newName;
}
</code></pre>

</figure>
<p>When you import those two bindings, the <code>setName()</code> function can change the value of <code>name</code>:</p>

<figure class="code">
<pre><code>import { name, setName } from "./example.js";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // error
</code></pre>

</figure>
<p>The call to <code>setName("Greg")</code> goes back into the module from which <code>setName()</code> was exported and executes there, setting <code>name</code> to <code>"Greg"</code> instead. Note this change is automatically reflected on the imported <code>name</code> binding. That's because <code>name</code> is the local name for the exported <code>name</code> identifier. The <code>name</code> used in the code above and the <code>name</code> used in the module being imported from aren't the same.</p>

<h3 id="leanpub-auto-renaming-exports-and-imports">Renaming Exports and Imports</h3>

<p>Sometimes, you may not want to use the original name of a variable, function, or class you've imported from a module. Fortunately, you can change the name of an export both during the export and during the import.</p>

<p>In the first case, suppose you have a function that you'd like to export with a different name. You can use the <code>as</code> keyword to specify the name that the function should be known as outside of the module:</p>

<figure class="code">
<pre><code>function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
</code></pre>

</figure>

<p>Here, the <code>sum()</code> function (<code>sum</code> is the <em>local name</em>) is exported as <code>add()</code> (<code>add</code> is the <em>exported name</em>). That means when another module wants to import this function, it will have to use the name <code>add</code> instead:</p>

<figure class="code">
<pre><code>import { add } from "./example.js";
</code></pre>

</figure>

<p>If the module importing the function wants to use a different name, it can also use <code>as</code>:</p>

<figure class="code">
<pre><code>import { add as sum } from "./example.js";
console.log(typeof add);            // "undefined"
console.log(sum(1, 2));             // 3
</code></pre>

</figure>

<p>This code imports the <code>add()</code> function using the <em>import name</em> and renames it to <code>sum()</code> (the local name). That means there is no identifier named <code>add</code> in this module.</p>

<h3 id="leanpub-auto-default-values-in-modules">Default Values in Modules</h3>

<p>The module syntax is really optimized for exporting and importing default values from modules, as this pattern was quite common in other module systems, like CommonJS (another specification for using JavaScript outside the browser). The <em>default value</em> for a module is a single variable, function, or class as specified by the <code>default</code> keyword, and you can only set one default export per module. Using the <code>default</code> keyword with multiple exports is a syntax error.</p>

<h4 id="leanpub-auto-exporting-default-values">Exporting Default Values</h4>

<p>Here's a simple example that uses the <code>default</code> keyword:</p>

<figure class="code">
<pre><code>export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>

</figure>

<p>This module exports a function as its default value. The <code>default</code> keyword indicates that this is a default export. The function doesn't require a name because the module itself represents the function.</p>

<p>You can also specify an identifier as the default export by by placing it after <code>export default</code>, such as:</p>

<figure class="code">
<pre><code>function sum(num1, num2) {
    return num1 + num2;
}

export default sum;
</code></pre>

</figure>

<p>Here, the <code>sum()</code> function is defined first and later exported as the default value of the module. You may want to choose this approach if the default value needs to be calculated.</p>

<p>A third way to specify an identifier as the default export is by using the renaming syntax as follows:</p>

<figure class="code">
<pre><code>function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
</code></pre>

</figure>

<p>The identifier <code>default</code> has special meaning in a renaming export and indicates a value should be the default for the module. Because <code>default</code> is a keyword in JavaScript, it can't be used for a variable, function, or class name (it can be used as a property name). So the use of <code>default</code> to rename an export is a special case to create a consistency with how non-default exports are defined. This syntax is useful if you want to use a single <code>export</code> statement to specify multiple exports, including the default, at once.</p>

<h4 id="leanpub-auto-importing-default-values">Importing Default Values</h4>

<p>You can import a default value from a module using the following syntax:</p>

<figure class="code">
<pre><code>// import the default
import sum from "./example.js";

console.log(sum(1, 2));     // 3
</code></pre>

</figure>

<p>This import statement imports the default from the module <code>example.js</code>. Note that no curly braces are used, unlike you'd see in a non-default import. The local name <code>sum</code> is used to represent whatever default function the module exports. This syntax is the cleanest, and the creators of ECMAScript 6 expect it to be the dominant form of import on the Web, allowing you to use an already-existing object.</p>

<p>For modules that export both a default and one or more non-default bindings, you can import all exported bindings with one statement. For instance, suppose you have this module:</p>

<figure class="code">
<pre><code>export let color = "red";

export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>

</figure>

<p>You can import both <code>color</code> and the default function using the following <code>import</code> statement:</p>

<figure class="code">
<pre><code>import sum, { color } from "./example.js";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
</code></pre>

</figure>

<p>The comma separates the default local name from the non-defaults, which are also surrounded by curly braces. Keep in mind that the default must come before the non-defaults in the <code>import</code> statement.</p>

<p>As with exporting defaults, you can import defauts with the renaming syntax, too:</p>

<figure class="code">
<pre><code>// equivalent to previous example
import { default as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
</code></pre>

</figure>

<p>In this code, the default export (<code>default</code>) is renamed to <code>sum</code> and the additional <code>color</code> export is also imported. This example is equivalent to the preceding example.</p>

<h3 id="leanpub-auto-re-exporting-a-binding">Re-exporting a Binding</h3>

<p>There may be a time when you'd like to re-export something that your module has imported (for instance, if you're creating a library out of several small modules). You can re-export an imported value with the patterns already discussed in this chapter as follows:</p>

<figure class="code">
<pre><code>import { sum } from "./example.js";
export { sum }
</code></pre>

</figure>

<p>That works, but a single statement can also do the same thing:</p>

<figure class="code">
<pre><code>export { sum } from "./example.js";
</code></pre>

</figure>

<p>This form of <code>export</code> looks into the specified module for the declaration of <code>sum</code> and then exports it. Of course, you can also choose to export a different name for the same value:</p>

<figure class="code">
<pre><code>export { sum as add } from "./example.js";
</code></pre>

</figure>

<p>Here, <code>sum</code> is imported from <code>"./example.js"</code> and then exported as <code>add</code>.</p>

<p>If you'd like to export everything from another module, you can use the <code>*</code> pattern:</p>

<figure class="code">
<pre><code>export * from "./example.js";
</code></pre>

</figure>

<p>By exporting everything, you're including the default as well as any named exports, which may affect what you can export from your module. For instance, if <code>example.js</code> has a default export, you'd be unable to define a new default export when using this syntax.</p>

<h3 id="leanpub-auto-importing-without-bindings">Importing Without Bindings</h3>

<p>Some modules may not export anything, and instead, only make modifications to objects in the global scope. Even though top-level variables, functions, and classes inside modules don't automatically end up in the global scope, that doesn't mean modules cannot access the global scope. The shared definitions of built-in objects such as <code>Array</code> and <code>Object</code> are accessible inside a module and changes to those objects will be reflected in other modules.</p>

<p>For instance, if you want to add a <code>pushAll()</code> method to all arrays, you might define a module like this:</p>

<figure class="code">
<pre><code>// module code without exports or imports
Array.prototype.pushAll = function(items) {

    // items must be an array
    if (!Array.isArray(items)) {
        throw new TypeError("Argument must be an array.");
    }

    // use built-in push() and spread operator
    return this.push(...items);
};
</code></pre>

</figure>

<p>This is a valid module even though there are no exports or imports. This code can be used both as a module and a script. Since it doesn't export anything, you can use a simplified import to execute the module code without importing any bindings:</p>

<figure class="code">
<pre><code>import "./example.js";

let colors = ["red", "green", "blue"];
let items = [];

items.pushAll(colors);
</code></pre>

</figure>

<p>This code imports and executes the module containing the <code>pushAll()</code> method, so <code>pushAll()</code> is added to the array prototype. That means <code>pushAll()</code> is now available for use on all arrays inside of this module.</p>

<aside class="information blurb">
    <p>Imports without bindings are most likely to be used to create polyfills and shims.</p>

</aside>

<h3 id="leanpub-auto-loading-modules">Loading Modules</h3>

<p>While ECMAScript 6 defines the syntax for modules, it doesn't define how to load them. This is part of the complexity of a specification that's supposed to be agnostic to implementation environments. Rather than trying to create a single specification that would work for all JavaScript environments, ECMAScript 6 specifies only the syntax and abstracts out the loading mechanism to an undefined internal operation called <code>HostResolveImportedModule</code>. Web browsers and Node.js are left to decide how to implement <code>HostResolveImportedModule</code> in a way that makes sense for their respective environments.</p>

<h4 id="leanpub-auto-using-modules-in-web-browsers">Using Modules in Web Browsers</h4>

<p>Even before ECMAScript 6, web browsers had multiple ways of including JavaScript in an web application. Those script loading options are:</p>

<ol class="numeric">
  <li>Loading JavaScript code files using the <code>&lt;script&gt;</code> element with the <code>src</code> attribute specifying a location from which to load the code.</li>
  <li>Embedding JavaScript code inline using the <code>&lt;script&gt;</code> element without the <code>src</code> attribute.</li>
  <li>Loading JavaScript code files to execute as workers (such as a web worker or service worker).</li>
</ol>

<p>In order to fully support modules, web browsers had to update each of these mechanisms. These details are defined in the HTML specification, and I'll summarize them in this section.</p>

<h5 id="leanpub-auto-using-modules-with-script">Using Modules With <code>&lt;script&gt;</code>
</h5>

<p>The default behavior of the <code>&lt;script&gt;</code> element is to load JavaScript files as scripts (not modules). This happens when the <code>type</code> attribute is missing or when the <code>type</code> attribute contains a JavaScript content type (such as <code>"text/javascript"</code>). The <code>&lt;script&gt;</code> element can then execute inline code or load the file specified in <code>src</code>. To support modules, the <code>"module"</code> value was added as a <code>type</code> option. Setting <code>type</code> to <code>"module"</code> tells the browser to load any inline code or code contained in the file specified by <code>src</code> as a module instead of a script. Here's a simple example:</p>

<figure class="code">
<pre><code>&lt;!-- load a module JavaScript file --&gt;
&lt;script type="module" src="module.js"&gt;&lt;/script&gt;

&lt;!-- include a module inline --&gt;
&lt;script type="module"&gt;

import { sum } from "./example.js";

let result = sum(1, 2);

&lt;/script&gt;
</code></pre>

</figure>

<p>The first <code>&lt;script&gt;</code> element in this example loads an external module file using the <code>src</code> attribute. The only difference from loading a script is that <code>"module"</code> is given as the <code>type</code>. The second <code>&lt;script&gt;</code> element contains a module that is embedded directly in the web page. The variable <code>result</code> is not exposed globally because it exists only within the module (as defined by the <code>&lt;script&gt;</code> element) and is therefore not added to <code>window</code> as a property.</p>

<p>As you can see, including modules in web pages is fairly simple and similar to including scripts. However, there are some differences in how modules are loaded.</p>

<aside class="information blurb">
    <p>You may have noticed that <code>"module"</code> is not a content type like the <code>"text/javascript"</code> type. Module JavaScript files are served with the same content type as script JavaScript files, so it's not possible to differentiate solely based on content type. Also, browsers ignore <code>&lt;script&gt;</code> elements when the <code>type</code> is unrecognized, so browsers that don't support modules will automatically ignore the <code>&lt;script type="module"&gt;</code> line, providing good backwards-compatibility.</p>

</aside>

<h5 id="leanpub-auto-module-loading-sequence-in-web-browsers">Module Loading Sequence in Web Browsers</h5>

<p>Modules are unique in that, unlike scripts, they may use <code>import</code> to specify that other files must be loaded to execute correctly. To support that functionality, <code>&lt;script type="module"&gt;</code> always acts as if the <code>defer</code> attribute is applied.</p>

<p>The <code>defer</code> attribute is optional for loading script files but is always applied for loading module files. The module file begins downloading as soon as the HTML parser encounters <code>&lt;script type="module"&gt;</code> with a <code>src</code> attribute but doesn't execute until after the document has been completely parsed. Modules are also executed in the order in which they appear in the HTML file. That means the first <code>&lt;script type="module"&gt;</code> is always guaranteed to execute before the second, even if one module contains inline code instead of specifying <code>src</code>. For example:</p>

<figure class="code">
<pre><code>&lt;!-- this will execute first --&gt;
&lt;script type="module" src="module1.js"&gt;&lt;/script&gt;

&lt;!-- this will execute second --&gt;
&lt;script type="module"&gt;
import { sum } from "./example.js";

let result = sum(1, 2);
&lt;/script&gt;

&lt;!-- this will execute third --&gt;
&lt;script type="module" src="module2.js"&gt;&lt;/script&gt;
</code></pre>

</figure>

<p>These three <code>&lt;script&gt;</code> elements execute in the order they are specified, so <code>module1.js</code> is guaranteed to execute before the inline module, and the inline module is guaranteed to execute before <code>module2.js</code>.</p>

<p>Each module may <code>import</code> from one or more other modules, which complicates matters. That's why modules are parsed completely first to identify all <code>import</code> statements. Each <code>import</code> statement then triggers a fetch (either from the network or from the cache), and no module is executed until all <code>import</code> resources have first been loaded and executed.</p>

<p>All modules, both those explicitly included using <code>&lt;script type="module"&gt;</code> and those implicitly included using <code>import</code>, are loaded and executed in order. In the preceding example, the complete loading sequence is:</p>

<ol class="numeric">
  <li>Download and parse <code>module1.js</code>.</li>
  <li>Recursively download and parse <code>import</code> resources in <code>module1.js</code>.</li>
  <li>Parse the inline module.</li>
  <li>Recursively download and parse <code>import</code> resources in the inline module.</li>
  <li>Download and parse <code>module2.js</code>.</li>
  <li>Recursively download and parse <code>import</code> resources in <code>module2.js</code>
</li>
</ol>

<p>Once loading is complete, nothing is executed until after the document has been completely parsed. After document parsing completes, the following actions happen:</p>

<ol class="numeric">
  <li>Recursively execute <code>import</code> resources for <code>module1.js</code>.</li>
  <li>Execute <code>module1.js</code>.</li>
  <li>Recursively execute <code>import</code> resources for the inline module.</li>
  <li>Execute the inline module.</li>
  <li>Recursively execute <code>import</code> resources for <code>module2.js</code>.</li>
  <li>Execute <code>module2.js</code>.</li>
</ol>

<p>Notice that the inline module acts like the other two modules except that the code doesn't have to be downloaded first. Otherwise, the sequence of loading <code>import</code> resources and executing modules is exactly the same.</p>

<aside class="information blurb">
    <p>The <code>defer</code> attribute is ignored on <code>&lt;script type="module"&gt;</code> because it already behaves as if <code>defer</code> is applied.</p>

</aside>

<h5 id="leanpub-auto-asynchronous-module-loading-in-web-browsers">Asynchronous Module Loading in Web Browsers</h5>

<p>You may already be familiar with the <code>async</code> attribute on the <code>&lt;script&gt;</code> element. When used with scripts, <code>async</code> causes the script file to be executed as soon as the file is completely downloaded and parsed. The order of <code>async</code> scripts in the document doesn't affect the order in which the scripts are executed, though. The scripts are always executed as soon as they finish downloading without waiting for the containing document to finish parsing.</p>

<p>The <code>async</code> attribute can be applied to modules as well. Using <code>async</code> on <code>&lt;script type="module"&gt;</code> causes the module to execute in a manner similar to a script. The only difference is that all <code>import</code> resources for the module are downloaded before the module itself is executed. That guarantees all resources the module needs to function will be downloaded before the module executes; you just can't guarantee <em>when</em> the module will execute. Consider the following code:</p>

<figure class="code">
<pre><code>&lt;!-- no guarantee which one of these will execute first --&gt;
&lt;script type="module" async src="module1.js"&gt;&lt;/script&gt;
&lt;script type="module" async src="module2.js"&gt;&lt;/script&gt;
</code></pre>

</figure>

<p>In this example, there are two module files loaded asynchronously. It's not possible to tell which module will execute first simply by looking at this code. If <code>module1.js</code> finishes downloading first (including all of its <code>import</code> resources), then it will execute first. If <code>module2.js</code> finishes downloading first, then that module will execute first instead.</p>

<h5 id="leanpub-auto-loading-modules-as-workers">Loading Modules as Workers</h5>

<p>Workers, such as web workers and service workers, execute JavaScript code outside of the web page context. Creating a new worker involves creating a new instance <code>Worker</code> (or another class) and passing in the location of JavaScript file. The default loading mechanism is to load files as scripts, like this:</p>

<figure class="code">
<pre><code>// load script.js as a script
let worker = new Worker("script.js");
</code></pre>

</figure>

<p>To support loading modules, the developers of the HTML standard added a second argument to these constructors. The second argument is an object with a <code>type</code> property with a default value of <code>"script"</code>. You can set <code>type</code> to <code>"module"</code> in order to load module files:</p>

<figure class="code">
<pre><code>// load module.js as a module
let worker = new Worker("module.js", { type: "module" });
</code></pre>

</figure>

<p>This example loads <code>module.js</code> as a module instead of a script by passing a second argument with <code>"module"</code> as the <code>type</code> property's value. (The <code>type</code> property is meant to mimic how the <code>type</code> attribute of <code>&lt;script&gt;</code> differentiates modules and scripts.) The second argument is supported for all worker types in the browser.</p>

<p>Worker modules are generally the same as worker scripts, but there are a couple of exceptions. First, worker scripts are limited to being loaded from the same origin as the web page in which they are referenced, but worker modules aren't quite as limited. Although worker modules have the same default restriction, they can also load files that have appropriate Cross-Origin Resource Sharing (CORS) headers to allow access. Second, while a worker script can use the <code>self.importScripts()</code> method to load additional scripts into the worker, <code>self.importScripts()</code> always fails on worker modules because you should use <code>import</code> instead.</p>

<h4 id="leanpub-auto-browser-module-specifier-resolution">Browser Module Specifier Resolution</h4>

<p>All of the examples to this point in the chapter have used a relative module specifier path such as <code>"./example.js"</code>. Browsers require module specifiers to be in one of the following formats:</p>

<ul>
  <li>Begin with <code>/</code> to resolve from the root directory</li>
  <li>Begin with <code>./</code> to resolve from the current directory</li>
  <li>Begin with <code>../</code> to resolve from the parent directory</li>
  <li>URL format</li>
</ul>

<p>For example, suppose you have a module file located at <code>https://www.example.com/modules/module.js</code> that contains the following code:</p>

<figure class="code">
<pre><code>// imports from https://www.example.com/modules/example1.js
import { first } from "./example1.js";

// imports from https://www.example.com/example2.js
import { second } from "../example2.js";

// imports from https://www.example.com/example3.js
import { third } from "/example3.js";

// imports from https://www2.example.com/example4.js
import { fourth } from "https://www2.example.com/example4.js";
</code></pre>

</figure>

<p>Each of the module specifiers in this example is valid for use in a browser, including the complete URL in the final line (you'd need to be sure <code>ww2.example.com</code> has properly configured its Cross-Origin Resource Sharing (CORS) headers to allow cross-domain loading). These are the only module specifier formats that browsers can resolve by default (though the not-yet-complete module loader specification will provide ways to resolve other formats). That means some normal looking module specifiers are actually invalid in browsers and will result in an error, such as:</p>

<figure class="code">
<pre><code>// invalid - doesn't begin with /, ./, or ../
import { first } from "example.js";

// invalid - doesn't begin with /, ./, or ../
import { second } from "example/index.js";
</code></pre>

</figure>

<p>Each of these module specifiers cannot be loaded by the browser. The two module specifiers are in an invalid format (missing the correct beginning characters) even though both will work when used as the value of <code>src</code> in a <code>&lt;script&gt;</code> tag. This is an intentional difference in behavior between <code>&lt;script&gt;</code> and <code>import</code>.</p>

<h3 id="leanpub-auto-summary-12">Summary</h3>

<p>ECMAScript 6 adds modules to the language as a way to package up and encapsulate functionality. Modules behave differently than scripts, as they don't modify the global scope with their top-level variables, functions, and classes, and <code>this</code> is <code>undefined</code>. To achieve that behavior, modules are loaded using a different mode.</p>

<p>You must export any functionality you'd like to make available to consumers of a module. Variables, functions, and classes can all be exported, and there is also one default export allowed per module. After exporting, another module can import all or some of the exported names. These names act as if defined by <code>let</code> and operate as block bindings that can't be redeclared in the same module.</p>

<p>Modules need not export anything if they are manipulating something in the global scope. You can actually import from such a module without introducing any bindings into the module scope.</p>

<p>Because modules must run in a different mode, browsers introduced <code>&lt;script type="module"&gt;</code> to signal that the source file or inline code should be executed as a module. Module files loaded with <code>&lt;script type="module"&gt;</code> are loaded as if the <code>defer</code> attribute is applied to them. Modules are also executed in the order in which they appear in the containing document once the document is fully parsed.</p>


<h2 id="leanpub-auto-appendix-a-smaller-changes">Appendix A: Smaller Changes</h2>

<p>Along with the major changes this book has already covered, ECMAScript 6 made several other changes that are smaller but still helpful in improving JavaScript. Those changes include making integers easier to use, adding new methods for calculations, a tweak to Unicode identifiers, and formalizing the<code>__proto__</code> property. I describe all of those in this appendix.</p>

<h3 id="leanpub-auto-working-with-integers">Working with Integers</h3>

<p>JavaScript uses the IEEE 754 encoding system to represent both integers and floats, which has caused a lot of confusion over the years. The language takes great pains to ensure that developers don't need to worry about the details of number encoding, but problems still leak through from time to time. ECMAScript 6 seeks to address this by making integers easier to identify and work with.</p>

<h4 id="leanpub-auto-identifying-integers">Identifying Integers</h4>

<p>First, ECMAScript 6 added the <code>Number.isInteger()</code> method, which can determine whether a value represents an integer in JavaScript. While JavaScript uses IEEE 754 to represent both types of numbers, floats and integers are stored differently. The <code>Number.isInteger()</code> method takes advantage of that, and when the method is called on a value, the JavaScript engine looks at the underlying representation of the value to determine whether that value is an integer. That means numbers that look like floats might actually be stored as integers and cause <code>Number.isInteger()</code> to return <code>true</code>. For example:</p>

<figure class="code">
<pre><code>console.log(Number.isInteger(25));      // true
console.log(Number.isInteger(25.0));    // true
console.log(Number.isInteger(25.1));    // false
</code></pre>

</figure>

<p>In this code, <code>Number.isInteger()</code> returns <code>true</code> for both <code>25</code> and <code>25.0</code> even though the latter looks like a float. Simply adding a decimal point to a number doesn't automatically make it a float in JavaScript. Since <code>25.0</code> is really just <code>25</code>, it is stored as an integer. The number <code>25.1</code>, however, is stored as a float because there is a fraction value.</p>

<h4 id="leanpub-auto-safe-integers">Safe Integers</h4>

<p>IEEE 754 can only accurately represent integers between -2<sup>53</sup> and 2<sup>53</sup>, and outside this "safe" range, binary representations end up reused for multiple numeric values. That means JavaScript can only safely represent integers within the IEEE 754 range before problems become apparent. For instance, consider this code:</p>

<figure class="code">
<pre><code>console.log(Math.pow(2, 53));      // 9007199254740992
console.log(Math.pow(2, 53) + 1);  // 9007199254740992
</code></pre>

</figure>

<p>This example doesn't contain a typo, yet two different numbers are represented by the same JavaScript integer. The effect becomes more prevalent the further the value falls outside the safe range.</p>

<p>ECMAScript 6 introduced the <code>Number.isSafeInteger()</code> method to better identify integers that the language can accurately represent. It also added the <code>Number.MAX_SAFE_INTEGER</code> and <code>Number.MIN_SAFE_INTEGER</code> properties to represent the upper and lower bounds of the integer range, respectively. The <code>Number.isSafeInteger()</code> method ensures that a value is an integer and falls within the safe range of integer values, as in this example:</p>

<figure class="code">
<pre><code>var inside = Number.MAX_SAFE_INTEGER,
    outside = inside + 1;

console.log(Number.isInteger(inside));          // true
console.log(Number.isSafeInteger(inside));      // true

console.log(Number.isInteger(outside));         // true
console.log(Number.isSafeInteger(outside));     // false
</code></pre>

</figure>

<p>The number <code>inside</code> is the largest safe integer, so it returns <code>true</code> for both the <code>Number.isInteger()</code> and <code>Number.isSafeInteger()</code> methods. The number <code>outside</code> is the first questionable integer value, and it isn't considered safe even though it's still an integer.</p>

<p>Most of the time, you only want to deal with safe integers when doing integer arithmetic or comparisons in JavaScript, so using <code>Number.isSafeInteger()</code> as part of input validation is a good idea.</p>

<h3 id="leanpub-auto-new-math-methods">New Math Methods</h3>

<p>The new emphasis on gaming and graphics that led ECMAScript 6 to include typed arrays in JavaScript also led to the realization that a JavaScript engine could do many mathematical calculations more efficiently. But optimization strategies like asm.js, which works on a subset of JavaScript to improve performance, need more information to perform calculations in the fastest way possible. For instance, knowing whether the numbers should be treated as 32-bit integers or as 64-bit floats is important for hardware-based operations, which are much faster than software-based operations.</p>

<p>As a result, ECMAScript 6 added several methods to the <code>Math</code> object to improve the speed of common mathematical calculations. Improving the speed of common calculations also improves the overall speed of applications that perform many calculations, such as graphics programs. The new methods are listed below:</p>

<ul>
  <li>
<code>Math.acosh(x)</code> Returns the inverse hyperbolic cosine of <code>x</code>.</li>
  <li>
<code>Math.asinh(x)</code> Returns the inverse hyperbolic sine of <code>x</code>.</li>
  <li>
<code>Math.atanh(x)</code> Returns the inverse hyperbolic tangent of <code>x</code>
</li>
  <li>
<code>Math.cbrt(x)</code> Returns the cubed root of <code>x</code>.</li>
  <li>
<code>Math.clz32(x)</code> Returns the number of leading zero bits in the 32-bit integer representation of <code>x</code>.</li>
  <li>
<code>Math.cosh(x)</code> Returns the hyperbolic cosine of <code>x</code>.</li>
  <li>
<code>Math.expm1(x)</code> Returns the result of subtracting 1 from the exponential function of <code>x</code>
</li>
  <li>
<code>Math.fround(x)</code> Returns the nearest single-precision float of <code>x</code>.</li>
  <li>
<code>Math.hypot(...values)</code> Returns the square root of the sum of the squares of each argument.</li>
  <li>
<code>Math.imul(x, y)</code> Returns the result of performing true 32-bit multiplication of the two arguments.</li>
  <li>
<code>Math.log1p(x)</code> Returns the natural logarithm of <code>1 + x</code>.</li>
  <li>
<code>Math.log10(x)</code> Returns the base 10 logarithm of <code>x</code>.</li>
  <li>
<code>Math.log2(x)</code> Returns the base 2 logarithm of <code>x</code>.</li>
  <li>
<code>Math.sign(x)</code> Returns -1 if the <code>x</code> is negative, 0 if <code>x</code> is +0 or -0, or 1 if <code>x</code> is positive.</li>
  <li>
<code>Math.sinh(x)</code> Returns the hyperbolic sine of <code>x</code>.</li>
  <li>
<code>Math.tanh(x)</code> Returns the hyperbolic tangent of <code>x</code>.</li>
  <li>
<code>Math.trunc(x)</code> Removes fraction digits from a float and returns an integer.</li>
</ul>

<p>It's beyond the scope of this book to explain each new method and what it does in detail. But if your application needs to do a reasonably common calculation, be sure to check the new <code>Math</code> methods before implementing it yourself.</p>

<h3 id="leanpub-auto-unicode-identifiers">Unicode Identifiers</h3>

<p>ECMAScript 6 offers better Unicode support than previous versions of JavaScript, and it also changes what characters may be used as identifiers. In ECMAScript 5, it was already possible to use Unicode escape sequences for identifiers. For example:</p>

<figure class="code">
<pre><code>// Valid in ECMAScript 5 and 6
var \u0061 = "abc";

console.log(\u0061);     // "abc"

// equivalent to:
console.log(a);          // "abc"
</code></pre>

</figure>

<p>After the <code>var</code> statement in this example, you can use either <code>\u0061</code> or <code>a</code> to access the variable. In ECMAScript 6, you can also use Unicode code point escape sequences as identifiers, like this:</p>

<figure class="code">
<pre><code>// Valid in ECMAScript 5 and 6
var \u{61} = "abc";

console.log(\u{61});      // "abc"

// equivalent to:
 console.log(a);          // "abc"
</code></pre>

</figure>

<p>This example just replaces <code>\u0061</code> with its code point equivalent. Otherwise, it does exactly the same thing as the previous example.</p>

<p>Additionally, ECMAScript 6 formally specifies valid identifiers in terms of <a href="http://unicode.org/reports/tr31/">Unicode Standard Annex #31: Unicode Identifier and Pattern Syntax</a>, which gives the following rules:</p>

<ol class="numeric">
  <li>The first character must be <code>$</code>, <code>_</code>, or any Unicode symbol with a derived core property of <code>ID_Start</code>.</li>
  <li>Each subsequent character must be <code>$</code>, <code>_</code>, <code>\u200c</code> (a zero-width non-joiner), <code>\u200d</code> (a zero-width joiner), or any Unicode symbol with a derived core property of <code>ID_Continue</code>.</li>
</ol>

<p>The <code>ID_Start</code> and <code>ID_Continue</code> derived core properties are defined in Unicode Identifier and Pattern Syntax as a way to identify symbols that are appropriate for use in identifiers such as variables and domain names. The specification is not specific to JavaScript.</p>

<h3 id="leanpub-auto-formalizing-the-proto-property">Formalizing the <code>__proto__</code> Property</h3>

<p>Even before ECMAScript 5 was finished, several JavaScript engines already implemented a custom property called <code>__proto__</code> that could be used to both get and set the <code>[[Prototype]]</code> property. Effectively, <code>__proto__</code> was an early precursor to both the <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> methods. Expecting all JavaScript engines to remove this property is unrealistic (there were popular JavaScript libraries making use of <code>__proto__</code>), so ECMAScript 6 also formalized the <code>__proto__</code> behavior. But the formalization appears in Appendix B of ECMA-262 along with this warning:</p>

<blockquote>
  <p>These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the
implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter.</p>
</blockquote>

<p>The ECMAScript specification recommends using <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> instead because <code>__proto__</code> has the following characteristics:</p>

<ol class="numeric">
  <li>You can only specify <code>__proto__</code> once in an object literal. If you specify two <code>__proto__</code> properties, then an error is thrown. This is the only object literal property with that restriction.</li>
  <li>The computed form <code>["__proto__"]</code> acts like a regular property and doesn't set or return the current object's prototype. All rules related to object literal properties apply in this form, as opposed to the non-computed form, which has exceptions.</li>
</ol>

<p>While you should avoid using the <code>__proto__</code> property, the way the specification defined it is interesting. In ECMAScript 6 engines, <code>Object.prototype.__proto__</code> is defined as an accessor property whose <code>get</code> method calls <code>Object.getPrototypeOf()</code> and whose <code>set</code> method calls the <code>Object.setPrototypeOf()</code> method. This leaves no real difference between using <code>__proto__</code> and <code>Object.getPrototypeOf()</code>/<code>Object.setPrototypeOf()</code>, except that <code>__proto__</code> allows you to set the prototype of an object literal directly. Here's how that works:</p>

<figure class="code">
<pre><code>let person = {
    getGreeting() {
        return "Hello";
    }
};

let dog = {
    getGreeting() {
        return "Woof";
    }
};

// prototype is person
let friend = {
    __proto__: person
};
console.log(friend.getGreeting());                      // "Hello"
console.log(Object.getPrototypeOf(friend) === person);  // true
console.log(friend.__proto__ === person);               // true

// set prototype to dog
friend.__proto__ = dog;
console.log(friend.getGreeting());                      // "Woof"
console.log(friend.__proto__ === dog);                  // true
console.log(Object.getPrototypeOf(friend) === dog);     // true
</code></pre>

</figure>

<p>Instead of calling <code>Object.create()</code> to make the <code>friend</code> object, this example creates a standard object literal that assigns a value to the <code>__proto__</code> property. When creating an object with the <code>Object.create()</code> method, on the other hand, you'd have to specify full property descriptors for any additional object properties.</p>


<h2 id="leanpub-auto-appendix-b-understanding-ecmascript-7-2016">Appendix B: Understanding ECMAScript 7 (2016)</h2>

<p>The development of ECMAScript 6 took about four years, and after that, TC-39 decided that such a long development process was unsustainable. Instead, they moved to a yearly release cycle to ensure new language features would make it into development sooner.</p>

<p>More frequent releases mean that each new edition of ECMAScript should have fewer new features than ECMAScript 6. To signify this change, new versions of the specification no longer prominently feature the edition number, and instead refer to the year in which the specification was published. As a result, ECMAScript 6 is also known as ECMAScript 2015, and ECMAScript 7 is formally known as ECMAScript 2016. TC-39 expects to use the year-based naming system for all future ECMAScript editions.</p>

<p>ECMAScript 2016 was finalized in March 2016 and contained only three additions to the language: a new mathematical operator, a new array method, and a new syntax error. Both are covered in this appendix.</p>

<h3 id="leanpub-auto-the-exponentiation-operator">The Exponentiation Operator</h3>

<p>The only change to JavaScript syntax introduced in ECMAScript 2016 is the <em>exponentiation operator</em>, which is a mathematical operation that applies an exponent to a base. JavaScript already had the <code>Math.pow()</code> method to perform exponentiation, but JavaScript was also one of the only languages that required a method rather than a formal operator. (And some developers argue an operator is easier to read and reason about.)</p>

<p>The exponentiation operator is two asterisks (<code>**</code>) where the left operand is the base and the right operand is the exponent. For example:</p>

<figure class="code">
<pre><code>let result = 5 ** 2;

console.log(result);                        // 25
console.log(result === Math.pow(5, 2));     // true
</code></pre>

</figure>

<p>This example calculates 5<sup>2</sup>, which is equal to 25. You can still use <code>Math.pow()</code> to achieve the same result.</p>

<h4 id="leanpub-auto-order-of-operations">Order of Operations</h4>

<p>The exponentiation operator has the highest precedence of all binary operators in JavaScript (unary operators have higher precedence than <code>**</code>). That means it is applied first to any compound operation, as in this example:</p>

<figure class="code">
<pre><code>let result = 2 * 5 ** 2;
console.log(result);        // 50
</code></pre>

</figure>

<p>The calculation of 5<sup>2</sup> happens first. The resulting value is then multiplied by 2 for a final result of 50.</p>

<h4 id="leanpub-auto-operand-restriction">Operand Restriction</h4>

<p>The exponentiation operator does have a somewhat unusual restriction that isn't present for other operators. The left side of an exponentiation operation cannot be a unary expression other than <code>++</code> or <code>--</code>. For example, this is invalid syntax:</p>

<figure class="code">
<pre><code>// syntax error
let result = -5 ** 2;
</code></pre>

</figure>

<p>The <code>-5</code> in this example is a syntax error because the order of operations is ambiguous. Does the <code>-</code> apply just to <code>5</code> or the result of the <code>5 ** 2</code> expression? Disallowing unary expressions on the left side of the exponentiation operator eliminates that ambiguity. In order to clearly specify intent, you need to include parentheses either around <code>-5</code> or around <code>5 ** 2</code> as follows:</p>

<figure class="code">
<pre><code>// ok
let result1 = -(5 ** 2);    // equal to -25

// also ok
let result2 = (-5) ** 2;    // equal to 25
</code></pre>

</figure>
<p>If you put the parentheses around the expression, the <code>-</code> is applied to the whole thing. When the parentheses surround <code>-5</code>, it's clear that you want to raise -5 to the second power.</p>

<p>You don't need parentheses to use <code>++</code> and <code>--</code> on the left side of the exponentiation operator because both operators have clearly-defined behavior on their operands. A prefix <code>++</code> or <code>--</code> changes the operand before any other operations take place, and the postfix versions don't apply any changes until after the entire expression has been evaluated. Both use cases are safe on the left side of this operator, as this code demonstrates:</p>

<figure class="code">
<pre><code>let num1 = 2,
    num2 = 2;

console.log(++num1 ** 2);       // 9
console.log(num1);              // 3

console.log(num2-- ** 2);       // 4
console.log(num2);              // 1
</code></pre>

</figure>

<p>In this example, <code>num1</code> is incremented before the exponentiation operator is applied, so <code>num1</code> becomes 3 and the result of the operation is 9. For <code>num2</code>, the value remains 2 for the exponentiation operation and then is decremented to 1.</p>

<h3 id="leanpub-auto-the-arrayprototypeincludes-method">The Array.prototype.includes() Method</h3>

<p>You might recall that ECMAScript 6 added <code>String.prototype.includes()</code> in order to check whether certain substrings exist within a given string. Originally, ECMAScript 6 was also going to introduce an <code>Array.prototype.includes()</code> method to continue the trend of treating strings and arrays similarly. But the specification for <code>Array.prototype.includes()</code> was incomplete by the ECMAScript 6 deadline, and so <code>Array.prototype.includes()</code> ended up in ECMAScript 2016 instead.</p>

<h4 id="leanpub-auto-how-to-use-arrayprototypeincludes">How to Use Array.prototype.includes()</h4>

<p>The <code>Array.prototype.includes()</code> method accepts two arguments: the value to search for and an optional index from which to start the search. When the second argument is provided, <code>includes()</code> starts the match from that index. (The default starting index is <code>0</code>.) The return value is <code>true</code> if the value is found inside the array and <code>false</code> if not. For example:</p>

<figure class="code">
<pre><code>let values = [1, 2, 3];

console.log(values.includes(1));        // true
console.log(values.includes(0));        // false

// start the search from index 2
console.log(values.includes(1, 2));     // false
</code></pre>

</figure>

<p>Here, calling <code>values.includes()</code> returns <code>true</code> for the value of <code>1</code> and <code>false</code> for the value of <code>0</code> because <code>0</code> isn't in the array. When the second argument is used to start the search at index 2 (which contains the value <code>3</code>), the <code>values.includes()</code> method returns <code>false</code> because the number <code>1</code> is not found between index 2 and the end of the array.</p>

<h4 id="leanpub-auto-value-comparison">Value Comparison</h4>

<p>The value comparison performed by the <code>includes()</code> method uses the <code>===</code> operator with one exception: <code>NaN</code> is considered equal to <code>NaN</code> even though <code>NaN === NaN</code> evaluates to <code>false</code>. This is different than the behavior of the <code>indexOf()</code> method, which strictly uses <code>===</code> for comparison. To see the difference, consider this code:</p>

<figure class="code">
<pre><code>let values = [1, NaN, 2];

console.log(values.indexOf(NaN));       // -1
console.log(values.includes(NaN));      // true
</code></pre>

</figure>

<p>The <code>values.indexOf()</code> method returns <code>-1</code> for <code>NaN</code> even though <code>NaN</code> is contained in the <code>values</code> array. On the other hand, <code>values.includes()</code> returns <code>true</code> for <code>NaN</code> because it uses a different value comparison operator.</p>

<aside class="warning blurb">
    <p>When you want to check just for the existence of a value in an array and don't need to know the index , I recommend using <code>includes()</code> because of the difference in how <code>NaN</code> is treated by the <code>includes()</code> and <code>indexOf()</code> methods. If you do need to know where in the array a value exists, then you have to use the <code>indexOf()</code> method.</p>

</aside>

<p>Another quirk of this implementation is that <code>+0</code> and <code>-0</code> are considered to be equal. In this case, the behavior of <code>indexOf()</code> and <code>includes()</code> is the same:</p>

<figure class="code">
<pre><code>let values = [1, +0, 2];

console.log(values.indexOf(-0));        // 1
console.log(values.includes(-0));       // true
</code></pre>

</figure>

<p>Here, both <code>indexOf()</code> and <code>includes()</code> find <code>+0</code> when <code>-0</code> is passed because the two values are considered equal. Note that this is different than the behavior of the <code>Object.is()</code> method, which considers <code>+0</code> and <code>-0</code> to be different values.</p>

<h3 id="leanpub-auto-change-to-function-scoped-strict-mode">Change to Function-Scoped Strict Mode</h3>

<p>When strict mode was introduced in ECMAScript 5, the language was quite a bit simpler than it became in ECMAScript 6. Despite that, ECMAScript 6 still allowed you to specify strict mode using the <code>"use strict"</code> directive either in the global scope (which would make all code run in strict mode) or in a function scope (so only the function would run in strict mode). The latter ended up being a problem in ECMAScript 6 due to the more complex ways that parameters could be defined, specifically, with destructuring and default parameter values. To understand the problem, consider the following code:</p>

<figure class="code">
<pre><code>function doSomething(first = this) {
    "use strict";

    return first;
}
</code></pre>

</figure>

<p>Here, the named parameter <code>first</code> is assigned a default value of <code>this</code>. What would you expect the value of <code>first</code> to be? The ECMAScript 6 specification instructed JavaScript engines to treat the parameters as being run in strict mode in this case, so <code>this</code> should be equal to <code>undefined</code>. However, implementing parameters running in strict mode when <code>"use strict"</code> is present inside the function turned out to be quite difficult because parameter default values can be functions as well. This difficulty led to most JavaScript engines not implementing this feature (so <code>this</code> would be equal to the global object).</p>

<p>As a result of the implementation difficulty, ECMAScript 2016 makes it illegal to have a <code>"use strict"</code> directive inside of a function whose parameters are either destructured or have default values. Only <em>simple parameter lists</em>, those that don't contain destructuring or default values, are allowed when <code>"use strict"</code> is present in the body of a function. Here are some examples:</p>

<figure class="code">
<pre><code>// okay - using simple parameter list
function okay(first, second) {
    "use strict";

    return first;
}

// syntax error
function notOkay1(first, second=first) {
    "use strict";

    return first;
}

// syntax error
function notOkay2({ first, second }) {
    "use strict";

    return first;
}
</code></pre>

</figure>

<p>You can still use <code>"use strict"</code> with simple parameter lists, which is why <code>okay()</code> works as you would expect (the same as it would in ECMAScript 5). The <code>notOkay1()</code> function is a syntax error because you can no longer use <code>"use strict"</code> in functions with default parameter values. Similarly, the <code>notOkay2()</code> function is a syntax error because you can't use <code>"use strict"</code> in a function with destructured parameters.</p>

<p>Overall, this change removes both a point of confusion for JavaScript developers and an implementation problem for JavaScript engines.</p>

</div>


</section>					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t02" name="t02"></a><h1>02 : Let's Learn ES2015</h1>
					<span class="ref-site">https://css-tricks.com/lets-learn-es2015/</span>
					<div class="tutorial__content">
<div class="article-content">

                
      
      <p><em class="explanation">The following is a guest post by <a href="http://ryanchristiani.com/">Ryan Christiani</a>. Ryan is a teacher at <a href="http://hackeryou.com/">HackerYou</a> and has been working on a video series called <a href="https://www.youtube.com/playlist?list=PL57atfCFqj2h5fpdZD-doGEIs0NZxeJTX">Let's Learn ES6</a>. He offered to put some of that together into a tutorial format, which I thought was perfect as we haven't covered ES2015 much here on CSS-Tricks.</em></p>
<p><span id="more-239837"></span></p>
<h3 id="article-header-id-0" class="has-header-link"><a class="article-headline-link" href="#article-header-id-0">#</a>What's in a name?</h3>
<p>As of June 2015, the largest addition to the JavaScript language was finalized. The official name is ECMAScript 2015, sometimes referred to as "ES6", or now more commonly known as "ES2105". It is the culmination of years of work and features.  </p>
<p>Moving forward, there will be ECMAScript 2016, which will likely be referred to as "ES7" or "ES2016". The plan is to have incremental yearly releases. </p>
<p>Most browsers have started to implement the ES2015 features, but support varies between them. You can see the current browser compatibility for this implementation using this <a href="https://kangax.github.io/compat-table/es6/">table</a>. </p>
<p>Tools like <a href="https://babeljs.io/">Babel</a> allow us to write new ES2015 code today and perform a task called transpiling (much like preprocessing) to convert the code into a earlier version of JavaScript that has greater browser support. This is similar to how Sass works; initially writing your code in Sass syntax, and then a preprocessor compiles to standard CSS.</p>
<h3 id="article-header-id-1" class="has-header-link"><a class="article-headline-link" href="#article-header-id-1">#</a>Overview</h3>
<p>In this article we will look at a few features that are now available to use as developers. </p>
<p>We will look at new keywords like <code>let</code> and <code>const</code>, how to create template literals to make concatenation easier, the new arrow function syntax, spread operator and rest parameters! Here's a table of contents:</p>
<ol>
<li><a href="#es2015-let-and-const"><code>let</code> and <code>const</code></a></li>
<li><a href="#es2015-template-literals">Template Literals</a></li>
<li><a href="#es2015-arrow-functions">Arrow Functions</a></li>
<li><a href="#es2015-spread-operators">Spread Operators</a></li>
<li><a href="#es2015-rest parameters">Rest Parameters</a></li>
</ol>
<p>These additions can help make writing JavaScript a real joy!</p>
<h3 id="es2015-let-and-const" class="has-header-link"><a class="article-headline-link" href="#es2015-let-and-const">#</a><code>let</code> and <code>const</code></h3>
<p><code>let</code> and <code>const</code> are two new keywords that are now available in ES2015. They are used to declare variables, however there is one key feature these variables share that sets them apart from <code>var</code>: <strong>they create block scoped variables.</strong></p>
<p>When you use the <code>var</code> keyword to create a variable it is function scoped, and it is local only to that function. This means it is available within the function it was created in and any function nested inside of that one. But it is NOT available outside of there. If you used <code>var</code> to define a variable outside of any function it would be available globally.</p>
<p>One common issue we will run into with function scoped variables is the <code>for</code> loop.</p>
<pre><code>for (var i = 0; i &lt; 10; i++) {
  console.log(i);
}
console.log(i); // Will print out 10;</code></pre>
<p>It is common to declare a variable inside of the <code>for</code> loop with the intent of it being bound to just that <code>for</code> loop however that is not that case. If you run the above code you will see the <code>i</code> variable is available outside of the for loop.</p>
<p>If you want to use <code>let</code> or <code>const</code> you will have to enable strict mode for your JavaScript file first. By adding <code>'use strict'</code> at the top of your document you enable a restricted variant of JavaScript. </p>
<pre><code>'use strict';</code></pre>
<p>Strict mode is a way to opt into a version of JavaScript that fixes some mistakes in the language, turning them into errors. It also prohibits syntax that will likely be defined in the future! For example, in strict mode, you cannot make a variable with the name of <code>let</code>. For more information on strict mode, check out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN</a> page on the topic.</p>
<p>(<strong>Editor's note</strong>: if we're using Babel then we don't have to worry about "use strict" because it will automatically add that to our code, but it's certainly worth knowing that it happens.)</p>
<p>A "block" in JavaScript is anything between <code>{ }</code>. So when we talk about block scope, that means that any variables defined in curly brackets will only exist in that block!</p>
<p><code>var</code> is function scoped, so creating a variable inside of a block with <code>var</code> will make it available outside of the block as well.</p>
<pre><code>{
  var user = "Ryan";
}
console.log(user); // Ryan</code></pre>
<p>When you define a variable with the <code>let</code> keyword it will create a new variable only within the <code>{ }</code> or block. </p>
<pre><code>{
  let user = "Ryan";
}
console.log(user); // Uncaught ReferenceError: user is not defined</code></pre>
<p>This defines and binds a variable only to the block in which it is in! If we take look at the <code>for</code> loop example again, and replace <code>var</code> with <code>let</code></p>
<pre><code>for (let i = 0; i &lt; 10; i++) {
  console.log(i);
}
console.log(i); // Uncaught ReferenceError: i is not defined </code></pre>
<p>Now it works as intended. The <code>const</code> keyword behaves the exact same way, with one exception. Once the base value is defined, it can never be redefined. It is a read-only value. </p>
<pre><code>const person = 'Ryan';
person = 'Kristen'; // Uncaught TypeError: Assignment to constant variable.
console.log(person);</code></pre>
<p>The browser will throw an error if you try to reassign a value to a variable defined with <code>const</code>. That being said, you can do something like this.</p>
<pre><code>const person = {
  name: 'Ryan'
};
person.name = 'Kristen';

console.log(person); // {name: 'Kristen'}</code></pre>
<p>Using <code>const</code> does not create an immutable value, the value stored on the person variable is still an object, however we have just changed a property inside of it. If you are looking to lock an object down, look at <code>Object.freeze()</code>.</p>
<h4 id="article-header-id-3" class="has-header-link"><a class="article-headline-link" href="#article-header-id-3">#</a>When to use <code>let</code> and when to use <code>const</code></h4>
<p>There is a bit of debate going on right now about when to use <code>let</code> vs <code>const</code>. The general rule of thumb is that if you know the value will not be redefined throughout your program, go with <code>const</code>, if you need a value that might change, go with <code>let</code>. Letting the browser know that a variable will be constant throughout the program will allow it to make certain adjustments, and this could increase performance!</p>
<h3 id="es2015-template-literals" class="has-header-link"><a class="article-headline-link" href="#es2015-template-literals">#</a>Template Literals</h3>
<p>In ES2015 there is a new way to define a string, and it comes with some added benefits. Currently if you want to define a string, you can use <code>''</code> or <code>""</code>.</p>
<pre><code>let name = "Ryan";
let job = 'Instructor';</code></pre>
<p>If you want to concatenate strings together you can use the <code>+</code> operator. </p>
<pre><code>let name = "Ryan";
let job = "Instructor";
let sentence = name + " works at HackerYou as an " + job;
console.log(sentence); // "Ryan works at HackerYou as an Instructor"</code></pre>
<p>As the amount you need to concatenate grows, this pattern gets pretty tedious and unruly. Enter template literals! </p>
<p>To create a template literal string, we use the backtick <code>`</code> in place of the quotes. </p>
<pre><code>let name = `Ryan`;
let job = `Instructor`;</code></pre>
<p>They behave exactly the same as a regular string literal, but there is one difference. With a template literal, concatenation becomes a lot easier. </p>
<pre><code>let name = `Ryan`;
let job = `Instructor`;
let sentence = `${name} works at HackerYou as an ${job}`;
console.log(sentence); // "Ryan works at HackerYou as an Instructor"</code></pre>
<p>Notice the <code>${}</code> syntax inside of the string? This is a template placeholder. It allows us to template out our strings, and the browser will replace the <code>${}</code> expression with the proper value at runtime. This makes concatenating large strings a lot more enjoyable. </p>
<p>These new placeholders also allow you to carry out expressions inside!</p>
<pre><code>const price = 9.99;
const shipping = 3.99;

const message = `Your total with shipping will be ${price + shipping}.`;

console.log(message); // Your total with shipping will be 13.98.</code></pre>
<h4 id="article-header-id-5" class="has-header-link"><a class="article-headline-link" href="#article-header-id-5">#</a>Multi line</h4>
<p>One last thing to look at with template literals is how they can handle multi line strings. With a regular string if you wanted to have it span more than one line, you would have to do something like this.</p>
<pre><code>const multi = "This is a \n multiline string";
console.log(multi);</code></pre>
<p>Including the <code>\n</code> or new line character will force text to go to a new line. If you tried to just put the text on two lines, like this:</p>
<pre><code>const multi = "This is a 
multiline string";
console.log(multi);</code></pre>
<p>It would throw an error <code>Uncaught SyntaxError: Unexpected token ILLEGAL</code>. However with template literals we CAN do just that and add line breaks wherever we'd like!</p>
<pre><code>const multi = `This is a 
multiline string`;
console.log(multi);</code></pre>
<p>This allows us to organize our markup in a way that is considerably cleaner!</p>
<pre><code>const person = {
  name: 'Ryan',
  job: 'Developer/Instructor'
};

const markup = `
  &lt;div&gt;
    &lt;h2&gt;${person.name}&lt;/h2&gt;
    &lt;h3&gt;${person.job}&lt;/h3&gt;
  &lt;/div&gt;
`;</code></pre>
<h3 id="es2015-arrow-functions" class="has-header-link"><a class="article-headline-link" href="#es2015-arrow-functions">#</a>Arrow Functions</h3>
<p>Arrow functions are a new syntax for creating functions in ES2015. This does not replace the <code>function() {}</code> syntax that we know and love, but we will be seeing it more and more as the go-to function syntax.</p>
<pre><code>const add = (a, b) =&gt; {
  return a + b;
};</code></pre>
<p>The core part of the syntax is the lack of the <code>function</code> keyword when defining a new function. Instead we have the <code>=&gt;</code> or fat arrow. You can call the function just as you would any other.</p>
<pre><code>add(2, 3); // 5</code></pre>
<p>There are actually a few ways you can define the arrow function. For example, if the function simply returns a value and there is nothing else in the function body, we can remove the <code>{}</code> and the <code>return</code> keyword.</p>
<pre><code>const add = (a, b) =&gt; a + b;</code></pre>
<p>The <code>return</code> here is implicit, meaning that it is implied as opposed to us having to explicitly add <code>return</code> to our block. If the function only had one parameter you can actually leave the <code>()</code> off the definition of the function.</p>
<pre><code>const add5 = a =&gt; a + 5;</code></pre>
<p>If there are no parameters to be used in the function, empty parenthesis are used as a placeholder.</p>
<pre><code>const eight = () =&gt; 3 + 5;</code></pre>
<p>Or there is a new pattern emerging where people will use a <code>_</code> as a placeholder in place of the empty parenthesis.</p>
<pre><code>const eight = _ =&gt; 3 + 5;</code></pre>
<h4 id="article-header-id-7" class="has-header-link"><a class="article-headline-link" href="#article-header-id-7">#</a>Arrow functions and functional programming</h4>
<p>Because the syntax for the arrow function is so small, and most operations in functional programming require very few operations in the function's body. This syntax is a perfect match for this programming style!</p>
<pre><code>// Without Arrow functions
const numbers = [3,4,5,6,7,8];
const doubleNumbers = numbers.map(function(n) {
  return n * 2;
});

// With arrow functions
const numbers = [3,4,5,6,7,8];
const doubleNumbers = numbers.map( n =&gt; n * 2 );</code></pre>
<p>The syntax allows you to make this nice and simple operation into one line!</p>
<h4 id="article-header-id-8" class="has-header-link"><a class="article-headline-link" href="#article-header-id-8">#</a>The <code>this</code> keyword</h4>
<p>One place to be cautious of when working with arrow functions is how they handle the <code>this</code> keyword. Consider a method on an object.</p>
<pre><code>const person = {
  firstName: "Ryan",
  sayName: function() {
    return this.firstName;
  }
}
console.log(person.sayName()); // "Ryan"</code></pre>
<p>Inside of the <code>sayName</code> method, the <code>this</code> keyword is bound to the <code>person</code> object. So running the method will produce <code>Ryan</code>. With an arrow function, the <code>this</code> keyword is lexically scoped. This means that the scope of the function will be bound based on where it was defined. The value of <code>this</code> then refers to the parent scope.</p>
<pre><code>const person = {
  firstName: "Ryan",
  sayName: () =&gt; {
    return this.firstName; 
  }
}
console.log(person.sayName()); // undefined</code></pre>
<p>In this example, if we changed the <code>sayName</code> method from an anonymous function to an arrow function it will return <code>undefined</code>! The <code>this</code> will be bound lexically, and in this case it will be the <code>window</code> object, on which there is no <code>firstName</code> property. There will be cases where you might want to have that be the correct result! Take a look at this example. </p>
<pre><code>const person = {
  firstName: 'Ryan',
  hobbies: ['Robots', 'Games', 'Internet'],
  showHobbies: function() {
    this.hobbies.forEach(function(hobby) {
      console.log(`${this.firstName} likes ${hobby}`);
    });
  }
};
person.showHobbies();</code></pre>
<p>Running this will produce <code>Uncaught TypeError: Cannot read property 'firstName' of undefined</code>. The <code>this</code> in the callback function for our <code>.forEach()</code> method is bound to nothing(in strict mode, in non strict it will be the <code>window</code>). But if we change the callback to an arrow function we can use the lexically bound <code>this</code> to get the value we want!</p>
<pre><code>const person = {
  firstName: 'Ryan',
  hobbies: ['Robots', 'Games', 'Internet'],
  showHobbies: function() {
    this.hobbies.forEach(hobby =&gt; {
      console.log(`${this.firstName} likes ${hobby}`);
    });
  }
};
person.showHobbies();</code></pre>
<p>The <code>this</code> inside of our <code>forEach</code> will be bound to the <code>person</code> object!</p>
<h3 id="es2015-spread-operators" class="has-header-link"><a class="article-headline-link" href="#es2015-spread-operators">#</a>Spread Operators</h3>
<p>Sometimes we want to do something with an array that we can't! For example let's assume we have an array of numbers that we want to find the max of. Math.max seems like the right method for this.</p>
<pre><code>const numbers = [39, 25, 90, 123];
const max = Math.max(numbers);
console.log(max); // NaN</code></pre>
<p><code>Math.max</code> is a method that takes a comma separated list of values and will return the highest! Sadly we can not pass an array to it. There is a way to get around this though, we can use a method called <code>.apply</code> that takes an array and calls a function as if we had passed them in as a list.</p>
<pre><code>const numbers = [39, 25, 90, 123];
const max = Math.max.apply(null, numbers);
console.log(max); // 123</code></pre>
<p>The first argument in <code>.apply</code> is the value we would like to set the <code>this</code> value for when we call <code>Math.max</code>, in this example we provide <code>null</code>. The second argument is the array we would like to apply to the function. This could be a little confusing, what if there was an easier way to do this? </p>
<h4 id="article-header-id-10" class="has-header-link"><a class="article-headline-link" href="#article-header-id-10">#</a>Enter the Spread Operator</h4>
<p>In ES2015 there is the spread operator. The syntax looks like this:</p>
<pre><code>...numbers</code></pre>
<p>What this tool does is spread out, or disperse the elements from the array! It will expand them in place. We can change the above <code>.apply</code> method call to look something like this now.</p>
<pre><code>const numbers = [39, 25, 90, 123];
const max = Math.max(...numbers);
console.log(max); // 123</code></pre>
<p>Spread will expand the array in place and pass the elements in as if it were a comma separated list.</p>
<h4 id="article-header-id-11" class="has-header-link"><a class="article-headline-link" href="#article-header-id-11">#</a>Using the spread operator to concat</h4>
<p>You can also use the spread operator to concatenate arrays together! Since spread expands arrays, we can expand arrays in arrays!</p>
<pre><code>const numbersArray1 = [3, 4, 5, 7, 8];
const numbersArray2 = [9, 6, 10, 11];
const concatArray = [...numbersArray1, ...numbersArray2];
console.log(concatArray); // [3, 4, 5, 7, 8, 9, 6, 10, 11]</code></pre>
<h3 id="es2015-rest parameters" class="has-header-link"><a class="article-headline-link" href="#es2015-rest parameters">#</a>Rest Parameters</h3>
<p>The spread operator allows us to pass an array of arguments into a function. On the flip side of that, rest parameters allows us to gather the parameters passed to our functions! Just like the spread operator the rest parameter syntax also involves the <code>...</code> at the beginning of a variable name.</p>
<p>Let's look at an example of this. Imagine we have a function that takes any number of arguments and returns the sum, <code>add(2, 3, 4, 5, 6, 7)</code> would return 27.</p>
<pre><code>const add = function() {
  const numbers = Array.prototype.slice.call(arguments);
  return numbers.reduce((a,b) =&gt; a + b);
};
add(2, 3, 4, 5, 6, 7);</code></pre>
<p>Without rest parameters, we would have to use the <code>arguments</code> keyword, and call <code>Array.prototype.slice.call(arguments)</code>. What in the world does <code>Array.prototype.slice.call(arguments)</code> mean?! <code>arguments</code> is an Array-LIKE object, meaning it is not an actual array but, is a collection of the arguments passed to a function. However, if we wanted to use an Array method like <code>.reduce()</code> on <code>arguments</code>, we would need to do some fiddling. </p>
<p>JavaScript is built up from a bunch of objects. All of these objects have a parent object that they inherit their methods and properties from. They do this via the <code>.prototype</code> property. Arrays have the <code>.slice</code> method that we can use to create an actual array from our <code>arguments</code> value. Using <code>.call</code> we can call the <code>.slice</code> method from the prototype with <code>arguments</code> as the context to create an array....whoa that is a lot. </p>
<h4 id="article-header-id-13" class="has-header-link"><a class="article-headline-link" href="#article-header-id-13">#</a>Enter rest parameters!</h4>
<pre><code>const add = function(...numbers) {
  return numbers.reduce((a, b) =&gt; a + b);
};
add(2, 3, 4, 5, 6, 7);</code></pre>
<p>WOW! That was a lot easier. Rest parameters create an actual array from the arguments passed to a function, so we can use methods like <code>.reduce</code> on it. This allows us the freedom to perform similar tasks much easier!</p>
<p>It is important to point out that you can mix and match with rest parameters and the spread operator. Consider a function that takes a multiplier as the first argument, and then will multiply any value after it by that number.</p>
<pre><code>const multi = (multiplier, ...numbers) =&gt; {
  return numbers.map(n =&gt; n * multiplier);
}</code></pre>
<p>We define the function with a parameter for the multiplier and use rest parameters to collect however many arguments get passed to this function!</p>
<h3 id="article-header-id-14" class="has-header-link"><a class="article-headline-link" href="#article-header-id-14">#</a>JavaScript moving forward</h3>
<p>There are a ton of features in ES2015 that we did not go over here, but hopefully this gives you a good basis of some useful new syntax and additions to the language! If you want to learn more, check out my video series <a href="https://www.youtube.com/watch?v=LTbnmiXWs2k&amp;list=PL57atfCFqj2h5fpdZD-doGEIs0NZxeJTX">Let's Learn ES6</a> on YouTube, as well as <a href="http://letslearnes6.com">letslearnes6.com</a> were you can find out about a book I am writing on ES6.</p>
      
    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t03" name="t03"></a><h1>03 : ES6 Symbols in Depth</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6-symbols-in-depth</span>
					<div class="tutorial__content">
<section itemprop="articleBody" class="at-corpus sp-item"><section itemprop="about" class="md-markdown at-introduction"><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank">CodePen</a> and then click on the gear icon for JavaScript – <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a href="http://babeljs.io/repl/" target="_blank">online REPL</a> <em>– it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank"><em>shamelessly ask for your support</em></a> if you're enjoying my <a href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for listening to that, and let's go into symbols now! For a bit of context, you may want to check out the last two articles, – on <a href="/articles/es6-iterators-in-depth">iterators</a> and <a href="/articles/es6-generators-in-depth">generators</a> – where we first talked about Symbols.</p></section><section class="md-markdown at-body"><h2 id="what-are-symbols"><a href="#what-are-symbols" class="md-heading">What are Symbols?</a></h2> <p>Symbols are a new primitive type in ES6. If you ask me, they're <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code class="md-code md-code-inline">Symbol</code> wrapper object.</p> <p>We can create our own Symbols.</p> <pre><code>var mystery = Symbol()
</code></pre> <p>Note that there was no <code class="md-code md-code-inline">new</code>. The <code class="md-code md-code-inline">new</code> operator even throws a <code class="md-code md-code-inline">TypeError</code> when we try it on <code class="md-code md-code-inline">Symbol</code>.</p> <pre><code>var oops = new Symbol()
// &lt;- TypeError
</code></pre> <p>For debugging purposes, you can describe symbols.</p> <pre><code>var mystery = Symbol('this is a descriptive description')
</code></pre> <p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p> <pre><code>console.log(Symbol() === Symbol())
// &lt;- false
console.log(Symbol('foo') === Symbol('foo'))
// &lt;- false
</code></pre> <p>Symbols are <em>symbols</em>.</p> <pre><code>console.log(typeof Symbol())
// &lt;- 'symbol'
console.log(typeof Symbol('foo'))
// &lt;- 'symbol'
</code></pre> <p>There are three different flavors of symbols – each flavor is accessed in a different way. We'll explore each of these and slowly figure out what all of this means.</p> <ul> <li>You can access local symbols by obtaining a reference to them <em>directly</em></li> <li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li> <li>"Well-known" symbols exist across <em>realms</em> – but you can't create them and they're not on the <em>global registry</em></li> </ul> <p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code class="md-code md-code-inline">&lt;iframe&gt;</code> within your page.</p> <h2 id="the-runtime-wide-symbol-registry"><a href="#the-runtime-wide-symbol-registry" class="md-heading">The "Runtime-Wide" Symbol Registry</a></h2> <p>There's two methods you can use to add symbols to the runtime-wide symbol registry: <code class="md-code md-code-inline">Symbol.for(key)</code> and <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code>. What do these do?</p> <h3 id="symbolfor-key"><a href="#symbolfor-key" class="md-heading"><code class="md-code md-code-inline">Symbol.for(key)</code></a></h3> <p>This method looks up <code class="md-code md-code-inline">key</code> in the runtime-wide symbol registry. If a symbol with that <code class="md-code md-code-inline">key</code> exists in the global registry, that symbol is returned. If no symbol with that <code class="md-code md-code-inline">key</code> is found in the registry, one is created. That's to say, <code class="md-code md-code-inline">Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code class="md-code md-code-inline">Symbol.for('foo')</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code class="md-code md-code-inline">key</code> is already in the registry by then – and associated to the symbol returned by the first call.</p> <pre><code>Symbol.for('foo') === Symbol.for('foo')
// &lt;- true
</code></pre> <p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code class="md-code md-code-inline">key</code>. Note that your <code class="md-code md-code-inline">key</code> will also be used as a <code class="md-code md-code-inline">description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don't just name your symbols <code class="md-code md-code-inline">'user'</code> or some generic name like that.</p> <h3 id="symbolkeyfor-symbol"><a href="#symbolkeyfor-symbol" class="md-heading"><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code></a></h3> <p>Given a symbol <code class="md-code md-code-inline">symbol</code>, <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> returns the <code class="md-code md-code-inline">key</code> that was associated with <code class="md-code md-code-inline">symbol</code> when the symbol was added to the global registry.</p> <pre><code>var symbol = Symbol.for('foo')
console.log(Symbol.keyFor(symbol))
// &lt;- 'foo'
</code></pre> <h3 id="how-wide-is-runtime-wide"><a href="#how-wide-is-runtime-wide" class="md-heading">How Wide is Runtime-Wide?</a></h3> <p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I'll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p> <pre><code>var frame = document.createElement('iframe')
document.body.appendChild(frame)
console.log(Symbol.for('foo') === frame.contentWindow.Symbol.for('foo'))
// &lt;- true
</code></pre> <h2 id="the-well-known-symbols"><a href="#the-well-known-symbols" class="md-heading">The "Well-Known" Symbols</a></h2> <p>Let me put you at ease: <strong>these aren't actually well-known at all.</strong> Far from it. I didn't have any idea these things existed until a few months ago. Why are they <em>"well-known"</em>, then? That's because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren't exposed to user code before ES6, but now you can fiddle with them.</p> <p>A great example of a <em>"well-known"</em> symbol is something we've already been playing with on Pony Foo: the <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code class="md-code md-code-inline">@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There's <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols" target="_blank" aria-label="Well-known symbols on MDN">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p> <p>One of the well-known symbols that <em>is</em> documented at this time is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match" target="_blank" aria-label="Symbol.match on MDN"><code class="md-code md-code-inline">Symbol.match</code></a>. According to MDN, you can set the <code class="md-code md-code-inline">Symbol.match</code> property on regular expressions to <code class="md-code md-code-inline">false</code> and have them behave as string literals when matching <em>(instead of regular expressions, which don't play nice with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank" aria-label="String.prototype.startsWith() – MDN"><code class="md-code md-code-inline">.startsWith</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" target="_blank" aria-label="String.prototype.endsWith() – MDN"><code class="md-code md-code-inline">.endsWith</code></a>, or <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" aria-label="String.prototype.includes() – MDN"><code class="md-code md-code-inline">.includes</code></a>)</em>.</p> <p>This part of the spec hasn't been implemented in Babel yet, <em>– I assume that's just because it's not worth the trouble –</em> but supposedly it goes like this.</p> <pre><code>var text = '/foo/'
var literal = /foo/
literal[Symbol.match] = false
console.log(text.startsWith(literal))
// &lt;- true
</code></pre> <p>Why you'd want to do that instead of just casting <code class="md-code md-code-inline">literal</code> to a string <em>is beyond me</em>.</p> <pre><code>var text = '/foo/'
var casted = /foo/.toString()
console.log(text.startsWith(casted))
// &lt;- true
</code></pre> <p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don't think it'll become a front-end development staple anytime soon.</p> <blockquote> <p>Regardless, <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> is actually very useful, and I'm sure other well-known symbols are useful as well.</p> </blockquote> <p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they're not accessible through the <em>global registry</em>.</p> <pre><code>var frame = document.createElement('iframe')
document.body.appendChild(frame)
console.log(Symbol.iterator === frame.contentWindow.Symbol.iterator)
// &lt;- true
</code></pre> <p>Not accessible through the <em>global registry</em>? Nope!</p> <pre><code>console.log(Symbol.keyFor(Symbol.iterator))
// &lt;- undefined
</code></pre> <p>Accessing them statically from anywhere should be more than enough, though.</p> <h2 id="symbols-and-iteration"><a href="#symbols-and-iteration" class="md-heading">Symbols and Iteration</a></h2> <p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p> <pre><code>var foo = {
  [Symbol()]: 'foo',
  [Symbol('foo')]: 'bar',
  [Symbol.for('bar')]: 'baz',
  what: 'ever'
}
console.log([...foo])
// &lt;- []
</code></pre> <p>The ES5 <code class="md-code md-code-inline">Object.keys</code> method ignores symbols.</p> <pre><code>console.log(Object.keys(foo))
// &lt;- ['what']
</code></pre> <p>Same goes for <code class="md-code md-code-inline">JSON.stringify</code>.</p> <pre><code>console.log(JSON.stringify(foo))
// &lt;- {"what":"ever"}
</code></pre> <p>So, <code class="md-code md-code-inline">for..in</code> then? Nope.</p> <pre><code>for (let key in foo) {
  console.log(key)
  // &lt;- 'what'
}
</code></pre> <p>I know, <code class="md-code md-code-inline">Object.getOwnPropertyNames</code>. Nah! <em>– but close.</em></p> <pre><code>console.log(Object.getOwnPropertyNames(foo))
// &lt;- ['what']
</code></pre> <p>You need to be explicitly looking for symbols to stumble upon them. They're like JavaScript neutrinos. You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" aria-label="Object.getOwnPropertySymbols() – MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> to detect them.</p> <pre><code>console.log(Object.getOwnPropertySymbols(foo))
// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')]
</code></pre> <p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code class="md-code md-code-inline">for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won't be as disappointing as the flukes in the snippet below.</p> <pre><code>for (let symbol of Object.getOwnPropertySymbols(foo)) {
  console.log(foo[symbol])
  // &lt;- 'foo'
  // &lt;- 'bar'
  // &lt;- 'baz'
}
</code></pre> <h2 id="why-would-i-want-symbols"><a href="#why-would-i-want-symbols" class="md-heading">Why Would I Want Symbols?</a></h2> <p>There's a few different uses for symbols.</p> <h3 id="name-clashes"><a href="#name-clashes" class="md-heading">Name Clashes</a></h3> <p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>"objects as hash maps"</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p> <h3 id="privacy"><a href="#privacy" class="md-heading">"Privacy"?</a></h3> <p>Symbols are <em>invisible to all "reflection" methods before ES6</em>. This can be useful in some scenarios, but they're not private by any stretch of imagination, as we've just demonstrated with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" aria-label="Object.getOwnPropertySymbols() – MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> API.</p> <p>That being said, the fact that you have to actively look for symbols to find them means they're useful in situations where you want to define metadata that shouldn't be part of iterable sequences for arrays or any <em>iterable</em> objects.</p> <h3 id="defining-protocols"><a href="#defining-protocols" class="md-heading">Defining Protocols</a></h3> <p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> – just like there's <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><code class="md-code md-code-inline">Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p> <p>Imagine for instance a library like <a href="https://github.com/bevacqua/dragula" target="_blank" aria-label="bevacqua/dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a> defining a protocol through <code class="md-code md-code-inline">Symbol.for('dragula.moves')</code>, where you could add a method on that <code class="md-code md-code-inline">Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code class="md-code md-code-inline">dragula</code> could call the <code class="md-code md-code-inline">el[Symbol.for('dragula.moves')]()</code> user-defined method to assert whether the element can be moved.</p> <p>This way, the logic about elements being draggable by <code class="md-code md-code-inline">dragula</code> is shifted from a single place for the entire <code class="md-code md-code-inline">drake</code> <em>(the <code class="md-code md-code-inline">options</code> for an instance of <code class="md-code md-code-inline">dragula</code>)</em>, to each individual DOM element. That'd make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code class="md-code md-code-inline">options.moves</code> method.</p></section></section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t04" name="t04"></a><h1>04 : ES6 Overview in 350 Bullet Points</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6</span>
					<div class="tutorial__content">
<section itemprop="articleBody" class="at-corpus sp-item"><section itemprop="about" class="md-markdown at-introduction"><p>I heard you like bullet points, so I made an article containing hundreds of those bad boys. To kick things off, here's a table of contents with all the topics covered. It has bullet points in it – <strong>obviously</strong>. Note that if you want these concepts to permeate your brain, you'll have a much better time learning the subject by going through the <a href="/articles/tagged/es6-in-depth" aria-label="ES6 in Depth on Pony Foo">in-depth series</a> and playing around, experimenting with ES6 code yourself.</p> <p><em>It's showtime!</em></p> <h1 id="table-of-contents" class=""><a href="#table-of-contents" class="md-heading">Table of Contents</a></h1> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#tooling">Tooling</a></li> <li><a href="#assignment-destructuring">Assignment Destructuring</a></li> <li><a href="#spread-operator-and-rest-parameters">Spread Operator and Rest Parameters</a></li> <li><a href="#arrow-functions">Arrow Functions</a></li> <li><a href="#template-literals">Template Literals</a></li> <li><a href="#object-literals">Object Literals</a></li> <li><a href="#classes">Classes</a></li> <li><a href="#let-and-const">Let and Const</a></li> <li><a href="#symbols">Symbols</a></li> <li><a href="#iterators">Iterators</a></li> <li><a href="#generators">Generators</a></li> <li><a href="#promises">Promises</a></li> <li><a href="#maps">Maps</a></li> <li><a href="#weakmaps">WeakMaps</a></li> <li><a href="#sets">Sets</a></li> <li><a href="#weaksets">WeakSets</a></li> <li><a href="#proxies">Proxies</a></li> <li><a href="#reflection">Reflection</a></li> <li><a href="#number"><code class="md-code md-code-inline">Number</code></a></li> <li><a href="#math"><code class="md-code md-code-inline">Math</code></a></li> <li><a href="#array"><code class="md-code md-code-inline">Array</code></a></li> <li><a href="#object"><code class="md-code md-code-inline">Object</code></a></li> <li><a href="#strings-and-unicode">Strings and Unicode</a></li> <li><a href="#modules">Modules</a></li> </ul></section><section class="md-markdown at-body"><p>Apologies about that long table of contents, and here we go.</p> <h1 id="introduction"><a href="#introduction" class="md-heading">Introduction</a></h1> <ul> <li>ES6 – also known as Harmony, <code class="md-code md-code-inline">es-next</code>, ES2015 – is the latest finalized specification of the language</li> <li>The ES6 specification was finalized in <strong>June 2015</strong>, <em>(hence ES2015)</em></li> <li>Future versions of the specification will follow the <code class="md-code md-code-inline">ES[YYYY]</code> pattern, e.g ES2016 for ES7 <ul> <li><strong>Yearly release schedule</strong>, features that don't make the cut take the next train</li> <li>Since ES6 pre-dates that decision, most of us still call it ES6</li> <li>Starting with ES2016 (ES7), we should start using the <code class="md-code md-code-inline">ES[YYYY]</code> pattern to refer to newer versions</li> <li>Top reason for naming scheme is to pressure browser vendors into quickly implementing newest features</li> </ul> </li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="tooling"><a href="#tooling" class="md-heading">Tooling</a></h1> <ul> <li>To get ES6 working today, you need a <strong>JavaScript-to-JavaScript</strong> <em>transpiler</em></li> <li>Transpilers are here to stay <ul> <li>They allow you to compile code in the latest version into older versions of the language</li> <li>As browser support gets better, we'll transpile ES2016 and ES2017 into ES6 and beyond</li> <li>We'll need better source mapping functionality</li> <li>They're the most reliable way to run ES6 source code in production today <em>(although browsers get ES5)</em></li> </ul> </li> <li>Babel <em>(a transpiler)</em> has a killer feature: <strong>human-readable output</strong></li> <li>Use <a href="http://babeljs.io/" target="_blank" aria-label="Babel JavaScript Compiler"><code class="md-code md-code-inline">babel</code></a> to transpile ES6 into ES5 for static builds</li> <li>Use <a href="https://github.com/babel/babelify" target="_blank" aria-label="babel/babelify on GitHub"><code class="md-code md-code-inline">babelify</code></a> to incorporate <code class="md-code md-code-inline">babel</code> into your <a href="/articles/gulp-grunt-whatever" aria-label="Gulp, Grunt, Whatever on Pony Foo">Gulp, Grunt, or <code class="md-code md-code-inline">npm run</code></a> build process</li> <li>Use Node.js <code class="md-code md-code-inline">v4.x.x</code> or greater as they have decent ES6 support baked in, thanks to <code class="md-code md-code-inline">v8</code></li> <li>Use <code class="md-code md-code-inline">babel-node</code> with any version of <code class="md-code md-code-inline">node</code>, as it transpiles modules into ES5</li> <li>Babel has a thriving ecosystem that already supports some of ES2016 and has plugin support</li> <li>Read <a href="/articles/a-brief-history-of-es6-tooling" aria-label="A Brief History of ES6 Tooling on Pony Foo">A Brief History of ES6 Tooling</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="assignment-destructuring" class=""><a href="#assignment-destructuring" class="md-heading">Assignment Destructuring</a></h1> <ul> <li><code class="md-code md-code-inline">var {foo} = pony</code> is equivalent to <code class="md-code md-code-inline">var foo = pony.foo</code></li> <li><code class="md-code md-code-inline">var {foo: baz} = pony</code> is equivalent to <code class="md-code md-code-inline">var baz = pony.foo</code></li> <li>You can provide default values, <code class="md-code md-code-inline">var {foo='bar'} = baz</code> yields <code class="md-code md-code-inline">foo: 'bar'</code> if <code class="md-code md-code-inline">baz.foo</code> is <code class="md-code md-code-inline">undefined</code></li> <li>You can pull as many properties as you like, aliased or not <ul> <li><code class="md-code md-code-inline">var {foo, bar: baz} = {foo: 0, bar: 1}</code> gets you <code class="md-code md-code-inline">foo: 0</code> and <code class="md-code md-code-inline">baz: 1</code></li> </ul> </li> <li>You can go deeper. <code class="md-code md-code-inline">var {foo: {bar}} = { foo: { bar: 'baz' } }</code> gets you <code class="md-code md-code-inline">bar: 'baz'</code></li> <li>You can alias that too. <code class="md-code md-code-inline">var {foo: {bar: deep}} = { foo: { bar: 'baz' } }</code> gets you <code class="md-code md-code-inline">deep: 'baz'</code></li> <li>Properties that aren't found yield <code class="md-code md-code-inline">undefined</code> as usual, e.g: <code class="md-code md-code-inline">var {foo} = {}</code></li> <li>Deeply nested properties that aren't found yield an error, e.g: <code class="md-code md-code-inline">var {foo: {bar}} = {}</code></li> <li>It also works for arrays, <code class="md-code md-code-inline">[a, b] = [0, 1]</code> yields <code class="md-code md-code-inline">a: 0</code> and <code class="md-code md-code-inline">b: 1</code></li> <li>You can skip items in an array, <code class="md-code md-code-inline">[a, , b] = [0, 1, 2]</code>, getting <code class="md-code md-code-inline">a: 0</code> and <code class="md-code md-code-inline">b: 2</code></li> <li>You can swap without an <em>"aux"</em> variable, <code class="md-code md-code-inline">[a, b] = [b, a]</code></li> <li>You can also use destructuring in function parameters <ul> <li>Assign default values like <code class="md-code md-code-inline">function foo (bar=2) {}</code></li> <li>Those defaults can be objects, too <code class="md-code md-code-inline">function foo (bar={ a: 1, b: 2 }) {}</code></li> <li>Destructure <code class="md-code md-code-inline">bar</code> completely, like <code class="md-code md-code-inline">function foo ({ a=1, b=2 }) {}</code></li> <li>Default to an empty object if nothing is provided, like <code class="md-code md-code-inline">function foo ({ a=1, b=2 } <mark class="md-mark md-code-mark">= {}</mark>) {}</code></li> </ul> </li> <li>Read <a href="/articles/es6-destructuring-in-depth" aria-label="ES6 Destructuring in Depth on Pony Foo">ES6 JavaScript Destructuring in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="spread-operator-and-rest-parameters"><a href="#spread-operator-and-rest-parameters" class="md-heading">Spread Operator and Rest Parameters</a></h1> <ul> <li>Rest parameters is a better <code class="md-code md-code-inline">arguments</code> <ul> <li>You declare it in the method signature like <code class="md-code md-code-inline">function foo (...everything) {}</code></li> <li><code class="md-code md-code-inline">everything</code> is an array with all parameters passed to <code class="md-code md-code-inline">foo</code></li> <li>You can name a few parameters before <code class="md-code md-code-inline">...everything</code>, like <code class="md-code md-code-inline">function foo (bar, ...rest) {}</code></li> <li>Named parameters are excluded from <code class="md-code md-code-inline">...rest</code></li> <li><code class="md-code md-code-inline">...rest</code> must be the last parameter in the list</li> </ul> </li> <li>Spread operator is better than magic, also denoted with <code class="md-code md-code-inline">...</code> syntax <ul> <li>Avoids <code class="md-code md-code-inline">.apply</code> when calling methods, <code class="md-code md-code-inline">fn(...[1, 2, 3])</code> is equivalent to <code class="md-code md-code-inline">fn(1, 2, 3)</code></li> <li>Easier concatenation <code class="md-code md-code-inline">[1, 2, ...[3, 4, 5], 6, 7]</code></li> <li>Casts array-likes or iterables into an array, e.g <code class="md-code md-code-inline">[...document.querySelectorAll('img')]</code></li> <li>Useful when <a href="#assignment-destructuring">destructuring</a> too, <code class="md-code md-code-inline">[a, , ...rest] = [1, 2, 3, 4, 5]</code> yields <code class="md-code md-code-inline">a: 1</code> and <code class="md-code md-code-inline">rest: [3, 4, 5]</code></li> <li>Makes <code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">.apply</code> effortless, <code class="md-code md-code-inline">new Date(...[2015, 31, 8])</code></li> </ul> </li> <li>Read <a href="/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter on Pony Foo">ES6 Spread and Butter in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="arrow-functions"><a href="#arrow-functions" class="md-heading">Arrow Functions</a></h1> <ul> <li>Terse way to declare a function like <code class="md-code md-code-inline">param =&gt; returnValue</code></li> <li>Useful when doing functional stuff like <code class="md-code md-code-inline">[1, 2].map(x =&gt; x * 2)</code></li> <li>Several flavors are available, might take you some getting used to <ul> <li><code class="md-code md-code-inline">p1 =&gt; expr</code> is okay for a single parameter</li> <li><code class="md-code md-code-inline">p1 =&gt; expr</code> has an implicit <code class="md-code md-code-inline">return</code> statement for the provided <code class="md-code md-code-inline">expr</code> expression</li> <li>To return an object implicitly, wrap it in parenthesis <code class="md-code md-code-inline">() =&gt; ({ foo: 'bar' })</code> or you'll get <strong>an error</strong></li> <li>Parenthesis are demanded when you have zero, two, or more parameters, <code class="md-code md-code-inline">() =&gt; expr</code> or <code class="md-code md-code-inline">(p1, p2) =&gt; expr</code></li> <li>Brackets in the right-hand side represent a code block that can have multiple statements, <code class="md-code md-code-inline">() =&gt; {}</code></li> <li>When using a code block, there's no implicit <code class="md-code md-code-inline">return</code>, you'll have to provide it – <code class="md-code md-code-inline">() =&gt; { return 'foo' }</code></li> </ul> </li> <li>You can't name arrow functions statically, but runtimes are now much better at inferring names for most methods</li> <li>Arrow functions are bound to their lexical scope <ul> <li><code class="md-code md-code-inline">this</code> is the same <code class="md-code md-code-inline">this</code> context as in the parent scope</li> <li><code class="md-code md-code-inline">this</code> can't be modified with <code class="md-code md-code-inline">.call</code>, <code class="md-code md-code-inline">.apply</code>, or similar <em>"reflection"-type</em> methods</li> </ul> </li> <li>Read <a href="/articles/es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions on Pony Foo">ES6 Arrow Functions in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="template-literals"><a href="#template-literals" class="md-heading">Template Literals</a></h1> <ul> <li>You can declare strings with <code class="md-code md-code-inline">`</code> (backticks), in addition to <code class="md-code md-code-inline">"</code> and <code class="md-code md-code-inline">'</code></li> <li>Strings wrapped in backticks are <em>template literals</em></li> <li>Template literals can be multiline</li> <li>Template literals allow interpolation like <code class="md-code md-code-inline">`ponyfoo.com is ${rating}`</code> where <code class="md-code md-code-inline">rating</code> is a variable</li> <li>You can use any valid JavaScript expressions in the interpolation, such as <code class="md-code md-code-inline">`${2 * 3}`</code> or <code class="md-code md-code-inline">`${foo()}`</code></li> <li>You can use tagged templates to change how expressions are interpolated <ul> <li>Add a <code class="md-code md-code-inline">fn</code> prefix to <code class="md-code md-code-inline">fn`foo, ${bar} and ${baz}`</code></li> <li><code class="md-code md-code-inline">fn</code> is called once with <code class="md-code md-code-inline">template, ...expressions</code></li> <li><code class="md-code md-code-inline">template</code> is <code class="md-code md-code-inline">['foo, ', ' and ', '']</code> and <code class="md-code md-code-inline">expressions</code> is <code class="md-code md-code-inline">[bar, baz]</code></li> <li>The result of <code class="md-code md-code-inline">fn</code> becomes the value of the template literal</li> <li>Possible use cases include input sanitization of expressions, parameter parsing, etc.</li> </ul> </li> <li>Template literals are almost strictly better than strings wrapped in single or double quotes</li> <li>Read <a href="/articles/es6-template-strings-in-depth" aria-label="ES6 Template Literals on Pony Foo">ES6 Template Literals in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="object-literals"><a href="#object-literals" class="md-heading">Object Literals</a></h1> <ul> <li>Instead of <code class="md-code md-code-inline">{ foo: foo }</code>, you can just do <code class="md-code md-code-inline">{ foo }</code> – known as a <em>property value shorthand</em></li> <li>Computed property names, <code class="md-code md-code-inline">{ <mark class="md-mark md-code-mark">[prefix + 'Foo']</mark>: 'bar' }</code>, where <code class="md-code md-code-inline">prefix: 'moz'</code>, yields <code class="md-code md-code-inline">{ mozFoo: 'bar' }</code></li> <li>You can't combine computed property names and property value shorthands, <code class="md-code md-code-inline">{ [foo] }</code> is invalid</li> <li>Method definitions in an object literal can be declared using an alternative, more terse syntax, <code class="md-code md-code-inline">{ foo () {} }</code></li> <li>See also <a href="#object"><code class="md-code md-code-inline">Object</code></a> section</li> <li>Read <a href="/articles/es6-object-literal-features-in-depth" aria-label="ES6 Object Literal Features in Depth on Pony Foo">ES6 Object Literal Features in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="classes"><a href="#classes" class="md-heading">Classes</a></h1> <ul> <li>Not <em>"traditional"</em> classes, syntax sugar on top of prototypal inheritance</li> <li>Syntax similar to declaring objects, <code class="md-code md-code-inline">class Foo {}</code></li> <li>Instance methods <em>– <code class="md-code md-code-inline">new Foo().bar</code> –</em> are declared using the short <a href="#object-literals">object literal</a> syntax, <code class="md-code md-code-inline">class Foo { bar () {} }</code></li> <li>Static methods <em>– <code class="md-code md-code-inline">Foo.isPonyFoo()</code> –</em> need a <code class="md-code md-code-inline">static</code> keyword prefix, <code class="md-code md-code-inline">class Foo { <mark class="md-mark md-code-mark">static</mark> isPonyFoo () {} }</code></li> <li>Constructor method <code class="md-code md-code-inline">class Foo { constructor () { /* initialize instance */ } }</code></li> <li>Prototypal inheritance with a simple syntax <code class="md-code md-code-inline">class PonyFoo <mark class="md-mark md-code-mark">extends</mark> Foo {}</code></li> <li>Read <a href="/articles/es6-classes-in-depth" aria-label="ES6 Classes in Depth on Pony Foo">ES6 Classes in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="let-and-const"><a href="#let-and-const" class="md-heading">Let and Const</a></h1> <ul> <li><code class="md-code md-code-inline">let</code> and <code class="md-code md-code-inline">const</code> are alternatives to <code class="md-code md-code-inline">var</code> when declaring variables</li> <li><code class="md-code md-code-inline">let</code> is block-scoped instead of lexically scoped to a <code class="md-code md-code-inline">function</code></li> <li><code class="md-code md-code-inline">let</code> is <a href="/articles/javascript-variable-hoisting" aria-label="JavaScript Variable Hoisting on Pony Foo">hoisted</a> to the top of the block, while <code class="md-code md-code-inline">var</code> declarations are hoisted to top of the function</li> <li>"Temporal Dead Zone" – TDZ for short <ul> <li>Starts at the beginning of the block where <code class="md-code md-code-inline">let foo</code> was declared</li> <li>Ends where the <code class="md-code md-code-inline">let foo</code> statement was placed in user code <em>(hoisiting is irrelevant here)</em></li> <li>Attempts to access or assign to <code class="md-code md-code-inline">foo</code> within the TDZ <em>(before the <code class="md-code md-code-inline">let foo</code> statement is reached)</em> result in an error</li> <li>Helps prevent mysterious bugs when a variable is manipulated before its declaration is reached</li> </ul> </li> <li><code class="md-code md-code-inline">const</code> is also block-scoped, hoisted, and constrained by TDZ semantics</li> <li><code class="md-code md-code-inline">const</code> variables must be declared using an initializer, <code class="md-code md-code-inline">const foo = 'bar'</code></li> <li>Assigning to <code class="md-code md-code-inline">const</code> after initialization fails silently (or <strong>loudly</strong> <em>– with an exception –</em> under strict mode)</li> <li><code class="md-code md-code-inline">const</code> variables don't make the assigned value immutable <ul> <li><code class="md-code md-code-inline">const foo = { bar: 'baz' }</code> means <code class="md-code md-code-inline">foo</code> will always reference the right-hand side object</li> <li><code class="md-code md-code-inline">const foo = { bar: 'baz' }; foo.bar = 'boo'</code> won't throw</li> </ul> </li> <li>Declaration of a variable by the same name will throw</li> <li>Meant to fix mistakes where you reassign a variable and lose a reference that was passed along somewhere else</li> <li>In ES6, <strong>functions are block scoped</strong> <ul> <li>Prevents leaking block-scoped secrets through hoisting, <code class="md-code md-code-inline">{ <mark class="md-mark md-code-mark">let</mark> _foo = 'secret', bar = <mark class="md-mark md-code-mark">() =&gt; _foo</mark>; }</code></li> <li>Doesn't break user code in most situations, and typically what you wanted anyways</li> </ul> </li> <li>Read <a href="/articles/es6-let-const-and-temporal-dead-zone-in-depth" aria-label="ES6 Let, Const, and the 'Temporal Dead Zone' (TDZ) in Depth on Pony Foo">ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="symbols"><a href="#symbols" class="md-heading">Symbols</a></h1> <ul> <li>A new primitive type in ES6</li> <li>You can create your own symbols using <code class="md-code md-code-inline">var symbol = Symbol()</code></li> <li>You can add a description for debugging purposes, like <code class="md-code md-code-inline">Symbol(<mark class="md-mark md-code-mark">'ponyfoo'</mark>)</code></li> <li>Symbols are immutable and unique. <code class="md-code md-code-inline">Symbol()</code>, <code class="md-code md-code-inline">Symbol()</code>, <code class="md-code md-code-inline">Symbol('foo')</code> and <code class="md-code md-code-inline">Symbol('foo')</code> are all different</li> <li>Symbols are of type <code class="md-code md-code-inline">symbol</code>, thus: <code class="md-code md-code-inline">typeof Symbol() === 'symbol'</code></li> <li>You can also create global symbols with <code class="md-code md-code-inline">Symbol.for(key)</code> <ul> <li>If a symbol with the provided <code class="md-code md-code-inline">key</code> already existed, you get that one back</li> <li>Otherwise, a new symbol is created, using <code class="md-code md-code-inline">key</code> as its description as well</li> <li><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> is the inverse function, taking a <code class="md-code md-code-inline">symbol</code> and returning its <code class="md-code md-code-inline">key</code></li> <li>Global symbols are <strong>as global as it gets</strong>, or <em>cross-realm</em>. Single registry used to look up these symbols across the runtime <ul> <li><code class="md-code md-code-inline">window</code> context</li> <li><code class="md-code md-code-inline">eval</code> context</li> <li><code class="md-code md-code-inline">&lt;iframe&gt;</code> context, <code class="md-code md-code-inline">Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')</code></li> </ul> </li> </ul> </li> <li>There's also "well-known" symbols <ul> <li>Not on the global registry, accessible through <code class="md-code md-code-inline">Symbol[name]</code>, e.g: <code class="md-code md-code-inline">Symbol.iterator</code></li> <li>Cross-realm, meaning <code class="md-code md-code-inline">Symbol.iterator === iframe.contentWindow.Symbol.iterator</code></li> <li>Used by specification to define protocols, such as the <a href="#iterators"><em>iterable</em> protocol</a> over <code class="md-code md-code-inline">Symbol.iterator</code></li> <li>They're not <strong>actually well-known</strong> – in colloquial terms</li> </ul> </li> <li>Iterating over symbol properties is hard, but not impossible and definitely not private <ul> <li>Symbols are hidden to all pre-ES6 "reflection" methods</li> <li>Symbols are accessible through <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></li> <li>You won't stumble upon them but you <strong>will</strong> find them if <em>actively looking</em></li> </ul> </li> <li>Read <a href="/articles/es6-symbols-in-depth" aria-label="ES6 Symbols in Depth on Pony Foo">ES6 Symbols in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="iterators"><a href="#iterators" class="md-heading">Iterators</a></h1> <ul> <li>Iterator and iterable protocol define how to iterate over any object, not just arrays and array-likes</li> <li>A well-known <code class="md-code md-code-inline">Symbol</code> is used to assign an iterator to any object</li> <li><code class="md-code md-code-inline">var foo = { [<mark class="md-mark md-code-mark">Symbol.iterator</mark>]: iterable}</code>, or <code class="md-code md-code-inline">foo[<mark class="md-mark md-code-mark">Symbol.iterator</mark>] = iterable</code></li> <li>The <code class="md-code md-code-inline">iterable</code> is a method that returns an <code class="md-code md-code-inline">iterator</code> object that has a <code class="md-code md-code-inline">next</code> method</li> <li>The <code class="md-code md-code-inline">next</code> method returns objects with two properties, <code class="md-code md-code-inline">value</code> and <code class="md-code md-code-inline">done</code> <ul> <li>The <code class="md-code md-code-inline">value</code> property indicates the current value in the sequence being iterated</li> <li>The <code class="md-code md-code-inline">done</code> property indicates whether there are any more items to iterate</li> </ul> </li> <li>Objects that have a <code class="md-code md-code-inline">[Symbol.iterator]</code> value are <em>iterable</em>, because they subscribe to the iterable protocol</li> <li>Some built-ins like <code class="md-code md-code-inline">Array</code>, <code class="md-code md-code-inline">String</code>, or <code class="md-code md-code-inline">arguments</code> – and <code class="md-code md-code-inline">NodeList</code> in browsers – are iterable by default in ES6</li> <li>Iterable objects can be looped over with <code class="md-code md-code-inline">for..of</code>, such as <code class="md-code md-code-inline">for (let el of document.querySelectorAll('a'))</code></li> <li>Iterable objects can be synthesized using the spread operator, like <code class="md-code md-code-inline">[...document.querySelectorAll('a')]</code></li> <li>You can also use <code class="md-code md-code-inline">Array.from(document.querySelectorAll('a'))</code> to synthesize an iterable sequence into an array</li> <li>Iterators are <em>lazy</em>, and those that produce an infinite sequence still can lead to valid programs</li> <li>Be careful not to attempt to synthesize an infinite sequence with <code class="md-code md-code-inline">...</code> or <code class="md-code md-code-inline">Array.from</code> as that <strong>will</strong> cause an infinite loop</li> <li>Read <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo">ES6 Iterators in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="generators"><a href="#generators" class="md-heading">Generators</a></h1> <ul> <li>Generator functions are a special kind of <em>iterator</em> that can be declared using the <code class="md-code md-code-inline"><mark class="md-mark md-code-mark">function*</mark> generator () {}</code> syntax</li> <li>Generator functions use <code class="md-code md-code-inline">yield</code> to emit an element sequence</li> <li>Generator functions can also use <code class="md-code md-code-inline">yield*</code> to delegate to another generator function <em>– or any iterable object</em></li> <li>Generator functions return a generator object that's adheres to both the <em>iterable</em> and <em>iterator</em> protocols <ul> <li>Given <code class="md-code md-code-inline">g = generator()</code>, <code class="md-code md-code-inline">g</code> adheres to the iterable protocol because <code class="md-code md-code-inline">g[Symbol.iterator]</code> is a method</li> <li>Given <code class="md-code md-code-inline">g = generator()</code>, <code class="md-code md-code-inline">g</code> adheres to the iterator protocol because <code class="md-code md-code-inline">g.next</code> is a method</li> <li>The iterator for a generator object <code class="md-code md-code-inline">g</code> is the generator itself: <code class="md-code md-code-inline">g[Symbol.iterator]() === g</code></li> </ul> </li> <li>Pull values using <code class="md-code md-code-inline">Array.from(g)</code>, <code class="md-code md-code-inline">[...g]</code>, <code class="md-code md-code-inline">for (let item of g)</code>, or just calling <code class="md-code md-code-inline">g.next()</code></li> <li>Generator function execution is suspended, remembering the last position, in four different cases <ul> <li>A <code class="md-code md-code-inline">yield</code> expression returning the next value in the sequence</li> <li>A <code class="md-code md-code-inline">return</code> statement returning the last value in the sequence</li> <li>A <code class="md-code md-code-inline">throw</code> statement halts execution in the generator entirely</li> <li>Reaching the end of the generator function signals <code class="md-code md-code-inline">{ done: true }</code></li> </ul> </li> <li>Once the <code class="md-code md-code-inline">g</code> sequence has ended, <code class="md-code md-code-inline">g.next()</code> simply returns <code class="md-code md-code-inline">{ done: true }</code> and has no effect</li> <li>It's easy to make asynchronous flows feel synchronous <ul> <li>Take user-provided generator function</li> <li>User code is suspended while asynchronous operations take place</li> <li>Call <code class="md-code md-code-inline">g.next()</code>, unsuspending execution in user code</li> </ul> </li> <li>Read <a href="/articles/es6-generators-in-depth" aria-label="ES6 Generators in Depth on Pony Foo">ES6 Generators in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="promises"><a href="#promises" class="md-heading">Promises</a></h1> <ul> <li>Follows the <a href="https://promisesaplus.com/" target="_blank" aria-label="An open standard for sound, interoperable JavaScript promises"><code class="md-code md-code-inline">Promises/A+</code></a> specification, was widely implemented in the wild before ES6 was standarized <em>(e.g <a href="https://github.com/petkaantonov/bluebird" target="_blank" aria-label="petkaantonov/bluebird on GitHub"><code class="md-code md-code-inline">bluebird</code></a>)</em></li> <li>Promises behave like a tree. Add branches with <code class="md-code md-code-inline">p.then(handler)</code> and <code class="md-code md-code-inline">p.catch(handler)</code></li> <li>Create new <code class="md-code md-code-inline">p</code> promises with <code class="md-code md-code-inline">new Promise(<mark class="md-mark md-code-mark">(resolve, reject) =&gt; { /* resolver */ }</mark>)</code> <ul> <li>The <code class="md-code md-code-inline">resolve(value)</code> callback will fulfill the promise with the provided <code class="md-code md-code-inline">value</code></li> <li>The <code class="md-code md-code-inline">reject(reason)</code> callback will reject <code class="md-code md-code-inline">p</code> with a <code class="md-code md-code-inline">reason</code> error</li> <li>You can call those methods asynchronously, blocking deeper branches of the promise tree</li> </ul> </li> <li>Each call to <code class="md-code md-code-inline">p.then</code> and <code class="md-code md-code-inline">p.catch</code> creates another promise that's blocked on <code class="md-code md-code-inline">p</code> being settled</li> <li>Promises start out in <em>pending</em> state and are <strong>settled</strong> when they're either <em>fulfilled</em> or <em>rejected</em></li> <li>Promises can only be settled once, and then they're settled. Settled promises unblock deeper branches</li> <li>You can tack as many promises as you want onto as many branches as you need</li> <li>Each branch will execute either <code class="md-code md-code-inline">.then</code> handlers or <code class="md-code md-code-inline">.catch</code> handlers, never both</li> <li>A <code class="md-code md-code-inline">.then</code> callback can transform the result of the previous branch by returning a value</li> <li>A <code class="md-code md-code-inline">.then</code> callback can block on another promise by returning it</li> <li><code class="md-code md-code-inline">p.catch(fn).catch(fn)</code> won't do what you want – unless what you wanted is to catch errors in the error handler</li> <li><a href="/articles/es6-promises-in-depth#using-promiseresolve-and-promisereject"><code class="md-code md-code-inline">Promise.resolve(value)</code></a> creates a promise that's fulfilled with the provided <code class="md-code md-code-inline">value</code></li> <li><a href="/articles/es6-promises-in-depth#using-promiseresolve-and-promisereject"><code class="md-code md-code-inline">Promise.reject(reason)</code></a> creates a promise that's rejected with the provided <code class="md-code md-code-inline">reason</code></li> <li><a href="/articles/es6-promises-in-depth#leveraging-promiseall-and-promiserace"><code class="md-code md-code-inline">Promise.all(...promises)</code></a> creates a promise that settles when all <code class="md-code md-code-inline">...promises</code> are fulfilled or 1 of them is rejected</li> <li><a href="/articles/es6-promises-in-depth#leveraging-promiseall-and-promiserace"><code class="md-code md-code-inline">Promise.race(...promises)</code></a> creates a promise that settles as soon as 1 of <code class="md-code md-code-inline">...promises</code> is settled</li> <li>Use <a href="http://bevacqua.github.io/promisees/" target="_blank" aria-label="Promisees — Promise visualization playground for the adventurous">Promisees</a> – the promise visualization playground – to better understand promises</li> <li>Read <a href="/articles/es6-promises-in-depth" aria-label="ES6 Promises in Depth">ES6 Promises in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="maps"><a href="#maps" class="md-heading">Maps</a></h1> <ul> <li>A replacement to the common pattern of creating a hash-map using plain JavaScript objects <ul> <li>Avoids security issues with user-provided keys</li> <li>Allows keys to be arbitrary values, you can even use DOM elements or functions as the <code class="md-code md-code-inline">key</code> to an entry</li> </ul> </li> <li><code class="md-code md-code-inline">Map</code> adheres to <em><a href="#iterators">iterable</a></em> protocol</li> <li>Create a <code class="md-code md-code-inline">map</code> using <code class="md-code md-code-inline">new Map()</code></li> <li>Initialize a map with an <code class="md-code md-code-inline">iterable</code> like <code class="md-code md-code-inline">[[key1, value1], [key2, value2]]</code> in <code class="md-code md-code-inline">new Map(iterable)</code></li> <li>Use <code class="md-code md-code-inline">map.set(key, value)</code> to add entries</li> <li>Use <code class="md-code md-code-inline">map.get(key)</code> to get an entry</li> <li>Check for a <code class="md-code md-code-inline">key</code> using <code class="md-code md-code-inline">map.has(key)</code></li> <li>Remove entries with <code class="md-code md-code-inline">map.delete(key)</code></li> <li>Iterate over <code class="md-code md-code-inline">map</code> with <code class="md-code md-code-inline">for (let [key, value] of map)</code>, the spread operator, <code class="md-code md-code-inline">Array.from</code>, etc</li> <li>Read <a href="/articles/es6-maps-in-depth" aria-label="ES6 Maps in Depth on Pony Foo">ES6 Maps in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="weakmaps"><a href="#weakmaps" class="md-heading">WeakMaps</a></h1> <ul> <li>Similar to <code class="md-code md-code-inline">Map</code>, but not quite the same</li> <li><code class="md-code md-code-inline">WeakMap</code> isn't iterable, so you don't get enumeration methods like <code class="md-code md-code-inline">.forEach</code>, <code class="md-code md-code-inline">.clear</code>, and others you had in <code class="md-code md-code-inline">Map</code></li> <li><code class="md-code md-code-inline">WeakMap</code> keys must be reference types. You can't use value types like symbols, numbers, or strings as keys</li> <li><code class="md-code md-code-inline">WeakMap</code> entries with a <code class="md-code md-code-inline">key</code> that's the only reference to the referenced variable are subject to garbage collection</li> <li>That last point means <code class="md-code md-code-inline">WeakMap</code> is great at keeping around metadata for objects, while those objects are still in use</li> <li>You avoid memory leaks, without manual reference counting – think of <code class="md-code md-code-inline">WeakMap</code> as <a href="https://msdn.microsoft.com/en-us/library/system.idisposable%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" aria-label="IDisposable on MSDN"><code class="md-code md-code-inline">IDisposable</code></a> in .NET</li> <li>Read <a href="/articles/es6-weakmaps-sets-and-weaksets-in-depth#es6-weakmaps" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth on Pony Foo">ES6 WeakMaps in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="sets"><a href="#sets" class="md-heading">Sets</a></h1> <ul> <li>Similar to <code class="md-code md-code-inline">Map</code>, but not quite the same</li> <li><code class="md-code md-code-inline">Set</code> doesn't have keys, there's only values</li> <li><code class="md-code md-code-inline">set.set(value)</code> doesn't look right, so we have <code class="md-code md-code-inline">set.add(value)</code> instead</li> <li>Sets can't have duplicate values because the values are also used as keys</li> <li>Read <a href="/articles/es6-weakmaps-sets-and-weaksets-in-depth#es6-sets" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth on Pony Foo">ES6 Sets in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="weaksets"><a href="#weaksets" class="md-heading">WeakSets</a></h1> <ul> <li><code class="md-code md-code-inline">WeakSet</code> is sort of a cross-breed between <code class="md-code md-code-inline">Set</code> and <code class="md-code md-code-inline">WeakMap</code></li> <li>A <code class="md-code md-code-inline">WeakSet</code> is a set that can't be iterated and doesn't have enumeration methods</li> <li><code class="md-code md-code-inline">WeakSet</code> values must be reference types</li> <li><code class="md-code md-code-inline">WeakSet</code> may be useful for a metadata table indicating whether a reference is actively in use or not</li> <li>Read <a href="/articles/es6-weakmaps-sets-and-weaksets-in-depth#es6-weaksets" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth on Pony Foo">ES6 WeakSets in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="proxies"><a href="#proxies" class="md-heading">Proxies</a></h1> <ul> <li>Proxies are created with <code class="md-code md-code-inline">new Proxy(target, handler)</code>, where <code class="md-code md-code-inline">target</code> is any object and <code class="md-code md-code-inline">handler</code> is configuration</li> <li>The default behavior of a <code class="md-code md-code-inline">proxy</code> acts as a passthrough to the underlying <code class="md-code md-code-inline">target</code> object</li> <li>Handlers determine how the underlying <code class="md-code md-code-inline">target</code> object is accessed on top of regular object property access semantics</li> <li>You pass off references to <code class="md-code md-code-inline">proxy</code> and retain strict control over how <code class="md-code md-code-inline">target</code> can be interacted with</li> <li>Handlers are also known as traps, these terms are used interchangeably</li> <li>You can create <strong>revocable</strong> proxies with <code class="md-code md-code-inline">Proxy.revocable(target, handler)</code> <ul> <li>That method returns an object with <code class="md-code md-code-inline">proxy</code> and <code class="md-code md-code-inline">revoke</code> properties</li> <li>You could <a href="#destructuring">destructure</a> <code class="md-code md-code-inline">var <mark class="md-mark md-code-mark">{proxy, revoke}</mark> = Proxy.revocable(target, handler)</code> for convenience</li> <li>You can configure the <code class="md-code md-code-inline">proxy</code> all the same as with <code class="md-code md-code-inline">new Proxy(target, handler)</code></li> <li>After <code class="md-code md-code-inline">revoke()</code> is called, the <code class="md-code md-code-inline">proxy</code> will <strong>throw</strong> on <em>any operation</em>, making it convenient when you can't trust consumers</li> </ul> </li> <li><a href="/articles/es6-proxies-in-depth#get"><code class="md-code md-code-inline">get</code></a> – traps <code class="md-code md-code-inline">proxy.prop</code> and <code class="md-code md-code-inline">proxy['prop']</code></li> <li><a href="/articles/es6-proxies-in-depth#set"><code class="md-code md-code-inline">set</code></a> – traps <code class="md-code md-code-inline">proxy.prop = value</code> and <code class="md-code md-code-inline">proxy['prop'] = value</code></li> <li><a href="/articles/es6-proxy-traps-in-depth#has"><code class="md-code md-code-inline">has</code></a> – traps <code class="md-code md-code-inline">in</code> operator</li> <li><a href="/articles/es6-proxy-traps-in-depth#deleteproperty"><code class="md-code md-code-inline">deleteProperty</code></a> – traps <code class="md-code md-code-inline">delete</code> operator</li> <li><a href="/articles/es6-proxy-traps-in-depth#defineproperty"><code class="md-code md-code-inline">defineProperty</code></a> – traps <code class="md-code md-code-inline">Object.defineProperty</code> and declarative alternatives</li> <li><a href="/articles/es6-proxy-traps-in-depth#enumerate"><code class="md-code md-code-inline">enumerate</code></a> – traps <code class="md-code md-code-inline">for..in</code> loops</li> <li><a href="/articles/es6-proxy-traps-in-depth#ownkeys"><code class="md-code md-code-inline">ownKeys</code></a> – traps <code class="md-code md-code-inline">Object.keys</code> and related methods</li> <li><a href="/articles/es6-proxy-traps-in-depth#apply"><code class="md-code md-code-inline">apply</code></a> – traps <em>function calls</em></li> <li><a href="/articles/morees6-proxy-traps-in-depth#construct"><code class="md-code md-code-inline">construct</code></a> – traps usage of the <code class="md-code md-code-inline">new</code> operator</li> <li><a href="/articles/morees6-proxy-traps-in-depth#getprototypeof"><code class="md-code md-code-inline">getPrototypeOf</code></a> – traps internal calls to <code class="md-code md-code-inline">[[GetPrototypeOf]]</code></li> <li><a href="/articles/morees6-proxy-traps-in-depth#setprototypeof"><code class="md-code md-code-inline">setPrototypeOf</code></a> – traps calls to <code class="md-code md-code-inline">Object.setPrototypeOf</code></li> <li><a href="/articles/morees6-proxy-traps-in-depth#isextensible"><code class="md-code md-code-inline">isExtensible</code></a> – traps calls to <code class="md-code md-code-inline">Object.isExtensible</code></li> <li><a href="/articles/morees6-proxy-traps-in-depth#preventextensions"><code class="md-code md-code-inline">preventExtensions</code></a> – traps calls to <code class="md-code md-code-inline">Object.preventExtensions</code></li> <li><a href="/articles/morees6-proxy-traps-in-depth#getownpropertydescriptor"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></a> – traps calls to <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></li> <li>Read <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">ES6 Proxies in Depth</a></li> <li>Read <a href="/articles/es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth on Pony Foo">ES6 Proxy Traps in Depth</a></li> <li>Read <a href="/articles/more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth on Pony Foo">More ES6 Proxy Traps in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="reflection"><a href="#reflection" class="md-heading">Reflection</a></h1> <ul> <li><code class="md-code md-code-inline">Reflection</code> is a new static built-in (think of <code class="md-code md-code-inline">Math</code>) in ES6</li> <li><code class="md-code md-code-inline">Reflection</code> methods have sensible internals, e.g <code class="md-code md-code-inline">Reflect.defineProperty</code> returns a boolean instead of throwing</li> <li>There's a <code class="md-code md-code-inline">Reflection</code> method for each proxy trap handler, and they represent the default behavior of each trap</li> <li>Going forward, new reflection methods in the same vein as <code class="md-code md-code-inline">Object.keys</code> will be placed in the <code class="md-code md-code-inline">Reflection</code> namespace</li> <li>Read <a href="/articles/es6-reflection-in-depth" aria-label="ES6 Reflection in Depth on Pony Foo">ES6 Reflection in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="number"><a href="#number" class="md-heading"><code class="md-code md-code-inline">Number</code></a></h1> <ul> <li>Use <code class="md-code md-code-inline">0b</code> prefix for binary, and <code class="md-code md-code-inline">0o</code> prefix for octal integer literals</li> <li><code class="md-code md-code-inline">Number.isNaN</code> and <code class="md-code md-code-inline">Number.isFinite</code> are like their global namesakes, except that they <em>don't</em> coerce input to <code class="md-code md-code-inline">Number</code></li> <li><code class="md-code md-code-inline">Number.parseInt</code> and <code class="md-code md-code-inline">Number.parseFloat</code> are exactly the same as their global namesakes</li> <li><code class="md-code md-code-inline">Number.isInteger</code> checks if input is a <code class="md-code md-code-inline">Number</code> value that doesn't have a decimal part</li> <li><code class="md-code md-code-inline">Number.EPSILON</code> helps figure out negligible differences between two numbers – e.g. <code class="md-code md-code-inline">0.1 + 0.2</code> and <code class="md-code md-code-inline">0.3</code></li> <li><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code> is the largest integer that can be safely and precisely represented in JavaScript</li> <li><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code> is the smallest integer that can be safely and precisely represented in JavaScript</li> <li><code class="md-code md-code-inline">Number.isSafeInteger</code> checks whether an integer is within those bounds, able to be represented safely and precisely</li> <li>Read <a href="/articles/es6-number-improvements-in-depth" aria-label="ES6 Number Improvements in Depth on Pony Foo">ES6 <code class="md-code md-code-inline">Number</code> Improvements in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="math"><a href="#math" class="md-heading"><code class="md-code md-code-inline">Math</code></a></h1> <ul> <li><a href="/articles/es6-math-additions-in-depth#mathsign"><code class="md-code md-code-inline">Math.sign</code></a> – sign function of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathtrunc"><code class="md-code md-code-inline">Math.trunc</code></a> – integer part of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathcbrt"><code class="md-code md-code-inline">Math.cbrt</code></a> – cubic root of value, or <code class="md-code md-code-inline">∛‾value</code></li> <li><a href="/articles/es6-math-additions-in-depth#mathexpm1"><code class="md-code md-code-inline">Math.expm1</code></a> – <code class="md-code md-code-inline">e</code> to the <code class="md-code md-code-inline">value</code> minus <code class="md-code md-code-inline">1</code>, or <code class="md-code md-code-inline">e<sup>value</sup> - 1</code></li> <li><a href="/articles/es6-math-additions-in-depth#mathlog1p"><code class="md-code md-code-inline">Math.log1p</code></a> – natural logarithm of <code class="md-code md-code-inline">value + 1</code>, or <code class="md-code md-code-inline"><em>ln</em>(value + 1)</code></li> <li><a href="/articles/es6-math-additions-in-depth#mathlog10"><code class="md-code md-code-inline">Math.log10</code></a> – base 10 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>10</sub>(value)</code></li> <li><a href="/articles/es6-math-additions-in-depth#mathlog2"><code class="md-code md-code-inline">Math.log2</code></a> – base 2 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>2</sub>(value)</code></li> <li><a href="/articles/es6-math-additions-in-depth#mathsinh"><code class="md-code md-code-inline">Math.sinh</code></a> – hyperbolic sine of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathcosh"><code class="md-code md-code-inline">Math.cosh</code></a> – hyperbolic cosine of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathtanh"><code class="md-code md-code-inline">Math.tanh</code></a> – hyperbolic tangent of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathasinh"><code class="md-code md-code-inline">Math.asinh</code></a> – hyperbolic arc-sine of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathacosh"><code class="md-code md-code-inline">Math.acosh</code></a> – hyperbolic arc-cosine of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathatanh"><code class="md-code md-code-inline">Math.atanh</code></a> – hyperbolic arc-tangent of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathhypot"><code class="md-code md-code-inline">Math.hypot</code></a> – square root of the sum of squares</li> <li><a href="/articles/es6-math-additions-in-depth#mathclz32"><code class="md-code md-code-inline">Math.clz32</code></a> – leading zero bits in the 32-bit representation of a number</li> <li><a href="/articles/es6-math-additions-in-depth#mathimul"><code class="md-code md-code-inline">Math.imul</code></a> – <em>C-like</em> 32-bit multiplication</li> <li><a href="/articles/es6-math-additions-in-depth#mathfround"><code class="md-code md-code-inline">Math.fround</code></a> – nearest single-precision float representation of a number</li> <li>Read <a href="/articles/es6-math-additions-in-depth" aria-label="ES6 Math Additions in Depth on Pony Foo">ES6 <code class="md-code md-code-inline">Math</code> Additions in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="array"><a href="#array" class="md-heading"><code class="md-code md-code-inline">Array</code></a></h1> <ul> <li><a href="/articles/es6-array-extensions-in-depth#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a> – create <code class="md-code md-code-inline">Array</code> instances from arraylike objects like <code class="md-code md-code-inline">arguments</code> or iterables</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayof"><code class="md-code md-code-inline">Array.of</code></a> – similar to <code class="md-code md-code-inline">new Array(...items)</code>, but without special cases</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypecopywithin"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></a> – copies a sequence of array elements into somewhere else in the array</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypefill"><code class="md-code md-code-inline">Array.prototype.fill</code></a> – fills all elements of an existing array with the provided value</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypefind"><code class="md-code md-code-inline">Array.prototype.find</code></a> – returns the first item to satisfy a callback</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypefindindex"><code class="md-code md-code-inline">Array.prototype.findIndex</code></a> – returns the index of the first item to satisfy a callback</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypekeys"><code class="md-code md-code-inline">Array.prototype.keys</code></a> – returns an iterator that yields a sequence holding the keys for the array</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a> – returns an iterator that yields a sequence holding the values for the array</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototypeentries"><code class="md-code md-code-inline">Array.prototype.entries</code></a> – returns an iterator that yields a sequence holding key value pairs for the array</li> <li><a href="/articles/es6-array-extensions-in-depth#arrayprototype-symboliterator"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></a> – exactly the same as the <a href="/articles/es6-array-extensions-in-depth#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a> method</li> <li>Read <a href="/articles/es6-array-extensions-in-depth" aria-label="ES6 Array Extensions in Depth on Pony Foo">ES6 <code class="md-code md-code-inline">Array</code> Extensions in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="object"><a href="#object" class="md-heading"><code class="md-code md-code-inline">Object</code></a></h1> <ul> <li><a href="/articles/es6-object-changes-in-depth#objectassign"><code class="md-code md-code-inline">Object.assign</code></a> – recursive shallow overwrite for properties from <code class="md-code md-code-inline">target, ...objects</code></li> <li><a href="/articles/es6-object-changes-in-depth#objectis"><code class="md-code md-code-inline">Object.is</code></a> – like using the <code class="md-code md-code-inline">===</code> operator programmatically, except it's <code class="md-code md-code-inline">true</code> for <code class="md-code md-code-inline">NaN</code> vs <code class="md-code md-code-inline">NaN</code> and <code class="md-code md-code-inline">false</code> for <code class="md-code md-code-inline">+0</code> vs <code class="md-code md-code-inline">-0</code></li> <li><a href="/articles/es6-object-changes-in-depth#objectgetownpropertysymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> – returns all own property symbols found on an object</li> <li><a href="/articles/es6-object-changes-in-depth#objectsetprototypeof"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a> – changes prototype. Equivalent to <code class="md-code md-code-inline">Object.prototype.__proto__</code> setter</li> <li>See also <a href="#object-literals">Object Literals</a> section</li> <li>Read <a href="/articles/es6-object-changes-in-depth" aria-label="ES6 Object Changes in Depth on Pony Foo">ES6 <code class="md-code md-code-inline">Object</code> Changes in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="strings-and-unicode"><a href="#strings-and-unicode" class="md-heading">Strings and Unicode</a></h1> <ul> <li>String Manipulation <ul> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototypestartswith"><code class="md-code md-code-inline">String.prototype.startsWith</code></a> – whether the string starts with <code class="md-code md-code-inline">value</code></li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototypeendswith"><code class="md-code md-code-inline">String.prototype.endsWith</code></a> – whether the string ends in <code class="md-code md-code-inline">value</code></li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototypeincludes"><code class="md-code md-code-inline">String.prototype.includes</code></a> – whether the string contains <code class="md-code md-code-inline">value</code> anywhere</li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototyperepeat"><code class="md-code md-code-inline">String.prototype.repeat</code></a> – returns the string repeated <code class="md-code md-code-inline">amount</code> times</li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototype-symboliterator"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></a> – lets you iterate over a sequence of unicode code points <em>(not characters)</em></li> </ul> </li> <li><a href="/articles/es6-strings-and-unicode-in-depth#unicode">Unicode</a> <ul> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototypecodepointat"><code class="md-code md-code-inline">String.prototype.codePointAt</code></a> – base-10 numeric representation of a code point at a given position in string</li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringfromcodepoint%60"><code class="md-code md-code-inline">String.fromCodePoint</code></a> – given <code class="md-code md-code-inline">...codepoints</code>, returns a string made of their unicode representations</li> <li><a href="/articles/es6-strings-and-unicode-in-depth#stringprototypenormalize"><code class="md-code md-code-inline">String.prototype.normalize</code></a> – returns a normalized version of the string's unicode representation</li> </ul> </li> <li>Read <a href="/articles/es6-strings-and-unicode-in-depth" aria-label="ES6 Strings (and Unicode) in Depth">ES6 Strings and Unicode Additions in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <h1 id="modules"><a href="#modules" class="md-heading">Modules</a></h1> <ul> <li><a href="/articles/es6-modules-in-depth#strict-mode">Strict Mode</a> is turned on by default in the ES6 module system</li> <li>ES6 modules are files that <a href="/articles/es6-modules-in-depth#export"><code class="md-code md-code-inline">export</code></a> an API</li> <li><a href="/articles/es6-modules-in-depth#exporting-a-default-binding"><code class="md-code md-code-inline">export default value</code></a> exports a default binding</li> <li><a href="/articles/es6-modules-in-depth#named-exports"><code class="md-code md-code-inline">export var foo = 'bar'</code></a> exports a named binding</li> <li>Named exports are bindings that <a href="/articles/es6-modules-in-depth#bindings-not-values">can be changed</a> at any time from the module that's exporting them</li> <li><code class="md-code md-code-inline">export { foo, bar }</code> exports <a href="/articles/es6-modules-in-depth#exporting-lists">a list of named exports</a></li> <li><code class="md-code md-code-inline">export { foo <mark class="md-mark md-code-mark">as ponyfoo</mark> }</code> aliases the export to be referenced as <code class="md-code md-code-inline">ponyfoo</code> instead</li> <li><code class="md-code md-code-inline">export { foo <mark class="md-mark md-code-mark">as default</mark> }</code> marks the named export as the default export</li> <li>As <a href="/articles/es6-modules-in-depth#best-practices-and-export">a best practice</a>, <code class="md-code md-code-inline">export default api</code> at the end of all your modules, where <code class="md-code md-code-inline">api</code> is an object, avoids confusion</li> <li>Module loading is implementation-specific, allows interoperation with CommonJS</li> <li><a href="/articles/es6-modules-in-depth#import"><code class="md-code md-code-inline">import 'foo'</code></a> loads the <code class="md-code md-code-inline">foo</code> module into the current module</li> <li><a href="/articles/es6-modules-in-depth#importing-default-exports"><code class="md-code md-code-inline">import <mark class="md-mark md-code-mark">foo from</mark> 'ponyfoo'</code></a> assigns the default export of <code class="md-code md-code-inline">ponyfoo</code> to a local <code class="md-code md-code-inline">foo</code> variable</li> <li><a href="/articles/es6-modules-in-depth#importing-named-exports"><code class="md-code md-code-inline">import {foo, bar} from 'baz'</code></a> imports named exports <code class="md-code md-code-inline">foo</code> and <code class="md-code md-code-inline">bar</code> from the <code class="md-code md-code-inline">baz</code> module</li> <li><code class="md-code md-code-inline">import {foo <mark class="md-mark md-code-mark">as bar</mark>} from 'baz'</code> imports named export <code class="md-code md-code-inline">foo</code> but aliased as a <code class="md-code md-code-inline">bar</code> variable</li> <li><code class="md-code md-code-inline">import {default} from 'foo'</code> also imports the default export</li> <li><code class="md-code md-code-inline">import {default <mark class="md-mark md-code-mark">as bar</mark>} from 'foo'</code> imports the default export aliased as <code class="md-code md-code-inline">bar</code></li> <li><code class="md-code md-code-inline">import foo, {bar, baz} from 'foo'</code> mixes default <code class="md-code md-code-inline">foo</code> with named exports <code class="md-code md-code-inline">bar</code> and <code class="md-code md-code-inline">baz</code> in one declaration</li> <li><a href="/articles/es6-modules-in-depth#import-all-the-things"><code class="md-code md-code-inline">import * as foo from 'foo'</code></a> imports the namespace object <ul> <li>Contains all named exports in <code class="md-code md-code-inline">foo[name]</code></li> <li>Contains the default export in <code class="md-code md-code-inline">foo.default</code>, if a default export was declared in the module</li> </ul> </li> <li>Read <a href="/articles/es6-modules-in-depth" aria-label="ES6 Modules in Depth on Pony Foo">ES6 Modules Additions in Depth</a></li> </ul> <p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p> <p>Time for a bullet point detox. Then again, I <em>did warn you</em> to read the <a href="/articles/tagged/es6-in-depth" aria-label="ES6 in Depth on Pony Foo">article series</a> instead. Don't forget to subscribe and maybe even <a href="http://patreon.com/bevacqua" target="_blank" aria-label="My Patreon Account">contribute to keep Pony Foo alive</a>. Also, did you try the <a href="https://en.wikipedia.org/wiki/Konami_Code" target="_blank">Konami code</a> just yet?</p></section></section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>05 : Metaprogramming in ES6: Symbols and why they're awesome</h1>
					<h3>Part 1</h3>
					<span class="ref-site">https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/</span>
					<div class="tutorial__content">
<section class="post-content">
<p>You've heard of ES6 right? It's the new version of JavaScript that is awesome in so many ways. I frequently wax lyrical about all of the amazing new features I keep discovering with ES6, much to the chagrin of my colleagues (consuming someone's lunch break talking about ES6 Modules seems to be not to everyone's liking).</p>
<p>A set of great new features for ES6 comes in the form of a slew of new metaprogramming tools, which provide low level hooks into code mechanics. Not much has been written on them, so I thought I'd do a teensy weensy 3 part post on them (sidebar; because I'm so lazy and this post has been sat in my drafts folder - 90% done - for three months, a <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/">bit more has been written about them since I said that</a>):</p>
<p>Part 1: Symbols (this post)
<a href="/metaprogramming-in-es6-part-2-reflect/">Part 2: Reflect</a>
<a href="/metaprogramming-in-es6-part-3-proxies/">Part 3: Proxies</a></p>
<h3 id="metaprogramming">Metaprogramming</h3>
<p>First, let's take a quick detour and discover the wonderful world of Metaprogramming. Metaprogramming is (loosely) all about the underlying mechanics of the language, rather than "high level" data modelling or business logic. If programming can be described as "making programs", metaprogramming could be described as "making programs making programs" - or something. You probably use metaprogramming every day perhaps without even noticing it.</p>
<p>Metaprogramming has a few "subgenres" - one is <em>Code Generation</em>, aka <code class="language-js highlighter-rouge"><span class="nb">eval</span></code> &amp; friends - which JavaScript has had since its inception (JS had <code class="language-js highlighter-rouge"><span class="nb">eval</span></code> in ES1, even before it got <code class="language-js highlighter-rouge"><span class="k">try</span></code>/<code class="language-js highlighter-rouge"><span class="k">catch</span></code> or <code class="language-js highlighter-rouge"><span class="k">switch</span></code> statements). Pretty much every other language you'd reasonably use today has <em>code generation</em> features.</p>
<p>Another facet of metaprogramming is <em>Reflection</em> - finding out about and adjusting the structure and semantics of your application. JavaScript has quite a few tools for Reflection. Functions have <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">name</span></code> and <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">length</span></code>, as well as <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">bind</span></code>, <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">call</span></code>, and <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">apply</span></code>. All of the available methods on <code class="language-js highlighter-rouge"><span class="nb">Object</span></code> are <em>Reflection</em>, e.g. <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnProperties</span></code> (As an aside, Reflection tools that don't alter code, but instead gather information about it are often called <em>Introspection</em>). We also have <em>Reflection</em>/<em>Introspection</em> operators, like <code class="language-js highlighter-rouge"><span class="k">typeof</span></code>, <code class="language-js highlighter-rouge"><span class="k">instanceof</span></code>, and <code class="language-js highlighter-rouge"><span class="k">delete</span></code>.</p>
<p>Reflection is a really cool part of metaprogramming, because it allows you to alter the internals of how an application works. Take for example Ruby, in Ruby you can specify operators as methods which lets you override how those operators work when used against the class (sometimes called "operator overloading"):</p>
<pre><code>class BoringClass
end
class CoolClass
  def ==(other_object)
   other_object.is_a? CoolClass
  end
end
BoringClass.new == BoringClass.new #=&gt; false
CoolClass.new == CoolClass.new #=&gt; true!
</code></pre>
<p>Compared to other languages like Ruby or Python, JavaScript's metaprogramming features are not yet as advanced - especially when it comes to nifty tools like Operator Overloading, but ES6 is starting to level the playing field.</p>
<h4 id="metaprogramming-within-es6">Metaprogramming within ES6</h4>
<p>The new APIs in ES6 come in three flavours: <code class="language-js highlighter-rouge"><span class="nx">Symbol</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Reflect</span></code>, and <code class="language-js highlighter-rouge"><span class="nx">Proxy</span></code>. Upon first glance this might be a little confusing - three separate APIs all for metaprogramming? But it actually makes a lot of sense when you see how each one is split:</p>
<ul>
<li>Symbols are all about <em>Reflection within implementation</em> - you sprinkle them on your existing classes and objects to change the behaviour.</li>
<li>Reflect is all about <em>Reflection through introspection</em> - used to discover very low level information about your code.</li>
<li>Proxy is all about <em>Reflection through intercession</em> - wrapping objects and intercepting their behaviours through traps.</li>
</ul>
<p>So how does each one work? How are they useful? This post will cover Symbols, while the next two posts will cover Reflect and Proxy respectively.</p>
<h3 id="symbols---reflection-within-implementation">Symbols - Reflection within Implementation</h3>
<p>Symbols are a new primitive. Just like the <code class="language-js highlighter-rouge"><span class="nb">Number</span></code>, <code class="language-js highlighter-rouge"><span class="nb">String</span></code>, and <code class="language-js highlighter-rouge"><span class="nb">Boolean</span></code> primitives, Symbols have a <code class="language-js highlighter-rouge"><span class="nx">Symbol</span></code> function which can be used to create them. Unlike the other primitives, Symbols do not have a literal syntax (e.g how Strings have <code class="language-js highlighter-rouge"><span class="s1">''</span></code>) - the only way to make them is with the Symbol constructor-not-constructor-thingy:</p>
<pre><code>Symbol(); // symbol
console.log(Symbol()); // prints "Symbol()" to the console
assert(typeof Symbol() === 'symbol')
new Symbol(); // TypeError: Symbol is not a constructor
</code></pre>
<h5 id="symbols-have-debuggability-built-in">Symbols have debuggability built in</h5>
<p>Symbols can be given a description, which is really just used for debugging to make life a little easier when logging them to a console:</p>
<pre><code>console.log(Symbol('foo')); // prints "Symbol(foo)" to the console.
assert(Symbol('foo').toString() === 'Symbol(foo)');
</code></pre>
<h5 id="symbols-can-be-used-as-object-keys">Symbols can be used as Object keys</h5>
<p>This is where Symbols get really interesting. They are heavily intertwined with Objects. Symbols can be assigned as keys to Objects (kind of like String keys), meaning you can assign an unlimited number of unique Symbols to an object and be guaranteed that these will never conflict with String keys, or other unique Symbols:</p>
<pre><code>var myObj = {};
var fooSym = Symbol('foo');
var otherSym = Symbol('bar');
myObj['foo'] = 'bar';
myObj[fooSym] = 'baz';
myObj[otherSym] = 'bing';
assert(myObj.foo === 'bar');
assert(myObj[fooSym] === 'baz');
assert(myObj[otherSym] === 'bing');
</code></pre>
<p>In addition to that, Symbols do not show up on an Object using <code class="language-js highlighter-rouge"><span class="k">for</span> <span class="k">in</span></code>, <code class="language-js highlighter-rouge"><span class="k">for</span> <span class="nx">of</span></code> or <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code> - the only way to get the Symbols within an Object is <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span></code>:</p>
<pre><code>var fooSym = Symbol('foo');
var myObj = {};
myObj['foo'] = 'bar';
myObj[fooSym] = 'baz';
Object.keys(myObj); // -&gt; [ 'foo' ]
Object.getOwnPropertyNames(myObj); // -&gt; [ 'foo' ]
Object.getOwnPropertySymbols(myObj); // -&gt; [ Symbol(foo) ]
assert(Object.getOwnPropertySymbols(myObj)[0] === fooSym);
</code></pre>
<p>This means Symbols give a whole new sense of purpose to Objects - they provide a kind of hidden under layer to Objects - not iterable over, not fetched using the already existing Reflection tools and guaranteed not to conflict with other properties in the object!</p>
<h5 id="symbols-are-completely-unique">Symbols are completely unique…</h5>
<p>By default, each new Symbol has a completely unique value. If you create a symbol (<code class="language-js highlighter-rouge"><span class="kd">var</span> <span class="nx">mysym</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">()</span></code>) it creates a completely new value inside the JavaScript engine. If you don't have the <em>reference</em> for the Symbol, you just can't use it. This also means two symbols will never equal the same value, even if they have the same description.</p>
<pre><code>assert.notEqual(Symbol(), Symbol());
assert.notEqual(Symbol('foo'), Symbol('foo'));
assert.notEqual(Symbol('foo'), Symbol('bar'));

var foo1 = Symbol('foo');
var foo2 = Symbol('foo');
var object = {
    [foo1]: 1,
    [foo2]: 2,
};
assert(object[foo1] === 1);
assert(object[foo2] === 2);
</code></pre>
<h5 id="except-when-theyre-not">…except when they're not.</h5>
<p>Well, there's a small caveat to that - as there is also another way to make Symbols that can be easily fetched and re-used: <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">()</span></code>. This method creates a Symbol in a "global Symbol registry". Small aside: this registry is also cross-realm, meaning a Symbol from an iframe or service worker will be the same as one generated from your existing frame:</p>
<pre><code>assert.notEqual(Symbol('foo'), Symbol('foo'));
assert.equal(Symbol.for('foo'), Symbol.for('foo'));

// Not unique:
var myObj = {};
var fooSym = Symbol.for('foo');
var otherSym = Symbol.for('foo');
myObj[fooSym] = 'baz';
myObj[otherSym] = 'bing';
assert(fooSym === otherSym);
assert(myObj[fooSym] === 'bing');
assert(myObj[otherSym] === 'bing');

// Cross-Realm
iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);
assert.notEqual(iframe.contentWindow.Symbol, Symbol);
assert(iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')); // true!
</code></pre>
<p>Having global Symbols does make things more complicated, but for good reason, which we'll get to. Right now some of you are probably saying "Argh!? How will I know which Symbols are unique Symbols and which Symbols aren't?", to that I say "it's okay, I got you, nothing bad is going to happen, we have <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">()</span></code>":</p>
<pre><code>var localFooSymbol = Symbol('foo');
var globalFooSymbol = Symbol.for('foo');

assert(Symbol.keyFor(localFooSymbol) === undefined);
assert(Symbol.keyFor(globalFooSymbol) === 'foo');
assert(Symbol.for(Symbol.keyFor(globalFooSymbol)) === Symbol.for('foo'));
</code></pre>
<h5 id="what-symbols-are-what-symbols-arent">What Symbols are, what Symbols aren't.</h5>
<p>So we've got a good overview for what Symbols are, and how they work - but it's just as important to know what Symbols <em>are</em> good for, and what they're <em>not</em> good for, as they could easily be assumed to be something they're not:</p>
<ul>
<li><strong>Symbols will never conflict with Object string keys</strong>. This makes them great for extending objects you've been given (e.g. as a function param) without affecting the Object in a noticeable way.</li>
<li><strong>Symbols cannot be read using existing reflection tools</strong>. You need the new <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPopertySymbols</span><span class="p">()</span></code> to access an Object's symbols, this makes Symbols great for storing bits of information you don't want people getting at through normal operation. Using <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">()</span></code> is a pretty special use-case.</li>
<li><strong>Symbols are not private</strong>. The other edge to that sword - all of the Symbols of an object can be gotten by using <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnSymbols</span><span class="p">()</span></code> - not very useful for a truly private value. Don't try to store information you want to be really private in an Object using a symbol - it can be gotten!</li>
<li><strong>Enumerable Symbols can be copied to other objects</strong> using new methods like Object.assign. If you try calling <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">newObject</span><span class="p">,</span> <span class="nx">objectWithSymbols</span><span class="p">)</span></code> all of the (enumerable) Symbols in the second param (<code class="language-js highlighter-rouge"><span class="nx">objectWithSymbols</span></code>) <em>will be copied</em> to the first (<code class="language-js highlighter-rouge"><span class="nx">newObject</span></code>). If you don't want this to happen, make them non-enumerable with <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span></code>.</li>
<li><strong>Symbols are not coercible into primitives</strong>. If you try to coerce a Symbol to a primitive (<code class="language-js highlighter-rouge"><span class="o">+</span><span class="nx">Symbol</span><span class="p">()</span></code>, <code class="language-js highlighter-rouge"><span class="s1">''</span><span class="o">+</span><span class="nx">Symbol</span><span class="p">()</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">()</span> <span class="o">+</span> <span class="s1">'foo'</span></code>) it will throw an Error. This prevents you accidentally stringifying them when setting them as property names.</li>
<li><strong>Symbols are not always unique</strong>. As mentioned above, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">()</span></code> returns you a non-unique Symbol. Don't always assume the Symbol you have is unique, unless you made it yourself.</li>
<li><strong>Symbols are nothing like Ruby Symbols</strong>. They share some similarities - such as having a central Symbol registry, but that's about it. They should not be used the same as Ruby symbols.</li>
</ul>
<h3 id="okay-but-what-are-symbols-really-good-for">Okay, but what are Symbols really good for?</h3>
<p>In reality, Symbols are just a slightly different way to attach properties to an Object - you could easily provide the well-known symbols as standard methods, just like <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span></code> which appears in everything that inherits from Object (which is basically everything). In fact, other languages such as Python do just that - Python's equivalent of <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code> is <code class="language-js highlighter-rouge"><span class="nx">__iter__</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span></code> is <code class="language-js highlighter-rouge"><span class="nx">__instancecheck__</span></code>, and I guess <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span></code> draws similarities with <code class="language-js highlighter-rouge"><span class="nx">__cmp__</span></code>. Python's way is, arguably, a worse approach though, as JavaScript Symbols don't need any weird syntax, and in no way can a user accidentally conflict with one of these special methods.</p>
<p>Symbols, in my opinion, can be used 2 fold:</p>
<h5 id="as-a-unique-value-where-youd-probably-normally-use-a-string-or-integer">1. As a unique value where you'd probably normally use a String or Integer:</h5>
<p>Let's assume you have a logging library, which includes multiple log levels such as <code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">DEBUG</span></code>, <code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">INFO</span></code>, <code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">WARN</span></code> and so on. In ES5 code you'd like make these Strings (so <code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">DEBUG</span> <span class="o">===</span> <span class="s1">'debug'</span></code>), or numbers (<code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span><span class="p">.</span><span class="nx">DEBUG</span> <span class="o">===</span> <span class="mi">10</span></code>). Both of these aren't ideal as those values aren't unique values, but Symbols are! So <code class="language-js highlighter-rouge"><span class="nx">logger</span><span class="p">.</span><span class="nx">levels</span></code> simply becomes:</p>
<pre><code>log.levels = {
    DEBUG: Symbol('debug'),
    INFO: Symbol('info'),
    WARN: Symbol('warn'),
};
log(log.levels.DEBUG, 'debug message');
log(log.levels.INFO, 'info message');
</code></pre>
<h5 id="a-place-to-put-metadata-values-in-an-object">2. A place to put metadata values in an Object</h5>
<p>You could also use them to store custom metadata properties that are secondary to the actual Object. Think of this as an extra layer of non-enumerability (after all, non-enumerable keys still come up in <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnProperties</span></code>). Lets take our trusty Collection class and add a size reference, which is hidden behind the scenes as a Symbol (just remember that <strong>Symbols are not private</strong> - and you can - and should - only use them in for stuff you don't mind being altered by the rest of the app):</p>
<pre><code>var size = Symbol('size');
class Collection {
    constructor() {
        this[size] = 0;
    }

    add(item) {
        this[this[size]] = item;
        this[size]++;
    }

    static sizeOf(instance) {
        return instance[size];
    }

}

var x = new Collection();
assert(Collection.sizeOf(x) === 0);
x.add('foo');
assert(Collection.sizeOf(x) === 1);
assert.deepEqual(Object.keys(x), ['0']);
assert.deepEqual(Object.getOwnPropertyNames(x), ['0']);
assert.deepEqual(Object.getOwnPropertySymbols(x), [size]);
</code></pre>
<h6 id="giving-developers-ability-to-add-hooks-to-their-objects-through-your-api">3. Giving developers ability to add hooks to their objects, through your API</h6>
<p>Ok, this sounds a little weird but bear with me. Let's pretend that we have a <code class="language-js highlighter-rouge"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span></code> style utility function - this function can take <em>any</em> Object, and log it to the console. It has its own routines for how it displays the given Object in the console - but you, as a developer who consumes this API, can override those by providing a method, under a hook: an <code class="language-js highlighter-rouge"><span class="nx">inspect</span></code> Symbol:</p>
<pre><code>// Retreive the magic inspect Symbol from the API's Symbol constants
var inspect = console.Symbols.INSPECT;

var myVeryOwnObject = {};
console.log(myVeryOwnObject); // logs out `{}`

myVeryOwnObject[inspect] = function () { return 'DUUUDE'; };
console.log(myVeryOwnObject); // logs out `DUUUDE`
</code></pre>
<p>An implementation of this theoretical inspect hook could look a little something like this:</p>
<pre><code>console.log = function (…items) {
    var output = '';
    for(const item of items) {
        if (typeof item[console.Symbols.INSPECT] === 'function') {
            output += item[console.Symbols.INSPECT](item);
        } else {
            output += console.inspect[typeof item](item);
        }
        output += '  ';
    }
    process.stdout.write(output + '\n');
}

</code></pre>
<p>To clarify, this does not mean you should write code that modifies objects given to it. That would most definitely be a no-no (for this, have a look at <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMaps</a> which can provide ancillary objects for you to gather your own metadata on Objects).</p>
<p><a href="https://nodejs.org/api/util.html#util_custom_inspect_function_on_objects">Node.js already has similar behaviour with its implementation of <code class="language-js highlighter-rouge"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span></code></a>. Sort of. It uses String (<code class="language-js highlighter-rouge"><span class="s1">'inspect'</span></code>) not a Symbol, meaning you can set <code class="language-js highlighter-rouge"><span class="nx">x</span><span class="p">.</span><span class="nx">inspect</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){}</span></code> - but this is clunky because it could clash with your classes methods, and occur by accident. Using Symbols <em>is a very purposeful way for this kind of behaviour to happen</em>.</p>
<p>This way of using Symbols is so profound, that it is actually part of the language, and with that we segue into the realm of well known Symbols…</p>
<h4 id="well-known-symbols">Well Known Symbols</h4>
<p>A key part of what makes Symbols useful, is a set of Symbol constants, known as "well known symbols". These are effectively a bunch of static properties on the <code class="language-js highlighter-rouge"><span class="nx">Symbol</span></code> class which are implemented within other native objects, such as Arrays, Strings, and within the internals of the JavaScript engine. This is where the real "Reflection within Implementation" part happens, as these well known Symbols alter the behaviour of (what used to be) JavaScript internals. Below I've detailed what each one does and why they're just so darn awesome!</p>
<h5 id="symbolhasinstance-instanceof">Symbol.hasInstance: instanceof</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span></code> is a Symbol which drives the behaviour of <code class="language-js highlighter-rouge"><span class="k">instanceof</span></code>. When an ES6 compliant engine sees the <code class="language-js highlighter-rouge"><span class="k">instanceof</span></code> operator in an expression it calls upon <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span></code>. For example, <code class="language-js highlighter-rouge"><span class="nx">lho</span> <span class="k">instanceof</span> <span class="nx">rho</span></code> would call <code class="language-js highlighter-rouge"><span class="nx">rho</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span><span class="p">](</span><span class="nx">lho</span><span class="p">)</span></code> (where <code class="language-js highlighter-rouge"><span class="nx">rho</span></code> is the right hand operand and <code class="language-js highlighter-rouge"><span class="nx">lho</span></code> is the left hand operand). It's then up to the method to determine if it inherits from that particular instance, you could implement this like so:</p>
<pre><code>class MyClass {
    static [Symbol.hasInstance](lho) {
        return Array.isArray(lho);
    }
}
assert([] instanceof MyClass);
</code></pre>
<h5 id="symboliterator">Symbol.iterator</h5>
<p>If you've heard anything about Symbols, you've probably heard about <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code>. With ES6 comes a new pattern - the <code class="language-js highlighter-rouge"><span class="k">for</span> <span class="nx">of</span></code> loop, which calls <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code> on right hand operand to get values to iterate over. In other words these two are equivalent:</p>
<pre><code>var myArray = [1,2,3];

// with `for of`
for(var value of myArray) {
    console.log(value);
}

// without `for of`
var _myArray = myArray[Symbol.iterator]();
while(var _iteration = _myArray.next()) {
    if (_iteration.done) {
        break;
    }
    var value = _iteration.value;
    console.log(value);
}
</code></pre>
<p><code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code> will allow you to override the <code class="language-js highlighter-rouge"><span class="nx">of</span></code> operator - meaning if you make a library that uses it, developers will love you:</p>
<pre><code>class Collection {
  *[Symbol.iterator]() {
    var i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }

}
var myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;
for(var value of myCollection) {
    console.log(value); // 1, then 2
}
</code></pre>
<h5 id="symbolisconcatspreadable">Symbol.isConcatSpreadable</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span></code> is a pretty specific Symbol - driving the behaviour of <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">concat</span></code>. You see, <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">concat</span></code> can take multiple arguments, which - if arrays - will themselves be flattened (or spread) as part of the concat operation. Consider the following code:</p>
<pre><code>x = [1, 2].concat([3, 4], [5, 6], 7, 8);
assert.deepEqual(x, [1, 2, 3, 4, 5, 6, 7, 8]);
</code></pre>
<p>As of ES6 the way <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">concat</span></code> will determine if any of its arguments are spreadable will be with <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span></code>. This is more used to say that the class you have made that extends Array won't be particularly good for <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">concat</span></code>, rather than the other way around:</p>
<pre><code>class ArrayIsh extends Array {
    get [Symbol.isConcatSpreadable]() {
        return true;
    }
}
class Collection extends Array {
    get [Symbol.isConcatSpreadable]() {
        return false;
    }
}
arrayIshInstance = new ArrayIsh();
arrayIshInstance[0] = 3;
arrayIshInstance[1] = 4;
collectionInstance = new Collection();
collectionInstance[0] = 5;
collectionInstance[1] = 6;
spreadableTest = [1,2].concat(arrayInstance).concat(collectionInstance);
assert.deepEqual(spreadableTest, [1, 2, 3, 4, &lt;Collection&gt;]);
</code></pre>
<h4 id="symbolunscopables">Symbol.unscopables</h4>
<p>This Symbol has a bit of interesting history. Essentially, while developing ES6, the TC found some old code in a popular JS libraries that did this kind of thing:</p>
<pre><code>var keys = [];
with(Array.prototype) {
    keys.push('foo');
}
</code></pre>
<p>This works well in old ES5 code and below, but ES6 now has <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">keys</span></code> - meaning when you do <code class="language-js highlighter-rouge"><span class="kd">with</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span></code>, <code class="language-js highlighter-rouge"><span class="nx">keys</span></code> is now the method <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">keys</span></code> - not the variable you set. So there were three solutions:</p>
<ol>
<li>Try to get all websites using this code to change it/update the libraries (impossible).</li>
<li>Remove <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">keys</span></code> and hope another bug like this doesn't crop up (not really solving the problem)</li>
<li>Write a hack around all of this which prevents some properties being scoped into <code class="language-js highlighter-rouge"><span class="kd">with</span></code> statements.</li>
</ol>
<p>Well, the TC went with option 3, and so <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">unscopables</span></code> was born, which defines a set of "unscopable" values in an Object which should not be set when used inside the <code class="language-js highlighter-rouge"><span class="kd">with</span></code> statement. You'll probably never need to use this - nor will you encounter it in day to day JavaScripting, but it demonstrates some of the utility of Symbols, and also is here for completeness:</p>
<pre><code>Object.keys(Array.prototype[Symbol.unscopables]); // -&gt; ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'keys']

// Without unscopables:
class MyClass {
    foo() { return 1; }
}
var foo = function () { return 2; };
with (MyClass.prototype) {
    foo(); // 1!!
}

// Using unscopables:
class MyClass {
    foo() { return 1; }
    get [Symbol.unscopables]() {
        return { foo: true };
    }
}
var foo = function () { return 2; };
with (MyClass.prototype) {
    foo(); // 2!!
}
</code></pre>
<h4 id="symbolmatch">Symbol.match</h4>
<p>This is another Symbol specific to a function. <code class="language-js highlighter-rouge"><span class="nb">String</span><span class="err">#</span><span class="nx">match</span></code> function will now use this to determine if the given value can be used to match against it. So, you can provide your own matching implementation to use, rather than using Regular Expressions:</p>
<pre><code>class MyMatcher {
    constructor(value) {
        this.value = value;
    }
    [Symbol.match](string) {
        var index = string.indexOf(this.value);
        if (index === -1) {
            return null;
        }
        return [this.value];
    }
}
var fooMatcher = 'foobar'.match(new MyMatcher('foo'));
var barMatcher = 'foobar'.match(new MyMatcher('bar'));
assert.deepEqual(fooMatcher, ['foo']);
assert.deepEqual(barMatcher, ['bar']);
</code></pre>
<h4 id="symbolreplace">Symbol.replace</h4>
<p>Just like <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">match</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">replace</span></code> has been added to allow custom classes, where you'd normally use Regular Expressions, for <code class="language-js highlighter-rouge"><span class="nb">String</span><span class="err">#</span><span class="nx">replace</span></code>:</p>
<pre><code>class MyReplacer {
    constructor(value) {
        this.value = value;
    }
    [Symbol.replace](string, replacer) {
        var index = string.indexOf(this.value);
        if (index === -1) {
            return string;
        }
        if (typeof replacer === 'function') {
            replacer = replacer.call(undefined, this.value, string);
        }
        return `${string.slice(0, index)}${replacer}${string.slice(index + this.value.length)}`;
    }
}
var fooReplaced = 'foobar'.replace(new MyReplacer('foo'), 'baz');
var barMatcher = 'foobar'.replace(new MyReplacer('bar'), function () { return 'baz' });
assert.equal(fooReplaced, 'bazbar');
assert.equal(barReplaced, 'foobaz');
</code></pre>
<h4 id="symbolsearch">Symbol.search</h4>
<p>Yup, just like <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">match</span></code> and <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">replace</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">search</span></code> exists to prop up <code class="language-js highlighter-rouge"><span class="nb">String</span><span class="err">#</span><span class="nx">search</span></code> - allowing for custom classes instead of Regular Expressions:</p>
<pre><code>class MySearch {
    constructor(value) {
        this.value = value;
    }
    [Symbol.search](string) {
        return string.indexOf(this.value);
    }
}
var fooSearch = 'foobar'.search(new MySearch('foo'));
var barSearch = 'foobar'.search(new MySearch('bar'));
var bazSearch = 'foobar'.search(new MySearch('baz'));
assert.equal(fooSearch, 0);
assert.equal(barSearch, 3);
assert.equal(bazSearch, -1);
</code></pre>
<h4 id="symbolsplit">Symbol.split</h4>
<p>Ok, last of the String symbols - <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">split</span></code> is for <code class="language-js highlighter-rouge"><span class="nb">String</span><span class="err">#</span><span class="nx">split</span></code>. Use like so:</p>
<pre><code>class MySplitter {
    constructor(value) {
        this.value = value;
    }
    [Symbol.split](string) {
        var index = string.indexOf(this.value);
        if (index === -1) {
            return string;
        }
        return [string.substr(0, index), string.substr(index + this.value.length)];
    }
}
var fooSplitter = 'foobar'.split(new MySplitter('foo'));
var barSplitter = 'foobar'.split(new MySplitter('bar'));
assert.deepEqual(fooSplitter, ['', 'bar']);
assert.deepEqual(barSplitter, ['foo', '']);
</code></pre>
<h4 id="symbolspecies">Symbol.species</h4>
<p>Symbol.species is a pretty clever Symbol, it points to the constructor value of a class, which allows classes to create new versions of themselves within methods. Take for example <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">map</span></code>, which creates a new Array resulting from each return value of the callback - in ES5 <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">map</span></code>'s code might look something like this:</p>
<pre><code>Array.prototype.map = function (callback) {
    var returnValue = new Array(this.length);
    this.forEach(function (item, index, array) {
        returnValue[index] = callback(item, index, array);
    });
    return returnValue;
}
</code></pre>
<p>In ES6 <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">map</span></code>, along with all of the other non-mutating Array methods have been upgraded to create Objects using the <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span></code> property, and so the ES6 <code class="language-js highlighter-rouge"><span class="nb">Array</span><span class="err">#</span><span class="nx">map</span></code> code now looks more like this:</p>
<pre><code>Array.prototype.map = function (callback) {
    var Species = this.constructor[Symbol.species];
    var returnValue = new Species(this.length);
    this.forEach(function (item, index, array) {
        returnValue[index] = callback(item, index, array);
    });
    return returnValue;
}
</code></pre>
<p>Now, if you were to make a <code class="language-js highlighter-rouge"><span class="kr">class</span> <span class="nx">Foo</span> <span class="kr">extends</span> <span class="nb">Array</span></code> - every time you called <code class="language-js highlighter-rouge"><span class="nx">Foo</span><span class="err">#</span><span class="nx">map</span></code> while before it would return an Array (no fun) and you'd have to write your own Map implementation just to create <code class="language-js highlighter-rouge"><span class="nx">Foo</span></code>s instead of <code class="language-js highlighter-rouge"><span class="nb">Array</span></code>s, now <code class="language-js highlighter-rouge"><span class="nx">Foo</span><span class="err">#</span><span class="nx">map</span></code> return a <code class="language-js highlighter-rouge"><span class="nx">Foo</span></code>, thanks to <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span></code>:</p>
<pre><code>class Foo extends Array {
    static get [Symbol.species]() {
        return this;
    }
}

class Bar extends Array {
    static get [Symbol.species]() {
        return Array;
    }
}

assert(new Foo().map(function(){}) instanceof Foo);
assert(new Bar().map(function(){}) instanceof Bar);
assert(new Bar().map(function(){}) instanceof Array);
</code></pre>
<p>You may be asking "why not just use <code class="language-js highlighter-rouge"><span class="k">this</span><span class="p">.</span><span class="nx">constructor</span></code> instead of <code class="language-js highlighter-rouge"><span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span><span class="p">]</span></code>?". Well, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span></code> provides a <em>customisable</em> entry-point for what type to create - you might not always want to subclass and have methods create your subclass - take for example the following:</p>
<pre><code>class TimeoutPromise extends Promise {
    static get [Symbol.species]() {
        return Promise;
    }
}
</code></pre>
<p>This timeout promise could be created to perform an operation that times out - but of course you don't want one Promise that times out to subsequently effect the whole Promise chain, and so <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">species</span></code> can be used to tell <code class="language-js highlighter-rouge"><span class="nx">TimeoutPromise</span></code> to return <code class="language-js highlighter-rouge"><span class="nx">Promise</span></code> from it's prototype methods. Pretty handy.</p>
<h4 id="symboltoprimitive">Symbol.toPrimitive</h4>
<p>This Symbol is the closest thing we have to overloading the Abstract Equality Operator (<code class="language-js highlighter-rouge"><span class="o">==</span></code> for short). Basically, <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span></code> is used when the JavaScript engine needs to convert your Object into a primitive value - for example if you do <code class="language-js highlighter-rouge"><span class="o">+</span><span class="nx">object</span></code> then JS will call <code class="language-js highlighter-rouge"><span class="nx">object</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span><span class="p">](</span><span class="s1">'number'</span><span class="p">);</span></code>, if you do <code class="language-js highlighter-rouge"><span class="s1">''</span><span class="o">+</span><span class="nx">object</span><span class="err">'</span></code> then JS will call <code class="language-js highlighter-rouge"><span class="nx">object</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span><span class="p">](</span><span class="s1">'string'</span><span class="p">)</span></code>, and if you do something like <code class="language-js highlighter-rouge"><span class="k">if</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span></code> then it will call <code class="language-js highlighter-rouge"><span class="nx">object</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span><span class="p">](</span><span class="s1">'default'</span><span class="p">)</span></code>. Before this, we had <code class="language-js highlighter-rouge"><span class="nx">valueOf</span></code> and <code class="language-js highlighter-rouge"><span class="nx">toString</span></code> to juggle with - both of which were kind of gnarly and you could never get the behaviour you wanted from them. <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span></code> gets implemented like so:</p>
<pre><code>class AnswerToLifeAndUniverseAndEverything {
    [Symbol.toPrimitive](hint) {
        if (hint === 'string') {
            return 'Like, 42, man';
        } else if (hint === 'number') {
            return 42;
        } else {
            // when pushed, most classes (except Date)
            // default to returning a number primitive
            return 42;
        }
    }
}

var answer = new AnswerToLifeAndUniverseAndEverything();
+answer === 42;
Number(answer) === 42;
''+answer === 'Like, 42, man';
String(answer) === 'Like, 42, man';
</code></pre>
<h4 id="symboltostringtag">Symbol.toStringTag</h4>
<p>Ok, this is the last of the well known Symbols. Come on, you've got this far, you can do this! <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span></code> is actually a pretty cool one - if you've ever tried to implement your own replacement for the <code class="language-js highlighter-rouge"><span class="k">typeof</span></code> operator, you've probably come across <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="err">#</span><span class="nx">toString</span><span class="p">()</span></code> - and how it returns this weird <code class="language-js highlighter-rouge"><span class="s1">'[object Object]'</span></code> or <code class="language-js highlighter-rouge"><span class="s1">'[object Array]'</span></code> String. Before ES6, this behaviour was defined in the crevices of the spec, however today, in fancy ES6 land we have a Symbol for it! Any Object passed to <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="err">#</span><span class="nx">toString</span><span class="p">()</span></code> will be checked to see if it has a property of <code class="language-js highlighter-rouge"><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span><span class="p">]</span></code> which should be a String, and if it is there then it will be used in the generated String - for example:</p>
<pre><code>class Collection {

  get [Symbol.toStringTag]() {
    return 'Collection';
  }

}
var x = new Collection();
Object.prototype.toString.call(x) === '[object Collection]'
</code></pre>
<p>As an aside for this - if you use <a href="http://chaijs.com">Chai</a> for testing, it now uses Symbols under the hood for type detection, so you can write <code class="language-js highlighter-rouge"><span class="nx">expect</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">to</span><span class="p">.</span><span class="nx">be</span><span class="p">.</span><span class="nx">a</span><span class="p">(</span><span class="s1">'Collection'</span><span class="p">)</span></code> in your tests (provided <code class="language-js highlighter-rouge"><span class="nx">x</span></code> has the Symbol.toStringTag property like above, oh and that you're running the code in a browser with <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">toStringTag</span></code>).</p>
<h3 id="the-missing-well-known-symbol-symbolisabstractequal">The missing well-known Symbol: Symbol.isAbstractEqual</h3>
<p>You've probably figured it out by now - but I really like the idea of Symbols for Reflection. To me, there is one piece missing that would make them something I'd be really excited about: <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isAbstractEqual</span></code>. Having a <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isAbstractEqual</span></code> well known Symbol could bring the abstract equality operator (<code class="language-js highlighter-rouge"><span class="o">==</span></code>) back into popular usage. Being able to use it in your own way, for your own classes just like you can in Ruby, Python, and co. When you see code like <code class="language-js highlighter-rouge"><span class="nx">lho</span> <span class="o">==</span> <span class="nx">rho</span></code> it could be converted into <code class="language-js highlighter-rouge"><span class="nx">rho</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">isAbstractEqual</span><span class="p">](</span><span class="nx">lho</span><span class="p">)</span></code>, allowing classes to override what <code class="language-js highlighter-rouge"><span class="o">==</span></code> means to them. This could be done in a backwards compatible way - by defining defaults for all current primitive prototypes (e.g. <code class="language-js highlighter-rouge"><span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span></code>) and would tidy up a chunk of the spec, while giving developers a reason to bring <code class="language-js highlighter-rouge"><span class="o">==</span></code> back from the bench.</p>
<h2 id="conclusion">Conclusion</h2>
<p>What do you think about Symbols? Still confused? Just want to rant to someone? I'm <a href="https://twitter.com/keithamus">@keithamus over on the Twitterverse</a> - so feel free to hit me up there, who knows, one day I might be taking up your whole lunchtimes telling you about sweet new ES6 features I like way too much.</p>
<p>Now you're done reading all about Symbols, you should totally read <a href="/metaprogramming-in-es6-part-2-reflect/">Part 2 - Reflect</a>.</p>
<p>Also lastly I'd like to thank the excellent developers <a href="https://twitter.com/focusaurus">@focusaurus</a>, <a href="https://twitter.com/mttshw">@mttshw</a>, <a href="https://twitter.com/colby_russell">@colby_russell</a>, <a href="https://twitter.com/mdmazzola">@mdmazzola</a>, and <a href="https://twitter.com/WebReflection">@WebReflection</a> for proof reading this, and making much needed improvements.</p>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t06" name="t06"></a><h1>06 : Metaprogramming in ES6: Part 2 - Reflect</h1>
					<span class="ref-site">https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/</span>
					<div class="tutorial__content">
<section class="post-content">
<p>In <a href="/metaprogramming-in-es6-symbols/">my last post we had a look at Symbols</a>, and how they add useful new metaprogramming features to JavaScript. This time, we're (finally!) going to talk all about Reflect. If you haven't read <a href="/metaprogramming-in-es6-symbols/">Part 1: Symbols</a>, then I'd recommend you do. In the last post, I made a key point which I'm going to reiterate:</p>
<blockquote>
<ul>
<li>Symbols are all about Reflection within implementation - you sprinkle them on your existing classes and objects to change the behaviour.</li>
<li>Reflect is all about Reflection through introspection - used to discover very low level information about your code.</li>
<li>Proxy is all about Reflection through intercession - wrapping objects and intercepting their behaviours through traps.</li>
</ul>
</blockquote>
<p><code class="language-js highlighter-rouge"><span class="nx">Reflect</span></code> is a new global Object (like <code class="language-js highlighter-rouge"><span class="nx">JSON</span></code> or <code class="language-js highlighter-rouge"><span class="nb">Math</span></code>) that provides a bunch of useful introspection methods (introspection is really just a fancy word for "looking at stuff"). Introspection tools already exist in JavaScript; <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span></code>, <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code>, etc. So why the need for a new API when these could just be added to <code class="language-js highlighter-rouge"><span class="nb">Object</span></code>?</p>
<h3 id="internal-methods">"Internal Methods"</h3>
<p>All JavaScript specs, and therefore engines, come with a series of "internal methods". Effectively these let the JavaScript engine perform essential operations on your Objects as it hops around your code. If you read through the spec, you'll find these everywhere, things like <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Get</span><span class="p">]]</span></code>, <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Set</span><span class="p">]]</span></code>, <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">HasOwnProperty</span><span class="p">]]</span></code> and so on (if you're having trouble sleeping, the full list of internal methods in <a href="https://es5.github.io/#x8.12">ES5 Section 8.12</a>/<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-ordinary-object-internal-methods-and-internal-slots">ES6 Section 9.1</a>).</p>
<p>Some of these "internal methods" were hidden from JavaScript code, others were applied in part by some methods, and even if there were available, they were tucked away inside various crevices, for example <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span></code> is an implementation of <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">HasOwnProperty</span><span class="p">]]</span></code>, except not every object inherits from Object, and so you have to perform convoluted incantations just to use it - for example:</p>
<pre><code>var myObject = Object.create(null); // Happens more often than you might think (especially with new ES6 classes)
assert(myObject.hasOwnProperty === undefined);
// If you want to use hasOwnProperty on `myObject`:
Object.prototype.hasOwnProperty.call(myObject, 'foo');
</code></pre>
<p>As another example, the <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">OwnPropertyKeys</span><span class="p">]]</span></code> internal method gets all of an Objects String keys and Symbol keys as one Array. The only way to get these (outside of Reflect) is to combined the results of <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code> and <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span></code>:</p>
<pre><code>var s = Symbol('foo');
var k = 'bar';
var o = { [s]: 1, [k]: 1 };
// Simulate [[OwnPropertyKeys]]
var keys = Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
assert.deepEqual(keys, [k, s]);
</code></pre>
<h3 id="reflect-methods">Reflect methods</h3>
<p>Reflect is effectively a collection of all of those <em>"internal methods"</em> that were available exclusively through the JavaScript engine internals, now exposed in one single, handy object. You might be thinking "yeah, but why not just attach these to Object like <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span></code>, <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code> etc are?". Here is why:</p>
<ol>
<li>Reflect has methods that are not meant just for Objects, for example <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span></code> - which targets a Function. Calling <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">myFunction</span><span class="p">)</span></code> would just look weird.</li>
<li>Having a single object to house these methods is a great way to keep the rest of JavaScript clean, rather than dotting Reflection methods throughout constructors and prototypes - or worse - globals.</li>
<li><code class="language-js highlighter-rouge"><span class="k">typeof</span></code>, <code class="language-js highlighter-rouge"><span class="k">instanceof</span></code>, and <code class="language-js highlighter-rouge"><span class="k">delete</span></code> already exist as Reflection operators - adding new keywords like this is not only cumbersome for developers, but also a nightmare for backwards compatibility and explodes the number of reserved words.</li>
</ol>
<h5 id="reflectapply--target-thisargument--argumentslist-">Reflect.apply ( target, thisArgument [, argumentsList] )</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span></code> is pretty much just <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">apply</span></code> - it takes a function, and calls it with a context, and an array of arguments. From this point on you <em>could</em> consider the <code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">call</span></code>/<code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="err">#</span><span class="nx">apply</span></code> versions deprecated. This isn't mind blowing, but it makes good sense. Here's how you use it:</p>
<pre><code>var ages = [11, 33, 12, 54, 18, 96];

// Function.prototype style:
var youngest = Math.min.apply(Math, ages);
var oldest = Math.max.apply(Math, ages);
var type = Object.prototype.toString.call(youngest);

// Reflect style:
var youngest = Reflect.apply(Math.min, Math, ages);
var oldest = Reflect.apply(Math.max, Math, ages);
var type = Reflect.apply(Object.prototype.toString, youngest);
</code></pre>
<p>The real benefit of Reflect.apply over Function.prototype.apply is defensibility: any code could trivially change the functions <code class="language-js highlighter-rouge"><span class="nx">call</span></code> or <code class="language-js highlighter-rouge"><span class="nx">apply</span></code> method, leaving you stuck with broken code or horrible workarounds. This doesn't really end up being a huge deal in the real world, but code like the following could certainly exist:</p>
<pre><code>function totalNumbers() {
  return Array.prototype.reduce.call(arguments, function (total, next) {
    return total + next;
  }, 0);
}
totalNumbers.apply = function () {
  throw new Error('Aha got you!');
}

totalNumbers.apply(null, [1, 2, 3, 4]); // throws Error('Aha got you!');

// The only way to defensively do this in ES5 code is horrible:
Function.prototype.apply.call(totalNumbers, null, [1, 2, 3, 4]) === 10;

//You could also do this, which is still not much cleaner:
Function.apply.call(totalNumbers, null, [1, 2, 3, 4]) === 10;

// Reflect.apply to the rescue!
Reflect.apply(totalNumbers, null, [1, 2, 3, 4]) === 10;
</code></pre>
<h5 id="reflectconstruct--target-argumentslist--constructortocreatethis-">Reflect.construct ( target, argumentsList [, constructorToCreateThis] )</h5>
<p>Similar to <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span></code> - this lets you call a Constructor with a set of arguments. This will work with Classes, and sets up the correct object so that Constructors have the right <code class="language-js highlighter-rouge"><span class="k">this</span></code> object with the matching prototype. In ES5 land, you'd use the <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span></code> pattern, and pass that to <code class="language-js highlighter-rouge"><span class="nx">Constructor</span><span class="p">.</span><span class="nx">call</span></code> or <code class="language-js highlighter-rouge"><span class="nx">Constructor</span><span class="p">.</span><span class="nx">apply</span></code>. The difference with <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span></code> is that rather than passing an object, you just pass the constructor - and <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span></code> will handle all that jazz (alternatively, just omit it and it'll default to the <code class="language-js highlighter-rouge"><span class="nx">target</span></code> argument). The old style of doing this was quite cumbersome, the new style can be much more succinct, as little as a one liner:</p>
<pre><code>class Greeting {

    constructor(name) {
        this.name = name;
    }

    greet() {
      return `Hello ${name}`;
    }

}

// ES5 style factory:
function greetingFactory(name) {
    var instance = Object.create(Greeting.prototype);
    Greeting.call(instance, name);
    return instance;
}

// ES6 style factory
function greetingFactory(name) {
    return Reflect.construct(Greeting, [name], Greeting);
}

// Or, omit the third argument, and it will default to the first argument.
function greetingFactory(name) {
  return Reflect.construct(Greeting, [name]);
}

// Super slick ES6 one liner factory function!
const greetingFactory = (name) =&gt; Reflect.construct(Greeting, [name]);
</code></pre>
<h5 id="reflectdefineproperty--target-propertykey-attributes-">Reflect.defineProperty ( target, propertyKey, attributes )</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span></code> pretty much takes over from <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span></code> - it lets you define metadata about a property. It fits much better here because Object.* implies that it acts on object literals (it is, after all, the Object literal constructor), while Reflect.defineProperty just implies that what you're doing is Reflection, which is more semantic.</p>
<p>An important note is that <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span></code> - just like <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span></code> - will throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code> for invalid <code class="language-js highlighter-rouge"><span class="nx">target</span></code>s, such Number or String primitives ( <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span></code>). This is a good thing, because throwing errors for wrong argument types notifies you of problems much better than silently failing.</p>
<p>Once again, you could consider <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span></code> pretty much deprecated from here on out. Use <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span></code> instead.</p>
<pre><code>function MyDate() {
  /*…*/
}

// Old Style, weird because we're using Object.defineProperty to define
// a property on Function (why isn't there a Function.defineProperty?)
Object.defineProperty(MyDate, 'now', {
  value: () =&gt; currentms
});

// New Style, not weird because Reflect does Reflection.
Reflect.defineProperty(MyDate, 'now', {
  value: () =&gt; currentms
});

</code></pre>
<h5 id="reflectgetownpropertydescriptor--target-propertykey-">Reflect.getOwnPropertyDescriptor ( target, propertyKey )</h5>
<p>This, once again, pretty much replaces <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span></code>, getting the descriptor metadata of a property. The key difference is that while <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span></code> silently fails, returning <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span></code> will throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code> - it throws for invalid arguments, just like <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span></code> does. You're probably getting the idea by now - but <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span></code> pretty much deprecates <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span></code>.</p>
<pre><code>var myObject = {};
Object.defineProperty(myObject, 'hidden', {
  value: true,
  enumerable: false,
});
var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');
assert.deepEqual(theDescriptor, { value: true, enumerable: true });

// Old style
var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');
assert.deepEqual(theDescriptor, { value: true, enumerable: true });

assert(Object.getOwnPropertyDescriptor(1, 'foo') === undefined)
Reflect.getOwnPropertyDescriptor(1, 'foo'); // throws TypeError
</code></pre>
<h5 id="reflectdeleteproperty--target-propertykey-">Reflect.deleteProperty ( target, propertyKey )</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span></code> will, surprise surprise, delete a property off of the target object. Pre ES6, you'd typically write <code class="language-js highlighter-rouge"><span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span></code>, now you can write <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span></code>. This is slightly more verbose, and the semantics are slightly different to the delete keyword, but it has the same basic effect for objects. Both of them call the internal <code class="language-js highlighter-rouge"><span class="nx">target</span><span class="p">[[</span><span class="nx">Delete</span><span class="p">]](</span><span class="nx">propertyKey</span><span class="p">)</span></code> method - but the <code class="language-js highlighter-rouge"><span class="k">delete</span></code> operator also "works" for non-object references (i.e. variables), and so it does more checking on the operand passed to it, and has more potential to throw:</p>
<pre><code>var myObj = { foo: 'bar' };
delete myObj.foo;
assert(myObj.hasOwnProperty('foo') === false);

myObj = { foo: 'bar' };
Reflect.deleteProperty(myObj, 'foo');
assert(myObj.hasOwnProperty('foo') === false);
</code></pre>
<p>Once again, you could consider this to be the "new way" to delete properties - if you wanted to. It's certainly more explicit to its intention.</p>
<h5 id="reflectgetprototypeof--target-">Reflect.getPrototypeOf ( target )</h5>
<p>The theme of replacing/deprecating Object methods continues - this time <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span></code>. Just like its siblings, the new <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span></code> method will throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code> if you give it an invalid <code class="language-js highlighter-rouge"><span class="nx">target</span></code> such as a Number or String literal, <code class="language-js highlighter-rouge"><span class="kc">null</span></code> or <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>, where <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span></code> coerces the <code class="language-js highlighter-rouge"><span class="nx">target</span></code> to be an object - so <code class="language-js highlighter-rouge"><span class="s1">'a'</span></code> becomes <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span></code>. Syntax otherwise, is exactly the same.</p>
<pre><code>var myObj = new FancyThing();
assert(Reflect.getPrototypeOf(myObj) === FancyThing.prototype);

// Old style
assert(Object.getPrototypeOf(myObj) === FancyThing.prototype);

Object.getPrototypeOf(1); // undefined
Reflect.getPrototypeOf(1); // TypeError
</code></pre>
<h5 id="reflectsetprototypeof--target-proto-">Reflect.setPrototypeOf ( target, proto )</h5>
<p>Of course, you couldn't have <code class="language-js highlighter-rouge"><span class="nx">getPrototypeOf</span></code> without <code class="language-js highlighter-rouge"><span class="nx">setPrototypeOf</span></code>. Now, <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span></code> will throw for non-objects, but it tries to coerce the given argument into an Object, and also if the <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">SetPrototype</span><span class="p">]]</span></code> internal operation fails, it'll throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code>, if it succeeds it'll return the <code class="language-js highlighter-rouge"><span class="nx">target</span></code> argument. <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span></code> is much more basic - if it receives a non-object it'll throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code>, but other than that, it'll just return the result of <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">SetPrototypeOf</span><span class="p">]]</span></code> - which is a Boolean indicating if the operation was successful. This is useful because then you can manage
the outcome without resorting to using a <code class="language-js highlighter-rouge"><span class="k">try</span></code>/<code class="language-js highlighter-rouge"><span class="k">catch</span></code> which will also catch any other <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code>s from passing in incorrect arguments.</p>
<pre><code>var myObj = new FancyThing();
assert(Reflect.setPrototypeOf(myObj, OtherThing.prototype) === true);
assert(Reflect.getPrototypeOf(myObj) === OtherThing.prototype);

// Old style
assert(Object.setPrototypeOf(myObj, OtherThing.prototype) === myObj);
assert(Object.getPrototypeOf(myObj) === FancyThing.prototype);

Object.setPrototypeOf(1); // TypeError
Reflect.setPrototypeOf(1); // TypeError

var myFrozenObj = new FancyThing();
Object.freeze(myFrozenObj);

Object.setPrototypeOf(myFrozenObj); // TypeError
assert(Reflect.setPrototypeOf(myFrozenObj) === false);
</code></pre>
<h5 id="reflectisextensible-target">Reflect.isExtensible (target)</h5>
<p>Ok, once again this one is just a replacement of <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span></code> - but its a bit more complicated than that. Prior to ES6 (so… ES5) <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span></code> threw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code> if you fed it a non-object (<code class="language-js highlighter-rouge"><span class="k">typeof</span> <span class="nx">target</span> <span class="o">!==</span> <span class="s1">'object'</span></code>). ES6 semantics have changed this (Gasp! A change to the existing API!) so that passing in a non-object to <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span></code> will now return <code class="language-js highlighter-rouge"><span class="kc">false</span></code> - because non-objects are all not extensible. So code like <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span></code> would throw, whereas ES6 runs the statement like you'd expect (evaluating to true).</p>
<p>The point of the brief history lesson is that <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span></code> uses the <em>old</em> behavior, of throwing on non-objects. I'm not really sure why it does, but it does. So technically <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span></code> changes the semantics against <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span></code>, but <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span></code> changed anyway. Here's some code to illustrate:</p>
<pre><code>var myObject = {};
var myNonExtensibleObject = Object.preventExtensions({});

assert(Reflect.isExtensible(myObject) === true);
assert(Reflect.isExtensible(myNonExtensibleObject) === false);
Reflect.isExtensible(1); // throws TypeError
Reflect.isExtensible(false);  // throws TypeError

// Using Object.isExtensible
assert(Object.isExtensible(myObject) === true);
assert(Object.isExtensible(myNonExtensibleObject) === false);

// ES5 Object.isExtensible semantics
Object.isExtensible(1); // throws TypeError on older browsers
Object.isExtensible(false);  // throws TypeError on older browsers

// ES6 Object.isExtensible semantics
assert(Object.isExtensible(1) === false); // only on newer browsers
assert(Object.isExtensible(false) === false); // only on newer browsers
</code></pre>
<h5 id="reflectpreventextensions--target-">Reflect.preventExtensions ( target )</h5>
<p>This is the last method in the Reflection object that borrows from Object. This follows the same story as <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span></code>; ES5's <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span></code> used to throw on non-objects, but now in ES6 it returns the value back, while <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span></code> follows the old ES5 behaviour - throwing on non-objects. Also, while <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span></code> has the potential to throw, <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span></code> will simply return <code class="language-js highlighter-rouge"><span class="kc">true</span></code> or <code class="language-js highlighter-rouge"><span class="kc">false</span></code>, depending on the success of the operation, allowing you to gracefully handle the failure scenario.</p>
<pre><code>var myObject = {};
var myObjectWhichCantPreventExtensions = magicalVoodooProxyCode({});

assert(Reflect.preventExtensions(myObject) === true);
assert(Reflect.preventExtensions(myObjectWhichCantPreventExtensions) === false);
Reflect.preventExtensions(1); // throws TypeError
Reflect.preventExtensions(false);  // throws TypeError

// Using Object.isExtensible
assert(Object.isExtensible(myObject) === true);
Object.isExtensible(myObjectWhichCantPreventExtensions); // throws TypeError

// ES5 Object.isExtensible semantics
Object.isExtensible(1); // throws TypeError
Object.isExtensible(false);  // throws TypeError

// ES6 Object.isExtensible semantics
assert(Object.isExtensible(1) === false);
assert(Object.isExtensible(false) === false);
</code></pre>
<h5 id="reflectenumerate--target-">Reflect.enumerate ( target )</h5>
<div class="update-block">
<p>
Update: This was removed in ES2016 (aka ES7). <code class="language-js highlighter-rouge"><span class="nx">myObject</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span></code> is the only way to enumerate an Object's keys or values now.
</p>
</div>
<p>Finally a completely new Reflect method! <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">enumerate</span></code> uses the same semantics as the new <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code> function (discussed in the <a href="/metaprogramming-in-es6-symbols/">previous article</a>), both use the hidden <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Enumerate</span><span class="p">]]</span></code> method that JavaScript engines are aware of. In other words, the only alternative to <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">enumerate</span></code> is <code class="language-js highlighter-rouge"><span class="nx">myObject</span><span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span></code>, except of course the <code class="language-js highlighter-rouge"><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span></code> can be overridden, while <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">enumerate</span></code> can never be overridden. Used like so:</p>
<pre><code>var myArray = [1, 2, 3];
myArray[Symbol.enumerate] = function () {
  throw new Error('Nope!');
}
for (let item of myArray) { // error thrown: Nope!
}
for (let item of Reflect.enumerate(myArray)) {
  // 1 then 2 then 3
}
</code></pre>
<h5 id="reflectget--target-propertykey---receiver-">Reflect.get ( target, propertyKey [ , receiver ])</h5>
<p>Reflect.get is also a completely new method. It's quite a simple method; it effectively calls <code class="language-js highlighter-rouge"><span class="nx">target</span><span class="p">[</span><span class="nx">propertyKey</span><span class="p">]</span></code>. If <code class="language-js highlighter-rouge"><span class="nx">target</span></code> is a non-object, the function call will throw - which is good because currently if you were to do something like <code class="language-js highlighter-rouge"><span class="mi">1</span><span class="p">[</span><span class="s1">'foo'</span><span class="p">]</span></code> it just silently returns <code class="language-js highlighter-rouge"><span class="kc">undefined</span></code>, while <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)</span></code> will throw a <code class="language-js highlighter-rouge"><span class="nx">TypeError</span></code>! One interesting part of <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span></code> is the receiver argument, which essentially acts as the <code class="language-js highlighter-rouge"><span class="k">this</span></code> argument if <code class="language-js highlighter-rouge"><span class="nx">target</span><span class="p">[</span><span class="nx">propertyKey</span><span class="p">]</span></code> is a <em>getter</em> function, for example:</p>
<pre><code>var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
}

assert(Reflect.get(myObject, 'foo') === 1);
assert(Reflect.get(myObject, 'bar') === 2);
assert(Reflect.get(myObject, 'baz') === 3);
assert(Reflect.get(myObject, 'baz', myObject) === 3);

var myReceiverObject = {
  foo: 4,
  bar: 4,
};
assert(Reflect.get(myObject, 'baz', myReceiverObject) === 8);

// Non-objects throw:
Reflect.get(1, 'foo'); // throws TypeError
Reflect.get(false, 'foo'); // throws TypeError

// These old styles don't throw:
assert(1['foo'] === undefined);
assert(false['foo'] === undefined);
</code></pre>
<h5 id="reflectset--target-propertykey-v---receiver--">Reflect.set ( target, propertyKey, V [ , receiver ] )</h5>
<p>You can probably guess what this method does. It's the sibling to <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span></code>, and it takes one extra argument - the value to set. Just like <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span></code>, <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span></code> will throw on non-objects, and has a special <code class="language-js highlighter-rouge"><span class="nx">receiver</span></code> argument which acts as the <code class="language-js highlighter-rouge"><span class="k">this</span></code> value if <code class="language-js highlighter-rouge"><span class="nx">target</span><span class="p">[</span><span class="nx">propertyKey</span><span class="p">]</span></code> is a <em>setter</em> function. Obligatory code example:</p>
<pre><code>var myObject = {
  foo: 1,
  set bar(value) {
    return this.foo = value;
  },
}

assert(myObject.foo === 1);
assert(Reflect.set(myObject, 'foo', 2));
assert(myObject.foo === 2);
assert(Reflect.set(myObject, 'bar', 3));
assert(myObject.foo === 3);
assert(Reflect.set(myObject, 'bar', myObject) === 4);
assert(myObject.foo === 4);

var myReceiverObject = {
  foo: 0,
};
assert(Reflect.set(myObject, 'bar', 1, myReceiverObject));
assert(myObject.foo === 4);
assert(myReceiverObject.foo === 1);

// Non-objects throw:
Reflect.set(1, 'foo', {}); // throws TypeError
Reflect.set(false, 'foo', {}); // throws TypeError

// These old styles don't throw:
1['foo'] = {};
false['foo'] = {};
assert(1['foo'] === undefined);
assert(false['foo'] === undefined);
</code></pre>
<h5 id="reflecthas--target-propertykey-">Reflect.has ( target, propertyKey )</h5>
<p><code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span></code> is an interesting one, because it is essentially the same functionality
as the <code class="language-js highlighter-rouge"><span class="k">in</span></code> operator (outside of a loop). Both use the <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">HasProperty</span><span class="p">]]</span></code> internal method, and both throw if the <code class="language-js highlighter-rouge"><span class="nx">target</span></code> isn't an object. Because of this there's little point in using <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span></code> over <code class="language-js highlighter-rouge"><span class="k">in</span></code> unless you prefer the function-call style, but it has important use in other parts of the language, which will become clear in the next post. Anyway, here's how you use it:</p>
<pre><code>myObject = {
  foo: 1,
};
Object.setPrototypeOf(myObject, {
  get bar() {
    return 2;
  },
  baz: 3,
});

// Without Reflect.has
assert(('foo' in myObject) === true);
assert(('bar' in myObject) === true);
assert(('baz' in myObject) === true);
assert(('bing' in myObject) === false);

// With Reflect.has:
assert(Reflect.has(myObject, 'foo') === true);
assert(Reflect.has(myObject, 'bar') === true);
assert(Reflect.has(myObject, 'baz') === true);
assert(Reflect.has(myObject, 'bing') === false);
</code></pre>
<h5 id="reflectownkeys--target-">Reflect.ownKeys ( target )</h5>
<p>This has already been discussed a tiny bit in this article, you see <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span></code> implements <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">OwnPropertyKeys</span><span class="p">]]</span></code> which if you recall above is a combination of <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code> and <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span></code>. This makes <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span></code> uniquely useful. Lets see shall we:</p>
<pre><code>var myObject = {
  foo: 1,
  bar: 2,
  [Symbol.for('baz')]: 3,
  [Symbol.for('bing')]: 4,
};

assert.deepEqual(Object.getOwnPropertyNames(myObject), ['foo', 'bar']);
assert.deepEqual(Object.getOwnPropertySymbols(myObject), [Symbol.for('baz'), Symbol.for('bing')]);

// Without Reflect.ownKeys:
var keys = Object.getOwnPropertyNames(myObject).concat(Object.getOwnPropertySymbols(myObject));
assert.deepEqual(keys, ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]);

// With Reflect.ownKeys:
assert.deepEqual(Reflect.ownKeys(myObject), ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]);
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>We've pretty exhaustively gone over every Reflect method. We've seen some are newer versions of common existing methods, sometimes with a few tweaks, and some are entirely new methods - allowing new levels of Reflection within JavaScript. If you want to - you could totally ditch <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="o">*</span></code>/<code class="language-js highlighter-rouge"><span class="nb">Function</span><span class="p">.</span><span class="o">*</span></code> methods and use the new <code class="language-js highlighter-rouge"><span class="nx">Reflect</span></code> ones instead, if you don't want to - don't sweat it, nothing bad will happen.</p>
<p>Now, I don't want you to go away empty handed. If you want to use <code class="language-js highlighter-rouge"><span class="nx">Reflect</span></code>, then I've got your back - as part of the work behind this post, I submitted a <a href="https://github.com/eslint/eslint/pull/2996">pull request to eslint</a> and as of <code class="language-js highlighter-rouge"><span class="nx">v1</span><span class="p">.</span><span class="mf">0.0</span></code>, <a href="http://eslint.org/docs/rules/prefer-reflect">ESlint has a <code class="language-js highlighter-rouge"><span class="nx">prefer</span><span class="o">-</span><span class="nx">reflect</span></code> rule</a> which you can use to get ESLint to tell you off when you use the older version of Reflect methods. You could also take a look at my <a href="https://github.com/keithamus/eslint-config-strict">eslint-config-strict</a> config, which has the <code class="language-js highlighter-rouge"><span class="nx">prefer</span><span class="o">-</span><span class="nx">reflect</span></code> turned on (plus a bunch of others). Of course, if you decide you want to use Reflect, you'll probably need to polyfill it; luckily there's some good polyfills out there, such as <a href="https://github.com/zloirock/core-js">core-js</a> and <a href="https://github.com/tvcutsem/harmony-reflect">harmony-reflect</a>.</p>
<p>What do you think about the new Reflect API? Plan on using it in your project? Let me know, in the comments below or on Twitter, where I'm <a href="https://twitter.com/keithamus">@keithamus</a>.</p>
<p>Oh - also don't forget, the third and final part of this series - Part 3 Proxies - will be out soon, and I'll try not to take 2 months to release it again!</p>
<p>Lastly, thanks to <a href="https://twitter.com/mttshw">@mttshw</a> and <a href="https://twitter.com/WebReflection">@WebReflection</a> for scrutinising my work and making this post much better than it would have been.</p>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t07" name="t07"></a><h1>07 : Metaprogramming in ES6: Part 3 - Proxies</h1>
					<span class="ref-site">https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-3-proxies/</span>
					<div class="tutorial__content">
<section class="post-content">
<p>In the third and final installment of my Metaprogramming in ES6 series - remember, those posts I wrote over a year ago and promised I wouldn't take ages to complete but did? In this last post, we'll be looking at possibly the coolest ES6 Reflection feature: Proxies. Those of you versed in my back catalogue will have already read <a href="/metaprogramming-in-es6-part-2-reflect/">my last post, when we had a look at the ES6 Reflect API</a>, and <a href="/metaprogramming-in-es6-symbols/">the post before where we took a look at ES6 Symbols</a> - those of you haven't should go ahead and get versed, the Reflect will be particularly relevant here and is required reading before we continue. Just like the other posts, I'm going to quote a point I made in Part 1:</p>
<blockquote>
<ul>
<li>Symbols are all about Reflection within implementation - you sprinkle them on your existing classes and objects to change the behaviour.</li>
<li>Reflect is all about Reflection through introspection - used to discover very low level information about your code.</li>
<li>Proxy is all about Reflection through intercession - wrapping objects and intercepting their behaviours through traps.</li>
</ul>
</blockquote>
<p>So, <code class="language-js highlighter-rouge"><span class="nx">Proxy</span></code> is a new global constructor (like <code class="language-js highlighter-rouge"><span class="nb">Date</span></code> or <code class="language-js highlighter-rouge"><span class="nb">Number</span></code>) that you pass an Object, a bunch of hooks, and it spits out a <em>new</em> Object that wraps the old one with all these fancy hooks. Voilà, you have a proxy! Post over, hope you enjoyed it, let's all go home!</p>
<p>Ok, so there's definitely some more to it. For starters, let's have a look at the constructor.</p>
<h3 id="creating-proxies">Creating Proxies</h3>
<p>The Proxy constructor takes two arguments, an initial Object that you want to proxy, and a set of handler hooks. Let's forget about the hooks for the moment and take a look at how we create proxies on objects. The clue is in the name with Proxies: they hold a reference to the Object you create, but if you have a reference to the original Object then you can still interact with it, and the Proxy will also be affected, similarly, any alterations you make with Proxy will be reflected onto the original object. In other words, Proxies return a new object which wraps the passed in object, but anything you do with either effects the other. To demonstrate:</p>
<pre><code>var myObject = {};
var proxiedMyObject = new Proxy(myObject, {/*handler hooks*/});

assert(myObject !== proxiedMyObject);

myObject.foo = true;
assert(proxiedMyObject.foo === true);

proxiedMyObject.bar = true;
assert(myObject.bar === true);
</code></pre>
<p>So far we've achieved nothing, our Proxy doesn't give us any benefits over just using the normal object. To do interesting stuff with it, we'll need to use the handler hooks.</p>
<h3 id="proxy-handler-hooks">Proxy Handler Hooks</h3>
<p>The handler hooks are a set of functions, each one has a specific name that Proxy is aware of, and each one controls the behaviour of how you interact with the Proxy (and therefore, its wrapped object). The handler hooks JavaScript's "internal methods", and if this is sounding familiar that's because we already discussed Internal Methods in <a href="/metaprogramming-in-es6-part-2-reflect/#internal-methods">the post on the Reflect API</a>.</p>
<p>Ok, it's time to spill the beans. There's a good reason I saved Proxy until last; that's because we needed to understand how Reflect works, because Proxy and Reflect are intertwined, like star crossed lovers. You see, every handler hook Proxy has Reflect has a method for, or to put it another way, every one of the Reflect methods has a Proxy Handler Hook. The full list of Reflect methods/Proxy handler hooks is:</p>
<ul>
<li><code class="language-js highlighter-rouge"><span class="nx">apply</span></code> (call a function with a <code class="language-js highlighter-rouge"><span class="k">this</span></code> argument and a set of <code class="language-js highlighter-rouge"><span class="nx">arguments</span></code>)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">construct</span></code> (call a class/constructor function with a set of <code class="language-js highlighter-rouge"><span class="nx">arguments</span></code> and optional constructor for prototype)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">defineProperty</span></code> (define a property on an Object, including metadata about its enumerability and whatnot)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">getOwnPropertyDescriptor</span></code> (get a properties "property descriptor": the metadata about an object property such as its enumerability)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">deleteProperty</span></code> (delete a property from an object)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">getPrototypeOf</span></code> (get an instances prototype)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">setPrototypeOf</span></code> (set an instances prototype)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">isExtensible</span></code> (determine if an object is "extensible" (can have properties added to it))</li>
<li><code class="language-js highlighter-rouge"><span class="nx">preventExtensions</span></code> (prevent the object from being extensible)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">get</span></code> (get the value of a property on an object)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">set</span></code> (set the value of a property on an object)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">has</span></code> (check if an object has a particular property without asserting on the value)</li>
<li><code class="language-js highlighter-rouge"><span class="nx">ownKeys</span></code> (retreive all of the own keys of a Object: the keys it has, but not the keys its prototype has)</li>
</ul>
<p>We went over all of these methods (with code samples) in the <a href="/metaprogramming-in-es6-part-2-reflect/">Reflect post</a> (one more time: go read it if you haven't). Proxy implements every one of these, with exactly the same argument set. In fact, Proxy's default behaviour essentially implements Reflect calls for every handler hook (the internal mechanics of JavaScript engines might be slightly different, but we can just pretend that unspecified hooks will just default to their Reflect counterparts). This also means that any hook you don't specify will behave just like it normally would, as if it was never proxied:</p>
<pre><code>// Here is a Proxy where we're defining the same behaviour as the default:
proxy = new Proxy({}, {
  apply: Reflect.apply,
  construct: Reflect.construct,
  defineProperty: Reflect.defineProperty,
  getOwnPropertyDescriptor: Reflect.getOwnPropertyDescriptor,
  deleteProperty: Reflect.deleteProperty,
  getPrototypeOf: Reflect.getPrototypeOf,
  setPrototypeOf: Reflect.setPrototypeOf,
  isExtensible: Reflect.isExtensible,
  preventExtensions: Reflect.preventExtensions,
  get: Reflect.get,
  set: Reflect.set,
  has: Reflect.has,
  ownKeys: Reflect.ownKeys,
});
</code></pre>
<p>Now, I could go into detail about how each of these Proxy handler hooks works, but it'd basically be me copy/pasting the Reflect examples with a few minor edits. It'd also be a bit unfair for Proxy, because Proxy is all about the cool use cases, not the utility of individual methods. So the rest of this post is going to show you cool things you can do with proxies, including some you could never do without them.</p>
<p>Also, to make things a bit more interactive, I've created small libraries for each of the examples, which demonstrate the functionality. I'll link the repos to each example.</p>
<h3 id="using-proxy-to">Using Proxy to…</h3>
<h4 id="make-an-infinitely-chainable-api">…make an infinitely chainable API</h4>
<p>Building on the previous example - using the same <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Get</span><span class="p">]]</span></code> trap: with a little bit more magic we can make an API which has an infinite number of methods, and when you finally call one of those it'll return everything you chained. This could be useful, for example, in making a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API</a> that constructs URLs for web requests, or maybe some kind of Test Assertion framework that chains together English words to make readable assertions, kind of like <a href="https://github.com/chaijs/chai">Chai</a>.</p>
<p>For this we need to hook into <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Get</span><span class="p">]]</span></code>, and push the retrieved prop into an array. The Proxy will wrap a function which returns the Array of all retrieved props and empty the array, so it can be re-used. We'll also hook into <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">HasProperty</span><span class="p">]]</span></code> because, like before, we want to demonstrate to our users that any property exists.</p>
<pre><code>function urlBuilder(domain) {
  var parts = [];
  var proxy = new Proxy(function () {
    var returnValue = domain + '/' + parts.join('/');
    parts = [];
    return returnValue;
  }, {
    has: function () {
      return true;
    },
    get: function (object, prop) {
      parts.push(prop);
      return proxy;
    },
  });
  return proxy;
}
var google = urlBuilder('http://google.com');
assert(google.search.products.bacon.and.eggs() === 'http://google.com/search/products/bacon/and/eggs')
</code></pre>
<p>You could also use this same pattern to make a tree traversal fluent API, something like you might see as part of jQuery or perhaps a React selector tool:</p>
<pre><code>function treeTraverser(tree) {
  var parts = [];
  var proxy = new Proxy(function (parts) {
    let node = tree; // start the node at the root
    for (part of parts) {
      if (!node.props || !node.props.children || node.props.children.length === 0) {
        throw new Error(`Node ${node.tagName} has no more children`);
      }
      // If the part is a child tag, drill down into that child for the next traversal step
      let index = node.props.children.findIndex((child) =&gt; child.tagName == part);
      if(index === -1) {
        throw new Error(`Cannot find child: ${part} in ${node.tagName}`);
      }
      node = node.props.children[index];
    }
    return node.props;
  }, {
    has: function () {
      return true;
    },
    get: function () {
      parts.push(prop);
      return proxy;
    }
  });
  return proxy;
}
var myDomIsh = treeTraverserExample({
  tagName: 'body',
  props: {
    children: [
      {
        tagName: 'div',
        props: {
          className: 'main',
          children: [
            {
              tagName: 'span',
              props: {
                className: 'extra',
                children: [
                  { tagName: 'i', props: { textContent: 'Hello' } },
                  { tagName: 'b', props: { textContent: 'World' } },
                ]
              }
            }
          ]
        }
      }
    ]
  }
});
assert(myDomIsh.div.span.i().textContent === 'Hello');
assert(myDomIsh.div.span.b().textContent === 'World');
</code></pre>
<p>I've made a slightly more reusable version of this over at <a href="https://github.com/keithamus/proxy-fluent-api">github.com/keithamus/proxy-fluent-api</a>, available on npm with the same name.</p>
<h4 id="implement-a-method-missing-hook">…implement a "method missing" hook</h4>
<p>Various other programming languages give you the ability to override the behaviour of a class using a well-known reflection methods, for example in PHP it is <code class="language-js highlighter-rouge"><span class="nx">__call</span></code>, in Ruby it is <code class="language-js highlighter-rouge"><span class="nx">method_missing</span></code>, in Python you can emulate this behaviour with <code class="language-js highlighter-rouge"><span class="nx">__getattr__</span></code>. JavaScript has no such mechanism - but now we have Proxies which allow us to do cool things like this.</p>
<p>To get an idea of what we're after, let's look at a Ruby example for some inspiration:</p>
<pre><code>class Foo
  def bar()
    print "you called bar. Good job!"
  end
  def method_missing(method)
    print "you called `#{method}` but it doesn't exist!"
  end
end

foo = Foo.new
foo.bar()
#=&gt; you called bar. Good job!
foo.this_method_does_not_exist()
#=&gt; you called this_method_does_not_exist but it doesn't exist
</code></pre>
<p>So for any method that exists, in this case <code class="language-js highlighter-rouge"><span class="nx">bar</span></code>, that method is executed like you'd expect. For methods which don't exist, like <code class="language-js highlighter-rouge"><span class="nx">foo</span></code> or <code class="language-js highlighter-rouge"><span class="nx">this_method_does_not_exist</span></code>, then the <code class="language-js highlighter-rouge"><span class="nx">method_missing</span></code> method is executed in place of it. In addition, it gets the called method name as the first argument, which is super useful for determining what the user wanted.</p>
<p>We could do something similar with a mixture of ES6 Symbols, and a function that can wrap the class and return a Proxy with the <code class="language-js highlighter-rouge"><span class="nx">get</span></code> (<code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Get</span><span class="p">]]</span></code>) trap:</p>
<pre><code>function Foo() {
  return new Proxy(this, {
    get: function (object, property) {
      if (Reflect.has(object, property)) {
        return Reflect.get(object, property);
      } else {
        return function methodMissing() {
          console.log('you called ' + property + ' but it doesn\'t exist!');
        }
      }
    }
  });
}

Foo.prototype.bar = function () {
  console.log('you called bar. Good job!');
}

foo = new Foo();
foo.bar();
//=&gt; you called bar. Good job!
foo.this_method_does_not_exist()
//=&gt; you called this_method_does_not_exist but it doesn't exist
</code></pre>
<p>This really comes into use where you have a set of methods whose functionality is largely the same, where the differences can be inferred from the method name. Effectively moving what would be function parameters into the function name for a more readable syntax. As an example of this - you could quickly and easily make an API for switching between two pairs of values like currencies, or perhaps bases:</p>
<pre><code>const baseConvertor = new Proxy({}, {
  get: function baseConvert(object, methodName) {
    var methodParts = methodName.match(/base(\d+)toBase(\d+)/);
    var fromBase = methodParts &amp;&amp; methodParts[1];
    var toBase = methodParts &amp;&amp; methodParts[2];
    if (!methodParts || fromBase &gt; 36 || toBase &gt; 36 || fromBase &lt; 2 || toBase &lt; 2) {
      throw new Error('TypeError: baseConvertor' + methodName + ' is not a function');
    }
    return function (fromString) {
      return parseInt(fromString, fromBase).toString(toBase);
    }
  }
});

baseConvertor.base16toBase2('deadbeef') === '11011110101011011011111011101111';
baseConvertor.base2toBase16('11011110101011011011111011101111') === 'deadbeef';
</code></pre>
<p>Of course, you could manually type out all 1,296 permutations of the available methods, or make a loop to create all of those methods individually, but both require much more code.</p>
<p>A more concrete example of this exists in Ruby on Rails ActiveRecord, which comes with "dynamic finders". It essentially implements <code class="language-js highlighter-rouge"><span class="nx">method_missing</span></code> to allow you to query a table by its columns. Rather than passing in a complex object, your parameters become values matched to the method name, for example:</p>
<pre><code>Users.find_by_first_name('Keith'); # [ Keith Cirkel, Keith Urban, Keith David ]
Users.find_by_first_name_and_last_name('Keith', 'David');  # [ Keith David ]
</code></pre>
<p>We could implement something similar in JavaScript using our above pattern:</p>
<pre><code>function RecordFinder(options) {
  this.attributes = options.attributes;
  this.table = options.table;
  return new Proxy({}, function findProxy(methodName) {
    var match = methodName.match(new RegExp('findBy((?:And)' + this.attributes.join('|') + ')'));
    if (!match){
      throw new Error('TypeError: ' + methodName + ' is not a function');
    }
  });
});
</code></pre>
<p>Like the rest of these examples, I've made a little lib out of this - over at <a href="https://github.com/keithamus/proxy-method-missing">github.com/keithamus/proxy-method-missing</a>.
It's on npm too.</p>
<h4 id="hide-all-properties-from-all-enumeration-methods-including-getownpropertynames-objectkeys-in-etc">…hide all properties from all enumeration methods including <code class="language-js highlighter-rouge"><span class="nx">getOwnPropertyNames</span></code>, <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span></code>, <code class="language-js highlighter-rouge"><span class="k">in</span></code> etc.</h4>
<p>We can use Proxies to make every property in an object completely hidden, except for when getting the value. Here's all of the ways you can find out if a property exists on an Object in JavaScript:</p>
<ul>
<li><code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span></code>,<code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">hasOwnProperty</span></code>,<code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span></code>, and the <code class="language-js highlighter-rouge"><span class="k">in</span></code> operator all use <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">HasProperty</span><span class="p">]]</span></code>. Proxy can trap this with <code class="language-js highlighter-rouge"><span class="nx">has</span></code>.</li>
<li><code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span></code>/<code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span></code>, which uses <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">OwnPropertyKeys</span><span class="p">]]</span></code>. Proxy can trap this with <code class="language-js highlighter-rouge"><span class="nx">ownKeys</span></code>.</li>
<li><code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span></code> (an upcoming ES2017 feature), also uses <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">OwnPropertyKeys</span><span class="p">]]</span></code> - again - trapped by <code class="language-js highlighter-rouge"><span class="nx">ownKeys</span></code>.</li>
<li><code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span></code> which uses <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">GetOwnProperty</span><span class="p">]]</span></code>. Proxy can trap this with, surprise surprise, <code class="language-js highlighter-rouge"><span class="nx">getOwnPropertyDescriptor</span></code>.</li>
</ul>
<pre><code>var example = new Proxy({ foo: 1, bar: 2 }, {
  has: function () { return false; },
  ownKeys: function () { return []; },
  getOwnPropertyDescriptor: function () { return false; },
});
assert(example.foo === 1);
assert(example.bar === 2);
assert('foo' in example === false);
assert('bar' in example === false);
assert(example.hasOwnProperty('foo') === false);
assert(example.hasOwnProperty('bar') === false);
assert.deepEqual(Object.keys(example), [ ]);
assert.deepEqual(Object.getOwnPropertyNames(example), [ ]);
</code></pre>
<p>I'm not going to lie, I cannot think of any super useful uses of this pattern. Nevertheless, I have made a library to go with this, available at <a href="https://github.com/keithamus/proxy-hide-properties">github.com/keithamus/proxy-hide-properties</a> which also lets you specify individual properties to hide, rather than blanket hiding all properties.</p>
<h4 id="implement-the-observer-pattern-aka-objectobserve">…implement the Observer pattern, aka Object.observe.</h4>
<p>Those of you who keenly follow the additions of new specs may have noticed <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">observe</span></code> being considered for inclusion in ES2016. Recently, however, the champions of <code class="language-js highlighter-rouge"><span class="nb">Object</span><span class="p">.</span><span class="nx">observe</span></code> have planned to <a href="https://esdiscuss.org/topic/an-update-on-object-observe">withdraw their proposal to include Object.observe</a>, and with good reason: it was originally created to answer a problem framework authors had around Data Binding. Now, with React and Polymer 1.0, the trend of data binding frameworks is declining, and instead immutable data structures are becoming more prevalent.</p>
<p>Thankfully, Proxy actually makes specs like Object.observe redundant, as now we have a low level API through Proxy, we can actually implement something like Object.observe. To get close feature parity with Object.observe, we need to hook on the <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Set</span><span class="p">]]</span></code>, <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">PreventExtensions</span><span class="p">]]</span></code>, <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">Delete</span><span class="p">]]</span></code>, and <code class="language-js highlighter-rouge"><span class="p">[[</span><span class="nx">DefineOwnProperty</span><span class="p">]]</span></code> internal methods - that's the <code class="language-js highlighter-rouge"><span class="nx">set</span></code>, <code class="language-js highlighter-rouge"><span class="nx">preventExtensions</span></code>, <code class="language-js highlighter-rouge"><span class="nx">deleteProperty</span></code> and <code class="language-js highlighter-rouge"><span class="nx">defineProperty</span></code> Proxy traps respectively:</p>
<pre><code>function observe(object, observerCallback) {
  var observing = true;
  const proxyObject = new Proxy(object, {
    set: function (object, property, value) {
      var hadProperty = Reflect.has(object, property);
      var oldValue = hadProperty &amp;&amp; Reflect.get(object, property);
      var returnValue = Reflect.set(object, property, value);
      if (observing &amp;&amp; hadProperty) {
        observerCallback({ object: proxyObject, type: 'update', name: property, oldValue: oldValue });
      } else if(observing) {
        observerCallback({ object: proxyObject, type: 'add', name: property });
      }
      return returnValue;
    },
    deleteProperty: function (object, property) {
      var hadProperty = Reflect.has(object, property);
      var oldValue = hadProperty &amp;&amp; Reflect.get(object, property);
      var returnValue = Reflect.deleteProperty(object, property);
      if (observing &amp;&amp; hadProperty) {
        observerCallback({ object: proxyObject, type: 'delete', name: property, oldValue: oldValue });
      }
      return returnValue;
    },
    defineProperty: function (object, property, descriptor) {
      var hadProperty = Reflect.has(object, property);
      var oldValue = hadProperty &amp;&amp; Reflect.getOwnPropertyDescriptor(object, property);
      var returnValue = Reflect.defineProperty(object, property, descriptor);
      if (observing &amp;&amp; hadProperty) {
        observerCallback({ object: proxyObject, type: 'reconfigure', name: property, oldValue: oldValue });
      } else if(observing) {
        observerCallback({ object: proxyObject, type: 'add', name: property });
      }
      return returnValue;
    },
    preventExtensions: function (object) {
      var returnValue = Reflect.preventExtensions(object);
      if (observing) {
        observerCallback({ object: proxyObject, type: 'preventExtensions' })
      }
      return returnValue;
    },
  });
  return { object: proxyObject, unobserve: function () { observing = false } };
}

var changes = [];
var observer = observe({ id: 1 }, (change) =&gt; changes.push(change));
var object = observer.object;
var unobserve = observer.unobserve;
object.a = 'b';
object.id++;
Object.defineProperty(object, 'a', { enumerable: false });
delete object.a;
Object.preventExtensions(object);
unobserve();
object.id++;
assert.equal(changes.length, 5);
assert.equal(changes[0].object, object);
assert.equal(changes[0].type, 'add');
assert.equal(changes[0].name, 'a');
assert.equal(changes[1].object, object);
assert.equal(changes[1].type, 'update');
assert.equal(changes[1].name, 'id');
assert.equal(changes[1].oldValue, 1);
assert.equal(changes[2].object, object);
assert.equal(changes[2].type, 'reconfigure');
assert.equal(changes[2].oldValue.enumerable, true);
assert.equal(changes[3].object, object);
assert.equal(changes[3].type, 'delete');
assert.equal(changes[3].name, 'a');
assert.equal(changes[4].object, object);
assert.equal(changes[4].type, 'preventExtensions');
</code></pre>
<p>As you can see, we have a relatively complete Object.observe implementation in a small chunk of code. The main differences between the proposed spec and this implementation is that Object.observe could mutate an object, where as Proxy has to return a new one - that and the unobserve function is not a global.</p>
<h2 id="bonus-round-revocable-proxies">Bonus Round: Revocable Proxies</h2>
<p>Proxies have one last trick up their sleeve: some Proxies can be revoked. To create a revocable Proxy, you need to use <code class="language-js highlighter-rouge"><span class="nx">Proxy</span><span class="p">.</span><span class="nx">revocable</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span></code> (instead of <code class="language-js highlighter-rouge"><span class="k">new</span> <span class="nx">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span></code>), and instead of returning the Proxy directly, it'll return an Object that looks like <code class="language-js highlighter-rouge"><span class="p">{</span> <span class="nx">proxy</span><span class="p">,</span> <span class="nx">revoke</span><span class="p">(){}</span> <span class="p">}</span></code>. An example:</p>
<pre><code>function youOnlyGetOneSafetyNet(object) {
  var revocable = Proxy.revocable(object, {
    get(property) {
      if (Reflect.has(this, property)) {
        return Reflect.get(this, property);
      } else {
        revocable.revoke();
        return 'You only get one safety net';
      }
    }
  });
  return revocable.proxy;
}


var myObject = youOnlyGetOneSafetyNet({ foo: true });

assert(myObject.foo === true);
assert(myObject.foo === true);
assert(myObject.foo === true);

assert(myObject.bar === 'You only get one safety net');
myObject.bar // TypeError
myObject.bar // TypeError
Reflect.has(myObject, 'bar') // TypeError
</code></pre>
<p>Sadly, as you can see right at the end in the example, a revoked Proxy will throw a TypeError when any of the handlers are triggered - even if those handlers haven't been set. I feel like this neuters the ability of a Revocable Proxy. If all handlers returned to their Reflect equivalents (effectively making the Proxy redundant, and the object behave as if the Proxy was never in place) this would make for a much more useful feature. Sadly, that isn't the case. As such this feature has been left in the proverbial footnotes of this post, as I'm not really sure of a concrete use case for a revocable Proxy.</p>
<p>Like the other examples, this one has been codified up, and is available at <a href="https://github.com/keithamus/proxy-object-observe">github.com/keithamus/proxy-object-observe</a> - and also on npm.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this post has shown you that Proxy is an incredibly powerful tool for messing with (what used to be) JavaScript internals. In many ways, Symbol, Reflect, and Proxy are opening up a new chapter of JavaScript - in as much as const and let, or classes and arrow functions. While const &amp; let make code less confusing, and classes &amp; arrow functions make code more terse, Symbol, Reflect, and Proxy are beginning to give developers really low level metaprogramming hooks within JavaScript.</p>
<p>These new metaprogramming tools are also not slowing down any time soon: new proposals for future EcmaScript versions are shaping up and adding additional interesting behaviours, such as <a href="https://github.com/caitp/TC39-Proposals/blob/master/tc39-reflect-isconstructor-iscallable.md">this proposal for <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isCallable</span></code> &amp; <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">isConstructor</span></code></a>, <a href="https://github.com/alex-weej/es-reflect-type-proposal">or this stage 0 proposal for <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">type</span></code></a>, or <a href="https://github.com/allenwb/ESideas/blob/master/Generator%20metaproperty.md">this proposal for <code class="language-js highlighter-rouge"><span class="kd">function</span><span class="p">.</span><span class="nx">sent</span></code> meta property</a>, <a href="https://github.com/allenwb/ESideas/blob/master/ES7MetaProps.md">or this one for a bunch more function metaproperties</a>. Also, these new APIs have inspired some interesting discussions about some great new features, such as <a href="https://esdiscuss.org/topic/reflect-parse-from-re-typeof-null">this proposal about adding <code class="language-js highlighter-rouge"><span class="nx">Reflect</span><span class="p">.</span><span class="nx">parse</span></code></a>, subsequently leading to discussion around making a AST (Abstract Syntax Tree) standard.</p>
<p>What do you think about the new Proxy API? Plan on using it in your project? Let me know, in the comments below or on Twitter, where I'm <a href="https://twitter.com/keithamus">@keithamus</a>.</p>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t08" name="t08"></a><h1>08 : ES6 Spread and Butter in Depth</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6-spread-and-butter-in-depth</span>
					<div class="tutorial__content">
<section class="md-markdown at-body">
	<h2 id="rest-parameters"><a href="#rest-parameters" class="md-heading">Rest parameters</a></h2> <p>You know how sometimes there's a ton of arguments and you end up having to use the <code class="md-code md-code-inline">arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p> <pre><code>function concat () {
  return Array.prototype.slice.call(arguments).join(' ')
}
var result = concat('this', 'was', 'no', 'fun')
console.log(result)
// &lt;- 'this was no fun'
</code></pre> <p>The rest parameters syntax enables you to pull a real <code class="md-code md-code-inline">Array</code> out of the <code class="md-code md-code-inline">function</code>'s arguments by adding a parameter name prefixed by <code class="md-code md-code-inline">...</code>. Definitely simpler, the fact that it's a real <code class="md-code md-code-inline">Array</code> is also very convenient, and I for one am glad not to have to resort to <code class="md-code md-code-inline">arguments</code> anymore.</p> <pre><code>function concat (...words) {
  return words.join(' ')
}
var result = concat('this', 'is', 'okay')
console.log(result)
// &lt;- 'this is okay'
</code></pre> <p>When you have more parameters in your <code class="md-code md-code-inline">function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p> <ul> <li>Rest parameter gets all the <code class="md-code md-code-inline">arguments</code> passed to the function call</li> <li>Each time a parameter is added on the left, it's as if its value is assigned by calling <code class="md-code md-code-inline">rest.shift()</code></li> <li>Note that you can't actually place parameters to the right: rest parameters can only be the last argument</li> </ul> <p>It's easier to visualize how that would behave than try to put it into words, so let's do that. The method below computes the <code class="md-code md-code-inline">sum</code> for all <code class="md-code md-code-inline">arguments</code> except the first one, which is then used as a <code class="md-code md-code-inline">multiplier</code> for the <code class="md-code md-code-inline">sum</code>. In case you don't recall, <code class="md-code md-code-inline">.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p> <pre><code>function sum () {
  var numbers = Array.prototype.slice.call(arguments) // numbers gets all arguments
  var multiplier = numbers.shift()
  var base = numbers.shift()
  var sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  return multiplier * sum
}
var total = sum(2, 6, 10, 8, 9)
console.log(total)
// &lt;- 66
</code></pre> <p>Here's how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don't need to use <code class="md-code md-code-inline">arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method – which now can focus on its functionality itself and not so much on rebalancing <code class="md-code md-code-inline">arguments</code>.</p> <pre><code>function sum (multiplier, base, ...numbers) {
  var sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  return multiplier * sum
}
var total = sum(2, 6, 10, 8, 9)
console.log(total)
// &lt;- 66
</code></pre> <h2 id="spread-operator"><a href="#spread-operator" class="md-heading">Spread Operator</a></h2> <p>Typically you invoke a function by passing arguments into it.</p> <pre><code>console.log(1, 2, 3)
// &lt;- '1 2 3'
</code></pre> <p>Sometimes however you have those arguments in a list and just don't want to access every index just for a method call <em>– or you just can't because the array is formed dynamically –</em> so you use <code class="md-code md-code-inline">.apply</code>. This feels kind of awkward because <code class="md-code md-code-inline">.apply</code> also takes a context for <code class="md-code md-code-inline">this</code>, which feels out of place when it's not relevant and you have to reiterate the host object <em>(or use <code class="md-code md-code-inline">null</code>)</em>.</p> <pre><code>console.log.apply(console, [1, 2, 3])
// &lt;- '1 2 3'
</code></pre> <p>The spread operator can be used as <em>a butter knife</em> alternative over using <code class="md-code md-code-inline">.apply</code>. There is no need for a context either. You just append three dots <code class="md-code md-code-inline">...</code> to the array, just like with the rest parameter.</p> <pre><code>console.log(...[1, 2, 3])
// &lt;- '1 2 3'
</code></pre> <p>As we'll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that's an <em>iterable</em>. This encompasses even things like the results of <code class="md-code md-code-inline">document.querySelectorAll('div')</code>.</p> <pre><code>[...document.querySelectorAll('div')]
// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre> <p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they'll be spread over the function call exactly how you'd expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p> <pre><code>console.log(1, ...[2, 3, 4], 5) // becomes `console.log(1, 2, 3, 4, 5)`
// &lt;- '1 2 3 4 5'
</code></pre> <p>Time for a real-world example. I sometimes use the method below in Express applications to allow <a href="https://github.com/expressjs/morgan" target="_blank" aria-label="expressjs/morgan on GitHub"><code class="md-code md-code-inline">morgan</code></a> <em>(the request logger in Express)</em> stream its messages through <a href="https://github.com/winstonjs/winston" target="_blank" aria-label="winstonjs/winston on GitHub"><code class="md-code md-code-inline">winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code class="md-code md-code-inline">message</code> because <code class="md-code md-code-inline">winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code class="md-code md-code-inline">pid</code> into the arguments list, and then I <code class="md-code md-code-inline">.apply</code> everything on the <code class="md-code md-code-inline">winston</code> logging mechanism. If you take a close look at the code, the only line of code that's actually doing anything is the one I've highlighted in yellow, the rest is just playing around with <code class="md-code md-code-inline">arguments</code>.</p> <pre><code>function createWriteStream (level) {
  return {
    write: function () {
      var bits = Array.prototype.slice.call(arguments)
      var message = bits.shift().replace(/\n+$/, '') // remove trailing breaks
      bits.unshift(message)
      bits.push({ hostname: os.hostname(), pid: process.pid })
      winston[level].apply(winston, bits)
    }
  }
}
app.use(morgan(':status :method :url', {
  stream: createWriteStream('debug')
}))
</code></pre> <p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code class="md-code md-code-inline">arguments</code>. The rest parameter already gives us a true array, so there's no casting involved either. We can grab the <code class="md-code md-code-inline">message</code> directly as the first parameter, and we can then apply everything on <code class="md-code md-code-inline">winston[level]</code> directly by combining normal arguments with the rest of the <code class="md-code md-code-inline">...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we're trying to accomplish, which is call <code class="md-code md-code-inline">winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> – <em>the method stopped being about the code we were trying to write.</em></p> <pre><code>function createWriteStream (level) {
  return {
    write: function (message, ...bits) {
      winston[level](message.replace(/\n+$/, ''), ...bits, {
        hostname: os.hostname(), pid: process.pid
      })
    }
  }
}
</code></pre> <p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won't change for the lifespan of the process. We could've done that in the ES5 code too, though.</p> <pre><code>var proc = { hostname: os.hostname(), pid: process.pid }
function createWriteStream (level) {
  return {
    write: function (message, ...bits) {
      winston[level](message.replace(/\n+$/, ''), ...bits, proc)
    }
  }
}
</code></pre> <p>Another thing we could do to shorten that piece of code might be to use <a href="/articles/es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions in Depth on Pony Foo">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You'd have to shorten <code class="md-code md-code-inline">message</code> to <code class="md-code md-code-inline">msg</code> so that it fits in a single line, and the call to <code class="md-code md-code-inline">winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn't</em> spent the last 15 minutes thinking about the method <em>– be it a team mate or yourself the week after you wrote this function.</em></p> <pre><code>var proc = { hostname: os.hostname(), pid: process.pid }
function createWriteStream (level) {
  return {
    write: (msg, ...bits) =&gt; winston[level](msg.replace(/\n+$/, ''), ...bits, proc)
  }
}
</code></pre> <p>It would be wiser to just keep our earlier version. While it's <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It's up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you're actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p> <p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a href="/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">while destructuring</a>, in which case it works sort of like <code class="md-code md-code-inline">...rest</code> did, and a use case that's not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code class="md-code md-code-inline">.apply</code> when using the <code class="md-code md-code-inline">new</code> operator as well.</p> <table> <thead> <tr> <th>Use Case</th> <th>ES5</th> <th>ES6</th> </tr> </thead> <tbody> <tr> <td>Concatenation</td> <td><code class="md-code md-code-inline">[1, 2].concat(more)</code></td> <td><code class="md-code md-code-inline">[1, 2, ...more]</code></td> </tr> <tr> <td>Push onto list</td> <td><code class="md-code md-code-inline">list.push.apply(list, [3, 4])</code></td> <td><code class="md-code md-code-inline">list.push(...[3, 4])</code></td> </tr> <tr> <td>Destructuring</td> <td><code class="md-code md-code-inline">a = list[0], rest = list.slice(1)</code></td> <td><code class="md-code md-code-inline">[a, ...rest] = list</code></td> </tr> <tr> <td><code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code></td> <td><a href="http://stackoverflow.com/a/8843181/389745" target="_blank" aria-label="This is insanely unreadable. Avoid."><code class="md-code md-code-inline">new (Date.bind.apply(Date, [null,2015,31,8]))</code></a></td> <td><code class="md-code md-code-inline">new Date(...[2015,31,8])</code></td> </tr> </tbody> </table> <h2 id="default-operator"><a href="#default-operator" class="md-heading">Default Operator</a></h2> <p>The default operator is something we've covered in <a href="/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p> <pre><code>function sum (left=1, right=2) {
  return left + right
}
console.log(sum())
// &lt;- 3
console.log(sum(2))
// &lt;- 4
console.log(sum(1, 0))
// &lt;- 1
</code></pre> <p>Consider the code that initializes options in <a href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37" target="_blank" aria-label="Option initialization in dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a>.</p> <pre><code>function dragula (options) {
  var o = options || {};
  if (o.moves === void 0) { o.moves = always; }
  if (o.accepts === void 0) { o.accepts = always; }
  if (o.invalid === void 0) { o.invalid = invalidTarget; }
  if (o.containers === void 0) { o.containers = initialContainers || []; }
  if (o.isContainer === void 0) { o.isContainer = never; }
  if (o.copy === void 0) { o.copy = false; }
  if (o.revertOnSpill === void 0) { o.revertOnSpill = false; }
  if (o.removeOnSpill === void 0) { o.removeOnSpill = false; }
  if (o.direction === void 0) { o.direction = 'vertical'; }
  if (o.mirrorContainer === void 0) { o.mirrorContainer = body; }
}
</code></pre> <blockquote> <p>Do you think it would be useful to switch to default parameters under ES6 syntax? How would you do that?</p> </blockquote>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t09" name="t09"></a><h1>09 : ES6 Reflection in Depth</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6-reflection-in-depth</span>
					<div class="tutorial__content">
<section class="md-markdown at-body"><h1 id="why-reflection" class=""><a href="#why-reflection" class="md-heading">Why Reflection?</a></h1> <p>Many statically typed languages have long offered a reflection API <em>(such as <a href="http://www.diveintopython.net/power_of_introspection/" target="_blank" aria-label="The Power of Introspection -- Dive Into Python">Python</a> or <a href="http://www.codeproject.com/Articles/17269/Reflection-in-C-Tutorial" target="_blank" aria-label="Reflection in C# Tutorial">C#</a>)</em>, whereas JavaScript hardly has a need for a reflection API – it <em>already being</em> a dynamic language. The introduction of ES6 features a few <strong>new extensibility points</strong> where the developer gets access to <em>previously internal aspects</em> of the language – yes, I'm talking about <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a>.</p> <p>You could argue that <strong>JavaScript already has reflection features in ES5</strong>, even though they weren't ever called that by either the specification or the community. Methods like <code class="md-code md-code-inline">Array.isArray</code>, <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code>, and even <code class="md-code md-code-inline">Object.keys</code> are classical examples of what you'd find <strong>categorized as reflection</strong> in other languages. The <code class="md-code md-code-inline">Reflect</code> built-in is, going forward, going to house future methods in the category. That makes a lot of sense, right? Why would you have <strong>super reflection<em>y</em> static methods</strong> like <code class="md-code md-code-inline">getOwnPropertyDescriptor</code> <em>(or even <code class="md-code md-code-inline">create</code>)</em> in <code class="md-code md-code-inline">Object</code>? After all, <code class="md-code md-code-inline">Object</code> is meant to be a base prototype, and not so much a repository of reflection methods. Having a dedicated interface that exposes most reflection methods makes more sense.</p> <h1 id="reflect"><a href="#reflect" class="md-heading"><code class="md-code md-code-inline">Reflect</code></a></h1> <p>We've mentioned the <code class="md-code md-code-inline">Reflect</code> object in passing the past few days. Much like <code class="md-code md-code-inline">Math</code>, <code class="md-code md-code-inline">Reflect</code> is a static object you can't <code class="md-code md-code-inline">new</code> up nor <em>call</em>, and all of its methods are static. The _traps in <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">ES6 proxies</a> <em>(covered <a href="/articles/es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth on Pony Foo">here</a> and <a href="/articles/more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth on Pony Foo">here</a>)</em> are <strong>mapped one-to-one</strong> to the <code class="md-code md-code-inline">Reflect</code> API. For every <em>trap</em>, there's a matching reflection method in <code class="md-code md-code-inline">Reflect</code>.</p> <p>The reflection API in JavaScript has <em>a number of benefits</em> that are worth examining.</p> <h2 id="return-values-in-reflect-vs-reflection-through-object"><a href="#return-values-in-reflect-vs-reflection-through-object" class="md-heading">Return Values in <code class="md-code md-code-inline">Reflect</code> vs Reflection Through <code class="md-code md-code-inline">Object</code></a></h2> <p>The <code class="md-code md-code-inline">Reflect</code> equivalents to reflection methods on <code class="md-code md-code-inline">Object</code> also provide more <strong>meaningful</strong> <em>return values</em>. For instance, the <code class="md-code md-code-inline">Reflect.defineProperty</code> method returns a boolean value indicating whether the property was successfully defined. Meanwhile, its <code class="md-code md-code-inline">Object.defineProperty</code> counterpart returns the object it got as its first argument <em>– not very <strong>useful</strong>.</em></p> <p>To illustrate, below is a code snippet showing how to verify <code class="md-code md-code-inline">Object.defineProperty</code> worked.</p> <pre><code>try {
  Object.defineProperty(target, 'foo', { value: 'bar' })
  // yay!
} catch (e) {
  // oops.
}
</code></pre> <p>As opposed to a <em>much more natural</em> <code class="md-code md-code-inline">Reflect.defineProperty</code> experience.</p> <pre><code>var yay = Reflect.defineProperty(target, 'foo', { value: 'bar' })
if (yay) {
  // yay!
} else {
  // oops.
}
</code></pre> <p>This way we avoided a <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> block and made our code a little more maintainable in the process.</p> <h2 id="keyword-operators-as-first-class-citizens"><a href="#keyword-operators-as-first-class-citizens" class="md-heading">Keyword Operators as First Class Citizens</a></h2> <p>Some of these reflection methods provide programmatic alternatives of doing things that were previously only possible through keywords. For example, <code class="md-code md-code-inline">Reflect.deleteProperty(target, key)</code> is equivalent to the <code class="md-code md-code-inline">delete target[key]</code> expression. Before ES6, if you wanted a method call to result in a <code class="md-code md-code-inline">delete</code> call, you'd have to create a dedicated utility method that wrapped <code class="md-code md-code-inline">delete</code> on your behalf.</p> <pre><code>var target = { foo: 'bar', baz: 'wat' }
delete target.foo
console.log(target)
// &lt;- { baz: 'wat' }
</code></pre> <p>Today, with ES6, you already have such a method in <code class="md-code md-code-inline">Reflect.deleteProperty</code>.</p> <pre><code>var target = { foo: 'bar', baz: 'wat' }
Reflect.deleteProperty(target, 'foo')
console.log(target)
// &lt;- { baz: 'wat' }
</code></pre> <p>Just like <code class="md-code md-code-inline">deleteProperty</code>, there's a few other methods that make it easy to do other things too.</p> <h2 id="easier-to-mix-new-with-arbitrary-argument-lists"><a href="#easier-to-mix-new-with-arbitrary-argument-lists" class="md-heading">Easier to mix <code class="md-code md-code-inline">new</code> with Arbitrary Argument Lists</a></h2> <p>In ES5, this is a hard problem: How do you create a <code class="md-code md-code-inline">new Foo</code> passing an arbitrary number of arguments? You can't do it directly, and it's <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" target="_blank" aria-label="Dominus on GitHub has an example where this was necessary">super verbose</a> if you need to do it anyways. You have to create an intermediary object that gets passed the arguments as an <code class="md-code md-code-inline">Array</code>. Then you have <em>that</em> object's constructor return the result of applying the constructor of the object you originally intended to <code class="md-code md-code-inline">.apply</code>. Straightforward, right? <em>– What do you mean <strong>no</strong>?</em></p> <pre><code>var proto = Dominus.prototype
Applied.prototype = proto
function Applied (args) {
  return Dominus.apply(this, args)
}
function apply (a) {
  return new Applied(a)
}
</code></pre> <p>Using <code class="md-code md-code-inline">apply</code> is actually easy, thankfully.</p> <pre><code>apply(['.foo', '.bar'])
apply.call(null, '.foo', '.bar')
</code></pre> <p>But that was <em>insane</em>, right? <strong>Who does that?</strong> Well, in ES5, everyone who has a valid reason to do it! Luckily ES6 has less insane approaches to this problem. One of them is simply to use the <a href="http://www.diveintopython.net/power_of_introspection/" target="_blank" aria-label="The Power of Introspection -- Dive Into Python">spread operator</a>.</p> <pre><code>new Dominus(...args)
</code></pre> <p>Another alternative is to go the <code class="md-code md-code-inline">Reflect</code> route.</p> <pre><code>Reflect.construct(Dominus, args)
</code></pre> <p>Both of these are tremendously simpler than what I had to do in the <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" target="_blank" aria-label="Dominus on GitHub has an example where this was necessary"><code class="md-code md-code-inline">dominus</code></a> codebase.</p> <h2 id="function-application-the-right-way"><a href="#function-application-the-right-way" class="md-heading">Function Application, The Right Way</a></h2> <p>In ES5 if we want to call a method with an arbitrary number of arguments, we can use <code class="md-code md-code-inline">.apply</code> passing a <code class="md-code md-code-inline">this</code> context and our arguments.</p> <pre><code>fn.apply(ctx, [1, 2, 3])
</code></pre> <p>If we fear <code class="md-code md-code-inline">fn</code> might shadow <code class="md-code md-code-inline">apply</code> with a property of their own, we can rely on a safer but way more verbose alternative.</p> <pre><code>Function.prototype.apply.call(fn, ctx, [1, 2, 3])
</code></pre> <p>In ES6, you can use <a href="/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread</a> as an alternative to <code class="md-code md-code-inline">.apply</code> for an arbitrary number of arguments.</p> <pre><code>fn(...[1, 2, 3])
</code></pre> <p>That doesn't solve your problems when you need to define a <code class="md-code md-code-inline">this</code> context, though. You could go back to the <code class="md-code md-code-inline">Function.prototype</code> way but that's <em>way</em> too verbose. Here's how <code class="md-code md-code-inline">Reflect</code> can help.</p> <pre><code>Reflect.apply(fn, ctx, args)
</code></pre> <p>Naturally, one of the most fitting use cases for <code class="md-code md-code-inline">Reflect</code> API methods is default behavior in <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a> <a href="/articles/es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth on Pony Foo">traps</a>.</p> <h2 id="default-behavior-in-proxy-traps"><a href="#default-behavior-in-proxy-traps" class="md-heading">Default Behavior in <code class="md-code md-code-inline">Proxy</code> Traps</a></h2> <p>We've already talked about how <em>traps</em> are mapped one-to-one to <code class="md-code md-code-inline">Reflect</code> methods. We haven't yet touched on the fact that their interfaces match as well. That is to say, <em>both their arguments and their return values match</em>. In code, this means you could do something like this to get the default <code class="md-code md-code-inline">get</code> <em>trap</em> behavior in your <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo">proxy handlers</a>.</p> <pre><code>var handler = {
  get () {
    return Reflect.get(...arguments)
  }
}
var target = { a: 'b' }
var proxy = new Proxy(target, handler)
console.log(proxy.a)
// &lt;- 'b'
</code></pre> <p>There is, in fact, nothing stopping you from making that <code class="md-code md-code-inline">handler</code> even simpler. Of course, at this point you'd be better off leaving the <em>trap</em> out entirely.</p> <pre><code>var handler = {
  get: Reflect.get
}
</code></pre> <p>The important take-away here is that you could set up a trap in your proxy handlers, wire up some custom functionality that ends up throwing or logging a console statement, and then in the default case you could just use the one-liner recipe found below.</p> <pre><code>return Reflect[trapName](...arguments)
</code></pre> <p>Certainly puts me at ease when it comes to demystifying <a href="/articles/es6-proxies-in-depth" aria-label="ES6 Proxies in Depth on Pony Foo"><code class="md-code md-code-inline">Proxy</code></a>.</p> <h2 id="lastly-there-s-proto"><a href="#lastly-there-s-proto" class="md-heading">Lastly, There's <code class="md-code md-code-inline">__proto__</code></a></h2> <p>Yesterday we talked about how the <a href="/articles/more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth on Pony Foo">legacy <code class="md-code md-code-inline">__proto__</code> is part of the ES6 specification</a> but still strongly advised against and how you should use <code class="md-code md-code-inline">Object.setPrototypeOf</code> and <code class="md-code md-code-inline">Object.getPrototypeOf</code> instead. Turns out, there's also <code class="md-code md-code-inline">Reflect</code> counterparts to those methods you could use. Think of these methods as <em>getter and setters</em> for <code class="md-code md-code-inline">__proto__</code> but without the cross-browser discrepancies.</p> <blockquote> <p>I wouldn't just hop onto the "<code class="md-code md-code-inline">setPrototypeOf</code> all the things" bandwagon just yet. In fact, I hope there never is a train pulling that wagon to begin with.</p> </blockquote></section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t10" name="t10"></a><h1>10 : ES6 Object Literal Features in Depth</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6-object-literal-features-in-depth</span>
					<div class="tutorial__content">
<section class="md-markdown at-body">
	<h2 id="property-value-shorthands" class=""><a href="#property-value-shorthands" class="md-heading">Property Value Shorthands</a></h2> <p>Whenever you find yourself assigning a property value that matches a property name, you can omit the property value, it's implicit in ES6.</p> <pre><code>var foo = 'bar'
var baz = { foo }
console.log(baz.foo)
// &lt;- 'bar'
</code></pre> <p>In the snippet shown below I re-implemented part of <code class="md-code md-code-inline">localStorage</code> in memory as a polyfill. It displays a pattern that I've followed countless times <a href="https://github.com/bevacqua/local-storage/blob/b9725b0fc77faabc737ba7c6ee57d343afa95102/stub.js#L3-L32" target="_blank" aria-label="See bevacqua/local-storage on GitHub">in my code</a>.</p> <pre><code>var ms = {}

function getItem (key) {
  return key in ms ? ms[key] : null
}

function setItem (key, value) {
  ms[key] = value
}

function clear () {
  ms = {}
}

module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
}
</code></pre> <p>The reasons why <em>– most often –</em> I don't place functions directly on an object definition are <em>several.</em></p> <ul> <li>Less indentation needed</li> <li>Public API stands out</li> <li>Harder to tightly couple methods</li> <li>Easier to reason about</li> </ul> <p>With ES6, we can throw another bullet into that list, and that's that the export can be even easier using <em>property value shorthands</em>. You can omit the property value if it matches the property name. The <code class="md-code md-code-inline">module.exports</code> from the code above thus becomes:</p> <pre><code>module.exports = { getItem, setItem, clear }
</code></pre> <p>So good!</p> <h2 id="computed-property-names"><a href="#computed-property-names" class="md-heading">Computed Property Names</a></h2> <p>We already covered computed property names briefly in the <a href="/articles/es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo">destructuring article</a>. This was a very common thing to do for me:</p> <pre><code>var foo = 'bar'
var baz = {}
baz[foo] = 'ponyfoo'
console.log(baz)
// &lt;- { bar: 'ponyfoo' }
</code></pre> <p>Computed property names allow you to write an <em>expression</em> wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name.</p> <pre><code>var foo = 'bar'
var baz = { [foo]: 'ponyfoo' }
console.log(baz)
// &lt;- { bar: 'ponyfoo' }
</code></pre> <p>One limitation of computed property names is that you won't be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar.</p> <pre><code>var foo = 'bar'
var bar = 'ponyfoo'
var baz = { [foo] }
console.log(baz)
// &lt;- SyntaxError
</code></pre> <p>That being said, I believe this to be the most common use case. Here our code is simpler because we don't have to spend three steps in allocating a <code class="md-code md-code-inline">foo</code> variable, assigning to <code class="md-code md-code-inline">foo[type]</code>, and returning <code class="md-code md-code-inline">foo</code>. Instead we can do all three in a single statement.</p> <pre><code>function getModel (type) {
  return {
    [type]: {
      message: 'hello, this is doge',
      date: new Date()
    }
  }
}
</code></pre> <p>Neat. What else?</p> <h2 id="method-definitions"><a href="#method-definitions" class="md-heading">Method Definitions</a></h2> <p>Typically in ES5 you declare methods on an object like so:</p> <pre><code>var foo = {
  bar: function (baz) {
  }
}
</code></pre> <p>While getters and setters have a syntax like this, where there's no need for the <code class="md-code md-code-inline">function</code> keyword. It's just inferred from context.</p> <pre><code>var cart = {
  _wheels: 4,
  get wheels () {
    return this._wheels
  },
  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error('hey, come back here!')  
    }
    this._wheels = value
  }
}
</code></pre> <p>Starting in ES6, you can declare regular methods with a similar syntax, only difference is it's not prefixed by <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code>.</p> <pre><code>var cart = {
  _wheels: 4,
  get wheels () {
    return this._wheels
  },
  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error('hey, come back here!')  
    }
    this._wheels = value
  },
  dismantle () {
    this._wheels = 0
    console.warn(`you're all going to pay for this!`)
  }
}
</code></pre> <p>I think it's nice that methods converged together with getters and setter. I for one don't use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the <a href="#property-value-shorthands">shorthand</a> section. However, it's still useful in some situations and definitely useful when declaring <em>"classes"</em> – if you're into that sort of thing.</p>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t11" name="t11"></a><h1>11 : ES6 WeakMaps, Sets, and WeakSets in Depth</h1>
					<span class="ref-site">https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth</span>
					<div class="tutorial__content">
<section class="md-markdown at-body"><h1 id="es6-weakmaps"><a href="#es6-weakmaps" class="md-heading">ES6 WeakMaps</a></h1> <p>You can think of <code class="md-code md-code-inline">WeakMap</code> as a subset of <a href="/articles/es6-maps-in-depth" aria-label="ES6 Maps in Depth on Pony Foo"><code class="md-code md-code-inline">Map</code></a>. There are a few limitations on <code class="md-code md-code-inline">WeakMap</code> that we didn't find in <code class="md-code md-code-inline">Map</code>. The biggest limitation is that <code class="md-code md-code-inline">WeakMap</code> is not iterable, as opposed to <code class="md-code md-code-inline">Map</code> – that means there is no <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><em>iterable</em></a> protocol, no <code class="md-code md-code-inline">.entries()</code>, no <code class="md-code md-code-inline">.keys()</code>, no <code class="md-code md-code-inline">.values()</code>, no <code class="md-code md-code-inline">.forEach()</code> and no <code class="md-code md-code-inline">.clear()</code>.</p> <p>Another <em>"limitation"</em> found in <code class="md-code md-code-inline">WeakMap</code> as opposed to <code class="md-code md-code-inline">Map</code> is that every <code class="md-code md-code-inline">key</code> must be an object, and <strong>value types are not admitted as keys</strong>. Note that <code class="md-code md-code-inline">Symbol</code> is a value type as well, and they're not allowed either.</p> <pre><code>var map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
</code></pre> <blockquote> <p>This is more of a feature than an issue, though, as it enables map keys to be garbage collected when they're only being referenced as <code class="md-code md-code-inline">WeakMap</code> keys. Usually you want this behavior when storing metadata related to something like a DOM node, and now you can keep that metadata in a <code class="md-code md-code-inline">WeakMap</code>. If you want all of those you could always <a href="/articles/es6-maps-in-depth" aria-label="ES6 Maps in Depth on Pony Foo">use a regular <code class="md-code md-code-inline">Map</code> as we explored earlier</a>.</p> </blockquote> <p>You are still able to pass an iterable to populate a <code class="md-code md-code-inline">WeakMap</code> through its constructor.</p> <pre><code>var map = new WeakMap([[new Date(), 'foo'], [() =&gt; 'bar', 'baz']])
</code></pre> <p>Just like with <code class="md-code md-code-inline">Map</code>, you can use <code class="md-code md-code-inline">.has</code>, <code class="md-code md-code-inline">.get</code>, and <code class="md-code md-code-inline">.delete</code> too.</p> <pre><code>var date = new Date()
var map = new WeakMap([[date, 'foo'], [() =&gt; 'bar', 'baz']])
console.log(map.has(date))
// &lt;- true
console.log(map.get(date))
// &lt;- 'foo'
map.delete(date)
console.log(map.has(date))
// &lt;- false
</code></pre> <h2 id="is-this-a-strictly-worse-map"><a href="#is-this-a-strictly-worse-map" class="md-heading">Is This a Strictly Worse Map?</a></h2> <p>I know! You must be wondering – why the hell would I use <code class="md-code md-code-inline">WeakMap</code> when it has so many limitations when compared to <code class="md-code md-code-inline">Map</code>?</p> <p>The difference that may make <code class="md-code md-code-inline">WeakMap</code> worth it is in its name. <code class="md-code md-code-inline">WeakMap</code> holds references to its keys <em>weakly</em>, meaning that if there are no other references to one of its keys, the object is subject to <strong>garbage collection</strong>.</p> <p>Use cases for <code class="md-code md-code-inline">WeakMap</code> generally revolve around the need to specify metadata or extend an object while still being able to garbage collect it if nobody else cares about it. A perfect example might be the underlying implementation for <a href="https://iojs.org/api/process.html#process_event_unhandledrejection" target="_blank" aria-label="Node.js Documentation for 'unhandledRejection' process event"><code class="md-code md-code-inline">process.on('unhandledRejection')</code></a> which <a href="https://github.com/petkaantonov/io.js/commit/f46874357ee7b909ae54304c6791f2a4baddf613#diff-6ff379484cbabad48301d485db111c08R269" target="_blank" aria-label="node: implement unhandled rejection tracking">uses a <code class="md-code md-code-inline">WeakMap</code></a> to keep track of promises that were rejected but <em>no error handlers dealt with the rejection</em> within a tick.</p> <p>Keeping data about DOM elements that should be released from memory when they're no longer of interest is another very important use case, and in this regard using <code class="md-code md-code-inline">WeakMap</code> is probably an even better solution to the DOM-related <a href="/articles/es6-maps-in-depth#hash-maps-and-the-dom" aria-label="Hash-Maps and the DOM">API caching solution</a> we wrote about earlier using <code class="md-code md-code-inline">Map</code>.</p> <p>In so many words then, <strong>no</strong>. <code class="md-code md-code-inline">WeakMap</code> is not strictly worse than <code class="md-code md-code-inline">Map</code> <em>– they just cater to different use cases.</em></p> 

<h2 id="es6-sets"><a href="#es6-sets" class="md-heading">ES6 Sets</a></h2> 
	
	<p>Sets are <em>yet another</em> collection type in ES6. Sets are <em>very</em> similar to <code class="md-code md-code-inline">Map</code>. To wit:</p> <ul> <li><code class="md-code md-code-inline">Set</code> is also <a href="/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo"><em>iterable</em></a></li> <li><code class="md-code md-code-inline">Set</code> constructor also accepts an <em>iterable</em></li> <li><code class="md-code md-code-inline">Set</code> also has a <code class="md-code md-code-inline">.size</code> property</li> <li>Keys can also be arbitrary values</li> <li>Keys must be unique</li> <li><code class="md-code md-code-inline">NaN</code> equals <code class="md-code md-code-inline">NaN</code> when it comes to <code class="md-code md-code-inline">Set</code> too</li> <li>All of <code class="md-code md-code-inline">.keys</code>, <code class="md-code md-code-inline">.values</code>, <code class="md-code md-code-inline">.entries</code>, <code class="md-code md-code-inline">.forEach</code>, <del><code class="md-code md-code-inline">.get</code></del>, <del><code class="md-code md-code-inline">.set</code></del>, <code class="md-code md-code-inline">.has</code>, <code class="md-code md-code-inline">.delete</code>, and <code class="md-code md-code-inline">.clear</code></li> </ul> <p>However, there's a few differences as well!</p> <ul> <li>Sets only have <code class="md-code md-code-inline">values</code></li> <li>No <code class="md-code md-code-inline">set.get</code> – but <strong>why</strong> would you want <code class="md-code md-code-inline">get(value) =&gt; value</code>?</li> <li>Having <code class="md-code md-code-inline">set.set</code> would be weird, so we have <code class="md-code md-code-inline">set.add</code> instead</li> <li><code class="md-code md-code-inline">set[Symbol.iterator] !== set.entries</code></li> <li><code class="md-code md-code-inline">set[Symbol.iterator] === set.values</code></li> <li><code class="md-code md-code-inline">set.keys === set.values</code></li> <li><code class="md-code md-code-inline">set.entries()</code> returns an iterator on a sequence of items like <code class="md-code md-code-inline">[value, value]</code></li> </ul> <p>In the example below you can note how it takes an iterable with duplicate values, it can be spread over an <code class="md-code md-code-inline">Array</code> using the <a href="/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a>, and how the duplicate value <em>has been ignored</em>.</p> <pre><code>var set = new Set([1, 2, 3, 4, 4])
console.log([...set])
// &lt;- [1, 2, 3, 4]
</code></pre> <p>Sets may be a great alternative to work with DOM elements. The following piece of code creates a <code class="md-code md-code-inline">Set</code> with all the <code class="md-code md-code-inline">&lt;div&gt;</code> elements on a page and then prints how many it found. Then, we query the DOM <em>again</em> and call <code class="md-code md-code-inline">set.add</code> again for every DOM element. Since they're all already in the <code class="md-code md-code-inline">set</code>, the <code class="md-code md-code-inline">.size</code> property won't change, meaning the <code class="md-code md-code-inline">set</code> remains the same.</p> <pre><code>function divs () {
  return [...document.querySelectorAll('div')]
}
var set = new Set(divs())
console.log(set.size)
// &lt;- 56
divs().forEach(div =&gt; set.add(div))
console.log(set.size)
// &lt;- 56
// &lt;- look at that, no duplicates!
</code></pre> 
<h2 id="es6-weaksets"><a href="#es6-weaksets" class="md-heading">ES6 WeakSets</a></h2> 
	<p>Much like with <code class="md-code md-code-inline">WeakMap</code> and <code class="md-code md-code-inline">Map</code>, <code class="md-code md-code-inline">WeakSet</code> is <strong><code class="md-code md-code-inline">Set</code> plus weakness</strong> minus the <em>iterability</em> <em>– I just made that term up, didn't I?</em></p> <p>That means you can't iterate over <code class="md-code md-code-inline">WeakSet</code>. Its values must be <strong>unique object references</strong>. If nothing else is referencing a <code class="md-code md-code-inline">value</code> found in a <code class="md-code md-code-inline">WeakSet</code>, it'll be subject to garbage collection.</p> <p>Much like in <code class="md-code md-code-inline">WeakMap</code>, you can only <code class="md-code md-code-inline">.add</code>, <code class="md-code md-code-inline">.has</code>, and <code class="md-code md-code-inline">.delete</code> values from a <code class="md-code md-code-inline">WeakSet</code>. And just like in <code class="md-code md-code-inline">Set</code>, there's no <code class="md-code md-code-inline">.get</code>.</p> <pre><code>var set = new WeakSet()
set.add({})
set.add(new Date())
</code></pre> <p>As we know, we can't use primitive values.</p> <pre><code>var set = new WeakSet()
set.add(Symbol())
// TypeError: invalid value used in weak set
</code></pre> <p>Just like with <code class="md-code md-code-inline">WeakMap</code>, passing iterators to the constructor is still allowed even though a <code class="md-code md-code-inline">WeakSet</code> instance is not iterable itself.</p> <pre><code>var set = new WeakSet([new Date(), {}, () =&gt; {}, [1]])
</code></pre> <p>Use cases for <code class="md-code md-code-inline">WeakSet</code> vary, and here's one from <a href="https://esdiscuss.org/topic/actual-weakset-use-cases#content-1" target="_blank" aria-label="Actual WeakSet Use Cases on ES Discuss">a thread on <em>es-discuss</em></a> – the mailing list for the ECMAScript-262 specification of JavaScript.</p> <pre><code>const foos = new WeakSet()
class Foo {
  constructor() {
    foos.add(this)
  }
  method () {
    if (!foos.has(this)) {
      throw new TypeError('Foo.prototype.method called on incompatible object!')
    }
  }
}
</code></pre> <p>As a general rule of thumb, you can also try and figure out whether a <code class="md-code md-code-inline">WeakSet</code> will do when you're considering to use a <code class="md-code md-code-inline">WeakMap</code> as some use cases may overlap. Particularly, if all you need to check for is whether a reference value is in the <code class="md-code md-code-inline">WeakSet</code> or not.</p> <blockquote> <p>Next week we'll be having <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" aria-label="Proxy Objects in ES6 on MDN"><code class="md-code md-code-inline">Proxy</code></a> for brunch :)</p> </blockquote></section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				

				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t12" name="t12"></a><h1>12 : JavaScript ES2015 Classes and Prototype Inheritance (Part 1 of 2)</h1>
					<span class="ref-site">https://www.accelebrate.com/blog/javascript-es6-classes-and-prototype-inheritance-part-1-of-2/</span>
					<div class="tutorial__content">
<div class="entry-content">
                            <h2>What is JavaScript ES2015?</h2>
<p>With the finalizing of the ECMA Script 2015 (ES2015) specification in June of last year, the JavaScript community can move towards the implementation of ES2015 in the many JavaScript engines in the marketplace. &nbsp;ES2015 was formerly known as ES6, but following the pattern of other programming languages, the year is now being used instead of an arbitrary version number.</p>
<p>ES2015 offers many helpful new features and cleaner syntax for existing features. One example of this cleaner syntax is the class keyword, as well as improved syntax for using prototype inheritance in JavaScript applications.</p>
<p>Until ES2015, implementing prototype inheritance with JavaScript was confusing and difficult for many JavaScript developers. The first challenge is to understand how prototype inheritance is different from the classic inheritance models of the C++, Java, and C# languages. In the conventional inheritance model, classes inherit from classes. Classes are nothing more than specifications or blueprints used to create objects. Specifications can inherit the qualities of other specifications. Using inherited qualities and its own qualities, new objects can be instantiated. Unlike traditional inheritance, JavaScript has no concept of these specifications.</p>
<h2>What is JavaScript Prototype Inheritance?</h2>
<p>In JavaScript prototype inheritance, one object inherits from another object, instead of one specification inheriting from another specification. Even the new class keyword is kind of a misnomer because while it implies a specification, it is still one object inheriting from another object. So if the inheritance mechanism is the same, why change the syntax needed to perform the task already accomplished in earlier versions of JavaScript? Simply put, the syntax in earlier versions of JavaScript is too tedious and difficult to follow. Therefore, once the developer understands object-to-object inheritance, the second challenge is how to improve the syntax for prototype inheritance – enter ES2015 classes.</p>
<h2>ES2015 Classes in JavaScript</h2>
<p>The new ES2015 syntax provides a clearer syntax for identifying class structures, creating constructor functions, extending classes, calling the constructor and functions on the super class, as well as providing static functions. Additionally, the new ES2015 class construct improves the syntax for creating ES5 style getter/setter property descriptors, enabling developers to utilize these largely unknown capabilities in ES2015.</p>
<p><strong>Class Definitions<br>
</strong>The use of the term "class" in JavaScript has a controversial history. Strictly speaking, JavaScript does not have classes. Even the classes in ES2015 are not really classes in the traditional sense. The classes in ES2015 are just a cleaned up syntax for setting up prototype inheritance between objects. Nevertheless, because ES2015 uses the term "class" for objects created with a function constructor (yes, a function constructor is the ultimate end result of the class keyword), this blog post will use the term "class" to describe not only ES2015 classes, but also ES5 and earlier constructor functions.</p>
<p>In ES5 and earlier, constructor functions defined "classes" like this:</p>
<pre><code>function MyClass() { }

var myClass = new MyClass();</code></pre>
<p>ES2015 introduces a new syntax using the class keyword:</p>
<pre><code>class MyClass {
  constructor() {  }
}
var myClass = new MyClass();</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [typeof.js]</p>
<p>The constructor function is the same function as defined in ES5. The class keyword wrapped block is where properties on the prototype are defined (this will be shown later). The new keyword syntax for instantiating a new instance of the class remains unchanged from ES5.</p>
<p>With this new class keyword syntax comes a function object, which is what ES5 used. Observe the following output from the Node.js REPL environment. First, we define a new class and then the typeof operator lists the type of the class object.</p>
<pre><code>&gt; class MyClass { constructor() {} }
class MyClass { constructor() {} }
[Function: MyClass]
&gt; typeof MyClass
'function'
&gt;</code></pre>
<p>ES2015 did not redefine the role and purpose of the constructor function; it simply cleaned up the syntax.</p>
<h2>What are Constructors in JavaScript?</h2>
<p>Constructors serve the same purpose as constructor functions in earlier versions of JavaScript. A constructor is a function that is executed when the new operator is used to instantiate a new instance of the class. Arguments can be passed into the constructor function to initialize object properties and perform other tasks.</p>
<p>In ES5, constructor functions looked like this:</p>
<pre><code>function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}</code></pre>
<p>The equivalent constructor function with ES2015 syntax looks like this:</p>
<pre><code>// the name of the ES5 constructor
// function is name of the ES2015 class
class Person {

  // observe there is no "function" keyword
  // also, the word "constructor" is used, not "Person"
  constructor(firstName, lastName) {

    // this represents the new object being
    // created and initialized
    this.firstName = firstName;
    this.lastName = lastName;

  }
}</code></pre>
<p>While the syntax is a little more verbose, it is also clearer, and makes it easier to add inherited properties.</p>
<p>To instantiate objects with either syntax, the code is the same.</p>
<pre><code>var person = new Person("Bob", "Smith");

// outputs "Bob"
console.log(person.firstName);

// outputs "Smith"
console.log(person.lastName);</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [constructors.js]</p>
<p><strong>Extending Classes</strong></p>
<p>Prior to ES2015, most developers who coded JavaScript did not understand how to setup an inheritance relationship between objects. A quick conversation with a C++, Java, or C# developer would quickly reveal the ease with which they could setup one class to inherit from another, and then instantiate an object from the subclass. Ask a typical JavaScript developer to demonstrate how to setup inheritance between two objects, and the result is usually a blank stare. The reason for this great difference is that configuring prototype inheritance is not straightforward, and the concept of prototype inheritance is foreign to most JavaScript developers. Here is some example code with comments to explain the process of configuring inheritance.</p>
<pre><code>// Person constructor function
// when called with the "new" operator,
// a new Person object is created

function Person(firstName, lastName) {
  // the "new" operator sets the reference of
  // "this" to a new object
  this.firstName = firstName;
  this.lastName = lastName;
}

// this property referencing the function will
// be configured on person's prototype object,
// and will be inherited by students
Person.prototype.getFullName = function() {
  return this.firstName + " " + this.lastName;
};

// Student constructor function
// when called with the "new" operator,
// a new Student object is created

function Student(studentId, firstName, lastName) {
  // the "new" operator sets the reference of "this" to
  // a new object, the new object is then passed to the
  // Person constructor function through the use of call,
  // so the first name and last name properties can be set
  this._super.call(this, firstName, lastName);
  this.studentId = studentId;
}

// students will inherit from a new object
// which inherits from the parent
Student.prototype = Object.create(Person.prototype);

// set the constructor property back to the Student
// constructor function
Student.prototype.constructor = Student;

// "_super" is NOT part of ES5, its a convention
// defined by the developer
// set the "_super" to the Person constructor function
Student.prototype._super = Person;

// this will exist on the student's prototype object
Student.prototype.getStudentInfo = function() {
  return this.studentId + " " + this.lastName + ", " + this.firstName;
};

// instantiate a new Student object
var student = new Student(1, "Bob", "Smith");

// invoking function on parent prototype
// outputs "Bob Smith"
console.log(student.getFullName());

// invoking function on child prototype
// output "1 Smith, Bob"
console.log(student.getStudentInfo());</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [es5_inheritance.js]</p>
<p>The above code is hard to follow, and it takes a lot of work just for one object to inherit from another while supporting constructor functions. Most JavaScript developers cannot create this code from memory, and many have never seen or considered anything like this when working with JavaScript.</p>
<p>To solve this problem and bring prototype inheritance into greater usage, ES2015 has introduced the <strong>extends</strong> keyword to the syntax of its new class structure. The following code demonstrates the same inheritance as the first code sample, but uses ES2015 syntax.</p>
<pre><code>"use strict";

class Person {

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName() {
    return this.firstName + " " + this.lastName;
  }

}

class Student extends Person {

  constructor(studentId, firstName, lastName) {
    super(firstName, lastName);
    this.studentId = studentId;
  }

  getStudentInfo() {
    return this.studentId + " " + this.lastName + ", " + this.firstName;
  }

}

var student = new Student(1, "Bob", "Smith");
console.log(student.getFullName());
console.log(student.getStudentInfo());</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [es6_inheritance.js]</p>
<p>Clearly, the second approach easier to understand. The interesting result is that both code samples produce exactly the same object structure. Therefore, while the new syntax simply improves the inheritance code, it does not change the result.</p>
<p>Another way to explore how this works is to look at the ES5 inheritance code generated by TypeScript. TypeScript is a JavaScript pre-processor language, which enhances JavaScript through strong-type checking and transpiling ES2015 code to ES5 code. Transpiling (aka transcompiling) is the process of compiling the source code of one language into the source code of another language. Popular transpilers include <a href="http://coffeescript.org" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://coffeescript.org', 'CoffeeScript');" target="_blank">CoffeeScript</a>, <a href="http://sass-lang.com" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://sass-lang.com', 'SASS');" target="_blank">SASS</a>, and <a href="http://lesscss.org" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://lesscss.org', 'LessCSS');" target="_blank">LessCSS</a>, as well as <a href="http://www.typescriptlang.org" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.typescriptlang.org', 'TypeScript');" target="_blank">TypeScript</a>.</p>
<h2>The _extends function in JavaScript</h2>
<p>To support ES2015 class inheritance, TypeScript transpiles the ES2015 <strong>extends</strong> keyword functionality to a function named <strong>__extends</strong>, which executes the code needed to setup the inheritance. Here is the code for the <strong>__extends</strong> function:</p>
<pre><code>var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};</code></pre>
<p>The above code is a little hard to follow, so here is an expanded, documented version of it. Review the added source code comments to understand the purpose of each line of code. The <strong>__extends</strong> function works with any pair of parent and child objects.</p>
<pre><code>// declare a variable to reference the extends function
var __extends;

if (this &amp;&amp; this.__extends) {

	// the extends function is already defined within the context
	// of this code, so use the existing __extends function
	__extends = this.__extends;

} else {</code></pre>
<p>Within the else block is the implementation of the <strong>__extends</strong> function. The function utilizes both the mixin pattern and prototype inheritance to construct the inheritance relationship between parent and child objects. The mixin pattern copies the properties from one object to another. The code below walks through the <strong>__extends</strong> function.</p>
<pre><code>// the extends function is not already defined within the current
// context; therefore, define it
__extends = function (child, parent) {

  // mixin pattern for copying parent constructor function properties
  // as static properties to the child constructor function
  // properties on constructor function are commonly known as static
  // properties
  for (var parentPropertyName in parent) {

    // only copy properties specifically defined on the parent
    if (parent.hasOwnProperty(parentPropertyName)) {
      // for primitive types, this will copy the value,
      // for object types, this will copy the reference only
      child[parentPropertyName] = parent[parentPropertyName];
    }

  }

  // constructor function for the object that instantiated child objects
  // will inherit from
  // this function is unique within the context of each call to extend

  function __() {
    this.constructor = child;
  }

  if (parent === null) {

    // objects instantiated with the child constructor function will
    // inherit from an object that inherits from nothing, not even
    // the built-in JavaScript Object
    child.prototype = Object.create(parent);

  } else {

    // assign the prototype property of the parent constructor function
    // to the prototype property of the constructor function defined
    // above
    __.prototype = parent.prototype;

    // create the object that all instances of the child will inherit
    // from, and assign it to the prototype property of the child
    // constructor function
    child.prototype = new __();

  }

};</code></pre>
<p>The following two lines of code confuse many developers:</p>
<pre><code>// assign the prototype property of the parent constructor function
// to the prototype property of the constructor function defined
// above
__.prototype = parent.prototype;

// create the object that all instances of the child will inherit
// from, and assign it to the prototype property of the child
// constructor function
child.prototype = new __();</code></pre>
<p>Developers may think the code should be written like this this instead:</p>
<pre><code>// this code does not yield the desired result
child.prototype = parent.prototype;</code></pre>
<p>Mistakenly, developers reason that the child will now inherit from the parent constructor function's prototype property. However, what really happens is that objects created with the parent's constructor function, and objects created with the child's constructor function, both inherit from the exact same prototype object. This is not desirable, because the child constructor function's prototype property cannot be modified without also changing the parent constructor function's prototype property. This means that all changes made to the child will also be made to the parent. This is not true inheritance.</p>
<p><a href="https://www.accelebrate.com/blog/wp-content/uploads/2016/01/inheritance-structure.png"><img class="aligncenter wp-image-799 size-full" title="Inheritance Structure" src="https://www.accelebrate.com/blog/wp-content/uploads/2016/01/inheritance-structure.png" alt="Inheritance Structure" width="673" height="262" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>
<p>When a new object is instantiated with the new operator and either the Parent or Child Constructor Functions, the resulting objects will inherit from the same prototype object (PPO). The instantiated parent and child objects are really siblings with the PPO as their parent. The child does not inherit from the parent.</p>
<p>Therefore, the purpose of this code is to establish the following inheritance structure.</p>
<pre><code>__.prototype = parent.prototype;
child.prototype = new __();</code></pre>
<p><a href="https://www.accelebrate.com/blog/wp-content/uploads/2016/01/correct-inheritance-structure.png"><img class=" wp-image-800 size-full aligncenter" title="Correct Inheritance Structure" src="https://www.accelebrate.com/blog/wp-content/uploads/2016/01/correct-inheritance-structure.png" alt="Correct Inheritance Structure" width="667" height="355" draggable="true" data-bukket-ext-bukket-draggable="true"></a></p>
<p>With this new structure, new child objects will inherit from the CPO, which inherits from PPO. New properties can be added to the CPO, which will not affect the PPO. New parent objects will inherit from the PPO, and are thus unaffected by changes to the CPO. Changes to the PPO will be inherited by object created with both the Parent and Child Constructor Functions. With this new structure, child objects inherit from the parent.<br>
Finally, the closing curly brace for the original if block.</p>
<pre><code>}</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [ts_extends.js]</p>
<p>ES2015 syntax for extending classes is much easier to understand. There are two new keywords: <strong>extends</strong> and <strong>super</strong>. The <strong>extends</strong> keyword sets up the prototype inheritance relationship between the parent and child classes. The <strong>super</strong> keyword invokes the constructor on the parent (aka super) class. Invoking the <strong>super</strong> function is required even if the parent object does no configuration. The invoking of the super constructor is what actually created the new this object to be used in the child class (aka subclass).</p>
<pre><code>class Person {

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName() {
    return this.firstName + " " + this.lastName;
  }

}

// 'extends' keyword sets up the prototype inheritance relationship
// with the super object
// 'extends' performs the same basic operation as the earlier
// '__extends' function

class Student extends Person {

  constructor(studentId, firstName, lastName) {
    // 'super' must be the first function called in the constructor
    // the 'super' invokes the constructor of the super class
    // the value of 'this' is not defined until 'super' is called
    super(firstName, lastName);

    // if this line is executed before the call to 'super' above
    // an error will occur saying that 'this' is not defined
    this.studentId = studentId;
  }

  getStudentInfo() {
    return this.studentId + " " + this.lastName + ", " + this.firstName;
  }

}

var student = new Student(1, "Bob", "Smith");</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [extends.js]</p>
<p>JavaScript objects only allow single inheritance, and there is no built-in support for interfaces (TypeScript offers interfaces).</p>
<p>By adopting and formalizing many current JavaScript object design patterns, ES2015 classes greatly improves the syntax to define object inheritance, getter/setter properties. While ES2015 classes do not change the nature of prototype inheritance, it does make prototype inheritance more accessible to JavaScript developers. I hope that this new syntax will allow new and old JavaScript developers alike to expand their understanding and use of prototype inheritance in JavaScript.</p>
<p><a href="https://www.accelebrate.com/blog/javascript-es2015-classes-and-properties-part-2-of-2/">JavaScript ES2015 Classes and Properties (Part 2 of 2)</a></p>

<p>Author: Eric Greene, one of Accelebrate's instructors.</p>

                          </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t13" name="t13"></a><h1>13 : JavaScript ES2015 Classes and Properties (Part 2 of 2)</h1>
					<span class="ref-site">https://www.accelebrate.com/blog/javascript-es2015-classes-and-properties-part-2-of-2/</span>
					<div class="tutorial__content">
<div class="entry-content">
                            <h2><strong>Classes, Objects and Properties </strong></h2>
<p>In the previous post, <a href="https://www.accelebrate.com/blog/javascript-es6-classes-and-prototype-inheritance-part-1-of-2/">JavaScript ES2015 Classes and Prototype Inheritance (Part 1 of 2)</a>, we explored the new class syntax and the many intricacies of prototype inheritance.</p>
<p>In this post, we will continue to explore properties that can be configured with the new class syntax and made available on objects that are instantiated. In particular, we will explore function properties, accessor properties, and static properties. The sharing of functions with multiple objects is the primary purpose of prototype inheritance ; therefore, understanding how to configure functions on classes is important.</p>
<p>Accessor properties have been around since the days of ECMAScript 5 (ES5), yet many developers do not know they even exist in the language. We will examine the new class syntax which makes them easier to work with.</p>
<p>Finally, many programming languages offer static members on class definitions. Static members are directly available on the class, with no specific instance required. Such properties are commonly used for helper functions related to the class. Even though there is no concept of static properties in JavaScript, the new <strong>class</strong> syntax offers a kind of static property through the <strong>static</strong> keyword.&nbsp; We will dive deeper into those as well. Use of static variables in certain cases was originally popularized by Java.&nbsp; You can read an excellent tutorial on this concept at <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html', 'https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html');" target="_blank">https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html</a>.</p>
<h2><strong>Function Properties </strong></h2>
<p>In practice, the primary purpose of prototype inheritance is to allow the inheritance of function properties (properties which point to any kind of function) from the parent object to the child object. Generally, value properties should exist directly on the child object because values are typically specific to a particular child object. Additionally, traversing the prototype chain to retrieve an object's values is inefficient. However, function properties are different from value properties. Rarely are function implementations specific to a particular object, therefore, sharing the same function object between multiple objects reduces memory consumption by the JavaScript application.</p>
<p>The key to different objects sharing the same function object is that the context of function execution is always determined by how the function is called, not the lexical position of the function in the source code. This flexibility means the same function can be used with any object, and the value of <strong>this</strong> within the function will always refer to the object which qualified the function call.</p>
<pre><code>// 'getFullName' function object
function getFullName() {
&nbsp;   return this.firstName + " " + this.lastName;
}

var person1 = {
  firstName: "Bob",
  lastName: "Smith",
  // property named 'getFullName' referencing the 'getFullName' function object above
  getFullName: getFullName
};

var person2 = {
  firstName: "Tim",
  lastName: "Johnson",
  // property named 'getFullName' referencing the 'getFullName' function object above
  getFullName: getFullName
};

// outputs "Bob Smith"
console.log(person1.getFullName());

// outputs "Tim   Johnson"
console.log(person2.getFullName());

// outputs "true" because both properties point to the same function
console.log(person1.getFullName === person2.getFullName);</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [this.js]</p>
<p>The property ‘getFullName' on both the person1 and person2 objects points to the same ‘getFullName' function object. By reusing the same function object for both objects (and the number of objects is not limited), less memory is used while allowing the function to be shared between different objects.</p>
<p>This concept, combined with prototype inheritance, allows for a function object to be defined on the prototype object. &nbsp;All objects inheriting from the prototype can use the same function with the value of <strong>this</strong> for each function call to be specific to the object against which the function is being executed.</p>
<p>To define properties to be inherited from the prototype, the following syntax is used.</p>
<pre><code>"use strict";

class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // function definition
  // a property referencing the function will exist on
  // the prototype object, not on each instance of Person
  getFullName() {
    return this.firstName + " " +   this.lastName;
  }
}

var person = new Person("Bob", "Smith");
// invoke the function on the instance
// the function is referenced on the prototype
// to find the function, the prototype chain is
// traversed, then function is executed within
// the context of the 'person' instance
console.log(person.getFullName());</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [functions.js]</p>
<p>Observe how the function object ‘getFullName' is defined without using the <strong>function</strong> keyword. With the ES2015 class syntax, the keyword <strong>function</strong> is omitted from the function object definitions.&nbsp; This function will not be a direct property of the person object; rather, it will be on the Person prototype that the person object will inherit from.</p>
<h2><strong>Getter/Setter Properties</strong></h2>
<p>Getter and setter properties are not new to JavaScript, even though few JavaScript developers know that they exist or how to use them.&nbsp; With the addition of property descriptors in ES5, object properties could be defined with property descriptors to be either standard value properties or to use accessor functions for getting and setting the values of properties. Developers from a .NET background are familiar with the accessor pattern for properties since .NET uses accessors for properties in .NET class definitions.</p>
<pre><code>"use strict";
class Person {

constructor(firstName, lastName) {
  // internal properties can be prefixed with an underscore
  this._firstName = firstName;
  this._lastName = lastName;
}

// the name of the property is used when defining the accessor functions
get firstName() {
  // return the value of the internal property,
  // other logic can be performed here as well
  // internal properties are a convention, not
  // part of the JavaScript languagereturn this._firstName;
}

// the accessor functions are defined on the prototype, while
// the values are stored on internal properties on the instance
set firstName(value) {
  // set the value of the internal property,
  // validation or other logic can go here as well
  this._firstName = value;
  }
}

var person = new Person("Bob", "Smith");

// properties are set like normal value properties, the accessors are implicitly called
person.firstName = "Tommy";

// get operations work in a similar fashion
console.log(person.firstName);</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [accessors.js]</p>
<h2><strong>Static Properties</strong></h2>
<p>As first mentioned in the <strong>extends</strong> function source code comments above, JavaScript provides a convention for defining static properties for objects.&nbsp; ES2015 classes continue this convention through the formalized keyword <strong>static</strong>.</p>
<pre><code>"use strict";

class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  //   static function definition
  // not accessible on the instance
  // function is defined on the class (function) object
  // itself, not the prototype; therefore, its not
  // inherited and cannot be shadowed (overridden)
  // by a child object
  static getFormattedName(person) {
    return person.lastName + ", " + person.firstName;
  }
}

var person = new Person("Bob", "Smith"); // reference the static function directly on the class (function) object
console.log(Person.getFormattedName(person));</code></pre>
<p>Static function are defined directly on the class itself, and are not accessible using the <strong>this</strong> object. Static functions are primarily used as helper functions related to the class.</p>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [static.js]</p>
<h2><strong>Private Properties</strong></h2>
<p>ES2015 still does not formally support the use of public, protected, and private access modifiers for object properties.&nbsp; With JavaScript, all properties are public.&nbsp; Some preprocessors such as TypeScript added transpile time support for public and private access modifiers.&nbsp; With a little JavaScript wizardry using class expressions and closures, private properties can be achieved.</p>
<pre><code>"use strict";

var Person = {
  // a wrapper function is needed to create new private variable for each
  // instance of the class
  // the class definition source code my be defined in the wrapper function
  // because closures dependent the lexical structure of the code
  create: function(...cargs) {
    let _name = undefined;
    return new class {
      constructor(name) {
&nbsp;       _name = name;
      }
      get name() {
        return _name;
      }
      set name(value) {
        _name = value;
      }
    }(...cargs);
  }
};

// call the wrapper function to   create the object
var person =   Person.create("Bob Smith");
console.log(person.name);</code></pre>
<p><a href="http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip" onclick="__gaTracker('send', 'event', 'download', 'http://lib.accelebrate.com/blog/JavaScript_ES2015_Classes.zip');">Click Here to Download the Code</a> [private.js]</p>
<p>While this will work, it has some downsides. While closures are used all of the time in JavaScript, they can hurt application performance and consume extra memory. Creating more closures to simply hide some properties is not generally worth it. Also, a new class definition object is created with each call to the wrapper function. The class definition must be defined in the wrapper function to leverage closures. The creation of this class definition over and over will also consume more memory and be inefficient.</p>
<p>It is key to remember that JavaScript is not C++, Java, or C#. It does not support classical inheritance and is not currently designed to mimic the typical features of classical inheritance such as access modifiers. Prefixing private (better termed internal) properties with an underscore or other character (Angular.js uses a $) is a commonly accepted pattern, and achieves the same goal without incurring the performance and memory overhead.</p>
<h2><strong>Conclusion</strong></h2>
<p>By adopting and formalizing many current JavaScript object design patterns, ES2015 classes greatly improves the syntax to define object inheritance, getter/setter properties. It also clarifies the differences between which properties are defined on the object instance, which are inherited, and which once are considered static. While ES2015 classes do not change the nature of prototype inheritance, they do make prototype inheritance more accessible to JavaScript developers. Hopefully this new syntax will allow new and old JavaScript developers alike to further expand their understanding and use of prototype inheritance in JavaScript.</p>
<p><a href="https://www.accelebrate.com/blog/javascript-es6-classes-and-prototype-inheritance-part-1-of-2/">JavaScript ES2015 Classes and Prototype Inheritance (Part 1 of 2)</a></p>

<p>Author: Eric Greene, one of Accelebrate's instructors.</p>

              
                          </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t14" name="t14"></a><h1>14 : ES6 - classes and inheritance</h1>
					<h3>Let's talk about ECMAScript 2015</h3>
					<span class="ref-site"></span>
					<div class="tutorial__content">
<div class="postArticle-content js-postField js-notesSource js-trackedPost" data-post-id="607804080906" data-source="post_page" data-collection-id="c8958ce340e4" data-tracking-context="postPage" data-scroll="native"><section name="1e20" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0cdb" id="0cdb" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">OO</strong> keywords is probably the most awaited features in ES6. <strong class="markup--strong markup--p-strong">Classes</strong> are something like another syntactic sugar over the prototype-based OO pattern. We now have one, concise way to make class patterns easier to use.</p><blockquote name="1356" id="1356" class="graf graf--pullquote graf-after--p">Over the prototype-based <strong class="markup--strong markup--pullquote-strong">OO pattern</strong> to ensure <strong class="markup--strong markup--pullquote-strong">backwards compatibility</strong>.</blockquote><h4 name="790a" id="790a" class="graf graf--h4 graf-after--pullquote">Overview — an example of ES6 class syntax and ES5 equivalent</h4><pre name="5155" id="5155" class="graf graf--pre graf-after--h4"><strong class="markup--strong markup--pre-strong">class</strong> Vehicle {<br> <br>  <strong class="markup--strong markup--pre-strong">constructor</strong> (name, type) {<br>    this.name = name;<br>    this.type = type;<br>  }<br> <br>  getName () {<br>    return this.name;<br>  }<br> <br>  getType () {<br>    return this.type;<br>  }<br> <br>}</pre><pre name="a1ce" id="a1ce" class="graf graf--pre graf-after--pre">let car = new Vehicle('Tesla', 'car');<br>console.log(car.getName()); // Tesla<br>console.log(car.getType()); // car</pre><p name="5380" id="5380" class="graf graf--p graf-after--pre">It's naive example, but we can see a new keywords as <strong class="markup--strong markup--p-strong">class </strong>and <strong class="markup--strong markup--p-strong">constructor</strong>.</p><p name="02b4" id="02b4" class="graf graf--p graf-after--p">ES5 equivalent could be something like this:</p><pre name="76c8" id="76c8" class="graf graf--pre graf-after--p">function Vehicle (name, type) {<br>  this.name = name;<br>  this.type = type;<br>};<br> <br>Vehicle.prototype.getName = function getName () {<br>  return this.name;<br>};<br> <br>Vehicle.prototype.getType = function getType () {<br>  return this.type;<br>};</pre><pre name="609a" id="609a" class="graf graf--pre graf-after--pre">var car = new Vehicle('Tesla', 'car');<br>console.log(car.getName()); // Tesla<br>console.log(car.getType()); // car</pre><blockquote name="01c1" id="01c1" class="graf graf--pullquote graf-after--pre">Classes support prototype-based <strong class="markup--strong markup--pullquote-strong">inheritance</strong>, <strong class="markup--strong markup--pullquote-strong">super calls</strong>, <strong class="markup--strong markup--pullquote-strong">instance</strong> and <strong class="markup--strong markup--pullquote-strong">static methods</strong> and <strong class="markup--strong markup--pullquote-strong">constructors</strong>.</blockquote><p name="49a5" id="49a5" class="graf graf--p graf-after--pullquote">It's simple. We instantiate our classes the same way, but let's add some..</p><h4 name="1425" id="1425" class="graf graf--h4 graf-after--p">inheritance</h4><p name="0de8" id="0de8" class="graf graf--p graf-after--h4">..to it and start from ES5 example:</p><pre name="b4a7" id="b4a7" class="graf graf--pre graf-after--p">function Vehicle (name, type) {<br>  this.name = name;<br>  this.type = type;<br>};<br> <br>Vehicle.prototype.getName = function getName () {<br>  return this.name;<br>};<br> <br>Vehicle.prototype.getType = function getType () {<br>  return this.type;<br>};</pre><pre name="0439" id="0439" class="graf graf--pre graf-after--pre">function Car (name) {<br>  Vehicle.call(this, name, ‘car');<br>}</pre><pre name="7c27" id="7c27" class="graf graf--pre graf-after--pre">Car.prototype = Object.create(Vehicle.prototype);<br>Car.prototype.constructor = Car;<br>Car.parent = Vehicle.prototype;<br>Car.prototype.getName = function () {<br>  return 'It is a car: '+ this.name;<br>};</pre><pre name="03eb" id="03eb" class="graf graf--pre graf-after--pre">var car = new Car('Tesla');<br>console.log(car.getName()); // It is a car: Tesla<br>console.log(car.getType()); // car</pre><p name="36d1" id="36d1" class="graf graf--p graf-after--pre">And now look at the ES6 version:</p><pre name="62f6" id="62f6" class="graf graf--pre graf-after--p">class Vehicle {<br> <br>  constructor (name, type) {<br>    this.name = name;<br>    this.type = type;<br>  }<br> <br>  getName () {<br>    return this.name;<br>  }<br> <br>  getType () {<br>    return this.type;<br>  }<br> <br>}</pre><pre name="be03" id="be03" class="graf graf--pre graf-after--pre">class Car <strong class="markup--strong markup--pre-strong">extends</strong> Vehicle {<br> <br>  constructor (name) {<br>    <strong class="markup--strong markup--pre-strong">super</strong>(name, 'car');<br>  }<br> <br>  getName () {<br>    return 'It is a car: ' + <strong class="markup--strong markup--pre-strong">super</strong>.getName();<br>  }<br> <br>}</pre><pre name="b019" id="b019" class="graf graf--pre graf-after--pre">let car = new Car('Tesla');<br>console.log(car.getName()); // It is a car: Tesla<br>console.log(car.getType()); // car</pre><p name="85e3" id="85e3" class="graf graf--p graf-after--pre">We see how easy is to implement inheritance with ES6. It's finally looking like in other OO programming languages. We use <strong class="markup--strong markup--p-strong">extends</strong> to inherit from another class and the <strong class="markup--strong markup--p-strong">super</strong> keyword to call the parent class (function). Moreover, <strong class="markup--strong markup--p-strong">getName()</strong> method was overridden in subclass <strong class="markup--strong markup--p-strong">Car</strong>.</p><blockquote name="da89" id="da89" class="graf graf--pullquote graf-after--p"><strong class="markup--strong markup--pullquote-strong">super</strong> — previously to achieve such functionality in Javascript required the use of <strong class="markup--strong markup--pullquote-strong">call</strong> or&nbsp;<strong class="markup--strong markup--pullquote-strong">apply</strong></blockquote><h4 name="9e79" id="9e79" class="graf graf--h4 graf-after--pullquote">static</h4><pre name="95ac" id="95ac" class="graf graf--pre graf-after--h4">class Vehicle {<br> <br>  constructor (name, type) {<br>    this.name = name;<br>    this.type = type;<br>  }<br> <br>  getName () {<br>    return this.name;<br>  }<br> <br>  getType () {<br>    return this.type;<br>  }<br> <br>  <strong class="markup--strong markup--pre-strong">static</strong> create (name, type) {<br>    return new Vehicle(name, type);<br>  }<br> <br>}</pre><pre name="9311" id="9311" class="graf graf--pre graf-after--pre">let car = Vehicle.create('Tesla', 'car');<br>console.log(car.getName()); // Tesla<br>console.log(car.getType()); // car</pre><p name="f880" id="f880" class="graf graf--p graf-after--pre">Classes gives us an opportunity to create static members. We don't have to use the <strong class="markup--strong markup--p-strong">new</strong> keyword later to instantiate a class.</p><blockquote name="31bd" id="31bd" class="graf graf--pullquote graf-after--p"><strong class="markup--strong markup--pullquote-strong">static</strong> methods (properties) are also inherited<br>and could be called by&nbsp;<strong class="markup--strong markup--pullquote-strong">super</strong></blockquote><h4 name="425b" id="425b" class="graf graf--h4 graf-after--pullquote">get /&nbsp;set</h4><p name="6358" id="6358" class="graf graf--p graf-after--h4">Other great things in upcoming ES6 are <strong class="markup--strong markup--p-strong">getters</strong> and <strong class="markup--strong markup--p-strong">setters</strong> for object properties. They allow us to run the code on the reading or writing of a property.</p><pre name="9c1d" id="9c1d" class="graf graf--pre graf-after--p">class Car {<br> <br>  constructor (name) {<br>    this._name = name;<br>  } <br> <br>  <strong class="markup--strong markup--pre-strong">set</strong> name (name) {<br>    this._name = name;<br>  }<br> <br>  <strong class="markup--strong markup--pre-strong">get</strong> name () {<br>    return this._name;<br>  }<br> <br>}</pre><pre name="d7cb" id="d7cb" class="graf graf--pre graf-after--pre">let car = new Car('Tesla');<br>console.log(car.name); // Tesla</pre><pre name="4148" id="4148" class="graf graf--pre graf-after--pre">car.name = 'BMW';<br>console.log(car.name); // BMW</pre><p name="cfec" id="cfec" class="graf graf--p graf-after--pre">I use ‘<strong class="markup--strong markup--p-strong">_</strong>' prefix to create a (<strong class="markup--strong markup--p-strong">tmp</strong>) field to store name property.</p><h4 name="acd2" id="acd2" class="graf graf--h4 graf-after--p">Enhanced Object Properties</h4><p name="e121" id="e121" class="graf graf--p graf-after--h4">The last thing I have to mention is <strong class="markup--strong markup--p-strong">property shorthand</strong>, <strong class="markup--strong markup--p-strong">computed property names</strong> and <strong class="markup--strong markup--p-strong">method properties</strong>.</p><p name="ff5c" id="ff5c" class="graf graf--p graf-after--p">ES6 gives us shorter syntax for common <strong class="markup--strong markup--p-strong">object property</strong> definition:</p><pre name="9d92" id="9d92" class="graf graf--pre graf-after--p">// <strong class="markup--strong markup--pre-strong">ES6</strong><br>let x = 1,<br>    y = 2,<br>    obj = { <strong class="markup--strong markup--pre-strong">x</strong>, <strong class="markup--strong markup--pre-strong">y</strong> };</pre><pre name="5977" id="5977" class="graf graf--pre graf-after--pre">console.log(obj); // Object { x: 1, y: 2 }</pre><pre name="ba54" id="ba54" class="graf graf--pre graf-after--pre">// <strong class="markup--strong markup--pre-strong">ES5</strong><br>var x = 1,<br>    y = 2,<br>    obj = {<br>      <strong class="markup--strong markup--pre-strong">x: x,<br>      y: y</strong><br>    };</pre><pre name="b686" id="b686" class="graf graf--pre graf-after--pre">console.log(obj); // Object { x: 1, y: 2 }</pre><p name="b19a" id="b19a" class="graf graf--p graf-after--pre graf--trailing">As you can see, this works because the property value has the same name as the property identifier.</p></div></div></section><section name="9b3a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="7e78" id="7e78" class="graf graf--p graf--leading">Another thing is ES6 support for <strong class="markup--strong markup--p-strong">computed names</strong> in object property definitions:</p><pre name="aa3b" id="aa3b" class="graf graf--pre graf-after--p">// <strong class="markup--strong markup--pre-strong">ES6</strong><br>let getKey = () =&gt; '123',<br>    obj = {<br>      foo: 'bar',<br>      [<strong class="markup--strong markup--pre-strong">'key_' + getKey()</strong>]: 123<br>    };</pre><pre name="ff27" id="ff27" class="graf graf--pre graf-after--pre">console.log(obj); // Object { foo: 'bar', key_123: 123 }</pre><pre name="8077" id="8077" class="graf graf--pre graf-after--pre">// <strong class="markup--strong markup--pre-strong">ES5<br></strong>var getKey = function () {<br>      return '123';<br>    },<br>    obj = {<br>      foo: 'bar'<br>    };</pre><pre name="d2d9" id="d2d9" class="graf graf--pre graf-after--pre">obj[<strong class="markup--strong markup--pre-strong">'key_' + getKey()</strong>] = 123;</pre><pre name="3595" id="3595" class="graf graf--pre graf-after--pre graf--trailing">console.log(obj); // Object { foo: 'bar', key_123: 123 }</pre></div></div></section><section name="609e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="f811" id="f811" class="graf graf--p graf--leading">The one last thing is <strong class="markup--strong markup--p-strong">method properties</strong> seen in classes above. We can even use it in object definitions:</p><pre name="af18" id="af18" class="graf graf--pre graf-after--p">// <strong class="markup--strong markup--pre-strong">ES6</strong><br>let obj = {<br>  name: 'object name',<br>  <strong class="markup--strong markup--pre-strong">toString</strong> () { // '<strong class="markup--strong markup--pre-strong">function</strong>' keyword is omitted here<br>    return this.name;<br>  }<br>};</pre><pre name="c736" id="c736" class="graf graf--pre graf-after--pre">console.log(obj.toString()); // object name</pre><pre name="01b5" id="01b5" class="graf graf--pre graf-after--pre">// <strong class="markup--strong markup--pre-strong">ES5<br></strong>var obj = {<br>  name: 'object name',<br>  <strong class="markup--strong markup--pre-strong">toString</strong>: <strong class="markup--strong markup--pre-strong">function</strong> () {<br>    return this.name;<br>  }<br>};</pre><pre name="c3c9" id="c3c9" class="graf graf--pre graf-after--pre graf--trailing">console.log(obj.toString()); // object name</pre></div></div></section></div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t15" name="t15"></a><h1>15 : Learning ES6: Classes</h1>
					<span class="ref-site">https://www.eventbrite.com/engineering/learning-es6-classes/</span>
					<div class="tutorial__content">
<div class="entry-content">
		
<p>We're going from <a href="http://www.eventbrite.com/engineering/learning-es6-enhanced-object-literals/">enhanced object literals</a> that look a lot like classes to actual classes in ES6. We'll learn, however, that these aren't really classes, but syntactic sugar over the existing prototype functions in JavaScript. Let's continue on with the <a href="http://www.eventbrite.com/engineering/tag/learning-es6/"><em>Learning ES6</em> series</a> series!</p>
<h2 id="tldr">TL;DR</h2>
<p>ECMAScript 6 provides syntactic sugar over the prototype-based, object-oriented pattern in JavaScript. ES6 classes provide support for constructors, instance and static methods, (prototype-based) inheritance, and super calls. Instance and static properties are not (yet) supported.</p>
<div><pre><code>// Define base Note class
class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;static add(...properties) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `this` will be the class on which
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `add()` was called increment counter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++this._idCounter;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let id = `note${this._idCounter}`;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// construct a new instance of the note passing in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// arguments after the ID. This is so subclasses can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get all of the arguments needed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let note = new this(id, ...properties);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add note to the lookup by ID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._noteLookup[id] = note;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return note;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;static get(id) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this._noteLookup[id];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// read-only
&nbsp;&nbsp;&nbsp;&nbsp;get id() { return this._id; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get content() { return this._content; }
&nbsp;&nbsp;&nbsp;&nbsp;set content(value) { this._content = value; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get owner() { return this._owner; }
&nbsp;&nbsp;&nbsp;&nbsp;set owner(value) { this._owner = value; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;toString() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `ID: ${this._id}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Content: ${this._content}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Owner: ${this._owner}`;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
// Static "private" properties (not yet supported in class syntax)
Note._idCounter = -1;
Note._noteLookup = {};
&nbsp;
class ColorNote extends Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner, color='#ff0000') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// super constructor must be called first!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._color = color;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get color() { return this._color; }
&nbsp;&nbsp;&nbsp;&nbsp;set color(value) { this._color = value; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;toString() {&nbsp; // computed method names are supported
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Override `toString()`, but call parent/super version
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `${super.toString()}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color: ${this._color}`;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
// `add` factory method is defined on `Note`, but accessible
// on ColorNote subclass
let colorNote = ColorNote.add('My note', 'benmvp', '#0000ff');
&nbsp;
// output: ID: note0
// Content: My Note
// Owner: benmvp
// Color: #0000ff
console.log(`${colorNote}`);
&nbsp;
// output: true
console.log(Note.get('note0') === colorNote);
</code></pre></div>
<p>This is just a quick example of how ES6 classes work. Be sure to clone the <a href="https://github.com/benmvp/learning-es6" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/benmvp/learning-es6', 'Learning ES6 Github repo');"><em>Learning ES6</em> Github repo</a> and take a look at the <a href="http://www.benmvp.com/learning-es6/#classes" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.benmvp.com/learning-es6/#classes', 'classes code examples');">classes code examples</a> page showing off the features in greater detail.</p>
<p>The example also uses <a href="http://www.eventbrite.com/engineering/learning-es6-default-parameters/">default parameters</a>, <a href="http://www.eventbrite.com/engineering/learning-es6-rest-spread-operators/#rest-operator">rest parameters</a>, and the <a href="http://www.eventbrite.com/engineering/learning-es6-rest-spread-operators/#spread-operator">spread operator</a> so you may want to revisit the relevant articles if you're not familiar. It also makes use of <a href="http://www.eventbrite.com/engineering/learning-es6-template-literals-tagged-templates/">template strings</a> for string interpolation, so you should read up on that as well.</p>
<p><span id="more-3296"></span></p>
<h2 id="whats-all-the-fuss">What's all the fuss?</h2>
<p>Before we jump into the nitty gritty details of the ES6 class features, let's take a moment to talk about why the features even exist. Prototype inheritance already exists in JavaScript so why create a new syntax that makes it seem like JavaScript has classes (when it technically doesn't)?</p>
<p>Well JavaScript has always confused new developers by it's lack of classes. Every other object-oriented language has them so their absence in JavaScript is pretty glaring. There are some folks out there who find the inclusion of ES6 classes pointless and misleading since, in the end, it's just syntax sugar over the underlying prototypal inheritance system; a system that is based on first-class functions and the ability to add methods onto their <code>prototype</code> property and call <code>new</code> on them.</p>
<p>However, the proliferation of JavaScript libraries and frameworks to try to make it easier to create classes is a pretty clear indication that there was need for a standard. Most developers don't know or care to know the details of prototypal inheritance, which is why they are using a library in the first place. Having a standard, native, convenient syntax for declaring classes makes them much easier to use and encourages interoperability across libraries and frameworks.</p>
<h2 id="class-declarations">Class declarations</h2>
<p>Let's first talk about class declarations…</p>
<h3 id="base-class">Base class</h3>
<p>Most developers have probably never had to do this because they create classes using their favorite library or framework, but the vanilla JavaScript way of creating a "class" looks something like:</p>
<div><pre><code>// constructor function
function Note(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
}
</code></pre></div>
<p>The <code>Note</code> "class" is actually a function. We just call <code>new</code> on it to turn it into a class. The arguments for the "constructor" are defined as the arguments of the function. Just looking at the code, you wouldn't even know that <code>Note</code> is intended to be a class. Your only indication is that we're assigning the arguments to <code>this</code>. This is generally a good indication that the function will be used as a class. But this is not at all intuitive, especially if you're new to JavaScript.</p>
<p>The equivalent ES6 code introduces the <code>class</code> keyword and looks like:</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>Anybody familiar with other programming languages can understand what's going on here. We're defining a class called <code>Note</code> and its constructor takes 3 parameters. Those parameters are then assigned to instance properties.</p>
<p>If a class doesn't need any special constructor handling, it can be omitted:</p>
<div><pre><code>class Note {
&nbsp;
}
</code></pre></div>
<p>The class declaration is just syntactic sugar on top of the ES5 constructor function. The <code>Note</code> class will actually create a function that behaves like <code>constructor</code>:</p>
<div><pre><code>const Note = function(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
};
</code></pre></div>
<p>The <code>const</code> is actually important in this recreation because classes declared using the ES6 class syntax are <code>const</code>. Their values cannot be reassigned after they are defined. This recreation also shows that ES6 classes are still functions even though syntactically they no longer look like functions. Here's the proof:</p>
<div><pre><code>// output: true
console.log(typeof Note === 'function');
</code></pre></div>
<h3 id="inherited-class">Inherited class</h3>
<p>The biggest win in my opinion for this new ES6 class syntax is creating derived or inherited classes. The ES5 code to create a derived <code>ColorNote</code> class is even less clear:</p>
<div><pre><code>function ColorNote(id, content, owner, color) {
&nbsp;&nbsp;&nbsp;&nbsp;Note.call(this, id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;this.color = color || '#ff0000';
}
&nbsp;
ColorNote.prototype = new Note();
</code></pre></div>
<p><code>ColorNote</code> inherits from <code>Note</code>, and in order to do so it must overwrite <code>Color.prototype</code> with a new object created from <code>Note</code> to inherit the methods. It also has to call <code>Note.call()</code> in the constructor as an equivalent of calling <code>super</code> constructor.</p>
<p>This code is as simple as it gets too. To be fully compliant we should use <code>Object.create</code>, check to ensure that <code>Note</code> is in fact a constructor function, etc. You'll find that there are lots of variations on "how to inherit a class in JavaScript." But once again, most developers have never had to worry about this because of libraries and frameworks. I imagine that most JavaScript developers (including this one) don't even know how to create an inherited class from scratch off the top of their head.</p>
<p>In ES6, derived classes use the <code>extends</code> keyword to specify the class from which the new class should inherit:</p>
<div><pre><code>class ColorNote extends Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner, color='#ff0000') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// super constructor must be called first!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>The <code>extends</code> keyword is just ES6 syntactic sugar over the ES5 implementation. The prototypes are automatically adjusted and you can access the base class constructor using <code>super()</code>. The nice thing about the ES6 class syntax is that unlike the ES5 syntax, the <code>Note</code> identifier is only used in the class declaration (<code>extends Note</code>) and not in the implementation of the constructor.</p>
<p>If you specify a constructor in the inherited class (as in the above example), you must call <code>super()</code> before accessing <code>this</code>. The call to <code>super()</code> is what properly initializes <code>this</code>. If you don't call <code>super()</code>, you'll get an <code>Error</code> when you try to access <code>this</code>. You can of course omit the constructor as well.</p>
<div><pre><code>class ColorNote extends Note {
&nbsp;
}
</code></pre></div>
<h3 id="abstract-base-class">Abstract base class</h3>
<p>An abstract base class is a type of class that is exclusively intended to be inherited. It cannot be directly constructed. The main use case is for the inherited classes to have a common interface. Unfortunately, ES6 classes don't yet leverage the <code>abstract</code> keyword to make abstract base classes, but you <em>can</em> use <code>new.target</code> (also introduced in ES6) to simulate it.</p>
<p>Within a constructor, <code>new.target</code> is a reference to the class that is to be constructed:</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(new.target === Note);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
let note = new Note();
&nbsp;
// output: true
</code></pre></div>
<p>However, when an inherited class is constructed, <code>new.target</code> points to the inherited class:</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(new.target === Note);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
class ColorNote extends Note {
&nbsp;
}
let colorNote = new ColorNote();
&nbsp;
// output: false
</code></pre></div>
<p>So, to simulate an abstract base class, just throw an exception if <code>new.target</code> is the base class, which would mean that the base class was was attempted to be constructed:</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === Note) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Note cannot be directly constructed.')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
class ColorNote extends Note {
&nbsp;
}
let note = new Note();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // error!
let colorNote = new ColorNote();&nbsp;&nbsp; // ok
</code></pre></div>
<h2 id="instance-methods">Instance methods</h2>
<p>The syntax for defining methods in ES6 classes has been streamlined and resembles <a href="http://www.eventbrite.com/engineering/learning-es6-enhanced-object-literals/#method-definition-shorthand">object literal method shorthand</a> (but without the comma separators):</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;toString() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `ID: ${this.id}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Content: ${this.content}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Owner: ${this.owner}`;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>Methods (like <code>toString()</code> in the above example) get auto-added to the prototype instead of having to manually do it in ES5:</p>
<div><pre><code>function Note(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
}
&nbsp;
Note.prototype.toString = function() {
&nbsp;&nbsp;&nbsp;&nbsp;return 'ID: ' + this.id +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'\nContent: ' + this.content +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'\nOwner:' + this.owner;
};
</code></pre></div>
<p>Just like with enhanced object literals, method names in classes can also be computed:</p>
<div><pre><code>class ColorNote extends Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner, color='#ff0000') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// super constructor must be called first!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;['to' + 'String']() { // computed method names are supported
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Override `toString()`, but call
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// parent/super version first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `${super.toString()}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color: ${this.color}`;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>In the above example, the <code>ColorNote</code> inherited class redefines the <code>toString()</code> method from the <code>Note</code> base class. If an inherited class has a method with the same name as the base class, it <em>overrides</em> the base class implementation. However, the inherited class can call <code>super.[methodName]</code> to call the base version, which is what is happening in the above example. We call <code>super.toString()</code> and concatenate additional information specific to <code>ColorNote</code> to it.</p>
<h2 id="static-methods">Static methods</h2>
<p>Static methods are indicated with the <code>static</code> keyword. They are methods on a class that do not depend on an instance of a class in their implementation. In short, they don't need <code>this</code> to be a reference to an instance. In fact, in a static method <code>this</code> is a reference to the class itself.</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;static add(...properties) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// `this` will be the class on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// which `add()` was called increment counter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++this._idCounter;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let id = `note${this._idCounter}`;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// construct a new instance of the note passing in the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// arguments after the ID. This is so subclasses can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get all of the arguments needed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let note = new this(id, ...properties);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add note to the lookup by ID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._noteLookup[id] = note;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return note;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;static get(id) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this._noteLookup[id];
&nbsp;&nbsp;&nbsp;&nbsp;}
}
&nbsp;
Note._idCounter = -1;
Note._noteLookup = {};
</code></pre></div>
<p>I will explain <code>Note._idCounter</code> and <code>Note._noteLookup</code> in the <a href="#properties">Properties section</a>. This ES6 syntactic sugar simplifies creating a static method in comparison to the ES5 equivalent:</p>
<div><pre><code>function Note(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
}
&nbsp;
Note._idCounter = -1;
Note._noteLookup = {};
&nbsp;
Note.add = function(content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;var id, note;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// `this` will be the class on which `add()` was called
&nbsp;&nbsp;&nbsp;&nbsp;// increment counter
&nbsp;&nbsp;&nbsp;&nbsp;++this._idCounter;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;id = 'note' + this._idCounter;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// construct a new instance of the note passing in the
&nbsp;&nbsp;&nbsp;&nbsp;// arguments after the ID. This is so subclasses can
&nbsp;&nbsp;&nbsp;&nbsp;// get all of the arguments needed
&nbsp;&nbsp;&nbsp;&nbsp;note = new Note(id, content, owner);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// add note to the lookup by ID
&nbsp;&nbsp;&nbsp;&nbsp;this._noteLookup[id] = note;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return note;
};
&nbsp;
Note.get = function(id) {
&nbsp;&nbsp;&nbsp;&nbsp;return this._noteLookup[id];
};
</code></pre></div>
<p>One thing to note with ES6 classes. If a base class has static methods (such as <code>Note.add()</code>), then those static methods are also available on the derived class (such as <code>ColorNote.add()</code>). This didn't happen by default with ES5 classes unless the methods were explicitly copied over.</p>
<h2 id="accessor-properties">Accessor properties</h2>
<p><a href="http://ejohn.org/blog/javascript-getters-and-setters/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://ejohn.org/blog/javascript-getters-and-setters/', 'Accessor properties');">Accessor properties</a> were introduced in ES5 as a simplified way of providing getters and setters for JavaScript prototype functions. The same syntax works with ES6:</p>
<div><pre><code>class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === Note) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Note cannot be directly constructed.')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this._owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;// read-only
&nbsp;&nbsp;&nbsp;&nbsp;get id() { return this._id; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get content() { return this._content; }
&nbsp;&nbsp;&nbsp;&nbsp;set content(value) { this._content = value; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;get owner() { return this._owner; }
&nbsp;&nbsp;&nbsp;&nbsp;set owner(value) { this._owner = value; }
}
</code></pre></div>
<p>This accessor property is created as non-enumerable, just like any other method would be, and is created on the <code>Note.prototype</code>. Accessor properties are just like methods in how they are defined except they have the <code>get</code>/<code>set</code> keyword in front of them. And since they are just like methods, they can also be marked <code>static</code> as well.</p>
<p>Since accessor properties were introduced with ES5, they of course do not work in ES3 JavaScript engines such as Internet Explorer 8 and below. In addition, transpilers cannot transpile accessor properties down to ES3. Only use accessor properties if you only need to support higher than IE8.</p>
<h2 id="properties">Properties</h2>
<p>You may have noticed that our ES6 code defined some static properties like so:</p>
<div><pre><code>Note._idCounter = -1;
Note._noteLookup = {};
</code></pre></div>
<p>This is exactly how it's done in ES5. It's after the class is defined that we then add additional (static) properties to it. This is because ES6 class syntax does not support static properties. It also doesn't support instance properties either. We got around the lack of instance properties by defining our <code>id</code>, <code>content</code> &amp; <code>owner</code> accessor properties within the class syntax, but those accessor properties were just wrappers of <code>_id</code>, <code>_content</code> &amp; <code>_owner</code>, which were instance properties assigned in the constructor. There is no such work-around for static properties besides just adding properties after the class definition as we've done.</p>
<p>Although ES6 class syntax doesn't support static or instance properties, there is an <a href="https://github.com/jeffmo/es-class-fields-and-static-properties" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/jeffmo/es-class-fields-and-static-properties', 'ES Class Fields &amp; Static Properties');">ES Class Fields &amp; Static Properties</a> specification under development. It appears to still be in Stage 1 so it will not be included in ES7/ES2016. Babel already supports transpiling static &amp; instance properties, and React makes heavy use of it. A specification that is still under development is not guaranteed to ultimately make it to approved status (see <a href="https://esdiscuss.org/topic/an-update-on-object-observe" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://esdiscuss.org/topic/an-update-on-object-observe', 'Object.observe');"><code>Object.observe</code></a> as a huge example), so I tend to avoid using features prematurely.</p>
<p>The <a href="https://github.com/jeffmo/es-class-fields-and-static-properties#why" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/jeffmo/es-class-fields-and-static-properties#why', 'rationale for instance properties');">rationale for instance properties</a>:</p>
<blockquote><p>The current idiomatic means of initializing a property on a class instance does not provide an expressively distinct way to "declare" them as part of the structure of a class. One must assign to an expando property on <code>this</code> in the constructor – or anywhere, really. This poses an inconvenience to tooling (and also often humans) when trying to deduce the <em>intended</em> set of members for a class simply because there is no clear distinction between initialization logic and the intended shape of the class.</p>
<p>Additionally, because instance-generated properties often need to be setup during class construction for object initialization, derived classes that wish to declare/initialize their own properties must implement some boilerplate to execute base class initialization first.</p></blockquote>
<p>And the <a href="https://github.com/jeffmo/es-class-fields-and-static-properties#why-1" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/jeffmo/es-class-fields-and-static-properties#why-1', 'rationale for static properties');">rationale for static properties</a>:</p>
<blockquote><p>Currently it's possible to express static methods on a class definition, but it is not possible to declaratively express static properties. As a result people generally have to assign static properties on a class after the class declaration – which makes it very easy to miss the assignment as it does not appear as part of the definition.</p></blockquote>
<p>Hopefully they (officially) come soon!</p>
<h2 id="class-expressions">Class expressions</h2>
<p>As we saw earlier, ES6 classes are just syntactic sugar over prototype constructor functions. And as we know, there are two ways to define a function: a function declaration and a function expression. Similarly an ES6 class can be defined either via a class declaration (what we've seen thus far) or a class expression. Let's talk about the latter.</p>
<p>A class expression can be assigned to a variable:</p>
<div><pre><code>const Note = class {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
};
</code></pre></div>
<p>A class expression can be passed into functions as arguments:</p>
<div><pre><code>const NoteWithFancy = mixin(
&nbsp;&nbsp;&nbsp;&nbsp;class {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fancy: function() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// method to be added to prototype of class expression
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
)
</code></pre></div>
<p>Just like functions, class expressions can be immediately invoked to create immediately-invoked class expressions (IICE), essentially creating a one-off singleton:</p>
<div><pre><code>let noteSingleton = new (class {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
}) (0, 'some content', benmvp);
</code></pre></div>
<p>Perhaps the most powerful aspect of derived classes in ECMAScript 6 is the ability to inherit from a class expression. We can use <code>extends</code> with <em>any</em> expression. If that expression resolves to a function with <code>[[Construct]]</code> and a <code>prototype</code>, that expression can be used as a base class.</p>
<div><pre><code>class ColorNote extends (class {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
}) {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner, color='#ff0000') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// super constructor must be called first!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>This means that an ES6 class can derive from an ES5 prototype constructor function!</p>
<div><pre><code>function Note(id, content, owner) {
&nbsp;&nbsp;&nbsp;&nbsp;this.id = id;
&nbsp;&nbsp;&nbsp;&nbsp;this.content = content;
&nbsp;&nbsp;&nbsp;&nbsp;this.owner = owner;
}
&nbsp;
class ColorNote extends Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor(id, content, owner, color='#ff0000') {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// super constructor must be called first!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(id, content, owner);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>Will talk more about mixing ES6 and ES5 classes in the upcoming <a href="#interoperability">interoperability</a> section.</p>
<h2 id="inheritable-built-ins">Inheritable built-ins</h2>
<p>Let's take a short break from syntactic sugar and talk about some new functionality introduced with ES6. Before in JavaScript, it wasn't (easily) possible to inherit from one of the built-in classes like <code>Array</code>, <code>RegEx</code>, <code>String</code>, etc. The most common class to inherit was <code>Array</code> in order to create stacks, queues, and other list-like data structures. Or you may want to create your own fancy array that inherits from <code>Array</code> in order to add helper methods like <code>first</code>, <code>last</code>, <code>take</code>, etc. that you find in libraries like <a href="http://underscorejs.org/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://underscorejs.org/', 'underscore.js');">underscore.js</a> and <a href="https://lodash.com/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://lodash.com/', 'lodash');">lodash</a>. Imagine if the <code>jQuery</code> object actually inherited from <code>Array</code> instead of just being array-like. It'd be even more powerful.</p>
<p>We can also inherit from the new ES6 APIs like <code>Promise</code> and the new collections (<code>Map</code>, <code>Set</code>, <code>WeakMap</code> &amp; <code>WeakSet</code>) that we'll be talking about soon.</p>
<p>One super useful class to inherit from is the <code>Error</code> class that is thrown with exceptions. Now when you need to throw an exception, you're no longer limited to the handful of native <code>Error</code> classes. You can create your own custom <code>Error</code> subclass. Remember our example from earlier to create an abstract base class? Instead of just throwing a generic <code>Error</code>, we can throw a custom-created <code>Error</code> subclass:</p>
<div><pre><code>class InheritanceError extends Error { }
&nbsp;
class Note {
&nbsp;&nbsp;&nbsp;&nbsp;constructor() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === Note) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error('Note cannot be directly constructed.')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>The class doesn't even have to do anything. But by create a custom <code>Error</code> class, if the error is ever thrown we can now check its type to know what type of error it was instead of having to rely solely on the message:</p>
<div><pre><code>try {
&nbsp;&nbsp;&nbsp;&nbsp;new Note(72, 'Vanilla note', 'benmvp');
}
catch (e) {
&nbsp;&nbsp;&nbsp;&nbsp;// output: true
&nbsp;&nbsp;&nbsp;&nbsp;console.log(e instanceof InheritanceError);
}
</code></pre></div>
<p>The only gotcha with inheritable built-ins is that they cannot be transpiled nor shimmed. The JavaScript engine has to natively support it. This means that it will probably be a while until we can leverage this great functionality. All Internet Explorer browsers have to die first.</p>
<h2 id="es6-classes-vs-es5-prototype-functions">ES6 classes vs ES5 prototype Functions</h2>
<p>I've mentioned a few times how ES6 classes are just syntactic sugar over ES5 prototype constructor functions, but there actually are some differences between them that are worth talking about.</p>
<p>First, class declarations, unlike function declarations, are not hoisted to the top of their enclosing scope. Class declarations act like block-scoped variables so they exist in the <a href="/learning-es6-block-level-scoping-let-const/#entering-the-temporal-dead-zone">temporal dead zone</a> until execution reaches the declaration. You cannot reference a class before it's declared.</p>
<p>Second, all code inside of class declarations runs in strict mode automatically. There's no way to opt-out of strict mode inside of classes.</p>
<p>Third, all methods are non-enumerable, meaning <code>Object.keys</code> or <code>for-in</code> won't iterate over them. This is a significant change from ES5 prototype constructor functions, where you need to use <code>Object.defineProperty()</code> to make a method non-enumerable.</p>
<p>Lastly, attempting to create an instance without using <code>new</code> or attempting to overwrite the class reference within a class method throws an <code>Error</code>. Some developers are annoyed by the fact that <code>new</code> <strong>must</strong> be used to create a class object, but I like it because it makes code more readable. It's clear that a class instance is being created.</p>
<p>So in sum, ES6 classes still are just syntactic sugar, but it's sugar with additional layers of protection.</p>
<h2 id="interoperability">Interoperability</h2>
<p>Before we wrap up, let's talk about how ES6 classes can coexist with existing ES5 prototype constructor functions. In theory, you should be able to have an ES6-style class extend from an ES5-style class. <em>In theory.</em> We already saw an example of a class we declared using ES6 syntax extending an ES5 prototype constructor function, but in practice this won't always work unfortunately.</p>
<p>As we also saw earlier, the way to create a class in ES5 is pretty onerous. As a result, many libraries and frameworks have their own "<code>extends</code>" method that allows developers to create their own classes. Something like:</p>
<div><pre><code>var Note = Backbone.Model.extend({
&nbsp;&nbsp;&nbsp;&nbsp;id: 0,
&nbsp;&nbsp;&nbsp;&nbsp;content: null,
&nbsp;&nbsp;&nbsp;&nbsp;owner: null,
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;toString: function() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'ID: ' + this.id +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'\nContent: ' + this.content +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'\nOwner:' + this.owner;
&nbsp;&nbsp;&nbsp;&nbsp;}
});
</code></pre></div>
<p>As you can see, our ES5 <code>Note</code> class doesn't directly inherit from <code>Object</code> but instead inherits from the library's base class (<a href="http://backbonejs.org/#Model" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://backbonejs.org/#Model', 'Backbone.Model');"><code>Backbone.Model</code></a> in the above example) that was created to abstract the complexity of creating classes in ES5. The interoperability problem stems from the fact that <code>Backbone.Model.extend()</code> can pretty much do whatever it wants before and after it ultimately creates a prototype constructor function and attaches methods to its <code>prototype</code>.</p>
<p>It could manipulate that object literal we're passing into <code>Backbone.Model.extend()</code> in ways that a plain ES6 class will not be able to do. Let's look at another example to illustrate the point further. Let's say you're creating a custom <a href="http://marionettejs.com/docs/v2.4.4/marionette.view.html" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://marionettejs.com/docs/v2.4.4/marionette.view.html', 'Marionette.View');"><code>Marionette.View</code></a>:</p>
<div><pre><code>var RegistrationView = Marionette.View.extend({
&nbsp;&nbsp;&nbsp;&nbsp;ui: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registerButton: '.btn-register'
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;events: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'click @ui.registerButton': 'handleRegisterClick'
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;handleRegisterClick: function() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('REGISTERED!');
&nbsp;&nbsp;&nbsp;&nbsp;}
});
</code></pre></div>
<p>On the surface, <code>RegistrationView</code> looks like a class with one method (<code>handleRegisterClick()</code>) and two instance properties (<code>ui</code> and <code>events</code>). Now we already learned that ES6 classes don't support instance properties, but let's say we decide to leverage Babel's speculative implementation of the <a href="https://github.com/jeffmo/es-class-fields-and-static-properties" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/jeffmo/es-class-fields-and-static-properties', 'properties specification');">properties specification</a>. The ES6 equivalent would look something like:</p>
<div><pre><code>class RegistrationView extends Marionette.View {
&nbsp;&nbsp;&nbsp;&nbsp;ui = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;registerButton: '.btn-register'
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;events = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'click @ui.registerButton': 'handleRegisterClick'
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;handleRegisterClick() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('REGISTERED!');
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre></div>
<p>The problem is that this doesn't work. <code>Marionette.View.extend()</code> does more than just enable a custom view to inherit from it. To give a simple summary, it does some processing of <code>ui</code>, <code>events</code> &amp; a few other properties before they get added to the <code>prototype</code>. In the end when you have an instance of the view, <code>this.ui.registerButton</code> is no longer a selector <code>String</code>, but a reference to a <code>jQuery</code> object.</p>
<p><code>Marionette.View.extend()</code> is a factory method similar to our <code>Note.add()</code> method. There's no way to declare a class using ES6 syntax to simulate what <code>Marionette.View.extend()</code> is doing behind the scenes (without some less-than-clean workarounds). Marionette would have to change it's class structure, much the way React did, in order to allow Marionette developers to write ES6 class declarations.</p>
<h2 id="javascript-engine-support">JavaScript engine support</h2>
<p>I'm happy to report that all of the transpilers support ES6 class syntax!</p>
<p>I already mentioned that the transpilers cannot support inheritable built-ins. Unfortunately Safari &amp; iOS don't yet support it either. They also don't support <code>new.target</code>, the trick we used to simulate an abstract base class. The transpilers also don't support <code>new.target</code>. They treat it as invalid syntax.</p>
<h2 id="additional-resources">Additional resources</h2>
<p>As always, you can check out the <a href="http://www.benmvp.com/learning-es6/#classes" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.benmvp.com/learning-es6/#classes', 'Learning ES6 examples page');"><em>Learning ES6</em> examples page</a> for the <a href="https://github.com/benmvp/learning-es6" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/benmvp/learning-es6', 'Learning ES6 Github repo');"><em>Learning ES6</em> Github repo</a> where you will find all of the code used in this article running natively in the browser. You can also get some practice with ES6 classes using <a href="http://es6katas.org/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://es6katas.org/', 'ES6 Katas');">ES6 Katas</a>.</p>
<p>There is also lots of great reading to deep dive into ES6 classes:</p>
<ul>
<li><a href="http://benmccormick.org/2015/04/07/es6-classes-and-backbone-js/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://benmccormick.org/2015/04/07/es6-classes-and-backbone-js/', 'Why Backbone.js and ES6 Classes Don't Mix');">Why Backbone.js and ES6 Classes Don't Mix</a> by <a href="https://twitter.com/ben336" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://twitter.com/ben336', 'Ben McCormick');">Ben McCormick</a></li>
<li><a href="http://exploringjs.com/es6/ch_classes.html" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://exploringjs.com/es6/ch_classes.html', 'Classes');">Classes</a> in <a href="http://exploringjs.com/es6/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://exploringjs.com/es6/', 'Exploring ES6');"><em>Exploring ES6</em></a> by <a href="https://twitter.com/rauschma" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://twitter.com/rauschma', 'Axel Rauschmayer');">Axel Rauschmayer</a></li>
<li><a href="https://leanpub.com/understandinges6/read#leanpub-auto-classes" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://leanpub.com/understandinges6/read#leanpub-auto-classes', 'Classes');">Classes</a> in <a href="https://leanpub.com/understandinges6/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://leanpub.com/understandinges6/', 'Understanding ECMAScript 6');"><em>Understanding ECMAScript 6</em></a> by <a href="https://twitter.com/slicknet" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://twitter.com/slicknet', 'Nicholas C. Zakas');">Nicholas C. Zakas</a></li>
<li><a href="http://ponyfoo.com/articles/es6-classes-in-depth" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://ponyfoo.com/articles/es6-classes-in-depth', 'ES6 Classes in Depth');">ES6 Classes in Depth</a> in <a href="http://ponyfoo.com/articles/tagged/es6-in-depth" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://ponyfoo.com/articles/tagged/es6-in-depth', 'ES6 in Depth');"><em>ES6 in Depth</em></a> by <a href="https://twitter.com/nzgb" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://twitter.com/nzgb', 'Nicolas Bevacqua');">Nicolas Bevacqua</a></li>
<li><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-classes/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://hacks.mozilla.org/2015/07/es6-in-depth-classes/', 'ES6 in Depth: Classes');">ES6 in Depth: Classes</a> in <a href="https://hacks.mozilla.org/category/es6-in-depth/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://hacks.mozilla.org/category/es6-in-depth/', 'ES6 in Depth');"><em>ES6 in Depth</em></a> by Eric Faust</li>
<li><a href="https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/', 'ES6 in Depth: Subclassing');">ES6 in Depth: Subclassing</a> in <a href="https://hacks.mozilla.org/category/es6-in-depth/" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://hacks.mozilla.org/category/es6-in-depth/', 'ES6 in Depth');"><em>ES6 in Depth</em></a> by Eric Faust</li>
</ul>
<h2 id="coming-up-next">Coming up next…</h2>
<p>Up next, let's talk about Promises. We've been using them in JavaScript for a while now with jQuery's <code>Deferred</code> object and libraries like <a href="https://github.com/kriskowal/q#using-qpromise" onclick="__gaTracker('send', 'event', 'outbound-article', 'https://github.com/kriskowal/q#using-qpromise', 'Q');">Q</a>. But now they become first-class citizens in the ECMAScript world. Until then…</p>
<h3 id="fyi">FYI</h3>
<p>This <a href="http://www.eventbrite.com/engineering/tag/learning-es6/"><em>Learning ES6</em> series</a> is actually a cross-posting of a series with the same name on my personal blog, <a href="http://www.benmvp.com" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.benmvp.com', 'benmvp.com');">benmvp.com</a>. The content is pretty much the exact same except that this series will have additional information on how we are specifically leveraging ES6 here in Eventbrite Engineering when applicable. I'll also be tackling the features in a different order than I did in my personal blog. The classes blog post can be found <a href="http://www.benmvp.com/learning-es6-classes/" onclick="__gaTracker('send', 'event', 'outbound-article', 'http://www.benmvp.com/learning-es6-classes/', 'here');">here</a>.</p>

			</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t16" name="t16"></a><h1>16 : Classes in ECMAScript 6 (final semantics)</h1>
					<span class="ref-site">http://2ality.com/2015/02/es6-classes-final.html</span>
					<div class="tutorial__content">
<div data-reactid="36">
<p><strong>Check out my book (free online): "<a href="http://exploringjs.com/es6/">Exploring ES6</a>".</strong> Updated version of this blog post: chapter "<a href="http://exploringjs.com/es6/ch_classes.html">Classes</a>".</p>

<p><a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2015-01/jan-27.md#44-subclass-instantiation-reformation-status-and-open-issues">Recently</a>, TC39 decided on the final semantics of classes in ECMAScript 6 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. This blog post explains how their final incarnation works. The most significant recent changes were related to how subclassing is handled.</p>
<!--more-->
<h2 id="overview">Overview&nbsp;&nbsp;<a class="header-anchor" href="#overview" aria-hidden="true">#</a></h2>
<pre><code>class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color;
    }
}

let cp = new ColorPoint(25, 8, 'green');
cp.toString(); // '(25, 8) in green'

console.log(cp instanceof ColorPoint); // true
console.log(cp instanceof Point); // true
</code></pre>
<h2 id="the-essentials">The essentials&nbsp;&nbsp;<a class="header-anchor" href="#the-essentials" aria-hidden="true">#</a></h2>
<h3 id="base-classes">Base classes&nbsp;&nbsp;<a class="header-anchor" href="#base-classes" aria-hidden="true">#</a></h3>
<p>A class is defined like this in ECMAScript 6 (ES6):</p>
<pre><code>class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}
</code></pre>
<p>You use this class just like an ES5 constructor function:</p>
<pre><code>&gt; var p = new Point(25, 8);
&gt; p.toString()
'(25, 8)'
</code></pre>
<p>In fact, the result of a class definition is a function:</p>
<pre><code>&gt; typeof Point
'function'
</code></pre>
<p>However, you can only invoke a class via <code>new</code>, not via a function call (<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-function-objects-call-thisargument-argumentslist">Sect. 9.2.2</a> in the spec):</p>
<pre><code>&gt; Point()
TypeError: Classes can't be function-called
</code></pre>
<h4 id="class-declarations-are-not-hoisted">Class declarations are not hoisted&nbsp;&nbsp;<a class="header-anchor" href="#class-declarations-are-not-hoisted" aria-hidden="true">#</a></h4>
<p>Function declarations are <em>hoisted</em>: When entering a scope, the functions that are declared in it are immediately available – independently of where the declarations happen. That means that you can call a function that is declared later:</p>
<pre><code>foo(); // works, because `foo` is hoisted

function foo() {}
</code></pre>
<p>In contrast, class declarations are not hoisted. Therefore, a class only exists after execution reached its definition and it was evaluated. Accessing it beforehand leads to a <code>ReferenceError</code>:</p>
<pre><code>new Foo(); // ReferenceError

class Foo {}
</code></pre>
<p>The reason for this limitation is that classes can have an <code>extends</code> clause whose value is an arbitrary expression. That expression must be evaluated in the proper "location", its evaluation can't be hoisted.</p>
<p>Not having hoisting is less limiting than you may think. For example, a function that comes before a class declaration can still refer to that class, but you have to wait until the class declaration has been evaluated before you can call the function.</p>
<pre><code>function functionThatUsesBar() {
    new Bar();
}

functionThatUsesBar(); // ReferenceError
class Bar {}
functionThatUsesBar(); // OK
</code></pre>
<h4 id="class-expressions">Class expressions&nbsp;&nbsp;<a class="header-anchor" href="#class-expressions" aria-hidden="true">#</a></h4>
<p>Similarly to functions, there are two kinds of <em>class definitions</em>, two ways to define a class: <em>class declarations</em> and <em>class expressions</em>.</p>
<p>Also similarly to functions, the identifier of a class expression is only visible within the expression:</p>
<pre><code>const MyClass = class Me {
    getClassName() {
        return Me.name;
    }
};
let inst = new MyClass();
console.log(inst.getClassName()); // Me
console.log(Me.name); // ReferenceError: Me is not defined
</code></pre>
<h3 id="inside-the-body-of-a-class-definition">Inside the body of a class definition&nbsp;&nbsp;<a class="header-anchor" href="#inside-the-body-of-a-class-definition" aria-hidden="true">#</a></h3>
<p>A class body can only contain methods, but not data properties. Prototypes having data properties is generally considered an anti-pattern, so this just enforces a best practice.</p>
<h4 id="constructor-static-methods-prototype-methods"><code>constructor</code>, static methods, prototype methods&nbsp;&nbsp;<a class="header-anchor" href="#constructor-static-methods-prototype-methods" aria-hidden="true">#</a></h4>
<p>Let's examine three kinds of methods that you often find in class literals.</p>
<pre><code>class Foo {
    constructor(prop) {
        this.prop = prop;
    }
    static staticMethod() {
        return 'classy';
    }
    prototypeMethod() {
        return 'prototypical';
    }
}
let foo = new Foo(123);
</code></pre>
<p>The object diagram for this class declaration looks as follows. Tip for understanding it: <code>[[Prototype]]</code> is an inheritance relationship between objects, while <code>prototype</code> is a normal property whose value is an object. The property <code>prototype</code> is only special because the <code>new</code> operator uses its value as the prototype for instances it creates.</p>
<p><img src="es6-classes-final/methods.jpg" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></p>
<p><strong>First, the pseudo-method <code>constructor</code>.</strong> This method is special, as it defines the function that represents the class:</p>
<pre><code>&gt; Foo === Foo.prototype.constructor
true
&gt; typeof Foo
'function'
</code></pre>
<p>It is sometimes called a <code>class constructor</code>. It has features that normal constructor functions don't have (mainly the ability to constructor-call its super-constructor via <code>super()</code>, which is explained later).</p>
<p><strong>Second, static methods.</strong> <em>Static properties</em> (or <em>class properties</em>) are properties of <code>Foo</code> itself. If you prefix a method definition with <code>static</code>, you create a class method:</p>
<pre><code>&gt; typeof Foo.staticMethod
'function'
&gt; Foo.staticMethod()
'classy'
</code></pre>
<p><strong>Third, prototype methods.</strong> The <em>prototype properties</em> of <code>Foo</code> are the properties of <code>Foo.prototype</code>. They are usually methods and inherited by instances of <code>Foo</code>.</p>
<pre><code>&gt; typeof Foo.prototype.prototypeMethod
'function'
&gt; foo.prototypeMethod()
'prototypical'
</code></pre>
<h4 id="getters-and-setters">Getters and setters&nbsp;&nbsp;<a class="header-anchor" href="#getters-and-setters" aria-hidden="true">#</a></h4>
<p>The syntax for getters and setters is just like <a href="http://speakingjs.com/es5/ch17.html#getters_setters">in ECMAScript 5 object literals</a>:</p>
<pre><code>class MyClass {
    get prop() {
        return 'getter';
    }
    set prop(value) {
        console.log('setter: '+value);
    }
}
</code></pre>
<p>You use <code>MyClass</code> as follows.</p>
<pre><code>&gt; let inst = new MyClass();
&gt; inst.prop = 123;
setter: 123
&gt; inst.prop
'getter'
</code></pre>
<h4 id="computed-method-names">Computed method names&nbsp;&nbsp;<a class="header-anchor" href="#computed-method-names" aria-hidden="true">#</a></h4>
<p>You can define the name of a method via an expression, if you put it in square brackets. For example, the following ways of defining <code>Foo</code> are all equivalent.</p>
<pre><code>class Foo {
    myMethod() {}
}

class Foo {
    ['my'+'Method']() {}
}

const m = 'myMethod';
class Foo {
    [m]() {}
}
</code></pre>
<p>Several special methods in ECMAScript 6 have keys that are symbols <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. Computed method names allow you to define such methods. For example, if an object has a method whose key is <code>Symbol.iterator</code>, it is <em>iterable</em> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>. That means that its contents can be iterated over by the <code>for-of</code> loop and other language mechanisms.</p>
<pre><code>class IterableClass {
    [Symbol.iterator]() {
        ···
    }
}
</code></pre>
<h4 id="generator-methods">Generator methods&nbsp;&nbsp;<a class="header-anchor" href="#generator-methods" aria-hidden="true">#</a></h4>
<p>If you prefix a method definition with an asterisk (<code>*</code>), it becomes a <em>generator method</em> <sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>. Among other things, a generator is useful for defining the method whose key is <code>Symbol.iterator</code>. The following code demonstrates how that works.</p>
<pre><code>class IterableArguments {
    constructor(...args) {
        this.args = args;
    }
    * [Symbol.iterator]() {
        for (let arg of this.args) {
            yield arg;
        }
    }
}

for (let x of new IterableArguments('hello', 'world')) {
    console.log(x);
}

// Output:
// hello
// world
</code></pre>
<h3 id="subclassing">Subclassing&nbsp;&nbsp;<a class="header-anchor" href="#subclassing" aria-hidden="true">#</a></h3>
<p>The <code>extends</code> clause lets you create a subclass of an existing constructor (which may or may not have been defined via a class):</p>
<pre><code>class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // (A)
        this.color = color;
    }
    toString() {
        return super.toString() + ' in ' + this.color; // (B)
    }
}
</code></pre>
<p>Again, this class is used like you'd expect:</p>
<pre><code>&gt; let cp = new ColorPoint(25, 8, 'green');
&gt; cp.toString()
'(25, 8) in green'

&gt; cp instanceof ColorPoint
true
&gt; cp instanceof Point
true
</code></pre>
<p>There are two kinds of classes:</p>
<ul>
<li><code>Point</code> is a <em>base class</em>, because it doesn't have an <code>extends</code> clause.</li>
<li><code>ColorPoint</code> is a <em>derived class</em>.</li>
</ul>
<p>There are two ways of using <code>super</code>:</p>
<ul>
<li>A <em>class constructor</em> (the pseudo-method <code>constructor</code> in a class literal) uses it like a function call (<code>super(···)</code>), in order to make a super-constructor call (line A).</li>
<li>Method definitions (in object literals or classes, with or without <code>static</code>) use it like property references (<code>super.prop</code>) or method calls (<code>super.method(···)</code>), in order to refer to super-properties (line B).</li>
</ul>
<h4 id="the-prototype-of-a-subclass-is-the-superclass">The prototype of a subclass is the superclass&nbsp;&nbsp;<a class="header-anchor" href="#the-prototype-of-a-subclass-is-the-superclass" aria-hidden="true">#</a></h4>
<p>The prototype of a subclass is the superclass in ECMAScript 6:</p>
<pre><code>&gt; Object.getPrototypeOf(ColorPoint) === Point
true
</code></pre>
<p>That means that static properties are inherited:</p>
<pre><code>class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
}
Bar.classMethod(); // 'hello'
</code></pre>
<p>You can even super-call static methods:</p>
<pre><code>class Foo {
    static classMethod() {
        return 'hello';
    }
}

class Bar extends Foo {
    static classMethod() {
        return super.classMethod() + ', too';
    }
}
Bar.classMethod(); // 'hello, too'
</code></pre>
<h4 id="super-constructor-calls">Super-constructor calls&nbsp;&nbsp;<a class="header-anchor" href="#super-constructor-calls" aria-hidden="true">#</a></h4>
<p>In a derived class, you must call <code>super()</code> before you can use <code>this</code>:</p>
<pre><code>class Foo {}

class Bar extends Foo {
    constructor(num) {
        let tmp = num * 2; // OK
        this.num = num; // ReferenceError
        super();
        this.num = num; // OK
    }
}
</code></pre>
<p>Implicitly leaving a derived constructor without calling <code>super()</code> also causes an error:</p>
<pre><code>class Foo {}

class Bar extends Foo {
    constructor() {
    }
}

let bar = new Bar(); // ReferenceError
</code></pre>
<h4 id="overriding-the-result-of-a-constructor">Overriding the result of a constructor&nbsp;&nbsp;<a class="header-anchor" href="#overriding-the-result-of-a-constructor" aria-hidden="true">#</a></h4>
<p>Just like in ES5, you can override the result of a constructor by explicitly returning an object:</p>
<pre><code>class Foo {
    constructor() {
        return Object.create(null);
    }
}
console.log(new Foo() instanceof Foo); // false
</code></pre>
<p>If you do so, it doesn't matter whether <code>this</code> has been initialized or not. In other words: you don't have to call <code>super()</code> in a derived constructor if you override the result in this manner.</p>
<h4 id="default-constructors-for-classes">Default constructors for classes&nbsp;&nbsp;<a class="header-anchor" href="#default-constructors-for-classes" aria-hidden="true">#</a></h4>
<p>If you don't specify a <code>constructor</code> for a base class, the following definition is used:</p>
<pre><code>constructor() {}
</code></pre>
<p>For derived classes, the following default constructor is used:</p>
<pre><code>constructor(...args) {
    super(...args);
}
</code></pre>
<h4 id="subclassing-built-in-constructors">Subclassing built-in constructors&nbsp;&nbsp;<a class="header-anchor" href="#subclassing-built-in-constructors" aria-hidden="true">#</a></h4>
<p>In ECMAScript 6, you can finally subclass all built-in constructors (there are <a href="http://speakingjs.com/es5/ch28.html">work-arounds for ES5</a>, but these have significant limitations).</p>
<p>For example, you can now create your own exception classes (that will inherit the feature of having a stack trace in most engines):</p>
<pre><code>class MyError extends Error {    
}
throw new MyError('Something happened!');
</code></pre>
<p>You can also create subclasses of <code>Array</code> whose instances properly handle <code>length</code>:</p>
<pre><code>class MyArray extends Array {
    constructor(len) {
        super(len);
    }
}

// Instances of of `MyArray` work like real arrays:
let myArr = new MyArray(0);
console.log(myArr.length); // 0
myArr[0] = 'foo';
console.log(myArr.length); // 1
</code></pre>
<p>Note that subclassing built-in constructors is something that engines have to support natively, you won't get this feature via transpilers.</p>
<h2 id="the-details-of-classes">The details of classes&nbsp;&nbsp;<a class="header-anchor" href="#the-details-of-classes" aria-hidden="true">#</a></h2>
<p>What we have seen so far are the essentials of classes. You only need to read on if you are interested how things happen under the hood. Let's start with the syntax of classes. The following is a slightly modified version of the syntax shown in <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-functions-and-classes">Sect. A.4 of the ECMAScript 6 specification</a>.</p>
<pre><code>ClassDeclaration:
    "class" BindingIdentifier ClassTail
ClassExpression:
    "class" BindingIdentifier? ClassTail

ClassTail:
    ClassHeritage? "{" ClassBody? "}"
ClassHeritage:
    "extends" AssignmentExpression
ClassBody:
    ClassElement+
ClassElement:
    MethodDefinition
    "static" MethodDefinition
    ";"

MethodDefinition:
    PropName "(" FormalParams ")" "{" FuncBody "}"
    "*" PropName "(" FormalParams ")" "{" GeneratorBody "}"
    "get" PropName "(" ")" "{" FuncBody "}"
    "set" PropName "(" PropSetParams ")" "{" FuncBody "}"

PropertyName:
    LiteralPropertyName
    ComputedPropertyName
LiteralPropertyName:
    IdentifierName  /* foo */
    StringLiteral   /* "foo" */
    NumericLiteral  /* 123.45, 0xFF */
ComputedPropertyName:
    "[" Expression "]"
</code></pre>
<p>Two observations:</p>
<ul>
<li>
<p>The value to be extended can be produced by an arbitrary expression. Which means that you'll be able to write code such as the following:</p>
<pre><code>class Foo extends combine(MyMixin, MySuperClass) {}
</code></pre>
</li>
<li>
<p>Semicolons are allowed between methods.</p>
</li>
</ul>
<h3 id="various-checks">Various checks&nbsp;&nbsp;<a class="header-anchor" href="#various-checks" aria-hidden="true">#</a></h3>
<ul>
<li>
<p>Error checks: the class name cannot be <code>eval</code> or <code>arguments</code>; duplicate class element names are not allowed; the name <code>constructor</code> can only be used for a normal method, not for a getter, a setter or a generator method.</p>
</li>
<li>
<p>Classes can't be function-called. They throw a <code>TypeException</code> if they are.</p>
</li>
<li>
<p>Prototype methods cannot be used as constructors:</p>
<pre><code>class C {
    m() {}
}
new C.prototype.m(); // TypeError
</code></pre>
</li>
</ul>
<h3 id="attributes-of-properties">Attributes of properties&nbsp;&nbsp;<a class="header-anchor" href="#attributes-of-properties" aria-hidden="true">#</a></h3>
<p>Class declarations create (mutable) let bindings. For a given class <code>Foo</code>:</p>
<ul>
<li>Static methods <code>Foo.*</code> are writable and configurable, but not enumerable. Making them writable allows for dynamic patching.</li>
<li>A constructor and the object in its property <code>prototype</code> have an immutable link:
<ul>
<li><code>Foo.prototype</code> is non-writeable, non-enumerable, non-configurable.</li>
<li><code>Foo.prototype.constructor</code> is non-writeable, non-enumerable, non-configurable.</li>
</ul>
</li>
<li>Prototype methods <code>Foo.prototype.*</code> are writable and configurable, but not enumerable.</li>
</ul>
<p>Note that method definitions in object literals produce enumerable properties.</p>
<h2 id="the-details-of-subclassing">The details of subclassing&nbsp;&nbsp;<a class="header-anchor" href="#the-details-of-subclassing" aria-hidden="true">#</a></h2>
<p>In ECMAScript 6, subclassing looks as follows.</p>
<pre><code>class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    ···
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    ···
}

let cp = new ColorPoint(25, 8, 'green');
</code></pre>
<p>This code produces the following objects.</p>
<p><img src="es6-classes-final/subclassing_es6.jpg" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></p>
<p>The next subsection examines the prototype chains (in the two columns), the subsection after that examines how <code>cp</code> is allocated and initialized.</p>
<h3 id="prototype-chains">Prototype chains&nbsp;&nbsp;<a class="header-anchor" href="#prototype-chains" aria-hidden="true">#</a></h3>
<p>In the diagram, you can see that there are two <em>prototype chains</em> (objects linked via the <code>[[Prototype]]</code> relationship, which is an inheritance relationship):</p>
<ul>
<li>
<p>Left column: classes (functions). The prototype of a derived class is the class it extends. The prototype of a base class is <code>Function.prototype</code>, which is also the prototype of functions:</p>
<pre><code>&gt; const getProto = Object.getPrototypeOf.bind(Object);

&gt; getProto(Point) === Function.prototype
true
&gt; getProto(function () {}) === Function.prototype
true
</code></pre>
</li>
<li>
<p>Right column: the prototype chain of the instance. The whole purpose of a class is to set up this prototype chain. The prototype chain ends with <code>Object.prototype</code> (whose prototype is <code>null</code>), which is also the prototype of objects created via object literals:</p>
<pre><code>&gt; const getProto = Object.getPrototypeOf.bind(Object);

&gt; getProto(Point.prototype) === Object.prototype
true
&gt; getProto({}) === Object.prototype
true
</code></pre>
</li>
</ul>
<p>The prototype chain in the left column leads to static properties being inherited.</p>
<h3 id="allocating-and-initializing-the-instance-object">Allocating and initializing the instance object&nbsp;&nbsp;<a class="header-anchor" href="#allocating-and-initializing-the-instance-object" aria-hidden="true">#</a></h3>
<p>The data flow between class constructors is different from the canonical way of subclassing in ES5. Under the hood, it roughly looks as follows.</p>
<pre><code>// Instance is allocated here
function Point(x, y) {
    // Performed before entering this constructor:
    this = Object.create(new.target.prototype);

    this.x = x;
    this.y = y;
}
···

function ColorPoint(x, y, color) {
    // Performed before entering this constructor:
    this = uninitialized;

    this = Reflect.construct(Point, [x, y], new.target); // (A)
        // super(x, y);

    this.color = color;
}
Object.setPrototypeOf(ColorPoint, Point);
···

let cp = Reflect.construct( // (B)
             ColorPoint, [25, 8, 'green'],
             ColorPoint);
    // let cp = new ColorPoint(25, 8, 'green');
</code></pre>
<p>The instance object is created in different locations in ES6 and ES5:</p>
<ul>
<li>In ES6, it is created in the base constructor, the last in a chain of constructor calls.</li>
<li>In ES5, it is created in the operand of <code>new</code>, the first in a chain of constructor calls.</li>
</ul>
<p>The previous code uses two new ES6 features:</p>
<ul>
<li>
<p><code>new.target</code> is an implicit parameter that all functions have. It is to constructor calls what <code>this</code> is to method calls.</p>
<ul>
<li>If a constructor has been directly invoked via <code>new</code>, its value is that constructor (line B).</li>
<li>If a constructor was called via <code>super()</code>, its value is the <code>new.target</code> of the constructor that made the call (line A).</li>
<li>During a normal function call, it is <code>undefined</code>. That means that you can use <code>new.target</code> to determine whether a function was function-called or constructor-called (via <code>new</code>).</li>
<li>Inside an arrow function, <code>new.target</code> refers to the <code>new.target</code> of the surrounding non-arrow function.</li>
</ul>
</li>
<li>
<p><code>Reflect.construct()</code> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> lets you do a constructor call while specifying <code>new.target</code> via the last parameter.</p>
</li>
</ul>
<p>The advantage of this way of subclassing is that it enables normal code to subclass built-in constructors (such as <code>Error</code> and <code>Array</code>). A later section explains why a different approach was necessary.</p>
<h4 id="safety-checks">Safety checks&nbsp;&nbsp;<a class="header-anchor" href="#safety-checks" aria-hidden="true">#</a></h4>
<ul>
<li><code>this</code> originally being uninitialized in derived constructors means that an error is thrown if they access <code>this</code> in any way before they have called <code>super()</code>.</li>
<li>Once <code>this</code> is initialized, calling <code>super()</code> produces a <code>ReferenceError</code>. This protects you against calling <code>super()</code> twice.</li>
<li>If a constructor returns implicitly (without a <code>return</code> statement), the result is <code>this</code>. If <code>this</code> is uninitialized, a <code>ReferenceError</code> is thrown. This protects you against forgetting to call <code>super()</code>.</li>
<li>If a constructor explicitly returns a non-object (including <code>undefined</code> and <code>null</code>), the result is <code>this</code> (this behavior is required to remain compatible with ES5 and earlier). If <code>this</code> is uninitialized, a <code>TypeError</code> is thrown.</li>
<li>If a constructor explicitly returns an object, it is used as its result. Then it doesn't matter whether <code>this</code> is initialized or not.</li>
</ul>
<h4 id="the-extends-clause">The <code>extends</code> clause&nbsp;&nbsp;<a class="header-anchor" href="#the-extends-clause" aria-hidden="true">#</a></h4>
<p>Let's examine how the <code>extends</code> clause influences how a class is set up (<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-classdefinitionevaluation">Sect. 14.5.14 of the spec</a>).</p>
<p>The value of an <code>extends</code> clause must be "constructible" (invocable via <code>new</code>). <code>null</code> is allowed, though.</p>
<pre><code>class C {
}
</code></pre>
<ul>
<li>Constructor kind: base</li>
<li>Prototype of <code>C</code>: <code>Function.prototype</code> (like a normal function)</li>
<li>Prototype of <code>C.prototype</code>: <code>Object.prototype</code> (which is also the prototype of objects created via object literals)</li>
</ul>
<pre><code>class C extends B {
}
</code></pre>
<ul>
<li>Constructor kind: derived</li>
<li>Prototype of <code>C</code>: <code>B</code></li>
<li>Prototype of <code>C.prototype</code>: <code>B.prototype</code></li>
</ul>
<pre><code>class C extends Object {
}
</code></pre>
<ul>
<li>Constructor kind: derived</li>
<li>Prototype of <code>C</code>: <code>Object</code></li>
<li>Prototype of <code>C.prototype</code>: <code>Object.prototype</code></li>
</ul>
<p>Note the following subtle difference with the first case: If there is no <code>extends</code> clause, the class is a base class and allocates instances. If a class extends <code>Object</code>, it is a derived class and <code>Object</code> allocates the instances. The resulting instances (including their prototype chains) are the same, but you get there differently.</p>
<pre><code>class C extends null {
}
</code></pre>
<ul>
<li>Constructor kind: derived</li>
<li>Prototype of <code>C</code>: <code>Function.prototype</code></li>
<li>Prototype of <code>C.prototype</code>: <code>null</code></li>
</ul>
<p>Such a class is not very useful: <code>new</code>-calling it leads to an error, because the default constructor makes a super-constructor call and <code>Function.prototype</code> (the super-constructor) can't be constructor-called. The only way to make the error go away is by adding a <code>constructor</code> that returns an object.</p>
<h3 id="why-cant-you-subclass-built-in-constructors-in-es5">Why can't you subclass built-in constructors in ES5?&nbsp;&nbsp;<a class="header-anchor" href="#why-cant-you-subclass-built-in-constructors-in-es5" aria-hidden="true">#</a></h3>
<p>In ECMAScript 5, most built-in constructors can't be subclassed (<a href="http://speakingjs.com/es5/ch28.html">several work-arounds exist</a>).</p>
<p>To understand why, let's use the canonical ES5 pattern to subclass <code>Array</code>. As we shall soon find out, this doesn't work.</p>
<pre><code>function MyArray(len) {
    Array.call(this, len); // (A)
}
MyArray.prototype = Object.create(Array.prototype);    
</code></pre>
<p>Unfortunately, if we instantiate <code>MyArray</code>, we find out that it doesn't work properly: The instance property <code>length</code> does not change in reaction to us adding array elements:</p>
<pre><code>&gt; var myArr = new MyArray(0);
&gt; myArr.length
0
&gt; myArr[0] = 'foo';
&gt; myArr.length
0
</code></pre>
<p>There are two obstracles that prevent <code>myArr</code> from being a proper array.</p>
<p><strong>First obstacle: initialization.</strong> The <code>this</code> you hand to the constructor <code>Array</code> (in line A) is completely ignored. That means you can't use <code>Array</code> to set up the instance that was created for <code>MyArray</code>.</p>
<pre><code>&gt; var a = [];
&gt; var b = Array.call(a, 3);
&gt; a !== b  // a is ignored, b is a new object
true
&gt; b.length // set up correctly
3
&gt; a.length // unchanged
0
</code></pre>
<p><strong>Second obstacle: allocation.</strong> The instance objects created by <code>Array</code> are <em>exotic</em> (a term used by the ECMAScript specification for objects that have features that normal objects don't have): Their property <code>length</code> tracks and influences the management of array elements. In general, exotic objects can be created from scratch, but you can't convert an existing normal object into an exotic one. Unfortunately, that is what <code>Array</code> would have to do, when called in line A: It would have to turn the normal object created for <code>MyArray</code> into an exotic array object.</p>
<h4 id="the-solution-es6-subclassing">The solution: ES6 subclassing&nbsp;&nbsp;<a class="header-anchor" href="#the-solution-es6-subclassing" aria-hidden="true">#</a></h4>
<p>In ECMAScript 6, subclassing <code>Array</code> looks as follows:</p>
<pre><code>class MyArray extends Array {
    constructor(len) {
        super(len);
    }
}
</code></pre>
<p>This works (but it's not something that ES6 transpilers can support, it depends on whether a JavaScript engine supports it natively):</p>
<pre><code>&gt; let myArr = new MyArray(0);
&gt; myArr.length
0
&gt; myArr[0] = 'foo';
&gt; myArr.length
1
</code></pre>
<p>We can now see how the ES6 approach to subclassing circumvents the obstacles:</p>
<ul>
<li>Allocation happens in the base constructor, which means that <code>Array</code> can allocate an exotic object. While most of the new approach is due to how derived constructors behave, this step requires that a base constructor is aware of <code>new.target</code> and makes <code>new.target.prototype</code> the protoype of the allocated instance.</li>
<li>Initialization also happens in the base constructor, a derived constructor receives an initialized object and works with that one instead of passing its own instance to the super-constructor and requiring it to set it up.</li>
</ul>
<h3 id="referring-to-super-properties-in-methods">Referring to super-properties in methods&nbsp;&nbsp;<a class="header-anchor" href="#referring-to-super-properties-in-methods" aria-hidden="true">#</a></h3>
<p>The following ES6 code makes a super-method call in line B.</p>
<pre><code>class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() { // (A)
        return '(' + this.x + ', ' + this.y + ')';
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    toString() {
        return super.toString() // (B)
               + ' in ' + this.color;
    }
}

let cp = new ColorPoint(25, 8, 'green');
console.log(cp.toString()); // (25, 8) in green
</code></pre>
<p>To understand how super-calls work, let's look at the object diagram of <code>cp</code>:</p>
<p><img src="es6-classes-final/supercalls.jpg" alt="" draggable="true" data-bukket-ext-bukket-draggable="true"></p>
<p><code>ColorPoint.prototype.toString</code> makes a super-call (line B) to the method (starting in line A) that it has overridden. Let's call the object, in which a method is stored, the <em>home object</em> of that method. For example, <code>ColorPoint.prototype</code> is the home object of <code>ColorPoint.prototype.toString()</code>.</p>
<p>The super-call in line B involves three steps:</p>
<ol>
<li>
<p>Start your search in the prototype of the home object of the current method.</p>
</li>
<li>
<p>Look for a method whose name is <code>toString</code>. That method may be found in the object where the search started or later in the prototype chain.</p>
</li>
<li>
<p>Call that method with the current <code>this</code>. The reason for doing so is: the super-called method must be able to access the same instance properties (in our example, the properties of <code>cp</code>).</p>
</li>
</ol>
<p>Note that even if you are only getting or setting a property (not calling a method), you still have to consider <code>this</code> in step #3, because the property may be implemented via a getter or a setter.</p>
<p>Let's express these steps in three different, but equivalent, ways:</p>
<pre><code>// Variation 1: super-method calls in ES5
var result = Point.prototype.toString.call(this) // steps 1,2,3

// Variation 2: ES5, refactored
var superObject = Point.prototype; // step 1
var superMethod = superObject.toString; // step 2
var result = superMethod.call(this) // step 3

// Variation 3: ES6
var homeObject = ColorPoint.prototype;
var superObject = Object.getPrototypeOf(homeObject); // step 1
var superMethod = superObject.toString; // step 2
var result = superMethod.call(this) // step 3
</code></pre>
<p>Variation 3 is how ECMAScript 6 handles super-calls. This approach is supported by <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-function-environment-records">two internal <em>bindings</em></a> that the <em>environments</em> of functions have (<em>environments</em> provide storage space, so-called <em>bindings</em>, for the variables in a scope):</p>
<ul>
<li><code>[[thisValue]]</code>: This internal binding also exists in ECMAScript 5 and stores the value of <code>this</code>.</li>
<li><code>[[HomeObject]]</code>: Refers to the home object of the environment's function. Filled in via an internal property <code>[[HomeObject]]</code> that all methods have that use <code>super</code>. Both the binding and the property are new in ECMAScript 6.</li>
</ul>
<p>A method definition in a class literal that uses <code>super</code> is now special: Its value is still a function, but it has the internal property <code>[[HomeObject]]</code>. That property is set up by the method definition and can't be changed in JavaScript. Therefore, you can't meaningfully move such a method to a different object.</p>
<p>Using <code>super</code> to refer to a property is not allowed in function declarations, function expressions and generator functions.</p>
<p>Referring to super-properties is handy whenever prototype chains are involved, which is why you can use it in method definitions inside object literals and class literals (the class can be derived or not, the method can be static or not).</p>
<h2 id="constructor-calls-explained-via-javascript-code">Constructor calls explained via JavaScript code&nbsp;&nbsp;<a class="header-anchor" href="#constructor-calls-explained-via-javascript-code" aria-hidden="true">#</a></h2>
<p>The JavaScript code in this section is a much simplified version of how the specification describes constructor calls and super-constructor calls. It may be interesting to you if you prefer code to explanations in human language. Before we can delve into the actual functionality, we need to understand a few other mechanisms.</p>
<h3 id="internal-variables-and-properties">Internal variables and properties&nbsp;&nbsp;<a class="header-anchor" href="#internal-variables-and-properties" aria-hidden="true">#</a></h3>
<p>The specification writes internal variables and properties in double brackets (<code>[[Foo]]</code>). In the code, I use double underscores, instead (<code>__Foo__</code>).</p>
<p>Internal variables used in the code:</p>
<ul>
<li><code>[[NewTarget]]</code>: The operand of the <code>new</code> operator that triggered the current constructor call (passed on if <code>[[Construct]]</code> is called recursively via <code>super()</code>).</li>
<li><code>[[thisValue]]</code>: Stores the value of <code>this</code>.</li>
<li><code>[[FunctionObject]]</code>: Refers to the function that is currently executed.</li>
</ul>
<p>Internal properties used in the code:</p>
<ul>
<li><code>[[Construct]]</code>: All constructor functions (including those created by classes) have this own (non-inherited) method. It implements constructor calls and is invoked by <code>new</code>.</li>
<li><code>[[ConstructorKind]]</code>: A property of constructor functions whose value is either <code>'base'</code> or <code>'derived'</code>.</li>
</ul>
<h3 id="environments">Environments&nbsp;&nbsp;<a class="header-anchor" href="#environments" aria-hidden="true">#</a></h3>
<p><em>Environments</em> provide storage space for variables, there is one environment per scope. Environments are managed as a stack. The environment on top of that stack is considered active. The following code is a sketch of how environments are handled.</p>
<pre><code>/**
 * Function environments are special, they have a few more
 * internal variables than other environments.
 * (`Environment` is not shown here)
 */
class FunctionEnvironment extends Environment {
    constructor(Func) {
        // [[FunctionObject]] is a function-specific
        // internal variable
        this.__FunctionObject__ = Func;
    }    
}

/**
 * Push an environment onto the stack
 */
function PushEnvironment(env) { ··· }

/**
 * Pop the topmost environment from the stack
 */
function PopEnvironment() { ··· }

/**
 * Find topmost function environment on stack
 */
function GetThisEnvironment() { ··· }
</code></pre>
<h3 id="constructor-calls">Constructor calls&nbsp;&nbsp;<a class="header-anchor" href="#constructor-calls" aria-hidden="true">#</a></h3>
<p>Let's start with the default way (<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget">ES6 spec Sect. 9.2.3</a>) in which constructor calls are handled for functions:</p>
<pre><code>/**
 * All constructible functions have this own method,
 * it is called by the `new` operator
 */
AnyFunction.__Construct__ = function (args, newTarget) {
    let Constr = this;
    let kind = Constr.__ConstructorKind__;

    let env = new FunctionEnvironment(Constr);
    env.__NewTarget__ = newTarget;
    if (kind === 'base') {
        env.__thisValue__ = Object.create(newTarget.prototype);
    } else {
        // While `this` is uninitialized, getting or setting it
        // throws a `ReferenceError`
        env.__thisValue__ = uninitialized;
    }

    PushEnvironment(env);
    let result = Constr(...args);
    PopEnvironment();

    // Let's pretend there is a way to tell whether `result`
    // was explicitly returned or not
    if (WasExplicitlyReturned(result)) {
        if (isObject(result)) {
            return result;
        }
        // Explicit return of a primitive
        if (kind === 'base') {
            // Base constructors must be backwards compatible
            return env.__thisValue__; // always initialized!
        }
        throw new TypeError();
    }
    // Implicit return
    if (env.__thisValue__ === uninitialized) {
        throw new ReferenceError();
    }
    return env.__thisValue__;
}
</code></pre>
<h3 id="super-constructor-calls-2">Super-constructor calls&nbsp;&nbsp;<a class="header-anchor" href="#super-constructor-calls-2" aria-hidden="true">#</a></h3>
<p>Super-constructor calls are handled as follows (<a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-super-keyword-runtime-semantics-evaluation">ES6 spec Sect. 12.3.5.1</a>).</p>
<pre><code>/**
 * Handle super-constructor calls
 */
function super(...args) {
    let env = GetThisEnvironment();
    let newTarget = env.__NewTarget__;
    let activeFunc = env.__FunctionObject__;
    let superConstructor = Object.getPrototypeOf(activeFunc);

    env.__thisValue__ = superConstructor
                        .__Construct__(args, newTarget);
}
</code></pre>
<h2 id="the-species-pattern">The species pattern&nbsp;&nbsp;<a class="header-anchor" href="#the-species-pattern" aria-hidden="true">#</a></h2>
<p>One more mechanism of built-in constructors has been made extensible in ECMAScript 6: If a method such as <code>Array.prototype.map()</code> returns a fresh instance, what constructor should it use to create that instance? The default is to use the same constructor that created <code>this</code>, but some subclasses may want it to remain a direct instance of <code>Array</code>. ES6 lets subclasses override the default, via the so-called <em>species pattern</em>:</p>
<ul>
<li>When creating a new instance of <code>Array</code>, methods such as <code>map()</code> use the constructor stored in <code>this.constructor[Symbol.species]</code>.</li>
<li>If a sub-constructor of <code>Array</code> does nothing, it inherits <code>Array[Symbol.species]</code>. That property is a getter that returns <code>this</code>.</li>
</ul>
<p>You can override the default, via a static getter (line A):</p>
<pre><code>class MyArray1 extends Array {
}
let result1 = new MyArray1().map(x =&gt; x);
console.log(result1 instanceof MyArray1); // true

class MyArray2 extends Array {
    static get [Symbol.species]() { // (A)
        return Array;
    }
}
let result2 = new MyArray2().map(x =&gt; x);
console.log(result2 instanceof MyArray2); // false
</code></pre>
<p>An alternative is to use <code>Object.defineProperty()</code> (you can't use assignment, as that would trigger a setter, which doesn't exist):</p>
<pre><code>Object.defineProperty(
    MyArray2, Symbol.species, {
        value: Array
    });
</code></pre>
<p>The following getters all return <code>this</code>, which means that methods such as <code>Array.prototype.map()</code> use the constructor that created the current instance for their results.</p>
<ul>
<li><code>Array.get [Symbol.species]()</code></li>
<li><code>ArrayBuffer.get [Symbol.species]()</code></li>
<li><code>Map.get [Symbol.species]()</code></li>
<li><code>Promise.get [Symbol.species]()</code></li>
<li><code>RegExp.get [Symbol.species]()</code></li>
<li><code>Set.get [Symbol.species]()</code></li>
<li><code>%TypedArray%.get [Symbol.species]()</code></li>
</ul>
<h2 id="conclusion">Conclusion&nbsp;&nbsp;<a class="header-anchor" href="#conclusion" aria-hidden="true">#</a></h2>
<h3 id="the-specialization-of-functions">The specialization of functions&nbsp;&nbsp;<a class="header-anchor" href="#the-specialization-of-functions" aria-hidden="true">#</a></h3>
<p>There is an interesting trend in ECMAScript 6: Previously, a single kind of function took on three roles: real function, method and constructor. In ES6, there is specialization:</p>
<ul>
<li>
<p>Arrow functions are specialized for non-method callbacks, where them picking up the <code>this</code> of their surrounding method or constructor is an advantage. Without <code>this</code>, they don't make much sense as methods and they throw an exception when invoked via <code>new</code>.</p>
</li>
<li>
<p>Method definitions enable the use of <code>super</code>, by setting up the property <code>[[HomeObject]]</code>. The functions they produce can't be constructor-called.</p>
</li>
<li>
<p>Class definitions are the only way to create derived constructors (enabling ES6-style subclassing that works for built-in constructors). Class definitions produce functions that can only be constructor-called.</p>
</li>
</ul>
<h3 id="the-future-of-classes">The future of classes&nbsp;&nbsp;<a class="header-anchor" href="#the-future-of-classes" aria-hidden="true">#</a></h3>
<p>The design maxim for classes was "maximally minimal". Several advanced features were discussed, but ultimately discarded in order to get a design that would be unanimously accepted by TC39.</p>
<p>Upcoming versions of ECMAScript can now extend this minimal design – classes will provide a foundation for features such as traits (or mixins), value objects (where different objects are equal if they have the same content) and const classes (that produce immutable instances).</p>
<h3 id="does-javascript-need-classes">Does JavaScript need classes?&nbsp;&nbsp;<a class="header-anchor" href="#does-javascript-need-classes" aria-hidden="true">#</a></h3>
<p>Classes are controversial within the JavaScript community. On one hand, people coming from class-based languages are happy that they don't have to deal with JavaScript's unorthodox inheritance mechanisms, anymore. On the other hand, there are many JavaScript programmers who argue that what's complicated about JavaScript is not prototypal inheritance, but constructors <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</p>
<p>ES6 classes provide a few clear benefits:</p>
<ul>
<li>
<p>They are backwards compatible with much of the current code.</p>
</li>
<li>
<p>Compared to constructors and constructor inheritance, classes make it easier for beginners to get started.</p>
</li>
<li>
<p>Subclassing is supported within the language.</p>
</li>
<li>
<p>Built-in constructors are subclassable.</p>
</li>
<li>
<p>No library for inheritance is needed, anymore; code will become more portable between frameworks.</p>
</li>
<li>
<p>They provide a foundation for advanced features in the future (mixins and more).</p>
</li>
<li>
<p>They help tools that statically analyze code (IDEs, type checkers, style checkers, etc.).</p>
</li>
</ul>
<p>I have made my peace with classes and am glad that they are in ES6. I would have preferred them to be prototypal (based on constructor objects <sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup>, not constructor functions), but I also understand that backwards compatibility is important.</p>
<h2 id="further-reading">Further reading&nbsp;&nbsp;<a class="header-anchor" href="#further-reading" aria-hidden="true">#</a></h2>
<p>Acknowledgement: #1 was an important source of this blog post.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>"<a href="http://exploringjs.com/">Exploring ES6: Upgrade to the next version of JavaScript</a>", book by Axel <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="http://2ality.com/2014/12/es6-symbols.html">Symbols in ECMAScript 6</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="http://2ality.com/2013/06/iterators-generators.html">Iterators and generators in ECMAScript 6</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="http://2ality.com/2014/12/es6-proxies.html">Meta programming with ECMAScript 6 proxies</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="http://2ality.com/2011/06/prototypes-as-classes.html">Prototypes as classes – an introduction to JavaScript inheritance</a> <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t17" name="t17"></a><h1>17 : ECMAScript 6: merging objects via Object.assign()</h1>
					<span class="ref-site">http://2ality.com/2014/01/object-assign.html</span>
					<div class="tutorial__content">
<div data-reactid="36"><p>

<b>New version of this blog post:</b> inside “<a href="http://2ality.com/2014/12/es6-oop.html">ECMAScript 6: new OOP features besides classes</a>”.
</p><p>
Copying all properties of one object to another one is a common operation in JavaScript. This blog post explains ECMAScript 6's implementation of it, which is called <tt>Object.assign()</tt>.

<!--more-->
</p><p>
This merging operation has a name in the JavaScript ecosystem that is only used there (and, unfortunately, clashes with classic OOP terminology): “extend”. Two examples of “extend” being provided by libraries:
</p><ul>
    <li>Prototype: <a href="http://prototypejs.org/doc/latest/language/Object/extend/"><tt>Object.extend(destination, source)</tt></a><br>
        Prototype first used the name “extend” for this operation.
    </li>
    <li>Underscore.js: <a href="http://underscorejs.org/#extend"><tt>_.extend(destination, *sources)</tt></a>
    </li>
</ul>

<h2>Object.assign()</h2>

For merging objects, ECMAScript 6 will have the function
<pre class="javascript">    Object.assign(target, source_1, ..., source_n)
</pre>
This function modifies <tt>target</tt> and returns it: it first copies all enumerable <a class="ptr">[1]</a> own operties of <tt>source_1</tt> to <tt>target</tt>, then those of <tt>source_2</tt>, etc.

<h3>Property keys: either strings or symbols</h3>

In ECMAScript 6, property keys can be either strings or <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type">symbols</a>. The latter are a new kind of unique identifier; there are never any name clashes with symbols as keys. <tt>Object.assign()</tt> supports both strings and symbols as keys.

<h3>Copying versus assignment</h3>

Properties in the target object are created via assignment (internal operation [[Put]]). That means that if <tt>target</tt> has (own or inherited) setters <a class="ptr">[1]</a>, those will be invoked during copying. An alternative would have been to <i>define</i> new properties <a class="ptr">[2]</a>, an operation which always creates new own properties and never invokes setters. There originally was a proposal for a variant of <tt>Object.assign()</tt> that uses definition instead of assignment. That proposal has been rejected for ECMAScript 6 (but may be reconsidered for later editions).

<h2>Use cases for Object.assign()</h2>

<h3>Setting up instance properties</h3>

The task of a constructor is to set up instance properties. Alas, variable names are always mentioned redundantly for this task:

<pre class="actionscript">    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }
</pre>

My favorite would have been the following syntax to completely remove that redundancy (CoffeeScript and TypeScript both have ways of doing this, but I prefer this syntax):

<pre class="actionscript">    class Point {
        constructor(this.x, this.y) {
        }
    }
</pre>

<tt>Object.assign()</tt> at least enables you to avoid some of the redundancy:

<pre class="actionscript">    class Point {
        constructor(x, y) {
            Object.assign(this, { x, y });
        }
    }
</pre>
In ECMAScript 6, <tt>{ x, y }</tt> is an abbreviation for <tt>{  x: x, y: y }</tt>.

<h3>Adding a method to an object</h3>

ECMAScript 5, you use a function expression to add a method to an object:

<pre class="javascript">    MyClass.prototype.foo = function (arg1, arg2) {
        ...
    };
</pre>

ECMAScript 6 has a more concise syntax for methods <a class="ptr">[3]</a>. Thanks to <tt>Object.assign()</tt>, you don't have to abandon that syntax:

<pre class="javascript">    Object.assign(MyClass.prototype, {
        foo(arg1, arg2) {
            ...
        }
    });
</pre>

<h3>Cloning an object</h3>

You can also use <tt>Object.assign()</tt> to (shallowly) clone an object:

<pre class="javascript">    var copy = Object.assign({ __proto__: obj.__proto__ }, obj);
</pre>

If you are only interested in an object's own properties, things become simpler:

<pre class="javascript">    var copy = Object.assign({}, obj);
</pre>

<h2>References</h2>

<ol id="references">
    <li><a href="http://2ality.com/2012/10/javascript-properties.html">Object properties in JavaScript</a></li>
    <li><a href="http://2ality.com/2012/08/property-definition-assignment.html">Properties in JavaScript: definition versus assignment</a></li>
    <li><a href="http://2ality.com/2013/08/es6-callables.html">Callable entities in ECMAScript 6</a></li>
</ol>
</div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>18 : Template Literals</h1>
					<span class="ref-site">https://css-tricks.com/template-literals/</span>
					<div class="tutorial__content">
<div class="article-content">

                
      
      <p>The Template Literal, introduced in ES6, is a new way to create a string. With it comes new features that allow us more control over dynamic strings in our programs. Gone will be the days of long string concatenation!</p>
<p>To create a template literal, instead of single quotes (<code>'</code>) or double quotes (<code>"</code>) quotes we use the backtick (<code>`</code>) character. This will produce a new string, and we can use it in any way we want.</p>
<p><span id="more-245501"></span></p>
<p>Basic usage:</p>
<pre><code>let newString = `A string`;</code></pre>
<h3 id="article-header-id-0" class="has-header-link"><a class="article-headline-link" href="#article-header-id-0">#</a>Multi-line</h3>
<p>The great thing about Template Literals is that we can now create multi-line strings! In the past, if we wanted a string to be on multiple lines, we had to use the <code>\n</code> or new line character.</p><div class="launchbit-ad-wrapper"><div id="bsa-ad-1" class="launchbit-ad"><a class="launchbit-in-article" href="//srv.buysellads.com/ads/click/x/GTND4237C67D52QLCE7LYKQWF6YI6K7UCTSICZ3JCEAI4KQNCKAI45QKC6BDLKQICT7IKK3EHJNCLSIZ" target="_blank"><img src="//assets.servedby-buysellads.com/p/manage/asset/id/37874" alt="" class="launchbit-img" draggable="true" data-bukket-ext-bukket-draggable="true">See The 3 Use Cases of How Our DevOp Teams Automate Development<img src="https://www.launchbit.com/taz-pixel/11315-6651-111" border="0" height="1" width="1" draggable="true" data-bukket-ext-bukket-draggable="true" style="display: none;"></a></div></div>
<pre><code>// The old way
var myMultiString = 'Some text that I want\nOn two lines!';</code></pre>
<p>With a Template Literal string, we can just go ahead and add the new line into the string as we write it.</p>
<pre><code>var myMultiString= `This will be
on two lines!`;</code></pre>
<p>This will produce a string with a new line in it. The ability to do this with expressions makes Template Literals a really nice templating language for building of bits of HTML that we will cover later. But what about concatenation? Let's look at how we can dynamically add values into our new Template Literals.</p>
<h3 id="article-header-id-1" class="has-header-link"><a class="article-headline-link" href="#article-header-id-1">#</a>Expressions</h3>
<p>In the new Template Literal syntax we have what are called expressions, and they look like this: <code>${expression}</code>. Consider the code below.</p>
<pre><code>let name = `Ryan`;

console.log(`Hi my name is ${name}`);</code></pre>
<p>The <code>${}</code> syntax allows us to put an expression in it and it will produce the value, which in our case above is just a variable that holds a string! There is something to note here: if you wanted to add in values, like above, you do not need to use a Template Literal for the <code>name</code> variable. It could just be a regular string.</p>
<pre><code>console.log(`Hi my name is ${'Ryan'}`);</code></pre>
<p>This will produce the same output. These expressions do more than just let us put in variables that contain strings in them. We can evaluate any sort of expressions that we would like.</p>
<pre><code>let price = 19.99;
let tax = 1.13;

let total = `The total prices is ${price * tax}`;</code></pre>
<p>We can also use this with a more complex object.</p>
<pre><code>let person = {
    firstName: `Ryan`,
    lastName: `Christiani`,
    sayName() {
        return `Hi my name is ${this.firstName} ${this.lastName}`;
    }
};</code></pre>
<p>Here we have a <code>person</code> object with a <code>sayName()</code> method on it. We can access the properties from an object inside of the <code>${}</code> syntax.</p>
<h3 id="article-header-id-2" class="has-header-link"><a class="article-headline-link" href="#article-header-id-2">#</a>HTML Templates</h3>
<p>With the ability to have multi-line strings and use Template Expressions to add content into our string, this makes it really nice to use for HTML templates in our code.</p>
<p>Let's imagine that we get some data from an API that looks something like this:</p>
<pre><code>{
    "id": 1,
    "name": "Bulbasaur",
    "base_experience": 64,
    "height": 7,
    "is_default": true,
    "order": 1,
    "weight": 69,
    ...
}</code></pre>
<p>This "imaginary" API is of course the <a href="http://pokeapi.co/">pokeapi</a>! With this data structure in mind, let's create the markup that would show this Pokemon.</p>
<pre><code>function createMarkup(data) {
    return `
        &lt;article class="pokemon"&gt;
            &lt;h3&gt;${data.name}&lt;/h3&gt;
            &lt;p&gt;The Pokemon ${data.name} has a base experience of ${data.base_experience}, they also weigh ${data.weight}&lt;/p&gt;
        &lt;/article&gt;
    `
}</code></pre>
<p>Without having to use a library like Handlebars or Mustache we can create nice and easy-to-use templates in our JavaScript!</p>
<h3 id="article-header-id-3" class="has-header-link"><a class="article-headline-link" href="#article-header-id-3">#</a>Tagged Templates</h3>
<p>Another features of Template Literals is the ability to create Tagged Template Literals. You create a function and this function will look like any other function, however it looks different when you call it:</p>
<pre><code>function myTaggedLiteral(strings) {
    console.log(strings);
}

myTaggedLiteral`test`; 
// ["test"]</code></pre>
<p>Notice there are no parens <code>()</code> when we call the function! We apply a Template Literal where the parentheses would be. As a parameter to our function we get an array of the strings in our literal. Let's expand on the string we send to the function and we will have it include an expression, and we will include a new parameter in our function as well.</p>
<pre><code>function myTaggedLiteral(strings, value) {
    console.log(strings,value);
}

let someText = 'Neat';
myTaggedLiteral`test ${someText}`; 
// ["test", ""]
// "Neat"</code></pre>
<p>When we use an expression we can access that from the next parameters and this keeps going. Say we added another expression.</p>
<pre><code>function myTaggedLiteral(strings, value, value2) {
    console.log(strings,value);
}

let someText = 'Neat';
myTaggedLiteral`test ${someText} ${2 + 3}`; 
// ["test", ""]
// "Neat"
// 5</code></pre>
<p>This is pretty powerful: it allows you to take the data used in a string and manipulate it to your liking.</p>
<h3 id="article-header-id-4" class="has-header-link"><a class="article-headline-link" href="#article-header-id-4">#</a>Reusable Templates</h3>
<p>Let's look at a simple use case for Template Literals. If you remember from above, we saw how Template Literals work really great for, well, making templates! Let's take that a step further and create a function that would allow us to create reusable templates. The idea here is that we can create the initial template and then pass in data for it to use later.</p>
<pre><code>const student = {
    name: "Ryan Christiani",
    blogUrl: "http://ryanchristiani.com"
}

const studentTemplate = templater`&lt;article&gt;
    &lt;h3&gt;${'name'} is a student at HackerYou&lt;/h3&gt;
    &lt;p&gt;You can find their work at ${'blogUrl'}.&lt;/p&gt;

&lt;/article&gt;`;

const myTemplate = studentTemplate(student);
console.log(myTemplate);
// Output will look like this!
// &lt;article&gt;
//    &lt;h3&gt;Ryan Christiani is a student at HackerYou&lt;/h3&gt;
//    &lt;p&gt;You can find their work at http://ryanchristiani.com.&lt;/p&gt;
// &lt;/article&gt;</code></pre>
<p>Let's look at implementing our <code>templater</code> function.</p>
<pre><code>const templater = function(strings, ...keys) {

}</code></pre>
<p>The first thing you will notice is this <code>...keys</code> parameter. The <code>...</code> syntax is what's called Rest Parameters; it will gather any parameters the function has and create an array for us.</p>
<p>The next thing we want to do is return a function that is going to access our object. The returning of the function is what allows us to call and pass in our student data, like this: <code>studentTemplate(student)</code>.</p>
<pre><code>const templater = function(strings, ...keys) {
    return function(data) {

    } 
}</code></pre>
<p>With this data now available to us we need to perform some manipulation. The process is as follows. First, we need to create a copy of the <code>strings</code> array. We make a copy in case we want to reference the original later. Then we need to loop through the array of <code>keys</code>, and for each one of those, grab the data from the object that matches the key (notice how in this example we pass in a string in the <code>${}</code>) and place it in our array where needed. Finally, we need to join it all back together as a string and return it from the function!</p>
<pre><code>function templater(strings, ...keys) {
    return function(data) {
        let temp = strings.slice();
        keys.forEach((key, i) =&gt; {
            temp[i] = temp[i] + data[key];
        });
        return temp.join('');
    }
};</code></pre>
<p>You will notice that this is not an exhaustive example. We have no way to accommodate nested data or array values; it is simply just strings. But I hope this example helps to illustrate what you can start doing with Tagged Template Literals.</p>

<div class="explanation" style="overflow: hidden;">
    <img src="https://cdn.css-tricks.com/wp-content/uploads/2016/09/es6.jpg" alt="Cover of Let's Learn ES6" style="float: left; margin: 0 20px 2px 0; max-width: 180px;" draggable="true" data-bukket-ext-bukket-draggable="true"><p></p>
<p><a href="http://ryanchristiani.com/">Ryan Christiani</a> is the Head Instructor &amp; Development Lead at HackerYou in Toronto and also the author of <a href="https://letslearnes6.com/">Let's Learn ES6</a>, a book with everything you need to know about the latest syntax in JavaScript.</p>
</div>
      
    </div>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>19 : ES6 Template Literals, the Handlebars killer?</h1>
					<span class="ref-site">https://www.keithcirkel.co.uk/es6-template-literals/</span>
					<div class="tutorial__content">
<section class="post-content">
<p>I had a recent discussion with one of the awesome developers at the <a href="https://ft.com">FT</a> - <a href="https://twitter.com/bjfletcher">@bjfletcher</a>. We were looking at how viable it would be to replace a templating language, like <a href="http://handlebarsjs.com/">Handlebars</a> with ES6 Template Literals, in some manner. Ben suggested it'd be a good idea to turn our discussion into a post, and here we are - with a click bait title and everything.</p>
<p>So what are <em>Template Literals</em>? How can they do what a complex library like Handlebars does? Settle in, dear reader, and let's find out…</p>
<h2 id="a-crash-course-through-template-literals">A crash course through Template Literals</h2>
<p>I've discussed ES6 here before - we looked at <a href="/metaprogramming-in-es6-symbols/">Symbols</a> (you should read that, we'll be using Symbols today), <a href="/metaprogramming-in-es6-part-2-reflect/">Reflect</a> and we looked at <a href="/metaprogramming-in-es6-part-3-proxies/">Proxies</a>. Even more ES6 content will be coming too (tease tease). Another big part of ES6 was also these things called <em>Template Literals</em>. They serve as a bit of a fix for many things to do with Strings in ES6 land. So let's just have a quick rundown of their features:</p>
<h3 id="a-literal-syntax">A literal syntax</h3>
<p>ES6 template literals, as the name suggests, come with a new literal syntax. They use back ticks (<code class="language-js highlighter-rouge"><span class="err">`</span> <span class="err">`</span></code>) to denote the start and end (just like strings use quote marks (<code class="language-js highlighter-rouge"><span class="s1">' '</span></code> or <code class="language-js highlighter-rouge"><span class="s2">" "</span></code>)). Within those back ticks, Template literals are parsed at runtime, to provide some new features.</p>
<h3 id="newlines-allowed">Newlines allowed.</h3>
<p>One of the neat little features about <em>Template Literals</em>, is that unlike String literals, they allow for newline characters; strings spanning over multiple lines look a lot cleaner as you don't need to write a bunch of ugly syntax concatenating them over lines. This seems like a small, maybe irrelevant feature, but it's very important for our use case - making template languages! Here's an example:</p>
<pre><code>var templateString = `
  Hello
  World
`;

// equivalent with strings:
var oldString = '\n' +
'  Hello\n' +
'  World\n';
</code></pre>
<h3 id="expression-interpolation">Expression interpolation</h3>
<p>The most powerful feature of <em>Template Literals</em>, is that they have a new syntax inside the string which allows inline code within that. Simply wrap any code within <code class="language-js highlighter-rouge"><span class="nx">$</span><span class="p">{</span></code> and <code class="language-js highlighter-rouge"><span class="p">}</span></code> and the code inside will be executed, and added to the string in place. If you've used Ruby before - this concept will be familiar to you (Ruby has a practically identical feature using <code class="language-js highlighter-rouge"><span class="err">#</span><span class="p">{</span></code> and <code class="language-js highlighter-rouge"><span class="p">}</span></code> instead). This is the first time JS has been able to do this. Here's a Ruby example:</p>
<pre><code>puts "1+1 = #{ 1 + 1 }" # Outputs: "1+1 = 2"
</code></pre>
<p>Here's the same kind of code, written in ES5 (Old JS) code:</p>
<pre><code>console.log('1+1 = ' + (1 + 1)); // Outputs: "1+1 = 2"
</code></pre>
<p>Now here's an example using ES6 code - this is what we can do with the amazing new <em>Template Literal</em> expression interpolation features!</p>
<pre><code>console.log(`1+1 = ${ 1 + 1 }`); // Outputs: "1+1 = 2"
</code></pre>
<p>In this string substitution, the code (<code class="language-js highlighter-rouge"><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span></code>) is executed, and the value (<code class="language-js highlighter-rouge"><span class="mi">2</span></code>) is coerced to a string (<code class="language-js highlighter-rouge"><span class="s2">"2"</span></code>) and then added to the output string in place. We can also make use of variables here - they work in the scopes you'd expect them to:</p>
<pre><code>var place = 'World';
console.log(`Hello ${place}`); // Outputs: "Hello World"

function greeting(place) {
  return `Hello ${place}`;
}
console.log(greeting('readers')); // Outputs: "Hello readers"
</code></pre>
<p>This ability for interpolation gives us some great abilities to create functions, which can take data, and output a string - which is the fundamentals of any templating language! However, there's a few missing pieces which we still need; things like the ability to control the data behind the interpolations, which is critical for escaping bad code (a core feature of any good templating language). What a nice segue into…</p>
<h3 id="tagged-template-literals">Tagged template literals</h3>
<p>This is the last important feature we'll be discussing about <em>Template Literals</em>. <em>Tagged Template Literals</em> provide a way to expose the component parts of a <em>Template Literal</em> to a function. <em>Template Tags</em> are just normal functions, but to be useful they have to be invoked differently. If you try to call a function with a <em>Template Literal</em> in the normal way you'll just get a String as the first argument. If you call it in the special <em>Tagged Template Literal</em> way, then you'll get the composite parts of the template literal; you'll get access to all the string fragments, and all of the results from each interpolated expression.</p>
<p>Alright, all of that is a bit dense, so let's look at some code to illustrate:</p>
<pre><code>// here is our normal function. It takes two arguments, `strings` and `value1`
function greeting(strings, value1) {
  console.log('Strings:', strings);
  console.log('Value1:', value1);
}

var place = 'World';

// If we try to call our function in the normal way, we're really just passing a string as the first argument
greeting(`Hello ${place}`);
// Log output:
// Strings: 'Hello World'
// Value1: undefined

// invoking our function as a Tagged Template Literal - note the lack of parenthesis
greeting`Hello ${place}`
// Log output:
// Strings: ['Hello ', '']
// Value1: 'World'
</code></pre>
<p>Notice that when calling <code class="language-js highlighter-rouge"><span class="nx">greeting</span><span class="p">()</span></code> the normal way, with a template string as the first argument - the string is fully rendered
(<code class="language-js highlighter-rouge"><span class="s2">"Hello World"</span></code>) and that is passed to <code class="language-js highlighter-rouge"><span class="nx">greeting</span><span class="p">()</span></code>, but when we remove the parens - making it a <em>Tagged Template Literal</em> - we get an Array of all of the Strings (<code class="language-js highlighter-rouge"><span class="p">[</span><span class="s1">'Hello '</span><span class="p">,</span> <span class="s1">''</span><span class="p">]</span></code>) as the first argument, and the second argument is our interpolated <code class="language-js highlighter-rouge"><span class="nx">place</span></code> value (<code class="language-js highlighter-rouge"><span class="s1">'World'</span></code>). These are each of the component parts of the template - we can put these all together to remake the String, just as you'd expect:</p>
<pre><code>function greeting(strings, value1) {
  return strings[0] + value1 + strings[1];
}
var place = 'World';
console.log(greeting`Hello ${place}`)); // Outputs: "Hello World"
</code></pre>
<p>Now each <em>Expression Interpolation</em> in a <em>Template Literal</em> is passed as a new argument to the function. This means if we want to handle all possible values, we need to make a <em>variadic</em> function (which is just a fancy way to say it takes an unlimited amount of arguments). Also every time there is an <em>Expression Interpolation</em> there will be 2 Strings in the <code class="language-js highlighter-rouge"><span class="nx">strings</span></code> array - one for the left side of the interpolation, the second for the right side of the interpolation. So if the <em>Template Literal</em> has 1 <em>Expression Interpolation</em> then the tag function will have an array of 2 strings, and a second argument. If the <em>Template Literal</em> has 2 expressions, then the tag function will have an array of 3 strings, and a second and third argument.</p>
<p>To make a function which we can reuse with a variety of <em>Template Literals</em> with or without <em>Expression Interpolation</em>, we ideally just want to loop through all of the String values and concatenate them with all of the values. Let's write some code for this!</p>
<pre><code>function getFullString(strings) {
  var interpolatedValues = [].slice.call(arguments, 1); // get the "variadic" values from arguments, make them an array
  return strings.reduce(function (total, current, index) { // use `reduce` to iterate over the array, returning a new value
    total += current; // append the string to the total string
    if (interpolatedValues.hasOwnProperty(index)) { // if there is an interpolatedValue with a matching index, append this too
      total += interpolatedValues[index];
    }
    return total;
  }, ''); // the starting value is an empty string (`''`)
}

var place = 'World';
getFullString`Hello ${place}!`; // outputs: "Hello World!"
</code></pre>
<p>We can use a few ES6 tricks to shorten the above function, into something a bit more compact and readable:</p>
<pre><code>function getFullString(strings, ...interpolatedValues) { // `...` essentially slices the arguments for us.
  return strings.reduce((total, current, index) =&gt; { // use an arrow function for brevity here
    total += current;
    if (interpolatedValues.hasOwnProperty(index)) {
      total += interpolatedValues[index];
    }
    return total;
  }, '');
}
</code></pre>
<p>Of course this <code class="language-js highlighter-rouge"><span class="nx">getFullString</span></code> function doesn't do anything special, that <em>Template Literals</em> don't already do. I mentioned previously though, that a core function of templating languages like Handlebars is the automatic escaping input. HTML templating languages like Handlebars will escape any variables injected in the template, to prevent XSS (Cross Site Scripting) vulnerabilities - basically ensuring the injected variables cannot render new HTML, like a <code class="language-js highlighter-rouge"><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span></code> tag. We can do the same kind of escaping with our tag function:</p>
<pre><code>function safeHTML(strings, ...interpolatedValues) { // `...` essentially slices the arguments for us.
  return strings.reduce((total, current, index) =&gt; { // use an arrow function for brevity here
    total += current;
    if (interpolatedValues.hasOwnProperty(index)) {
      total += String(interpolatedValues[index]).replace(/&amp;/g, '&amp;').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
    }
    return total;
  }, '');
}

var badVariable = '&lt;script&gt;deleteEverything()&lt;/script&gt;';
safeHTML`&lt;div&gt;${badVariable}&lt;/div&gt;`; // Outputs: "&lt;div&gt;&lt;script&gt;deleteEverything()&lt;/script&gt;&lt;/div&gt;"
</code></pre>
<p>(By the way, don't actually write this kind of html escaping code and put it into production, as <a href="#comment-2984755245">WebReflection points out below</a> it is still vulnerable to XSS, but provides a simple illustration).</p>
<h2 id="replacing-handlebars-or-pugjade-or-dust-or-whatever-with-es6-template-strings">Replacing Handlebars (or Pug/Jade or Dust or whatever) with ES6 template strings</h2>
<p>Okay, so we can use multiple lines, interpolate variables and escape html all natively within ES6. This should be enough to replace a library like Handlebars with ES6 template strings right?</p>
<p>Let's look at an Handlebars template example. This is just a basic example of how to use handlebars, we'll use this as a yard stick to compare how expressive we can get with template strings;</p>
<pre><code>var Handlebars = require('handlebars');
Handlebars.registerHelper('capitalize', function (options) {
  var string = String(options.fn(this));
  return string[0].toUpperCase() + string.slice(1);
});
var page = Handlebars.compile(`
  &lt;h2&gt;People&lt;/h2&gt;
  &lt;ul&gt;
  {\{#each people}}
      &lt;li&gt;
        &lt;span&gt;&lt;/span&gt;
        {\{#if isAdmin}}
          &lt;button&gt;Delete &lt;/button&gt;
        {\{/if}}
      &lt;/li&gt;
  {\{/each}}
  &lt;/ul&gt;
`);

page({ isAdmin: true, people: ['Keith', 'Dave', 'Amy' ] });
</code></pre>
<h3 id="first-pass-es6-template-strings">First pass, ES6 template strings</h3>
<p>Given the handlebars example, if we just get rid of Handlebars, and try to do that with <em>just</em> <em>Template Literals</em> plus a few wrapping functions, we end up with this:</p>
<pre><code>function template(strings, ...interpolatedValues) {
  return strings.reduce((total, current, index) =&gt; {
    total += current;
    if (interpolatedValues.hasOwnProperty(index)) {
      total += String(interpolatedValues[index]).replace(/&amp;/g, '&amp;').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
    }
    return total;
  }, '');
}
function capitalize(string) {
  return string[0].toUpperCase() + string.slice(1);
}
var page = ({ people, isAdmin }) =&gt; template`
  &lt;h2&gt;People&lt;/h2&gt;
  &lt;ul&gt;
  ${people.map(person =&gt; `
      &lt;li&gt;
        &lt;span&gt;${capitalize(person)}&lt;/span&gt;
        ${isAdmin ?
          `&lt;button&gt;Delete ${capitalize(person)}&lt;/button&gt;`
        : ''}
      &lt;/li&gt;
  `)}
  &lt;/ul&gt;
`;

page({ isAdmin: true, people: ['Keith', 'Dave', 'Amy' ] });
</code></pre>
<p>That's pretty clean! Well, I guess we're done here…</p>
<p>Not so fast. There's some very weird looking bits of that function. For starters, there are template tags within template tags, which means sprinkling lots of little annoying syntax everywhere. Secondly, we're using a ternary (<code class="language-js highlighter-rouge"><span class="nx">$</span><span class="p">{</span><span class="nx">isAdmin</span><span class="p">}</span></code>) which forces us to include the "elsey" value (that weird <code class="language-js highlighter-rouge"><span class="err">:</span> <span class="s1">''</span><span class="p">}</span></code> bit). Not only that, but Handlebars gives us <em>loads</em> of other helpers, like <code class="language-js highlighter-rouge"><span class="nx">unless</span></code>, <code class="language-js highlighter-rouge"><span class="kd">with</span></code> and <code class="language-js highlighter-rouge"><span class="nx">lookup</span></code>. Handlebars also provides a mechanism for registering custom helpers, we could sure do with that! So what can we do to fix both of these problems?</p>
<h3 id="additional-helpers-for-es6-templates">Additional helpers for ES6 templates</h3>
<p>Luckily, with ES6 template strings - we could easily make new helpers, they're just functions! Let's make a helpers object which can also be used to register new helpers:</p>
<pre><code>function template(strings, ...interpolatedValues) {
  return strings.reduce((total, current, index) =&gt; {
    total += current;
    if (interpolatedValues.hasOwnProperty(index)) {
      total += String(interpolatedValues[index]).replace(/&amp;/g, '&amp;').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
    }
    return total;
  }, '');
}
var helpers = {
  if: (condition, thenTemplate, elseTemplate = '') =&gt; {
    return condition ? thenTemplate : elseTemplate;
  },
  unless: (condition, thenTemplate, elseTemplate) =&gt; {
    return !condition ? thenTemplate : elseTemplate;
  },
  registerHelper(name, fn) =&gt; {
    helpers[name] = fn;
  }
};
helpers.registerHelper('capitalize', (string) =&gt; {
  return string[0].toUpperCase() + string.slice(1).toUpperCase();
});

var page = ({ people, isAdmin }) =&gt; template`
  &lt;h2&gt;People&lt;/h2&gt;
  &lt;ul&gt;
  ${people.map(person =&gt; `
      &lt;li&gt;
        &lt;span&gt;${helpers.capitalize(person)}&lt;/span&gt;
        ${helpers.if(isAdmin,
          `&lt;button&gt;Delete ${helpers.capitalize(person)}&lt;/button&gt;`
        )}
      &lt;/li&gt;
  `)}
  &lt;/ul&gt;
`;

page({ isAdmin: true, people: ['Keith', 'Dave', 'Amy' ] });
</code></pre>
<p>Okay, this is a bit cleaner. There's less slightly syntax, and we have a nice way to add helpers which can be useful. There's still lots of back ticks everywhere though, is there a way we could get rid of those?</p>
<h3 id="es6-template-strings-with-symbols">ES6 template strings with Symbols</h3>
<p>So, as we're able to parse the template, and take all of its values - we can leverage the uniqueness of Symbols as a <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinel values</a>. Sentinel values are just unique values, that we can detect in our code to trigger certain code paths. We can use sentinel values here, to trigger our template features, like the if conditional. Let's take a look at what we can do with Symbol sentinels values, by replacing the <code class="language-js highlighter-rouge"><span class="k">if</span></code> and adding a nice readable <code class="language-js highlighter-rouge"><span class="nx">endIf</span></code>:</p>
<pre><code>var startBlockSentinel = Symbol('blockSentinel');
var ignoreBlockSentinel = Symbol('ignoreBlockSentinel');
var endBlockSentinel = Symbol('endBlockSentinel');
var helpers = {
  if: (condition, thenTemplate, elseTemplate = '') =&gt; {
    return condition ? startBlockSentinel : ignoreBlockSentinel;
  },
  end: () =&gt; {
    return endBlockSentinel;
  },
  unless: (condition, thenTemplate, elseTemplate) =&gt; {
    return !condition ? startBlockSentinel : ignoreBlockSentinel;
  },
  registerHelper(name, fn) =&gt; {
    helpers[name] = fn;
  },
};

function template(strings, ...interpolatedValues) {
  const blockNest = [];
  return strings.reduce((total, current, index) =&gt; {
    if (blockNest.includes(ignoreBlockSentinel)) { // If at any point we chose to ignore this block, skip this render pass
      return total;
    }

    total += current;
    if (interpolatedValues.hasOwnProperty(index)) {
      var value = interpolatedValues[index];
      if (value === startBlockSentinel || value === ignoreBlockSentinel) {
        blockNest.push(value);
      }
      if (value === endBlockSentinel) {
        blockNest.pop();
      }
      total += String(interpolatedValues[index]).replace(/&amp;/g, '&amp;').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
    }
    return total;
  }, '');
}


helpers.registerHelper('capitalize', (string) =&gt; {
  return string[0].toUpperCase() + string.slice(1).toUpperCase();
});

var page = ({ people, isAdmin }) =&gt; template`
  &lt;h2&gt;People&lt;/h2&gt;
  &lt;ul&gt;
  ${people.map(person) =&gt; `
      &lt;li&gt;
        &lt;span&gt;${helpers.capitalize(person)}&lt;/span&gt;
        ${helpers.if(isAdmin)}
        &lt;button&gt;Delete ${helpers.capitalize(person)}&lt;/button&gt;
        ${helpers.end()}
      &lt;/li&gt;
  `)}
  &lt;/ul&gt;
`;

page({ isAdmin: true, people: ['Keith', 'Dave', 'Amy' ] });
</code></pre>
<p>Hey, check that out! We've added a small amount of code to our template function, and we've managed to clean up our template from all the easy-to-miss syntax, we're no longer lost in a sea of parentheses and back ticks, instead we have some nice readable function calls.</p>
<h2 id="wait-is-all-this-code-really-better">Wait… is all this code really better?</h2>
<p>It's a great question. We've come all this way, and it's questionable if this is any better than what Handlebars already provides us, in terms of an expressive syntax. We're not really making our code more concise, it's probably not much faster than Handlebars would be (when fully compiled), so it is questionable if this has all been worth it?</p>
<p>Ultimately, as you may have expected by now - I think the answer is no, not really. It was an interesting experiment, and showed some cool ES6 features, but Handlebars exists - has lots of great features and the developers have had plenty of time to work out all of the bugs and edge cases. What we have with our solution, is the beginnings of a huge commitment of time to get it to the level of refinement that Handlebars has.</p>
<p>Surely this hasn't been a total waste of time though? Have we learned anything from this? Is there anything we could take away from this? Well, I'm glad you asked, dear reader (you did ask right)?</p>
<h2 id="microtemplates-are-the-best-solution">Microtemplates are the best solution</h2>
<p>The real answer, I think, is not that our solution was more expressive or not than Handlebars, it was that the fundamental concept of "monolithic templates" is broken in its expressiveness.</p>
<p>If you've spent time doing React, or any functional programming, then you might already be familiar with the concept of splitting out larger templates - with complex state and conditionals - into a series of smaller templates which can be managed much more easily. This, I believe, is where we can use <em>Template Literals</em> to our advantage. Our existing templates did too many complicated things! Let's break them down into much smaller templates:</p>
<pre><code>var capitalize = (string) =&gt; {
  return string[0].toUpperCase() + string.slice(1);
};

var adminDelete = ({ person }) =&gt; {
  return `&lt;button&gt;Delete ${capitalize(person)}&lt;/button&gt;`;
}
var personRecord = ({ person, deleteButton }) =&gt; {
  return `
  &lt;li&gt;
    &lt;span&gt;${capitalize(person)}&lt;/span&gt;
    ${deleteButton}
  &lt;/li&gt;
`;
}

var peopleList = ({ people, isAdmin }) =&gt; {
  return `
  &lt;ul&gt;
    ${people.map(person =&gt; personRecord({
      person,
      deleteButton: isAdmin ? adminDelete(person) : ''
    })).join('')}
  &lt;/ul&gt;
`;
}

var page = ({ people, isAdmin }) =&gt; {
  return `
  &lt;h2&gt;People&lt;/h2&gt;
  ${peopleList({ people, isAdmin })}
`;
}
</code></pre>
<p>By having these smaller functions, we have made a more manageable codebase because:</p>
<ol>
<li>Smaller functions are easier to test, they take a smaller set of data, and have a smaller range of outputs</li>
<li>Smaller functions are composable! You can swap out parts easier, or re-arrange or refactor them with less work.</li>
<li>Smaller functions are reusable! For example <code class="language-js highlighter-rouge"><span class="nx">personRecord</span></code> could easily be used where ever your app lists people, in a friends list, a block list, etc.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>So Handlebars (or Dust or Jade or whatever templating language you are using or want to use) does a fine job. ES6 <em>Template Literals</em> probably won't be replacing <em>those libaries</em> any time soon, as there is little to gain from doing so. If you're using an existing templating library, you can feel confident that there's no new awesome thing that will shake up the landscape.</p>
<p>Having said that, maybe these <em>template literals</em> have given us a chance to step back and see that those templating languages aren't really fixing the problem in the right way? Maybe having small, composible template fragements is actually much more preferable, and maybe by breaking them down that small - we remove all of the need for these templating libraries?</p>
<p>What do you think about this? I'd love to hear your thoughts, musings and machinations around this topic. Feel free to send all hate mail to <code class="language-js highlighter-rouge"><span class="o">/</span><span class="nx">dev</span><span class="o">/</span><span class="kc">null</span></code>, otherwise, as always, speak up in the comments below or on Twitter, where I'm <a href="https://twitter.com/keithamus">@keithamus</a>.</p>
</section>
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>20 : Metaprogramming in ES6: Symbols and why they're awesome</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>21 : Metaprogramming in ES6: Symbols and why they're awesome</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>22 : Metaprogramming in ES6: Symbols and why they're awesome</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				<!--================= START :: Tutorial =================-->
				<article>
					<a id="t05" name="t05"></a><h1>23 : Metaprogramming in ES6: Symbols and why they're awesome</h1>
					<span class="ref-site"></span>
					<div class="tutorial__content">
					
					</div>
				</article>
				<!--================= END :: Tutorial =================-->
				
				
			</section>
			
		</main>
	
			</body></html>