<html>
	<head>
		<title>ES6 Tutorials :: Part 1</title>
		<style>
			@font-face {
			font-family: 'pt_sansregular';
			src: url('fonts/PTS55F-webfont.eot');
			src: url('fonts/PTS55F-webfont.eot?#iefix') format('embedded-opentype'),
			url('fonts/PTS55F-webfont.woff') format('woff'),
			url('fonts/PTS55F-webfont.ttf') format('truetype'),
			url('fonts/PTS55F-webfont.svg#pt_sansregular') format('svg');
			font-weight: normal;
			font-style: normal;
			}
			body { font-family: 'pt_sansregular', Arial, Tahoma, Helvetica, FreeSans, sans-serif; line-height: 1.7; font-size: 14px; }
			pre {
			border: 1px dashed #888;
			padding: 15px;
			word-break: normal;
			word-break: break-all;
			word-wrap: break-word;
			font-size: 13px;
			line-height: 1.42857143;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
			position: relative;
			}
			pre:after {
			content: "CODE";
			position: absolute;
			right: 0;
			top: 0;
			padding: 5px 10px;
			border-left: 1px dashed #888;
			border-bottom: 1px dashed #888;
			}
			h1{ border-top: 1px solid #666; border-bottom: 2px solid #888; padding: 10px 0; font-size: 20px; text-align: center; }
			h2, h3 { font-size: 16px; border-left: 6px solid #666; padding: 5px 15px; }
			code, kbd, pre, samp {
			font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
			}
			code {
			padding: 2px 4px;
			font-size: 90%;
			background-color: #f9f2f4;
			border-radius: 4px;
			}
			blockquote {
			letter-spacing: .01rem;
			font-weight: 400;
			font-style: italic;
			border-left: 3px solid rgba(0,0,0,0.8);
			padding-left: 20px;
			margin-left: -0;
			margin-bottom: 30px;
			padding-bottom: 3px;
			}
			@media print {
			img {
			display: block;
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			pre, code, pre code, pre span, code span, pre code span {
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			}
		</style>
	</head>
	<body>
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<div class="read">

<h1>
Understanding ECMAScript 6
</h1>
<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="#leanpub-auto-introduction">Introduction</a>
    <ul>
      <li>
        <a href="#leanpub-auto-browser-and-nodejs-compatibility">Browser and Node.js Compatibility</a>
      </li>
      <li>
        <a href="#leanpub-auto-who-this-book-is-for">Who This Book is For</a>
      </li>
      <li>
        <a href="#leanpub-auto-overview">Overview</a>
      </li>
      <li>
        <a href="#leanpub-auto-help-and-support">Help and Support</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-block-bindings">Block Bindings</a>
    <ul>
      <li>
        <a href="#leanpub-auto-let-declarations">Let declarations</a>
      </li>
      <li>
        <a href="#leanpub-auto-constant-declarations">Constant declarations</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-temporal-dead-zone">The Temporal Dead Zone</a>
      </li>
      <li>
        <a href="#leanpub-auto-use-in-loops">Use in Loops</a>
      </li>
      <li>
        <a href="#leanpub-auto-global-block-bindings">Global Block Bindings</a>
      </li>
      <li>
        <a href="#leanpub-auto-emerging-best-practices">Emerging Best Practices</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-destructuring">Destructuring</a>
    <ul>
      <li>
        <a href="#leanpub-auto-object-destructuring">Object Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-array-destructuring">Array Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-mixed-destructuring">Mixed Destructuring</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-1">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-strings-and-regular-expressions">Strings and Regular Expressions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-better-unicode-support">Better Unicode Support</a>
      </li>
      <li>
        <a href="#leanpub-auto-other-string-changes">Other String Changes</a>
      </li>
      <li>
        <a href="#leanpub-auto-other-regular-expression-changes">Other Regular Expression Changes</a>
      </li>
      <li>
        <a href="#leanpub-auto-template-strings">Template Strings</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-2">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-functions">Functions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-default-parameters">Default Parameters</a>
      </li>
      <li>
        <a href="#leanpub-auto-rest-parameters">Rest Parameters</a>
      </li>
      <li>
        <a href="#leanpub-auto-destructured-parameters">Destructured Parameters</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-spread-operator">The Spread Operator</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-name-property">The name Property</a>
      </li>
      <li>
        <a href="#leanpub-auto-newtarget-call-and-construct">new.target, [[Call]], and [[Construct]]</a>
      </li>
      <li>
        <a href="#leanpub-auto-block-level-functions">Block-Level Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-arrow-functions">Arrow Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-syntax">Syntax</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-3">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-objects">Objects</a>
    <ul>
      <li>
        <a href="#leanpub-auto-object-categories">Object Categories</a>
      </li>
      <li>
        <a href="#leanpub-auto-object-literal-extensions">Object Literal Extensions</a>
      </li>
      <li>
        <a href="#leanpub-auto-objectis">Object.is()</a>
      </li>
      <li>
        <a href="#leanpub-auto-objectassign">Object.assign()</a>
      </li>
      <li>
        <a href="#leanpub-auto-duplicate-object-literal-properties">Duplicate Object Literal Properties</a>
      </li>
      <li>
        <a href="#leanpub-auto-changing-prototypes">Changing Prototypes</a>
      </li>
      <li>
        <a href="#leanpub-auto-super-references">Super References</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-4">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-symbols">Symbols</a>
    <ul>
      <li>
        <a href="#leanpub-auto-creating-symbols">Creating Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-identifying-symbols">Identifying Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-using-symbols">Using Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-sharing-symbols">Sharing Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-finding-object-symbols">Finding Object Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-coercing-symbols-to-strings">Coercing Symbols to Strings</a>
      </li>
      <li>
        <a href="#leanpub-auto-well-known-symbols">Well-Known Symbols</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-5">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-iterators-and-generators">Iterators and Generators</a>
    <ul>
      <li>
        <a href="#leanpub-auto-what-are-iterators">What are Iterators?</a>
      </li>
      <li>
        <a href="#leanpub-auto-generators">Generators</a>
      </li>
      <li>
        <a href="#leanpub-auto-iterables-and-for-of">Iterables and for-of</a>
      </li>
      <li>
        <a href="#leanpub-auto-built-in-iterators">Built-in Iterators</a>
      </li>
      <li>
        <a href="#leanpub-auto-advanced-functionality">Advanced Functionality</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-6">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-classes">Classes</a>
    <ul>
      <li>
        <a href="#leanpub-auto-class-like-structures-in-ecmascript-5">Class-Like Structures in ECMAScript 5</a>
      </li>
      <li>
        <a href="#leanpub-auto-class-declarations">Class Declarations</a>
      </li>
      <li>
        <a href="#leanpub-auto-class-expressions">Class Expressions</a>
      </li>
      <li>
        <a href="#leanpub-auto-accessor-properties">Accessor Properties</a>
      </li>
      <li>
        <a href="#leanpub-auto-static-members">Static Members</a>
      </li>
      <li>
        <a href="#leanpub-auto-derived-classes">Derived Classes</a>
      </li>
      <li>
        <a href="#leanpub-auto-newtarget">new.target</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-7">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-promises">Promises</a>
    <ul>
      <li>
        <a href="#leanpub-auto-asynchronous-programming-background">Asynchronous Programming Background</a>
      </li>
      <li>
        <a href="#leanpub-auto-promise-basics">Promise Basics</a>
      </li>
      <li>
        <a href="#leanpub-auto-chaining-promises">Chaining Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-returning-promise-in-promise-chains">Returning Promise in Promise Chains</a>
      </li>
      <li>
        <a href="#leanpub-auto-responding-to-multiple-promises">Responding to Multiple Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-inheriting-from-promises">Inheriting from Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-8">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-modules">Modules</a>
    <ul>
      <li>
        <a href="#leanpub-auto-what-are-modules">What are Modules?</a>
      </li>
      <li>
        <a href="#leanpub-auto-basic-exporting-and-importing">Basic Exporting and Importing</a>
      </li>
      <li>
        <a href="#leanpub-auto-renaming-exports-and-imports">Renaming Exports and Imports</a>
      </li>
      <li>
        <a href="#leanpub-auto-exporting-and-importing-defaults">Exporting and Importing Defaults</a>
      </li>
      <li>
        <a href="#leanpub-auto-re-exporting">Re-exporting</a>
      </li>
      <li>
        <a href="#leanpub-auto-importing-without-bindings">Importing Without Bindings</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-9">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-appendix-a-other-changes">Appendix A: Other Changes</a>
    <ul>
      <li>
        <a href="#leanpub-auto-working-with-integers">Working with Integers</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-math-methods">New Math Methods</a>
      </li>
      <li>
        <a href="#leanpub-auto-unicode-identifiers">Unicode Identifiers</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main">
<h2 id="leanpub-auto-introduction">Introduction</h2>

<p>The JavaScript core language features are defined in a standard called ECMA-262. The language defined in this standard is called ECMAScript, of which the JavaScript in the browser and Node.js environments are a superset. While browsers and Node.js may add more capabilities through additional objects and methods, the core of the language remains as defined in ECMAScript, which is why the ongoing development of ECMA-262 is vital to the success of JavaScript as a whole.</p>

<p>In 2007, JavaScript was at a crossroads. The popularity of Ajax was ushering in a new age of dynamic web applications while JavaScript hadn't changed since the third edition of ECMA-262 was published in 1999. TC-39, the committee responsible for driving the ECMAScript process, put together a large draft specification for ECMAScript 4. ECMAScript 4 was massive in scope, introducing changes both small and large to the language. Language features included new syntax, modules, classes, classical inheritance, private object members, optional type annotations, and more.</p>

<p>The scope of the ECMAScript 4 changes caused a rift to form in TC-39, with some members feeling that the fourth edition was trying to accomplish too much. A group of leaders from Yahoo, Google, and Microsoft came up with an alternate proposal for the next version of ECMAScript that they initially called ECMAScript 3.1. The "3.1" was intended to show that this was an incremental change to the existing standard.</p>

<p>ECMAScript 3.1 introduced very few syntax changes, instead focusing on property attributes, native JSON support, and adding methods to already-existing objects. Although there was an early attempt to reconcile ECMAScript 3.1 and ECMAScript 4, this ultimately failed as the two camps had difficulty with the very different perspectives on how the language should grow.</p>

<p>In 2008, Brendan Eich, the creator of JavaScript, announced that TC-39 would focus its efforts on standardizing ECMAScript 3.1. They would table the major syntax and feature changes of ECMAScript 4 until after the next version of ECMAScript was standardized, and all members of the committee would work to bring the best pieces of ECMAScript 3.1 and 4 together after that point into an effort initially nicknamed ECMAScript Harmony.</p>

<p>ECMAScript 3.1 was eventually standardized as the fifth edition of ECMA-262, also described as ECMAScript 5. The committee never released an ECMAScript 4 standard to avoid confusion with the now-defunct effort of the same name. Work then began on ECMAScript Harmony, with ECMAScript 6 being the first standard released in this new "harmonious" spirit.</p>

<p>ECMAScript 6 reached feature complete status in 2015 was formally dubbed "ECMAScript 2015" (though this text still refers to it as ECMAScript 6, the name most familiar to developers). The features vary widely from completely new objects and patterns to syntax changes to new methods on existing objects. The exciting thing about ECMAScript 6 is that all of these changes are geared towards problems that developers are actually facing. And while it will still take time for adoption and implementation to reach the point where ECMAScript 6 is the minimum that developers can expect, there's a lot to be gained from a good understanding of what the future of JavaScript looks like.</p>

<h3 id="leanpub-auto-browser-and-nodejs-compatibility">Browser and Node.js Compatibility</h3>

<p>Many JavaScript environments, such as web browsers and Node.js, are actively working on implementing ECMAScript 6. This book does not attempt to address the inconsistencies between implementations and instead focuses on what the specification defines as the correct behavior. As such, it's possible that your JavaScript environment may not conform to the behavior described in this book.</p>

<h3 id="leanpub-auto-who-this-book-is-for">Who This Book is For</h3>

<p>This book is intended as a guide for those who are already familiar with JavaScript and ECMAScript 5. While a deep understanding of the language isn't necessary to use this book, it is helpful in understanding the differences between ECMAScript 5 and 6. In particular, this book is aimed at intermediate-to-advanced JavaScript developers (both browser and Node.js environments) who want to learn about the future of the language.</p>

<p>This book is not for beginners who have never written JavaScript. You will need to have a good basic understanding of the language to make use of this book.</p>

<h3 id="leanpub-auto-overview">Overview</h3>

<p><strong>Chapter 1: Block Bindings</strong> talks about <code>let</code> and <code>const</code>, the block-level replacement for <code>var</code>.</p>

<p><strong>Chapter 2: Destructuring</strong> introduces object and array destructuring, which allow you to decompose objects and arrays using a concise syntax.</p>

<p><strong>Chapter 3: Strings and Regular Expressions</strong> covers the additions to string manipulation and inspection as well as the introduction of template strings.</p>

<p><strong>Chapter 4: Functions</strong> discusses the various changes to functions. This includes the arrow function form, default parameters, rest parameters, and more.</p>

<p><strong>Chapter 5: Objects</strong> explains the changes to how objects are created, modified, and used. Topics include changes to object literal syntax, and new reflection methods.</p>

<p><strong>Chapter 6: Symbols</strong> introduces the concept of symbols, a new way to define properties. Symbols are a new primitive type that can be used to obscure (but not hide) object properties and methods.</p>

<p><strong>Chapter 7: Iterators and Generators</strong> discusses the addition of iterators and generators to the language. These features allow you to work with collections of data in powerful ways that were not possible in previous versions of JavaScript.</p>

<p><strong>Chapter 8: Classes</strong> introduces the first formal concept of classes in JavaScript. Often a point of confusion for those coming from other languages, the addition of class syntax in JavaScript makes the language more approachable to others and more concise for enthusiasts.</p>

<p><strong>Chapter 9: Arrays</strong> details the changes to native arrays and the interesting new ways they can be used in JavaScript.</p>

<p><strong>Chapter 10: Collections</strong> details the new collection types of <code>Set</code>, <code>WeakSet</code>, <code>Map</code>, and <code>WeakMap</code>. These types expand on the usefulness of arrays by adding semantics, de-duping, and memory management designed specifically for JavaScript.</p>

<p><strong>Chapter 11: Promises</strong> introduces promises as a new part of the language. Promises were a grassroots effort that eventually took off and gained in popularity due to extensive library support. ECMAScript 6 formalizes promises and makes them available by default.</p>

<p><strong>Chapter 12: Reflection</strong> introduces the formalized reflection API for JavaScript. Similar to other languages, ECMAScript 6 reflection allows you to inspect objects at a granular level, even if you didn't create the object.</p>

<p><strong>Chapter 13: Proxies</strong> discusses the new proxy object that allows you to intercept every operation performed on an object. Proxies give developers unprecedented control over objects and, as such, unlimited possibilities for defining new interaction patterns.</p>

<p><strong>Chapter 14: Modules</strong> details the official module format for JavaScript. The intent is that these modules can replace the numerous ad-hoc module definition formats that have appeared over the years.</p>

<h3 id="leanpub-auto-help-and-support">Help and Support</h3>

<p>You can file issues, suggest changes, and open pull requests against this book by visiting: <a href="https://github.com/nzakas/understandinges6">https://github.com/nzakas/understandinges6</a></p>

<p>For anything else, please send a message to the mailing list: <a href="http://groups.google.com/group/zakasbooks">http://groups.google.com/group/zakasbooks</a>.</p>

<h2 id="leanpub-auto-block-bindings">Block Bindings</h2>

<p>Traditionally, one of the tricky parts of JavaScript has been the way that <code>var</code> declarations work. In most C-based languages, variables (or <em>bindings</em>) are created at the spot where the declaration occurs. In JavaScript, however, this is not the case. Variables declared using <code>var</code> are <em>hoisted</em> to the top of the function (or global scope, if declared outside of a function) regardless of where the actual declaration occurs. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>

        <code class="c1">// other code</code>

        <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>

        <code class="c1">// value exists here with a value of undefined</code>

        <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// value exists here with a value of undefined</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>If you are unfamiliar with JavaScript, you might expect that the variable <code>value</code> is only defined if <code>condition</code> evaluates to true. In fact, the variable <code>value</code> is declared regardless. The JavaScript engine changes the function to look like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">var</code> <code class="nx">value</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>

        <code class="c1">// other code</code>

        <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>

        <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The declaration of <code>value</code> is moved to the top (hoisted) while the initialization remains in the same spot. That means the variable <code>value</code> is actually still accessible from within the <code>else</code> clause, it just has a value of <code>undefined</code> because it hasn't been initialized.</p>

<p>It often takes new JavaScript developers some time to get used to declaration hoisting and this unique behavior can end up causing bugs. For this reason, ECMAScript 6 introduces block level scoping options to make the control of variable lifecycle a little more powerful.</p>

<h3 id="leanpub-auto-let-declarations">Let declarations</h3>

<p>The <code>let</code> declaration syntax is the same as for <code>var</code>. You can basically replace <code>var</code> with <code>let</code> to declare a variable but keep its scope to the current code block. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>

        <code class="c1">// other code</code>

        <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>

        <code class="c1">// value doesn't exist here</code>

        <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// value doesn't exist here</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This function now behaves much closer to other C-based languages. The variable <code>value</code> is declared using <code>let</code> instead of <code>var</code>. That means the declaration is not hoisted to the top, and the variable <code>value</code> is destroyed once execution has flowed out of the <code>if</code> block. If <code>condition</code> evaluates to false, then <code>value</code> is never declared or initialized.</p>

<aside class="information blurb">
    <p>Since <code>let</code> declarations are <em>not</em> hoisted to the top of the enclosing block, you may want to always place <code>let</code> declarations first in the block so that they are available to the entire block.</p>

</aside>

<p>Perhaps one of the areas where developers most want block level scoping of variables is with <code>for</code> loops. It's not uncommon to see code such as this:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">process</code><code class="p">(</code><code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
<code class="p">}</code>

<code class="c1">// i is still accessible here</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>                     <code class="c1">// 10</code>
</pre></div>

</figure>

<p>In other languages, where block level scoping is the default, code like this works as intended. In JavaScript, the variable <code>i</code> is still accessible after the loop is completed because the <code>var</code> declaration was hoisted. Using <code>let</code> allows you to get the intended behavior:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">process</code><code class="p">(</code><code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
<code class="p">}</code>

<code class="c1">// i is not accessible here - throws an error</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
</pre></div>

</figure>

<p>In this example, the variable <code>i</code> only exists within the <code>for</code> loop. Once the loop is complete, the variable is destroyed and is no longer accessible elsewhere.</p>

<h3 id="leanpub-auto-constant-declarations">Constant declarations</h3>

<p>Another new way to define variables is to use the <code>const</code> declaration syntax. Variables declared using <code>const</code> are considered to be <em>constants</em>, so the value cannot be changed once set. For this reason, every <code>const</code> variable must be initialized. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Valid constant</code>
<code class="kr">const</code> <code class="nx">maxItems</code> <code class="o">=</code> <code class="mi">30</code><code class="p">;</code>

<code class="c1">// Syntax error: missing initialization</code>
<code class="kr">const</code> <code class="nx">name</code><code class="p">;</code>
</pre></div>

</figure>

<p>Constants, like <code>let</code> declarations, are block-level declarations. That means constants are destroyed once execution flows out of the block in which they were declared, and declarations are not hoisted to the top of the block. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">maxItems</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>

    <code class="c1">// more code</code>
<code class="p">}</code>

<code class="c1">// maxItems isn't accessible here</code>
</pre></div>

</figure>

<p>In this code, the constant <code>maxItems</code> is declared within an <code>if</code> statement. Once the statement finishes executing, <code>maxItems</code> is destroyed and is not accessible outside of that block.</p>

<p>Also similar to <code>let</code>, an error is thrown whenever a <code>const</code> declaration is made with an identifier for an already-defined variable in the same scope. It doesn't matter if that variable was declared using <code>var</code> (for global or function scope) or <code>let</code> (for block scope). For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Hello!"</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">25</code><code class="p">;</code>

<code class="c1">// Each of these would throw an error given the previous declarations</code>
<code class="kr">const</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Goodbye!"</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">30</code><code class="p">;</code>
</pre></div>

</figure>

<p>The big difference between <code>let</code> and <code>const</code> is that attempting to assign to a previously defined constant will throw an error in both strict and non-strict modes:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">const</code> <code class="nx">maxItems</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>

<code class="nx">maxItems</code> <code class="o">=</code> <code class="mi">6</code><code class="p">;</code>      <code class="c1">// throws error</code>
</pre></div>

</figure>

<p>Keep in mind that <code>const</code> prevents modification of the binding and not of the value itself. That means <code>const</code> declarations for objects do not prevent modification of those objects. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// works</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"Greg"</code><code class="p">;</code>

<code class="c1">// throws an error</code>
<code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Greg"</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Here, the binding <code>person</code> is created with an initial value of an object with one property. It's possible to change <code>person.name</code> without causing an error because you are changing what <code>person</code> contains and not changing the value that <code>person</code> is bound to. If you then attempt to assign a value to <code>person</code> (attempting to change the binding), an error is thrown. This subtlety in how <code>const</code> works with objects is easy to misunderstand. Remember, <code>const</code> prevents modification of the binding, not modification of the bound value.</p>

<aside class="warning blurb">
    <p>Several browsers implement pre-ECMAScript 6 versions of <code>const</code>. Implementations range from being simply a synonym for <code>var</code> (allowing the value to be overwritten) to actually defining constants but only in the global or function scope. For this reason, be especially careful with using <code>const</code> in a production system. It may not be providing you with the functionality you expect.</p>

</aside>

<h3 id="leanpub-auto-the-temporal-dead-zone">The Temporal Dead Zone</h3>

<p>Unlike <code>var</code>, <code>let</code> and <code>const</code> has no hoisting characteristics. A variable declared with either cannot be accessed until after the declaration. Attempting to do so results in a reference error:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// ReferenceError!</code>
    <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In this code, the variable <code>value</code> is defined and initialized using <code>let</code>, but that statement is never executed because the previous line throws an error. The issue is that <code>value</code> exists in what has become known as the <em>temporal dead zone</em> (TDZ). The TDZ is never named explicitly in the specification, but is a term often used to describe the non-hoisting behavior of <code>let</code>.</p>

<p>When a JavaScript engine looks through the upcoming block to find variable declarations, it results in either hoisting the declaration (for <code>var</code>) or placing the declaration in the TDZ (for <code>let</code> and <code>const</code>, discussed later). Any attempt to access a variable in the TDZ results in a runtime error. Only once execution flows to the variable declaration is that variable removed from the TDZ and therefore safe to use.</p>

<p>The same is true anytime you attempt to use a variable declared with <code>let</code> inside of the same block prior to it being defined. Even the normally safe <code>typeof</code> operator isn't safe:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code><code class="p">);</code>     <code class="c1">// ReferenceError!</code>
    <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Here, <code>typeof value</code> throws the same error as the previous example. You cannot use a <code>let</code> variable before its declaration within the same block. However, you can use <code>typeof</code> outside of the block:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code><code class="p">);</code>     <code class="c1">// "undefined"</code>

<code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"blue"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The variable <code>value</code> isn't in the TDZ when the <code>typeof</code> operation executes because it occurs outside of the block in which <code>value</code> is declared. That means there is no <code>value</code> binding and <code>typeof</code> simply returns <code>"undefined"</code>.</p>

<p>If an identifier has already been defined in the block, then using the identifier in a <code>let</code> declaration causes an error to be thrown. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">30</code><code class="p">;</code>

<code class="c1">// Syntax error</code>
<code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">40</code><code class="p">;</code>
</pre></div>

</figure>

<p>In this example, <code>count</code> is declared twice, once with <code>var</code> and once with <code>let</code>. Because <code>let</code> will not redefine an identifier that already exists in the same scope, the declaration throws an error. No error is thrown if a <code>let</code> declaration creates a new variable in a scope with the same name as a variable in the containing scope, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">30</code><code class="p">;</code>

<code class="c1">// Does not throw an error</code>
<code class="k">if</code> <code class="p">(</code><code class="nx">condition</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">40</code><code class="p">;</code>

    <code class="c1">// more code</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Here, the <code>let</code> declaration will not throw an error because it is creating a new variable called <code>count</code> within the <code>if</code> statement. This new variable shadows the global <code>count</code>, preventing access to it from within the <code>if</code> block.</p>

<aside class="information blurb">
    <p>Although the examples in this section use <code>let</code>, the same is true for <code>const</code>.</p>

</aside>

<h3 id="leanpub-auto-use-in-loops">Use in Loops</h3>

<p>The characteristics of <code>var</code> have long made using variables inside of loops problematic. Consider the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code> <code class="p">});</code>
<code class="p">}</code>

<code class="nx">funcs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">func</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">func</code><code class="p">();</code>     <code class="c1">// outputs the number "10" ten times</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This code will output the number <code>10</code> ten times in a row. That's because the variable <code>i</code> is shared across each iteration of the loop, meaning the functions created inside the loop all hold a reference to the same variable. The variable <code>i</code> has a value of <code>10</code> once the loop completes, and so that's the value each function outputs.</p>

<p>To fix this problem, developers use immediately-invoked function expressions (IIFEs) inside of loops to force a new copy of the variable to be created:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">((</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}(</code><code class="nx">i</code><code class="p">)));</code>
<code class="p">}</code>

<code class="nx">funcs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">func</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">func</code><code class="p">();</code>     <code class="c1">// outputs 0, then 1, then 2, up to 9</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This version of the example uses an IIFE inside of the loop. The <code>i</code> variable is passed to the IIFE, which creates its own copy and stores it as <code>value</code>. This is the value used of the function for that iteration, so calling each function returns the expected value.</p>

<h4 id="leanpub-auto-let-declarations-in-loops">Let Declarations in Loops</h4>

<p>A <code>let</code> declaration simplifies loops by effectively mimicking what the IIFE does in the previous example. Each iteration through the loop results in a new variable being created and initialized to the value of the variable with the same name from the previous iteration. That means you can omit the IIFE altogether and get the results you expect:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nx">funcs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">func</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">func</code><code class="p">();</code>     <code class="c1">// outputs 0, then 1, then 2, up to 9</code>
<code class="p">})</code>
</pre></div>

</figure>

<p>This code works exactly like the code that used <code>var</code> and an IIFE but is, arguably, cleaner. The <code>let</code> declaration creates a new variable <code>i</code> each time through the loop, so each function created inside the loop gets its own copy of <code>i</code>. Each copy of <code>i</code> has the value it was assigned at the beginning of the loop iteration in which it was created. The same is true for <code>for-in</code> and <code>for-of</code> (discussed in Chapter 7) loops:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">object</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">a</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">b</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">c</code><code class="o">:</code> <code class="kc">true</code>
    <code class="p">};</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nx">funcs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">func</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">func</code><code class="p">();</code>     <code class="c1">// outputs "a", then "b", then "c"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, <code>for-in</code> loop shows the same behavior as the <code>for</code> loop. Each time through the loop, a new <code>key</code> binding is created and so each function has its own copy. The result is that each function outputs a different value (if <code>var</code> was used, they would all output <code>"c"</code>).</p>

<aside class="information blurb">
    <p>It's important to understand that the behavior of <code>let</code> declarations in loops is a specially-defined behavior in the specification and is not necessarily related to the non-hoisting characteristics of <code>let</code>. In fact, early implementions of <code>let</code> did not have this behavior as it was added later on in the process.</p>

</aside>

<h4 id="leanpub-auto-constant-declarations-in-loops">Constant Declarations in Loops</h4>

<p>The specification doesn't explicitly disallow <code>const</code> declarations in loops, however, there are different behaviors based on the type of loop you're using. For a normal <code>for</code> loop, you can use <code>const</code> in the initializer, but the loop will throw a warning if you attempt to change the value. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>

<code class="c1">// throws an error after one iteration</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In this code, the <code>i</code> variable is declared as a constant. The first iteration of the loop, where <code>i</code> is 0, executes successfully. An error is thrown when <code>i++</code> executes because it's attempting to modify a constant. As such, you can only use <code>const</code> in the loop initializer if you are not modifying it.</p>

<p>When used in a <code>for-in</code> or <code>for-of</code> loop, <code>const</code> behaves the same as <code>let</code>. So the following will not cause an error:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">object</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">a</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">b</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">c</code><code class="o">:</code> <code class="kc">true</code>
    <code class="p">};</code>

<code class="c1">// doesn't cause an error</code>
<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nx">funcs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">func</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">func</code><code class="p">();</code>     <code class="c1">// outputs "a", then "b", then "c"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This code functions almost exactly the same as when using <code>let</code>. The only difference is that the value of <code>key</code> cannot be changed inside of the loop. The <code>for-in</code> and <code>for-of</code> loops work with <code>const</code> because the initializer creates a new binding each time through the loop rather than attempting to modify the value of an existing binding (as was the case with the <code>for</code> loop example).</p>

<h3 id="leanpub-auto-global-block-bindings">Global Block Bindings</h3>

<p>There is the potential for naming collisions when using <code>let</code> or <code>const</code> in the global scope because the global object has predefined properties. In many JavaScript environments, global variables are assigned as properties on the global object, and global object properties are accessed transparently as non-qualified identifiers (such as <code>name</code> or <code>location</code>). Using a block binding declaration to define a variable that shares a name with a property of the global object can produce an error because global object properties may be nonconfigurable. Since block bindings disallow redefinition of an identifier in the same scope, it's not possible to shadow nonconfigurable global properties. Attempting to do so will result in an error. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nb">RegExp</code> <code class="o">=</code> <code class="s2">"Hello!"</code><code class="p">;</code>          <code class="c1">// ok</code>
<code class="kd">let</code> <code class="kc">undefined</code> <code class="o">=</code> <code class="s2">"Hello!"</code><code class="p">;</code>       <code class="c1">// throws error</code>
</pre></div>

</figure>

<p>The first line of this example redefines the global <code>RegExp</code> as a string. Even though this would be problematic, there is no error thrown. The second line throws an error because <code>undefined</code> is a nonconfigurable own property of the global object. Since its definition is locked down by the environment, the <code>let</code> declaration is illegal.</p>

<p>It's unusual to use <code>let</code> or <code>const</code> in the global scope, but if you do, it's important to understand this situation.</p>

<h3 id="leanpub-auto-emerging-best-practices">Emerging Best Practices</h3>

<p>While ECMAScript 6 was in development, there was widespread belief you should use <code>let</code> by default instead of <code>var</code> for variable declarations. For many, <code>let</code> behaves exactly the way they thought <code>var</code> should have behaved, and so the direct replacement makes logical sense. You would then use <code>const</code> for variables that needed modification protection.</p>

<p>However, as more developers migrated to ECMAScript 6, an alternate approach gained popularity: use <code>const</code> by default and only use <code>let</code> when you know a variable's value needs to change. The rationale is that most variables should not change their value after initialization because unexpected value changes are a source of bugs. This idea has gained a significant amount of traction and is worth exploring in your code as you adopt ECMAScript 6.</p>

<h3 id="leanpub-auto-summary">Summary</h3>

<p>The <code>let</code> and <code>const</code> block bindings introduce lexical scoping to JavaScript. These declarations are not hoisted and only exist within the block in which they are declared. That means behavior that is more like other languages and less likely to cause unintentional errors, as variables can now be declared exactly where they are needed. As a side effect, you cannot access variables before they are declared, even with safe operators such as <code>typeof</code>. Attempting to access a block binding before its declaration results in an error due to the binding's presence in the temporal dead zone (TDZ).</p>

<p>In many cases, <code>let</code> and <code>const</code> behave in a manner that is similar to <code>var</code>, however, this is not true for loops. For both <code>let</code> and <code>const</code>, <code>for-in</code> and <code>for-of</code> loops create a new binding with each iteration through the loop. That means functions created inside the loop body can access the loop bindings values as they were during that iteration rather than as they were after the last iteration (the behavior with <code>var</code>). The same is true for <code>let</code> declarations in <code>for</code> loops, while attempting to use <code>const</code> declarations in a <code>for</code> loop may result in an error.</p>

<p>The current best practice for block bindings is to use <code>const</code> by default and only use <code>let</code> when you know a variable's value needs to change. This ensures a basic level of immutability in code that can help prevent certain types of errors.</p>

<h2 id="leanpub-auto-destructuring">Destructuring</h2>

<p>JavaScript developers spend a lot of time pulling data out of objects and arrays. It's not uncommon to see code such as this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code>
    <code class="p">};</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="nx">localRepeat</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">repeat</code><code class="p">,</code>
    <code class="nx">localSave</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">save</code><code class="p">;</code>
</pre></div>

</figure>

<p>Frequently, object properties are stored into local variables for more succinct code and easier access. ECMAScript 6 makes this easy by introducing <em>destructuring assignment</em>, which systematically goes through an object or array and stores specified pieces of data into local variables.</p>

<aside class="warning blurb">
    <p>If the right side value of a destructuring assignment evaluates to <code>null</code> or <code>undefined</code>, an error is thrown.</p>

</aside>

<h3 id="leanpub-auto-object-destructuring">Object Destructuring</h3>

<p>Object destructuring assignment syntax uses an object literal on the left side of an assignment operation. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code>
    <code class="p">};</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="p">{</code> <code class="nx">repeat</code><code class="o">:</code> <code class="nx">localRepeat</code><code class="p">,</code> <code class="nx">save</code><code class="o">:</code> <code class="nx">localSave</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">localRepeat</code><code class="p">);</code>       <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">localSave</code><code class="p">);</code>         <code class="c1">// false</code>
</pre></div>

</figure>

<p>In this code, the value of <code>options.repeat</code> is stored in a variable called <code>localRepeat</code> and the value of <code>options.save</code> is stored in a variable called <code>localSave</code>. These are both specified using the object literal syntax where the key is the property to find on <code>options</code> and the value is the variable in which to store the property value.</p>

<aside class="information blurb">
    <p>If the property with the given name doesn't exist on the object, then the local variable gets a value of <code>undefined</code>.</p>

</aside>

<p>If you want to use the property name as the local variable name, you can omit the colon and the identifier, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code>
    <code class="p">};</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="p">{</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">repeat</code><code class="p">);</code>        <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">save</code><code class="p">);</code>          <code class="c1">// false</code>
</pre></div>

</figure>

<p>Here, two local variables called <code>repeat</code> and <code>save</code> are created. They are initialized with the value of <code>options.repeat</code> and <code>options.save</code>, respectively. This shorthand is helpful when there's no need to have different variable names.</p>

<p>Destructuring can also handle nested objects, such as the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
        <code class="nx">rules</code><code class="o">:</code> <code class="p">{</code>
            <code class="nx">custom</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>
        <code class="p">}</code>
    <code class="p">};</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="p">{</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code><code class="p">,</code> <code class="nx">rules</code><code class="o">:</code> <code class="p">{</code> <code class="nx">custom</code> <code class="p">}}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">repeat</code><code class="p">);</code>        <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">save</code><code class="p">);</code>          <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">custom</code><code class="p">);</code>        <code class="c1">// 10</code>
</pre></div>

</figure>

<p>In this example, the <code>custom</code> property is embedded in another object. The extra set of curly braces allows you to descend into a nested object and pull out its properties.</p>

<aside>
  <h4 id="leanpub-auto-syntax-gotcha">Syntax Gotcha</h4>

  <p>If you try use destructuring assignment without a <code>var</code>, <code>let</code>, or <code>const</code>, you may be surprised by the result:</p>

  <figure class="code">
<div class="highlight"><pre><code class="c1">// syntax error</code>
<code class="p">{</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code><code class="p">,</code> <code class="nx">rules</code><code class="o">:</code> <code class="p">{</code> <code class="nx">custom</code> <code class="p">}}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>
</pre></div>

  </figure>

  <p>This causes a syntax error because the opening curly brace is normally the beginning of a block and blocks can't be part of assignment expressions.</p>

  <p>The solution is to wrap the entire expression in parentheses:</p>

  <figure class="code">
<div class="highlight"><pre><code class="c1">// no syntax error</code>
<code class="p">({</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code><code class="p">,</code> <code class="nx">rules</code><code class="o">:</code> <code class="p">{</code> <code class="nx">custom</code> <code class="p">}}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">);</code>
</pre></div>

  </figure>

  <p>This now works without any problems.</p>

</aside>

<h3 id="leanpub-auto-array-destructuring">Array Destructuring</h3>

<p>Similarly, you can destructure arrays using array literal syntax on the left side of an assignment operation. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">];</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="p">[</code> <code class="nx">firstColor</code><code class="p">,</code> <code class="nx">secondColor</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstColor</code><code class="p">);</code>        <code class="c1">// "red"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">secondColor</code><code class="p">);</code>       <code class="c1">// "green"</code>
</pre></div>

</figure>

<p>In this example, array destructuring pulls out the first and second values in the <code>colors</code> array. Keep in mind that the array itself isn't changed in any way.</p>

<p>Similar to object destructuring, you can also nest array destructuring. Just use another set of square brackets to descend into a subarray:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="p">[</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"lightgreen"</code> <code class="p">],</code> <code class="s2">"blue"</code> <code class="p">];</code>

<code class="c1">// later</code>

<code class="kd">var</code> <code class="p">[</code> <code class="nx">firstColor</code><code class="p">,</code> <code class="p">[</code> <code class="nx">secondColor</code> <code class="p">]</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstColor</code><code class="p">);</code>        <code class="c1">// "red"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">secondColor</code><code class="p">);</code>       <code class="c1">// "green"</code>
</pre></div>

</figure>

<p>Here, the <code>secondColor</code> variable refers to the <code>"green"</code> value inside of the <code>colors</code> array. That item is contained within a second array, so the extra square brackets around <code>secondColor</code> in the destructuring assignment is necessary.</p>

<h3 id="leanpub-auto-mixed-destructuring">Mixed Destructuring</h3>

<p>It's possible to mix objects and arrays together in a destructuring assignment expression using a mix of object and array literals. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
        <code class="nx">colors</code><code class="o">:</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">]</code>
    <code class="p">};</code>

<code class="kd">var</code> <code class="p">{</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code><code class="p">,</code> <code class="nx">colors</code><code class="o">:</code> <code class="p">[</code> <code class="nx">firstColor</code><code class="p">,</code> <code class="nx">secondColor</code> <code class="p">]}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">repeat</code><code class="p">);</code>            <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">save</code><code class="p">);</code>              <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstColor</code><code class="p">);</code>        <code class="c1">// "red"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">secondColor</code><code class="p">);</code>       <code class="c1">// "green"</code>
</pre></div>

</figure>

<p>This example extracts two property values, <code>repeat</code> and <code>save</code>, and then two items from the <code>colors</code> array, <code>firstColor</code> and <code>secondColor</code>. Of course, you could also choose to retrieve the entire array:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">repeat</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">save</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
        <code class="nx">colors</code><code class="o">:</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">]</code>
    <code class="p">};</code>

<code class="kd">var</code> <code class="p">{</code> <code class="nx">repeat</code><code class="p">,</code> <code class="nx">save</code><code class="p">,</code> <code class="nx">colors</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">repeat</code><code class="p">);</code>                        <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">save</code><code class="p">);</code>                          <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">);</code>                        <code class="c1">// "red,green,blue"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code> <code class="o">===</code> <code class="nx">options</code><code class="p">.</code><code class="nx">colors</code><code class="p">);</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>This modified example retrieves <code>options.colors</code> and stores it in the <code>colors</code> variable. Notice that <code>colors</code> is a direct reference to <code>options.colors</code> and not a copy.</p>

<p>Mixed destructuring is very useful for pulling values out of JSON configuration structures without navigating the entire structure.</p>

<h3 id="leanpub-auto-summary-1">Summary</h3>

<p>Destructuring makes it easier to work with objects and arrays in JavaScript. Using syntax that's already familiar to many developers, object literals and array literals, you can now pick data structures apart to get at just the information you're interested in.</p>

<h2 id="leanpub-auto-strings-and-regular-expressions">Strings and Regular Expressions</h2>

<p>Strings are arguably one of the most important data types in programming. Found in nearly every higher-level programming language, the way developers work with strings is a fundamental capability for creating useful programs. Regular expressions, by extension, are important because of their relationship to strings and the extra power that developers can wield on strings through regular expressions. That's why ECMAScript 6 improved strings and regular expressions, adding new capabilities and long-missing functionality.</p>

<h3 id="leanpub-auto-better-unicode-support">Better Unicode Support</h3>

<p>Prior to ECMAScript 6, JavaScript strings were based solely on the idea of 16-bit character encodings. All string properties and methods, such as <code>length</code> and <code>charAt()</code>, were based around the idea that every 16-bit sequence represented a single character. ECMAScript 5 allowed JavaScript engines to decide which of two encodings to use, either UCS-2 or UTF-16 (both encodings use 16-bit <em>code units</em>, making all observable operations the same). While it's true that all of the world's characters used to fit into 16 bits at one point in time, that is no longer the case.</p>

<p>Keeping within 16 bits wasn't possible for Unicode's stated goal of providing a globally unique identifier to every character in the world. These globally unique identifiers, called <em>code points</em>, are simply numbers starting at 0 (you might think of these as character codes, though there is a subtle difference). A character encoding is responsible for encoding a code point into code units that are internally consistent. While UCS-2 had a one-to-one mapping of code point to code unit, UTF-16 is more variable.</p>

<p>The first 2^16 code points are represented as single 16-bit code units in UTF-16. This is called the <em>Basic Multilingual Plane</em> (BMP). Everything beyond that range is considered to be in a <em>supplementary plane</em>, where the code points can no longer be represented in just 16-bits. UTF-16 solves this problem by introducing <em>surrogate pairs</em> in which a single code point is represented by two 16-bit code units. That means any single character in a string can be either one code unit (for BMP, total of 16 bits) or two (for supplementary plane characters, total of 32 bits).</p>

<p>ECMAScript 5 kept all operations as working on 16-bit code units, meaning that you could get unexpected results from strings containing surrogate pairs. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>           <code class="c1">// 2</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sr">/^.$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">text</code><code class="p">));</code>      <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>        <code class="c1">// ""</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>        <code class="c1">// ""</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>    <code class="c1">// 55362</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>    <code class="c1">// 57271</code>
</pre></div>

</figure>

<p>In this example, a single Unicode character is represented using surrogate pairs, and as such, the JavaScript string operations treat the string as having two 16-bit characters. That means <code>length</code> is 2, a regular expression trying to match a single character fails, and <code>charAt()</code> is unable to return a valid character string. The <code>charCodeAt()</code> method returns the appropriate 16-bit number for each code unit, but that is the closest you could get to the real value in ECMAScript 5.</p>

<p>ECMAScript 6 enforces encoding of strings in UTF-16. Standardizing on this character encoding means that the language can now support functionality designed to work specifically with surrogate pairs.</p>

<h4 id="leanpub-auto-the-codepointat-method">The codePointAt() Method</h4>

<p>The first example of fully supporting UTF-16 is the <code>codePointAt()</code> method, which can be used to retrieve the Unicode code point that maps to a given position in a string. This method accepts the code unit position (not the character position) and returns an integer value:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">"a"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>    <code class="c1">// 55362</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>    <code class="c1">// 57271</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 97</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>   <code class="c1">// 134071</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>   <code class="c1">// 57271</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>   <code class="c1">// 97</code>
</pre></div>

</figure>

<p>The <code>codePointAt()</code> method works in the same manner as <code>charCodeAt()</code> except for non-BMP characters. The first character in <code>text</code> is non-BMP and is therefore comprised of two code units, meaning the entire length of the string is 3 rather than 2. The <code>charCodeAt()</code> method returns only the first code unit for position 0 whereas <code>codePointAt()</code> returns the full code point even though it spans multiple code units. Both methods return the same value for positions 1 (the second code unit of the first character) and 2 (the <code>"a"</code>).</p>

<p>This method is the easiest way to determine if a given character is represented by one or two code points:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">is32Bit</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mh">0xFFFF</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">is32Bit</code><code class="p">(</code><code class="s2">""</code><code class="p">));</code>         <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">is32Bit</code><code class="p">(</code><code class="s2">"a"</code><code class="p">));</code>          <code class="c1">// false</code>
</pre></div>

</figure>

<p>The upper bound of 16-bit characters is represented in hexadecimal as <code>FFFF</code>, so any code point above that number must be represented by two code units.</p>

<h4 id="leanpub-auto-stringfromcodepoint">String.fromCodePoint()</h4>

<p>When ECMAScript provides a way to do something, it also tends to provide a way to do the reverse. You can use <code>codePointAt()</code> to retrieve the code point for a character in a string, while <code>String.fromCodePoint()</code> produces a single-character string for the given code point. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code><code class="mi">134071</code><code class="p">));</code>  <code class="c1">// ""</code>
</pre></div>

</figure>

<p>You can think of <code>String.fromCodePoint()</code> as a more complete version of <code>String.fromCharCode()</code>. Each method has the same result for all characters in the BMP; the only difference is with characters outside of that range.</p>

<h4 id="leanpub-auto-escaping-non-bmp-characters">Escaping Non-BMP Characters</h4>

<p>ECMAScript 5 allows strings to contain 16-bit Unicode characters represented by an <em>escape sequence</em>. The escape sequence is the <code>\u</code> followed by four hexadecimal values. For example, the escape sequence <code>\u0061</code> represents the letter <code>"a"</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"\u0061"</code><code class="p">);</code>      <code class="c1">// "a"</code>
</pre></div>

</figure>

<p>If you try to use an escape sequence with a number past <code>FFFF</code>, the upper bound of the BMP, then you can get some surprising results:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"\u20BB7"</code><code class="p">);</code>     <code class="c1">// "7"</code>
</pre></div>

</figure>

<p>Since Unicode escape sequences were defined as always having exactly four hexadecimal characters, ECMAScript evaluates <code>\u20BB7</code> as two characters: <code>\u20BB</code> and <code>"7"</code>. The first character is unprintable and the second is the number 7.</p>

<p>ECMAScript 6 solves this problem by introducing an extended Unicode escape sequence where the hexadecimal numbers are contained within curly braces. This allows any number of hexadecimal characters to specify a single character:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"\u{20BB7}"</code><code class="p">);</code>     <code class="c1">// ""</code>
</pre></div>

</figure>

<p>Using the extended escape sequence, the correct character is contained in the string.</p>

<aside class="warning blurb">
    <p>Make sure that you use this new escape sequence only in an ECMAScript 6 environment. In all other environments, doing so causes a syntax error. You may want to check and see if the environment supports the extended escape sequence using a function such as:</p>

  <figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">supportsExtendedEscape</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="nb">eval</code><code class="p">(</code><code class="s2">"'\\u{00FF1}'"</code><code class="p">);</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

  </figure>

</aside>

<h4 id="leanpub-auto-the-normalize-method">The normalize() Method</h4>

<p>Another interesting aspect of Unicode is that different characters may be considered equivalent for the purposes of sorting or other comparison-based operations. There are two ways to define these relationships. First, <em>canonical equivalence</em> means that two sequences of code points are considered interchangeable in all respects. That even means that a combination of two characters can be canonically equivalent to one character. The second relationship is <em>compatibility</em>, meaning that two sequences of code points having different appearances but can be used interchangeably in certain situations.</p>

<p>The important thing to understand is that due to these relationships, it's possible to have two strings that represent fundamentally the same text and yet have them contain different code point sequences. For example, the character "" and the string "ae" may be used interchangeably even though they are different code points. These two strings would therefore be unequal in JavaScript unless they are normalized in some way.</p>

<p>ECMAScript 6 supports Unicode normalization forms through a new <code>normalize()</code> method on strings. This method optionally accepts a single string parameter indicating the Unicode normalization form to apply: <code>"NFC"</code> (default), <code>"NFD"</code>, <code>"NFKC"</code>, or <code>"NFKD"</code>. It's beyond the scope of this book to explain the differences between these four forms. Just keep in mind that, when comparing strings, both strings must be normalized to the same form. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">normalized</code> <code class="o">=</code> <code class="nx">values</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">text</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">normalize</code><code class="p">();</code>
<code class="p">});</code>

<code class="nx">normalized</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">first</code> <code class="o">&lt;</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">first</code> <code class="o">===</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this code, the strings in a <code>values</code> array are converted into a normalized form so that the array can be sorted appropriately. You can accomplish the sort on the original array by calling <code>normalize()</code> as part of the comparator:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">values</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">firstNormalized</code> <code class="o">=</code> <code class="nx">first</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(),</code>
        <code class="nx">secondNormalized</code> <code class="o">=</code> <code class="nx">second</code><code class="p">.</code><code class="nx">normalize</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">firstNormalized</code> <code class="o">&lt;</code> <code class="nx">secondNormalized</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">firstNormalized</code> <code class="o">===</code> <code class="nx">secondNormalized</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Once again, the most important thing to remember is that both values must be normalized in the same way. These examples have used the default, NFC, but you can just as easily specify one of the others:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">values</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">firstNormalized</code> <code class="o">=</code> <code class="nx">first</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"NFD"</code><code class="p">),</code>
        <code class="nx">secondNormalized</code> <code class="o">=</code> <code class="nx">second</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"NFD"</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">firstNormalized</code> <code class="o">&lt;</code> <code class="nx">secondNormalized</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">firstNormalized</code> <code class="o">===</code> <code class="nx">secondNormalized</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>If you've never worried about Unicode normalization before, then you probably won't have much use for this method. However, knowing that it is available will help, should you ever end up working on an internationalized application.</p>

<h4 id="leanpub-auto-the-regular-expression-u-flag">The Regular Expression u Flag</h4>

<p>Many common string operations are accomplished by using regular expressions. However, as noted earlier, regular expressions also work on the basis of 16-bit code units each representing a single character. That's why the single character match in the earlier example didn't work. To address this problem, ECMAScript 6 defines a new flag for regular expressions: <code>u</code> for "Unicode".</p>

<p>When a regular expression has the <code>u</code> flag set, it switches modes to work on characters and not code units. That means the regular expression will no longer get confused about surrogate pairs in strings and can behave as expected. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>           <code class="c1">// 2</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sr">/^.$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">text</code><code class="p">));</code>      <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">/^.$/u.test(text));     // true</code>
</pre></div>

</figure>

<p>Adding the <code>u</code> flag allows the regular expression to correctly match the string by characters. Unfortunately, ECMAScript 6 does not natively have a way of determining how many code points are present in a string; fortunately, regular expressions with the <code>u</code> flag can be used to figure it out:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">codePointLength</code><code class="p">(</code><code class="nx">text</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">text</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="err">/[\s\S]/gu);</code>
    <code class="k">return</code> <code class="nx">result</code> <code class="o">?</code> <code class="nx">result</code><code class="p">.</code><code class="nx">length</code> <code class="o">:</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">codePointLength</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">));</code>    <code class="c1">// 3</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">codePointLength</code><code class="p">(</code><code class="s2">"bc"</code><code class="p">));</code>   <code class="c1">// 3</code>
</pre></div>

</figure>

<p>The regular expression in this example matches both whitespace and non-whitespace characters, and is applied globally with Unicode enabled. The <code>result</code> contains an array of matches when there's at least one match, so the array length ends up being the number of code points in the string.</p>

<aside class="warning blurb">
    <p>Although this approach works, it's not very fast, especially when applied to long strings. Try to minimize counting code points whenever possible. Hopefully ECMAScript 7 will bring a more performant means by which to count code points.</p>

</aside>

<p>Since the <code>u</code> flag is a syntax change, attempting to use it in non-compliant JavaScript engines means a syntax error is thrown. The safest way to determine if the <code>u</code> flag is supported is with a function:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">hasRegExpU</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"u"</code><code class="p">);</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This function uses the <code>RegExp</code> constructor to pass in the <code>u</code> flag as an argument. This is valid syntax even in older JavaScript engines, however, the constructor will throw an error if <code>u</code> isn't supported.</p>

<aside class="information blurb">
    <p>If your code still needs to work in older JavaScript engines, it's best to use the <code>RegExp</code> constructor exclusively when using the <code>u</code> flag. This will prevent syntax errors and allow you to optionally detect and use the <code>u</code> flag without aborting execution.</p>

</aside>

<h3 id="leanpub-auto-other-string-changes">Other String Changes</h3>

<p>JavaScript strings have always lagged behind similar features of other languages. It was only in ECMAScript 5 that strings finally gained a <code>trim()</code> method, and ECMAScript 6 continues extending strings with new functionality.</p>

<h4 id="leanpub-auto-includes-startswith-endswith">includes(), startsWith(), endsWith()</h4>

<p>Developers have used <code>indexOf()</code> as a way to identify strings inside of other strings since JavaScript was first introduced. ECMAScript 6 adds three new methods whose purpose is to identify strings inside of other strings:</p>

<ul>
  <li>
<code>includes()</code> - returns true if the given text is found anywhere within the string or false if not.</li>
  <li>
<code>startsWith()</code> - returns true if the given text is found at the beginning of the string or false if not.</li>
  <li>
<code>endsWith()</code> - returns true if the given text is found at the end of the string or false if not.</li>
</ul>

<p>Each of these methods accepts two arguments: the text to search for and an optional location from which to start the search. When the second argument is omitted, <code>includes()</code> and <code>startsWith()</code> start search from the beginning of the string while <code>endsWith()</code> starts from the end. In effect, the second argument results in less of the string being searched. Here are some examples:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Hello world!"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">));</code>       <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s2">"!"</code><code class="p">));</code>             <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s2">"o"</code><code class="p">));</code>             <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s2">"o"</code><code class="p">));</code>           <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s2">"world!"</code><code class="p">));</code>        <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s2">"x"</code><code class="p">));</code>             <code class="c1">// false</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s2">"o"</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code>        <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s2">"o"</code><code class="p">,</code> <code class="mi">8</code><code class="p">));</code>          <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s2">"o"</code><code class="p">,</code> <code class="mi">8</code><code class="p">));</code>          <code class="c1">// false</code>
</pre></div>

</figure>

<p>These three methods make it much easier to identify substrings without needing to worry about identifying their exact position.</p>

<aside class="information blurb">
    <p>All of these methods return a boolean value. If you need to find the position of a string within another, use <code>indexOf()</code> or <code>lastIndexOf()</code>.</p>

</aside>

<aside class="warning blurb">
    <p>The <code>startsWith()</code>, <code>endsWith()</code>, and <code>includes()</code> methods will throw an error if you pass a regular expression instead of a string. This stands in contrast to <code>indexOf()</code> and <code>lastIndexOf()</code>, which both convert a regular expression argument into a string and then search for that string.</p>

</aside>

<h4 id="leanpub-auto-repeat">repeat()</h4>

<p>ECMAScript 6 also adds a <code>repeat()</code> method to strings. This method accepts a single argument, which is the number of times to repeat the string, and returns a new string that has the original string repeated the specified number of times. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"x"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code>         <code class="c1">// "xxx"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"hello"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>     <code class="c1">// "hellohello"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code>       <code class="c1">// "abcabcabcabc"</code>
</pre></div>

</figure>

<p>This method is really a convenience function above all else, which can be especially useful when dealing with text manipulation. One example where this functionality comes in useful is with code formatting utilities where you need to create indentation levels:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// indent using a specified number of spaces</code>
<code class="kd">var</code> <code class="nx">indent</code> <code class="o">=</code> <code class="s2">" "</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="nx">size</code><code class="p">),</code>
    <code class="nx">indentLevel</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="c1">// whenever you increase the indent</code>
<code class="kd">var</code> <code class="nx">newIndent</code> <code class="o">=</code> <code class="nx">indent</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="o">++</code><code class="nx">indentLevel</code><code class="p">);</code>
</pre></div>

</figure>

<h3 id="leanpub-auto-other-regular-expression-changes">Other Regular Expression Changes</h3>

<p>Regular expressions are an important part of working with strings in JavaScript, and like many parts of the language, haven't really changed very much in recent versions. ECMAScript 6, however, makes several improvements to regular expressions to go along with the updates to strings.</p>

<h4 id="leanpub-auto-the-regular-expression-y-flag">The Regular Expression y Flag</h4>

<p>ECMAScript 6 standardized the <code>y</code> flag after it had been implemented in Firefox as a proprietary extension to regular expressions. The <code>y</code> (sticky) flag starts matching at the position specified by its <code>lastIndex</code> property. If there is no match at that location, then the regular expression stops matching. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">"hello1 hello2 hello3"</code><code class="p">,</code>
    <code class="nx">pattern</code> <code class="o">=</code> <code class="sr">/hello\d\s?/</code><code class="p">,</code>
    <code class="nx">result</code> <code class="o">=</code> <code class="nx">pattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">),</code>
    <code class="nx">globalPattern</code> <code class="o">=</code> <code class="sr">/hello\d\s?/g</code><code class="p">,</code>
    <code class="nx">globalResult</code> <code class="o">=</code> <code class="nx">globalPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">),</code>
    <code class="nx">stickyPattern</code> <code class="o">=</code> <code class="err">/hello\d\s?/y,</code>
    <code class="nx">stickyResult</code> <code class="o">=</code> <code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>         <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello1 "</code>

<code class="nx">pattern</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="nx">globalPattern</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="nx">result</code> <code class="o">=</code> <code class="nx">pattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
<code class="nx">globalResult</code> <code class="o">=</code> <code class="nx">globalPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
<code class="nx">stickyResult</code> <code class="o">=</code> <code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>         <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello2 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// Error! stickyResult is null</code>
</pre></div>

</figure>

<p>In this example, three regular expressions are used, one each with the <code>y</code> flag, the <code>g</code> flag, and no flags. When used the first time, all three regular expressions return the same value <code>"hello1 "</code> (with a space at the end). After that, the <code>lastIndex</code> property is changed to 1, meaning that the regular expression should start matching from the second character. The regular expression with no flags completely ignores the change to <code>lastIndex</code> and still matches <code>"hello1 "</code>; the regular expression with the <code>g</code> flag goes on to match <code>"hello2 "</code> because it is searching forward from the second character of the string ("e"); the sticky regular expression doesn't match anything beginning at the second character so <code>stickyResult</code> is <code>null</code>.</p>

<p>The sticky flag saves the index of the next character after the last match in <code>lastIndex</code> whenever an operation is performed. If an operation results in no match then <code>lastIndex</code> is set back to 0. This behavior is the same as the global flag:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">"hello1 hello2 hello3"</code><code class="p">,</code>
    <code class="nx">pattern</code> <code class="o">=</code> <code class="sr">/hello\d\s?/</code><code class="p">,</code>
    <code class="nx">result</code> <code class="o">=</code> <code class="nx">pattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">),</code>
    <code class="nx">globalPattern</code> <code class="o">=</code> <code class="sr">/hello\d\s?/g</code><code class="p">,</code>
    <code class="nx">globalResult</code> <code class="o">=</code> <code class="nx">globalPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">),</code>
    <code class="nx">stickyPattern</code> <code class="o">=</code> <code class="err">/hello\d\s?/y,</code>
    <code class="nx">stickyResult</code> <code class="o">=</code> <code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>         <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello1 "</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>         <code class="c1">// 0</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalPattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>   <code class="c1">// 7</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>   <code class="c1">// 7</code>

<code class="nx">result</code> <code class="o">=</code> <code class="nx">pattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
<code class="nx">globalResult</code> <code class="o">=</code> <code class="nx">globalPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
<code class="nx">stickyResult</code> <code class="o">=</code> <code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>         <code class="c1">// "hello1 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello2 "</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyResult</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>   <code class="c1">// "hello2 "</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>         <code class="c1">// 0</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">globalPattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>   <code class="c1">// 14</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">stickyPattern</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">);</code>   <code class="c1">// 14</code>
</pre></div>

</figure>

<p>The value of <code>lastIndex</code> changed to 7 after the first call to <code>exec()</code> and to 14 after the second call for both the sticky and global patterns.</p>

<p>There are also a couple other subtle details to the sticky flag:</p>

<ol class="numeric">
  <li>The <code>lastIndex</code> property is only honored when calling methods on the regular expression object such as <code>exec()</code> and <code>test()</code>. Passing the regular expression to a string method, such as <code>match()</code>, will not result in the sticky behavior.</li>
  <li>When using the <code>^</code> character to match the start of a string, sticky regular expressions will only match from the start of the string (or start of line in multiline mode). So long as <code>lastIndex</code> is 0, the <code>^</code> makes a sticky regular expression no different from a non-sticky one. If <code>lastIndex</code> doesn't correspond to the beginning of the string (in single-line mode) or the beginning of a line (in multiline mode), the sticky regular expression will never match</li>
</ol>

<p>As with other regular expression flags, you can detect the presence of <code>y</code> by using a property. The <code>sticky</code> property is set to true with the sticky flag is present and false if not:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="err">/hello\d/y;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">sticky</code><code class="p">);</code>    <code class="c1">// true</code>
</pre></div>

</figure>

<p>The <code>sticky</code> property is read-only based on the presence of the flag and so cannot be changed in code.</p>

<p>Similar to the <code>u</code> flag, the <code>y</code> flag is a syntax change, so it will cause a syntax error in older JavaScript engines. You can use the same approach to detect support:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">hasRegExpY</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="kd">var</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"y"</code><code class="p">);</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Also similar to <code>u</code>, if you need to use <code>y</code> in code that runs in older JavaScript engines, be sure to use the <code>RegExp</code> constructor when defining those regular expressions to avoid a syntax error.</p>

<h4 id="leanpub-auto-duplicating-regular-expressions">Duplicating Regular Expressions</h4>

<p>In ECMAScript 5, you can duplicate regular expressions by passing them into the <code>RegExp</code> constructor, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">re1</code> <code class="o">=</code> <code class="sr">/ab/i</code><code class="p">,</code>
    <code class="nx">re2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="nx">re1</code><code class="p">);</code>
</pre></div>

</figure>

<p>However, if you provide the second argument to <code>RegExp</code>, which specifies the flags for the regular expression, then an error is thrown:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">re1</code> <code class="o">=</code> <code class="sr">/ab/i</code><code class="p">,</code>

    <code class="c1">// throws an error in ES5, okay in ES6</code>
    <code class="nx">re2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="nx">re1</code><code class="p">,</code> <code class="s2">"g"</code><code class="p">);</code>
</pre></div>

</figure>

<p>If you execute this code in an ECMAScript 5 environment, you'll get an error stating that the second argument cannot be used when the first argument is a regular expression. ECMAScript 6 changed this behavior such that the second argument is allowed and will override whichever flags are present on the first argument. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">re1</code> <code class="o">=</code> <code class="sr">/ab/i</code><code class="p">,</code>

    <code class="c1">// throws an error in ES5, okay in ES6</code>
    <code class="nx">re2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="nx">re1</code><code class="p">,</code> <code class="s2">"g"</code><code class="p">);</code>


<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re1</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>            <code class="c1">// "/ab/i"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re2</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>            <code class="c1">// "/ab/g"</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re1</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="s2">"ab"</code><code class="p">));</code>            <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re2</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="s2">"ab"</code><code class="p">));</code>            <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re1</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="s2">"AB"</code><code class="p">));</code>            <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re2</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="s2">"AB"</code><code class="p">));</code>            <code class="c1">// false</code>
</pre></div>

</figure>

<p>In this code, <code>re1</code> has the case-insensitive <code>i</code> flag present while <code>re2</code> has only the global <code>g</code> flag. The <code>RegExp</code> constructor duplicated the pattern from <code>re1</code> and then substituted <code>g</code> for <code>i</code>. If the second argument was missing then <code>re2</code> would have the same flags as <code>re1</code>.</p>

<h4 id="leanpub-auto-the-flags-property">The <code>flags</code> Property</h4>

<p>In ECMAScript 5, it's possible to get the text of the regular expression by using the <code>source</code> property, but to get the flag string requires parsing the output of <code>toString()</code>, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">getFlags</code><code class="p">(</code><code class="nx">re</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">re</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">substring</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">lastIndexOf</code><code class="p">(</code><code class="s2">"/"</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// toString() is "/ab/g"</code>
<code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/ab/g</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">getFlags</code><code class="p">(</code><code class="nx">re</code><code class="p">));</code>          <code class="c1">// "g"</code>
</pre></div>

</figure>

<p>ECMAScript 6 adds a <code>flags</code> property to go along with <code>source</code>. Both properties are prototype accessor properties with only a getter assigned (making them read-only). The addition of <code>flags</code> makes it easier to inspect regular expressions for both debugging and inheritance purposes.</p>

<p>A late addition to ECMAScript 6, the <code>flags</code> property returns the string representation of any flags applied to a regular expression. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/ab/g</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re</code><code class="p">.</code><code class="nx">source</code><code class="p">);</code>     <code class="c1">// "ab"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">re</code><code class="p">.</code><code class="nx">flags</code><code class="p">);</code>      <code class="c1">// "g"</code>
</pre></div>

</figure>

<p>Using <code>source</code> and <code>flags</code> together allow you to extract just the pieces of the regular expression that are necessary without needing to parse the regular expression string directly.</p>

<h3 id="leanpub-auto-template-strings">Template Strings</h3>

<p>JavaScript's strings have been fairly limited when compared to those in other languages. Template strings add new syntax to allow the creation of domain-specific languages (DSLs) for working with content in a way that is safer than the solutions we have today. The description on the template string strawman was as follows:</p>

<blockquote>
  <p>This scheme extends ECMAScript syntax with syntactic sugar to allow libraries to provide DSLs that easily produce, query, and manipulate content from other languages that are immune or resistant to injection attacks such as XSS, SQL Injection, etc.</p>
</blockquote>

<p>In reality, though, template strings are ECMAScript 6's answer to several ongoing problems in JavaScript:</p>

<ul>
  <li>
<strong>Multiline strings</strong> - JavaScript has never had a formal concept of multiline strings.</li>
  <li>
<strong>Basic string formatting</strong> - The ability to substitute parts of the string for values contained in variables.</li>
  <li>
<strong>HTML escaping</strong> - The ability to transform a string such that it is safe to insert into HTML.</li>
</ul>

<p>Rather than trying to add more functionality to JavaScript's already-existing strings, template strings represent an entirely new approach to solving these problems.</p>

<h4 id="leanpub-auto-basic-syntax">Basic Syntax</h4>

<p>At their simplest, template strings act like regular strings that are delimited by backticks (<code>`</code>) instead of double or single quotes. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="err">`</code><code class="nx">Hello</code> <code class="nx">world</code><code class="o">!</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>               <code class="c1">// "Hello world!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">message</code><code class="p">);</code>        <code class="c1">// "string"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>        <code class="c1">// 12</code>
</pre></div>

</figure>

<p>This code demonstrates that the variable <code>message</code> contains a normal JavaScript string. The template string syntax only is used to create the string value, which is then assigned to <code>message</code>.</p>

<p>If you want to use a backtick in your string, then you need only escape it by using a backslash (<code>\</code>):</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="err">`\`</code><code class="nx">Hello</code><code class="err">\`</code> <code class="nx">world</code><code class="o">!</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>               <code class="c1">// "`Hello` world!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">message</code><code class="p">);</code>        <code class="c1">// "string"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>        <code class="c1">// 14</code>
</pre></div>

</figure>

<p>There's no need to escape either double or single quotes inside of template strings.</p>

<h4 id="leanpub-auto-multiline-strings">Multiline Strings</h4>

<p>Ever since the first version of JavaScript, developers have longed for a way to create multiline strings in JavaScript. When using double or single quotes, strings must be completely contained on a single line. JavaScript has long had a syntax bug that would allow multiline strings by using a backslash (<code>\</code>) before a newline, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Multiline \</code>
<code class="s2">string"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>       <code class="c1">// "Multiline string"</code>
</pre></div>

</figure>

<p>Note that the string has no newlines present when output, that's because the backslash is treated as a continuation rather than a newline. In order to have a newline at that point, you would need to manually include it, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Multiline \n\</code>
<code class="s2">string"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>       <code class="c1">// "Multiline</code>
                            <code class="c1">//  string"</code>
</pre></div>

</figure>

<p>Despite this working in all major JavaScript engines, the behavior was defined as a bug and many recommended avoiding its usage.</p>

<p>Other attempts to create multiline strings usually relied on arrays or string concatenation, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="p">[</code>
    <code class="s2">"Multiline "</code><code class="p">,</code>
    <code class="s2">"string"</code>
<code class="p">].</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">);</code>

<code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Multiline \n"</code> <code class="o">+</code>
    <code class="s2">"string"</code><code class="p">;</code>
</pre></div>

</figure>

<p>All of the ways developers worked around JavaScript's lack of multiline strings left something to be desired.</p>

<p>Template strings make multiline strings easy because there is no special syntax. Just include a newline where you want and it shows up in the result. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="err">`</code><code class="nx">Multiline</code>
<code class="nx">string</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>           <code class="c1">// "Multiline</code>
                                <code class="c1">//  string"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>    <code class="c1">// 16</code>
</pre></div>

</figure>

<p>All whitespace inside of the backticks is considered to be part of the string, so be careful with indentation. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="err">`</code><code class="nx">Multiline</code>
               <code class="nx">string</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>           <code class="c1">// "Multiline</code>
                                <code class="c1">//                 string"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>    <code class="c1">// 31</code>
</pre></div>

</figure>

<p>In this code, all of the whitespace before the second line of the template string is considered to be a part of the string itself. If making the text line up with proper indentation is important to you, then you consider leaving nothing on the first line of a multiline template string and then indenting after that, such as this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">html</code> <code class="o">=</code> <code class="err">`</code>
<code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
    <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Title</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>
<code class="o">&lt;</code><code class="err">/div&gt;`.trim();</code>
</pre></div>

</figure>

<p>This code begins the template string on the first line but doesn't have any text until the second. The HTML tags are indented to look correct and then the <code>trim()</code> method is called to remove the initial (empty) line.</p>

<aside>
  <p>If you prefer, you can also use <code>\n</code> in a template string to indicate where a newline should be inserted:</p>
  <figure class="code">
<div class="highlight"><pre><code class="n">let</code> <code class="n">message</code> <code class="o">=</code> <code class="err">`</code><code class="n">Multiline</code><code class="err">\</code><code class="n">nstring</code><code class="err">`</code><code class="p">;</code>

<code class="n">console</code><code class="p">.</code><code class="n">log</code><code class="p">(</code><code class="n">message</code><code class="p">);</code>           <code class="c1">// "Multiline</code>
                                <code class="c1">//  string"</code>
<code class="n">console</code><code class="p">.</code><code class="n">log</code><code class="p">(</code><code class="n">message</code><code class="p">.</code><code class="n">length</code><code class="p">);</code>    <code class="c1">// 16</code>
</pre></div>

  </figure>

</aside>

<h4 id="leanpub-auto-substitutions">Substitutions</h4>

<p>To this point, template strings may look like a fancier way of defining normal JavaScript strings. The real difference is with template string substitutions. Substitutions allow you to embed any valid JavaScript expression inside of a template string and have the result be output as part of the string.</p>

<p>Substitutions are delimited by an opening <code>${</code> and a closing <code>}</code>, within which you can use any JavaScript expression. At its simplest, substitutions let you embed local variables directly into the result string, like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="nx">message</code> <code class="o">=</code> <code class="err">`</code><code class="nx">Hello</code><code class="p">,</code> <code class="nx">$</code><code class="p">{</code><code class="nx">name</code><code class="p">}.</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>       <code class="c1">// "Hello, Nicholas."</code>
</pre></div>

</figure>

<p>The substitution <code>${name}</code> accessed the local variable <code>name</code> to insert it into the string. The <code>message</code> variable then holds the result of the substitution immediately.</p>

<aside class="information blurb">
    <p>Template strings can access any variable that is accessible in the scope in which it is defined. Attempting to use an undeclared variable in a template string results in an error being thrown in both strict and non-strict modes.</p>

</aside>

<p>Since all substitutions are JavaScript expressions, it's possible to substitute more than just simple variable names. You can easily embed calculations, function calls, and more. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code>
    <code class="nx">price</code> <code class="o">=</code> <code class="mf">0.25</code><code class="p">,</code>
    <code class="nx">message</code> <code class="o">=</code> <code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code> <code class="nx">items</code> <code class="nx">cost</code> <code class="nx">$$</code><code class="p">{(</code><code class="nx">count</code> <code class="o">*</code> <code class="nx">price</code><code class="p">).</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">2</code><code class="p">)}.</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>       <code class="c1">// "10 items cost $2.50."</code>
</pre></div>

</figure>

<p>This code performs a calculation as part of the template string. The variables <code>count</code> and <code>price</code> are multiplied together to get a result, and then formatted to two decimal places using <code>.toFixed()</code>. The dollar sign before the second substitution is output as-is because it's not followed by an opening curly brace.</p>

<h4 id="leanpub-auto-tagged-templates">Tagged Templates</h4>

<p>To this point, you've seen how template strings can be used for multiline strings and to insert values into strings without using concatenation. The real power of template strings comes from tagged templates. A <em>template tag</em> performs a transformation on the template string and returns the final string value. This tag is specified at the start of the template, just before the first <code>`</code> character, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="nx">tag</code><code class="err">`</code><code class="nx">Hello</code> <code class="nx">world</code><code class="err">`</code><code class="p">;</code>
</pre></div>

</figure>

<p>In this example, <code>tag</code> is the template tag to apply to <code>`Hello world`</code>.</p>

<h5 id="leanpub-auto-defining-tags">Defining Tags</h5>

<p>A tag is simply a function that is called with the processed template string data. The function receives data about the template string as individual pieces that the tag must then combined to create the finished value. The first argument is an array containing the literal strings as they are interpreted by JavaScript. Each subsequent argument is the interpreted value of each substitution. Tag functions are typically defined using rest arguments to make dealing with the data easier:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">tag</code><code class="p">(</code><code class="nx">literals</code><code class="p">,</code> <code class="p">...</code><code class="nx">substitutions</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// return a string</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To better understand what is passed to tags, consider the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code>
    <code class="nx">price</code> <code class="o">=</code> <code class="mf">0.25</code><code class="p">,</code>
    <code class="nx">message</code> <code class="o">=</code> <code class="nx">passthru</code><code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code> <code class="nx">items</code> <code class="nx">cost</code> <code class="nx">$$</code><code class="p">{(</code><code class="nx">count</code> <code class="o">*</code> <code class="nx">price</code><code class="p">).</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">2</code><code class="p">)}.</code><code class="err">`</code><code class="p">;</code>
</pre></div>

</figure>

<p>If you had a function called <code>passthru()</code>, that function would receive three arguments:</p>

<ol class="numeric">
  <li>
<code>literals</code>, containing:
    <ul>
      <li>
<code>""</code> - the empty string before the first substitution</li>
      <li>
<code>" items cost $"</code> - the string after the first substitution and before the second</li>
      <li>
<code>"."</code> - the string after the second substitution</li>
    </ul>
  </li>
  <li>
<code>10</code> - the interpreted value for <code>count</code> (this becomes <code>substitutions[0]</code>)</li>
  <li>
<code>"2.50"</code> - the interpreted value for <code>(count * price).toFixed(2)</code> (this becomes <code>substitutions[1]</code>)</li>
</ol>

<p>Note that the first item in <code>literals</code> is an empty string. This is to ensure that <code>literals[0]</code> is always the start of the string, just like <code>literals[literals.length - 1]</code> is always the end of the string. There is always one fewer substitution than literal, which is to say that <code>substitutions.length === literals.length - 1</code> all the time.</p>

<p>Using this pattern, the <code>literals</code> and <code>substitutions</code> arrays can be interweaved to create the result. The first item in <code>literals</code> comes first, then the first item in <code>substitutions</code>, and so on, until the string has been completed. So to mimic the default behavior of template, you need only define a function that performs this operation:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">passthru</code><code class="p">(</code><code class="nx">literals</code><code class="p">,</code> <code class="p">...</code><code class="nx">substitutions</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>

    <code class="c1">// run the loop only for the substitution count</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">substitutions</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">literals</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">substitutions</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="p">}</code>

    <code class="c1">// add the last literal</code>
    <code class="nx">result</code> <code class="o">+=</code> <code class="nx">literals</code><code class="p">[</code><code class="nx">literals</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">];</code>

    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code>
    <code class="nx">price</code> <code class="o">=</code> <code class="mf">0.25</code><code class="p">,</code>
    <code class="nx">message</code> <code class="o">=</code> <code class="nx">passthru</code><code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code> <code class="nx">items</code> <code class="nx">cost</code> <code class="nx">$$</code><code class="p">{(</code><code class="nx">count</code> <code class="o">*</code> <code class="nx">price</code><code class="p">).</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">2</code><code class="p">)}.</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>       <code class="c1">// "10 items cost $2.50."</code>
</pre></div>

</figure>

<p>This example defines a <code>passthru</code> tag that performs the same transformation as the default template string behavior. The only trick is to use <code>substitutions.length</code> for the loop rather than <code>literals.length</code> to avoid accidentally going past the end of <code>substitutions</code>. This works because the relationship between <code>literals</code> and <code>substitutions</code> is well-defined.</p>

<aside class="information blurb">
    <p>The values contained in <code>substitutions</code> are not necessarily strings. If an expression is evaluated to be a number, as in the previous example, then the numeric value is passed in. It's part of the tag's job to determine how such values should be output in the result.</p>

</aside>

<h5 id="leanpub-auto-using-raw-values">Using Raw Values</h5>

<p>Template tags also have access to raw string information, which primarily means access to character escapes before they are transformed into their character equivalents. The simplest way to work with raw string values is to the built-in <code>String.raw()</code> tag. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">message1</code> <code class="o">=</code> <code class="err">`</code><code class="nx">Multiline</code><code class="err">\</code><code class="nx">nstring</code><code class="err">`</code><code class="p">,</code>
    <code class="nx">message2</code> <code class="o">=</code> <code class="nb">String</code><code class="p">.</code><code class="nx">raw</code><code class="err">`</code><code class="nx">Multiline</code><code class="err">\</code><code class="nx">nstring</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message1</code><code class="p">);</code>          <code class="c1">// "Multiline</code>
                                <code class="c1">//  string"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message2</code><code class="p">);</code>          <code class="c1">// "Multiline\\nstring"</code>
</pre></div>

</figure>

<p>In this code, the <code>\n</code> in <code>message1</code> is interpreted as a newline while the <code>\n</code> in <code>message2</code> is returned in its raw form of <code>"\\n"</code> (two characters, the slash and <code>n</code>). Retrieving the raw string information in this way allows for more complex processing (when necessary).</p>

<p>The raw string information is also passed into template tags. The first argument in a tag function is an array with an extra property called <code>raw</code>. The <code>raw</code> property is an array containing the raw equivalent of each literal value. So the value in <code>literals[0]</code> always has an equivalent <code>literals.raw[0]</code> that contains the raw string information. Knowing that, it's possible to mimic <code>String.raw()</code> using the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">raw</code><code class="p">(</code><code class="nx">literals</code><code class="p">,</code> <code class="p">...</code><code class="nx">substitutions</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>

    <code class="c1">// run the loop only for the substitution count</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">substitutions</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">literals</code><code class="p">.</code><code class="nx">raw</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>      <code class="c1">// use raw values instead</code>
        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">substitutions</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="p">}</code>

    <code class="c1">// add the last literal</code>
    <code class="nx">result</code> <code class="o">+=</code> <code class="nx">literals</code><code class="p">.</code><code class="nx">raw</code><code class="p">[</code><code class="nx">literals</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">];</code>

    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="nx">raw</code><code class="err">`</code><code class="nx">Multiline</code><code class="err">\</code><code class="nx">nstring</code><code class="err">`</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>           <code class="c1">// "Multiline\\nstring"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>    <code class="c1">// 17</code>
</pre></div>

</figure>

<p>This example uses <code>literals.raw</code> instead of <code>literals</code> to output the string result. That means any character escapes, including Unicode code point escapes, will be returned in their raw form.</p>

<h3 id="leanpub-auto-summary-2">Summary</h3>

<p>Full Unicode support allows JavaScript to start dealing with UTF-16 characters in logical ways. The ability to transfer between code point and character via <code>codePointAt()</code> and <code>String.fromCodePoint()</code> is an important step for string manipulation. The addition of the regular expression <code>u</code> flag makes it possible to operate on code points instead of 16-bit characters, and the <code>normalize()</code> method allows for more appropriate string comparisons.</p>

<p>Additional methods for working with strings were added, allowing you to more easily identify substrings no matter where they are found, and more functionality was added to regular expressions.</p>

<p>Template strings are an important addition to ECMAScript 6 that allows the creating of domain-specific languages (DSLs) to make creating strings easier. The ability to embed variables directly into template strings means that developers have a safer tool than string concatenation for composing long strings with variables.</p>

<p>Built-in support for multiline strings also makes template strings a useful upgrade over normal JavaScript strings, which have never had this ability. Despite allowing newlines directly inside the template string, you can still use <code>\n</code> and other character escape sequences.</p>

<p>Template tags are the most important part of this feature for creating DSLs. Tags are functions that receive the pieces of the template string as arguments. You can then use that data to return an appropriate string value. The data provided includes literals, their raw equivalents, and any substitution values. These pieces of information can then be used to determine the correct output for the tag.</p>

<h2 id="leanpub-auto-functions">Functions</h2>

<p>Functions are an important part of any programming language, and JavaScript functions hadn't changed much since the language was first introduced. This left a backlog of problems and nuanced behavior that made it easy to make mistakes or require more code just to achieve a very common behavior.</p>

<p>ECMAScript 6 functions made a big leap forward, taking into account years of complaints and asks from JavaScript developers. The result is a number of incremental improvements on top of ECMAScript 5 functions that make programming in JavaScript less error-prone and more powerful than ever before.</p>

<h3 id="leanpub-auto-default-parameters">Default Parameters</h3>

<p>Functions in JavaScript are unique in that they allow any number of parameters to be passed regardless of the number of declared parameters in the function definition. This allows you to define functions that can handle different number of parameters, often by just filling in default values when ones aren't provided. In ECMAScript 5 and earlier, you would likely use the following pattern to accomplish this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">makeRequest</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">timeout</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">timeout</code> <code class="o">=</code> <code class="nx">timeout</code> <code class="o">||</code> <code class="mi">2000</code><code class="p">;</code>
    <code class="nx">callback</code> <code class="o">=</code> <code class="nx">callback</code> <code class="o">||</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{};</code>

    <code class="c1">// the rest of the function</code>

<code class="p">}</code>
</pre></div>

</figure>

<p>In this example, both <code>timeout</code> and <code>callback</code> are actually optional because they are given a default value if not provided. The logical OR operator (<code>||</code>) always returns the second operand when the first is falsy. Since named function parameters that are not explicitly provided are set to <code>undefined</code>, the logical OR operator is frequently used to provide default values for missing parameters. There is a flaw with this approach, however, in that a valid value for <code>timeout</code> might actually be <code>0</code>, but this would replace it with <code>2000</code> because <code>0</code> is falsy.</p>

<p>Other ways of determining if any parameters are missing include checking <code>arguments.length</code> for the number of parameters that were passed or directly inspecting each parameter to see if it is not <code>undefined</code>.</p>

<p>ECMAScript 6 makes it easier to provide default values for parameters by providing initializations that are used when the parameter isn't formally passed. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">makeRequest</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">timeout</code> <code class="o">=</code> <code class="mi">2000</code><code class="p">,</code> <code class="nx">callback</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{})</code> <code class="p">{</code>

    <code class="c1">// the rest of the function</code>

<code class="p">}</code>
</pre></div>

</figure>

<p>Here, only the first parameter is expected to be passed all the time. The other two parameters have default values, which makes the body of the function much smaller because you don't need to add any code to check for a missing value. When <code>makeRequest()</code> is called with all three parameters, then the defaults are not used. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// uses default timeout and callback</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">);</code>

<code class="c1">// uses default callback</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">,</code> <code class="mi">500</code><code class="p">);</code>

<code class="c1">// doesn't use defaults</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">,</code> <code class="mi">500</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">body</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">doSomething</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Any parameters with a default value are considered to be optional parameters while those without a default value are considered to be required parameters.</p>

<p>It's possible to specify default values for any arguments, including those that appear before arguments without default values. For example, this is fine:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">makeRequest</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">timeout</code> <code class="o">=</code> <code class="mi">2000</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>

    <code class="c1">// the rest of the function</code>

<code class="p">}</code>
</pre></div>

</figure>

<p>In this case, the default value for <code>timeout</code> will only be used if there is no second argument passed in or if the second argument is explicitly passed in as <code>undefined</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// uses default timeout</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">body</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">doSomething</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// uses default timeout</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">);</code>

<code class="c1">// doesn't use default timeout</code>
<code class="nx">makeRequest</code><code class="p">(</code><code class="s2">"/foo"</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">body</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">doSomething</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In the case of default parameter values, the value of <code>null</code> is considered to be valid and the default value will not be used.</p>

<p>Perhaps the most interesting feature of default parameter values is that the default value need not be a primitive value. You can, for example, execute a function to retrieve the default parameter:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">getCallback</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// some code</code>
    <code class="p">};</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">makeRequest</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">timeout</code> <code class="o">=</code> <code class="mi">2000</code><code class="p">,</code> <code class="nx">callback</code> <code class="o">=</code> <code class="nx">getCallback</code><code class="p">())</code> <code class="p">{</code>

    <code class="c1">// the rest of the function</code>

<code class="p">}</code>
</pre></div>

</figure>

<p>Here, if the last argument isn't provided, the function <code>getCallback()</code> is called to retrieve the correct default value. This opens up a lot of interesting possibilities to dynamically inject information into functions.</p>

<h3 id="leanpub-auto-rest-parameters">Rest Parameters</h3>

<p>Since JavaScript functions can be passed any number of parameters, it's not always necessary to define each parameter specifically. Early on, JavaScript provided the <code>arguments</code> object as a way of inspecting all function parameters that were passed without necessarily defining each one individually. While that worked fine in most cases, it can become a little cumbersome to work with. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">pick</code><code class="p">(</code><code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>

    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code><code class="p">[</code><code class="nx">arguments</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">object</code><code class="p">[</code><code class="nx">arguments</code><code class="p">[</code><code class="nx">i</code><code class="p">]];</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Understanding ECMAScript 6"</code><code class="p">,</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Nicholas C. Zakas"</code><code class="p">,</code>
    <code class="nx">year</code><code class="o">:</code> <code class="mi">2015</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">bookData</code> <code class="o">=</code> <code class="nx">pick</code><code class="p">(</code><code class="nx">book</code><code class="p">,</code> <code class="s2">"author"</code><code class="p">,</code> <code class="s2">"year"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bookData</code><code class="p">.</code><code class="nx">author</code><code class="p">);</code>   <code class="c1">// "Nicholas C. Zakas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bookData</code><code class="p">.</code><code class="nx">year</code><code class="p">);</code>     <code class="c1">// 2015</code>
</pre></div>

</figure>

<p>This function mimics the <code>pick()</code> method from Underscore. The first argument is the object from which to copy properties and every other argument is the name of a property that should be copied on the result. There are couple of things to notice about this function. First, it's not at all obvious that the function is capable of handling more than one parameter. You could add in several more named parameters, but you would always fall short of indicating that this function can take any number of parameters. Second, because the first parameter is named and used directly, you have to start looking in the <code>arguments</code> object at index 1 instead of starting at index 0. Remembering to use the appropriate indices with <code>arguments</code> isn't necessarily difficult, but it's one more thing to keep track of. ECMAScript 6 introduces rest parameters to help with these issues.</p>

<p>Rest parameters are indicated by three dots (<code>...</code>) preceding a named parameter. That named parameter then becomes an <code>Array</code> containing the rest of the parameters (which is why these are called "rest" parameters). For example, <code>pick()</code> can be rewritten using rest parameters like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">pick</code><code class="p">(</code><code class="nx">object</code><code class="p">,</code> <code class="p">...</code><code class="nx">keys</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>

    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">keys</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code><code class="p">[</code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">object</code><code class="p">[</code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">]];</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In this version of the function, <code>keys</code> is a rest parameter that contains all parameters after the first one (unlike <code>arguments</code>, which contains all parameters including the first one). That means you can iterate over <code>keys</code> from beginning to end without worry. As a bonus, you can tell by looking at the function that it is capable of handling any number of parameters.</p>

<p>The only restriction on rest parameters is that no other named arguments can follow in the function declaration. For example, this causes syntax error:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Syntax error: Can't have a named parameter after rest parameters</code>
<code class="kd">function</code> <code class="nx">pick</code><code class="p">(</code><code class="nx">object</code><code class="p">,</code> <code class="p">...</code><code class="nx">keys</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>

    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">keys</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code><code class="p">[</code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">object</code><code class="p">[</code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">]];</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Here, the parameter <code>last</code> follows the rest parameter <code>keys</code> and causes a syntax error.</p>

<p>Rest parameters were designed to replace <code>arguments</code> in ECMAScript. Originally ECMAScript 4 did away with <code>arguments</code> and added rest parameters to allow for an unlimited number of arguments to be passed to functions. Even though ECMAScript 4 never came into being, the idea was kept around and reintroduced in ECMAScript 6 despite <code>arguments</code> not being removed from the language.</p>

<h3 id="leanpub-auto-destructured-parameters">Destructured Parameters</h3>

<p>In Chapter 1, you learned about destructuring assignment. Destructuring can also be used outside of the context of an assignment expression and perhaps the most interesting such case is with destructured parameters.</p>

<p>It's common for functions that take a large number of optional parameters to use an options object as one or more parameters. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">setCookie</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">options</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">options</code> <code class="o">=</code> <code class="nx">options</code> <code class="o">||</code> <code class="p">{};</code>

    <code class="kd">var</code> <code class="nx">secure</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">secure</code><code class="p">,</code>
        <code class="nx">path</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">path</code><code class="p">,</code>
        <code class="nx">domain</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">domain</code><code class="p">,</code>
        <code class="nx">expires</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">expires</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">setCookie</code><code class="p">(</code><code class="s2">"type"</code><code class="p">,</code> <code class="s2">"js"</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">secure</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
    <code class="nx">expires</code><code class="o">:</code> <code class="mi">60000</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>There are many <code>setCookie()</code> functions in JavaScript libraries that look similar to this. The <code>name</code> and <code>value</code> are required but everything else is not. And since there is no priority order for the other data, it makes sense to have an options object with named properties rather than extra named parameters. This approach is okay, although it makes the expected input for the function a bit opaque.</p>

<p>Using destructured parameters, the previous function can be rewritten as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">setCookie</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="p">{</code> <code class="nx">secure</code><code class="p">,</code> <code class="nx">path</code><code class="p">,</code> <code class="nx">domain</code><code class="p">,</code> <code class="nx">expires</code> <code class="p">})</code> <code class="p">{</code>

    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">setCookie</code><code class="p">(</code><code class="s2">"type"</code><code class="p">,</code> <code class="s2">"js"</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">secure</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
    <code class="nx">expires</code><code class="o">:</code> <code class="mi">60000</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The behavior of this function is similar to the previous example, the biggest difference is the third argument uses destructuring to pull out the necessary data. Doing so makes it clear which parameters are really expected, and the destructured parameters also act like regular parameters in that they are set to <code>undefined</code> if they are not passed.</p>

<p>One quirk of this pattern is that the destructured parameters throw an error when the argument isn't provided. If <code>setCookie()</code> is called with just two arguments, it results in a runtime error:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Error!</code>
<code class="nx">setCookie</code><code class="p">(</code><code class="s2">"type"</code><code class="p">,</code> <code class="s2">"js"</code><code class="p">);</code>
</pre></div>

</figure>

<p>This code throws an error because the third argument is missing (<code>undefined</code>). To understand why this is an error, it helps to understand that destructured parameters are really just a shorthand for destructured assignment. The JavaScript engine is actually doing this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">setCookie</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">options</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">var</code> <code class="p">{</code> <code class="nx">secure</code><code class="p">,</code> <code class="nx">path</code><code class="p">,</code> <code class="nx">domain</code><code class="p">,</code> <code class="nx">expires</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">options</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Since destructuring assignment throws an error when the right side expression evaluates to <code>null</code> or <code>undefined</code>, the same is true when the third argument isn't passed.</p>

<p>You can work around this behavior by providing a default value for the destructured parameter:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">setCookie</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="p">{</code> <code class="nx">secure</code><code class="p">,</code> <code class="nx">path</code><code class="p">,</code> <code class="nx">domain</code><code class="p">,</code> <code class="nx">expires</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{</code>

    <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example now works exactly the same as the first example in this section. Providing the default value for the destructured parameter means that <code>secure</code>, <code>path</code>, <code>domain</code>, and <code>expires</code> will all be <code>undefined</code> if the third argument to <code>setCookie()</code> isn't provided.</p>

<aside class="information blurb">
    <p>It's recommended to always provide the default value for destructured parameters to avoid these types of errors.</p>

</aside>

<h3 id="leanpub-auto-the-spread-operator">The Spread Operator</h3>

<p>Closely related to rest parameters is the spread operator. Whereas rest parameters allow you to specify that multiple independent arguments should be combined into an array, the spread operator allows you to specify an array that should be split and have its items passed in as separate arguments to a function. Consider the <code>Math.max()</code> method, which accepts any number of arguments and returns the one with the highest value. It's basic usage is as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">value1</code> <code class="o">=</code> <code class="mi">25</code><code class="p">,</code>
    <code class="nx">value2</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">value1</code><code class="p">,</code> <code class="nx">value2</code><code class="p">));</code>      <code class="c1">// 50</code>
</pre></div>

</figure>

<p>When you're dealing with just two values, as in this example, <code>Math.max()</code> is very easy to use. The two values are passed in and the higher value is returned. But what if you have been tracking values in an array, and now you want to find the highest value? The <code>Math.max()</code> method doesn't allow you to pass in an array, so in ECMAScript 5 and earlier, you'd be stuck either searching the array yourself or using <code>apply()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[</code><code class="mi">25</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="mi">75</code><code class="p">,</code> <code class="mi">100</code><code class="p">]</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nb">Math</code><code class="p">,</code> <code class="nx">values</code><code class="p">));</code>  <code class="c1">// 100</code>
</pre></div>

</figure>

<p>While possible, using <code>apply()</code> in this manner is a bit confusing - it actually seems to obfuscate the true meaning of the code with additional syntax.</p>

<p>The ECMAScript 6 spread operator makes this case very simple. Instead of calling <code>apply()</code>, you can pass in the array and prefix it with the same <code>...</code> pattern that is used with rest parameters. The JavaScript engine then splits up the array into individual arguments and passes them in:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[</code><code class="mi">25</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="mi">75</code><code class="p">,</code> <code class="mi">100</code><code class="p">]</code>

<code class="c1">// equivalent to</code>
<code class="c1">// console.log(Math.max(25, 50, 75, 100));</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(...</code><code class="nx">values</code><code class="p">));</code>           <code class="c1">// 100</code>
</pre></div>

</figure>

<p>Now the call to <code>Math.max()</code> looks a bit more conventional and avoids the complexity of specifying a <code>this</code>-binding for a simple mathematical operation.</p>

<p>You can mix and match the spread operator with other arguments as well. Suppose you want the smallest number returned from <code>Math.max()</code> to be 0 (just in case negative numbers sneak into the array). You can pass that argument separately and still use the spread operator for the other arguments:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[</code><code class="o">-</code><code class="mi">25</code><code class="p">,</code> <code class="o">-</code><code class="mi">50</code><code class="p">,</code> <code class="o">-</code><code class="mi">75</code><code class="p">,</code> <code class="o">-</code><code class="mi">100</code><code class="p">]</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(...</code><code class="nx">values</code><code class="p">,</code> <code class="mi">0</code><code class="p">));</code>        <code class="c1">// 0</code>
</pre></div>

</figure>

<p>In this example, the last argument passed to <code>Math.max()</code> is <code>0</code>, which comes after the other arguments are passed in using the spread operator.</p>

<p>The spread operator for argument passing makes using arrays for function arguments much easier. You'll likely find it to be a suitable replacement for the <code>apply()</code> method in most circumstances.</p>

<h3 id="leanpub-auto-the-name-property">The name Property</h3>

<p>Identifying functions can be challenging in JavaScript given the various ways a function can be defined. Additionally, the prevalence of anonymous function expressions makes debugging a bit more difficult, often resulting in stack traces that are hard to read and decipher. For these reasons, ECMAScript 6 adds the <code>name</code> property to all functions.</p>

<p>All functions in an ECMAScript 6 program will have an appropriate value for their <code>name</code> property while all others will have an empty string. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">doSomething</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">doAnotherThing</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">doSomething</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>          <code class="c1">// "doSomething"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">doAnotherThing</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <code class="c1">// "doAnotherThing"</code>
</pre></div>

</figure>

<p>In this code, <code>doSomething()</code> has a <code>name</code> property equal to <code>"doSomething"</code> because it's a function declaration. The anonymous function expression <code>doAnotherThing()</code> has a <code>name</code> of <code>"doAnotherThing"</code> due to the variable to which it is assigned.</p>

<p>While appropriate names for function declarations and function expressions are easy to find, ECMAScript 6 goes further to ensure that all functions have appropriate names:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">doSomething</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">doSomethingElse</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">get</code> <code class="nx">firstName</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Nicholas"</code>
    <code class="p">},</code>
    <code class="nx">sayName</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">doSomething</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>      <code class="c1">// "doSomethingElse"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>   <code class="c1">// "sayName"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">firstName</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// "get firstName"</code>
</pre></div>

</figure>

<p>In this example, <code>doSomething.name</code> is <code>"doSomethingElse"</code> because the function expression itself has a name and that name takes priority over the variable to which the function was assigned. The <code>name</code> property of <code>person.sayName()</code> is <code>"sayName"</code>, as the value was interpreted from the object literal. Similarly, <code>person.firstName</code> is actually a getter function, so its name is <code>"get firstName"</code> to indicate this difference (setter functions are prefixed with <code>"set"</code> as well).</p>

<p>There are a couple of other special cases for function names. Functions created using <code>bind()</code> will have their name prefixed with <code>"bound"</code> and functions created using the <code>Function</code> constructor have a name of <code>"anonymous"</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">doSomething</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">doSomething</code><code class="p">.</code><code class="nx">bind</code><code class="p">().</code><code class="nx">name</code><code class="p">);</code>   <code class="c1">// "bound doSomething"</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">((</code><code class="k">new</code> <code class="nb">Function</code><code class="p">()).</code><code class="nx">name</code><code class="p">);</code>     <code class="c1">// "anonymous"</code>
</pre></div>

</figure>

<p>The <code>name</code> of a bound function will always be the <code>name</code> of the function being bound prefixed with the <code>"bound "</code>, so the bound version of <code>doSomething()</code> is <code>"bound doSomething"</code>.</p>

<h3 id="leanpub-auto-newtarget-call-and-construct">new.target, [[Call]], and [[Construct]]</h3>

<p>In ECMAScript 5 and earlier, functions serve the double purpose of being callable with or without <code>new</code>. When used with <code>new</code>, the <code>this</code> value inside of a function is a new object and that new object is returned. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">notAPerson</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">);</code>        <code class="c1">// "[Object object]"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">notAPerson</code><code class="p">);</code>    <code class="c1">// "undefined"</code>
</pre></div>

</figure>

<p>Calling <code>Person()</code> without <code>new</code> results in <code>undefined</code> (and a <code>name</code> property being set on the global object in non-strict mode). It's fairly obvious from the code that the intent is to use <code>Person</code> with <code>new</code> to create a new object. The confusion over the dual roles of functions led to some changes in ECMAScript 6.</p>

<p>First, the specification defines two different internal-only methods that every function has: <code>[[Call]]</code> and <code>[[Construct]]</code>. When a function is called without <code>new</code>, the <code>[[Call]]</code> method is executed, which essentially executes the body of the function as it appears in the code. When a function is called with <code>new</code>, that's when the <code>[[Construct]]</code> method is called. The <code>[[Construct]]</code> method is responsible for creating a new object, called the <em>new target</em>, and then executing the function body with <code>this</code> set to the new target. Functions that have a <code>[[Construct]]</code> method are called <em>constructors</em>.</p>

<aside class="information blurb">
    <p>Keep in mind that not all functions have <code>[[Construct]]</code>, and therefore not all function can be called with <code>new</code>. Arrow functions, discussed later in this chapter, do not have a <code>[[Construct]]</code> method.</p>

</aside>

<p>The most popular way to determine if a function was called with <code>new</code> in ECMAScript 5 is to use <code>instanceof</code>, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="k">instanceof</code> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>   <code class="c1">// using new</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"You must use new with Person."</code><code class="p">)</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">notAPerson</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>  <code class="c1">// throws error</code>
</pre></div>

</figure>

<p>Here, the <code>this</code> value is checked to see if it's an instance of the constructor, and if so, it continues as normal. If <code>this</code> isn't an instance of <code>Person</code>, then an error is thrown. This works because the <code>[[Construct]]</code> method creates a new instance of <code>Person</code> and assigns it to <code>this</code>. Unfortunately, this approach is not completely reliable because <code>this</code> can be an instance of <code>Person</code> without using <code>new</code>, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="k">instanceof</code> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>   <code class="c1">// using new</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"You must use new with Person."</code><code class="p">)</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">notAPerson</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">person</code><code class="p">,</code> <code class="s2">"Michael"</code><code class="p">);</code>    <code class="c1">// works!</code>
</pre></div>

</figure>

<p>The call to <code>Person.call()</code> passes the <code>person</code> variable as the first argument, which means <code>this</code> is set to <code>person</code> inside of the <code>Person</code> function. To the function, there's no way to distinguish this from being called with <code>new</code>.</p>

<p>To solve this problem, ECMAScript 6 introduces the <code>new.target</code> <em>metaproperty</em>. When a function's <code>[[Construct]]</code> method is called, <code>new.target</code> is filled with the target of the <code>new</code> operator, which is typically the constructor of the newly created object instance that will become <code>this</code> inside the function body. If <code>[[Call]]</code> is executed, then <code>new.target</code> is <code>undefined</code>. That means you can now safely detect if a function is called with <code>new</code> by checking that <code>new.target</code> is defined:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">!==</code> <code class="s2">"undefined"</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>   <code class="c1">// using new</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"You must use new with Person."</code><code class="p">)</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">notAPerson</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">person</code><code class="p">,</code> <code class="s2">"Michael"</code><code class="p">);</code>    <code class="c1">// error!</code>
</pre></div>

</figure>

<p>By using <code>new.target</code> instead of <code>this instanceof Person</code>, the <code>Person</code> constructor is now correctly throwing an error when used without <code>new</code>.</p>

<p>You can also check that <code>new.target</code> was called with a specific constructor, for instance:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">===</code> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>   <code class="c1">// using new</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"You must use new with Person."</code><code class="p">)</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">AnotherPerson</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">anotherPerson</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AnotherPerson</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>  <code class="c1">// error!</code>
</pre></div>

</figure>

<p>In this example, <code>new.target</code> must be <code>Person</code> in order to work correctly. When <code>new AnotherPerson("Nicholas")</code> is called, <code>new.target</code> is set to <code>AnotherPerson</code>, so the subsequent call to <code>Person.call(this, name)</code> will throw an error even though <code>new.target</code> is defined.</p>

<aside class="warning blurb">
    <p>Using <code>new.target</code> outside of a function is a syntax error.</p>

</aside>

<h3 id="leanpub-auto-block-level-functions">Block-Level Functions</h3>

<p>In ECMAScript 3 and earlier, a function declaration occurring inside of a block (a <em>block-level function</em>) was technically a syntax error, but many browsers still supported it. Unfortunately, each browser that allowed the syntax behaved in a slightly different way, so it is considered a best practice to avoid function declarations inside of blocks (the best alternative is to use a function expression).</p>

<p>In an attempt to reign in this incompatible behavior, ECMAScript 5 strict mode introduced an error whenever a function declaration was used inside of a block. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="s2">"use strict"</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>

    <code class="c1">// Throws a syntax error in ES5, not so in ES6</code>
    <code class="kd">function</code> <code class="nx">doSomething</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In ECMAScript 5, this code throws a syntax error. In ECMAScript 6, the <code>doSomething()</code> function is considered a block-level declaration and can be accessed and called within the same block in which it was defined. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="s2">"use strict"</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>        <code class="c1">// "function"</code>

    <code class="kd">function</code> <code class="nx">doSomething</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="nx">doSomething</code><code class="p">();</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>            <code class="c1">// "undefined"</code>
</pre></div>

</figure>

<p>Block level functions are hoisted to the top of the block in which they are defined, so <code>typeof doSomething</code> returns <code>"function"</code> even though it appears before the function declaration in the code. Once the <code>if</code> block is finished executing, <code>doSomething()</code> no longer exists.</p>

<p>Block level functions are a similar to <code>let</code> function expressions in that the function definition is removed once execution flows out of the block in which it's defined. The key difference is that block level functions are hoisted to the top of the containing block while <code>let</code> function expressions are not hoisted. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="s2">"use strict"</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>        <code class="c1">// throws error</code>

    <code class="kd">let</code> <code class="nx">doSomething</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="nx">doSomething</code><code class="p">();</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>
</pre></div>

</figure>

<p>Here, code execution stops when <code>typeof doSomething</code> is executed because the <code>let</code> statement hasn't been executed yet.</p>

<p>Whether you want to use block level functions or <code>let</code> expressions depends on whether or not you want the hoisting behavior.</p>

<p>ECMAScript 6 also allows block-level functions in nonstrict mode, but the behavior is slightly different. Instead of hoisting these declarations to the top of the block, they are hoisted all the way to the containing function or global environment. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// ECMAScript 6 behavior</code>
<code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>        <code class="c1">// "function"</code>

    <code class="kd">function</code> <code class="nx">doSomething</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>

    <code class="nx">doSomething</code><code class="p">();</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">doSomething</code><code class="p">);</code>            <code class="c1">// "function"</code>
</pre></div>

</figure>

<p>In this example, <code>doSomething()</code> is hoisted into the global scope so that it still exists outside of the <code>if</code> block. ECMAScript 6 standardized this behavior to remove the incompatible browser behaviors that previously existed. ECMAScript 6 runtimes will all behave in the same way.</p>

<h3 id="leanpub-auto-arrow-functions">Arrow Functions</h3>

<p>One of the most interesting new parts of ECMAScript 6 are arrow functions. Arrow functions are, as the name suggests, functions defined with a new syntax that uses an "arrow" (<code>=&gt;</code>). However, arrow functions behave differently than traditional JavaScript functions in a number of important ways:</p>

<ul>
  <li>
<strong>Lexical <code>this</code> binding</strong> - The value of <code>this</code> inside of the function is determined by where the arrow function is defined not where it is used.</li>
  <li>
<strong>Not <code>new</code>able</strong> - Arrow functions do not have a <code>[[Construct]]</code> method and therefore cannot be used as constructors. Arrow functions throw an error when used with <code>new</code>.</li>
  <li>
<strong>Can't change <code>this</code></strong> - The value of <code>this</code> inside of the function can't be changed, it remains the same value throughout the entire lifecycle of the function.</li>
  <li>
<strong>No <code>arguments</code> object</strong> - You can't access arguments through the <code>arguments</code> object, you must use named arguments or other ES6 features such as rest arguments.</li>
</ul>

<p>There are a few reasons why these differences exist. First and foremost, <code>this</code> binding is a common source of error in JavaScript. It's very easy to lose track of the <code>this</code> value inside of a function, which can result in unintended consequences. Second, by limiting arrow functions to simply executing code with a single <code>this</code> value, JavaScript engines can more easily optimize these operations (as opposed to regular functions, which might be used as a constructor or otherwise modified).</p>

<aside class="information blurb">
    <p>Arrow functions also have a <code>name</code> property that follows the same rule as other functions.</p>

</aside>

<h3 id="leanpub-auto-syntax">Syntax</h3>

<p>The syntax for arrow functions comes in many flavors depending upon what you are trying to accomplish. All variations begin with function arguments, followed by the arrow, followed by the body of the function. Both the arguments and the body can take different forms depending on usage. For example, the following arrow function takes a single argument and simply returns it:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">reflect</code> <code class="o">=</code> <code class="nx">value</code> <code class="o">=&gt;</code> <code class="nx">value</code><code class="p">;</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">reflect</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>When there is only one argument for an arrow function, that one argument can be used directly without any further syntax. The arrow comes next and the expression to the right of the arrow is evaluated and returned. Even though there is no explicit <code>return</code> statement, this arrow function will return the first argument that is passed in.</p>

<p>If you are passing in more than one argument, then you must include parentheses around those arguments. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The <code>sum()</code> function simply adds two arguments together and returns the result. The only difference is that the arguments are enclosed in parentheses with a comma separating them (same as traditional functions).</p>

<p>If there are no arguments to the function, then you must include an empty set of parentheses:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">getName</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"Nicholas"</code><code class="p">;</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>When you want to provide a more traditional function body, perhaps consisting of more than one expression, then you need to wrap the function body in braces and explicitly define a return value, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>You can more or less treat the inside of the curly braces as the same as in a traditional function with the exception that <code>arguments</code> is not available.</p>

<p>If you want to create a function that does nothing, then you need to include curly braces:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">doNothing</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{};</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">doNothing</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{};</code>
</pre></div>

</figure>

<p>Because curly braces are used to denote the function's body, an arrow function that wants to return an object literal outside of a function body must wrap the literal in parentheses. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">getTempItem</code> <code class="o">=</code> <code class="nx">id</code> <code class="o">=&gt;</code> <code class="p">({</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Temp"</code> <code class="p">});</code>

<code class="c1">// effectively equivalent to:</code>

<code class="kd">var</code> <code class="nx">getTempItem</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">id</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">id</code><code class="o">:</code> <code class="nx">id</code><code class="p">,</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"Temp"</code>
    <code class="p">};</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Wrapping the object literal in parentheses signals that the braces are an object literal instead of the function body.</p>

<h4 id="leanpub-auto-immediately-invoked-function-expressions-iifes">Immediately-Invoked Function Expressions (IIFEs)</h4>

<p>A popular use of functions in JavaScript is immediately-invoked function expressions (IIFEs). IIFEs allow you to define an anonymous function and call it immediately without saving a reference. This pattern comes in handy when you want to create a scope that is shielded from the rest of a program. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">};</code>

<code class="p">}(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code>      <code class="c1">// "Nicholas"</code>
</pre></div>

</figure>

<p>In this code, the IIFE is used to create an object with a <code>getName()</code> method. The method uses the <code>name</code> argument as the return value, effectively making <code>name</code> a private member of the returned object.</p>

<p>You can accomplish the same thing using arrow functions so long as you wrap the arrow function in parentheses:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">((</code><code class="nx">name</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">};</code>

<code class="p">})(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code>      <code class="c1">// "Nicholas"</code>
</pre></div>

</figure>

<p>Note that the location of the parentheses is around just the arrow function definition, and does not include <code>("Nicholas")</code>. This is different from a formal function, where the parentheses can be placed outside of the passed-in parameters as well as just as around the function definition.</p>

<h4 id="leanpub-auto-lexical-this-binding">Lexical this Binding</h4>

<p>One of the most common areas of error in JavaScript is the binding of <code>this</code> inside of functions. Since the value of <code>this</code> can change inside of a single function depending on the context in which it's called, it's possible to mistakenly affect one object when you meant to affect another. Consider the following example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">PageHandler</code> <code class="o">=</code> <code class="p">{</code>

    <code class="nx">id</code><code class="o">:</code> <code class="s2">"123456"</code><code class="p">,</code>

    <code class="nx">init</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nb">document</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">doSomething</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">);</code>     <code class="c1">// error</code>
        <code class="p">},</code> <code class="kc">false</code><code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">doSomething</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Handling "</code> <code class="o">+</code> <code class="nx">type</code>  <code class="o">+</code> <code class="s2">" for "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>In this code, the object <code>PageHandler</code> is designed to handle interactions on the page. The <code>init()</code> method is called to set up the interactions and that method in turn assigns an event handler to call <code>this.doSomething()</code>. However, this code doesn't work as intended. The call to <code>this.doSomething()</code> is broken because <code>this</code> is a reference to the element object (in this case <code>document</code>) that was the target of the event, instead of being bound to <code>PageHandler</code>. If you tried to run this code, you will get an error when the event handler fires because <code>this.doSomething()</code> doesn't exist on the target <code>document</code> object.</p>

<p>You can bind the value of <code>this</code> to <code>PageHandler</code> explicitly using the <code>bind()</code> method on the function:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">PageHandler</code> <code class="o">=</code> <code class="p">{</code>

    <code class="nx">id</code><code class="o">:</code> <code class="s2">"123456"</code><code class="p">,</code>

    <code class="nx">init</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nb">document</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">doSomething</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">);</code>     <code class="c1">// no error</code>
        <code class="p">}).</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">),</code> <code class="kc">false</code><code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">doSomething</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Handling "</code> <code class="o">+</code> <code class="nx">type</code>  <code class="o">+</code> <code class="s2">" for "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Now the code works as expected, but may look a little bit strange. By calling <code>bind(this)</code>, you're actually creating a new function whose <code>this</code> is bound to the current <code>this</code>, which is <code>PageHandler</code>. The code now works as you would expect even though you had to create an extra function to get the job done.</p>

<p>Arrow functions have implicit <code>this</code> binding, which means that the value of <code>this</code> inside of an arrow function is always the same as the value of <code>this</code> in the scope in which the arrow function was defined. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">PageHandler</code> <code class="o">=</code> <code class="p">{</code>

    <code class="nx">id</code><code class="o">:</code> <code class="s2">"123456"</code><code class="p">,</code>

    <code class="nx">init</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nb">document</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code>
                <code class="nx">event</code> <code class="o">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">doSomething</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">),</code> <code class="kc">false</code><code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">doSomething</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Handling "</code> <code class="o">+</code> <code class="nx">type</code>  <code class="o">+</code> <code class="s2">" for "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The event handler in this example is an arrow function that calls <code>this.doSomething()</code>. The value of <code>this</code> is the same as it is within <code>init()</code>, so this version of the example works similarly to the one using <code>bind()</code>. Even though the <code>doSomething()</code> method doesn't return a value, it is still the only statement executed necessary for the function body and so there is no need to include braces.</p>

<p>Arrow functions are designed to be "throwaway" functions and so cannot be used to define new types. This is evident by the missing <code>prototype</code> property that regular functions have. If you try to use the <code>new</code> operator with an arrow function, you'll get an error:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">MyType</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{},</code>
    <code class="nx">object</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyType</code><code class="p">();</code>  <code class="c1">// error - you can't use arrow functions with 'ne\</code>
<code class="nx">w</code><code class="err">'</code>
</pre></div>

</figure>

<p>Also, since the <code>this</code> value is statically bound to the arrow function, you cannot change the value of <code>this</code> using <code>call()</code>, <code>apply()</code>, or <code>bind()</code>.</p>

<p>The concise syntax for arrow functions makes them ideal for use with array processing. For example, if you want to sort an array using a custom comparator, you typically write something like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">values</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>That's a lot of syntax for a very simple procedure. Compare that to the more terse arrow function version:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">values</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">);</code>
</pre></div>

</figure>

<p>The array methods that accept callback functions such as <code>sort()</code>, <code>map()</code>, and <code>reduce()</code> all can benefit from simpler syntax with arrow functions to change what would appear to be more complex processes into simpler code.</p>

<p>Generally speaking, arrow functions are designed to be used in places where anonymous functions have traditionally been used. They are not really designed to be kept around for long periods of time, hence the inability to use arrow functions as constructors. Arrow functions are best used for callbacks that are passed into other functions, as seen in the examples in this section.</p>

<h4 id="leanpub-auto-lexical-arguments-binding">Lexical arguments Binding</h4>

<p>Even though arrow functions don't have their own <code>arguments</code> object, it's possible for them to access the <code>arguments</code> object from a containing function. That <code>arguments</code> object is then available no matter where the arrow function is executed later on. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">createArrowFunctionReturningFirstArg</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">arrowFunction</code> <code class="o">=</code> <code class="nx">createArrowFunctionReturningFirstArg</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">arrowFunction</code><code class="p">());</code>       <code class="c1">// 5</code>
</pre></div>

</figure>

<p>Inside of <code>createArrowFunctionReturningFirstArg()</code>, <code>arguments[0]</code> is referenced by the created arrow function. That reference contains the first argument passed to <code>createArrowFunctionReturningFirstArg()</code>. When the arrow function is later executed, it returns <code>5</code>, which was the first argument passed in to <code>createArrowFunctionReturningFirstArg()</code>. Even though the arrow function is no longer in the scope of the function that created it, <code>arguments</code> remains accessible as a lexical binding.</p>

<h4 id="leanpub-auto-identifying-arrow-functions">Identifying Arrow Functions</h4>

<p>Despite the different syntax, arrow functions are still functions and are identified as such:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">comparator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">comparator</code><code class="p">);</code>                 <code class="c1">// "function"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">comparator</code> <code class="k">instanceof</code> <code class="nb">Function</code><code class="p">);</code>    <code class="c1">// true</code>
</pre></div>

</figure>

<p>Both <code>typeof</code> and <code>instanceof</code> behave the same with arrow functions as they do with other functions.</p>

<p>Also like other functions, you can still use <code>call()</code>, <code>apply()</code>, and <code>bind()</code>, although the <code>this</code>-binding of the function will not be affected. Here are some examples:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>      <code class="c1">// 3</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]));</code>   <code class="c1">// 3</code>

<code class="kd">var</code> <code class="nx">boundSum</code> <code class="o">=</code> <code class="nx">sum</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">boundSum</code><code class="p">());</code>                <code class="c1">// 3</code>
</pre></div>

</figure>

<p>In this example, the <code>sum()</code> function is called using <code>call()</code> and <code>apply()</code> to pass arguments as you would with any function. The <code>bind()</code> method is used to create <code>boundSum()</code>, which has its two arguments bound to <code>1</code> and <code>2</code> so that they don't need to be passed directly.</p>

<p>Arrow functions are appropriate to use anywhere you're currently using an anonymous function expression, such as with callbacks.</p>

<h3 id="leanpub-auto-summary-3">Summary</h3>

<p>Functions haven't undergone a huge change in ECMAScript 6, but rather, a series of incremental changes that make them easier to work with.</p>

<p>Default function parameters allow you to easily specify what value to use when a particular argument isn't passed. Prior to ECMAScript 6, this would require some extra code inside of the function to both check for the presence of arguments and assign a different value.</p>

<p>Rest parameters allow you to specify an array into which all remaining parameters should be placed. Using a real array and letting you indicate which parameters to include makes rest parameters a much more flexible solution than <code>arguments</code>.</p>

<p>Destructured parameters use the destructuring syntax to make options objects more transparent when used as function parameters. The actual data you're interested in can be listed out along with other named parameters.</p>

<p>The spread operator is a companion to rest parameters, allowing you to destructure an array into separate parameters when calling a function. Prior to ECMAScript 6, the only ways to pass individual parameters that were contained in an array were either manually specifying each parameter or using <code>apply()</code>. With the spread operator, you can easily pass an array to any function without worrying about the <code>this</code> binding of the function.</p>

<p>The addition of the <code>name</code> property helps to more easily identify functions for debugging and evaluation purposes. Additionally, ECMAScript 6 formally defines the behavior of block-level functions so they are no longer a syntax error in strict mode.</p>

<p>The behavior of a function has been defined by <code>[[Call]]</code>, normal function execution, and <code>[[Construct]]</code>, when a function is called with <code>new</code>. The <code>new.target</code> metaproperty allows you to determine if a function was called using <code>new</code> or not.</p>

<p>The biggest change to functions in ECMAScript 6 was the addition of arrow functions. Arrow functions are designed to be used in places where anonymous function expressions have traditionally been used. Arrow functions have a more concise syntax, lexical <code>this</code> binding, and no <code>arguments</code> object. Additionally, arrow functions can't change their <code>this</code> binding and so can't be used as constructors.</p>

<h2 id="leanpub-auto-objects">Objects</h2>

<p>A lot of ECMAScript 6 focused on improving the utility of objects. The focus makes sense given that nearly every value in JavaScript is represented by some type of object. Additionally, the number of objects used in an average JavaScript program continues to increase, meaning that developers are writing more objects all the time. With more objects comes the necessity to use them more effectively.</p>

<p>ECMAScript 6 improves objects in a number of ways, from simple syntax to new ways of manipulating and interacting with objects.</p>

<h3 id="leanpub-auto-object-categories">Object Categories</h3>

<p>The ECMAScript 6 specification introduced some new terminology to help distinguish between categories of objects. JavaScript has long been littered with a mix of terminology used to describe objects found in the standard as opposed to those that are added by execution environments such as the browser. ECMAScript 6 takes the time to clearly define each category of object, and it's important to understand this terminology to have a good understanding of the language as a whole. The object categories are:</p>

<ul>
  <li>
<em>Ordinary objects</em> are objects that have all of the default internal behaviors for objects in JavaScript.</li>
  <li>
<em>Exotic objects</em> are objects whose internal behavior is different than the default in some way.</li>
  <li>
<em>Standard objects</em> are objects defined by ECMAScript 6, such as <code>Array</code>, <code>Date</code>, etc. Standard objects may be ordinary or exotic.</li>
  <li>
<em>Built-in objects</em> are objects that are present in a JavaScript execution environment when a script begins to execute. All standard objects are built-in objects.</li>
</ul>

<p>These terms are used throughout the book to explain the various objects defined by ECMAScript 6.</p>

<h3 id="leanpub-auto-object-literal-extensions">Object Literal Extensions</h3>

<p>One of the most popular patterns in JavaScript is the object literal. It's the syntax upon which JSON is built and can be seen in nearly every JavaScript file on the Internet. The reason for the popularity is clear: a succinct syntax for creating objects that otherwise would take several lines of code to accomplish. ECMAScript 6 recognized the popularity of the object literal and extends the syntax in several ways to make object literals more powerful and even more succinct.</p>

<h4 id="leanpub-auto-property-initializer-shorthand">Property Initializer Shorthand</h4>

<p>In ECMAScript 5 and earlier, object literals were simply collections of name-value pairs. That meant there could be some duplication when property values are being initialized. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">createPerson</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">name</code><code class="o">:</code> <code class="nx">name</code><code class="p">,</code>
        <code class="nx">age</code><code class="o">:</code> <code class="nx">age</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The <code>createPerson()</code> function creates an object whose property names are the same as the function parameter names. The result is what appears to be duplication of <code>name</code> and <code>age</code> even though each represents a different aspect of the process.</p>

<p>In ECMAScript 6, you can eliminate the duplication that exists around property names and local variables by using the property initializer shorthand. When the property name is going to be the same as the local variable name, you can simply include the name without a colon and value. For example, <code>createPerson()</code> can be rewritten as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">createPerson</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">name</code><code class="p">,</code>
        <code class="nx">age</code>
    <code class="p">};</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>When a property in an object literal only has a name and no value, the JavaScript engine looks into the surrounding scope for a variable of the same name. If found, that value is assigned to the same name on the object literal. So in this example, the object literal property <code>name</code> is assigned the value of the local variable <code>name</code>.</p>

<p>The purpose of this extension is to make object literal initialization even more succinct than it already was. Assigning a property with the same name as a local variable is a very common pattern in JavaScript and so this extension is a welcome addition.</p>

<h4 id="leanpub-auto-method-initializer-shorthand">Method Initializer Shorthand</h4>

<p>ECMAScript 6 also improves syntax for assigning methods to object literals. In ECMAScript 5 and earlier, you must specify a name and then the full function definition to add a method to an object. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="nx">sayName</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>In ECMAScript 6, the syntax is made more succinct by eliminating the colon and the <code>function</code> keyword. You can then rewrite the previous example as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This shorthand syntax, also called <em>concise method</em> syntax, creates a method on the <code>person</code> object just as the previous example did. There is no difference aside from saving you some keystrokes, so <code>sayName()</code> is assigned an anonymous function expression and has all of the same characteristics as the function defined in the previous example.</p>

<aside class="information blurb">
    <p>The <code>name</code> property of a method created using this shorthand is the name used before the parentheses. In the previous example, the <code>name</code> property for <code>person.sayName()</code> is <code>"sayName"</code>.</p>

</aside>

<h4 id="leanpub-auto-computed-property-names">Computed Property Names</h4>

<p>JavaScript objects have long had computed property names through the use of square brackets instead of dot notation. The square brackets allow you to specify property names using variables and string literals that may contain characters that would be a syntax error if used in an identifier. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{},</code>
    <code class="nx">lastName</code> <code class="o">=</code> <code class="s2">"last name"</code><code class="p">;</code>

<code class="nx">person</code><code class="p">[</code><code class="s2">"first name"</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="nx">person</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Zakas"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="s2">"first name"</code><code class="p">]);</code>      <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]);</code>          <code class="c1">// "Zakas"</code>
</pre></div>

</figure>

<p>Both of the property names in this example have a space, making it impossible to reference those names using dot notation. However, bracket notation allows any string value to be used as a property name.</p>

<p>In ECMAScript 5, you could use string literals as property names in object literals, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="s2">"first name"</code><code class="o">:</code> <code class="s2">"Nicholas"</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="s2">"first name"</code><code class="p">]);</code>      <code class="c1">// "Nicholas"</code>
</pre></div>

</figure>

<p>If you could provide the string literal inside of the object literal property definition then you were all set. If, however, the property name was contained in a variable or had to be calculated, then there was no way to define that property using an object literal.</p>

<p>ECMAScript 6 adds computed property names to object literal syntax by using the same square bracket notation that has been used to reference computed property names in object instances. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">lastName</code> <code class="o">=</code> <code class="s2">"last name"</code><code class="p">;</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="s2">"first name"</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="p">[</code><code class="nx">lastName</code><code class="p">]</code><code class="o">:</code> <code class="s2">"Zakas"</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="s2">"first name"</code><code class="p">]);</code>      <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]);</code>          <code class="c1">// "Zakas"</code>
</pre></div>

</figure>

<p>The square brackets inside of the object literal indicate that the property name is computed, so its contents are evaluated as a string. That means you can also include expressions such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">suffix</code> <code class="o">=</code> <code class="s2">" name"</code><code class="p">;</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="s2">"first"</code> <code class="o">+</code> <code class="nx">suffix</code><code class="p">]</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="p">[</code><code class="s2">"last"</code> <code class="o">+</code> <code class="nx">suffix</code><code class="p">]</code><code class="o">:</code> <code class="s2">"Zakas"</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="s2">"first name"</code><code class="p">]);</code>      <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="s2">"last name"</code><code class="p">]);</code>       <code class="c1">// "Zakas"</code>
</pre></div>

</figure>

<p>Anything you would put inside of square brackets while using bracket notation on object instances will also work for computed property names inside of object literals.</p>

<h3 id="leanpub-auto-objectis">Object.is()</h3>

<p>When you want to compare two values, you're probably used to using either the equals operator (<code>==</code>) or the identically equals operator (<code>===</code>). Many prefer to use the latter to avoid type coercion during the comparison. However, even the identically equals operator isn't entirely accurate. For example, the values +0 and -0 are considered equal by <code>===</code> even though they are represented differently in the JavaScript engine. Also <code>NaN === NaN</code> returns <code>false</code>, which necessitates using <code>isNaN()</code> to detect <code>NaN</code> properly.</p>

<p>ECMAScript 6 introduces <code>Object.is()</code> to make up for the remaining quirks of the identically equals operator. This method accepts two arguments and returns <code>true</code> if the values are equivalent. Two values are considered equivalent when they are of the same type and have the same value. In many cases, <code>Object.is()</code> works the same as <code>===</code>. The only differences are that +0 and -0 are considered not equivalent and <code>NaN</code> is considered equivalent to <code>NaN</code>. Here are some examples:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="o">+</code><code class="mi">0</code> <code class="o">==</code> <code class="o">-</code><code class="mi">0</code><code class="p">);</code>              <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="o">+</code><code class="mi">0</code> <code class="o">===</code> <code class="o">-</code><code class="mi">0</code><code class="p">);</code>             <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code><code class="o">+</code><code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">0</code><code class="p">));</code>     <code class="c1">// false</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kc">NaN</code> <code class="o">==</code> <code class="kc">NaN</code><code class="p">);</code>            <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kc">NaN</code> <code class="o">===</code> <code class="kc">NaN</code><code class="p">);</code>           <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code><code class="kc">NaN</code><code class="p">,</code> <code class="kc">NaN</code><code class="p">));</code>   <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code> <code class="o">==</code> <code class="mi">5</code><code class="p">);</code>                <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code> <code class="o">==</code> <code class="s2">"5"</code><code class="p">);</code>              <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code> <code class="o">===</code> <code class="mi">5</code><code class="p">);</code>               <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code> <code class="o">===</code> <code class="s2">"5"</code><code class="p">);</code>             <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code>       <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="s2">"5"</code><code class="p">));</code>     <code class="c1">// false</code>
</pre></div>

</figure>

<p>In most cases you will probably still want to use <code>==</code> or <code>===</code> for comparing values, as special cases covered by <code>Object.is()</code> may not affect you directly.</p>

<h3 id="leanpub-auto-objectassign">Object.assign()</h3>

<p>One of the most popular patterns for object composition is <em>mixins</em>, in which one object receives properties and methods from another object. Many JavaScript libraries have a mixin method similar to this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">mixin</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">supplier</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">receiver</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">supplier</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
    <code class="p">});</code>

    <code class="k">return</code> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The <code>mixin()</code> function iterates over the own properties of <code>supplier</code> and copies them onto <code>receiver</code>. This allows the <code>receiver</code> to gain new behaviors without inheritance. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">EventTarget</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">}</code>
<code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="o">:</code> <code class="nx">EventTarget</code><code class="p">,</code>
    <code class="nx">emit</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">},</code>
    <code class="nx">on</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">}</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">myObject</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">mixin</code><code class="p">(</code><code class="nx">myObject</code><code class="p">,</code> <code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>

<code class="nx">myObject</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code><code class="s2">"somethingChanged"</code><code class="p">);</code>
</pre></div>

</figure>

<p>In this example, <code>myObject</code> receives behavior from <code>EventTarget.prototype</code>. This gives <code>myObject</code> the ability to publish events and let others subscribe to them using <code>emit()</code> and <code>on()</code>, respectively.</p>

<p>This pattern became popular enough that ECMAScript 6 added <code>Object.assign()</code>, which behaves the same way. The difference in name is to reflect the actual operation that occurs. Since the <code>mixin()</code> method uses the assignment operator (<code>=</code>), it cannot copy accessor properties to the receiver as accessor properties. The name <code>Object.assign()</code> was chosen to reflect this distinction.</p>

<aside class="information blurb">
    <p>Similar methods in various libraries may have other names. Some popular alternate names for the same basic functionality are <code>extend()</code> and <code>mix()</code>. There was also, briefly, an <code>Object.mixin()</code> method in ECMAScript 6 in addition to <code>Object.assign()</code>. The primary difference was that <code>Object.mixin()</code> also copied over accessor properties, but the method was removed due to concerns over the use of <code>super</code> (discussed later in this chapter).</p>

</aside>

<p>You can use <code>Object.assign()</code> anywhere the <code>mixin()</code> function would have been used:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">EventTarget</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">}</code>
<code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="o">:</code> <code class="nx">EventTarget</code><code class="p">,</code>
    <code class="nx">emit</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">},</code>
    <code class="nx">on</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/*...*/</code> <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">myObject</code> <code class="o">=</code> <code class="p">{}</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">myObject</code><code class="p">,</code> <code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>

<code class="nx">myObject</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code><code class="s2">"somethingChanged"</code><code class="p">);</code>
</pre></div>

</figure>

<p>The <code>Object.assign()</code> method accepts any number of suppliers, and the receiver receives the properties in the order in which the suppliers are specified. That means the second supplier might overwrite a value from the first supplier on the receiver. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">receiver</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"js"</code><code class="p">,</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"file.js"</code>
    <code class="p">},</code> <code class="p">{</code>
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"css"</code>
    <code class="p">}</code>
<code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">receiver</code><code class="p">.</code><code class="nx">type</code><code class="p">);</code>     <code class="c1">// "css"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">receiver</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>     <code class="c1">// "file.js"</code>
</pre></div>

</figure>

<p>The value of <code>receiver.type</code> is <code>"css"</code> because the second supplier overwrote the value of the first.</p>

<p>The <code>Object.assign()</code> method isn't a big addition to ECMAScript 6, but it does formalize a common function that is found in many JavaScript libraries.</p>

<aside>
  <h4 id="leanpub-auto-working-with-accessor-properties">Working with Accessor Properties</h4>

  <p>Keep in mind that you cannot create accessor properties on the receiver by using a supplier with accessor properties. Since <code>Object.assign()</code> uses the assignment operator, an accessor property on a supplier will become a data property on the receiver. For example:</p>

  <figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">receiver</code> <code class="o">=</code> <code class="p">{},</code>
    <code class="nx">supplier</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="s2">"file.js"</code>
        <code class="p">}</code>
    <code class="p">};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">supplier</code><code class="p">);</code>

<code class="kd">var</code> <code class="nx">descriptor</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="s2">"name"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>      <code class="c1">// "file.js"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">get</code><code class="p">);</code>        <code class="c1">// undefined</code>
</pre></div>

  </figure>

  <p>In this code, the <code>supplier</code> has an accessor property called <code>name</code>. After using <code>Object.assign()</code>, <code>receiver.name</code> exists as a data property with the value of <code>"file.js"</code>. That's because <code>supplier.name</code> returned "file.js" at the time <code>Object.assign()</code> was called.</p>

</aside>

<h3 id="leanpub-auto-duplicate-object-literal-properties">Duplicate Object Literal Properties</h3>

<p>ECMAScript 5 strict mode introduced a check for duplicate object literal properties that would throw an error if a duplicate was found. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Greg"</code>        <code class="c1">// syntax error in ES5 strict mode</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>When running in ECMAScript 5 strict mode, this example results in a syntax error on the second <code>name</code> property.</p>

<p>In ECMAScript 6, the duplicate property check has been removed. Both strict and nonstrict mode code no longer check for duplicate properties and instead take the last property of the given name as the actual value.</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Nicholas"</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Greg"</code>        <code class="c1">// not an error in ES6</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <code class="c1">// "Greg"</code>
</pre></div>

</figure>

<p>In this example, the value of <code>person.name</code> is <code>"Greg"</code> because that was the last value assigned to the property.</p>

<h3 id="leanpub-auto-changing-prototypes">Changing Prototypes</h3>

<p>Prototypes are the foundation of inheritance in JavaScript, and so ECMAScript 6 continues to make prototypes more powerful. ECMAScript 5 added the <code>Object.getPrototypeOf()</code> method for retrieving the prototype of any given object. ECMAScript 6 adds the reverse operation, <code>Object.setPrototypeOf()</code>, which allows you to change the prototype of any given object.</p>

<p>Normally, the prototype of an object is specified at the time of its creation, either by using a constructor or via <code>Object.create()</code>. Prior to ECMAScript 6, there was no standard way to change an object's prototype after it had already been created. In a way, <code>Object.setPrototypeOf()</code> changes one of the biggest assumptions about objects in JavaScript to this point, which is that an object's prototype remains unchanged after creation.</p>

<p>The <code>Object.setPrototypeOf()</code> method accepts two arguments, the object whose prototype should be changed and the object that should become the first argument's prototype. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">dog</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Woof"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">person</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Hello"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">person</code><code class="p">);</code>  <code class="c1">// true</code>

<code class="c1">// set prototype to dog</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">,</code> <code class="nx">dog</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Woof"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">dog</code><code class="p">);</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>This code defines two base objects: <code>person</code> and <code>dog</code>. Both objects have a method <code>getGreeting()</code> that returns a string. The object <code>friend</code> starts out inheriting from <code>person</code>, meaning that <code>getGreeting()</code> will output <code>"Hello"</code>. When the prototype is changed to be <code>dog</code> instead, <code>person.getGreeting()</code> outputs <code>"Woof"</code> because the original relationship to <code>person</code> is broken.</p>

<p>The actual value of an object's prototype is stored in an internal-only property called <code>[[Prototype]]</code>. The <code>Object.getPrototypeOf()</code> method returns the value stored in <code>[[Prototype]]</code> and <code>Object.setPrototypeOf()</code> changes the value stored in <code>[[Prototype]]</code>. However, these aren't the only ways to work with the value of <code>[[Prototype]]</code>.</p>

<p>Even before ECMAScript 5 was finished, several JavaScript engines already implemented a custom property called <code>__proto__</code> that could be used to both get and set the prototype of an object. Effectively, <code>__proto__</code> was an early precursor to both <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code>. It was unrealistic to expect all of the JavaScript engines to remove this property, so ECMAScript 6 formalized the behavior of <code>__proto__</code>.</p>

<p>In ECMAScript 6 engines, <code>Object.prototype.__proto__</code> is defined as an accessor property whose <code>get</code> method calls <code>Object.getPrototypeOf()</code> and whose <code>set</code> method calls <code>Object.setPrototypeOf()</code>. This means that there is no real difference between using <code>__proto__</code> and the other methods except that <code>__proto__</code> allows you to set the prototype of an object literal directly. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">dog</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Woof"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code>
<code class="p">};</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Hello"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">person</code><code class="p">);</code>  <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">===</code> <code class="nx">person</code><code class="p">);</code>               <code class="c1">// true</code>

<code class="c1">// set prototype to dog</code>
<code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">=</code> <code class="nx">dog</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Woof"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">===</code> <code class="nx">dog</code><code class="p">);</code>                  <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">dog</code><code class="p">);</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>This example is functionally equivalent to the previous. The call to <code>Object.create()</code> has been replaced with an object literal that assigns a value to <code>__proto__</code>. The only real difference between creating an object using <code>Object.create()</code> or an object literal with <code>__proto__</code> is that the former requires you to specify full property descriptors for any additional object properties while the latter is just a standard object literal.</p>

<aside class="warning blurb">
    <p>The <code>__proto__</code> property is special in a number of ways:</p>

  <ol class="numeric">
    <li>You can only specify it once in an object literal. If you specify two <code>__proto__</code> properties, then an error is thrown. This is the only object literal property that has this restriction.</li>
    <li>The computed form <code>["__proto__"]</code> acts like a regular property and does not set or return the current object's prototype. All rules related to object literal properties apply in this form, as opposed to the non-computed form, for which there are exceptions.</li>
  </ol>

  <p>It's best to be careful when using <code>__proto__</code> to make sure you don't get caught by these differences.</p>

</aside>

<h3 id="leanpub-auto-super-references">Super References</h3>

<p>As previously mentioned, prototypes are very important for JavaScript and a lot of work went into making them easier to use in ECMAScript 6. Among the improvements is the introduction of <code>super</code> references to more easily access functionality on an object's prototype. For example, if you want to override a method on an object instance such that it also calls the prototype method of the same name, you would need to do the following in ECMAScript 5:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">dog</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Woof"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// same as this.__proto__.getGreeting.call(this)</code>
        <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="nx">getGreeting</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">)</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Hello, hi!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">person</code><code class="p">);</code>  <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">===</code> <code class="nx">person</code><code class="p">);</code>               <code class="c1">// true</code>

<code class="c1">// set prototype to dog</code>
<code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">=</code> <code class="nx">dog</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                      <code class="c1">// "Woof, hi!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">===</code> <code class="nx">dog</code><code class="p">);</code>                  <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">friend</code><code class="p">)</code> <code class="o">===</code> <code class="nx">dog</code><code class="p">);</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>In this example, <code>getGreeting()</code> on <code>friend</code> calls the prototype method of the same name. The <code>Object.getPrototypeOf()</code> method is used to ensure the method is always getting the accurate prototype and then an additional string is appended. The additional <code>.call(this)</code> ensures that the <code>this</code> value inside the prototype method is set correctly.</p>

<p>Needing to remember to use <code>Object.getPrototypeOf()</code> and <code>.call(this)</code> to call a method on the prototype is a bit involved, so ECMAScript 6 introduced <code>super</code>.</p>

<p>At it's simplest, <code>super</code> acts as a pointer to the current object's prototype, effectively acting like <code>Object.getPrototypeOf(this)</code>. So you can simplify the <code>getGreeting()</code> method by rewriting it as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// in the previous example, this is the same as:</code>
        <code class="c1">// 1. Object.getPrototypeOf(this).getGreeting.call(this)</code>
        <code class="c1">// 2. this.__proto__.getGreeting.call(this)</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The call to <code>super.getGreeting()</code> is the same as <code>Object.getPrototypeOf(this).getGreeting.call(this)</code> or <code>this.__proto__.getGreeting.call(this)</code>. Similarly, you can call any method on an object's prototype by using a <code>super</code> reference.</p>

<p>Where <code>super</code> is really powerful is when you have multiple levels of inheritance. In such a case, <code>Object.getPrototypeOf()</code> no longer works in all circumstances. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="nx">getGreeting</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">)</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is friend</code>
<code class="kd">let</code> <code class="nx">relative</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">friend</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                  <code class="c1">// "Hello"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                  <code class="c1">// "Hello, hi!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">relative</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                <code class="c1">// error!</code>
</pre></div>

</figure>

<p>In this example, <code>Object.getPrototypeOf()</code> results in an error when <code>relative.getGreeting()</code> is called. That's because <code>this</code> is <code>relative</code>, and the prototype of <code>relative</code> is <code>friend</code>. When <code>friend.getGreeting().call()</code> is called with <code>relative</code> as <code>this</code>, the process starts over again and continues to call recursively until a stack overflow error occurs. This is a difficult problem to solve in ECMAScript 5, but with ECMAScript 6 and <code>super</code>, it's easy:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is friend</code>
<code class="kd">let</code> <code class="nx">relative</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">friend</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                  <code class="c1">// "Hello"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                  <code class="c1">// "Hello, hi!"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">relative</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>                <code class="c1">// "Hello, hi!"</code>
</pre></div>

</figure>

<p>Because <code>super</code> references are not dynamic, they always refer to the correct object. In this case, <code>super.getGreeting()</code> always refers to <code>person.getGreeting()</code>, regardless of how many other object inherit this method.</p>

<aside class="warning blurb">
    <p><code>super</code> references can only be used inside of concise methods and cannot be used in other functions or the global scope. Attempting to use <code>super</code> outside of concise methods results in a syntax error.</p>

</aside>

<h4 id="leanpub-auto-methods">Methods</h4>

<p>Prior to ECMAScript 6, there was no formal definition of a "method" - methods were just object properties that contained functions instead of data. ECMAScript 6 formally defines a method as a function that has an internal <code>[[HomeObject]]</code> property containing the object to which the method belongs. Consider the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>

    <code class="c1">// method</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// not a method</code>
<code class="kd">function</code> <code class="nx">shareGreeting</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Hi!"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example defines <code>person</code> with a single method called <code>getGreeting()</code>. The <code>[[HomeObject]]</code> for <code>getGreeting()</code> is <code>person</code> by virtue of assigning the function directly to an object. The <code>shareGreeting()</code> function, on the other hand, has no <code>[[HomeObject]]</code> specified because it wasn't assigned to an object when it was created. In most cases this difference isn't important, but it becomes very important when using <code>super</code>.</p>

<p>Any reference to <code>super</code> uses the <code>[[HomeObject]]</code> to determine what to do. The first step is to call <code>Object.getPrototypeOf()</code> on the <code>[[HomeObject]]</code> to retrieve a reference to the prototype. Then, the prototype is searched for a function with the same name as the executing function. Last, the <code>this</code>-binding is set and the method is called. If a function has no <code>[[HomeObject]]</code>, or has a different one than expected, then this process won't work. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="s2">"Hello"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">getGlobalGreeting</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", yo!"</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>  <code class="c1">// "Hello, hi!"</code>

<code class="nx">getGlobalGreeting</code><code class="p">();</code>                      <code class="c1">// throws error</code>
</pre></div>

</figure>

<p>Calling <code>friend.getGreeting()</code> returns a string while calling <code>getGlobalGreeting()</code> throws an error for improper use of <code>super</code>. Since the <code>getGlobalGreeting()</code> function has no <code>[[HomeObject]]</code>, it's not possible to perform a lookup. Interestingly, the situation doesn't change if <code>getGlobalGreeting()</code> is later assigned as a method on <code>friend</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// prototype is person</code>
<code class="kd">let</code> <code class="nx">friend</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">person</code><code class="p">,</code>
    <code class="nx">getGreeting</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", hi!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">getGlobalGreeting</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">()</code> <code class="o">+</code> <code class="s2">", yo!"</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">());</code>  <code class="c1">// "Hello, hi!"</code>

<code class="c1">// assign getGreeting to the global function</code>
<code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code> <code class="o">=</code> <code class="nx">getGlobalGreeting</code><code class="p">;</code>

<code class="nx">friend</code><code class="p">.</code><code class="nx">getGreeting</code><code class="p">();</code>               <code class="c1">// throws error</code>
</pre></div>

</figure>

<p>Here the global <code>getGlobalGreeting()</code> function is used to overwrite the previously-defined <code>getGreeting()</code> method on <code>friend</code>. Calling <code>friend.getGreeting()</code> at that point results in an error as well. The value of <code>[[HomeObject]]</code> is only set when the function is first created, so even assigning onto an object doesn't fix the problem.</p>

<h3 id="leanpub-auto-summary-4">Summary</h3>

<p>Objects are at the center of programming in JavaScript, and ECMAScript 6 has made some helpful changes to objects that both make them easier to deal with and more powerful.</p>

<p>ECMAScript 6 makes several changes to object literals. Shorthand property definitions make it easier to assign properties whose names are the same as in-scope variables. Computed property names allow you to specify non-literal values as property names, which is something you've already been able to do in other areas of the language. Shorthand methods let you type a lot fewer characters in order to define methods on object literals by completely omitting the colon and <code>function</code> keyword. A loosening of the strict mode check for duplicate object literal property names was introduced as well, meaning you can now have two properties with the same name in a single object literal without an error being thrown.</p>

<p>The <code>Object.assign()</code> method makes it easier to change multiple properties on a single object at once. This can be very useful if you use the mixin pattern. The <code>Object.is()</code> method performs strict equality on any value, effectively becoming a safer version of <code>===</code> when dealing with special JavaScript values.</p>

<p>It's now possible to modify an object's prototype after it's already created using <code>Object.setPrototypeOf()</code>. ECMAScript 6 also defines the behavior of the <code>__proto__</code> property, which is an accessor property whose getter calls <code>Object.getPrototypeOf()</code> and whose setter calls <code>Object.setPrototypeOf()</code>.</p>

<p>The <code>super</code> keyword can now be used to call methods on an object's prototype. It can be used either standalone as a method, such as <code>super()</code>, or as a reference to the prototype itself, such as <code>super.getGreeting()</code>. In both cases, the <code>this</code>-binding is setup automatically to work with the current value of <code>this</code>.</p>

<h2 id="leanpub-auto-symbols">Symbols</h2>

<aside class="warning blurb">
    <p>This chapter is a work-in-progress. As such, it may have more typos or content errors than others.</p>

</aside>

<p>ECMAScript 6 symbols began as a way to create private object members, a feature JavaScript developers have long wanted. The focus was around creating properties that were not identified by string names. Any property with a string name was easy picking to access regardless of the obscurity of the name. The initial "private names" feature aimed to create non-string property names. That way, normal techniques for detecting these private names wouldn't work.</p>

<p>The private names proposal eventually evolved into ECMAScript 6 symbols. While the implementation details remained the same (non-string values for property identifiers), TC-39 dropped the requirement that these properties be private. Instead, the properties would be categorized separately, being non-enumerable by default but still discoverable.</p>

<p>Symbols are actually a new kind of primitive value, joining strings, numbers, booleans, <code>null</code>, and <code>undefined</code>. They are unique among JavaScript primitives in that they do not have a literal form. The ECMAScript 6 standard uses a special notation to indicate symbols, prefixing the identifier with <code>@@</code>, such as <code>@@create</code>. This book uses this same convention for ease of understanding.</p>

<aside class="warning blurb">
    <p>Despite the notation, symbols do not exactly map to strings beginning with "@@". Don't try to use string values where symbols are required.</p>

</aside>

<h3 id="leanpub-auto-creating-symbols">Creating Symbols</h3>

<p>You can create a symbol by using the <code>Symbol</code> function, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nx">person</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]);</code>     <code class="c1">// "Nicholas"</code>
</pre></div>

</figure>

<p>In this example, the symbol <code>firstName</code> is created and used to assign a new property on <code>person</code>. That symbol must be used each time you want to access that same property. It's a good idea to name the symbol variable appropriately so you can easily tell what the symbol represents.</p>

<aside class="warning blurb">
    <p>Because symbols are primitive values, <code>new Symbol()</code> throws an error when called. It is possible to create an instance of <code>Symbol</code> via <code>new Object(yourSymbol)</code>, but it's unclear when this capability would be useful.</p>

</aside>

<p>The <code>Symbol</code> function accepts an optional argument that is the description of the symbol. The description itself cannot be used to access the property but is used for debugging purposes. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"first name"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nx">person</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"first name"</code> <code class="k">in</code> <code class="nx">person</code><code class="p">);</code>        <code class="c1">// false</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]);</code>             <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstName</code><code class="p">);</code>                     <code class="c1">// "Symbol(first name)"</code>
</pre></div>

</figure>

<p>A symbol's description is stored internally in a property called <code>[[Description]]</code>. This property is read whenever the symbol's <code>toString()</code> method is called either explicitly or implicitly (as in this example). It is not otherwise possible to access <code>[[Description]]</code> directly from code. It's recommended to always provide a description to make both reading and debugging code using symbols easier.</p>

<h3 id="leanpub-auto-identifying-symbols">Identifying Symbols</h3>

<p>Since symbols are primitive values, you can use the <code>typeof</code> operator to identify them. ECMAScript 6 extends <code>typeof</code> to return <code>"symbol"</code> when used on a symbol. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"test symbol"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">symbol</code><code class="p">);</code>         <code class="c1">// "symbol"</code>
</pre></div>

</figure>

<p>While there are other indirect ways of determining whether a variable is a symbol, <code>typeof</code> is the most accurate and preferred way of doing so.</p>

<h3 id="leanpub-auto-using-symbols">Using Symbols</h3>

<p>You can use symbols anywhere you would use a computed property name. You've already seen the use of bracket notation in the previous sections, but you can use symbols in computed object literal property names as well as with <code>Object.defineProperty()</code>, and <code>Object.defineProperties()</code>, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"first name"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">firstName</code><code class="p">]</code><code class="o">:</code> <code class="s2">"Nicholas"</code>
<code class="p">};</code>

<code class="c1">// make the property read only</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">person</code><code class="p">,</code> <code class="nx">firstName</code><code class="p">,</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code> <code class="p">});</code>

<code class="kd">var</code> <code class="nx">lastName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"last name"</code><code class="p">);</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperties</code><code class="p">(</code><code class="nx">person</code><code class="p">,</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">lastName</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="s2">"Zakas"</code><code class="p">,</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]);</code>     <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]);</code>      <code class="c1">// "Zakas"</code>
</pre></div>

</figure>

<p>With computed property names in object literals, symbols are very easy to work with.</p>

<h3 id="leanpub-auto-sharing-symbols">Sharing Symbols</h3>

<p>You may find that you want different parts of your code to use the same symbols. For example, suppose you have two different object types in your application that should use the same symbol property to represent a unique identifier. Keeping track of symbols across files or large codebases can be difficult and error-prone. That's why ECMAScript 6 provides a global symbol registry that you can access at any point in time.</p>

<p>When you want to create a symbol to be shared, use the <code>Symbol.for()</code> method instead of calling <code>Symbol()</code>. The <code>Symbol.for()</code> method accepts a single parameter, which is a string identifier for the symbol you want to create (this value is also used as the description). For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">uid</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">object</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nx">object</code><code class="p">[</code><code class="nx">uid</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"12345"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">[</code><code class="nx">uid</code><code class="p">]);</code>       <code class="c1">// "12345"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">uid</code><code class="p">);</code>               <code class="c1">// "Symbol(uid)"</code>
</pre></div>

</figure>

<p>The <code>Symbol.for()</code> method first searches the global symbol registry to see if a symbol with the key <code>"uid"</code> exists. If so, then it returns the already existing symbol. If no such symbol exists, then a new symbol is created and registered into the global symbol registry using the specified key. The new symbol is then returned. That means subsequent calls to <code>Symbol.for()</code> using the same key will return the same symbol:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">uid</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">object</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">uid</code><code class="p">]</code><code class="o">:</code> <code class="s2">"12345"</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">[</code><code class="nx">uid</code><code class="p">]);</code>       <code class="c1">// "12345"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">uid</code><code class="p">);</code>               <code class="c1">// "Symbol(uid)"</code>

<code class="kd">var</code> <code class="nx">uid2</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">uid</code> <code class="o">===</code> <code class="nx">uid2</code><code class="p">);</code>      <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">[</code><code class="nx">uid2</code><code class="p">]);</code>      <code class="c1">// "12345"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">uid2</code><code class="p">);</code>              <code class="c1">// "Symbol(uid)"</code>
</pre></div>

</figure>

<p>In this example, <code>uid</code> and <code>uid2</code> contain the same symbol and so they can be used interchangeably. The first call to <code>Symbol.for()</code> creates the symbol and second call retrieves the symbol from the global symbol registry.</p>

<p>Another unique aspect of shared symbols is that you can retrieve the key associated with a symbol in the global symbol registry by using <code>Symbol.keyFor()</code>, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">uid</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code><code class="nx">uid</code><code class="p">));</code>    <code class="c1">// "uid"</code>

<code class="kd">var</code> <code class="nx">uid2</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code><code class="nx">uid2</code><code class="p">));</code>   <code class="c1">// "uid"</code>

<code class="kd">var</code> <code class="nx">uid3</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code><code class="nx">uid3</code><code class="p">));</code>   <code class="c1">// undefined</code>
</pre></div>

</figure>

<p>Notice that both <code>uid</code> and <code>uid2</code> return the key <code>"uid"</code>. The symbol <code>uid3</code> doesn't exist in the global symbol registry, so it has no key associated with it and <code>Symbol.keyFor()</code> returns <code>undefined</code>.</p>

<aside class="warning blurb">
    <p>The global symbol registry is a shared environment, just like the global scope. That means you can't make assumptions about what is or is not already present in that environment. You should use namespacing of symbol keys to reduce the likelihood of naming collisions when using third-party components. For example, jQuery might prefix all keys with <code>"jquery."</code>, such as <code>"jquery.element"</code>.</p>

</aside>

<h3 id="leanpub-auto-finding-object-symbols">Finding Object Symbols</h3>

<p>Similar to other properties on objects, you can access symbol properties using the <code>Object.getOwnPropertySymbols()</code> method. This method works exactly the same as <code>Object.getOwnPropertyNames()</code> except that the returned values are symbols rather than strings. Since symbols technically aren't property names, they are omitted from the result of <code>Object.getOwnPropertyNames()</code>.</p>

<p>The return value of <code>Object.getOwnPropertySymbols()</code> is an array of symbols that represent own properties. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">uid</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"uid"</code><code class="p">);</code>
<code class="kd">var</code> <code class="nx">object</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">uid</code><code class="p">]</code><code class="o">:</code> <code class="s2">"12345"</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">symbols</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertySymbols</code><code class="p">(</code><code class="nx">object</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">symbols</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>        <code class="c1">// 1</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">symbols</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>            <code class="c1">// "Symbol(uid)"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">[</code><code class="nx">symbols</code><code class="p">[</code><code class="mi">0</code><code class="p">]]);</code>    <code class="c1">// "12345"</code>
</pre></div>

</figure>

<p>In this code, <code>object</code> has a single symbol property. The array returned from <code>Object.getOwnPropertySymbols()</code> is an array containing just that symbol.</p>

<aside class="information blurb">
    <p>All objects start off with zero own symbol properties (although they do have some inherited symbol properties).</p>

</aside>

<h3 id="leanpub-auto-coercing-symbols-to-strings">Coercing Symbols to Strings</h3>

<p>TODO</p>

<p>String(symbol) works but symbol + "" throws</p>

<h3 id="leanpub-auto-well-known-symbols">Well-Known Symbols</h3>

<p>In addition to the symbols you defined, there are some predefined symbols as well (called <em>well-known</em> symbols in the specification). These symbols represent common behaviors in JavaScript that were previously considered internal-only operations. Each well-known symbol is represented by a property on <code>Symbol</code>, such as <code>Symbol.create</code> for the <code>@@create</code> symbol.</p>

<p>A central theme for both ECMAScript 5 and ECMAScript 6 was exposing and defining some of the "magic" parts of JavaScript - the parts that couldn't be emulated by a developer. ECMAScript 6 follows this tradition by exposing even more of the previously internal-only logic of the language. It does so primarily through the use of symbol prototype properties that define the basic behavior of certain objects.</p>

<aside class="information blurb">
    <p>Overwriting a method defined with a well-known symbol changes an ordinary object to an exotic object because this changes some internal default behavior.</p>

</aside>

<p>The well-known symbols are:</p>

<ul>
  <li>
<code>@@hasInstance</code> - a method used by <code>instanceof</code> to determine an object's inheritance.</li>
  <li>
<code>@@isConcatSpreadable</code> - a Boolean value indicating if use with <code>Array.prototype.concat()</code> should flatten the collection's elements.</li>
  <li>
<code>@@iterator</code> - a method that returns an iterator (see Chapter 7).</li>
  <li>
<code>@@match</code> - a method used by <code>String.prototype.match()</code> to compare strings.</li>
  <li>
<code>@@replace</code> - a method used by <code>String.prototype.replace()</code> to replace substrings.</li>
  <li>
<code>@@search</code> - a method used by <code>String.prototype.search()</code> to locate substrings.</li>
  <li>
<code>@@species</code> - the constructor from which derived objects are made.</li>
  <li>
<code>@@split</code> - a method used by <code>String.prototype.split()</code> to split up strings.</li>
  <li>
<code>@@toPrimitive</code> - a method that returns a primitive value representation of the object.</li>
  <li>
<code>@@toStringTag</code> - a string used by <code>Object.prototype.toString()</code> to create an object description.</li>
  <li>
<code>@@unscopeables</code> - an object whose properties are the names of object properties that should not be included in a <code>with</code> statement.</li>
</ul>

<p>Some of the well-known symbols are discussed below while others are discussed throughout the book to keep them in the correct context.</p>

<h4 id="leanpub-auto-tostringtag">@@toStringTag</h4>

<p>One of the most interesting problems in JavaScript has been the availability of multiple global execution environments. This occurs in web browsers when a page includes an iframe, as the page and the iframe each have their own execution environments. In most cases, this isn't a problem, as data can be passed back and forth between the environments with little cause for concern. The problem arises when trying to identify what type of an object you're dealing with.</p>

<p>The canonical example of this is passing an array from the iframe into the containing page or vice-versa. Now in a different execution environment, <code>instanceof Array</code> returns <code>false</code> because the array was created with a constructor from a different environment.</p>

<p>Developers soon found a good way to identify arrays. It was discovered that by calling the standard <code>toString()</code> method on the object, a predictable string was always returned. Thus, many JavaScript libraries began including a function that works similar to this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">isArray</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">===</code> <code class="s2">"[object Array]"</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isArray</code><code class="p">([]));</code>   <code class="c1">// true</code>
</pre></div>

</figure>

<p>This may look a bit roundabout, but in reality it was found to work quite well in all browsers. The <code>toString()</code> method on arrays isn't very useful for this purpose because it returns a string representation of the items it contains. The <code>toString()</code> method on <code>Object.prototype</code>, however, had this quirk where it included some internally-defined name in the result. By using this method on an object, you could retrieve what the JavaScript environment thought the data type was.</p>

<p>Developers quickly realized that since there was no way to change this behavior, it was possible to use the same approach to distinguish between native objects and those created by developers. The most important case of this was the ECMAScript 5 <code>JSON</code> object.</p>

<p>Prior to ECMAScript 5, many used Douglas Crockford's <code>json2.js</code>, which created a global <code>JSON</code> object. As browsers started to implement the <code>JSON</code> global object, it became necessary to tell whether the global <code>JSON</code> was provided by the JavaScript environment itself or through some other library. Using the same technique, many created functions like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">supportsNativeJSON</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">typeof</code> <code class="nx">JSON</code> <code class="o">!==</code> <code class="s2">"undefined"</code> <code class="o">&amp;&amp;</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">JSON</code><code class="p">)</code> <code class="o">===</code> <code class="s2">"[object JSON]"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Here, the same characteristic that allowed developers to identify arrays across iframe boundaries also provided a way to tell if <code>JSON</code> was the native one or not. A non-native <code>JSON</code> object would return <code>[object Object]</code> while the native version returned <code>[object JSON]</code>. From that point on, this approach became the de facto standard for identifying native objects.</p>

<p>ECMAScript 6 explains this behavior through the <code>@@toStringTag</code> symbol. This symbol represents a property on each object that defines what value should be produced when <code>Object.prototype.toString.call()</code> is called on it. So the value returned for arrays is explained by having the <code>@@toStringTag</code> property equal <code>"Array"</code>. Likewise, you can define that value for your own objects:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Person"</code><code class="p">;</code>

<code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>                         <code class="c1">// "[object Person]"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">me</code><code class="p">));</code>    <code class="c1">// "[object Person]"</code>
</pre></div>

</figure>

<p>In this example, a <code>@@toStringTag</code> property is defined on <code>Person.prototype</code> to provide the default behavior for creating a string representation. Since <code>Person.prototype</code> inherits <code>Object.prototype.toString()</code>, the value returned from <code>@@toStringTag</code> is also used when calling <code>me.toString()</code>. However, you can still define your own <code>toString()</code> that provides a different behavior without affecting the use of <code>Object.prototype.toString.call()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Person"</code><code class="p">;</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>                         <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">me</code><code class="p">));</code>    <code class="c1">// "[object Person]"</code>
</pre></div>

</figure>

<p>This code defines <code>Person.prototype.toString()</code> to return the value of the <code>name</code> property. Since <code>Person</code> instances no longer inherit <code>Object.prototype.toString()</code>, calling <code>me.toString()</code> exhibits a different behavior.</p>

<aside class="information blurb">
    <p>All objects inherit <code>@@toStringTag</code> from <code>Object.prototype</code> unless otherwise specified. This default property value is <code>"Object"</code>.</p>

</aside>

<p>There is no restriction on which values can be used for <code>@@toStringTag</code> on developer-defined objects. For example, there's nothing preventing you from using <code>"Array"</code> as the value of <code>@@toStringTag</code>, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Array"</code><code class="p">;</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>                         <code class="c1">// "Nicholas"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">me</code><code class="p">));</code>    <code class="c1">// "[object Array]"</code>
</pre></div>

</figure>

<p>Here, the result of calling <code>Object.prototype.toString()</code> is <code>"[object Array]"</code>, which is the same as you would get from an actual array. This highlights the fact that <code>Object.prototype.toString()</code> is no longer a completely reliable way of identifying an object's type.</p>

<p>It's possible to change the string tag for native objects by assigning to <code>@@toStringTag</code> on their prototype. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Magic"</code><code class="p">;</code>

<code class="kd">var</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">values</code><code class="p">));</code>    <code class="c1">// "[object Magic]"</code>
</pre></div>

</figure>

<p>Even though <code>@@toStringTag</code> is overwritten for arrays in this example, the call to <code>Object.prototype.toString()</code> results in <code>"[object Magic]"</code>. While it's recommended not to change built-in objects in this way, there's nothing in the language that forbids it.</p>

<h4 id="leanpub-auto-toprimitive">@@toPrimitive</h4>

<p>JavaScript frequently attempts to convert objects into primitive values implicitly when certain operations are applied. For instance, when you compare a string to an object using double equals (<code>==</code>), the object is converted into a primitive value before comparing. Exactly what value should be used was previously an internal operation that is exposed in ECMAScript 6 through the <code>@@toPrimitive</code> method.</p>

<p>The <code>@@toPrimitive</code> method is defined on the prototype of each standard type and prescribes the exact behavior. When a primitive conversion is needed, <code>@@toPrimitive</code> is called with a single argument, referred to as <code>hint</code> in the specification. The <code>hint</code> argument is <code>"default"</code>, specifying that the operation has no preference as to the type, <code>"string"</code>, indicating a string should be returned, or <code>"number"</code>, if a number is necessary to perform the operation. Most standard objects treat <code>"default"</code> as equivalent to <code>"number"</code> (except for <code>Date</code>, which treats <code>"default"</code> as <code>"string"</code>).</p>

<p>TODO</p>

<h4 id="leanpub-auto-isconcatspreadable">@@isConcatSpreadable</h4>

<p>TODO</p>

<h4 id="leanpub-auto-species">@@species</h4>

<p>TODO</p>

<h4 id="leanpub-auto-unscopeables">@@unscopeables</h4>

<p>TODO</p>

<p>Only applied to <code>with</code> statement object records - does not refer to other scopes.</p>

<h4 id="leanpub-auto-hasinstance">@@hasInstance</h4>

<p>TODO</p>

<h3 id="leanpub-auto-summary-5">Summary</h3>

<p>TODO</p>

<h2 id="leanpub-auto-iterators-and-generators">Iterators and Generators</h2>

<p>Iterators have been used in many programming languages as a way to more easily work with collections of data. In ECMAScript 6, JavaScript adds iterators as an important feature of the language. When coupled with new array methods and new types of collections (such as sets and maps), iterators become even more important for efficient processing of data.</p>

<h3 id="leanpub-auto-what-are-iterators">What are Iterators?</h3>

<p>Iterators are nothing more than objects with a certain interface. That interface consists of a method called <code>next()</code> that returns a result object. The result object has two properties, <code>value</code>, which is the next value, and <code>done</code>, which is a boolean value that's <code>true</code> when there are no more values to return. The iterator keeps an internal pointer to a location within a collection of values and, with each call to <code>next()</code>, returns the next appropriate value.</p>

<p>If you call <code>next()</code> after the last value has been returned, the method returns <code>done</code> as <code>true</code> and <code>value</code> contains the return value for the iterator. The <em>return value</em> is not considered part of the data set, but rather a final piece of related data or <code>undefined</code> if no such data exists. (This concept will become clearer in the generators section later in this chapter.)</p>

<p>With that understanding, it's fairly easy to create an iterator using ECMAScript 5, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">createIterator</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>

            <code class="kd">var</code> <code class="nx">done</code> <code class="o">=</code> <code class="p">(</code><code class="nx">i</code> <code class="o">&gt;=</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
            <code class="kd">var</code> <code class="nx">value</code> <code class="o">=</code> <code class="o">!</code><code class="nx">done</code> <code class="o">?</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">:</code> <code class="kc">undefined</code><code class="p">;</code>

            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">done</code><code class="o">:</code> <code class="nx">done</code><code class="p">,</code>
                <code class="nx">value</code><code class="o">:</code> <code class="nx">value</code>
            <code class="p">};</code>

        <code class="p">}</code>
    <code class="p">};</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 3, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>

<code class="c1">// for all further calls</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>The <code>createIterator()</code> function in this example returns an object with a <code>next()</code> method. Each time the method is called, the next value in the <code>items</code> array is returned as <code>value</code>. When <code>i</code> is 3, <code>items[i++]</code> returns <code>undefined</code> and <code>done</code> is <code>true</code>, which fulfills the special last case for iterators in ECMAScript 6.</p>

<p>ECMAScript 6 makes use of iterators in a number of places to make dealing with collections of data easier, so having a good basic understanding allows you to better understand the language as a whole.</p>

<h3 id="leanpub-auto-generators">Generators</h3>

<p>You might be thinking that iterators sound interesting but they look like a bunch of work. Indeed, writing iterators so that they adhere to the correct behavior is a bit difficult, which is why ECMAScript 6 provides generators. A <em>generator</em> is a special kind of function that returns an iterator. Generator functions are indicated by inserting a star character (<code>*</code>) after the <code>function</code> keyword (it doesn't matter if the star is directly next to <code>function</code> or if there's some whitespace between them). The <code>yield</code> keyword is used inside of generators to specify the values that the iterator should return when <code>next()</code> is called. So if you want to return three different values for each successive call to <code>next()</code>, you can do so as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// generator</code>
<code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// generators are called like regular functions but return an iterator</code>
<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="nx">of</code> <code class="nx">iterator</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="mi">1</code>
<code class="mi">2</code>
<code class="mi">3</code>
</pre></div>

</figure>

<p>In this example, the <code>createIterator()</code> function is a generator (as indicated by the <code>*</code> before the name) and it's called like any other function. The value returned is an object that adheres to the iterator pattern. Multiple <code>yield</code> statements inside the generator indicate the progression of values that should be returned when <code>next()</code> is called on the iterator. First, <code>next()</code> should return <code>1</code>, then <code>2</code>, and then <code>3</code> before the iterator is finished.</p>

<p>Perhaps the most interesting aspect of generator functions is that they stop execution after each <code>yield</code> statement, so <code>yield 1</code> executes and then the function doesn't execute anything else until the iterator's <code>next()</code> method is called. At that point, execution resumes with the next statement after <code>yield 1</code>, which in this case is <code>yield 2</code>. This ability to stop execution in the middle of a function is extremely powerful and lends to some interesting uses of generator functions (discussed later in this chapter).</p>

<p>The <code>yield</code> keyword can be used with any value or expression, so you can do interesting things like use <code>yield</code> inside of a <code>for</code> loop:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 3, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>

<code class="c1">// for all further calls</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this example, an array is used in a <code>for</code> loop, yielding each item as the loop progresses. Each time <code>yield</code> is encountered, the loop stops, and each time <code>next()</code> is called on <code>iterator</code>, the loop picks back up where it left off.</p>

<p>Generator functions are an important part of ECMAScript 6, and since they are just functions, they can be used in all the same places.</p>

<h4 id="leanpub-auto-generator-function-expressions">Generator Function Expressions</h4>

<p>Generators can be created using function expressions in the same way as using function declarations by including a star (<code>*</code>) character between the <code>function</code> keyword and the opening paren, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">createIterator</code> <code class="o">=</code> <code class="kd">function</code> <code class="o">*</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 3, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>

<code class="c1">// for all further calls</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this code, <code>createIterator()</code> is created by using a generator function expression. This behaves exactly the same as the example in the previous section.</p>

<h4 id="leanpub-auto-generator-object-methods">Generator Object Methods</h4>

<p>Because generators are just functions, they can be added to objects the same way as any other functions. For example, you can use an ECMAScript 5-style object literal with a function expression:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>

    <code class="nx">createIterator</code><code class="o">:</code> <code class="kd">function</code> <code class="o">*</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>
</pre></div>

</figure>

<p>You can also use the ECMAScript 6 method shorthand by prepending the method name with a star (<code>*</code>):</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>

    <code class="o">*</code><code class="nx">createIterator</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>
</pre></div>

</figure>

<p>This example is functionally equivalent to the previous one, the only difference is the syntax used.</p>

<h4 id="leanpub-auto-generator-class-methods">Generator Class Methods</h4>

<p>Similar to objects, you can add generator methods directly to classes using almost the same syntax:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{</code>

    <code class="o">*</code><code class="nx">createIterator</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">items</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="p">}</code>
    <code class="p">}</code>

<code class="p">}</code>

<code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyClass</code><code class="p">();</code>
<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">createIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code>
</pre></div>

</figure>

<p>The syntax is very similar to using shorthand object literal methods, as the asterisk needs to come before the method name.</p>

<h3 id="leanpub-auto-iterables-and-for-of">Iterables and for-of</h3>

<p>Closely related to the concept of an iterator is an iterable. An <em>iterable</em> is an object that has a default iterator specified using the <code>@@iterator</code> symbol. More specifically, <code>@@iterator</code> contains a function that returns an iterator for the given object. All of the collection objects, including arrays, sets, and maps, as well as strings, are iterables and so have a default iterator specified. Iterables are designed to be used with a new addition to ECMAScript: the <code>for-of</code> loop.</p>

<p>The <code>for-of</code> loop is similar to the other loops in ECMAScript except that it is designed to work with iterables. The loop itself calls <code>next()</code> behind the scenes and exits when the <code>done</code> property of the returned object is <code>true</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="nx">of</code> <code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="mi">1</code>
<code class="mi">2</code>
<code class="mi">3</code>
</pre></div>

</figure>

<p>The <code>for-of</code> loop in this example is first calling the <code>@@iterator</code> method to retrieve an iterator, and then calling <code>iterator.next()</code> and assigning the variable <code>i</code> to the value returned on the <code>value</code> property. So <code>i</code> is first 1, then 2, and finally 3. When <code>done</code> is <code>true</code>, the loop exits, so <code>i</code> is never assigned the value of <code>undefined</code>.</p>

<aside class="warning blurb">
    <p>The <code>for-of</code> statement will throw an error when used on, a non-iterable, <code>null</code>, or <code>undefined</code>.</p>

</aside>

<h4 id="leanpub-auto-accessing-the-default-iterator">Accessing the Default Iterator</h4>

<p>You can access the default iterator for an object using <code>Symbol.iterator</code>, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">values</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">values</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 3, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>This code gets the default iterator for <code>values</code> and uses that to iterate over the values in the array. Knowing that <code>Symbol.iterator</code> specifies the default iterator, it's possible to detect if an object is iterable by using the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">isIterable</code><code class="p">(</code><code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">typeof</code> <code class="nx">object</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"function"</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isIterable</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]));</code>     <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">));</code>       <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="k">new</code> <code class="nx">Map</code><code class="p">()));</code>     <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="k">new</code> <code class="nx">Set</code><code class="p">()));</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>The <code>isIterable()</code> function simply checks to see if a default iterator exists on the object and is a function. This is similar to the check that the <code>for-of</code> loop does before executing.</p>

<h4 id="leanpub-auto-creating-iterables">Creating Iterables</h4>

<p>Developer-defined objects are not iterable by default, but you can make them iterable by using the <code>@@iterator</code> symbol. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">collection</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">items</code><code class="o">:</code> <code class="p">[],</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="o">*</code><code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">values</code><code class="p">();</code>
    <code class="p">}</code>

<code class="p">};</code>

<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="nx">of</code> <code class="nx">collection</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// Output:</code>
<code class="c1">// 1</code>
<code class="c1">// 2</code>
<code class="c1">// 3</code>
</pre></div>

</figure>

<p>This code defines a default iterator for a variable called <code>collection</code> using object literal method shorthand and a computed property using <code>Symbol.iterator</code>. The generator then delegates to the <code>values()</code> iterator of <code>this.items</code> using the <code>yield *</code> notation, discussed later in this chapter. The <code>for-of</code> loop then uses the generator to create an iterator and execute the loop.</p>

<p>You can also define a default iterator using classes, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Collection</code> <code class="p">{</code>

    <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">items</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="p">}</code>

    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="o">*</code><code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">values</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">collection</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="p">();</code>
<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
<code class="nx">collection</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="nx">of</code> <code class="nx">collection</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// Output:</code>
<code class="c1">// 1</code>
<code class="c1">// 2</code>
<code class="c1">// 3</code>
</pre></div>

</figure>

<p>This example mirrors the previous one with the exception that a class is used instead of an object literal.</p>

<p>Default iterators can be added to any object by assigning a generator to <code>Symbol.iterator</code>. It doesn't matter if the property is an own or prototype property, as <code>for-of</code> normal prototype chain lookup applies.</p>

<h3 id="leanpub-auto-built-in-iterators">Built-in Iterators</h3>

<p>Another way that ECMAScript 6 makes using iterators easier is by making iterators available on many objects by default. You don't actually need to create your own iterators for many of the built-in types because the language has them already. You only need to create iterators when you find that the built-in ones don't serve your purpose.</p>

<h4 id="leanpub-auto-collection-iterators">Collection Iterators</h4>

<p>The ECMAScript 6 collection objects, arrays, maps, and sets, all have three default iterators to help you navigate data. You can retrieve an iterator for a collection by calling one of these methods:</p>

<ul>
  <li>
<code>entries()</code> - returns an iterator whose values are a key-value pair.</li>
  <li>
<code>values()</code> - returns an iterator whose values are the values of the collection.</li>
  <li>
<code>keys()</code> - returns an iterator whose values are the keys contained in the collection.</li>
</ul>

<p>The <code>entries()</code> iterator actually returns a two-item array where the first item is the key and the second item is the value. For arrays, the first item is the numeric index; for sets, the first item is also the value (since values double as keys in sets). Here are some examples:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">];</code>
<code class="kd">let</code> <code class="nx">tracking</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1234</code><code class="p">,</code> <code class="mi">5678</code><code class="p">,</code> <code class="mi">9012</code><code class="p">]);</code>
<code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>

<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"title"</code><code class="p">,</code> <code class="s2">"Understanding ECMAScript 6"</code><code class="p">);</code>
<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"format"</code><code class="p">,</code> <code class="s2">"ebook"</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">entry</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">tracking</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">entry</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">data</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">entry</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">[0, "red"]</code>
<code class="k">[1, "green"]</code>
<code class="k">[2, "blue"]</code>
<code class="k">[1234, 1234]</code>
<code class="k">[5678, 5678]</code>
<code class="k">[9012, 9012]</code>
<code class="k">["title", "Understanding ECMAScript 6"]</code>
<code class="k">["format", "ebook"]</code>
</pre></div>

</figure>

<p>The <code>values()</code> iterator simply returns the values as they are stored in the collection. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">];</code>
<code class="kd">let</code> <code class="nx">tracking</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1234</code><code class="p">,</code> <code class="mi">5678</code><code class="p">,</code> <code class="mi">9012</code><code class="p">]);</code>
<code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>

<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"title"</code><code class="p">,</code> <code class="s2">"Understanding ECMAScript 6"</code><code class="p">);</code>
<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"format"</code><code class="p">,</code> <code class="s2">"ebook"</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">values</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">tracking</code><code class="p">.</code><code class="nx">values</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">data</code><code class="p">.</code><code class="nx">values</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="s">"red"</code>
<code class="s">"green"</code>
<code class="s">"blue"</code>
<code class="mi">1234</code>
<code class="mi">5678</code>
<code class="mi">9012</code>
<code class="s">"Understanding ECMAScript 6"</code>
<code class="s">"ebook"</code>
</pre></div>

</figure>

<p>In this case, using <code>values()</code> returns the exact data contained in the <code>value</code> property returned from <code>next()</code>.</p>

<p>The <code>keys()</code> iterator returns each key present in the collection. For arrays, this is the numeric keys only (it never returns other own properties of the array); for sets, the keys are the same as the values and so <code>keys()</code> and <code>values()</code> return the same iterator.</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">];</code>
<code class="kd">let</code> <code class="nx">tracking</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1234</code><code class="p">,</code> <code class="mi">5678</code><code class="p">,</code> <code class="mi">9012</code><code class="p">]);</code>
<code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>

<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"title"</code><code class="p">,</code> <code class="s2">"Understanding ECMAScript 6"</code><code class="p">);</code>
<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"format"</code><code class="p">,</code> <code class="s2">"ebook"</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="nx">of</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">keys</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="nx">of</code> <code class="nx">tracking</code><code class="p">.</code><code class="nx">keys</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="nx">of</code> <code class="nx">data</code><code class="p">.</code><code class="nx">keys</code><code class="p">())</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="mi">0</code>
<code class="mi">1</code>
<code class="mi">2</code>
<code class="mi">1234</code>
<code class="mi">5678</code>
<code class="mi">9012</code>
<code class="s">"title"</code>
<code class="s">"format"</code>
</pre></div>

</figure>

<p>Additionally, each collection type has a default iterator that is used by <code>for-of</code> whenever an iterator isn't explicitly specified. The default iterator for arrays and sets is <code>values()</code> while the default iterator for maps is <code>entries()</code>. This makes it a little bit easier to use collection objects in <code>for-of</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code> <code class="p">];</code>
<code class="kd">let</code> <code class="nx">tracking</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1234</code><code class="p">,</code> <code class="mi">5678</code><code class="p">,</code> <code class="mi">9012</code><code class="p">]);</code>
<code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>

<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"title"</code><code class="p">,</code> <code class="s2">"Understanding ECMAScript 6"</code><code class="p">);</code>
<code class="nx">data</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s2">"format"</code><code class="p">,</code> <code class="s2">"ebook"</code><code class="p">);</code>

<code class="c1">// same as using colors.values()</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">colors</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// same as using tracking.values()</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">tracking</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">num</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// same as using data.entries()</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">entry</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="s">"red"</code>
<code class="s">"green"</code>
<code class="s">"blue"</code>
<code class="mi">1234</code>
<code class="mi">5678</code>
<code class="mi">9012</code>
<code class="p">[</code><code class="s">"title"</code><code class="p">,</code> <code class="s">"Understanding ECMAScript 6"</code><code class="p">]</code>
<code class="p">[</code><code class="s">"format"</code><code class="p">,</code> <code class="s">"ebook"</code><code class="p">]</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-string-iterators">String Iterators</h4>

<p>Beginning with ECMAScript 5, JavaScript strings have slowly been evolving to be more array-like. ECMAScript 5 formalizes bracket notation for access characters (<code>text[0]</code> to get the first character). Unfortunately, bracket notation works on code units rather than characters, so it cannot be used to access double-byte characters correctly. ECMAScript 6 has added a lot of functionality to fully support Unicode (see Chapter 1) and as such, the default iterator for strings works on characters rather than code units.</p>

<p>Using bracket notation and the <code>length</code> property, the code units are used instead of characters and the output is a bit unexpected:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"A  &reg; B"</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">message</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="n">A</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="n">B</code>
</pre></div>

</figure>

<p>Since the double-byte character is treated as two separate code units, there are four empty lines between <code>A</code> and <code>B</code> in the output.</p>

<p>Using the default string iterator with a <code>for-of</code> loop results in a more appropriate result:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"A  &reg; B"</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">c</code> <code class="nx">of</code> <code class="nx">message</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code outputs the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="n">A</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="err"></code> <code class="err">&reg;</code>
<code class="p">(</code><code class="n">blank</code><code class="p">)</code>
<code class="n">B</code>
</pre></div>

</figure>

<p>This output is more in line with what you might expect when working with characters. The default string iterator is ECMAScript 6's attempt at solving the iteration problem by using characters instead of code units.</p>

<h4 id="leanpub-auto-nodelist-iterators">NodeList Iterators</h4>

<p>In the Document Object Model (DOM), there is a <code>NodeList</code> type that represents a collection of elements in a document. For those who write JavaScript to run in web browsers, understanding the difference between <code>NodeList</code> objects and arrays has always been a bit difficult. Both use the <code>length</code> property to indicate the number of items and both use bracket notation to access individual items. However, internally a <code>NodeList</code> and an array behave quite differently, and so that has led to a lot of confusion.</p>

<p>With the addition of default iterators in ECMAScript 6, the DOM definition of <code>NodeList</code> now specifically includes a default iterator that behaves in the same manner as the array default iterator. That means you can use <code>NodeList</code> in a <code>for-of</code> loop or any other place that uses an object's default iterator. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">divs</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">div</code> <code class="nx">of</code> <code class="nx">divs</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">div</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This code uses <code>getElementsByTagName()</code> method to retrieve a <code>NodeList</code> that represents all of the <code>&lt;div&gt;</code> elements in the document. The <code>for-of</code> loop then iterates over each element and outputs its ID, effectively making the code the same as it would be for a standard array.</p>

<h3 id="leanpub-auto-advanced-functionality">Advanced Functionality</h3>

<p>There's a lot that can be accomplished with the basic functionality of iterators and the convenience of creating them using generators. However, developers have discovered that iterators are much more powerful when used for tasks other than simply iterating over a collection of values. During the development of ECMAScript 6, a lot of unique ideas and patterns emerged that caused the addition of more functionality. Some of the changes are subtle, but when used together, can accomplish some interesting interactions.</p>

<h4 id="leanpub-auto-passing-arguments-to-iterators">Passing Arguments to Iterators</h4>

<p>Throughout this chapter, you've seen that iterators can pass values out via the <code>next()</code> method or by using <code>yield</code> in a generator. It's also possible to pass arguments into the iterator through the <code>next()</code> method. When an argument is passed to <code>next()</code>, it becomes the value of the <code>yield</code> statement inside a generator. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">first</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="kd">let</code> <code class="nx">second</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">first</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code>       <code class="c1">// 4 + 2</code>
    <code class="k">yield</code> <code class="nx">second</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>                   <code class="c1">// 5 + 3</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code>          <code class="c1">// "{ value: 6, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code>          <code class="c1">// "{ value: 8, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>The first call to <code>next()</code> is a special case where any argument passed to it is lost. Since arguments passed to <code>next()</code> become the value returned by <code>yield</code>, there would have to be a way to access that argument before the first <code>yield</code> in the generator function. That's not possible, so there's no reason to pass an argument the first time <code>next()</code> is called.</p>

<p>On the second call to <code>next()</code>, the value <code>4</code> is passed as the argument. The <code>4</code> ends up assigned to the variable <code>first</code> inside the generator function. In a <code>yield</code> statement including an assignment the right side of the expression is evaluated on the first call to <code>next()</code> and the left side is evaluated on the second call to <code>next()</code> before the function continues executing. Since the second call to <code>next()</code> passes in <code>4</code>, that value is assigned to <code>first</code> and then execution continues.</p>

<p>The second <code>yield</code> uses the result of the first <code>yield</code> and adds two, which means it returns a value of six. When <code>next()</code> is called a third time, the value <code>5</code> is passed as an argument. That value is assigned to the variable <code>second</code> and then used in the third <code>yield</code> statement to return eight.</p>

<p>It's a bit easier to think about what's happening by considering which code is executing each time execution continues inside the generator function. Figure 6-1 uses colors to show the code being executed before yielding.</p>


<figure class="image center">
  <img alt="Figure 6-1: Code execution inside a generator" src="/site_images/understandinges6/fg0601.png">
  <figcaption>Figure 6-1: Code execution inside a generator</figcaption>
</figure>


<p>The color yellow represents the first call to <code>next()</code> and all of the code that is executed inside of the generator as a result; the color aqua represents the call to <code>next(4)</code> and the code that is executed; the color purple represents the call to <code>next(5)</code> and the code that is executed as a result. The tricky part is the code on the right side of each expression executing and stopping before the left side is executed. This makes debugging complicated generators a bit more involved than regular functions.</p>

<h4 id="leanpub-auto-throwing-errors-in-iterators">Throwing Errors in Iterators</h4>

<p>It's not only possible to pass data into iterators, it's also possible to pass error conditions. Iterators can choose to implement a <code>throw()</code> method that instructs the iterator to throw an error when it resumes. You can pass in an error object that should be thrown when the iterator continues processing. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">first</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="kd">let</code> <code class="nx">second</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">first</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code>       <code class="c1">// yield 4 + 2, then throw</code>
    <code class="k">yield</code> <code class="nx">second</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>                   <code class="c1">// never is executed</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>                   <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code>                  <code class="c1">// "{ value: 6, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Boom"</code><code class="p">)));</code> <code class="c1">// error thrown from generator</code>
</pre></div>

</figure>

<p>In this example, the first two <code>yield</code> expressions are evaluated as normal, but when <code>throw()</code> is called, an error is thrown before <code>let second</code> is evaluated. This effectively halts code execution similar to directly throwing an error. The only difference is the location in which the error is thrown. Figure 6-2 shows which code is executed at each step.</p>


<figure class="image center">
  <img alt="Figure 6-2: Throwing an error inside a generator" src="/site_images/understandinges6/fg0602.png">
  <figcaption>Figure 6-2: Throwing an error inside a generator</figcaption>
</figure>


<p>In this figure, the color red represents the code executed when <code>throw()</code> is called and the red star shows approximately when the error is thrown inside the generator. The first two <code>yield</code> statements are evaluated fine, it's only when <code>throw()</code> is called that an error is thrown before any other code is executed. Knowing this, it's possible to catch such errors inside the generator using a <code>try-catch</code> block, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">first</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="kd">let</code> <code class="nx">second</code><code class="p">;</code>

    <code class="k">try</code> <code class="p">{</code>
        <code class="nx">second</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">first</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code>       <code class="c1">// yield 4 + 2, then throw</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">second</code> <code class="o">=</code> <code class="mi">6</code><code class="p">;</code>                     <code class="c1">// on error, assign a different value</code>
    <code class="p">}</code>
    <code class="k">yield</code> <code class="nx">second</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>                   <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">4</code><code class="p">));</code>                  <code class="c1">// "{ value: 6, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Boom"</code><code class="p">)));</code> <code class="c1">// "{ value: 9, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>            <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this example, a <code>try-catch</code> block is wrapped around the second <code>yield</code> statement. While this <code>yield</code> executes without error, the error is thrown before any value can be assigned to <code>second</code>, so the <code>catch</code> block assigns it a value of six. Execution then flows to the next <code>yield</code> and returns nine.</p>

<p>You'll also notice something interesting happened - the <code>throw()</code> method returned a value similar to that returned by <code>next()</code>. Because the error was caught inside the generator, code execution continued on to the next <code>yield</code> and returned the appropriate value.</p>

<p>It helps to think of <code>next()</code> and <code>throw()</code> as both being instructions to the iterator: <code>next()</code> instructs the iterator to continue executing (possibly with a given value) and <code>throw()</code> instructs the iterator to continue executing by throwing an error. What happens after that point depends on the code inside the generator.</p>

<h4 id="leanpub-auto-generator-return-statements">Generator Return Statements</h4>

<p>Since generators are functions, you can use the <code>return</code> statement both to exit early and to specify a return value for the last call to <code>next()</code>. For most of this chapter you've seen examples where the last call to <code>next()</code> on an iterator returns <code>undefined</code>. It's possible to specify an alternate value by using <code>return</code> as you would in any other function. In a generator, <code>return</code> indicates that all processing is done, so the <code>done</code> property is set to <code>true</code> and the value, if provided, becomes the <code>value</code> field. Here's an example that simply exits early using <code>return</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">return</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this code, the generator has a <code>yield</code> statement followed by a <code>return</code> statement. The <code>return</code> indicates that there are no more values to come and so the rest of the <code>yield</code> statements will not execute (they are unreachable).</p>

<p>You can also specify a return value that will end up in the <code>value</code> field of the returned object. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">return</code> <code class="mi">42</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 42, done: true }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>Here, the value <code>42</code> is returned in the <code>value</code> field on the second call to <code>next()</code> (which is the first time that <code>done</code> is <code>true</code>). The third call to <code>next()</code> returns an object whose <code>value</code> property is once again <code>undefined</code>. Any value you specify with <code>return</code> is only available on the returned object one time before the <code>value</code> field is reset to <code>undefined</code>.</p>

<aside class="information blurb">
    <p>Any value specified by <code>return</code> is ignored by <code>for-of</code>.</p>

</aside>

<h4 id="leanpub-auto-delegating-generators">Delegating Generators</h4>

<p>In some cases it may be useful to combine the values from two iterators into one. Using generators, it's possible to delegate to another generator using a special form of <code>yield</code> with a star (<code>*</code>). As with generator definitions, it doesn't matter where the star appears so as long as it is between the keyword <code>yield</code> and the generator function name. Here's an example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createColorIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="s2">"red"</code><code class="p">;</code>
    <code class="k">yield</code> <code class="s2">"green"</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createCombinedIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">();</code>
    <code class="k">yield</code> <code class="o">*</code><code class="nx">createColorIterator</code><code class="p">();</code>
    <code class="k">yield</code> <code class="kc">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createCombinedIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "red", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "green", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: true, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this example, the <code>createCombinedIterator()</code> generator delegates first to <code>createNumberIterator()</code> and then to <code>createColorIterator()</code>. The returned iterator appears, from the outside, to be one consistent iterator that has produced all of the values. Each call to <code>next()</code> is delegated to the appropriate iterator until they are empty, and then the final <code>yield</code> is executed to return <code>true</code>.</p>

<p>Generator delegation also lets you use make of generator return values (as seen in the previous section). This is the easiest way to access such returned values and can be quite useful in performing complex tasks. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">return</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createRepeatingIterator</code><code class="p">(</code><code class="nx">count</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">count</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="s2">"repeat"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createCombinedIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="k">yield</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">();</code>
    <code class="k">yield</code> <code class="o">*</code><code class="nx">createRepeatingIterator</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createCombinedIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>Here, the <code>createCombinedIterator()</code> generator delegates to <code>createNumberIterator()</code> and assigns the return value to <code>result</code>. Since <code>createNumberIterator()</code> contains <code>return 3</code>, the returned value is <code>3</code>. The <code>result</code> variable is then passed to <code>createRepeatingIterator()</code> as an argument indicating how many times to yield the same string (in this case, three times).</p>

<p>Notice that the value <code>3</code> was never output from any call to <code>next()</code>, it existed solely inside of <code>createCombinedIterator()</code>. It is possible to output that value as well by adding another <code>yield</code> statement, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">return</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createRepeatingIterator</code><code class="p">(</code><code class="nx">count</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">count</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="s2">"repeat"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">createCombinedIterator</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="k">yield</code> <code class="o">*</code><code class="nx">createNumberIterator</code><code class="p">();</code>
    <code class="k">yield</code> <code class="nx">result</code><code class="p">;</code>
    <code class="k">yield</code> <code class="o">*</code><code class="nx">createRepeatingIterator</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">createCombinedIterator</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 1, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 2, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: 3, done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: "repeat", done: false }"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>           <code class="c1">// "{ value: undefined, done: true }"</code>
</pre></div>

</figure>

<p>In this code, the extra <code>yield</code> statement explicitly outputs the returned value from <code>createNumberIterator()</code>.</p>

<p>Generator delegation using the return value is a very powerful paradigm that allows for some very interesting possibilities, especially when used in conjunction with asynchronous operations.</p>

<aside class="information blurb">
    <p>You can use <code>yield *</code> directly on strings, such as <code>yield * "hello"</code> and the string's default iterator will be used.</p>

</aside>

<h4 id="leanpub-auto-asynchronous-task-scheduling">Asynchronous Task Scheduling</h4>

<p>A lot of the excitement around generators is directly related to usage with asynchronous programming. Asynchronous programming in JavaScript is a double-edged sword: it's very easy to do simple things while complex things become an errand in code organization. Since generators allow you to effectively pause code in the middle of execution, this opens up a lot of possibilities as it relates to asynchronous processing.</p>

<p>The traditional way to perform asynchronous operations is to call a function that has a callback. For example, consider reading a file from disk in Node.js:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">(</code><code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">init</code><code class="p">(</code><code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">readConfigFile</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="nx">doSomethingWith</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Done"</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nx">init</code><code class="p">();</code>
</pre></div>

</figure>

<p>Instead of providing a callback, you can <code>yield</code> and just wait for a response before starting again:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="kd">var</code> <code class="nx">task</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">task</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">init</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">contents</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">readConfigFile</code><code class="p">();</code>
    <code class="nx">doSomethingWith</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Done"</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">task</code> <code class="o">=</code> <code class="nx">init</code><code class="p">();</code>
<code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
</pre></div>

</figure>

<p>The difference between <code>init()</code> in this example and the previous one is why developers are excited about generators for asynchronous operation. Instead of using callbacks, <code>init()</code> yields to <code>readConfigFile()</code>, which does the asynchronous read operation and, when complete, either calls <code>throw()</code> if there's an error or <code>next()</code> if the contents have been ready. That means the <code>yield</code> operation inside of <code>init()</code> will throw an error if there's a read error or else the file contents will be returned almost as if the operation was synchronous.</p>

<p>Managing the <code>task</code> variable is a bit cumbersome in this example, but it's only important that you understand the theory. There are more powerful ways of doing asynchronous task scheduling using promises, and that will be covered further in Chapter 10.</p>

<h3 id="leanpub-auto-summary-6">Summary</h3>

<p>Iterators are an important part of ECMAScript 6 and are at the root of several important parts of the language. On the surface, iterators provide a simple way to return a sequence of values using a simple API. However, there are far more complex ways to use iterators in ECMAScript 6.</p>

<p>The <code>@@iterator</code> symbol is used to define default iterators for objects. Both built-in objects and developer-defined objects can use this symbol to provide a method that returns an iterator. When <code>@@iterator</code> is provided, the object is considered an iterable.</p>

<p>The <code>for-of</code> loop uses iterables to return a series of values in a loop. This makes creating loops easier than the traditional <code>for</code> loop because you no longer need to track values and control when the loop ends. The <code>for-of</code> loop automatically reads all values from the iterator until there are no more and then exits.</p>

<p>To make it easier to use <code>for-of</code>, many values in ECMAScript 6 have default iterators. All the collection types, arrays, maps, and sets, have iterators designed for easy access to their contents. Strings also have a default iterator so it's easy to iterate over the code points of the string (rather than the code units).</p>

<p>Generators are a special type of function that automatically creates an iterator when called. These functions are indicated by the start (<code>*</code>) and make use of the <code>yield</code> keyword to indicate which value to return for each successive call to <code>next()</code>.</p>

<p>Generator delegation encourages good encapsulation of iterator behavior by letting you reuse existing generators in new ones. This is done using <code>yield *</code> instead of <code>yield</code>, allowing you to create an iterator that returns values from multiple iterators.</p>

<p>Perhaps the most interesting and exciting aspect of generators and iterators is the possibility of creating cleaner-looking asynchronous code. Instead of needing to use callbacks everywhere, you can setup code that looks synchronous but in fact uses <code>yield</code> to wait for asynchronous operations to complete.</p>

<h2 id="leanpub-auto-classes">Classes</h2>

<p>Ever since JavaScript was first created, many developers have been confused by its lack of classes. Most formal object-oriented programming languages support classes and classical inheritance as the primary way of defining similar and related objects. From pre-ECMAScript 1 all the way through ECMAScript 5, this point of confusion led many libraries to create utilities designed to make JavaScript look like it had support for classes.</p>

<p>While there are some JavaScript developers who feel strongly that the language doesn't need classes, the fact that so many libraries were created specifically for this purpose led to the inclusion of classes in ECMAScript 6. However, ECMAScript 6 classes aren't exactly the same as classes in other language. There's a uniqueness about them that embraces the dynamic of JavaScript as a language.</p>

<h3 id="leanpub-auto-class-like-structures-in-ecmascript-5">Class-Like Structures in ECMAScript 5</h3>

<p>Before exploring classes, it's helpful to understand the underlying mechanisms that classes use. In ECMAScript 5 and earlier, there were no classes, and the closest equivalent was creating a constructor and then assigning methods to its prototype. This approach is called creating a custom type. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">PersonType</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">PersonType</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">PersonType</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>   <code class="c1">// outputs "Nicholas"</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nx">PersonType</code><code class="p">);</code>  <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nb">Object</code><code class="p">);</code>      <code class="c1">// true</code>
</pre></div>

</figure>

<p>In this code, <code>PersonType</code> is a constructor function that creates a single property called <code>name</code>. The <code>sayName()</code> method is assigned to the prototype so the same function is shared by all instances of <code>PersonType</code>. Then, a new instance of <code>PersonType</code> is created via the <code>new</code> operator, and the resulting <code>person</code> object is considered an instance of <code>PersonType</code> and of <code>Object</code> (through prototypal inheritance).</p>

<p>This same basic pattern underlies a lot of the class-mimicking JavaScript libraries. And that's where ECMAScript 6 classes start.</p>

<h3 id="leanpub-auto-class-declarations">Class Declarations</h3>

<p>The simplest form of classes to understand is the one that looks similar to other languages: the class declaration. Class declarations begin with the <code>class</code> keyword followed by the name of the class. The rest of the syntax looks similar to concise methods in object literals without requiring commas between them. For example, here's the class equivalent of the previous example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">PersonClass</code> <code class="p">{</code>

    <code class="c1">// equivalent of the PersonType constructor</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// equivalent of PersonType.prototype.sayName</code>
    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">PersonClass</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>   <code class="c1">// outputs "Nicholas"</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nx">PersonClass</code><code class="p">);</code>     <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nb">Object</code><code class="p">);</code>          <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">PersonClass</code><code class="p">);</code>                    <code class="c1">// "function"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">PersonClass</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code><code class="p">);</code>  <code class="c1">// "function"</code>
</pre></div>

</figure>

<p>The class declaration <code>PersonClass</code> behaves quite similarly to <code>PersonType</code> from the previous example. Instead of defining a function as the constructor, class declarations allow you to define the constructor directly inside of the class using the special <code>constructor</code> method name. Since class methods use the concise syntax, there's no need to use the <code>function</code> keyword. All other method names have no special meaning, so you can add as many as you want.</p>

<aside class="information blurb">
    <p>Own properties, properties that occur on the instance rather than the prototype, can only be created inside of a class constructor or method. In the previous example, <code>name</code> is an own property. It's recommended to create all possible own properties inside of the constructor function so there's a single place that's responsible for all of them.</p>

</aside>

<p>Perhaps the worst-kept secret in ECMAScript 6 is that class declarations such as this example are actually just syntactic sugar on top of the existing custom type declarations. The <code>PersonClass</code> declaration actually creates a function that has the behavior of the <code>constructor</code> method, which is why <code>typeof PersonClass</code> is <code>"function"</code>. Similarly, the <code>sayName()</code> method ends up as a method on <code>PersonClass.prototype</code>, similar to <code>PersonType.prototype</code> in the earlier example. These similarities allow you to mix custom types and classes without worry too much about which you're using.</p>

<p>Despite the similarities, there are some important differences to keep in mind:</p>

<ol class="numeric">
  <li>Class declarations, unlike function declarations, are not hoisted. Class declarations act like <code>let</code> declarations and so exist in the temporal dead zone until execution reaches the declaration.</li>
  <li>All code inside of class declarations runs in strict mode automatically. There's no way to opt-out of strict mode inside of classes.</li>
  <li>All methods are non-enumerable. This is a significant change from custom types, where you need to use <code>Object.defineProperty()</code> to make a method non-enumerable.</li>
  <li>Calling the class constructor without <code>new</code> throws an error.</li>
  <li>Attempting to overwrite the class name within a class method throws an error.</li>
</ol>

<p>With all of this in mind, the <code>PersonClass</code> declaration from the previous example is directly equivalent to the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// direct equivalent of PersonClass</code>
<code class="kd">let</code> <code class="nx">PersonType2</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>

    <code class="s2">"use strict"</code><code class="p">;</code>

    <code class="kr">const</code> <code class="nx">PersonType2</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// make sure the function was called with new</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">===</code> <code class="s2">"undefined"</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Constructor must be called with new."</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">PersonType2</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="s2">"sayName"</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
        <code class="p">},</code>
        <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
    <code class="p">});</code>

    <code class="k">return</code> <code class="nx">PersonType2</code><code class="p">;</code>
<code class="p">}());</code>
</pre></div>

</figure>

<p>While it was possible to do everything that classes do without adding new syntax, you can see how the class syntax makes all of the functionality a lot simpler than it would be otherwise.</p>

<aside>
  <h4 id="leanpub-auto-constant-class-names">Constant Class Names</h4>

  <p>The name of a class is specified as if using <code>const</code>, but only inside of the class itself. That means you can overwrite the class name outside of the class but not inside a class method. For example:</p>

  <figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Foo</code> <code class="p">{</code>
   <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
       <code class="nx">Foo</code> <code class="o">=</code> <code class="s2">"bar"</code><code class="p">;</code>    <code class="c1">// throws an error when executed</code>
   <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// but this is okay</code>
<code class="nx">Foo</code> <code class="o">=</code> <code class="s2">"baz"</code><code class="p">;</code>
</pre></div>

  </figure>

  <p>In this code, the <code>Foo</code> inside of the class constructor is a separate binding than the <code>Foo</code> outside of the class. The internal <code>Foo</code> is defined as if it's a <code>const</code> and so cannot be overwritten, which means and error is thrown when an attempt is made to do so; the external <code>Foo</code> is defined as if it's a <code>let</code> declaration and so its value may be overwritten at any time.</p>

</aside>

<h3 id="leanpub-auto-class-expressions">Class Expressions</h3>

<p>Classes and functions are similar in that they have two forms: declarations and expressions. Function and class declarations begin with an appropriate keyword (<code>function</code> or <code>class</code>, respectively) followed by an identifier. Functions have an expression form that doesn't require an identifier after <code>function</code>, and similarly, classes have an expression form that doesn't require an identifier after <code>class</code>.</p>

<p>These <em>class expressions</em> are designed to be used in variable declarations or passed into functions as arguments. Here's the class expression equivalent of the previous examples:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// class expressions do not require identifiers after "class"</code>
<code class="kd">let</code> <code class="nx">PersonClass</code> <code class="o">=</code> <code class="kr">class</code> <code class="p">{</code>

    <code class="c1">// equivalent of the PersonType constructor</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// equivalent of PersonType.prototype.sayName</code>
    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">PersonClass</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>   <code class="c1">// outputs "Nicholas"</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nx">PersonClass</code><code class="p">);</code>     <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <code class="k">instanceof</code> <code class="nb">Object</code><code class="p">);</code>          <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">PersonClass</code><code class="p">);</code>                    <code class="c1">// "function"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">PersonClass</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code><code class="p">);</code>  <code class="c1">// "function"</code>
</pre></div>

</figure>

<p>Aside from the syntax, class expressions are exactly equivalent to class declarations. This example omits the identifier after <code>class</code>, but you can also include it:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">PersonClass</code> <code class="o">=</code> <code class="kr">class</code> <code class="nx">PersonClass2</code> <code class="p">{</code>

    <code class="c1">// equivalent of the PersonType constructor</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// equivalent of PersonType.prototype.sayName</code>
    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">PersonClass</code> <code class="o">===</code> <code class="nx">PersonClass2</code><code class="p">);</code>  <code class="c1">// true</code>
</pre></div>

</figure>

<p>In this case, <code>PersonClass</code> and <code>PersonClass2</code> both reference the same class, and so they can be used interchangeably.</p>

<p>Class expressions can also be used in some interesting ways. For example, they can be passed into functions as arguments:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">createObject</code><code class="p">(</code><code class="nx">classDef</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">classDef</code><code class="p">();</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nx">createObject</code><code class="p">(</code><code class="kr">class</code> <code class="p">{</code>

    <code class="nx">sayHi</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="nx">obj</code><code class="p">.</code><code class="nx">sayHi</code><code class="p">();</code>        <code class="c1">// "Hi!"</code>
</pre></div>

</figure>

<p>In this example, an anonymous class expression is passed into <code>createObject()</code>. An instance is then created by using <code>new</code> and that object is returned.</p>

<p>Another interesting use of class expressions is to create singletons by immediately invoking the class constructor. To do so, you must use <code>new</code> with a class expression and include parentheses at the end. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="kr">class</code> <code class="p">{</code>

    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>

<code class="p">}(</code><code class="s2">"Nicholas"</code><code class="p">);</code>

<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>       <code class="c1">// "Nicholas"</code>
</pre></div>

</figure>

<p>Here, the anonymous class expression is created and then executed immediately. This pattern allows you to use the class syntax for creating singletons without leaving a class reference available for inspection. The parentheses at the end are the indicator that you're calling a function while also allowing you to pass in an argument.</p>

<p>Whether you use class declarations or class expressions is purely a matter of style. Unlike function declarations and function expressions, both class declarations and class expressions are not hoisted, and so the choice has little bearing on the runtime behavior of the code.</p>

<h3 id="leanpub-auto-accessor-properties">Accessor Properties</h3>

<p>While own properties should be created inside of class constructors, classes allow you to define accessor properties on the prototype by using a syntax similar to that of object literal accessor format. To create a getter, use the keyword <code>get</code> followed by a space followed by an identifier; to create a setter, do the same using the keyword <code>set</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">CustomHTMLElement</code> <code class="p">{</code>

    <code class="nx">constructor</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">element</code> <code class="o">=</code> <code class="nx">element</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">get</code> <code class="nx">html</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">element</code><code class="p">.</code><code class="nx">innerHTML</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">set</code> <code class="nx">html</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">element</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">descriptor</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">CustomHTMLElement</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code><code class="o">\</code>
 <code class="s2">"html"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"get"</code> <code class="k">in</code> <code class="nx">descriptor</code><code class="p">);</code>   <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"set"</code> <code class="k">in</code> <code class="nx">descriptor</code><code class="p">);</code>   <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">enumerable</code><code class="p">);</code> <code class="c1">// false</code>
</pre></div>

</figure>

<p>In this example, the <code>CustomHTMLElement</code> class is made as a simple wrapper around an existing DOM element. It has both a getter and setter for <code>html</code> that simply delegates to the <code>innerHTML</code> method on the element itself. This accessor property is created as non-enumerable, just like any other method would be, and is created on the <code>CustomHTMLElement.prototype</code>. The equivalent non-class representation is:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// direct equivalent to previous example</code>
<code class="k">let</code> <code class="n">CustomHTMLElement</code> <code class="o">=</code> <code class="p">(</code><code class="k">function</code><code class="p">()</code> <code class="p">{</code>

    <code class="s">"use strict"</code><code class="p">;</code>

    <code class="k">const</code> <code class="n">CustomHTMLElement</code> <code class="o">=</code> <code class="k">function</code><code class="p">(</code><code class="n">element</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// make sure the function was called with new</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">typeof</code> <code class="k">new</code><code class="p">.</code><code class="n">target</code> <code class="o">===</code> <code class="s">"undefined"</code><code class="p">)</code> <code class="p">{</code>
            <code class="n">throw</code> <code class="k">new</code> <code class="n">Error</code><code class="p">(</code><code class="s">"Constructor must be called with new."</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">this</code><code class="p">.</code><code class="n">element</code> <code class="o">=</code> <code class="n">element</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="n">Object</code><code class="p">.</code><code class="n">defineProperty</code><code class="p">(</code><code class="n">CustomHTMLElement</code><code class="p">.</code><code class="n">prototype</code><code class="p">,</code> <code class="s">"html"</code><code class="p">,</code> <code class="p">{</code>
        <code class="nl">enumerable:</code> <code class="n">false</code><code class="p">,</code>
        <code class="nl">configurable:</code> <code class="n">true</code><code class="p">,</code>
        <code class="nl">get:</code> <code class="k">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="n">element</code><code class="p">.</code><code class="n">innerHTML</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nl">set:</code> <code class="k">function</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="n">element</code><code class="p">.</code><code class="n">innerHTML</code> <code class="o">=</code> <code class="n">value</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">});</code>

    <code class="k">return</code> <code class="n">CustomHTMLElement</code><code class="p">;</code>
<code class="p">}());</code>
</pre></div>

</figure>

<p>As with previous examples, this one shows just how much code you're saving by using a class instead of the non-class equivalent. The accessor property definition alone is almost the size of the equivalent class declaration.</p>

<h3 id="leanpub-auto-static-members">Static Members</h3>

<p>Another common pattern in JavaScript is adding addition methods directly onto constructors to simulate static members. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">PersonType</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// static method</code>
<code class="nx">PersonType</code><code class="p">.</code><code class="nx">create</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">PersonType</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
<code class="p">};</code>

<code class="c1">// instance method</code>
<code class="nx">PersonType</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">person</code> <code class="o">=</code> <code class="nx">PersonType</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
</pre></div>

</figure>

<p>This code creates a factory method called <code>PersonType.create()</code>. In other programming languages, this would be considered a static method as it is not dependent on an instance of <code>PersonType</code> for its data.</p>

<p>Classes simplify the creation of static members by using the formal <code>static</code> annotation before the method or accessor property name. Here's the equivalent of the last example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">PersonClass</code> <code class="p">{</code>

    <code class="c1">// equivalent of the PersonType constructor</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// equivalent of PersonType.prototype.sayName</code>
    <code class="nx">sayName</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// equivalent of PersonType.create</code>
    <code class="kr">static</code> <code class="nx">create</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nx">PersonClass</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="nx">PersonClass</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="s2">"Nicholas"</code><code class="p">);</code>
</pre></div>

</figure>

<p>The <code>PersonClass</code> definition defines a single static method called <code>create()</code> by adding the <code>static</code> keyword.</p>

<p>You can use the <code>static</code> keyword on any method or accessor property definition within a class. The only restriction is that you cannot use <code>static</code> with the <code>constructor</code> method definition.</p>

<aside class="information blurb">
    <p>Just as with other class members, static members are not enumerable by default.</p>

</aside>

<h3 id="leanpub-auto-derived-classes">Derived Classes</h3>

<p>Another problem with custom types in ECMAScript 5 and earlier was the extensive process necessary to implement inheritance. To properly inherit, you would need multiple steps. For instance:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Rectangle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getArea</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">Square</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Rectangle</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">Square</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Rectangle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code><code class="nx">Square</code><code class="p">,</code>
        <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="kd">var</code> <code class="nx">square</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>              <code class="c1">// 9</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code> <code class="k">instanceof</code> <code class="nx">Square</code><code class="p">);</code>      <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code> <code class="k">instanceof</code> <code class="nx">Rectangle</code><code class="p">);</code>   <code class="c1">// true</code>
</pre></div>

</figure>

<p>Here, <code>Square</code> inherits from <code>Rectangle</code>, and to do so, it must be overwrite <code>Square.prototype</code> with a new object created from <code>Rectangle.prototype</code> as well as call <code>Rectangle.call()</code>. These steps often confused newcomers to the language and were a source of errors for experienced developers.</p>

<p>Derived classes use the <code>extends</code> keyword to specify the function from which the class should inherit. The prototypes are automatically adjusted and you can access the base class constructor using <code>super()</code>. Here's the equivalent of the previous example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">getArea</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// same as Rectangle.call(this, length, length)</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">square</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>              <code class="c1">// 9</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code> <code class="k">instanceof</code> <code class="nx">Square</code><code class="p">);</code>      <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">square</code> <code class="k">instanceof</code> <code class="nx">Rectangle</code><code class="p">);</code>   <code class="c1">// true</code>
</pre></div>

</figure>

<p>In this example, the <code>Square</code> class inherits from <code>Rectangle</code> using the <code>extends</code> keyword. The <code>Square</code> constructor uses <code>super()</code> to call the <code>Rectangle</code> constructor with the specified arguments. Note that unlike the ECMAScript 5 version of the code, the identifier <code>Rectangle</code> is only used within the class declaration (after <code>extends</code>).</p>

<p>Using <code>super()</code> is a requirement of derived classes if you specify a constructor (if you don't, an error will occur). If you choose not to use a constructor, then <code>super()</code> is automatically called for you with all arguments upon creating a new instance of the class. For instance, the following two classes are identical:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="c1">// no constructor</code>
<code class="p">}</code>

<code class="c1">// Is equivalent to</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The second class in this example shows the equivalent of the default constructor for all derived classes. All of the arguments are passed, in order, to the base class constructor. In this case, the functionality isn't quite correct because the <code>Square</code> constructor needs only one argument and so it's best to manually define the constructor.</p>

<aside class="warning blurb">
    <p>There are a few things to keep in mind when using <code>super()</code>:</p>

  <ol class="numeric">
    <li>You can only use <code>super()</code> in a derived class. If you try to use it in a non-derived class (a class that doesn't use <code>extends</code>) or a function, it will throw an error.</li>
    <li>You must call <code>super()</code> before accessing <code>this</code> in the constructor. Since <code>super()</code> is responsible for initializing <code>this</code>, attempting to access <code>this</code> before calling <code>super()</code> results in an error.</li>
    <li>The only way to avoid calling <code>super()</code> is to return an object from the class constructor.</li>
  </ol>

</aside>

<h4 id="leanpub-auto-class-methods">Class Methods</h4>

<p>The methods on derived classes always shadow methods of the same name on the base class. For instance, you can add <code>getArea()</code> to <code>Square</code> in order to redefine that functionality:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// override and shadow Rectangle.prototype.getArea()</code>
    <code class="nx">getArea</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In this code, <code>getArea()</code> is now defined as part of <code>Square</code> and therefore <code>Rectangle.prototype.getArea()</code> will no longer be called by any instances of <code>Square</code>. Of course, you can always decide to call the base class version of the method by using <code>super.getArea()</code>, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// override, shadow, and call Rectangle.prototype.getArea()</code>
    <code class="nx">getArea</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getArea</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Using <code>super</code> in this way is the same as discussed in Chapter 3: the <code>this</code> value is automatically set correctly so you can make a simple method call.</p>

<p>Another interesting aspect of class methods is that they are missing the <code>[[Construct]]</code> internal method and therefore cannot be used with <code>new</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// throws an error</code>
<code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getArea</code><code class="p">();</code>
</pre></div>

</figure>

<p>Since class methods can't be called with <code>new</code>, you are prevented from accidentally calling these methods in a manner for which they were not intended.</p>

<p>Class methods can have computed names, just like computed names in object literals, by using square brackets around an expression. Here's an example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">methodName</code> <code class="o">=</code> <code class="s2">"getArea"</code><code class="p">;</code>
<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// override, shadow, and call Rectangle.prototype.getArea()</code>
    <code class="p">[</code><code class="nx">methodName</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getArea</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example is equivalent to the previous. The only difference is that a computed name is used for the <code>getArea()</code> method.</p>

<h4 id="leanpub-auto-static-members-1">Static Members</h4>

<p>If a base class has static members then those static members are also available on the derived class. This maps to how inheritance works in other languages, but is a new concept for JavaScript. Here's an example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">getArea</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kr">static</code> <code class="nx">create</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// same as Rectangle.call(this, length, length)</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">rect</code> <code class="o">=</code> <code class="nx">Square</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rect</code> <code class="k">instanceof</code> <code class="nx">Rectangle</code><code class="p">);</code>     <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rect</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>                <code class="c1">// 12</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rect</code> <code class="k">instanceof</code> <code class="nx">Square</code><code class="p">);</code>        <code class="c1">// false</code>
</pre></div>

</figure>

<p>In this code, a new static <code>create()</code> method is added to <code>Rectangle</code>. Through inheritance, that method is available as <code>Square.create()</code> and behaves in the same manner as <code>Rectangle.create()</code>.</p>

<h4 id="leanpub-auto-derived-classes-from-expressions">Derived Classes from Expressions</h4>

<p>Perhaps the most powerful aspect of derived classes in ECMAScript 6 is the ability to derive a class from an expression. You can use <code>extends</code> with any expression, and if the expression resolves to a function with <code>[[Construct]]</code> and a prototype, the class will work. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Rectangle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getArea</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>               <code class="c1">// 9</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code> <code class="k">instanceof</code> <code class="nx">Rectangle</code><code class="p">);</code>    <code class="c1">// true</code>
</pre></div>

</figure>

<p>This example defines <code>Rectangle</code> as an ECMAScript 5-style constructor while <code>Square</code> is a class. Since <code>Rectangle</code> has <code>[[Construct]]</code> and a prototype, the class can still inherit directly from it.</p>

<p>Accepting any type of expression after <code>extends</code> allows for some powerful possibilities, such as dynamically determining what to inherit from. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Rectangle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getArea</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">getBase</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">Rectangle</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">getBase</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>               <code class="c1">// 9</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code> <code class="k">instanceof</code> <code class="nx">Rectangle</code><code class="p">);</code>    <code class="c1">// true</code>
</pre></div>

</figure>

<p>Here, the <code>getBase()</code> function is called directly as part of the class declaration. It returns <code>Rectangle</code>, which means this example is functionally equivalent to the previous one. And since you can determine the base dynamically, that means it's possible to create different inheritance approaches. For instance, you can effectively create mixins:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">SerializableMixin</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">serialize</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">AreaMixin</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">getArea</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">mixin</code><code class="p">(...</code><code class="nx">mixins</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">base</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{};</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">base</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">...</code><code class="nx">mixins</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">base</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">mixin</code><code class="p">(</code><code class="nx">AreaMixin</code><code class="p">,</code> <code class="nx">SerializableMixin</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">.</code><code class="nx">getArea</code><code class="p">());</code>               <code class="c1">// 9</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">.</code><code class="nx">serialize</code><code class="p">());</code>             <code class="c1">// "{"length":3,"width":3}"</code>
</pre></div>

</figure>

<p>In this example, mixins are used instead of classical inheritance. The <code>mixin()</code> function takes any number of arguments that represent mixin objects. It creates a function called <code>base</code> and assigns the properties of each mixin object to the prototype. The function is then returned so <code>Square</code> can use <code>extends</code>. Keep in mind that since <code>extends</code> is still used, you are required to call <code>super()</code> in the constructor.</p>

<p>The instance of <code>Square</code> has both <code>getArea()</code> from <code>AreaMixin</code> and <code>serialize</code> from <code>SerializableMixin</code>. This is accomplished through prototypal inheritance, as the <code>mixin()</code> function dynamically populates the prototype of a new function with all of the own properties of each mixin.</p>

<aside class="warning blurb">
    <p>Even though any expression can be used after <code>extends</code>, not all expressions result in a valid class. Specifically, the following expression types causes errors:</p>

  <ul>
    <li><code>null</code></li>
    <li>generator functions (chapter 8)</li>
  </ul>

  <p>In these cases, attempting to create a new instance of the class will throw an error because there is <code>[[Construct]]</code> to call.</p>

</aside>

<h4 id="leanpub-auto-inheriting-from-built-ins">Inheriting from Built-ins</h4>

<p>For almost as long as there have been JavaScript arrays, developers have wanted to inherit from arrays to create their own special array types. However, in ECMAScript 5 and earlier, this wasn't possible. Here's an example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// built-in array behavior</code>
<code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[];</code>
<code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>         <code class="c1">// 1</code>

<code class="nx">colors</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>             <code class="c1">// undefined</code>

<code class="c1">// trying to inherit from array in ES5</code>

<code class="kd">function</code> <code class="nx">MyArray</code><code class="p">()</code> <code class="p">{</code>
    <code class="nb">Array</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">MyArray</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="nx">MyArray</code><code class="p">,</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
        <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyArray</code><code class="p">();</code>
<code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>         <code class="c1">// 0</code>

<code class="nx">colors</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>             <code class="c1">// "red"</code>
</pre></div>

</figure>

<p>As you can see, using the classical form of JavaScript inheritance results in unexpected behavior. The <code>length</code> and numeric properties don't behave the same as they built-in array because this functionality isn't covered either by <code>Array.apply()</code> or by assigning the prototype.</p>

<p>One of the goals of ECMAScript 6 classes is to allow inheritance from all built-ins. In order to accomplish this, the inheritance model of classes is slightly different than the classical inheritance model found in ECMAScript 5 and earlier:</p>

<ul>
  <li>In ECMAScript 5 classical inheritance, the value of <code>this</code> is first created by the derived type (for example, <code>MyArray</code>) and then the base type constructor is called (<code>Array.apply()</code>). That means <code>this</code> starts out as an instance of <code>MyArray</code> and then is decorated with additional properties from <code>Array</code>.</li>
  <li>In ECMAScript 6 class-based inheritance, the value of <code>this</code> is first created by the base (<code>Array</code>) and then modified by the derived class constructor (<code>MyArray</code>). The result is that <code>this</code> is starts out with all of the built-in functionality of the base and correctly receives all functionality related to it.</li>
</ul>

<p>The following class-based special array works as you would expect:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">MyArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyArray</code><code class="p">();</code>
<code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>         <code class="c1">// 1</code>

<code class="nx">colors</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>             <code class="c1">// undefined</code>
</pre></div>

</figure>

<p>In this example, <code>MyArray</code> inherits directly from <code>Array</code> and therefore works in the exact same way. Interacting with numeric properties updates the <code>length</code> property, and manipulating the <code>length</code> property updates the numeric properties.</p>

<p>Additionally, <code>MyArray</code> inherits all static members from <code>Array</code>, which means that <code>MyArray.of()</code> already exists and can be used:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">MyArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">colors</code> <code class="o">=</code> <code class="nx">MyArray</code><code class="p">.</code><code class="nx">of</code><code class="p">([</code><code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code><code class="p">]);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code> <code class="k">instanceof</code> <code class="nx">MyArray</code><code class="p">);</code>     <code class="c1">// true</code>
</pre></div>

</figure>

<p>The inherited <code>MyArray.of()</code> behaves the same as <code>Array.of()</code> except that it creates an instance of <code>MyArray</code> rather than an instance of <code>Array</code>. Many built-in objects are specifically defined so that their static methods work appropriately for derived classes.</p>

<p>This same approach can be used to inherit from any of the built-in JavaScript objects, with a full guarantee that it will work the same way as the built-ins.</p>

<h3 id="leanpub-auto-newtarget">new.target</h3>

<p>In Chapter 2, you learned about <code>new.target</code> and how its value changes depending on how a function is called. You can also use <code>new.target</code> in class constructors to determine how the class is being invoked. In the simple case, <code>new.target</code> is equal to the constructor function for the class, as in this example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">===</code> <code class="nx">Rectangle</code><code class="p">);</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// new.target is Rectangle</code>
<code class="kd">var</code> <code class="nx">obj</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">);</code>      <code class="c1">// outputs true</code>
</pre></div>

</figure>

<p>In this code, you can see that <code>new.target</code> is equivalent to <code>Rectangle</code> when <code>new Rectangle(3, 4)</code> is called. Since class constructors cannot be called without <code>new</code>, <code>new.target</code> is always defined inside of class constructors. However, the value may not always be the same.</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">===</code> <code class="nx">Rectangle</code><code class="p">);</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Square</code> <code class="kr">extends</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">length</code><code class="p">)</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// new.target is Square</code>
<code class="kd">var</code> <code class="nx">obj</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>      <code class="c1">// outputs false</code>
</pre></div>

</figure>

<p>Here, <code>Square</code> is calling the <code>Rectangle</code> constructor, so <code>new.target</code> is equal to <code>Square</code> when the <code>Rectangle</code> constructor is called. This is important because it gives each constructor the ability to alter its behavior based on how it's being called. For instance, you can create an abstract base class (one that cannot be instantiated directly) by using <code>new.target</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// abstract base class</code>
<code class="kr">class</code> <code class="nx">Shape</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="o">===</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"This class cannot be instantiated directly."</code><code class="p">)</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Rectangle</code> <code class="kr">extends</code> <code class="nx">Shape</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Shape</code><code class="p">();</code>                <code class="c1">// throws error</code>

<code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Rectangle</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">);</code>        <code class="c1">// no error</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">y</code> <code class="k">instanceof</code> <code class="nx">Shape</code><code class="p">);</code>    <code class="c1">// true</code>
</pre></div>

</figure>

<p>In this example, the <code>Shape</code> class constructor throws an error whenever <code>new.target</code> is <code>Shape</code>, meaning that <code>new Shape()</code> always throws an error. However, you can still use it as a base class, which is what <code>Rectangle</code> does.</p>

<h3 id="leanpub-auto-summary-7">Summary</h3>

<p>For those who have struggled to understand JavaScript in the absence of classes, ECMAScript 6 classes provide an easier way to become acclimated with the language without needing to completely throw away their understanding of inheritance. ECMAScript 6 classes start out as syntatic sugar for the classical inheritance model of ECMAScript 5, but adds a lot of features to reduce mistakes.</p>

<p>ECMAScript 6 classes work with prototypal inheritance by defining non-static methods on the class prototype while static methods end up on the constructor itself. All methods are non-enumerable, which better matches the behavior of built-in objects for which methods are typically not enumerable by default. Additionally, class constructors cannot be called without <code>new</code>, ensuring that you can't accidentally call a class as a function.</p>

<p>Class-based inheritance allows you to derive a class from another class, function, or expression. This ability means you can call function to determine the correct base to inherit from, allowing you to use mixins and other different composition patterns to create a new class. Inheritance works in such a way that inheriting from built-in objects, such as <code>Array</code>, is now possible and works as expected.</p>

<p>You can use <code>new.target</code> in class constructors to behave differently depending on how the class is called. The most common use is to create an abstract base class that throws an error when instantiated directly but still allows inheritance via other classes.</p>

<p>Overall, classes are an important addition to the language that provides a more concise syntax and better functionality for defining custom object types in a safe, consistent manner.</p>

<h2 id="leanpub-auto-promises">Promises</h2>

<p>One of the most powerful aspects of JavaScript is how easy it handles asynchronous programming. Since JavaScript originated as a language for the web, it was a requirement to be able to respond to user interactions such as clicks and key presses. Node.js further popularized asynchronous programming in JavaScript by using callbacks as an alternative to events. As more and more programs started using asynchronous programming, there was a growing sense that these two models, events and callbacks, weren't powerful enough to support everything that developers wanted to do. Promises are the solution to this problem.</p>

<p>Promises are another option for asynchronous programming, and similar functionality is available in other languages under names such as futures and deferreds. The basic idea is to specify some code to be executed later (as with events and callbacks) and also explicitly indicate if the code succeeded or failed in its job. In that way, you can chain promises together based on success or failure in ways that are easier to understand and debug.</p>

<p>Before you can get a good understanding of how promises work, however, it's important to understand some of the basic concepts upon which they are built.</p>

<h3 id="leanpub-auto-asynchronous-programming-background">Asynchronous Programming Background</h3>

<p>JavaScript engines are built on the concept of a single-threaded event loop. Single-threaded means that only one piece of code is executed at any given point in time. This stands in contrast to other languages such as Java or C++ that may use threads to allow multiple different pieces of code to execute at the same time. Maintaining, and protecting, state when multiple pieces of code can access and change that state is a difficult problem and the source of frequent bugs in thread-based software.</p>

<p>Because JavaScript engines can only execute one piece of code at a time, it's necessary to keep track of code that is meant to run. That code is kept in a <em>job queue</em>. Whenever a piece of code is ready to be executed, it is added to the job queue. When the JavaScript engine is finished executing code, the event loop picks the next job in the queue and executes it. The <em>event loop</em> is a process inside of the JavaScript engine that monitors code execution and manages the job queue. Keep in mind that as a queue, job execution runs from the first job in the queue to the last.</p>

<h4 id="leanpub-auto-events">Events</h4>

<p>When a user clicks a button or presses a key on the keyboard, an <em>event</em> is triggered (such as <code>onclick</code>). That event may be used to respond to the interaction by adding a new job to the back of the job queue. This is the most basic form of asynchronous programming JavaScript has: the event handler code doesn't execute until the event fires, and when it does execute, it has the appropriate context. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"my-btn"</code><code class="p">);</code>
<code class="nx">button</code><code class="p">.</code><code class="nx">onclick</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Clicked"</code><code class="p">);</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>In this code, <code>console.log("Clicked")</code> will not be executed until <code>button</code> is clicked. When <code>button</code> is clicked, the function assigned to <code>onclick</code> is added to the back of the job queue and will be executed when all other jobs ahead of it are complete.</p>

<p>Events work well for simple interactions such as this, but chaining multiple separate asynchronous calls together becomes more complicated because you must keep track of the event target (<code>button</code> in the previous example) for each event. Additionally, you need to ensure all appropriate event handlers are added before the first instance of an event occurs. For instance, if <code>button</code> in the previous example was clicked before <code>onclick</code> is assigned, then nothing will happen.</p>

<p>So while events are useful for responding to user interactions and similar functionality that occurs infrequently, they aren't very flexible for more complex needs.</p>

<h4 id="leanpub-auto-callbacks">Callbacks</h4>

<p>When Node.js was created, it furthered the asynchronous programming model by popularizing the callback pattern. The callback pattern is similar to the event model because it doesn't execute code until a later point in time; it is different because the function to call is passed in as an argument. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
<code class="p">});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>
</pre></div>

</figure>

<p>This example uses the traditional Node.js style of error-first callback. The <code>readFile()</code> function is intended to read from a file on disk (specified as the first argument) and then execute the callback (the second argument) when complete. If there's an error, the <code>err</code> argument of the callback is an error object; otherwise, the <code>contents</code> argument contains the file contents as a string.</p>

<p>Using the callback pattern, <code>readFile()</code> begins executing immediately and pauses when it begins reading from the disk. That means <code>console.log("Hi!")</code> is output immediately after <code>readFile()</code> is called (before <code>console.log(contents)</code>). When <code>readFile()</code> has finished, it adds a new job to the end of the job queue with the callback function and its arguments. That job is then executed upon completion of all other jobs ahead of it.</p>

<p>The callback pattern is more flexible than events because it is easier to chain multiple calls together. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">writeFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"File was written!"</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this code, a successful call to <code>readFile()</code> results in another asynchronous call, this time to <code>writeFile()</code>. Note that the same basic pattern of checking <code>err</code> is present in both functions. When <code>readFile()</code> is complete, it adds a job to the job queue that results in <code>writeFile()</code> being called (assuming no errors). Then, <code>writeFile()</code> adds a job to the job queue when it is complete.</p>

<p>While this works fairly well, you can quickly get into a pattern that has come to be known as <em>callback hell</em>. Callback hell occurs when you nest too many callbacks:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">method1</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="p">{</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">method2</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="p">{</code>

        <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="nx">method3</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="p">{</code>

            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="nx">method4</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="p">{</code>

                <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="nx">err</code><code class="p">;</code>
                <code class="p">}</code>

                <code class="nx">method5</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>
            <code class="p">});</code>

        <code class="p">});</code>

    <code class="p">});</code>

<code class="p">});</code>
</pre></div>

</figure>

<p>Nesting multiple method calls, as in this example, creates a tangled web of code that is hard to understand and debug.</p>

<p>Callbacks also present problems when you want to accomplish more complex functionality. What if you'd like two asynchronous operations to run in parallel and be notified when they both are complete? What if you'd like to kick off two asynchronous operations but only take the first one to complete? In these cases, you end up needing to keep track of multiple callbacks and cleanup operations. This is precisely where promises greatly improve the situation.</p>

<h3 id="leanpub-auto-promise-basics">Promise Basics</h3>

<p>A promise is a placeholder for the result of an asynchronous operation. Instead of subscribing to an event or passing a callback to a function, the function can return a promise, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// readFile promises to complete at some point in the future</code>
<code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">);</code>
</pre></div>

</figure>

<p>In this code, <code>readFile()</code> doesn't actually start reading the file immediately (that will happen later). It returns a promise object that represents the asynchronous operation so you can work with it later.</p>

<h4 id="leanpub-auto-lifecycle">Lifecycle</h4>

<p>Each promise goes through a short lifecycle. It starts in the <em>pending</em> state, which is an indicator that the asynchronous operation has not yet completed. The promise in the last example is in the pending state as soon as it is returned from <code>readFile()</code>. Once the asynchronous operation completes, the promise is considered <em>settled</em> and enters one of two possible states:</p>

<ol class="numeric">
  <li>
<em>Fulfilled</em> - the promise's asynchronous operation has completed successfully</li>
  <li>
<em>Rejected</em> - the promise's asynchronous operation did not complete successfully (either due to error or some other cause)</li>
</ol>

<p>You can't determine which state the promise is in programmatically, but you can take a specific action when a promise changes state by using the <code>then()</code> method.</p>

<aside class="information blurb">
    <p>There is an internal <code>[[PromiseState]]</code> property that is set to <code>"pending"</code>, <code>"fulfilled"</code>, or <code>"rejected"</code> to reflect the promise's state.</p>

</aside>

<p>The <code>then()</code> method is present on all promises and takes two arguments (any object that implements <code>then()</code> is called a <em>thenable</em>). The first argument is a function to call when the promise is fulfilled. Any additional data related to the asynchronous operation is passed into this fulfillment function. The second argument is a function to call when the promise is rejected. Similar to the fulfillment function, the rejection function is passed any additional data related to the rejection.</p>

<p>Both arguments are optional, so you can listen for any combination of fulfillment and rejection. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">);</code>

<code class="c1">// listen for both fulfillment and rejection</code>
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// fulfillment</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
<code class="p">},</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// rejection</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// listen for just fulfillment - errors are not reported</code>
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// fulfillment</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// listen for just rejection - success is not reported</code>
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// rejection</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>There is also a <code>catch()</code> method that behaves the same as <code>then()</code> when only a rejection handler is passed. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// rejection</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// is the same as:</code>

<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// rejection</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The intent is to use a combination of <code>then()</code> and <code>catch()</code> to properly handle the result of asynchronous operations. The benefit of this over both events and callbacks is that it's completely clear whether the operation succeeded or failed. (Events tend not to fire when there's an error and in callbacks you must always remember to check the error argument.)</p>

<aside class="warning blurb">
    <p>If you don't attach a rejection handler to a promise, all failures happen silently. It's a good idea to always attach a rejection handler even if it just logs the failure.</p>

</aside>

<p>One of the unique aspects of promises is that a fulfillment or rejection handler will still be executed if it is added after the promise is already settled. This allows you to add new fulfillment and rejection handlers at any point in time and be assured that they will be called. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">);</code>

<code class="c1">// original fulfillment handler</code>
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>

    <code class="c1">// now add another</code>
    <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, the fulfillment handler adds another fulfillment handler to the same promise.The promise is already fulfilled at this point, so the new fulfillment handler is added to the job queue and called when ready. Rejection handlers work the same way in that they can be added at any point and are guaranteed to be called.</p>

<aside class="information blurb">
    <p>Each call to <code>then()</code> or <code>catch()</code> creates a new job to be executed when the promise is resolved. However, these jobs end up in a separate job queue that is reserved strictly for promises. The precise details of this second job queue aren't all that important for understanding how to use promises so long as you understand how job queues work in general.</p>

</aside>

<h4 id="leanpub-auto-creating-unsettled-promises">Creating Unsettled Promises</h4>

<p>New promises are created through the <code>Promise</code> constructor. This constructor accepts a single argument, which is a function (called the <em>executor</em>) containing the code to execute when the promise is added to the job queue. The executor is passed two functions as arguments, <code>resolve()</code> and <code>reject()</code>. The <code>resolve()</code> function is called when the executor has finished successfully in order to signal that the promise is ready to be resolved while the <code>reject()</code> function indicates that the executor has failed. Here's an example using a promise in Node.js to implement the <code>readFile()</code> function from earlier in this chapter:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Node.js example</code>

<code class="kd">let</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="kd">function</code> <code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>

        <code class="c1">// trigger the asynchronous operation</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="p">{</code> <code class="nx">encoding</code><code class="o">:</code> <code class="s2">"utf8"</code> <code class="p">},</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>

            <code class="c1">// check for errors</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">reject</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
                <code class="k">return</code><code class="p">;</code>
            <code class="p">}</code>

            <code class="c1">// the read succeeded</code>
            <code class="nx">resolve</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>

        <code class="p">});</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">readFile</code><code class="p">(</code><code class="s2">"example.txt"</code><code class="p">);</code>

<code class="c1">// listen for both fulfillment and rejection</code>
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// fulfillment</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
<code class="p">},</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// rejection</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, the native Node.js <code>fs.readFile()</code> asynchronous call is wrapped in a promise. The executor either passes the error object to <code>reject()</code> or the file contents to <code>resolve()</code>.</p>

<p>Keep in mind that the executor doesn't run immediately when <code>readFile()</code> is called. Instead, it is added as a job to the job queue. This is called <em>job scheduling</em>, and if you've ever used <code>setTimeout()</code> or <code>setInterval()</code>, then you're already familiar with it. The idea is that a new job is added to the job queue so as to say, "don't execute this right now, but execute later." In the case of <code>setTimeout()</code> and <code>setInterval()</code>, you're specifying a delay before the job is added to the queue:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// add this function to the job queue after 500ms have passed</code>
<code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Timeout"</code><code class="p">);</code>
<code class="p">},</code> <code class="mi">500</code><code class="p">)</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>
</pre></div>

</figure>

<p>In this example, the code schedules a job to be added to the job queue after 500ms. That results in the following output:</p>

<figure class="code">
<div class="highlight"><pre><code class="n">Hi</code><code class="o">!</code>
<code class="n">Timeout</code>
</pre></div>

</figure>

<p>You can tell from the output that the function passed to <code>setTimeout()</code> was executed after <code>console.log("Hi!")</code>. Promises work in a similar way.</p>

<p>The promise executor is added to the job queue immediately, meaning it will execute only after all previous jobs are complete. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Promise"</code><code class="p">);</code>
    <code class="nx">resolve</code><code class="p">();</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>
</pre></div>

</figure>

<p>The output for this example is:</p>

<figure class="code">
<div class="highlight"><pre><code class="n">Hi</code><code class="o">!</code>
<code class="n">Promise</code>
</pre></div>

</figure>

<p>The takeaway is that the executor doesn't run until sometime after the current job has finished executing. The same is true for the functions passed to <code>then()</code> and <code>catch()</code>, as these will also be added to the job queue, but only after the executor job. Here's an example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Promise"</code><code class="p">);</code>
    <code class="nx">resolve</code><code class="p">();</code>
<code class="p">});</code>

<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Resolved."</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">);</code>
</pre></div>

</figure>

<p>The output for this example is:</p>

<figure class="code">
<div class="highlight"><pre><code class="n">Hi</code><code class="o">!</code>
<code class="n">Promise</code>
<code class="n">Resolved</code>
</pre></div>

</figure>

<p>The fulfillment and rejection handlers are always added to the end of the job queue after the executor has completed.</p>

<h4 id="leanpub-auto-creating-settled-promises">Creating Settled Promises</h4>

<p>The <code>Promise</code> constructor is the best way to create unsettled promises due to the dynamic nature of what the promise executor does. However, if you want a promise to represent just a single known value, then it doesn't make sense to go through the work of scheduling a job that simply passes a value to <code>resolve()</code>. Instead, there are two methods that create settled promises given a specific value.</p>

<p>The <code>Promise.resolve()</code> method accepts a single argument and returns a promise in the fulfilled state. That means there is no job scheduling that occurs and you need to add one or more fulfillment handlers to the promise to retrieve the value. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>

<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// 42</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This code creates a fulfilled promise so the fulfillment handler receives 42 as <code>value</code>. If a rejection handler were added to this promise, it would never be called because the promise will never be in the rejected state.</p>

<p>You can also create rejected promises by using the <code>Promise.reject()</code> method. This works in the same way as <code>Promise.resolve()</code> except that the created promise is in the rejected state. That means any additional rejection handlers added to the promise will be called but not fulfillment handlers will be called:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>

<code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// 42</code>
<code class="p">});</code>
</pre></div>

</figure>

<aside class="information blurb">
    <p>If you pass a promise to either <code>Promise.resolve()</code> or <code>Promise.reject()</code>, the promise is returned without modification.</p>

</aside>

<p>Both <code>Promise.resolve()</code> and <code>Promise.reject()</code> also accept non-promise thenables as arguments and will create a new promise that is called after <code>then()</code>. A non-promise thenable is created when a object has a <code>then()</code> method that accepts two arguments: <code>resolve</code> and <code>reject</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">thenable</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">then</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The <code>thenable</code> object in this example has no characteristics associated with a promise other than the <code>then()</code> method. It can be converted into a fulfilled promise using <code>Promise.resolve()</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">thenable</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">then</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">thenable</code><code class="p">);</code>
<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, <code>Promise.resolve()</code> calls <code>thenable.then()</code> so that a promise state can be determined. Since this code calls <code>resolve(42)</code>, the promise state for <code>thenable</code> is fulfilled. A new promise is created in the fulfilled state with the value passed from the thenable (42) so the fulfillment handler for <code>p1</code> receives 42 as the value. The same process can be used with <code>Promise.reject()</code> in order to create a rejected promise from a thenable:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">thenable</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">then</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">reject</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code><code class="nx">thenable</code><code class="p">);</code>
<code class="nx">p1</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This example is similar to the last except that <code>Promise.reject()</code> is used on <code>thenable</code>. Doing so executes <code>thenable.then()</code> and creates a new promise in the rejected state with a value of 42. That value is then passed to the rejection handler for <code>p1</code>.</p>

<p>Both <code>Promise.resolve()</code> and <code>Promise.reject()</code> work in this way to allow you to easily work with non-promise thenables. Whenever you're unsure if an object is a promise, passing the object through <code>Promise.resolve()</code> or <code>Promise.reject()</code> (depending on your anticipated result) is the best approach since promises are just passed through without any change.</p>

<h4 id="leanpub-auto-executor-errors">Executor Errors</h4>

<p>If an error is thrown inside of an executor, then the promise's rejection handler is called. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Explosion!"</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>     <code class="c1">// "Explosion!"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this code, the executor intentionally throws an error. There is an implicit <code>try-catch</code> inside of every executor such that the error is caught and then passed to the rejection handler. In effect, the previous example is equivalent to:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// equivalent of previous example</code>
<code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Explosion!"</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">reject</code><code class="p">(</code><code class="nx">ex</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>     <code class="c1">// "Explosion!"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The executor handles catching any thrown errors in order to simplify this common use case.</p>

<h3 id="leanpub-auto-chaining-promises">Chaining Promises</h3>

<p>To this point, promises may seem like little more than an incremental improvement over using some combination of a callback and <code>setTimeout()</code>, but there is much more to promises than meets the eye. More specifically, there are a number of ways to chain promises together to accomplish more complex asynchronous behavior.</p>

<p>Each call to <code>then()</code> or <code>catch()</code> actually creates and returns another promise. This second promise is resolved only once the first has been fulfilled or rejected. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Finished"</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>The output from this example is:</p>

<figure class="code">
<div class="highlight"><pre><code class="mi">42</code>
<code class="n">Finished</code>
</pre></div>

</figure>

<p>The call to <code>p1.then()</code> returns a second promise on which <code>then()</code> is called. The second <code>then()</code> fulfillment handler is only called after the first promise has been resolved. If you unchain this example, it looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// same as</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">})</code>

<code class="nx">p2</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Finished"</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>As you might have guessed, <code>p2.then()</code> also returns a promise, but it's not used in this example.</p>

<h4 id="leanpub-auto-catching-errors">Catching Errors</h4>

<p>Promise chaining allows you to catch errors that may occur in a fulfillment or rejection handler from a previous promise. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Boom!"</code><code class="p">);</code>
<code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>     <code class="c1">// "Boom!"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, the fulfillment handler for <code>p1</code> throws an error. The chained call to <code>catch()</code>, which is on a second promise, is able to receive that error through its rejection handler. The same is true if a rejection handler throws an error:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Explosion!"</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>     <code class="c1">// "Explosion!"</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Boom!"</code><code class="p">);</code>
<code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>     <code class="c1">// "Boom!"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Here, the executor throws an error then triggers <code>p1</code>'s rejection handler. That handler then throws another error that is caught by the second promise's rejection handler. In this way, chained promise calls can be made aware of errors in other promises in the chain.</p>

<aside class="information blurb">
    <p>It's recommended to always have a rejection handler at the end of a promise chain to ensure that you can properly handle any errors that may occur.</p>

</aside>

<h4 id="leanpub-auto-returning-values-in-promise-chains">Returning Values in Promise Chains</h4>

<p>Another important aspect of promise chains is the ability to pass data from one promise to the next. You've already seen that a value passed to the <code>resolve()</code> handler inside an executor is passed to the fulfillment handler for that promise. You can continue passing data along by specifying a return value from the fulfillment handler. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// "42"</code>
    <code class="k">return</code> <code class="nx">value</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// "43"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, the fulfillment handler for <code>p1</code> returns a value (<code>value + 1</code>). Since <code>value</code> is 42 (from the executor) then the fulfillment handler returns 43. That value is then passed to the fulfillment handler of the second promise that can output it to the console.</p>

<p>The same thing is possible using the rejection handler. When a rejection handler is called, it has the option of return a value. That value is then used to fulfill the next promise in the chain. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">reject</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// "42"</code>
    <code class="k">return</code> <code class="nx">value</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// "43"</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Here, the executor calls <code>reject()</code> with 42. That value is passed into the rejection handler for the promise, where <code>value + 1</code> is returned. Even though this return value is coming from a rejection handler, it is still used in the fulfillment handler of the next promise in the chain. This allows for the failure of one promise to allow recovery of the entire chain if necessary.</p>

<h3 id="leanpub-auto-returning-promise-in-promise-chains">Returning Promise in Promise Chains</h3>

<p>Returning primitive values from fulfillment and rejection handlers allows passing of data between promises, but what if you return an object? If the object is a promise, then there's an extra step that's taken to determine how to proceed. Consider the following example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
    <code class="k">return</code> <code class="nx">p2</code><code class="p">;</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this code, <code>p1</code> schedules a job that resolves to 42. In the fulfillment handler for <code>p1</code>, <code>p2</code>, a promise is already in the resolved state, is returned. The second fulfillment handler is called because <code>p2</code> has been fulfilled. If <code>p2</code> was rejected, the second fulfillment handler would not be called and instead a rejection handler (if present) would be called.</p>

<p>The important thing to recognize about this pattern is that the second fulfillment handler is not added to <code>p2</code>, but rather to a third promise. It's this third promise that the second fulfillment handler is attached to. The previous example is equivalent to this:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
    <code class="k">return</code> <code class="nx">p2</code><code class="p">;</code>
<code class="p">});</code>

<code class="nx">p3</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Here, it's clear that the second fulfillment handler is attached to <code>p3</code> rather than <code>p2</code>. This is a subtle but important distinction as the second fulfillment handler will not be called if <code>p2</code> is rejected. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">reject</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
    <code class="k">return</code> <code class="nx">p2</code><code class="p">;</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// never called</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, the second fulfillment handler is never called because <code>p2</code> is rejected. You could, however, attach a rejection handler instead:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">reject</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
    <code class="k">return</code> <code class="nx">p2</code><code class="p">;</code>
<code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Here, the rejection handler is called as a result of <code>p2</code> being rejected. The rejected value 43 from <code>p2</code> is passed into that rejection handler.</p>

<p>Returning thenables from fulfillment or rejection handlers doesn't change when the promise executors are executed. The first defined promise will run its executor first, followed by the second, and so on. Returning thenables simply allows you to define additional responses. You defer the execution of fulfillment handlers by creating a new promise within a fulfillment handler. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>

    <code class="c1">// create a new promise</code>
    <code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">resolve</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
    <code class="p">});</code>

    <code class="k">return</code> <code class="nx">p2</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, a new promise is created within the fulfillment handler for <code>p1</code>. That means the second fulfillment handler will not be executed until after <code>p2</code> has been fulfilled. This pattern useful when you want to wait until a previous promise has been settled before before triggering another promise.</p>

<h3 id="leanpub-auto-responding-to-multiple-promises">Responding to Multiple Promises</h3>

<p>Up to this point, each example has dealt with responding to one promise at a time. There are times, however, when you'll want to monitor the progress of multiple promises in order to determine the next action. ECMAScript 6 provides two methods that monitor multiple promises: <code>Promise.all()</code> and <code>Promise.race()</code>.</p>

<h4 id="leanpub-auto-promiseall">Promise.all()</h4>

<p>The <code>Promise.all()</code> method accepts a single argument, which is an iterable of promises to monitor, and returns a promise that is resolved only when every promise in the iterable is resolved. The returned promise is fulfilled when every promise in the iterable is fulfilled, for example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">44</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code><code class="nx">p1</code><code class="p">,</code> <code class="nx">p2</code><code class="p">,</code> <code class="nx">p3</code><code class="p">]);</code>

<code class="nx">p4</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// [42, 43, 44]</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Each of the promises in this example resolves with a number. The call to <code>Promise.all()</code> creates a new promise, <code>p4</code>, that ultimately is fulfilled because each of the promises is fulfilled. The result passed to the fulfillment handler for <code>p4</code> is an array containing each resolved value: 42, 43, and 44. In this way, you can match promise results to the promises that resolved to them.</p>

<p>If any of the promises passed to <code>Promise.all()</code> is rejected, the returned promise is immediately rejected without waiting for the other promises to complete:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">reject</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">44</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code><code class="nx">p1</code><code class="p">,</code> <code class="nx">p2</code><code class="p">,</code> <code class="nx">p3</code><code class="p">]);</code>

<code class="nx">p4</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, <code>p2</code> is rejected with a value of 43. The rejection handler for <code>p4</code> is called immediately without waiting for either <code>p1</code> or <code>p3</code> to finish executing (they still finish executing, it's just that <code>p4</code> doesn't wait). The rejection handler is passed 43 to reflect the rejection from <code>p2</code>.</p>

<h4 id="leanpub-auto-promiserace">Promise.race()</h4>

<p>The <code>Promise.race()</code> method provides a slightly different take on monitoring multiple promises. This method also accepts an iterable of promises to monitor and returns a promise, however, the returned promise is settled as soon as the first promise is settled. So instead of waiting for all promises to be fulfilled, as in <code>Promise.all()</code>, the returned promise is fulfilled as soon as any of the promises is fulfilled. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">44</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">([</code><code class="nx">p1</code><code class="p">,</code> <code class="nx">p2</code><code class="p">,</code> <code class="nx">p3</code><code class="p">]);</code>

<code class="nx">p4</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 42</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this code, <code>p1</code> is created as a fulfilled promise while the others schedule jobs. The fulfillment handler for <code>p4</code> is then called with the value of 42 and ignores the other promises completely. The promises passed to <code>Promise.race()</code> are truly in a race to see which is settled first. If the first promise to settle is fulfilled, then the returned promise is fulfilled; if the first promise to settle is rejected, then the returned promise is rejected. Here's an example with a rejection:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code><code class="mi">43</code><code class="p">);</code>

<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">44</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">([</code><code class="nx">p1</code><code class="p">,</code> <code class="nx">p2</code><code class="p">,</code> <code class="nx">p3</code><code class="p">]);</code>

<code class="nx">p4</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>     <code class="c1">// 43</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Here, <code>p4</code> is rejected because <code>p2</code> is already in the rejected state when <code>Promise.race()</code> is called. Even though <code>p1</code> and <code>p3</code> are fulfilled, those results are ignored because they occur after <code>p2</code> is rejected.</p>

<h4 id="leanpub-auto-asynchronous-task-scheduling-1">Asynchronous Task Scheduling</h4>

<p>Back in chapter 8, you learned about generators and how they can be used for asynchronous task scheduling such as the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="kd">let</code> <code class="nx">task</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">task</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code><code class="nx">init</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">contents</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">readConfigFile</code><code class="p">();</code>
    <code class="nx">doSomethingWith</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Done"</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">task</code> <code class="o">=</code> <code class="nx">init</code><code class="p">();</code>
<code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
</pre></div>

</figure>

<p>The pain point of this implementation was needing to keep track of <code>task</code> and calling the appropriate methods on it in every single asynchronous function you use (such as <code>readConfigFile()</code>). With promises, you can greatly simplify and generalize this process by ensuring that each asynchronous operation returns a promise. That common interface means you can greatly simplify asynchronous code:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="kd">function</code> <code class="nx">run</code><code class="p">(</code><code class="nx">taskDef</code><code class="p">)</code> <code class="p">{</code>

    <code class="c1">// create the iterator</code>
    <code class="kd">let</code> <code class="nx">task</code> <code class="o">=</code> <code class="nx">taskDef</code><code class="p">();</code>

    <code class="c1">// start the task</code>
    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

    <code class="c1">// recursive function to iterate through</code>
    <code class="p">(</code><code class="kd">function</code> <code class="nx">step</code><code class="p">()</code> <code class="p">{</code>

        <code class="c1">// if there's more to do</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">result</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>

            <code class="c1">// resolve to a promise to make it easy</code>
            <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
            <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">result</code> <code class="o">=</code> <code class="nx">task</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
                <code class="nx">step</code><code class="p">();</code>
            <code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">result</code> <code class="o">=</code> <code class="nx">task</code><code class="p">.</code><code class="k">throw</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
                <code class="nx">step</code><code class="p">();</code>
            <code class="p">});</code>
        <code class="p">}</code>
    <code class="p">}());</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">contents</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">reject</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="nx">resolve</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">});</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nx">run</code><code class="p">(</code><code class="kd">function</code> <code class="o">*</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">contents</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">readConfigFile</code><code class="p">();</code>
    <code class="nx">doSomethingWith</code><code class="p">(</code><code class="nx">contents</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Done"</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this version of the code, a generic <code>run()</code> function is used to execute a generator. The <code>run()</code> function executes the generator to create an iterator, starts the task by calling <code>task.next()</code>, and then recursively calls <code>step()</code> until the iterator is complete. Inside of <code>step()</code>, if there's more work to do then <code>result.done</code> is <code>false</code>. At that point, <code>result.value</code> should be a promise, but <code>Promise.resolve()</code> is used just in case the function in question didn't return a promise. Then, a fulfillment handler is added that retrieves the promise value and passes it back to the iterator and <code>result</code> is assigned to the next yield result before calling <code>step()</code>. A rejection handler is also added and assumes any rejection results in an error object. That error object is passed back into the iterator using <code>task.throw()</code> and <code>result</code> is assigned to the next yield result if the error is catched in the task, and then <code>step()</code> is called to continue.</p>

<p>This same <code>run()</code> function can be used to run any generator that uses <code>yield</code> as a way to achieve asynchronous code without exposing promises (or callbacks) to the developer.</p>

<h3 id="leanpub-auto-inheriting-from-promises">Inheriting from Promises</h3>

<p>Just like other built-in types, promises can be used as a base upon which you can create a derived class. This allows you to define your own variation of promises to extend what the built-in promises can do. Suppose, for instance, you'd like to create a promise that uses <code>success()</code> and <code>failure()</code> in addition to <code>then()</code> and <code>catch()</code>. You could do so as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">class</code> <code class="nx">MyPromise</code> <code class="kr">extends</code> <code class="nx">Promise</code> <code class="p">{</code>

    <code class="c1">// use default constructor</code>

    <code class="nx">success</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="nx">failure</code><code class="p">(</code><code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">reject</code><code class="p">);</code>
    <code class="p">}</code>

<code class="p">}</code>

<code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyPromise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">promise</code><code class="p">.</code><code class="nx">success</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>             <code class="c1">// 42</code>
<code class="p">}).</code><code class="nx">failure</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>In this example, <code>MyPromise</code> is derived from <code>Promise</code> and two additional methods are added. Both <code>success()</code> and <code>failure()</code> use <code>this</code> to call the appropriate method they are mimicking. The created promise functions the same as the built-in version, except now you can use <code>success()</code> and <code>failure()</code> in addition to <code>then()</code> and <code>catch()</code>.</p>

<p>Since static methods are also inherited, that means <code>MyPromise.resolve()</code>, <code>MyPromise.reject()</code>, <code>MyPromise.race()</code>, and <code>MyPromise.all()</code> are also present. While the last two behave the same as the built-in methods, the first two are slightly different.</p>

<p>Both <code>MyPromise.resolve()</code> and <code>MyPromise.reject()</code> will return an instance of <code>MyPromise</code> regardless of the value passed. So if a built-in promise is passed to either, it will be resolved or rejected and a new <code>MyPromise</code> so you can assign fulfillment and rejection handlers. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="nx">MyPromise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">p1</code><code class="p">);</code>
<code class="nx">p2</code><code class="p">.</code><code class="nx">success</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>         <code class="c1">// 42</code>
<code class="p">});</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p2</code> <code class="k">instanceof</code> <code class="nx">MyPromise</code><code class="p">);</code>   <code class="c1">// true</code>
</pre></div>

</figure>

<p>Here, <code>p1</code> is a built-in promise that is passed to <code>MyPromise.resolve()</code>. The result, <code>p2</code>, is an instance of <code>MyPromise</code> where the resolved value from <code>p1</code> is passed into the fulfillment handler.</p>

<p>If an instance of <code>MyPromise</code> is passed to <code>MyPromise.resolve()</code> or <code>MyPromise.reject()</code>, it will just be returned directly without being resolved. In all other ways these two methods behave the same as <code>Promise.resolve()</code> and <code>Promise.reject()</code>.</p>

<h3 id="leanpub-auto-summary-8">Summary</h3>

<p>Promises are designed to improve asynchronous programming in JavaScript. Whereas events and callbacks have several limitations, the permutations available via promises mean more control and composability over asynchronous operations. This is accomplished by scheduling jobs to be added to the JavaScript engine's job queue for execution later. A second job queue keeps track of promise fulfillment and rejection handlers to ensure proper execution.</p>

<p>Promises have three states: pending, fulfilled, and rejected. A promise starts out in a pending state and is either fulfilled (a success) or rejected (a failure). In either case, handlers can be added to be notified when a promise is settled. The <code>then()</code> method allows you to assign a fulfillment and rejection handler and the <code>catch()</code> method allows you to assign only a rejection handler.</p>

<p>You can chain promises together in a variety of ways and pass information between them. Each call to <code>then()</code> creates and returns a new promise that is resolved when the previous one is resolved. Such chains can be used to trigger responses to a series of asynchronous events. You can also use <code>Promise.race()</code> and <code>Promise.all()</code> to monitor the progress of multiple promises and respond accordingly.</p>

<p>Asynchronous task scheduling is made easier using generators in addition to promises, as promises give a common interface that asynchronous operations can return. You can then use generators and the <code>yield</code> operator to wait for asynchronous responses and respond appropriately.</p>

<p>Most new web APIs are being built on top of promises, and you can expect many more to follow suit in the future.</p>

<h2 id="leanpub-auto-modules">Modules</h2>

<p>One of the most error-prone and confusing aspects of JavaScript has long been the "shared everything" approach to loading code. Whereas other languages have concepts such as packages, JavaScript lagged behind, and everything defined in every file shared the same global scope. As web applications became more complex and the amount of JavaScript used grew, the "shared everything" approach began to show problems with naming collisions, security concerns, and more. One of the goals of ECMAScript 6 was to solve this problem and bring some order into JavaScript applications. That's where modules come in.</p>

<h3 id="leanpub-auto-what-are-modules">What are Modules?</h3>

<p><em>Modules</em> are JavaScript files that are loaded in a special mode (as opposed to <em>scripts</em>, which are loaded in the original way JavaScript worked). At the time of my writing, neither browsers nor Node.js have a way to natively load ECMAScript 6 modules, but both have indicated that there will need to be some sort of opt-in to do so. The reason this opt-in is necessary is because module files have very different semantics than non-module files:</p>

<ol class="numeric">
  <li>Module code automatically runs in strict mode and there's no way to opt-out of strict mode.</li>
  <li>Variables created in the top level of a module are not automatically added to the shared global scope. They exist only within the top-level scope of the module.</li>
  <li>The value of <code>this</code> in the top level of a module is <code>undefined</code>.</li>
  <li>Does not allow HTML-style comments within the code (a leftover feature from the early browser days).</li>
  <li>Modules must export anything that should be available to code outside of the module.</li>
</ol>

<p>These differences may seem small at first glance, however, they represent a significant change in how JavaScript code is loaded and evaluated.</p>

<p>Module JavaScript files are created just like any other JavaScript file: in a text editor and typically with the <code>.js</code> extension. The only difference during development is that you use some different syntax.</p>

<h3 id="leanpub-auto-basic-exporting-and-importing">Basic Exporting and Importing</h3>

<p>The <code>export</code> keyword is used to expose parts of published code to other modules. In the simplest case, you can place <code>export</code> in front of any variable, function, or class declaration to export it from the module. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// export data</code>
<code class="kr">export</code> <code class="kd">var</code> <code class="nx">color</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">magicNumber</code> <code class="o">=</code> <code class="mi">7</code><code class="p">;</code>

<code class="c1">// export function</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num1</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// export class</code>
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">Rectangle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">length</code><code class="p">,</code> <code class="nx">width</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">length</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// this function is private to the module</code>
<code class="kd">function</code> <code class="nx">subtract</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">-</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// define a function</code>
<code class="kd">function</code> <code class="nx">multiply</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">*</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// export later</code>
<code class="kr">export</code> <code class="nx">multiply</code><code class="p">;</code>
</pre></div>

</figure>

<p>There are a few things to notice in this example:</p>

<ol class="numeric">
  <li>Every declaration is exactly the same as it would otherwise be without the <code>export</code> keyword.</li>
  <li>Both function and class declarations require a name. You cannot export anonymous functions or classes using this syntax.</li>
  <li>You need not always export the declaration, you can also export references, as with <code>multiply</code> in this example.</li>
  <li>Any variables, functions, or classes that are not explicitly exported remain private to the module. In this example, <code>subtract()</code> is not exported and is therefore not accessible from outside the module.</li>
</ol>

<p>An important limitation of <code>export</code> is that it must be used in the top-level of the module. For instance, this is a syntax error:</p>

<figure class="code">
<div class="highlight"><pre><code class="k">if</code> <code class="p">(</code><code class="nx">flag</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">export</code> <code class="nx">flag</code><code class="p">;</code>    <code class="c1">// syntax error</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This example is a syntax error because <code>export</code> is inside of an <code>if</code> statement. Exports cannot be condition or done dynamically in any way. Part of the benefit of module syntax is so the JavaScript engine can staticly determine what will be exported. As such, you can only use <code>export</code> at the top-level of a module.</p>

<aside class="warning blurb">
    <p>If you are using a transpiler like Babel.js, you may find that <code>export</code> can be used anywhere. This only works when code is converted to ECMAScript 5 and will not work with a native ECMAScript 6 module system.</p>

</aside>

<p>Once you have a module with exports, you can access the functionality in another module by using the <code>import</code> keyword. An <code>import</code> statement has two parts: the identifiers you're importing and the module from which those identifiers should be imported. The basic form is as follows:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">identifier1</code><code class="p">,</code> <code class="nx">identifier2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"module"</code><code class="p">;</code>
</pre></div>

</figure>

<p>The curly braces after <code>import</code> indicate the identifiers to import from the given module. The keyword <code>from</code> is used to indicate the module from which to import the given identifiers. The module is specified using a string. At the time of my writing, it is still undecided what module identifiers will look like. They may end up being full file paths (such as "../mymodule.js"), file paths without extensions (such as "../mymodule"), or something else. This likely won't be determined until browsers and Node.js begin implementing modules natively.</p>

<aside class="information blurb">
    <p>Even though it looks similar, the list of identifiers to import is not a destructured object.</p>

</aside>

<p>When importing an identifier from a module, the identifier acts as if were defined using <code>const</code>. That means you cannot define another variable with the same name, use the identifier prior to the <code>import</code> statement, or change its value.</p>

<p>Suppose that the first example in this section is in a module named <code>"example"</code>. You can import and use identifiers from that module in a number of ways. You can just import one identifier:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// import just one</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">sum</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>     <code class="c1">// 3</code>

<code class="nx">sum</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>        <code class="c1">// error</code>
</pre></div>

</figure>

<p>This example imports only <code>sum()</code> from the example module. Even though the example module exports more than just that one function, they are not exposed here. If you try to assign a new value to <code>sum</code>, the result is an error, as you cannot reassign imported identifiers.</p>

<p>If you want to import multiple identifiers from the example module, you can explicitly list them out:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// import multiple</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">sum</code><code class="p">,</code> <code class="nx">multiply</code><code class="p">,</code> <code class="nx">magicNumber</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="nx">magicNumber</code><code class="p">));</code>   <code class="c1">// 8</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">multiply</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>        <code class="c1">// 2</code>
</pre></div>

</figure>

<p>Here, three identifiers are imported from the example module: <code>sum</code>, <code>multiply</code>, and <code>magicNumber</code>. They are then used as if they were locally defined.</p>

<p>There's also a special case that allows you to import the entire module as a single object. All of the exports are then available on that object as properties. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// import everything</code>
<code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">example</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">example</code><code class="p">.</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code>
        <code class="nx">example</code><code class="p">.</code><code class="nx">magicNumber</code><code class="p">));</code>          <code class="c1">// 8</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">example</code><code class="p">.</code><code class="nx">multiply</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>    <code class="c1">// 2</code>
</pre></div>

</figure>

<p>In this code, the entirety of the example module is loaded into an object called <code>example</code>. The named exports <code>sum()</code>, <code>multiple()</code>, and <code>magicNumber</code> are then accessible as properties on <code>example</code>.</p>

<p>Keep in mind that the code inside of a module will only ever be executed once, regardless of the number of times it's used in an <code>import</code> statement. Consider the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">sum</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">multiply</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">magicNumber</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
</pre></div>

</figure>

<p>Even though there are three <code>import</code> statements in this module, the code in <code>"example"</code> will only be executed once. The instantiated module is then kept in memory and reused whenever another <code>import</code> statement references it. It doesn't matter if the <code>import</code> statements are all in the module, or are spread across multiple modules - they each will use the same module instance.</p>

<h3 id="leanpub-auto-renaming-exports-and-imports">Renaming Exports and Imports</h3>

<p>Sometimes the original name of a variable, function, or class isn't what you want to use. It's possible to change the name of an export both during the export and when the identifier is being imported.</p>

<p>In the first case, suppose you have a function that you'd like to export with a different name. You can use the <code>as</code> keyword to specify the name that the function should be known as outside of the module:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">sum</code> <code class="nx">as</code> <code class="nx">add</code> <code class="p">};</code>
</pre></div>

</figure>

<p>Here, the <code>sum()</code> function (<code>sum</code> is the <em>local name</em>) is exported as <code>add()</code> (<code>add</code> is the <em>exported name</em>). That means when another module wants to import this function, it will have to use the name <code>add</code> instead:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">add</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
</pre></div>

</figure>

<p>If the module importing the function wants to use a different name, it can also use <code>as</code>:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">add</code> <code class="nx">as</code> <code class="nx">sum</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">add</code><code class="p">);</code>            <code class="c1">// "undefined"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>             <code class="c1">// 3</code>
</pre></div>

</figure>

<p>This code imports the <code>add()</code> function (the <em>import name</em>) and renames it to <code>sum()</code> (the local name). That means there is no identifier named <code>add</code> in this module.</p>

<aside>
  <h4 id="leanpub-auto-imported-bindings">Imported Bindings</h4>

  <p>A subtle but important point about the <code>import</code> statements is that they create bindings to variables, functions, and classes rather than simply referencing them. That means even though you cannot change an imported identifier, it can still change on its own. For example, suppose you have this module:</p>

  <figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">setName</code><code class="p">(</code><code class="nx">newName</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">name</code> <code class="o">=</code> <code class="nx">newName</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

  </figure>

  <p>When you import <code>name</code> and <code>setName()</code>, you can see that <code>setName()</code> is able to change the value of <code>name</code>:</p>

  <figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">setName</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>       <code class="c1">// "Nicholas"</code>
<code class="nx">setName</code><code class="p">(</code><code class="s2">"Greg"</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>       <code class="c1">// "Greg"</code>

<code class="nx">name</code> <code class="o">=</code> <code class="s2">"Nicholas"</code><code class="p">;</code>       <code class="c1">// error</code>
</pre></div>

  </figure>

  <p>The call to <code>setName("Greg")</code> goes back into the module from which <code>setName()</code> was exported and executes there, setting <code>name</code> to <code>"Greg"</code>. Note this change is automatically reflected on the imported <code>name</code> binding. That's because <code>name</code> is the local name for the exported <em>name</em> identifier so they are not the same thing.</p>

</aside>

<h3 id="leanpub-auto-exporting-and-importing-defaults">Exporting and Importing Defaults</h3>

<p>The module syntax is really optimized for exporting and importing default values from modules. The default value for a module is a single variable, function, or class as specified by the <code>default</code> keyword. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This module exports a function as the default. The <code>default</code> keyword indicates that this is a default export and the function doesn't require a name because the module itself represents the function.</p>

<p>You can also specify an identifier as being the default export using the renaming syntax, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// equivalent to previous example</code>
<code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">sum</code> <code class="nx">as</code> <code class="k">default</code> <code class="p">};</code>
</pre></div>

</figure>

<p>The <code>as default</code> specifies that <code>sum</code> should be the default export of the module. This syntax is equivalent to the previous example.</p>

<aside class="warning blurb">
    <p>You can only have one default export per module. It is a syntax error to use the <code>default</code> keyword with multiple exports.</p>

</aside>

<p>You can import a default value from a module using the following syntax:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// import the default</code>
<code class="kr">import</code> <code class="nx">sum</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>     <code class="c1">// 3</code>
</pre></div>

</figure>

<p>This import statement imports the default from the module <code>"example"</code>. Note that there are no curly braces used in this case, as would be with a non-default export. The local name <code>sum</code> is used to represent the function that the module exports. This syntax is the cleanest as it's anticipated to be the dominant form of import on the web, allowing you to use already-existing object, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="nx">$</code> <code class="nx">from</code> <code class="s2">"jquery"</code><code class="p">;</code>
</pre></div>

</figure>

<p>For modules that export both a default and one or more non-defaults, you can import them with one statment. For instance, suppose you have this module:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="kd">let</code> <code class="nx">color</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>

<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>You can then import both <code>color</code> and the default function using the following:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="nx">sum</code><code class="p">,</code> <code class="p">{</code> <code class="nx">color</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>     <code class="c1">// 3</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color</code><code class="p">);</code>         <code class="c1">// "red"</code>
</pre></div>

</figure>

<p>The comma separates the default local name from the non-defaults (which are also surrounded by curly braces).</p>

<p>As with exporting defaults, importing defaults can also be accomplished using the renaming syntax:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// equivalent to previous example</code>
<code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="nx">as</code> <code class="nx">sum</code><code class="p">,</code> <code class="nx">color</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>     <code class="c1">// 3</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color</code><code class="p">);</code>         <code class="c1">// "red"</code>
</pre></div>

</figure>

<p>In this code, the default export (<code>default</code>) is renamed to <code>sum</code> and the additional <code>color</code> export is also imported. This example is equivalent to the previous example.</p>

<h3 id="leanpub-auto-re-exporting">Re-exporting</h3>

<p>There may be a time when you'd like to re-export something that your module has imported. You can do this using the patterns already discussed in this chapter, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="p">{</code> <code class="nx">sum</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">sum</code> <code class="p">}</code>
</pre></div>

</figure>

<p>However, there's also a single statement that can accomplish the same thing:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="p">{</code> <code class="nx">sum</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
</pre></div>

</figure>

<p>This form of <code>export</code> looks into the specified module for the declaration of <code>sum</code> and then exports it. Of course, you can also choose to export a different name for the same thing:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="p">{</code> <code class="nx">sum</code> <code class="nx">as</code> <code class="nx">add</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
</pre></div>

</figure>

<p>Here, <code>sum</code> is imported from <code>"example"</code> and then exported as <code>add</code>.</p>

<p>If you'd like to export everything from another module, you can use the <code>*</code> pattern:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">export</code> <code class="o">*</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>
</pre></div>

</figure>

<p>By exporting everything, you're including the default as well as any named exports, which may affect what you can export from your module. For instance, if <code>"example"</code> has a default export, you'll be unable to define a new default export when using this syntax.</p>

<h3 id="leanpub-auto-importing-without-bindings">Importing Without Bindings</h3>

<p>Some modules may not export anything, and instead, only make modifications to objects in the global scope. Even though top-level variables, functions, and classes inside of modules do not automatically end up in the global scope, that doesn't mean modules cannot access the global scope. The shared definitions of built-in objects such as <code>Array</code> and <code>Object</code> are accessible inside of a module and changes to those objects will be reflected in other modules.</p>

<p>For instance, suppose you want to add a method to all arrays called <code>pushAll()</code>, you may define a module like this:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// module code without exports or imports</code>
<code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">pushAll</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>

    <code class="c1">// items must be an array</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">items</code><code class="p">))</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Argument must be an array."</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// use built-in push() and spread operator</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">push</code><code class="p">(...</code><code class="nx">items</code><code class="p">);</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This is a valid module even though there are no exports or imports. This code can be used both as a module and a script. Since it doesn't export anything, you can use a simplified import to execute the module code without importing any bindings:</p>

<figure class="code">
<div class="highlight"><pre><code class="kr">import</code> <code class="nx">from</code> <code class="s2">"example"</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code><code class="p">];</code>
<code class="kd">let</code> <code class="nx">items</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nx">items</code><code class="p">.</code><code class="nx">pushAll</code><code class="p">(</code><code class="nx">colors</code><code class="p">);</code>
</pre></div>

</figure>

<p>In this example, the module is imported and executed, so <code>pushAll()</code> is added to the array prototype. That means <code>pushAll()</code> is now available for use on all arrays inside of this module.</p>

<aside class="information blurb">
    <p>Imports without bindings are most likely to be used to create polyfills and shims.</p>

</aside>

<h3 id="leanpub-auto-summary-9">Summary</h3>

<p>ECMAScript 6 adds modules to the language as a way to package up and encapsulate functionality. Modules behave differently than scripts, as they do not modify the global scope with their top-level variables, functions, and classes, and <code>this</code> is <code>undefined</code>. In order to work differently than scripts, modules must be loaded using a different mode.</p>

<p>You must export any functionality you'd like to make available to consumers of a module. Variables, functions, and classes can all be exported, and there is also one default export allowed per module. After exporting, another module can import all or some of the exported names. These names act as if defined by <code>let</code>, and so operate as block bindings that cannot be redeclared in the same module.</p>

<p>Modules need not export anything if they are manipulating something in the global scope. In that case, it's possible to import from such a module without introducing any bindings into the module scope.</p>

<h2 id="leanpub-auto-appendix-a-other-changes">Appendix A: Other Changes</h2>

<p>Along with the changes already mentioned in the book, ECMAScript 6 has made some very small changes and improvements. This appendix lists out those changes.</p>

<h3 id="leanpub-auto-working-with-integers">Working with Integers</h3>

<p>A lot of confusion has been caused over the years related to JavaScript's single number type that is used to represent both integers and floats. The language goes through great pains to ensure that developers don't need to worry about the details, but problems still leak through from time to time. ECMAScript 6 seeks to address this by making it easier to identify and work with integers.</p>

<h4 id="leanpub-auto-identifying-integers">Identifying Integers</h4>

<p>The first addition is <code>Number.isInteger()</code>, which allows you to determine if a value represents an integer in JavaScript. Since integers and floats are stored differently, the JavaScript engine looks at the underlying representation of the value to make this determination. That means numbers that look like floats might actually be stored as integers and therefore return <code>true</code> from <code>Number.isInteger()</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="mi">25</code><code class="p">));</code>      <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="mf">25.0</code><code class="p">));</code>    <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="mf">25.1</code><code class="p">));</code>    <code class="c1">// false</code>
</pre></div>

</figure>

<p>In this code, <code>Number.isInteger()</code> returns <code>true</code> for both <code>25</code> and <code>25.0</code> even though the latter looks like a float. Simply adding a decimal point to a number doesn't automatically make it a float in JavaScript. Since <code>25.0</code> is really just <code>25</code>, it is stored as an integer. The number <code>25.1</code>, however, is stored as a float because there is a fraction value.</p>

<h4 id="leanpub-auto-safe-integers">Safe Integers</h4>

<p>However, all is not so simple with integers. JavaScript can only accurately represent integers between -2<sup>53</sup> and 2<sup>53</sup>, and outside of this "safe" range, binary representations end up reused for multiple numeric values. For example:</p>

<figure class="code">
<div class="highlight"><pre><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">53</code><code class="p">));</code>      <code class="c1">// 9007199254740992</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">53</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>  <code class="c1">// 9007199254740992</code>
</pre></div>

</figure>

<p>This example doesn't contain a typo, two different numbers end up represented by the same JavaScript integer. The effect becomes more prevalent the further the value is outside of the safe range.</p>

<p>ECMAScript 6 introduces <code>Number.isSafeInteger()</code> to better identify integers that can accurately be represented in the language. There is also <code>Number.MAX_SAFE_INTEGER</code> and <code>Number.MIN_SAFE_INTEGER</code> that represent the upper and lower bounds of the same range, respectively. The <code>Number.isSafeInteger()</code> method ensures that a value is an integer and falls within the safe range of integer values:</p>

<figure class="code">
<div class="highlight"><pre><code class="kd">var</code> <code class="nx">inside</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code><code class="p">,</code>
    <code class="nx">outside</code> <code class="o">=</code> <code class="nx">inside</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">inside</code><code class="p">));</code>          <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code><code class="nx">inside</code><code class="p">));</code>      <code class="c1">// true</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">outside</code><code class="p">));</code>         <code class="c1">// true</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code><code class="nx">outside</code><code class="p">));</code>     <code class="c1">// false</code>
</pre></div>

</figure>

<p>The number <code>inside</code> is the largest safe integer, so it returns <code>true</code> for both <code>Number.isInteger()</code> and <code>Number.isSafeInteger()</code>. The number <code>outside</code> is the first questionable integer value, so it is no longer considered safe even though it's still an integer.</p>

<p>Most of the time, you only want to deal with safe integers when doing integer arithmetic or comparisons in JavaScript, so it's a good idea to use <code>Number.isSafeInteger()</code> as part of input validation.</p>

<h3 id="leanpub-auto-new-math-methods">New Math Methods</h3>

<p>The aforementioned new emphasis on gaming and graphics in JavaScript led to the realization that many mathematical calculations could be done more efficiently by a JavaScript engine than with pure JavaScript code. Optimization strategies like asm.js, which works on a subset of JavaScript to improve performance, need more information to perform calculations in the fastest way possible. It's important, for instance, to know whether the numbers should be treated as 32-bit integers or as 64-bit floats.</p>

<p>As a result, ECMAScript 6 adds several new methods to the <code>Math</code> object. These new methods are important for improving the speed of common mathematical calculations, and therefore, improving the speed of applications that must perform many calculations (such as graphics programs). The new methods are listed below.</p>

<table style="width: 80%;">
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Math.acosh(x)</code></td>
      <td>Returns the inverse hyperbolic cosine of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.asinh(x)</code></td>
      <td>Returns the inverse hyperbolic sine of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.atanh(x)</code></td>
      <td>Returns the inverse hyperbolic tangent of <code>x</code>
</td>
    </tr>
    <tr>
      <td><code>Math.cbrt(x)</code></td>
      <td>Returns the cubed root of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.clz32(x)</code></td>
      <td>Returns the number of leading zero bits in the 32-bit integer representation of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.cosh(x)</code></td>
      <td>Returns the hyperbolic cosine of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.expm1(x)</code></td>
      <td>Returns the result of subtracting 1 from the exponential function of <code>x</code>
</td>
    </tr>
    <tr>
      <td><code>Math.fround(x)</code></td>
      <td>Returns the nearest single-precision float of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.hypot(...values)</code></td>
      <td>Returns the square root of the sum of the squares of each argument.</td>
    </tr>
    <tr>
      <td><code>Math.imul(x, y)</code></td>
      <td>Returns the result of performing true 32-bit multiplication of the two arguments.</td>
    </tr>
    <tr>
      <td><code>Math.log1p(x)</code></td>
      <td>Returns the natural logarithm of <code>1 + x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.log10(x)</code></td>
      <td>Returns the base 10 logarithm of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.log2(x)</code></td>
      <td>Returns the base 2 logarithm of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.sign(x)</code></td>
      <td>Returns -1 if the <code>x</code> is negative, 0 if <code>x</code> is +0 or -0, or 1 if <code>x</code> is positive.</td>
    </tr>
    <tr>
      <td><code>Math.sinh(x)</code></td>
      <td>Returns the hyperbolic sine of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.tanh(x)</code></td>
      <td>Returns the hyperbolic tangent of <code>x</code>.</td>
    </tr>
    <tr>
      <td><code>Math.trunc(x)</code></td>
      <td>Removes fraction digits from a float and returns an integer.</td>
    </tr>
  </tbody>

</table>

<p>It's beyond the scope of this book to explain each new method and what it does in detail. However, if you are looking for a reasonably common calculation, be sure to check the new <code>Math</code> methods before implementing it yourself.</p>

<h3 id="leanpub-auto-unicode-identifiers">Unicode Identifiers</h3>

<p>Better Unicode support in ECMAScript 6 also means changes to what characters may be used for an identifier. In ECMAScript 5, it was already possible to use Unicode escape sequences for identifiers, such as:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Valid in ECMAScript 5 and 6</code>
<code class="kd">var</code> <code class="err">\</code><code class="nx">u0061</code> <code class="o">=</code> <code class="s2">"abc"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">\</code><code class="nx">u0061</code><code class="p">);</code>        <code class="c1">// "abc"</code>

<code class="c1">// equivalent to</code>
<code class="c1">// console.log(a);          // "abc"</code>
</pre></div>

</figure>

<p>In ECMAScript 6, you can also use Unicode code point escape sequences as identifiers:</p>

<figure class="code">
<div class="highlight"><pre><code class="c1">// Valid in ECMAScript 5 and 6</code>
<code class="kd">var</code> <code class="err">\</code><code class="nx">u</code><code class="p">{</code><code class="mi">61</code><code class="p">}</code> <code class="o">=</code> <code class="s2">"abc"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">\</code><code class="nx">u</code><code class="p">{</code><code class="mi">61</code><code class="p">});</code>        <code class="c1">// "abc"</code>

<code class="c1">// equivalent to</code>
<code class="c1">// console.log(a);          // "abc"</code>
</pre></div>

</figure>

<p>Additionally, ECMAScript 6 formally specifies valid identifiers in terms of <a href="http://unicode.org/reports/tr31/">Unicode Standard Annex #31: Unicode Identifier and Pattern Syntax</a>:</p>

<ol class="numeric">
  <li>The first character must be <code>$</code>, <code>_</code>, or any Unicode symbol with a derived core property of <code>ID_Start</code>.</li>
  <li>Each subsequent character must be <code>$</code>, <code>_</code>, <code>\u200c</code> (zero-width non-joiner), <code>\u200d</code> (zero-width joiner), or any Unicode symbol with a derived core property of <code>ID_Continue</code>.</li>
</ol>

<p>The <code>ID_Start</code> and <code>ID_Continue</code> derived core properties are defined in Unicode Identifier and Pattern Syntax as a way to identify symbols that are appropriate for use in identifiers such as variables and domain names (the specification is not specific to JavaScript).</p>


</div>


</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<div class="read">

<h1>
ECMAScript 2015
</h1>
<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="#leanpub-auto-es6-guide">ES6-guide</a>
  </li>
  <li>
    <a href="#leanpub-auto-let--const">let + const</a>
    <ul>
      <li>
        <a href="#leanpub-auto-let">let</a>
      </li>
      <li>
        <a href="#leanpub-auto-const">const</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-arrow-functions">arrow functions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-syntactic-sugar">Syntactic sugar</a>
      </li>
      <li>
        <a href="#leanpub-auto-fixed-this--lexical-this">Fixed "this" = lexical "this"</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-same-function">The same function</a>
      </li>
      <li>
        <a href="#leanpub-auto-limitations">Limitations</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-default--rest--spread">default + rest + spread</a>
    <ul>
      <li>
        <a href="#leanpub-auto-default">default</a>
      </li>
      <li>
        <a href="#leanpub-auto-rest">rest</a>
      </li>
      <li>
        <a href="#leanpub-auto-spread">spread</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-destructuring">destructuring</a>
    <ul>
      <li>
        <a href="#leanpub-auto-arrays">arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-objects">objects</a>
      </li>
      <li>
        <a href="#leanpub-auto-mixed">mixed</a>
      </li>
      <li>
        <a href="#leanpub-auto-attention">attention!</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-strings">strings</a>
    <ul>
      <li>
        <a href="#leanpub-auto-template-strings">template strings</a>
      </li>
      <li>
        <a href="#leanpub-auto-extended-support-for-unicode">extended support for Unicode</a>
      </li>
      <li>
        <a href="#leanpub-auto-strings-are-iterable">strings are iterable</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-string-methods">new string methods</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-iterators">iterators</a>
    <ul>
      <li>
        <a href="#leanpub-auto-iterator--iterable">iterator &amp; iterable</a>
      </li>
      <li>
        <a href="#leanpub-auto-for-of-loop">for-of loop</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-generators">generators</a>
  </li>
  <li>
    <a href="#leanpub-auto-classes-and-inheritance">classes and inheritance</a>
    <ul>
      <li>
        <a href="#leanpub-auto-overviewan-example-of-es6-class-syntax-and-es5-equivalent">Overview&hairsp;&mdash;&hairsp;an example of ES6 class syntax and ES5 equivalent</a>
      </li>
      <li>
        <a href="#leanpub-auto-inheritance">inheritance</a>
      </li>
      <li>
        <a href="#leanpub-auto-static">static</a>
      </li>
      <li>
        <a href="#leanpub-auto-get--set">get / set</a>
      </li>
      <li>
        <a href="#leanpub-auto-enhanced-object-properties">Enhanced Object Properties</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-modules">modules</a>
    <ul>
      <li>
        <a href="#leanpub-auto-named-export">Named export</a>
      </li>
      <li>
        <a href="#leanpub-auto-default-export">Default export</a>
      </li>
      <li>
        <a href="#leanpub-auto-api">API</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-promises">promises</a>
    <ul>
      <li>
        <a href="#leanpub-auto-callbacks-and-callback-hell">Callbacks and callback hell</a>
      </li>
      <li>
        <a href="#leanpub-auto-promises-1">Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-pitfall">Pitfall</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-set-map-weak">set, map, weak</a>
    <ul>
      <li>
        <a href="#leanpub-auto-map">Map</a>
      </li>
      <li>
        <a href="#leanpub-auto-set">Set</a>
      </li>
      <li>
        <a href="#leanpub-auto-weakmap">WeakMap</a>
      </li>
      <li>
        <a href="#leanpub-auto-weakset">WeakSet</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main">
<h2 id="leanpub-auto-es6-guide">ES6-guide</h2>

<p><strong>ECMAScript 6 (ES6) guide</strong></p>

<div class="image-with-caption center image-with-caption center">
  <img alt="" src="/site_images/ecmascript2015es6guide/javascript.jpg"><p class="caption"></p>
</div>

<p><strong>CHECK SUMMARY TO SEE TABLE OF CONTENT</strong></p>

<p>I want to share with you some thoughts, snippets of code and tell you a little about the upcoming <strong>ES6</strong>. It's my own road to know it before it will be a standard.</p>

<p>You might have noticed about ES6 a lot lately. This is because the standard is targeting ratification in June 2015.</p>

<p>See draft - <a href="https://people.mozilla.org/~jorendorff/es6-draft.html">ECMAScript 2015</a></p>

<p>ECMAScript 2015 is a significant update to the language. Previous (ES5) was standardized in 2009. Frameworks like <strong>AngularJS</strong>, <strong>Aurelia</strong>, <strong>ReactJS</strong>, <strong>Ionic</strong> start using it today.</p>

<p>ES6 includes a lot of new features:</p>

<ul>
<li>arrows</li>
  <li>classes</li>
  <li>enhanced object literals</li>
  <li>template strings</li>
  <li>destructuring</li>
  <li>default + rest + spread</li>
  <li>let + const</li>
  <li>iterators + for..of</li>
  <li>generators</li>
  <li>unicode</li>
  <li>modules</li>
  <li>module loaders</li>
  <li>map + set + weakmap + weakset</li>
  <li>proxies</li>
  <li>symbols</li>
  <li>subclassable built-ins</li>
  <li>promises</li>
  <li>math + number + string + object APIs</li>
  <li>binary and octal literals</li>
  <li>reflect api</li>
  <li>tail calls</li>
</ul>
<p>I will try to describe each of these in the next stories, so stay updated.</p>

<p>Thanks to the use of transpilers (Babel, Traceur and others) we can actually use it right now until browsers fully catch up.</p>

<p><a href="https://kangax.github.io/compat-table/es6/">Browser support matrix</a></p>

<p>ES6 Repl in Chrome Devl Tools - <a href="https://chrome.google.com/webstore/detail/scratch-js/alploljligeomonipppgaahpkenfnfkn">Scratch JS</a></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">Future</code> <code class="nx">is</code> <code class="nx">bright</code><code class="p">.</code>
</pre></div>

</div>

<p>People from the community denounced these words. I have only one to add: we can handle it easily!</p>

<div class="image-with-caption center image-with-caption center">
  <img alt="" src="/site_images/ecmascript2015es6guide/future_is_bright.jpg"><p class="caption"></p>
</div>

<h2 id="leanpub-auto-let--const">let + const</h2>

<p>First topic about ECMAScript 2015 is <strong>let + const</strong>. If you are familiar with JavaScript, you have probably known the term: <strong>scope</strong>. If you are not that lucky, don't worry about it. I'll explain that in a few words below.</p>

<p>Why I mentioned something about JavaScript <strong>scope</strong>? This is because <strong>let</strong> and <strong>const</strong> have a very strong connection with that word. Firstly, imagine and old way (and still valid) to declare a new variable in your JS code using ES5:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES5</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="k">if</code> <code class="p">(</code><code class="mi">1</code> <code class="o">===</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">c</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">c</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="c1">// </code>
<code class="lineno">11</code> <code class="p">}</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kd">function</code> <code class="nx">letsDeclareAnotherOne</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="kd">var</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// ReferenceError: d is not defined</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="c1">// window</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">25</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<ol class="numeric numeric">
<li>We can see that variable <strong>a</strong> is declared as global. Nothing surprising.</li>
  <li>Variable <strong>b</strong> is inside an <strong>if block</strong>, but in JavaScript it doesn't create a new scope. If you are familiar with other languages, you can be disappointed, but this is JavaScript and it works as you see.</li>
  <li>The next statement is a <strong>for loop</strong>. <strong>C</strong> variable is declared in this for loop, but also in the global scope.</li>
  <li>Until variable <strong>d</strong> is declared in his own scope. It's inside a function and only <strong>function creates new scopes</strong>.</li>
</ol>
<p><strong>Variables in JavaScript are hoisted to the top!</strong></p>

<p><strong>Hoisting</strong> is JavaScript's default behavior of moving all declarations to the top of the current scope (<strong>to the top of the current script</strong> or <strong>the current function</strong>).</p>

<p>In JavaScript, a variable can be declared after it has been used. In other words - a variable can be used before it has been declared!</p>

<p>One more rule, more aware: JavaScript only hoists declarations, not initialization.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// scope and variable hoisting</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">var</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
<code class="lineno"> 7</code>   <code class="kd">var</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 8</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="p">})();</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
</pre></div>

</div>

<p>Let's look for the new keywords in JavaScript ECMAScript 2015: <strong>let</strong> and <strong>const</strong>.</p>

<h3 id="leanpub-auto-let">let</h3>

<p>We can imagine that <strong>let</strong> is a new var statement. What is the difference? let is block scoped. Let's see an example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6 &mdash; let</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="k">if</code> <code class="p">(</code><code class="mi">1</code> <code class="o">===</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">c</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">c</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="c1">// </code>
<code class="lineno">11</code> <code class="p">}</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kd">function</code> <code class="nx">letsDeclareAnotherOne</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// ReferenceError: b is not defined</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// ReferenceError: c is not defined</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// ReferenceError: d is not defined</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="c1">// window</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// undefined</code>
<code class="lineno">25</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// undefined</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<p>As we can see, this time only variable <strong>a</strong> is declared as a global. <strong>let</strong> gives us a way to declare block scoped variables, which is undefined outside it.</p>

<p><strong>I use Chrome (stable version) with #enable-javascript-harmony flag enabled. Visit chrome://flags/#enable-javascript-harmony, enable this flag, restart Chrome and you will get many new features.</strong></p>

<p>You can also use <strong>BabelJS repl</strong> or <strong>Traceur repl</strong> and compare results.</p>

<h3 id="leanpub-auto-const">const</h3>

<p><strong>const</strong> is single-assignment and like a <strong>let</strong>, block-scoped declaration.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES6 const</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.141593</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14</code><code class="p">;</code> <code class="c1">// throws "PI" is read-only</code>
<code class="lineno">6</code> <code class="p">}</code>
<code class="lineno">7</code> 
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">PI</code><code class="p">);</code> <code class="c1">// throws ReferenceError: PI is not defined</code>
</pre></div>

</div>

<p>const cannot be reinitialized. It will throw an Error when we try to assign another value.</p>

<p>Let's look for the equivalent in ES5:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES5 const</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">PI</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="kd">var</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.141593</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">PI</code><code class="p">;</code> <code class="p">};</code>
<code class="lineno">6</code> <code class="p">})();</code>
</pre></div>

</div>

<h2 id="leanpub-auto-arrow-functions">arrow functions</h2>

<p>A new syntactic sugar which ES6 brings us soon, called <strong>arrow functions</strong> (also known as a fat arrow function). It's a shorter syntax compared to function expressions and lexically binds <strong>this</strong> value.</p>

<p>REMEMBER - <strong>Arrow functions are always anonymous.</strong></p>

<h3 id="leanpub-auto-syntactic-sugar">Syntactic sugar</h3>

<p>How does it look? It's a signature:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">([</code><code class="nx">param</code><code class="p">]</code> <code class="p">[,</code> <code class="nx">param</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>  <code class="nx">statements</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code>            <code class="nx">param</code> <code class="o">=&gt;</code> <code class="nx">expression</code>
<code class="lineno">6</code> <code class="p">(</code><code class="nx">param1</code><code class="p">,</code> <code class="nx">param2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">block</code> <code class="p">}</code>
</pre></div>

</div>

<p>..and it could be translated to:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code>     <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err"></code> <code class="p">}</code>       <code class="c1">// no argument</code>
<code class="lineno">2</code>      <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err"></code> <code class="p">}</code>       <code class="c1">// one argument</code>
<code class="lineno">3</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err"></code> <code class="p">}</code>       <code class="c1">// several arguments</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code> <code class="p">}</code> <code class="c1">// block</code>
<code class="lineno">6</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code>            <code class="c1">// expression, same as above</code>
</pre></div>

</div>

<p>Lambda expressions in JavaScript! Cool!</p>

<p>Instead of writing:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">});</code>
</pre></div>

</div>

<p>..you can write something like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>
</pre></div>

</div>

<p>Awesome. Isn't it? There is more!</p>

<h3 id="leanpub-auto-fixed-this--lexical-this">Fixed "this" = lexical "this"</h3>

<p><strong>The value of this inside of the function is determined by where the arrow function is defined not where it is used.</strong></p>

<p>No more <strong>bind</strong>, <strong>call</strong> and <strong>apply</strong>! No more:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
</pre></div>

</div>

<p>It solves a major pain point (from my point of view) and has the added bonus of improving performance through JavaScript engine optimizations.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES5</code>
<code class="lineno"> 2</code> <code class="kd">function</code> <code class="nx">FancyObject</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 3</code>  <code class="kd">var</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code>  <code class="nx">self</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'FancyObject'</code><code class="p">;</code>
<code class="lineno"> 6</code>  <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="nx">self</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'Hello World!'</code><code class="p">;</code>
<code class="lineno"> 8</code>  <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="c1">// ES6</code>
<code class="lineno">12</code> <code class="kd">function</code> <code class="nx">FancyObject</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'FancyObject'</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">15</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'Hello World!'</code><code class="p">;</code> <code class="c1">// properly refers to FancyObject</code>
<code class="lineno">16</code>   <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">17</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-the-same-function">The same function</h3>

<ul>
<li>
<strong>typeof</strong> returns <strong>function</strong>
</li>
  <li>
<strong>instanceof</strong> returns <strong>Function</strong>
</li>
</ul>
<h3 id="leanpub-auto-limitations">Limitations</h3>

<ul>
<li>It's cannot be used as a constructor and will throw an error when used with <strong>new</strong>.</li>
  <li>Fixed <strong>this</strong> means that you cannot change the <strong>value of this</strong> inside of the function. It remains the same value throughout the entire lifecycle of the function.</li>
  <li>Regular functions can be <strong>named</strong>.</li>
  <li>Functions declarations are <strong>hoisted</strong> (can be used before they are declared).</li>
</ul>
<h2 id="leanpub-auto-default--rest--spread">default + rest + spread</h2>

<p>ECMAScript 2015 functions made a significant progress, taking into account years of complaints. The result is a number of improvements that make programming in JavaScript <strong>less error-prone</strong> and <strong>more powerful</strong>.</p>

<p>Let's see three new features which give us <strong>extended parameter handling</strong>.</p>

<h3 id="leanpub-auto-default">default</h3>

<p>It's a simple, little addition that makes it much easier to handle function parameters. Functions in JavaScript allow any number of parameters to be passed regardless of the number of declared parameters in the function definition. You probably know <strong>commonly seen pattern</strong> in current JavaScript code:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// set default to 1 if increment not passed</code>
<code class="lineno">3</code>   <code class="c1">// (or passed as undefined)</code>
<code class="lineno">4</code>   <code class="nx">increment</code> <code class="o">=</code> <code class="nx">increment</code> <code class="o">||</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno">6</code> <code class="p">}</code>
<code class="lineno">7</code> 
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<p>The logical <strong>OR operator</strong> (||) always returns the second operand when the first is falsy.</p>

<p><strong>ES6</strong> gives us a way to set default function parameters. Any parameters with a default value are considered to be optional.</p>

<p>ES6 version of <strong>inc</strong> function looks like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<p>You can also set default values to parameters that appear <strong>before arguments</strong> without default values:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">10</code><code class="p">));</code>         <code class="c1">// 16 -&gt; b === 5</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">10</code><code class="p">));</code> <code class="c1">// 13 -&gt; b as default</code>
</pre></div>

</div>

<p>You can even execute a function to set default parameter. It's not restricted to <strong>primitive values</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">getDefaultIncrement</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code> <code class="p">}</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code> <code class="o">=</code> <code class="nx">getDefaultIncrement</code><code class="p">())</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<h3 id="leanpub-auto-rest">rest</h3>

<p>Let's rewrite <strong>sum</strong> function to handle all arguments passed to it (without validation - just to be clear). If we want to use <strong>ES5</strong>, we probably also want to use <strong>arguments</strong> object.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>    <code class="kd">var</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">arguments</code><code class="p">),</code>
<code class="lineno"> 3</code>        <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 4</code>    <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 5</code>        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno"> 6</code>    <code class="p">});</code>
<code class="lineno"> 7</code>    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">}</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>             <code class="c1">// 1</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code> <code class="c1">// 15</code>
</pre></div>

</div>

<p>But it's not obvious that the function is capable of handling any parameters. W have to scan body of the function and find <strong>arguments</strong> object.</p>

<p><strong>ECMAScript 6</strong> introduces <strong>rest</strong> parameters to help us with this and other pitfalls.</p>

<p><strong>arguments - contains all parameters including named parameters</strong></p>

<p>Rest parameters are indicated by three dots <strong></strong> preceding a parameter. Named parameter becomes an <strong>array</strong> which contain the rest of the parameters.</p>

<p><strong>sum</strong> function can be rewritten using ES6 syntax:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="err"></code><code class="nx">numbers</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="p">});</code>
<code class="lineno"> 6</code>   <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 1</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code> <code class="c1">// 15</code>
</pre></div>

</div>

<p>Restriction: <strong>no other named arguments can follow in the function declaration.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="err"></code><code class="nx">numbers</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// causes a syntax error</code>
<code class="lineno">2</code>   <code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>     <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="p">});</code>
<code class="lineno">6</code>   <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno">7</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-spread">spread</h3>

<p>The <strong>spread</strong> is closely related to rest parameters, because of <strong></strong> (three dots) notation. It allows to split an array to single arguments which are passed to the function as separate arguments.</p>

<p>Let's define our <strong>sum</strong> function an pass <strong>spread</strong> to it:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="err"></code><code class="nx">args</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>ES5 equivalent is:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="nx">args</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>Instead using an <strong>apply</strong> function, we can just type <strong>args</strong> and pass all array argument separately.</p>

<p>We can also mix standard arguments with spread operator:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="err"></code><code class="nx">args</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>The result is the same. First two arguments are from args array, and the last passed argument is 3.</p>

<h2 id="leanpub-auto-destructuring">destructuring</h2>

<p><strong>Destructuring</strong> is one more little addition to the upcoming JavaScript standard, which helps us write code more flexibly and effectively.</p>

<p>It allows binding using pattern matching. We can use it for matching arrays and objects. It's similar to standard object look up and returns <strong>undefined</strong> when value is not found.</p>

<h3 id="leanpub-auto-arrays">arrays</h3>

<p>Today it's common to see the code such as this.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES5</code>
<code class="lineno">2</code> <code class="kd">var</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">xVal</code> <code class="o">=</code> <code class="nx">point</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code>
<code class="lineno">4</code>     <code class="nx">yVal</code> <code class="o">=</code> <code class="nx">point</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>ES6 gives us destructuring of arrays into individual variables during assignment which is intuitive and flexible.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">xVal</code><code class="p">,</code> <code class="nx">yVal</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno"> 7</code> <code class="c1">// .. and reverse!</code>
<code class="lineno"> 8</code> <code class="p">[</code><code class="nx">xVal</code><code class="p">,</code> <code class="nx">yVal</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">yVal</code><code class="p">,</code> <code class="nx">xVal</code><code class="p">];</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 1</code>
</pre></div>

</div>

<p>We can even omit some values..</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">threeD</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="p">,</code> <code class="nx">c</code><code class="p">]</code> <code class="o">=</code> <code class="nx">threeD</code><code class="p">;</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
</pre></div>

</div>

<p>..and have nested array destructuring.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">nested</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="mi">4</code><code class="p">];</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="p">[</code><code class="nx">b</code><code class="p">],</code> <code class="nx">d</code><code class="p">]</code> <code class="o">=</code> <code class="nx">nested</code><code class="p">;</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</div>

<h3 id="leanpub-auto-objects">objects</h3>

<p>As well as the array syntax, ES6 also has the ability to destructure objects. It uses an object literal on the left side of an assignment operation. Object pattern is very similar to array pattern seen above. Let's see:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno">3</code>   <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code>
<code class="lineno">4</code> <code class="p">};</code>
<code class="lineno">5</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>It supports nested object as well as array pattern.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>   <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">z</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">one</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
<code class="lineno"> 6</code>     <code class="nx">two</code><code class="o">:</code> <code class="mi">4</code>
<code class="lineno"> 7</code>   <code class="p">}</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">d</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</div>

<h3 id="leanpub-auto-mixed">mixed</h3>

<p>We can also mix objects and arrays together and use theirs literals.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">mixed</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">one</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>   <code class="nx">two</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]</code>
<code class="lineno"> 5</code> <code class="p">};</code>
<code class="lineno"> 6</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="nx">c</code><code class="p">,</code> <code class="p">,</code> <code class="nx">e</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">mixed</code><code class="p">;</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code> <code class="c1">// 5</code>
</pre></div>

</div>

<p>But I think the most interesting is that we are able to use <strong>functions</strong> which return destructuring assignment.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">mixed</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="nx">one</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">two</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 5</code>     <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]</code>
<code class="lineno"> 6</code>   <code class="p">};</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="nx">c</code><code class="p">,</code> <code class="p">,</code> <code class="nx">e</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">mixed</code><code class="p">();</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code> <code class="c1">// 5</code>
</pre></div>

</div>

<p>The same result! It gives us a lot of possibilities to use it in our code.</p>

<h3 id="leanpub-auto-attention">attention!</h3>

<p><strong>If the value of a destructuring assignment isn't match, it evaluates to undefined.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<p><strong>If we try to omit var, let or const, it will throw an error, because block code can't be destructuring assignment.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code> <code class="c1">// throws error</code>
</pre></div>

</div>

<p>We have to wrap it in parentheses. Just that </p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> <code class="p">({</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
</pre></div>

</div>

<h2 id="leanpub-auto-strings">strings</h2>

<p>I gonna show you a couple of changes to <strong>strings</strong> in JavaScript, which will be available when ES6 comes. A syntactic sugar, which could be helpful in daily work.</p>

<h3 id="leanpub-auto-template-strings">template strings</h3>

<p>First, a <strong>string interpolation</strong>. Yep, template strings (finally) support string interpolation. ES6 brings us also support for <strong>multi-line</strong> syntax and <strong>raw literals</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">let</code> <code class="nx">sumTpl</code> <code class="o">=</code> <code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">x</code><code class="p">}</code> <code class="o">+</code> <code class="nx">$</code><code class="p">{</code><code class="nx">y</code><code class="p">}</code> <code class="o">=</code> <code class="nx">$</code><code class="p">{</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">}</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sumTpl</code><code class="p">);</code> <code class="c1">// 1 + 2 = 3</code>
</pre></div>

</div>

<p>As you can see, we can inject values to string by using <strong>${value}</strong> syntax. Another thing to consider is <strong>grave accent</strong> - a char under the tilde (~) on a keyboard. A template literal string must be wrapped by it, to work properly.</p>

<p>The example above is an equivalent (in ES5) to simply (Babel version):</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">sumTpl</code> <code class="o">=</code> <code class="s2">""</code> <code class="o">+</code> <code class="nx">x</code> <code class="o">+</code> <code class="s2">" + "</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="s2">" = "</code> <code class="o">+</code> <code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">);</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sumTpl</code><code class="p">);</code> <code class="c1">// 1 + 2 = 3</code>
</pre></div>

</div>

<p>This feature is very useful and almost removes the need for a template system.</p>

<p>Template strings provide also <strong>multi-line syntax</strong>, which is not legal in ES5 and earlier.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">types</code> <code class="o">=</code> <code class="err">`</code><code class="nb">Number</code>
<code class="lineno">2</code> <code class="nb">String</code>
<code class="lineno">3</code> <code class="nb">Array</code>
<code class="lineno">4</code> <code class="nb">Object</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">types</code><code class="p">);</code> <code class="c1">// Number</code>
<code class="lineno">6</code>                     <code class="c1">// String</code>
<code class="lineno">7</code>                     <code class="c1">// Array</code>
<code class="lineno">8</code>                     <code class="c1">// Object</code>
</pre></div>

</div>

<p>ES5 equivalent:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">types</code> <code class="o">=</code> <code class="s2">"Number\nString\nArray\nObject"</code><code class="p">;</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">types</code><code class="p">);</code> <code class="c1">// Number</code>
<code class="lineno">3</code>                     <code class="c1">// String</code>
<code class="lineno">4</code>                     <code class="c1">// Array</code>
<code class="lineno">5</code>                     <code class="c1">// Object</code>
</pre></div>

</div>

<p>The last thing is access the <strong>raw template string</strong> content where backslashes are not interpreted. We don't have equivalent in ES5 here.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">interpreted</code> <code class="o">=</code> <code class="s1">'raw\nstring'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">esaped</code> <code class="o">=</code> <code class="s1">'raw\\nstring'</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">let</code> <code class="nx">raw</code> <code class="o">=</code> <code class="nb">String</code><code class="p">.</code><code class="nx">raw</code><code class="err">`</code><code class="nx">raw</code><code class="err">\</code><code class="nx">nstring</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">interpreted</code><code class="p">);</code>    <code class="c1">// raw</code>
<code class="lineno">6</code>                              <code class="c1">// string</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">raw</code> <code class="o">===</code> <code class="nx">esaped</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<h3 id="leanpub-auto-extended-support-for-unicode">extended support for Unicode</h3>

<p>ES6 gives us full support for <strong>Unicode</strong> within strings and regular expressions. It's non-breaking addition allows to building global apps.</p>

<p>Let's see an example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">''</code><code class="p">;</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>             <code class="c1">// 2</code>
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code> <code class="o">===</code> <code class="s1">'\uD842\uDFB7'</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<p>You can see that character <strong></strong>* represented by two 16-bit code units. It's a surrogate pair in which we have a single code point represented by two code units. The length of that string is also 2.</p>

<p><strong>Surrogate pairs are used in UTF-16 to represent code points above U+FFFF.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code> <code class="c1">// 55362</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 57271</code>
</pre></div>

</div>

<p>The <strong>charCodeAt()</strong> method returns the 16-bit number for each code unit.</p>

<p>ES6 allows encoding of strings in UTF-16. JavaScript can now support work with surrogate pairs. It gives us also a new method <strong>codePointAt()</strong> that returns Unicode code point instead of Unicode code unit.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code> <code class="c1">// 134071</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 57271</code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code> <code class="o">===</code> <code class="mh">0x20BB7</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<p>It works the same as <strong>charCodeAt()</strong> except for non-BMP characters.</p>

<p><strong>BMP - Basic Multilingual Plane - the first 2^16 code points.</strong></p>

<p><strong>codePointAt()</strong> returns full code point at the 0 <strong>position</strong>. codePointAt() and charCodeAt() return the same value for <strong>position 1</strong>.</p>

<p>We can also do a reverse operation with another new method added to ES6: <strong>fromCodePoint()</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code><code class="mi">134071</code><code class="p">));</code>  <code class="c1">// ""</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code><code class="mh">0x20BB7</code><code class="p">));</code> <code class="c1">// ""</code>
</pre></div>

</div>

<p><strong>Unicode code unit escape sequences consist of six characters, namely \u plus four hexadecimal digits, and contribute one code unit.</strong></p>

<p><strong>Unicode code point escape sequences consist of five to ten characters, namely
\u{ 1&ndash;6 hexadecimal digits }, and contribute one or two code units.</strong></p>

<p>Dealing with that two definitions, above example could be represented by one code point in <strong>ES6</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES6</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u{20BB7}'</code><code class="p">);</code> <code class="c1">// </code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u{20BB7}'</code> <code class="o">===</code> <code class="s1">'\uD842\uDFB7'</code><code class="p">);</code> <code class="c1">// true</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="c1">// ES5</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u20BB7); // 7!</code>
<code class="lineno">7</code> <code class="s1">console.log('</code><code class="err">\</code><code class="nx">u20BB7</code><code class="s1">' === '</code><code class="err">\</code><code class="nx">uD842</code><code class="err">\</code><code class="nx">uDFB7</code><code class="err">'</code><code class="p">);</code> <code class="c1">// false</code>
</pre></div>

</div>

<p>In ES5 we get an unexpected result when we try to match one single character using regular expression.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sr">/^.$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">str</code><code class="p">));</code> <code class="c1">// false - length is 2</code>
</pre></div>

</div>

<p>ES6 allows us to use new RegExp <strong>u mode</strong> to handle code points. It is simply a new <strong>u</strong> flag (u == Unicode).</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">/^.$/u.test(str)); // true</code>
</pre></div>

</div>

<p>Adding u flag allows to correctly match the string by characters instead of code units.</p>

<h3 id="leanpub-auto-strings-are-iterable">strings are iterable</h3>

<p>Strings are iterable by using the <strong>for-of</strong> loop which I will cover in more detail in iterators article later. I write about it now because it enumerate Unicode code points and each may comprise one or two characters.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">'abc\uD842\uDFB7'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 5</code>
<code class="lineno">3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">c</code> <code class="nx">of</code> <code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// a</code>
<code class="lineno">5</code>                   <code class="c1">// b</code>
<code class="lineno">6</code>                   <code class="c1">// c</code>
<code class="lineno">7</code>                   <code class="c1">// </code>
<code class="lineno">8</code> <code class="p">}</code>
</pre></div>

</div>

<p>We can also use <strong>spread</strong> operator to transform string into an array with full Unicode support.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">'abc\uD842\uDFB7'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">chars</code> <code class="o">=</code> <code class="p">[</code><code class="err"></code><code class="nx">str</code><code class="p">];</code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">chars</code><code class="p">);</code> <code class="c1">// ['a', 'b', 'c', '']</code>
</pre></div>

</div>

<h3 id="leanpub-auto-new-string-methods">new string methods</h3>

<p><strong>repeat(n)</strong> - string repeats by <strong>n</strong> times</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'abc|'</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code> <code class="c1">// 'abc|abc|abc|'</code>
</pre></div>

</div>

<p><strong>startsWith(str, starts = 0) : boolean</strong> - check if string starts with <strong>str</strong>, starting from <strong>starts</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">));</code>      <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'script'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<p><strong>endsWith(str, ends = str.length) : boolean</strong> - check if string ends with <strong>str</strong>, <strong>ends</strong> - where the string to be checked ends</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s1">'script'</code><code class="p">));</code>  <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<p><strong>includes(str, starts = 0) : boolean</strong> - check if string contain <strong>str</strong>, starting from <strong>starts</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">));</code>      <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s1">'script'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<h2 id="leanpub-auto-iterators">iterators</h2>

<h3 id="leanpub-auto-iterator--iterable">iterator &amp; iterable</h3>

<p><strong>An iterator is an object with a next method that returns { done, value } tuples.</strong></p>

<p>ES6 gives us a pattern for creating custom iterators and it has a similar implementation to Java <strong>Iterable</strong> or .NET <strong>IEnumerable</strong>. It has also built-in <strong>iterables</strong>: <strong>String</strong>, <strong>Array</strong>, <strong>TypedArray</strong>, <strong>Map</strong> and <strong>Set</strong>. An iterator object can be any object with a next() method.</p>

<p><strong>Iterable is an object which has <a href="">Symbol.iterator</a> method inside.</strong></p>

<p><strong>Symbol is in turn an unique and immutable data type which can be used as an identifier for object properties&hairsp;&mdash;&hairsp;no equivalent in ES5.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// Symbol</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">s1</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'abc'</code><code class="p">);</code>
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="nx">s2</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'abc'</code><code class="p">);</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">s1</code> <code class="o">!==</code> <code class="nx">s2</code><code class="p">);</code> <code class="c1">// true</code>
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">s1</code><code class="p">);</code> <code class="c1">// 'symbol'</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>
<code class="lineno"> 9</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">s1</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'abc'</code><code class="p">;</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { Symbol(abc): 'abc' }</code>
</pre></div>

</div>

<p>Let's see a simple iterator written from scratch, which allows us to iterate through random numbers which are dynamically generated by <strong>next()</strong> method. A function returning iterable object take one argument (<strong>items</strong>) which is used to determine if the iterator should stop and returns <strong>done = true</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">random1_10</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">items</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="kd">let</code> <code class="nx">cur</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 5</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 6</code>         <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>           <code class="kd">let</code> <code class="nx">done</code> <code class="o">=</code> <code class="nx">cur</code> <code class="o">===</code> <code class="nx">items</code><code class="p">,</code>
<code class="lineno"> 8</code>               <code class="nx">random</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 9</code>           <code class="o">++</code><code class="nx">cur</code><code class="p">;</code>
<code class="lineno">10</code>           <code class="k">return</code> <code class="p">{</code>
<code class="lineno">11</code>             <code class="nx">done</code><code class="o">:</code> <code class="nx">done</code><code class="p">,</code>
<code class="lineno">12</code>             <code class="nx">value</code><code class="o">:</code> <code class="nx">random</code>
<code class="lineno">13</code>           <code class="p">}</code>
<code class="lineno">14</code>         <code class="p">}</code>
<code class="lineno">15</code>       <code class="p">}</code>
<code class="lineno">16</code>     <code class="p">}</code>
<code class="lineno">17</code>   <code class="p">};</code>
<code class="lineno">18</code> <code class="p">};</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="nx">of</code> <code class="nx">random1_10</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code> <code class="p">{</code>
<code class="lineno">21</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code> <code class="c1">// prints 5 random numbers</code>
<code class="lineno">22</code> <code class="p">}</code>
</pre></div>

</div>

<p>Every time <strong>for-of</strong> loop call <strong>next()</strong> method, an iterator generate a random number and returns it to the loop.</p>

<p><strong>If the iterator returns done = true, you can omit value, so the result will be { done: true }</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">random1_10</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">items</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="kd">let</code> <code class="nx">cur</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 5</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 6</code>         <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>           <code class="k">if</code> <code class="p">(</code><code class="nx">cur</code> <code class="o">===</code> <code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>             <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 9</code>               <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code>
<code class="lineno">10</code>             <code class="p">}</code>
<code class="lineno">11</code>           <code class="p">}</code>
<code class="lineno">12</code>           <code class="o">++</code><code class="nx">cur</code><code class="p">;</code>
<code class="lineno">13</code>           <code class="k">return</code> <code class="p">{</code>
<code class="lineno">14</code>             <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
<code class="lineno">15</code>             <code class="nx">value</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code>
<code class="lineno">16</code>           <code class="p">}</code>
<code class="lineno">17</code>         <code class="p">}</code>
<code class="lineno">18</code>       <code class="p">}</code>
<code class="lineno">19</code>     <code class="p">}</code>
<code class="lineno">20</code>   <code class="p">};</code>
<code class="lineno">21</code> <code class="p">};</code>
<code class="lineno">22</code> 
<code class="lineno">23</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="nx">of</code> <code class="nx">random1_10</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code> <code class="p">{</code>
<code class="lineno">24</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code> <code class="c1">// prints 5 random numbers</code>
<code class="lineno">25</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-for-of-loop">for-of loop</h3>

<p>ES6 has a new loop&hairsp;&mdash;&hairsp;<strong>for-of</strong>. It works with iterables. Let's look at his signature:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">for</code> <code class="p">(</code><code class="nx">LET</code> <code class="nx">of</code> <code class="nx">ITERABLE</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">CODE</code> <code class="nx">BLOCK</code>
<code class="lineno">3</code> <code class="p">}</code>
</pre></div>

</div>

<p>It's similar to <strong>for-in</strong> loop, which can be used to iterate through object properties (plain old Objects).</p>

<p><strong>Arrays</strong> in ES6 are iterable by default, so we finally can use <strong>for-of</strong> for looping over the elements.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">item</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code>                      <code class="c1">// 2</code>
<code class="lineno">6</code>                      <code class="c1">// 3</code>
<code class="lineno">7</code>                      <code class="c1">// 4</code>
<code class="lineno">8</code>                      <code class="c1">// 5</code>
<code class="lineno">9</code> <code class="p">}</code>
</pre></div>

</div>

<p>Inside the for-of loop, we can even use a <strong>break</strong>, <strong>continue</strong> and <strong>return</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">item</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>   <code class="k">if</code> <code class="p">(</code><code class="nx">item</code> <code class="o">&gt;</code> <code class="mi">4</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="k">break</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code>   <code class="k">if</code> <code class="p">(</code><code class="mi">0</code> <code class="o">!==</code> <code class="nx">item</code> <code class="o">%</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="k">continue</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="p">}</code>
<code class="lineno">10</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">11</code>                      <code class="c1">// 4</code>
<code class="lineno">12</code> <code class="p">}</code>
</pre></div>

</div>

<h2 id="leanpub-auto-generators">generators</h2>

<p><strong>Generators</strong> are simply subtypes of <strong>Iterators</strong> which I wrote about previously. They are a special kind of function that can be suspended and resumed, which is making a difference to iterators. Generators use <strong>function</strong>* and <strong>yield</strong> operators to work their magic.</p>

<p><strong>The yield operator returns a value from the function and when the generator is resumed, execution continues after the yield.</strong></p>

<p><strong>We also have to use function* (with star character) instead of a function to return a generator instance.</strong></p>

<p><strong>!!! Generators have been borrowed from Python language.</strong></p>

<p><strong>The most magical feature in ES6!</strong></p>

<p>Why? Take a look:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">generator</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="c1">// pause</code>
<code class="lineno"> 4</code>   <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="c1">// pause</code>
<code class="lineno"> 6</code>   <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
<code class="lineno"> 7</code>   <code class="c1">// pause</code>
<code class="lineno"> 8</code>   <code class="k">yield</code> <code class="s1">'done?'</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="c1">// done</code>
<code class="lineno">10</code> <code class="p">}</code>
<code class="lineno">11</code> <code class="kd">let</code> <code class="nx">gen</code> <code class="o">=</code> <code class="nx">generator</code><code class="p">();</code> <code class="c1">// [object Generator]</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 1, done: false}</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 2, done: false}</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 3, done: false}</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 'done?', done: false}</code>
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: undefined, done: true}</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: undefined, done: true}</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">val</code> <code class="nx">of</code> <code class="nx">generator</code><code class="p">())</code> <code class="p">{</code>
<code class="lineno">21</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">val</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">22</code>                     <code class="c1">// 2</code>
<code class="lineno">23</code>                     <code class="c1">// 3</code>
<code class="lineno">24</code>                     <code class="c1">// 'done?'</code>
<code class="lineno">25</code> <code class="p">}</code>
</pre></div>

</div>

<p>As you can see, the generator has four <strong>yield</strong> statements. Each returns a value, pauses execution and moves to the next yield when <strong>next()</strong> method is called. Calling a function produces an object for controlling generator execution, a so-called <strong>generator object</strong>.</p>

<p>Use is similar to iterators. We have <strong>next()</strong> method as I mentioned above and we can even use it with <strong>for-of</strong> loop.</p>

<p>Below is an example of a generator called <strong>random1_10</strong>, which returns random numbers from 1 to 10.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random1_10</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="k">yield</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code>   <code class="p">}</code>
<code class="lineno"> 5</code> <code class="p">}</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_10</code><code class="p">();</code>
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">10</code> <code class="c1">// </code>
</pre></div>

</div>

<p>Generator has never ending <strong>while</strong> loop. It produces random numbers every time when you call <strong>next()</strong> method.</p>

<p>ES5 implementation:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">random1_10</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="nx">next</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 5</code>         <code class="nx">value</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 6</code>         <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code>
<code class="lineno"> 7</code>       <code class="p">};</code>
<code class="lineno"> 8</code>     <code class="p">}</code>
<code class="lineno"> 9</code>   <code class="p">};</code>
<code class="lineno">10</code> <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_10</code><code class="p">();</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">15</code> <code class="c1">// </code>
</pre></div>

</div>

<p>We can also mix generators together:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random</code> <code class="p">(</code><code class="nx">max</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">yield</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">max</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code> <code class="p">}</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random1_20</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 7</code>     <code class="k">yield</code><code class="o">*</code> <code class="nx">random</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code>
<code class="lineno"> 8</code>   <code class="p">}</code>
<code class="lineno"> 9</code> <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_20</code><code class="p">();</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">14</code> <code class="c1">// </code>
</pre></div>

</div>

<p><strong>random1_20</strong> generator returns random values from 1 to 20. It uses <strong>random</strong> generator inside to create random number each time when yield statement is reached.</p>

<h2 id="leanpub-auto-classes-and-inheritance">classes and inheritance</h2>

<p><strong>OO</strong> keywords is probably the most awaited features in ES6. <strong>Classes</strong> are something like another syntactic sugar over the prototype-based OO pattern. We now have one, concise way to make class patterns easier to use.</p>

<p><strong>Over the prototype-based OO pattern to ensure backwards compatibility.</strong></p>

<h3 id="leanpub-auto-overviewan-example-of-es6-class-syntax-and-es5-equivalent">Overview&hairsp;&mdash;&hairsp;an example of ES6 class syntax and ES5 equivalent</h3>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>It's naive example, but we can see a new keywords as class and constructor.</p>

<p>ES5 equivalent could be something like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">Vehicle</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getType</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">12</code> <code class="p">};</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="kd">var</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p><strong>Classes support prototype-based inheritance, super calls, instance and static methods and constructors.</strong></p>

<p>It's simple. We instantiate our classes the same way, but let's add some..</p>

<h3 id="leanpub-auto-inheritance">inheritance</h3>

<p>..to it and start from ES5 example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">Vehicle</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getType</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">12</code> <code class="p">};</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="kd">function</code> <code class="nx">Car</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">15</code>   <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
<code class="lineno">19</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">=</code> <code class="nx">Car</code><code class="p">;</code>
<code class="lineno">20</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">parent</code> <code class="o">=</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>
<code class="lineno">21</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">22</code>   <code class="k">return</code> <code class="s1">'It is a car: '</code><code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">23</code> <code class="p">};</code>
<code class="lineno">24</code> 
<code class="lineno">25</code> <code class="kd">var</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// It is a car: Tesla</code>
<code class="lineno">27</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>And now look at the ES6 version:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="kr">class</code> <code class="nx">Car</code> <code class="kr">extends</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno">19</code> 
<code class="lineno">20</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">21</code>     <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">22</code>   <code class="p">}</code>
<code class="lineno">23</code> 
<code class="lineno">24</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">25</code>     <code class="k">return</code> <code class="s1">'It is a car: '</code> <code class="o">+</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code>
<code class="lineno">26</code>   <code class="p">}</code>
<code class="lineno">27</code> 
<code class="lineno">28</code> <code class="p">}</code>
<code class="lineno">29</code> 
<code class="lineno">30</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">31</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// It is a car: Tesla</code>
<code class="lineno">32</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>We see how easy is to implement inheritance with ES6. It's finally looking like in other OO programming languages. We use <strong>extends</strong> to inherit from another class and the <strong>super</strong> keyword to call the parent class (function). Moreover, <strong>getName()</strong> method was overridden in subclass <strong>Car</strong>.</p>

<p><strong>super&hairsp;&mdash;&hairsp;previously to achieve such functionality in Javascript required the use of call or apply</strong></p>

<h3 id="leanpub-auto-static">static</h3>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code>   <code class="kr">static</code> <code class="nx">create</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">17</code>     <code class="k">return</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">);</code>
<code class="lineno">18</code>   <code class="p">}</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="p">}</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>Classes give us an opportunity to create static members. We don't have to use the <strong>new</strong> keyword later to instantiate a class.</p>

<p>static methods (properties) are also inherited
and could be called by super</p>

<h3 id="leanpub-auto-get--set">get / set</h3>

<p>Other great things in upcoming ES6 are <strong>getters</strong> and <strong>setters</strong> for object properties. They allow us to run the code on the reading or writing of a property.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Car</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">_name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="p">}</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code>   <code class="nx">set</code> <code class="nx">name</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="k">this</code><code class="p">.</code><code class="nx">_name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code>   <code class="nx">get</code> <code class="nx">name</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">12</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_name</code><code class="p">;</code>
<code class="lineno">13</code>   <code class="p">}</code>
<code class="lineno">14</code> 
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Tesla</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">car</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'BMW'</code><code class="p">;</code>
<code class="lineno">21</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// BMW</code>
</pre></div>

</div>

<p>I use _' prefix to create a (<strong>tmp</strong>) field to store name property.</p>

<h3 id="leanpub-auto-enhanced-object-properties">Enhanced Object Properties</h3>

<p>The last thing I have to mention is <strong>property shorthand</strong>, <strong>computed property names</strong> and <strong>method properties</strong>.</p>

<p>ES6 gives us shorter syntax for common <strong>object property</strong> definition:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { x: 1, y: 2 }</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="c1">// ES5</code>
<code class="lineno"> 9</code> <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno">10</code>     <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno">11</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">12</code>       <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code>
<code class="lineno">13</code>       <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code>
<code class="lineno">14</code>     <code class="p">};</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { x: 1, y: 2 }</code>
</pre></div>

</div>

<p>As you can see, this works because the property value has the same name as the property identifier.</p>

<p>Another thing is ES6 support for <strong>computed names</strong> in object property definitions:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">getKey</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'123'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">foo</code><code class="o">:</code> <code class="s1">'bar'</code><code class="p">,</code>
<code class="lineno"> 5</code>       <code class="p">[</code><code class="s1">'key_'</code> <code class="o">+</code> <code class="nx">getKey</code><code class="p">()]</code><code class="o">:</code> <code class="mi">123</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { foo: 'bar', key_123: 123 }</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="c1">// ES5</code>
<code class="lineno">11</code> <code class="kd">var</code> <code class="nx">getKey</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">12</code>       <code class="k">return</code> <code class="s1">'123'</code><code class="p">;</code>
<code class="lineno">13</code>     <code class="p">},</code>
<code class="lineno">14</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">15</code>       <code class="nx">foo</code><code class="o">:</code> <code class="s1">'bar'</code>
<code class="lineno">16</code>     <code class="p">};</code>
<code class="lineno">17</code> <code class="nx">obj</code><code class="p">[</code><code class="s1">'key_'</code> <code class="o">+</code> <code class="nx">getKey</code><code class="p">()]</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="lineno">18</code> 
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { foo: 'bar', key_123: 123 }</code>
</pre></div>

</div>

<p>The one last thing is <strong>method properties</strong> seen in classes above. We can even use it in object definitions:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="nx">name</code><code class="o">:</code> <code class="s1">'object name'</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">toString</code> <code class="p">()</code> <code class="p">{</code> <code class="c1">// 'function' keyword is omitted here</code>
<code class="lineno"> 5</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> <code class="p">};</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// object name</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="c1">// ES5</code>
<code class="lineno">13</code> <code class="kd">var</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="nx">name</code><code class="o">:</code> <code class="s1">'object name'</code><code class="p">,</code>
<code class="lineno">15</code>   <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">16</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">17</code>   <code class="p">}</code>
<code class="lineno">18</code> <code class="p">};</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// object name</code>
</pre></div>

</div>

<h2 id="leanpub-auto-modules">modules</h2>

<p>Today we have a couple of ways to create <strong>modules</strong>, export &amp; import them. JavaScript doesn't have any built-in module loader yet. Upcoming ECMAScript 2015 standard gives us a reason to make people happy. Finally ;)</p>

<p>We have third party standards: <strong>CommonJS</strong> and <strong>AMD</strong>. The most popular, but, unfortunately, incompatible standards for module loaders.</p>

<p><strong>CommonJS is known from <a href="https://nodejs.org/">Node.js</a>. It's mostly dedicated for servers and it supports synchronous loading. It also has a compact syntax focused on export and require keywords.</strong></p>

<p><strong>AMD and the most popular implementation - <a href="http://requirejs.org/">RequireJS</a> are dedicated for browsers. AMD supports asynchronous loading, but has more complicated syntax than CommonJS.</strong></p>

<p>The goal for ES6 is (was) to mix these two standards and make both user groups happy.</p>

<p>ES6 gives us an easy syntax and support for asynchronous and configurable module loading.</p>

<p><strong>Async model</strong>&hairsp;&mdash;&hairsp;no code executes until requested modules are available and processed.</p>

<h3 id="leanpub-auto-named-export">Named export</h3>

<p>Modules can export multiple objects, which could be simple variables or functions.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">export</code> <code class="kd">function</code> <code class="nx">multiply</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can also export a function stored in a variable, but we have to wrap the variable in a set of curly braces.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">multiply</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kr">export</code> <code class="p">{</code> <code class="nx">multiply</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can even export many objects and like in the above example&hairsp;&mdash;&hairsp;we have to wrap exported statements in a set of curly braces if we use one export keyword.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">export</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">;</code>
<code class="lineno"> 2</code> <code class="kr">export</code> <code class="kd">function</code> <code class="nx">multiply</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="c1">// === OR ===</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="kd">var</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">,</code>
<code class="lineno"> 9</code>     <code class="nx">multiply</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>       <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">11</code>     <code class="p">};</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kr">export</code> <code class="p">{</code> <code class="nx">hello</code><code class="p">,</code> <code class="nx">multiply</code> <code class="p">};</code>
</pre></div>

</div>

<p>Let's just imagine that we have <strong>modules.js</strong> file with all exported statements. To import them in another file (<strong>in the same directory</strong>) we use  <strong>import { .. } from</strong> .. syntax:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">hello</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p><strong>We can omit .js extension just like in CommonJS and AMD.</strong></p>

<p>We can even import many statements:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">hello</code><code class="p">,</code> <code class="nx">multiply</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p>Imports may also be <strong>aliased</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">multiply</code> <code class="nx">as</code> <code class="nx">pow2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p>..and use <strong>wildcard</strong> (*) to import all exported statemets:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="o">*</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<h3 id="leanpub-auto-default-export">Default export</h3>

<p>In our module, we can have many named exports, but we can also have a <strong>default export</strong>. It's because our module could be a large library and with default export we can import then an entire module. It could be also useful when our module has single value or model (class / constructor).</p>

<p><strong>One default export per module.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
</pre></div>

</div>

<p>This time we don't have to use curly braces for importing and we have a chance to name imported statement as we wish.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="nx">multiply</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="c1">// === OR ===</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kr">import</code> <code class="nx">pow2</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="c1">// === OR ===</code>
<code class="lineno">8</code> 
<code class="lineno">9</code> <code class="p">...</code>
</pre></div>

</div>

<p><strong>Module can have both named exports and a default export.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// modules.js</code>
<code class="lineno">2</code> <code class="kr">export</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">5</code> <code class="p">};</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="c1">// app.js</code>
<code class="lineno">8</code> <code class="kr">import</code> <code class="nx">pow2</code><code class="p">,</code> <code class="p">{</code> <code class="nx">hello</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p><strong>The default export is just a named export with the special name default.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// modules.js</code>
<code class="lineno">2</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">3</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">4</code> <code class="p">};</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="c1">// app.js</code>
<code class="lineno">7</code> <code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<h3 id="leanpub-auto-api">API</h3>

<p>In addition, there is also a programmatic API and it allows to:</p>

<ul>
<li>Programmatically work with modules and scripts</li>
  <li>Configure module loading</li>
</ul>
<p><strong><a href="https://github.com/systemjs/systemjs">SystemJS</a>&hairsp;&mdash;&hairsp;universal dynamic module loader&hairsp;&mdash;&hairsp;loads ES6 modules, AMD, CommonJS and global scripts in the browser and NodeJS. Works with both Traceur and Babel.</strong></p>

<p>Module loader should support:
* Dynamic loading</p>

<ul>
<li>Global namespace isolation</li>
  <li>Nested virtualization</li>
  <li>Compilation hooks</li>
</ul>
<h2 id="leanpub-auto-promises">promises</h2>

<p>Promises aren't a new and shiny idea. I use it every day in my AngularJS code. It's based on <a href="https://github.com/kriskowal/q">kriskowal / q</a> library:</p>

<p><strong>A tool for creating and composing asynchronous promises in JavaScript.</strong></p>

<p>It's a library for asynchronous programming, to make our life easier. But, before I describe promises, I have to write something about callbacks.</p>

<h3 id="leanpub-auto-callbacks-and-callback-hell">Callbacks and callback hell</h3>

<p>Until I remember, JavaScript coders use callbacks for all browser-based asynchronous functions (setTimeout, XMLHttpRequest, etc.).</p>

<p>Look at naive example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'start!'</code><code class="p">);</code>
<code class="lineno"> 2</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ping'</code><code class="p">);</code>
<code class="lineno"> 4</code>   <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'pong'</code><code class="p">);</code>
<code class="lineno"> 6</code>     <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>       <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'end!'</code><code class="p">);</code>
<code class="lineno"> 8</code>     <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno"> 9</code>   <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">10</code> <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="c1">// start!</code>
<code class="lineno">13</code> <code class="c1">// after 1 sec: ping</code>
<code class="lineno">14</code> <code class="c1">// .. 1 sec later: pong</code>
<code class="lineno">15</code> <code class="c1">// .. and: end!</code>
</pre></div>

</div>

<p>We have simple code which prints some statements to the console. I used a <strong>setTimeout</strong> function here, to show callback functions passed to invoke later (1 sec here). It looks terrible and we have only 3 steps here. Let's imagine more steps. It will look like you build a pyramid, not nice, readable code. Awful, right? It's called <strong>callback hell</strong> and we have it everywhere.</p>

<p><a href="http://callbackhell.com/">Callback Hell</a></p>

<h3 id="leanpub-auto-promises-1">Promises</h3>

<p>Support for promises is a very nice addition to the language. It's finally native in the ES6.</p>

<p><strong>Promises are a first class representation of a value that may be made available in the future.</strong></p>

<p>A promise can be:</p>

<ul>
<li>
<strong>fulfilled</strong> - promise succeeded</li>
  <li>
<strong>rejected</strong> - promise failed</li>
  <li>
<strong>pending</strong> - not fulfilled or not rejected yet</li>
  <li>
<strong>settled</strong> - fulfilled or rejected</li>
</ul>
<p>Every returned <strong>promise object</strong> also has a <strong>then</strong> method to execute code when a promise is <strong>settled</strong>.</p>

<p>Yep, promise <strong>object</strong>, because..</p>

<p><strong>callbacks are functions, promises are objects.</strong></p>

<p>Callbacks are blocks of code to execute in response to.. something (event). Promises are objects which store an information about the state.</p>

<p>How does it look like? Let's see:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno">3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno">7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>Promise calls its <strong>resolve function</strong> when it's fulfilled (success) and <strong>reject function</strong> otherwise (failure).</p>

<p>Promises are objects, so it's not passed as arguments like callbacks, it's <strong>returned</strong>. The return statement is an object which is a placeholder for the result, which will be available in the future.</p>

<p>Promises have just one responsibility-<strong>they represent only one</strong> event. Callbacks can handle multiple events, many times.</p>

<p>We can assign returned value (object) to the <strong>let statement</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno">3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno">7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>As I mentioned above-promise object also has a <strong>then</strong> method to execute code when the promise is settled.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">onResolve</code><code class="p">,</code> <code class="nx">onReject</code><code class="p">)</code>
</pre></div>

</div>

<p>We can use this function to handle <strong>onResolve</strong> and <strong>onReject</strong> values returned by a promise. We can handle <strong>success</strong>, <strong>failure</strong> or <strong>both</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno"> 3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno"> 4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno"> 7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno"> 8</code> <code class="p">});</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
<code class="lineno">12</code> <code class="p">},</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
<code class="lineno">14</code> <code class="p">});</code>
<code class="lineno">15</code> <code class="c1">// success</code>
</pre></div>

</div>

<p>Our code above never executes <strong>reject</strong> function, so we can omit it for simplicity:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">4</code> <code class="p">});</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// success</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>Handlers passed to <strong>promise.then</strong> don't just handle the result of the previous promise-they return is turned into a <strong>new promise</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno"> 4</code> <code class="p">});</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// success</code>
<code class="lineno"> 8</code>   <code class="k">return</code> <code class="s1">'another success'</code><code class="p">;</code>
<code class="lineno"> 9</code> <code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// another success</code>
<code class="lineno">11</code> <code class="p">});</code>
</pre></div>

</div>

<p>You can see, that the code based on promises is always <em>flat</em>. No more <strong>callback hell</strong>.</p>

<p>If you are only interested in rejections, you can omit the first parameter.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">let</code> <code class="nx">reason</code> <code class="o">=</code> <code class="s1">'failure'</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">reject</code><code class="p">(</code><code class="nx">reason</code><code class="p">);</code>
<code class="lineno"> 4</code> <code class="p">});</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code>
<code class="lineno"> 7</code>   <code class="kc">null</code><code class="p">,</code>
<code class="lineno"> 8</code>   <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> <code class="p">);</code>
</pre></div>

</div>

<p>But is a more compact way of doing the same thing-<strong>catch()</strong> method.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="kd">let</code> <code class="nx">reason</code> <code class="o">=</code> <code class="s1">'failure'</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">reject</code><code class="p">(</code><code class="nx">reason</code><code class="p">);</code>
<code class="lineno">4</code> <code class="p">});</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>If we have more than one <strong>then()</strong> call, the error is passed on until there is an error handler.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">resolve</code><code class="p">();</code>
<code class="lineno"> 3</code> <code class="p">});</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">promise</code>
<code class="lineno"> 6</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 7</code>     <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 8</code>   <code class="p">})</code>
<code class="lineno"> 9</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">10</code>     <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'failure'</code><code class="p">);</code>
<code class="lineno">11</code>   <code class="p">})</code>
<code class="lineno">12</code>   <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">14</code>   <code class="p">});</code>
</pre></div>

</div>

<p>We can even combine <strong>one or more promises</strong> into new promises without having to take care of ordering of the underlying asynchronous operations yourself.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">doSmth</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'doSmth'</code><code class="p">);</code>
<code class="lineno"> 3</code>   <code class="p">}),</code>
<code class="lineno"> 4</code>   <code class="nx">doSmthElse</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'doSmthElse'</code><code class="p">);</code>
<code class="lineno"> 6</code>   <code class="p">}),</code>
<code class="lineno"> 7</code>   <code class="nx">oneMore</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'oneMore'</code><code class="p">);</code>
<code class="lineno"> 9</code>   <code class="p">});</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
<code class="lineno">12</code>     <code class="nx">doSmth</code><code class="p">,</code>
<code class="lineno">13</code>     <code class="nx">doSmthElse</code><code class="p">,</code>
<code class="lineno">14</code>     <code class="nx">oneMore</code>
<code class="lineno">15</code>   <code class="p">])</code>
<code class="lineno">16</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">17</code>     <code class="kd">let</code> <code class="p">[</code><code class="nx">one</code><code class="p">,</code> <code class="nx">two</code><code class="p">,</code> <code class="nx">three</code><code class="p">]</code> <code class="o">=</code> <code class="nx">response</code><code class="p">;</code>
<code class="lineno">18</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">one</code><code class="p">,</code> <code class="nx">two</code><code class="p">,</code> <code class="nx">three</code><code class="p">);</code> <code class="c1">// doSmth doSmthElse oneMore</code>
<code class="lineno">19</code>   <code class="p">});</code>
</pre></div>

</div>

<p><strong>Promise.all()</strong> takes an array of promises and when all of them are fulfilled, it put their values into the array.</p>

<p>There are two more functions which are useful:</p>

<ul>
<li>
<strong>Promise.resolve(value)</strong> - it returns a promise which resolves to a <strong>value</strong> or returns <strong>value</strong> if <strong>value</strong> is already a promise</li>
  <li>
<strong>Promise.reject(value)</strong> - returns rejected promise with <strong>value</strong> as <strong>value</strong>
</li>
</ul>
<h3 id="leanpub-auto-pitfall">Pitfall</h3>

<p>Promises have its pitfall as well. Let's image that when any exception is thrown within a <strong>then</strong> or the function passed to <strong>new Promise</strong>, will be silently disposed of <strong>unless manually handled</strong>.</p>

<h2 id="leanpub-auto-set-map-weak">set, map, weak</h2>

<p>Sets and maps will be (are) finally available in ES6! No more spartan way to manipulate data structures. This chapter explains how we can deal with <strong>Map</strong>, <strong>Set</strong>, <strong>WeakMap</strong> and <strong>WeakSet</strong>.</p>

<h3 id="leanpub-auto-map">Map</h3>

<p>Maps are a store for <strong>key</strong> / <strong>value</strong> pairs. Key and value could be a primitives or object references.</p>

<p>Let's create a map:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code> <code class="c1">// Map {0 =&gt; 'val1', '1' =&gt; 'val2', Object {key: 2} =&gt; Object \</code>
<code class="lineno">12</code> <code class="p">{</code><code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code><code class="p">}}</code>
</pre></div>

</div>

<p>We can also use a constructor to create the sam map, based on array param passed to the constructor:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code><code class="p">,</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">],</code> <code class="p">[</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">],</code> <code class="p">[{</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">]]);</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code> <code class="c1">// Map {0 =&gt; 'val1', '1' =&gt; 'val2', Object {key: 2} =&gt; Object \</code>
<code class="lineno">10</code> <code class="p">{</code><code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code><code class="p">}}</code>
</pre></div>

</div>

<p>To get a value by using a key, we have to use a <strong>get()</strong> method to do it (surprising):</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'1'</code><code class="p">));</code> <code class="c1">// val2</code>
</pre></div>

</div>

<p>To iterate over the map collection, we can use built-in <strong>forEach</strong> method or use new <strong>for..of</strong> structure:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// forEach</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 3</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 5</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno">10</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="nx">map</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Key</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">key</code><code class="p">}</code> <code class="nx">has</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">value</code><code class="p">}</code><code class="err">`</code><code class="p">);</code>
<code class="lineno">14</code>   <code class="c1">// Key: 0 has value: val1</code>
<code class="lineno">15</code>   <code class="c1">// Key: 1 has value: val2</code>
<code class="lineno">16</code>   <code class="c1">// Key: [object Object] has value: [object Object]</code>
<code class="lineno">17</code> <code class="p">});</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// for..of</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 3</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 5</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno">10</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">map</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Key</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">entry</code><code class="p">[</code><code class="mi">0</code><code class="p">]}</code> <code class="nx">has</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">entry</code><code class="p">[</code><code class="mi">1</code><code class="p">]}</code><code class="err">`</code><code class="p">);</code>
<code class="lineno">14</code>   <code class="c1">// Key: 0 has value: val1</code>
<code class="lineno">15</code>   <code class="c1">// Key: 1 has value: val2</code>
<code class="lineno">16</code>   <code class="c1">// Key: [object Object] has value: [object Object]</code>
<code class="lineno">17</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can also use a couple of methods to iterate:</p>

<ul>
<li>
<strong>entries()</strong>&hairsp;&mdash;&hairsp;get all entries</li>
  <li>
<strong>keys()</strong>&hairsp;&mdash;&hairsp;get only all keys</li>
  <li>
<strong>values()</strong>&hairsp;&mdash;&hairsp;get only all values</li>
</ul>
<p>To check if value is stored in our map, we can use <strong>has()</strong> method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>     <code class="c1">// true</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="s1">'key'</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>

<p>To delete entry, we have <strong>delete()</strong> method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="nx">map</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="s1">'1'</code><code class="p">);</code>
<code class="lineno">14</code> 
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>..and to clear all collection, we use clear() method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code>  <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>      <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>      <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>        <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>      <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">12</code> 
<code class="lineno">13</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">clear</code><code class="p">();</code>
<code class="lineno">14</code> 
<code class="lineno">15</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 0</code>
</pre></div>

</div>

<h3 id="leanpub-auto-set">Set</h3>

<p>It's a collection for <em>unique</em> values. The values could be also a primitives or object references.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">();</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="lineno">4</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s1">'1'</code><code class="p">);</code>
<code class="lineno">5</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">});</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">);</code> <code class="c1">// Set {1, '1', Object {key: 'value'}}</code>
</pre></div>

</div>

<p>Like a map, set allows to create collection by passing an array to its constructor:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">);</code> <code class="c1">// Set {1, '1', Object {key: 'value'}}</code>
</pre></div>

</div>

<p>To iterate over sets we have the same two options&hairsp;&mdash;&hairsp;built-in <strong>forEach</strong> function or <strong>for..of</strong> structure:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// forEach</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">set</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">5</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">6</code>   <code class="c1">// 1</code>
<code class="lineno">7</code>   <code class="c1">// '1'</code>
<code class="lineno">8</code>   <code class="c1">// Object {key: 'value'}</code>
<code class="lineno">9</code> <code class="p">});</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// for..of</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">5</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">6</code>   <code class="c1">// 1</code>
<code class="lineno">7</code>   <code class="c1">// '1'</code>
<code class="lineno">8</code>   <code class="c1">// Object {key: 'value'}</code>
<code class="lineno">9</code> <code class="p">};</code>
</pre></div>

</div>

<p><strong>Set doesn't allow to add duplicates.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">]);</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 5!</code>
</pre></div>

</div>

<p>We can also use <strong>has()</strong>, <strong>delete()</strong>, <strong>clear()</strong> methods, which are similar to the Map versions.</p>

<h3 id="leanpub-auto-weakmap">WeakMap</h3>

<p>WeakMaps provides leak-free object keyed side tables. It's a Map that doesn't prevent its keys from being <strong>garbage-collected</strong>. We don't have to worry about memory leaks.</p>

<p>If the object is destroyed, the garbage collector removes an entry from the WeakMap and frees memory.</p>

<p><strong>Keys must be objects.</strong></p>

<p>It has almost the same API like a Map, but we <strong>can't iterate</strong> over the WeakMap collection. We can't even determine the length of the collection because we don't have <strong>size</strong> attribute here.</p>

<p>The API looks like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">WeakMap</code><code class="p">([</code><code class="nx">iterable</code><code class="p">])</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>        <code class="o">:</code> <code class="nx">any</code>
<code class="lineno">4</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="o">:</code> <code class="k">this</code>
<code class="lineno">5</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>        <code class="o">:</code> <code class="kr">boolean</code>
<code class="lineno">6</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>     <code class="o">:</code> <code class="kr">boolean</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">wm</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakMap</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>       <code class="nx">key1</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 4</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v1'</code>
<code class="lineno"> 5</code>       <code class="p">},</code>
<code class="lineno"> 6</code>       <code class="nx">key2</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 7</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v2'</code>
<code class="lineno"> 8</code>       <code class="p">}</code>
<code class="lineno"> 9</code>    <code class="p">};</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">wm</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno">12</code> <code class="nx">wm</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key2</code><code class="p">,</code> <code class="s1">'val2'</code><code class="p">);</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">);</code> <code class="c1">// WeakMap {Object {k: 'v1'} =&gt; 'val1', Object {k: 'v2'} =&gt; 'va\</code>
<code class="lineno">15</code> <code class="nx">l2</code><code class="err">'</code><code class="p">}</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// true</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="k">delete</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">;</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>

<h3 id="leanpub-auto-weakset">WeakSet</h3>

<p>Like a WeakMap, WeakSet is a Seat that doesn't prevent its values from being garbage-collected. It has simpler API than WeakMap, because has only three methods:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">([</code><code class="nx">iterable</code><code class="p">])</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>    <code class="o">:</code> <code class="nx">any</code>
<code class="lineno">4</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>    <code class="o">:</code> <code class="kr">boolean</code>
<code class="lineno">5</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">:</code> <code class="kr">boolean</code>
</pre></div>

</div>

<p><strong>WeakSets are collections of unique objects only.</strong></p>

<p>WeakSet collection can't be iterated and we cannot determine its size.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">ws</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>       <code class="nx">key1</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 4</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v1'</code>
<code class="lineno"> 5</code>       <code class="p">},</code>
<code class="lineno"> 6</code>       <code class="nx">key2</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 7</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v2'</code>
<code class="lineno"> 8</code>       <code class="p">}</code>
<code class="lineno"> 9</code>    <code class="p">};</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">ws</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">);</code>
<code class="lineno">12</code> <code class="nx">ws</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key2</code><code class="p">);</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">);</code> <code class="c1">// WeakSet {Object {k: 'v1'}, Object {k: 'v2'}}</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// true</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="k">delete</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">;</code>
<code class="lineno">18</code> 
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>
</div>


</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Symbols in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>Buon giorno! Willkommen to <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 &ndash; <em>"I can't believe this is yet another installment"</em> &ndash; in Depth</a>. If you have no idea how you got here or what ES6 even is, I recommend reading <a aria-label="A Brief History of ES6 Tooling on Pony Foo" href="/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, and <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a>. Today we'll be discussing <em>Symbols</em>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for listening to that, and let's go into symbols now! For a bit of context, you may want to check out the last two articles, &ndash; on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a> and <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a> &ndash; where we first talked about Symbols.</p></section>
		<section class="md-markdown at-body"><h2 id="what-are-symbols">What are Symbols?</h2><p>Symbols are a new primitive type in ES6. If you ask me, they're <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code class="md-code md-code-inline">Symbol</code> wrapper object.</p><p>We can create our own Symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol()
</code></pre><p>Note that there was no <code class="md-code md-code-inline">new</code>. The <code class="md-code md-code-inline">new</code> operator even throws a <code class="md-code md-code-inline">TypeError</code> when we try it on <code class="md-code md-code-inline">Symbol</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> oops = <span class="md-code-keyword">new</span> Symbol()
<span class="md-code-comment">// &lt;- TypeError</span>
</code></pre><p>For debugging purposes, you can describe symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol(<span class="md-code-string">'this is a descriptive description'</span>)
</code></pre><p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol() === Symbol())
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(Symbol(<span class="md-code-string">'foo'</span>) === Symbol(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre><p>Symbols are <em>symbols</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol())
<span class="md-code-comment">// &lt;- 'symbol'</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- 'symbol'</span>
</code></pre><p>There are three different flavors of symbols &ndash; each flavor is accessed in a different way. We'll explore each of these and slowly figure out what all of this means.</p><ul><li>You can access local symbols by obtaining a reference to them <em>directly</em></li><li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li><li>"Well-known" symbols exist across <em>realms</em> &ndash; but you can't create them and they're not on the <em>global registry</em></li></ul><p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code class="md-code md-code-inline">&lt;iframe&gt;</code> within your page.</p><h2 id="the-runtime-wide-symbol-registry">The "Runtime-Wide" Symbol Registry</h2><p>There's two methods you can use to add symbols to the runtime-wide symbol registry: <code class="md-code md-code-inline">Symbol.for(key)</code> and <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code>. What do these do?</p><h3 id="symbolfor-key"><code class="md-code md-code-inline">Symbol.for(key)</code></h3><p>This method looks up <code class="md-code md-code-inline">key</code> in the runtime-wide symbol registry. If a symbol with that <code class="md-code md-code-inline">key</code> exists in the global registry, that symbol is returned. If no symbol with that <code class="md-code md-code-inline">key</code> is found in the registry, one is created. That's to say, <code class="md-code md-code-inline">Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code class="md-code md-code-inline">Symbol.for('foo')</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code class="md-code md-code-inline">key</code> is already in the registry by then &ndash; and associated to the symbol returned by the first call.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">Symbol.for(<span class="md-code-string">'foo'</span>) === Symbol.for(<span class="md-code-string">'foo'</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code class="md-code md-code-inline">key</code>. Note that your <code class="md-code md-code-inline">key</code> will also be used as a <code class="md-code md-code-inline">description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don't just name your symbols <code class="md-code md-code-inline">'user'</code> or some generic name like that.</p><h3 id="symbolkeyfor-symbol"><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code></h3><p>Given a symbol <code class="md-code md-code-inline">symbol</code>, <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> returns the <code class="md-code md-code-inline">key</code> that was associated with <code class="md-code md-code-inline">symbol</code> when the symbol was added to the global registry.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> symbol = Symbol.for(<span class="md-code-string">'foo'</span>)
<span class="md-code-built_in">console</span>.log(Symbol.keyFor(symbol))
<span class="md-code-comment">// &lt;- 'foo'</span>
</code></pre><h3 id="how-wide-is-runtime-wide">How Wide is Runtime-Wide?</h3><p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I'll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">'iframe'</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.for(<span class="md-code-string">'foo'</span>) === frame.contentWindow.Symbol.for(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><h2 id="the-well-known-symbols">The "Well-Known" Symbols</h2><p>Let me put you at ease: <strong>these aren't actually well-known at all.</strong> Far from it. I didn't have any idea these things existed until a few months ago. Why are they <em>"well-known"</em>, then? That's because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren't exposed to user code before ES6, but now you can fiddle with them.</p><p>A great example of a <em>"well-known"</em> symbol is something we've already been playing with on Pony Foo: the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code class="md-code md-code-inline">@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There's <a aria-label="Well-known symbols on MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p><p>One of the well-known symbols that <em>is</em> documented at this time is <a aria-label="Symbol.match on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match"><code class="md-code md-code-inline">Symbol.match</code></a>. According to MDN, you can set the <code class="md-code md-code-inline">Symbol.match</code> property on regular expressions to <code class="md-code md-code-inline">false</code> and have them behave as string literals when matching <em>(instead of regular expressions, which don't play nice with <a aria-label="String.prototype.startsWith() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith"><code class="md-code md-code-inline">.startsWith</code></a>, <a aria-label="String.prototype.endsWith() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith"><code class="md-code md-code-inline">.endsWith</code></a>, or <a aria-label="String.prototype.includes() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes"><code class="md-code md-code-inline">.includes</code></a>)</em>.</p><p>This part of the spec hasn't been implemented in Babel yet, <em>&ndash; I assume that's just because it's not worth the trouble &ndash;</em> but supposedly it goes like this.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">'/foo/'</span>
<span class="md-code-keyword">var</span> literal = <span class="md-code-regexp">/foo/</span>
<mark class="md-mark md-code-mark">literal[Symbol.match] = false</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(literal))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Why you'd want to do that instead of just casting <code class="md-code md-code-inline">literal</code> to a string <em>is beyond me</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">'/foo/'</span>
<span class="md-code-keyword">var</span> casted = <span class="md-code-regexp">/foo/</span><mark class="md-mark md-code-mark">.toString()</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(casted))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don't think it'll become a front-end development staple anytime soon.</p><blockquote><p>Regardless, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> is actually very useful, and I'm sure other well-known symbols are useful as well.</p></blockquote><p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they're not accessible through the <em>global registry</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">'iframe'</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.iterator === frame.contentWindow.Symbol.iterator)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Not accessible through the <em>global registry</em>? Nope!</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol.keyFor(Symbol.iterator))
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre><p>Accessing them statically from anywhere should be more than enough, though.</p><h2 id="symbols-and-iteration">Symbols and Iteration</h2><p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol()]: <span class="md-code-string">'foo'</span>,
  [Symbol(<span class="md-code-string">'foo'</span>)]: <span class="md-code-string">'bar'</span>,
  [Symbol.for(<span class="md-code-string">'bar'</span>)]: <span class="md-code-string">'baz'</span>,
  what: <span class="md-code-string">'ever'</span>
}
<span class="md-code-built_in">console</span>.log([...foo])
<span class="md-code-comment">// &lt;- []</span>
</code></pre><p>The ES5 <code class="md-code md-code-inline">Object.keys</code> method ignores symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.keys(foo))
<span class="md-code-comment">// &lt;- ['what']</span>
</code></pre><p>Same goes for <code class="md-code md-code-inline">JSON.stringify</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">JSON</span>.stringify(foo))
<span class="md-code-comment">// &lt;- {"what":"ever"}</span>
</code></pre><p>So, <code class="md-code md-code-inline">for..in</code> then? Nope.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key <span class="md-code-keyword">in</span> foo) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- 'what'</span>
}
</code></pre><p>I know, <code class="md-code md-code-inline">Object.getOwnPropertyNames</code>. Nah! <em>&ndash; but close.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyNames(foo))
<span class="md-code-comment">// &lt;- ['what']</span>
</code></pre><p>You need to be explicitly looking for symbols to stumble upon them. They're like JavaScript neutrinos. You can use <a aria-label="Object.getOwnPropertySymbols() &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> to detect them.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo))
<span class="md-code-comment">// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')]</span>
</code></pre><p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code class="md-code md-code-inline">for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won't be as disappointing as the flukes in the snippet below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> symbol of <span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo)) {
  <span class="md-code-built_in">console</span>.log(foo[symbol])
  <span class="md-code-comment">// &lt;- 'foo'</span>
  <span class="md-code-comment">// &lt;- 'bar'</span>
  <span class="md-code-comment">// &lt;- 'baz'</span>
}
</code></pre><h2 id="why-would-i-want-symbols">Why Would I Want Symbols?</h2><p>There's a few different uses for symbols.</p><h3 id="name-clashes">Name Clashes</h3><p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>"objects as hash maps"</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p><h3 id="privacy">"Privacy"?</h3><p>Symbols are <em>invisible to all "reflection" methods before ES6</em>. This can be useful in some scenarios, but they're not private by any stretch of imagination, as we've just demonstrated with the <a aria-label="Object.getOwnPropertySymbols() &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> API.</p><p>That being said, the fact that you have to actively look for symbols to find them means they're useful in situations where you want to define metadata that shouldn't be part of iterable sequences for arrays or any <em>iterable</em> objects.</p><h3 id="defining-protocols">Defining Protocols</h3><p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> &ndash; just like there's <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p><p>Imagine for instance a library like <a aria-label="bevacqua/dragula on GitHub" href="https://github.com/bevacqua/dragula"><code class="md-code md-code-inline">dragula</code></a> defining a protocol through <code class="md-code md-code-inline">Symbol.for('dragula.moves')</code>, where you could add a method on that <code class="md-code md-code-inline">Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code class="md-code md-code-inline">dragula</code> could call the <code class="md-code md-code-inline">el[Symbol.for('dragula.moves')]()</code> user-defined method to assert whether the element can be moved.</p><p>This way, the logic about elements being draggable by <code class="md-code md-code-inline">dragula</code> is shifted from a single place for the entire <code class="md-code md-code-inline">drake</code> <em>(the <code class="md-code md-code-inline">options</code> for an instance of <code class="md-code md-code-inline">dragula</code>)</em>, to each individual DOM element. That'd make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code class="md-code md-code-inline">options.moves</code> method.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 JavaScript Destructuring in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>I've briefly mentioned a few ES6 features <em>(and how to <a aria-label="Setting up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">get started with Babel</a>)</em> in the React article series I've been writing about, and now I want to <strong>focus on the language features</strong> themselves. I've read a <em>ton</em> about ES6 and ES7 and it's about time we started discussing ES6 and ES7 features here in Pony Foo.</p><p>This article <strong>warns about going overboard</strong> with ES6 language features. Then we'll start off the series by discussing about Destructuring in ES6, and when it's most useful, as well as some of its gotchas and caveats.</p><h2 id="a-word-of-caution">A word of caution</h2><p>When uncertain, chances are <mark class="md-mark">you probably should default to ES5 and older syntax instead of adopting ES6 just because you can</mark>. By this I don't mean that using ES6 syntax is a bad idea &ndash; quite the opposite, see I'm writing an article about ES6! My concern lies with the fact that when we adopt ES6 features we must do it because <strong>they'll absolutely improve our code quality</strong>, and not just because of the <em>"cool factor"</em> &ndash; whatever that may be.</p><p>The approach I've been taking thus far is to write things in <em>plain ES5</em>, and then adding ES6 sugar on top where it'd genuinely improve my code. I presume over time I'll be able to more quickly identify scenarios where a ES6 feature may be worth using over ES5, but when getting started it might be a good idea <em>not</em> to go overboard too soon. Instead, carefully analyze what would fit your code best first, and <strong>be mindful of adopting ES6</strong>.</p><blockquote><p>This way, you'll <strong>learn to use</strong> the new features in your favor, rather than just <em>learning the syntax</em>.</p></blockquote><p>Onto the cool stuff now!</p></section>
		<section class="md-markdown at-body"><h2 id="destructuring">Destructuring</h2><p>This is easily one of the features I've been using the most. It's also one of the simplest. It binds properties to as many variables as you need and it works with both Arrays and Objects.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: <span class="md-code-string">'pony'</span>, baz: <span class="md-code-number">3</span> }
<span class="md-code-keyword">var</span> {bar, baz} = foo
<span class="md-code-built_in">console</span>.log(bar)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>It makes it very quick to pull out a specific property from an object. You're also allowed to map properties into aliases as well.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: <span class="md-code-string">'pony'</span>, baz: <span class="md-code-number">3</span> }
<span class="md-code-keyword">var</span> {bar: a, baz: b} = foo
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>You can also pull properties as deep as you want, and you could also alias those deep bindings.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: { deep: <span class="md-code-string">'pony'</span>, dangerouslySetInnerHTML: <span class="md-code-string">'lol'</span> } }
<span class="md-code-keyword">var</span> {bar: { deep, dangerouslySetInnerHTML: sure }} = foo
<span class="md-code-built_in">console</span>.log(deep)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(sure)
<span class="md-code-comment">// &lt;- 'lol'</span>
</code></pre><p>By default, properties that aren't found will be <code class="md-code md-code-inline">undefined</code>, just like when accessing properties on an object with the dot or bracket notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo} = {bar: <span class="md-code-string">'baz'</span>}
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre><p>If you're trying to access a deeply nested property of a parent that doesn't exist, then you'll get an exception, though.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo:{bar}} = {baz: <span class="md-code-string">'ouch'</span>}
<span class="md-code-comment">// &lt;- Exception</span>
</code></pre><p>That makes a lot of sense, if you think of destructuring as sugar for ES5 like the code below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> _temp = { baz: <span class="md-code-string">'ouch'</span> }
<span class="md-code-keyword">var</span> bar = _temp.foo.bar
<span class="md-code-comment">// &lt;- Exception</span>
</code></pre><p>A cool property of destructuring is that it allows you to swap variables without the need for the infamous <code class="md-code md-code-inline">aux</code> variable.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">es5</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> left = <span class="md-code-number">10</span>
  <span class="md-code-keyword">var</span> right = <span class="md-code-number">20</span>
  <span class="md-code-keyword">var</span> aux
  <span class="md-code-keyword">if</span> (right &gt; left) {
    aux = right
    right = left
    left = aux
  }
}
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">es6</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> left = <span class="md-code-number">10</span>
  <span class="md-code-keyword">var</span> right = <span class="md-code-number">20</span>
  <span class="md-code-keyword">if</span> (right &gt; left) {
    <mark class="md-mark md-code-mark">[left, right] = [right, left]</mark>
  }
}
</code></pre><p>Another convenient aspect of destructuring is the ability to pull keys using <a aria-label="Computed Property Names &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names">computed property names</a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> key = <span class="md-code-string">'such_dynamic'</span>
<span class="md-code-keyword">var</span> { <mark class="md-mark md-code-mark">[key]</mark>: foo } = { such_dynamic: <span class="md-code-string">'bar'</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 'bar'</span>
</code></pre><p>In ES5, that'd take an extra statement and variable allocation on your behalf.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> key = <span class="md-code-string">'such_dynamic'</span>
<span class="md-code-keyword">var</span> baz = { such_dynamic: <span class="md-code-string">'bar'</span> }
<span class="md-code-keyword">var</span> foo = baz[key]
<span class="md-code-built_in">console</span>.log(foo)
</code></pre><p>You can also define default values, for the case where the pulled property evaluates to <code class="md-code md-code-inline">undefined</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { foo: <span class="md-code-number">2</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 2</span>
<span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { foo: <span class="md-code-literal">undefined</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { bar: <span class="md-code-number">2</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>Destructuring works for Arrays as well, as we mentioned earlier. Note how I'm <strong>using square brackets</strong> in the destructuring side of the declaration now.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [a] = [<span class="md-code-number">10</span>]
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 10</span>
</code></pre><p>Here, again, we can use the default values and follow the same rules.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [a] = []
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- undefined</span>
<span class="md-code-keyword">var</span> [b=<span class="md-code-number">10</span>] = [<span class="md-code-literal">undefined</span>]
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 10</span>
<span class="md-code-keyword">var</span> [c=<span class="md-code-number">10</span>] = []
<span class="md-code-built_in">console</span>.log(c)
<span class="md-code-comment">// &lt;- 10</span>
</code></pre><p>When it comes to Arrays you can conveniently skip over elements that you don't care about.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [,,a,b] = [<span class="md-code-number">1</span>,<span class="md-code-number">2</span>,<span class="md-code-number">3</span>,<span class="md-code-number">4</span>,<span class="md-code-number">5</span>]
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 4</span>
</code></pre><p>You can also use destructuring in a <code class="md-code md-code-inline">function</code>s parameter list.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">function greet ({ age, name:greeting='she' }) {
  console.log(<mark class="md-mark md-code-mark">`${greeting} is ${age} years old.`</mark>)
}
greet({ name: 'nico', age: 27 })
// &lt;- 'nico is 27 years old'
greet({ age: 24 })
// &lt;- 'she is 24 years old'
</code></pre><p>That's roughly <strong>how</strong> you can use destructuring. What is destructuring <strong>good</strong> for?</p><h2 id="use-cases-for-destructuring">Use Cases for Destructuring</h2><p>There are many situations where destructuring comes in handy. Here's some of the most common ones. Whenever you have a method that returns an object, destructuring makes it much terser to interact with.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getCoords</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> {
    x: <span class="md-code-number">10</span>,
    y: <span class="md-code-number">22</span>
  }
}
<span class="md-code-keyword">var</span> {x, y} = getCoords()
<span class="md-code-built_in">console</span>.log(x)
<span class="md-code-comment">// &lt;- 10</span>
<span class="md-code-built_in">console</span>.log(y)
<span class="md-code-comment">// &lt;- 22</span>
</code></pre><p>A similar use case but in the opposite direction is being able to define default options when you have a method with a bunch of options that need default values. This is particularly interesting as an alternative to named parameters in other languages like Python and C#.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">random</span> <span class="md-code-params">({ min=1, max=300 })</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.floor(<span class="md-code-built_in">Math</span>.random() * (max - min)) + min
}
<span class="md-code-built_in">console</span>.log(random({}))
<span class="md-code-comment">// &lt;- 174</span>
<span class="md-code-built_in">console</span>.log(random({max: <span class="md-code-number">24</span>}))
<span class="md-code-comment">// &lt;- 18</span>
</code></pre><p>If you wanted to make the options object <em>entirely optional</em> you could change the syntax to the following.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">random</span> <span class="md-code-params">({ min=1, max=300 }<mark class="md-mark md-code-mark"> = {}</mark>)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.floor(<span class="md-code-built_in">Math</span>.random() * (max - min)) + min
}
<span class="md-code-built_in">console</span>.log(random())
<span class="md-code-comment">// &lt;- 133</span>
</code></pre><p>A great fit for destructuring are things like regular expressions, where you would just love to name parameters without having to resort to index numbers. Here's an example parsing a URL with a random <code class="md-code md-code-inline">RegExp</code> <a aria-label="Getting parts of a URL on StackOverflow" href="http://stackoverflow.com/a/27755/389745">I got on StackOverflow</a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getUrlParts</span> <span class="md-code-params">(url)</span> </span>{
  <span class="md-code-keyword">var</span> magic = <span class="md-code-regexp">/^(https?):\/\/(ponyfoo\.com)(\/articles\/([a-z0-9-]+))$/</span>
  <span class="md-code-keyword">return</span> magic.exec(url)
}
<span class="md-code-keyword">var</span> parts = getUrlParts(<span class="md-code-string">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)
<span class="md-code-keyword">var</span> [,protocol,host,pathname,slug] = parts
<span class="md-code-built_in">console</span>.log(protocol)
<span class="md-code-comment">// &lt;- 'http'</span>
<span class="md-code-built_in">console</span>.log(host)
<span class="md-code-comment">// &lt;- 'ponyfoo.com'</span>
<span class="md-code-built_in">console</span>.log(pathname)
<span class="md-code-comment">// &lt;- '/articles/es6-destructuring-in-depth'</span>
<span class="md-code-built_in">console</span>.log(slug)
<span class="md-code-comment">// &lt;- 'es6-destructuring-in-depth'</span>
</code></pre><h3 id="special-case-import-statements">Special Case: <code class="md-code md-code-inline">import</code> Statements</h3><p>Even though <code class="md-code md-code-inline">import</code> statements don't follow destructuring rules, they behave a bit similarly. This is probably the <em>"destructuring-like"</em> use case I find myself using the most, even though it's not actually destructuring. Whenever you're writing module <code class="md-code md-code-inline">import</code> statements, you can pull just what you need from a module's public API. An example using <a aria-label="bevacqua/contra on GitHub" href="https://github.com/bevacqua/contra"><code class="md-code md-code-inline">contra</code></a>:</p><pre class="md-code-block"><code class="md-code md-lang-javascript">import {series, concurrent, map } from <span class="md-code-string">'contra'</span>
series(tasks, done)
concurrent(tasks, done)
map(items, mapper, done)
</code></pre><p>Note that, however, <code class="md-code md-code-inline">import</code> statements have a different syntax. When compared against destructuring, none of the following <code class="md-code md-code-inline">import</code> statements will work.</p><ul><li>Use defaults values such as <code class="md-code md-code-inline">import {series = noop} from 'contra'</code></li><li>"Deep" destructuring style like <code class="md-code md-code-inline">import {map: { series }} from 'contra'</code></li><li>Aliasing syntax <code class="md-code md-code-inline">import {map: mapAsync} from 'contra'</code></li></ul><p>The main reason for these limitations is that the <code class="md-code md-code-inline">import</code> statement brings in a <em>binding</em>, and not a reference or a value. This is an important differentiation that we'll explore more in depth in a future article about ES6 modules.</p><blockquote><p>I'll keep posting about ES6 &amp; ES7 features every day, so make sure to subscribe if you want to know more!</p></blockquote><p><sub><mark class="md-mark">*</mark> How about we visit string interpolation tomorrow?</sub><br><sub><mark class="md-mark">**</mark>We'll leave arrow functions for monday!</sub></p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Generators in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>This is <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a>, the longest-running article series in the history of Pony Foo! Trapped in the ES5 bubble? Welcome! Let me get you started with <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, and <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">Iterators</a>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for listening to that, and let's go into generators now! If you haven't yet, you should read yesterday's article on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, as this article pretty much assumes that you've read it.</p></section>
		<section class="md-markdown at-body"><h2 id="generator-functions-and-generator-objects">Generator Functions and Generator Objects</h2><p>Generators are a new feature in ES6. You declare a <em>generator function</em> which returns generator objects <code class="md-code md-code-inline">g</code> that can then be iterated using any of <a aria-label="Array.from() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"><code class="md-code md-code-inline">Array.from(g)</code></a>, <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth"><code class="md-code md-code-inline">[...g]</code></a>, or <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">for value of g</code></a> loops. Generator functions allow you to declare a special kind of <em>iterator</em>. These iterators can suspend execution while retaining their context. We already examined iterators in <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">the previous article</a> and how their <code class="md-code md-code-inline">.next()</code> method is called once at a time to pull values from a sequence.</p><p>Here is an example generator function. Note the <code class="md-code md-code-inline">*</code> after <code class="md-code md-code-inline">function</code>. That's not a typo, that's how you mark a generator function as a <em>generator</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
}
</code></pre><p>Generator objects conform to both the <em>iterable</em> protocol and the <em>iterator</em> protocol. This means</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> g = <mark class="md-mark md-code-mark">generator()</mark>
<span class="md-code-comment">// a generator object g is built using the generator function</span>
<span class="md-code-keyword">typeof</span> g[Symbol.iterator] === <span class="md-code-string">'function'</span>
<span class="md-code-comment">// it's an iterable because it has an @@iterator</span>
<span class="md-code-keyword">typeof</span> g.next === <span class="md-code-string">'function'</span>
<span class="md-code-comment">// it's also an iterator because it has a .next method</span>
g[Symbol.iterator]() === g
<span class="md-code-comment">// the iterator for a generator object is the generator object itself</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">[...g]</mark>)
<span class="md-code-comment">// &lt;- ['f', 'o', 'o']</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">Array.from(g)</mark>)
<span class="md-code-comment">// &lt;- ['f', 'o', 'o']</span>
</code></pre><p><sub><em>(This article is starting to sound an awful lot like a Math course)</em></sub></p><p>When you create a generator object <em>(I'll just call them "generator" from here on out)</em>, you'll get an <em>iterator</em> that uses the generator to produce its <em>sequence</em>. Whenever a <code class="md-code md-code-inline">yield</code> expression is reached, that value is emitted by the iterator and <strong>function execution is suspended</strong>.</p><p>Let's use a different example, this time with some other statements mixed in between <code class="md-code md-code-inline">yield</code> expressions. This is a simple generator but it behaves in an interesting enough way for our purposes here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'p'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'n'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'y'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'!'</span>)
}
</code></pre><p>If we use a <code class="md-code md-code-inline">for..of</code> loop, this will print <code class="md-code md-code-inline">ponyfoo!</code> one character at a time, as expected.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = generator()
<span class="md-code-keyword">for</span> (<mark class="md-mark md-code-mark">let pony of foo</mark>) {
  <span class="md-code-built_in">console</span>.log(pony)
  <span class="md-code-comment">// &lt;- 'p'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- 'n'</span>
  <span class="md-code-comment">// &lt;- 'y'</span>
  <span class="md-code-comment">// &lt;- 'f'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- '!'</span>
}
</code></pre><p>What about using the spread <code class="md-code md-code-inline">[...foo]</code> syntax? Things turn out a little different here. This might be a little unexpected, but that's how generators work, everything that's not yielded ends up becoming <strong>a side effect</strong>. As the sequence is being constructed, the <code class="md-code md-code-inline">console.log</code> statements in between <code class="md-code md-code-inline">yield</code> calls are executed, and they print characters to the console before <code class="md-code md-code-inline">foo</code> is spread over an array. The previous example worked because we were printing characters as soon as they were pulled from the sequence, instead of waiting to construct a range for the entire sequence first.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = generator()
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">[...foo]</mark>)
<span class="md-code-comment">// &lt;- 'o'</span>
<span class="md-code-comment">// &lt;- 'y'</span>
<span class="md-code-comment">// &lt;- 'o'</span>
<span class="md-code-comment">// &lt;- '!'</span>
<span class="md-code-comment">// &lt;- ['p', 'n', 'f', 'o']</span>
</code></pre><p>A neat aspect of generator functions is that you can also use <code class="md-code md-code-inline">yield*</code> to delegate to another generator function. Want a very contrived way to split <code class="md-code md-code-inline">'ponyfoo'</code> into individual characters? Since strings in ES6 adhere to the <em>iterable</em> protocol, you could do the following.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span>* <span class="md-code-string">'ponyfoo'</span>
}
<span class="md-code-built_in">console</span>.log([...generator()])
<span class="md-code-comment">// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']</span>
</code></pre><p>Of course, in the real world you could just do <code class="md-code md-code-inline">[...'ponyfoo']</code>, since spread supports iterables just fine. Just like you could <code class="md-code md-code-inline">yield*</code> a string, you can <code class="md-code md-code-inline">yield*</code> anything that adheres to the iterable protocol. That includes other generators, arrays, and come ES6 &ndash; <em>just about anything.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol.iterator]: () =&gt; ({
    items: <mark class="md-mark md-code-mark">[<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>, <span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>, <span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>, <span class="md-code-string">'o'</span>]</mark>,
    next: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">next</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">return</span> {
        done: <span class="md-code-keyword">this</span>.items.length === <span class="md-code-number">0</span>,
        value: <span class="md-code-keyword">this</span>.items.shift()
      }
    }
  })
}
<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">multiplier</span> <span class="md-code-params">(value)</span> </span>{
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">2</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">3</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">4</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">5</span>
}
<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">trailmix</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">0</span>
  <span class="md-code-keyword">yield</span>* [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]
  <span class="md-code-keyword">yield</span>* <mark class="md-mark md-code-mark">[...multiplier(<span class="md-code-number">2</span>)]</mark>
  <span class="md-code-keyword">yield</span>* multiplier(<span class="md-code-number">3</span>)
  <span class="md-code-keyword">yield</span>* <mark class="md-mark md-code-mark">foo</mark>
}
<span class="md-code-built_in">console</span>.log([...trailmix()])
<span class="md-code-comment">// &lt;- [0, 1, 2, <mark class="md-mark md-code-mark">4, 6, 8, 10</mark>, 6, 9, 12, 15, <mark class="md-mark md-code-mark">'p', 'o', 'n', 'y', 'f', 'o', 'o'</mark>]</span>
</code></pre><p>You could also iterate the sequence by hand, calling <code class="md-code md-code-inline">.next()</code>. This approach gives you the most control over the iteration, but it's also the most involved. There's a few features you can leverage here that give you even more control over the iteration.</p><h2 id="iterating-over-generators-by-hand">Iterating Over Generators by Hand</h2><p>Besides iterating over <code class="md-code md-code-inline">trailmix</code> as we've already covered, using <code class="md-code md-code-inline">[...trailmix()]</code>, <code class="md-code md-code-inline">for value of trailmix()</code>, and <code class="md-code md-code-inline">Array.from(trailmix())</code>, we could use the generator returned by <code class="md-code md-code-inline">trailmix()</code> directly, and iterate over that. But <code class="md-code md-code-inline">trailmix</code> was an overcomplicated showcase of <code class="md-code md-code-inline">yield*</code>, let's go back to the <em>side-effects</em> <code class="md-code md-code-inline">generator</code> for this one.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'p'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'n'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'y'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'!'</span>)
}
<span class="md-code-keyword">var</span> g = generator()
<span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
  <span class="md-code-keyword">let</span> item = <mark class="md-mark md-code-mark">g.next()</mark>
  <span class="md-code-keyword">if</span> (item.done) {
    <span class="md-code-keyword">break</span>
  }
  <span class="md-code-built_in">console</span>.log(item.value)
}
</code></pre><p>Just like we <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">learned yesterday</a>, any items returned by an iterator will have a <code class="md-code md-code-inline">done</code> property that indicates whether the sequence has reached its end, and a <code class="md-code md-code-inline">value</code> indicating the current value in the sequence.</p><blockquote><p>If you're confused as to <strong>why the <code class="md-code md-code-inline">'!'</code> is printed</strong> even though there are no more <code class="md-code md-code-inline">yield</code> expressions after it, that's because <code class="md-code md-code-inline">g.next()</code> doesn't know that. The way it works is that each time its called, it executes the method until a <code class="md-code md-code-inline">yield</code> expression is reached, emits its value and <em>suspends execution</em>. The next time <code class="md-code md-code-inline">g.next()</code> is called, _execution is resumed _from where it left off <em>(the last <code class="md-code md-code-inline">yield</code> expression)</em>, until the next <code class="md-code md-code-inline">yield</code> expression is reached. When no <code class="md-code md-code-inline">yield</code> expression is reached, the generator returns <code class="md-code md-code-inline">{ done: true }</code>, signaling that the sequence has ended. At this point, the <code class="md-code md-code-inline">console.log('!')</code> statement has been already executed, though.</p><p>It's also worth noting that <strong>context is preserved</strong> across suspensions and resumptions. That means generators can be stateful. Generators are, in fact, the underlying implementation for <code class="md-code md-code-inline">async</code>/<code class="md-code md-code-inline">await</code> semantics coming in ES7.</p></blockquote><p>Whenever <code class="md-code md-code-inline">.next()</code> is called on a generator, there's four "events" that will suspend execution in the generator, returning an <em><code class="md-code md-code-inline">IteratorResult</code></em> to the caller of <code class="md-code md-code-inline">.next()</code>.</p><ul><li>A <code class="md-code md-code-inline">yield</code> expression returning the <em>next</em> value in the sequence</li><li>A <code class="md-code md-code-inline">return</code> statement returning the <em>last</em> value in the sequence</li><li>A <code class="md-code md-code-inline">throw</code> statement halts execution in the generator entirely</li><li>Reaching the end of the generator function signals <code class="md-code md-code-inline">{ done: true }</code></li></ul><p>Once the <code class="md-code md-code-inline">g</code> generator ended iterating over a sequence, subsequent calls to <code class="md-code md-code-inline">g.next()</code> will have no effect and just return <code class="md-code md-code-inline">{ done: true }</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'only'</span>
}
<span class="md-code-keyword">var</span> g = generator()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 'only' }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><h2 id="generators-the-del-weird-del-ins-awesome-ins-parts">Generators: The <del>Weird</del> <ins><em>Awesome</em></ins> Parts</h2><p>Generator objects come with a couple more methods besides <a aria-label="Generator.prototype.next() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next"><code class="md-code md-code-inline">.next</code></a>. These are <a aria-label="Generator.prototype.return() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return"><code class="md-code md-code-inline">.return</code></a> and <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">.throw</code></a>. We've already covered <code class="md-code md-code-inline">.next</code> extensively, but not quite. You could also use <code class="md-code md-code-inline">.next(value)</code> to send values <em>into the generator</em>.</p><p>Let's make <strong>a magic 8-ball generator</strong>. First off, you'll need some answers. Wikipedia obliges, yielding <a aria-label="Magic 8 Ball Possible Answers on Wikipedia" href="https://en.wikipedia.org/wiki/Magic_8-Ball#Possible_answers">20 possible answers</a> for our magic 8-ball.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var answers = [
  `It is certain`, `It is decidedly so`, `Without a doubt`,
  `Yes definitely`, `You may rely on it`, `As I see it, yes`,
  `Most likely`, `Outlook good`, `Yes`, `Signs point to yes`,
  `Reply hazy try again`, `Ask again later`, `Better not tell you now`,
  `Cannot predict now`, `Concentrate and ask again`,
  `Don't count on it`, `My reply is no`, `My sources say no`,
  `Outlook not so good`, `Very doubtful`
]
function answer () {
  return answers[Math.floor(Math.random() * answers.length)]
}
</code></pre><p>The following generator function can act as a <em>"genie"</em> that answers any questions you might have for them. Note how we discard the first result from <code class="md-code md-code-inline">g.next()</code>. That's because the first call to <code class="md-code md-code-inline">.next</code> enters the generator and there's no <code class="md-code md-code-inline">yield</code> expression waiting to capture the <code class="md-code md-code-inline">value</code> from <code class="md-code md-code-inline">g.next(value)</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">chat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">let</span> question = <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Genie] '</span> + answer()
    <span class="md-code-built_in">console</span>.log(question)
  }
}
<span class="md-code-keyword">var</span> g = chat()
<mark class="md-mark md-code-mark">g.next()</mark>
<span class="md-code-built_in">console</span>.log(g.next(<span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>).value)
<span class="md-code-comment">// &lt;- '[Me] Will ES6 die a painful death?'</span>
<span class="md-code-comment">// &lt;- '[Genie] My sources say no'</span>
<span class="md-code-built_in">console</span>.log(g.next(<span class="md-code-string">'[Me] How youuu doing?'</span>).value)
<span class="md-code-comment">// &lt;- '[Me] How youuu doing?'</span>
<span class="md-code-comment">// &lt;- '[Genie] Concentrate and ask again'</span>
</code></pre><p>Randomly dropping <code class="md-code md-code-inline">g.next()</code> feels like a very dirty coding practice, though. What else could we do? We could flip responsibilities around.</p><h3 id="inversion-of-control">Inversion of Control</h3><p>We could have the Genie be in control, and have the generator ask the questions. How would that look like? At first, you might think that the code below is unconventional, but in fact, most libraries built around generators work by inverting responsibility.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">chat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
}
<span class="md-code-keyword">var</span> g = chat()
<span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
  <span class="md-code-keyword">let</span> question = g.next()
  <span class="md-code-keyword">if</span> (question.done) {
    <span class="md-code-keyword">break</span>
  }
  <span class="md-code-built_in">console</span>.log(question.value)
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + answer())
  <span class="md-code-comment">// &lt;- '[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-comment">// &lt;- '[Genie] Very doubtful'</span>
  <span class="md-code-comment">// &lt;- '[Me] How youuu doing?'</span>
  <span class="md-code-comment">// &lt;- '[Genie] My reply is no'</span>
}
</code></pre><p>You would expect the <strong>generator to do the heavy lifting</strong> of an iteration, but in fact generators make it easy to iterate over things by suspending execution of themselves &ndash; and deferring the heavy lifting. That's one of the most powerful aspects of generators. Suppose now that the iterator is a <code class="md-code md-code-inline">genie</code> method in a library, like so:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">let</span> question = g.next()
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">break</span>
    }
    <span class="md-code-built_in">console</span>.log(question.value)
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + answer())
  }
}
</code></pre><p>To use it, all you'd have to do is pass in a simple generator like the one we just made.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">questions</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
})
</code></pre><p>Compare that to the generator we had before, where questions were sent to the generator instead of the other way around. See how much more complicated the logic would have to be to achieve the same goal? Letting the library deal with the flow control means you can <strong>just worry about the <em>thing</em> you want to iterate</strong> over, and you can <strong>delegate <em>how</em> to iterate over it</strong>. But yes, it does mean your code now has an asterisk in it. <em>Weird.</em></p><h3 id="dealing-with-asynchronous-flows">Dealing with asynchronous flows</h3><p>Imagine now that the <code class="md-code md-code-inline">genie</code> library gets its magic 8-ball answers from an API. How does that look then? Probably something like the snippet below. Assume the <a aria-label="Raynos/xhr on GitHub" href="https://github.com/Raynos/xhr"><code class="md-code md-code-inline">xhr</code></a> pseudocode call always yields JSON responses like <code class="md-code md-code-inline">{ answer: 'No' }</code>. Keep in mind this is a simple example that just processes each question in series. You could put together different and more complex flow control algorithms depending on what you're looking for.</p><p>This is just a demonstration of the sheer power of generators.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  pull()
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">pull</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">let</span> question = <mark class="md-mark md-code-mark">g.next()</mark>
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">return</span>
    }
    ask(question.value, pull)
  }
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ask</span> <span class="md-code-params">(q, next)</span> </span>{
    <mark class="md-mark md-code-mark">xhr(<span class="md-code-string">'https://computer.genie/?q='</span> + <span class="md-code-built_in">encodeURIComponent</span>(q), got)</mark>
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">got</span> <span class="md-code-params">(err, res, body)</span> </span>{
      <span class="md-code-keyword">if</span> (err) {
        <span class="md-code-comment">// todo</span>
      }
      <span class="md-code-built_in">console</span>.log(q)
      <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + body.answer)
      next()
    }
  }
}
</code></pre><p><sub>See <a aria-label="Babel REPL of async generator for genie responses" href="http://buff.ly/1UimWsZ">this link for a live demo</a> on the Babel REPL</sub></p><p>Even though we've just made our <code class="md-code md-code-inline">genie</code> method asynchronous and are now using an API to fetch responses to the user's questions, the way the consumer uses the <code class="md-code md-code-inline">genie</code> library by passing a <code class="md-code md-code-inline">questions</code> generator function <em>remains unchanged!</em> That's awesome.</p><p>We haven't handled the case for an <code class="md-code md-code-inline">err</code> coming out of the API. That's inconvenient. What can we do about that one?</p><h3 id="throwing-at-a-generator">Throwing <em>at</em> a Generator</h3><p>Now that we've figured out that the most important aspect of generators is <em>actually the control flow code</em> that decides when to call <code class="md-code md-code-inline">g.next()</code>, we can look at the other two methods and actually understand their purpose. Before shifting our thinking into <em>"the generator defines <strong>what</strong> to iterate over, not the <strong>how</strong>"</em>, we would've been hard pressed to find a user case for <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">g.throw</code></a>. Now however it seems immediately obvious. The flow control that leverages a generator needs to be able to tell the generator that's yielding the sequence to be iterated when something goes wrong processing an item in the sequence.</p><p>In the case of our <code class="md-code md-code-inline">genie</code> flow, that is now using <a aria-label="Raynos/xhr on GitHub" href="https://github.com/Raynos/xhr"><code class="md-code md-code-inline">xhr</code></a>, we may experience network issues and be unable to continue processing items, or we may want to warn the user about unexpected errors. Here's how, we simply add <code class="md-code md-code-inline">g.throw(error)</code> in our control flow code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  pull()
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">pull</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">let</span> question = g.next()
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">return</span>
    }
    ask(question.value, pull)
  }
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ask</span> <span class="md-code-params">(q, next)</span> </span>{
    xhr(<span class="md-code-string">'https://computer.genie/?q='</span> + <span class="md-code-built_in">encodeURIComponent</span>(q), got)
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">got</span> <span class="md-code-params">(err, res, body)</span> </span>{
      <span class="md-code-keyword">if</span> (err) {
        <mark class="md-mark md-code-mark">g.throw(err)</mark>
      }
      <span class="md-code-built_in">console</span>.log(q)
      <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + body.answer)
      next()
    }
  }
}
</code></pre><p>The <em>user code</em> is still unchanged, though. In between <code class="md-code md-code-inline">yield</code> statements it may throw errors now. You could use <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> blocks to address those issues. If you do this, execution will be able to resume. The good thing is that this is up to the user, it's still perfectly sequential on their end, and they can leverage <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> semantics just like in high-school.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">questions</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  } <span class="md-code-keyword">catch</span> (e) {
    <span class="md-code-built_in">console</span>.error(<span class="md-code-string">'Error'</span>, e.message)
  }
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
  } <span class="md-code-keyword">catch</span> (e) {
    <span class="md-code-built_in">console</span>.error(<span class="md-code-string">'Error'</span>, e.message)
  }
})
</code></pre><h3 id="returning-on-behalf-of-a-generator">Returning on Behalf of a Generator</h3><p>Usually not as interesting in asynchronous control flow mechanisms in general, the <a aria-label="Generator.prototype.return() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return"><code class="md-code md-code-inline">g.return()</code></a> method allows you to resume execution inside a generator function, much like <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">g.throw()</code></a> did moments earlier. The key difference is that <code class="md-code md-code-inline">g.return()</code> won't result in an exception at the generator level, although <strong>it will end the sequence.</strong></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">3</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">g.return()</mark>)
<span class="md-code-comment">// &lt;- { done: true }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }, <mark class="md-mark md-code-mark">as we know</mark></span>
</code></pre><p>You could also return a <code class="md-code md-code-inline">value</code> using <code class="md-code md-code-inline">g.return(value)</code>, and the resulting <code class="md-code md-code-inline">IteratorResult</code> will contain said <code class="md-code md-code-inline">value</code>. This is equivalent to having <code class="md-code md-code-inline">return value</code> somewhere in the generator function. You should be careful there though &ndash; as neither <code class="md-code md-code-inline">for..of</code>, <code class="md-code md-code-inline">[...generator()]</code>, nor <code class="md-code md-code-inline">Array.from(generator())</code> include the <code class="md-code md-code-inline">value</code> in the <code class="md-code md-code-inline">IteratorResult</code> that signals <code class="md-code md-code-inline">{ done: true }</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <mark class="md-mark md-code-mark">return <span class="md-code-number">3</span></mark>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
}
<span class="md-code-built_in">console</span>.log([...numbers()])
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[1, 2]</mark></span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Array</span>.from(numbers()))
<span class="md-code-comment">// &lt;- [1, 2]</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> n of numbers()) {
  <span class="md-code-built_in">console</span>.log(n)
  <span class="md-code-comment">// &lt;- 1</span>
  <span class="md-code-comment">// &lt;- 2</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 2 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 3</mark> }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><p>Using <code class="md-code md-code-inline">g.return</code> is no different in this regard, think of it as the programmatic equivalent of what we just did.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <span class="md-code-keyword">return</span> <span class="md-code-number">3</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.return(<span class="md-code-number">5</span>))
<span class="md-code-comment">// &lt;- { done: true, value: 5 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><p>You can avoid the impending sequence termination, <a aria-label="ES6 generators in depth by Dr. Axel Rauschmayer" href="http://www.2ality.com/2015/03/es6-generators.html">as Axel points out</a>, if the code in the generator function when <code class="md-code md-code-inline">g.return()</code> got called is wrapped in <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">finally</code>. Once the <code class="md-code md-code-inline">yield</code> expressions in the <code class="md-code md-code-inline">finally</code> block are over, the sequence <em>will</em> end with the <code class="md-code md-code-inline">value</code> passed to <code class="md-code md-code-inline">g.return(value)</code></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  } <span class="md-code-keyword">finally</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-number">3</span>
    <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
  }
  <span class="md-code-keyword">yield</span> <span class="md-code-number">5</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 2 }</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">g.return(<span class="md-code-number">6</span>)</mark>)
<span class="md-code-comment">// &lt;- { done: false, value: 3 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 4 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 6</mark> }</span>
</code></pre><p>That's all there is to know when it comes to generators <em>in terms of functionality.</em></p><h2 id="use-cases-for-es6-generators">Use Cases for ES6 Generators</h2><p>At this point in the article you should feel comfortable with the concepts of iterators, iterables, and generators in ES6. If you feel like reading more on the subject, I highly recommend you go over <a aria-label="ES6 generators in depth by Dr. Axel Rauschmayer" href="http://www.2ality.com/2015/03/es6-generators.html">Axel's article on generators</a>, as he put together an amazing write-up on use cases for generators just <em>a few months ago</em>.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Arrow Functions in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>The daily saga of <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">es6-in-depth</a> articles continues. Today we'll be discussing Arrow Functions. In previous articles we've covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a> and <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>. I strive to cover <em>all the things</em> when it comes to the ES6 feature-set &ndash; and eventually we'll move onto ES7. I find that writing about these features makes it way easier for them to become <strong>engraved in my skull</strong> as well.</p><p>Since you're reading these articles, I suggest you <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel and <code class="md-code md-code-inline">babel-node</code></a>, and follow along by copying the self-contained examples into a file. You can then run them using <code class="md-code md-code-inline">babel-node yourfile</code> in the terminal. Running these examples on your own and maybe tweaking them a little bit <strong>will help you better internalize these new features</strong> &ndash; even if you're just adding <code class="md-code md-code-inline">console.log</code> statements to figure out what's going on.</p><blockquote><p>Now onto the topic of the day.</p></blockquote><p>We've already kind of went over <em>arrow functions</em> in previous articles, using them in passing without a lot of explaining going on. This article will focus mainly in arrow functions and keep the rest of ES6 in the back burner. I think that's the best way to write about ES6 &ndash; making a single feature "stand out" in each article, and gradually adding the others and interconnecting the different concepts so that we can understand <em>how they interact together</em>. I've observed <strong>a lot of synergy</strong> in ES6 features, which is <em>awesome</em>. It's still important to make a gradual dive into ES6 syntax and features and not jump into the water as it's warming up, because otherwise you'll have a bad time adjusting to the new temperature &ndash; that was probably a bad analogy, moving on.</p></section>
		<section class="md-markdown at-body"><h2 id="using-arrow-functions-in-javascript">Using Arrow Functions in JavaScript</h2><p>Arrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they're now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it's nice to have a terse alternative.</p><p>Here's how the syntax looks like if we have a single argument and just want to return the results for an expression.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(num =&gt; num * <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>The ES5 equivalent would be as below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(num)</span> </span>{ <span class="md-code-keyword">return</span> num * <span class="md-code-number">2</span> })
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>If we need to declare more arguments <em>(or no arguments)</em>, we'll have to use parenthesis.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; num * <span class="md-code-number">2</span> + index)
<span class="md-code-comment">// &lt;- [2, 5, 8, 11]</span>
</code></pre><p>You might want to have some other statements and not just an expression to return. In this case you'll have to use bracket notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map(num =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + num
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [3, 8, 15, 24]</span>
</code></pre><p>You could also add more arguments with the parenthesis syntax here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + index
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [2, 6, 12, 20]</span>
</code></pre><p>At that point, however, chances are you'd be better off using a named function declaration for a number of reasons.</p><ul><li><code class="md-code md-code-inline">(num, index) =&gt;</code> is only marginally shorter than <code class="md-code md-code-inline">function (num, index)</code></li><li>The <code class="md-code md-code-inline">function</code> form allows you to name the method, improving code quality</li><li>When a function has multiple arguments and multiple statements, I'd say it's improbable that six extra characters will make a difference</li><li>However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile</li></ul><p>Moving on, if we need to return an object literal, we'll have to wrap the expression in parenthesis. That way the object literal won't be interpreted as a statement block (which would result in a silent error or worse, a <strong>syntax error</strong> because <code class="md-code md-code-inline">number: n</code> isn't a valid expression in the example below. The first example interprets <code class="md-code md-code-inline">number</code> as a label and then figures out we have an <code class="md-code md-code-inline">n</code> expression. Since we're in a block and not returning anything, the mapped values will be <code class="md-code md-code-inline">undefined</code>. In the second case, after the label and the <code class="md-code md-code-inline">n</code> expression, <code class="md-code md-code-inline">, something: 'else'</code> makes no sense to the compiler, and a <code class="md-code md-code-inline">SyntaxError</code> is thrown.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n })
<span class="md-code-comment">// [undefined, undefined, undefined]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n, something: <span class="md-code-string">'else'</span> })
<span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n }))
<span class="md-code-comment">// &lt;- [{ number: 1 }, { number: 2 }, { number: 3 }]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n, something: <span class="md-code-string">'else'</span> }))
<span class="md-code-comment">/* &lt;- [
  { number: 1, something: 'else' },
  { number: 2, something: 'else' },
  { number: 3, something: 'else' }]
*/</span>
</code></pre><p>A cool aspect of arrow functions in ES6 is that they're bound to their lexical scope. That means that you can say goodbye to <code class="md-code md-code-inline">var self = this</code> and similar hacks <em>&ndash; such as using <code class="md-code md-code-inline">.bind(this)</code> &ndash;</em> to preserve the context from within deeply nested methods.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Timer</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.seconds = <span class="md-code-number">0</span>
  setInterval(() =&gt; <span class="md-code-keyword">this</span>.seconds++, <span class="md-code-number">1000</span>)
}
<span class="md-code-keyword">var</span> timer = <span class="md-code-keyword">new</span> Timer()
setTimeout(() =&gt; <span class="md-code-built_in">console</span>.log(timer.seconds), <span class="md-code-number">3100</span>)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>Keep in mind that the lexical <code class="md-code md-code-inline">this</code> binding in ES6 arrow functions means that <code class="md-code md-code-inline">.call</code> and <code class="md-code md-code-inline">.apply</code> won't be able to change the context. Usually however, that's more of a feature than a bug.</p><h2 id="conclusions">Conclusions</h2><p>Arrow functions are neat when it comes to defining anonymous functions that should probably be <em>lexically bound anyways</em>, and they can definitely make your code more terse in some situations.</p><p>There's no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I'm a big proponent of named function declarations, because they improve readability of the codebase without the need for comments &ndash; which means I'll have <em>"a hard time"</em> adopting arrow functions in most situations.</p><p>That being said, I think arrow functions are particularly useful in most functional programming situations such as when using <code class="md-code md-code-inline">.map</code>, <code class="md-code md-code-inline">.filter</code>, or <code class="md-code md-code-inline">.reduce</code> on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Maps in Depth</h1>
<section class="md-markdown at-teaser" itemprop="about"><p>Hello, this is <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 &ndash; <em>"Please make them stop"</em> &ndash; in Depth</a>. New here? Start with <a aria-label="A Brief History of ES6 Tooling on Pony Foo" href="/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a>, and <a aria-label="ES6 Symbols in Depth on Pony Foo" href="/articles/es6-symbols-in-depth">Symbols</a>. Today we'll be discussing a new collection data structure objects coming in ES6 &ndash; I'm talking about <code class="md-code md-code-inline">Map</code>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for reading that, and let's go into collections now! For a bit of context, you may want to check out the article on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a> <em>&ndash; which are closely related to ES6 collections &ndash;</em> and the one on <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread and rest parameters</a>.</p><p>Now, let's start with <code class="md-code md-code-inline">Map</code>. I moved the rest of the ES6 collections to tomorrow's publication in order to keep the series sane, as otherwise this would've been too long for a single article!</p></section>
<section class="md-markdown at-body"><h1 id="before-es6-there-were-hash-maps">Before ES6, There Were Hash-Maps</h1><p>A very common <em>ab</em>use case of JavaScript objects is hash-maps, where we map string keys to arbitrary values. For example, one might use an object to map <code class="md-code md-code-inline">npm</code> package names to their metadata, like so:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> registry = {}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span> <span class="md-code-params">(name, meta)</span> </span>{
  registry[name] = meta
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">get</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">return</span> registry[name]
}
add(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
add(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
add(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>There's several issues with this approach, to wit:</p><ul><li><strong>Security issues</strong> where user-provided keys like <code class="md-code md-code-inline">__proto__</code>, <code class="md-code md-code-inline">toString</code>, or anything in <code class="md-code md-code-inline">Object.prototype</code> break expectations and make interaction with these kinds of <em>hash-map</em> data structures more cumbersome</li><li>Iteration over list items is verbose with <code class="md-code md-code-inline">Object.keys(registry).forEach</code> or implementing the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> on the <code class="md-code md-code-inline">registry</code></li><li>Keys are limited to strings, making it hard to create hash-maps where you'd like to index values by DOM elements or other non-string references</li></ul><p>The first problem could be fixed using a prefix, and being careful to always get or set values in the hash-map through methods. It would be even better to use <a aria-label="Proxy Objects in ES6 on MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy">ES6 proxies</a>, but we <em>won't be covering those until tomorrow!</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> registry = {}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span> <span class="md-code-params">(name, meta)</span> </span>{
  registry[<mark class="md-mark md-code-mark"><span class="md-code-string">'map:'</span> + </mark>name] = meta
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">get</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">return</span> registry[<mark class="md-mark md-code-mark"><span class="md-code-string">'map:'</span> + </mark>name]
}
add(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
add(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
add(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>Luckily for us, though, <em>ES6 maps</em> provide us with an even better solution to the key-naming security issue. At the same time they facilitate collection behaviors out the box that may also come in handy. Let's plunge into their practical usage and inner workings.</p><h1 id="es6-maps">ES6 Maps</h1><p>Map is a key/value data structure in ES6. It provides a better data structure to be used for hash-maps. Here's how what we had earlier looks like with ES6 maps.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <mark class="md-mark md-code-mark">new Map()</mark>
<mark class="md-mark md-code-mark">map.set</mark>(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
map.set(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
map.set(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>One of the important differences is also that you're able to use anything for the keys. You're not just limited to primitive values like symbols, numbers, or strings, but you can even use functions, objects and dates &ndash; too. Keys won't be casted to strings like with regular objects, either.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{})
map.set(() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> })
map.set(Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>])
</code></pre><p>You can also provide <code class="md-code md-code-inline">Map</code> objects with any object that follows the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> and produces a collection such as <code class="md-code md-code-inline">[['key', 'value'], ['key', 'value']]</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([
  [<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{}],
  [() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> }],
  [Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]]
])
</code></pre><p>The above would be effectively the same as the following. Note how we're using destructuring in the parameters of <code class="md-code md-code-inline">items.forEach</code> to <em>effortlessly</em> pull the <code class="md-code md-code-inline">key</code> and <code class="md-code md-code-inline">value</code> out of the two-dimensional <code class="md-code md-code-inline">item</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> items = [
  [<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{}],
  [() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> }],
  [Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]]
]
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
items.forEach((<mark class="md-mark md-code-mark">[key, value]</mark>) =&gt; map.set(key, value))
</code></pre><p>Of course, it's kind of silly to go through the trouble of adding items one by one when you can just feed an iterable to your <code class="md-code md-code-inline">Map</code>. Speaking of iterables &ndash; <code class="md-code md-code-inline">Map</code> adheres to the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em></a> protocol. It's very easy to pull a key-value pair collection much like the ones you can feed to the <code class="md-code md-code-inline">Map</code> constructor.</p><p>Naturally, we can use the spread operator to this effect.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>)
map.set(<span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'o'</span>, <span class="md-code-string">'!'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [['p', 'o'], ['n', 'y'], ['f', 'o'], ['o', '!']]</span>
</code></pre><p>You could also use a <code class="md-code md-code-inline">for..of</code> loop, and we could combine that with <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a> to make it seriously terse. Also, remember <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>?</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>)
map.set(<span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'o'</span>, <span class="md-code-string">'!'</span>)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> <mark class="md-mark md-code-mark">[key, value]</mark> of map) {
  <span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">`${key}: ${value}`</mark>)
  <span class="md-code-comment">// &lt;- 'p: o'</span>
  <span class="md-code-comment">// &lt;- 'n: y'</span>
  <span class="md-code-comment">// &lt;- 'f: o'</span>
  <span class="md-code-comment">// &lt;- 'o: !'</span>
}
</code></pre><p>Even though maps have a programmatic API to add items, keys are unique, just like with hash-maps. Setting a key over and over again will only overwrite its value.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'a'</span>)
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'b'</span>)
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'c'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [['a', 'c']]</span>
</code></pre><p>In ES6 <code class="md-code md-code-inline">Map</code>, <code class="md-code md-code-inline">NaN</code> becomes a "corner-case" that gets <strong>treated as a value that's equal to itself</strong> even though the following expression actually evaluates to <code class="md-code md-code-inline">true</code> &ndash; <code class="md-code md-code-inline">NaN !== NaN</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-literal">NaN</span> === <span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-literal">NaN</span>, <span class="md-code-string">'foo'</span>)
map.set(<span class="md-code-literal">NaN</span>, <span class="md-code-string">'bar'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [[NaN, 'bar']]</span>
</code></pre><h2 id="hash-maps-and-the-dom">Hash-Maps and the DOM</h2><p>In ES5, whenever we had a DOM element we wanted to associate with an API object for some library, we had to follow a verbose and slow pattern like the one below. The following piece of code just returns an API object with a bunch of methods for a given DOM element, allowing us to put and remove DOM elements from the cache, and also allowing us to retrieve the API object for a DOM element &ndash; if one already exists.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = []
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">put</span> <span class="md-code-params">(el, api)</span> </span>{
  cache.push({ el: el, api: api })
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">find</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">for</span> (i = <span class="md-code-number">0</span>; i &lt; cache.length; i++) {
    <span class="md-code-keyword">if</span> (cache[i].el === el) {
      <span class="md-code-keyword">return</span> cache[i].api
    }
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">destroy</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">for</span> (i = <span class="md-code-number">0</span>; i &lt; cache.length; i++) {
    <span class="md-code-keyword">if</span> (cache[i].el === el) {
      cache.splice(i, <span class="md-code-number">1</span>)
      <span class="md-code-keyword">return</span>
    }
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = find(el)
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.bind(<span class="md-code-literal">null</span>, el)
  }
  put(el, api)
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>One of the coolest aspects of <code class="md-code md-code-inline">Map</code>, <em>as I've previously mentioned</em>, is the ability to index by DOM elements. The fact that <code class="md-code md-code-inline">Map</code> also has collection manipulation abilities also greatly simplifies things.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = <span class="md-code-keyword">new</span> Map()
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">put</span> <span class="md-code-params">(el, api)</span> </span>{
  <mark class="md-mark md-code-mark">cache.set(el, api)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">find</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">cache.get(el)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">destroy</span> <span class="md-code-params">(el)</span> </span>{
  <mark class="md-mark md-code-mark">cache.delete(el)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = find(el)
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.bind(<span class="md-code-literal">null</span>, el)
  }
  put(el, api)
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>The fact that these methods have now become one liners means we can just inline them, as readability is no longer an issue. We just went from <em>~30 LOC</em> to <strong>half that amount</strong>. Needless to say, at some point in the future this will also perform <em>much</em> faster than the haystack alternative.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = <span class="md-code-keyword">new</span> Map()
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = <mark class="md-mark md-code-mark">cache.get(el)</mark>
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: () =&gt; <mark class="md-mark md-code-mark">cache.delete(el)</mark>
  }
  <mark class="md-mark md-code-mark">cache.set(el, api)</mark>
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>The simplicity of <code class="md-code md-code-inline">Map</code> is amazing. If you ask me, we desperately needed this feature in JavaScript. Being to index a collection by arbitrary objects is <strong>super important</strong>.</p><blockquote><p>What else can we do with <code class="md-code md-code-inline">Map</code>?</p></blockquote><h2 id="collection-methods-in-map">Collection Methods in <code class="md-code md-code-inline">Map</code></h2><p>Maps make it very easy to probe the collection and figure out whether a <code class="md-code md-code-inline">key</code> is defined in the <code class="md-code md-code-inline">Map</code>. As we noted earlier, <code class="md-code md-code-inline">NaN</code> equals <code class="md-code md-code-inline">NaN</code> as far as <code class="md-code md-code-inline">Map</code> is concerned. However, <code class="md-code md-code-inline">Symbol</code> values are always different, so you'll have to use them by value!</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [Symbol(), <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-literal">NaN</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(Symbol()))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'bar'</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre><p>As long as you keep a <code class="md-code md-code-inline">Symbol</code> reference around, you'll be okay. <em>Keep your references close, and your <code class="md-code md-code-inline">Symbol</code>s closer?</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">var sym = Symbol()</mark>
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [sym, <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(sym))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre><p>Also, remember the <strong>no key-casting</strong> thing? <em>Beware!</em> We are so used to objects casting keys to strings that this may bite you if you're not careful.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-string">'a'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-number">1</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'1'</span>))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre><p>You can also clear a <code class="md-code md-code-inline">Map</code> entirely of entries without losing a reference to it. This can be very handy sometimes.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
map.clear()
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-number">1</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- []</span>
</code></pre><p>When you use <code class="md-code md-code-inline">Map</code> as an iterable, you are actually looping over its <code class="md-code md-code-inline">.entries()</code>. That means that you don't need to <strong>explicitly</strong> iterate over <code class="md-code md-code-inline">.entries()</code>. It'll be done on your behalf anyways. You do remember <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a>, right?</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(map[<mark class="md-mark md-code-mark">Symbol.iterator</mark>] === map.entries)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Just like <code class="md-code md-code-inline">.entries()</code>, <code class="md-code md-code-inline">Map</code> has two other iterators you can leverage. These are <code class="md-code md-code-inline">.keys()</code> and <code class="md-code md-code-inline">.values()</code>. I'm sure you guessed what sequences of values they yield, but here's a code snippet anyways.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
<span class="md-code-built_in">console</span>.log([...map.keys()])
<span class="md-code-comment">// &lt;- [1, 3, 5]</span>
<span class="md-code-built_in">console</span>.log([...map.values()])
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>Maps also come with a <em>read-only</em> <code class="md-code md-code-inline">.size</code> property that behaves sort of like <code class="md-code md-code-inline">Array.prototype.length</code> &ndash; at any point in time it gives you the current amount of entries in the map.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 3</span>
map.delete(<span class="md-code-number">3</span>)
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 2</span>
map.clear()
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 0</span>
</code></pre><p>One more aspect of <code class="md-code md-code-inline">Map</code> that's worth mentioning is that their entries are always iterated in <strong>insertion order</strong>. This is in contrast with <code class="md-code md-code-inline">Object.keys</code> loops which follow <a aria-label="for..in on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">an arbitrary order</a>.</p><blockquote><p>The <a aria-label="for..in on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code class="md-code md-code-inline">for..in</code></a> statement iterates over the enumerable properties of an object, in arbitrary order.</p></blockquote><p>Maps also have a <code class="md-code md-code-inline">.forEach</code> method that's identical in <em>behavior</em> to that in ES5 <code class="md-code md-code-inline">Array</code> objects. Once again, keys do not get casted into strings here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [Symbol(), <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
map.forEach(<mark class="md-mark md-code-mark">(value, key)</mark> =&gt; <span class="md-code-built_in">console</span>.log(key, value))
<span class="md-code-comment">// &lt;- NaN 1</span>
<span class="md-code-comment">// &lt;- Symbol() 2</span>
<span class="md-code-comment">// &lt;- 'foo' 'bar'</span>
</code></pre><blockquote><p>Get up early tomorrow morning, we'll be having <a aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth on Pony Foo" href="http://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth"><code class="md-code md-code-inline">WeakMap</code>, <code class="md-code md-code-inline">Set</code>, and <code class="md-code md-code-inline">WeakSet</code></a> for breakfast :)</p></blockquote></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Template Literals in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>Yesterday we've covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">ES6 destructuring in depth</a>, as well as some of its most common use cases. Today we'll be moving to <strong>template literals</strong>. What they are, and how we can use them and what good they're for.</p><p>Template literals are a new feature in ES6 to make working with strings and string templates easier. You wrap your text in <code class="md-code md-code-inline">`backticks`</code> and you'll get the features described below.</p><ul><li>You can interpolate variables in them</li><li>You can actually interpolate using <em>any kind of expression</em>, not just variables</li><li>They can be <strong>multi-line</strong>. <em>Finally!</em></li><li>You can construct <em>raw templates</em> that don't interpret backslashes</li></ul><p>In addition, you can also define <em>a method</em> that will decide what to make of the template, instead of using the default templating behavior. There are some interesting use cases for this one.</p><blockquote><p>Let's dig into template literals and see what we can come up with.</p></blockquote></section>
		<section class="md-markdown at-body"><h2 id="using-template-literals">Using Template Literals</h2><p>We've already covered the basic <em><code class="md-code md-code-inline">`I'm just a string`</code></em>. One aspect of template literals that may be worth mentioning is that you're now able to declare strings with both <code class="md-code md-code-inline">'</code> and <code class="md-code md-code-inline">"</code> quotation marks in them without having to escape anything.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var text = `I'm "amazed" that we have so many quotation marks to choose from!`
</code></pre><p>That was neat, but surely there's more useful stuff we can apply template literals to. How about some <em>actual interpolation</em>? You can use the <code class="md-code md-code-inline">${expression}</code> notation for that.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> host = <span class="md-code-string">'ponyfoo.com'</span>
<span class="md-code-keyword">var</span> text = `<span class="md-code-keyword">this</span> blog lives at <mark class="md-mark md-code-mark">${host}</mark>`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre><p>I've already mentioned you can have any kind of expressions you want in <mark class="md-mark">there</mark>. Think of whatever expressions you put in there as defining a variable before the template runs, and then concatenating that value with the rest of the string. That means that variables you use, methods you call, and so on, should all be available to the current scope.</p><p>The following expressions would all work just as well. It'll be up to us to decide how much logic we cram into the interpolation expressions.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = `<span class="md-code-keyword">this</span> blog lives at ${<span class="md-code-string">'ponyfoo.com'</span>}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> today = <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
<span class="md-code-keyword">var</span> text = `the time and date is ${today.toLocaleString()}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'the time and date is 8/26/2015, 3:15:20 PM'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript">import moment from <span class="md-code-string">'moment'</span>
<span class="md-code-keyword">var</span> today = <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
<span class="md-code-keyword">var</span> text = `today is the ${moment(today).format(<span class="md-code-string">'Do [of] MMMM'</span>)}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'today is the 26th of August'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = `such ${<span class="md-code-literal">Infinity</span>/<span class="md-code-number">0</span>}, very uncertain`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'such Infinity, very uncertain'</span>
</code></pre><p>Multi-line strings mean that you no longer have to use methods like these anymore.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = (
  <span class="md-code-string">'foo\n'</span> +
  <span class="md-code-string">'bar\n'</span> +
  <span class="md-code-string">'baz'</span>
)
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = [
  <span class="md-code-string">'foo'</span>,
  <span class="md-code-string">'bar'</span>,
  <span class="md-code-string">'baz'</span>
].join(<span class="md-code-string">'\n'</span>)
</code></pre><p>Instead, you can now just use backticks! Note that spacing matters, so you might still want to use parenthesis in order to keep the first line of text away from the variable declaration.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = (
`foo
bar
baz`)
</code></pre><p>Multi-line strings really shine when you have, <em>for instance</em>, a chunk of HTML you want to interpolate some variables to. Much like with <a aria-label="React, JSX and ES6: The Weird Parts on Pony Foo" href="/articles/react-jsx-and-es6-the-weird-parts">JSX</a>, you're perfectly able to use an expression to iterate over a collection and <code class="md-code md-code-inline">return</code> yet another template literal to declare list items. This makes it a breeze to declare sub-components in your templates. Note also how I'm <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">using destructuring</a> to avoid having to prefix every expression of mine with <code class="md-code md-code-inline">article.</code>, I like to think of it as <em>"a <code class="md-code md-code-inline">with</code> block, but not as insane"</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> article = {
  title: <span class="md-code-string">'Hello Template Literals'</span>,
  teaser: <span class="md-code-string">'String interpolation is awesome. Here are some features'</span>,
  body: <span class="md-code-string">'Lots and lots of sanitized HTML'</span>,
  tags: [<span class="md-code-string">'es6'</span>, <span class="md-code-string">'template-literals'</span>, <span class="md-code-string">'es6-in-depth'</span>]
}
<span class="md-code-keyword">var</span> {title,teaser,body,tags} = article
<span class="md-code-keyword">var</span> html = `&lt;article&gt;
  <span><span class="md-code-tag">&lt;<span class="md-code-title">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>${title}<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>${teaser}<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>${body}<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">ul</span>&gt;</span>
      <mark class="md-mark md-code-mark">${tags.map(tag =&gt; `<span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>${tag}<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>`).join('\n      ')}</mark>
    <span class="md-code-tag">&lt;/<span class="md-code-title">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">article</span>&gt;</span>`
</span></code></pre><p>The above will produce output as shown below. Note how the spacing trick was enough to properly indent the <code class="md-code md-code-inline">&lt;li&gt;</code> tags.</p><pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">article</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>Hello Template Literals<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>String interpolation is awesome. Here are some features<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>Lots and lots of sanitized HTML<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">ul</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>es6<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>template-literals<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>es6-in-depth<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">article</span>&gt;</span>
</code></pre><p>Raw templates are the same in essence, you just have to prepend your template literal with <code class="md-code md-code-inline">String.raw</code>. This can be very convenient in some use cases.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var text = String.raw`The "\n" newline won't result in a new line.
It'll be escaped.`
console.log(text)
// The "\n" newline won't result in a new line.
// It'll be escaped.
</code></pre><p>You might've noticed that <code class="md-code md-code-inline">String.raw</code> seems to be a special part of the template literal syntax, and you'd be right! The method you choose will be used to parse the template. Template literal methods &ndash; called <em>"tagged templates"</em> &ndash; receive an array containing a list of the static parts of the template, as well as each expression on their own variables.</p><p>For instance a template literal like <code class="md-code md-code-inline">`hello ${name}. I am ${emotion}!`</code> will pass arguments to the <em>"tagged template"</em> in a function call like the one below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">fn([<span class="md-code-string">'hello '</span>, <span class="md-code-string">'. I am'</span>, <span class="md-code-string">'!'</span>], <span class="md-code-string">'nico'</span>, <span class="md-code-string">'confused'</span>)
</code></pre><p>You might be confused by the seeming oddity in which the arguments are laid out, but they start to make sense when you think of it this way: for every item in the template array, there's an expression result after it.</p><h2 id="demystifying-tagged-templates">Demystifying Tagged Templates</h2><p>I wrote an example <code class="md-code md-code-inline">normal</code> method below, and it works <em>exactly like the default behavior</em>. This might help you better understand what happens under the hood for template literals.</p><blockquote><p>If you don't know what <code class="md-code md-code-inline">.reduce</code> does, refer to <a aria-label="Array.prototype.reduce() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN</a> or my <a aria-label="Computing with .reduce, .reduceRight on Pony Foo" href="/articles/fun-with-native-arrays#computing-with-reduce-reduceright">"Fun with Native Arrays"</a> article. Reduce is always useful when you're trying to map a collection of values into a single value that can be computed from the collection.</p></blockquote><p>In this case we can reduce the <code class="md-code md-code-inline">template</code> starting from <code class="md-code md-code-inline">template[0]</code> and then reducing all other parts by adding the preceding <code class="md-code md-code-inline">expression</code> and the subsequent <code class="md-code md-code-inline">part</code>. Note that I would've used <code class="md-code md-code-inline">template.shift()</code> for the initial value of the reducer <em>(thus avoiding the <code class="md-code md-code-inline">.slice(1)</code> call)</em>, but Babel seals the <code class="md-code md-code-inline">template</code> so we can't mutate it.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">normal</span> <span class="md-code-params">(template, <mark class="md-mark md-code-mark">...expressions</mark>)</span> </span>{
  <span class="md-code-keyword">return</span> template.slice(<span class="md-code-number">1</span>).reduce((accumulator, part, i) =&gt; {
    <span class="md-code-keyword">return</span> accumulator + expressions[i] + part
  }, template[<span class="md-code-number">0</span>])
}
</code></pre><p>The <code class="md-code md-code-inline">...expressions</code> syntax is new in ES6 as well. It's called the <a aria-label="Rest parameters in ES6 &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters"><em>"rest parameters syntax"</em></a>, and it'll basically place all the arguments passed to <code class="md-code md-code-inline">normal</code> that come after <code class="md-code md-code-inline">template</code> into a single array. You can try the tagged template as seen below, and you'll notice you get the same output as if you omitted <code class="md-code md-code-inline">normal</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> name = <span class="md-code-string">'nico'</span>
<span class="md-code-keyword">var</span> outfit = <span class="md-code-string">'leather jacket'</span>
<span class="md-code-keyword">var</span> text = <mark class="md-mark md-code-mark">normal</mark>`hello ${name}, you look lovely today <span class="md-code-keyword">in</span> that ${outfit}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'hello nico, you look lovely today in that leather jacket'</span>
</code></pre><p>Now that we've figured out how tagged templates work, what can we do with them? Well, whatever we want. One possible use case might be to make user input uppercase, turning our greeting into something that sounds more satirical &ndash; <em>I read the result out loud in my head with Gob's voice from Arrested Development, now I'm laughing alone. I've made a huge mistake</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">upperExpr</span> <span class="md-code-params">(template, ...expressions)</span> </span>{
  <span class="md-code-keyword">return</span> template.slice(<span class="md-code-number">1</span>).reduce((accumulator, part, i) =&gt; {
    <span class="md-code-keyword">return</span> accumulator + expressions[i].toUpperCase() + part
  }, template[<span class="md-code-number">0</span>])
}
<span class="md-code-keyword">var</span> name = <span class="md-code-string">'nico'</span>
<span class="md-code-keyword">var</span> outfit = <span class="md-code-string">'leather jacket'</span>
<span class="md-code-keyword">var</span> text = <mark class="md-mark md-code-mark">upperExpr</mark>`hello ${name}, you look lovely today <span class="md-code-keyword">in</span> that ${outfit}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'hello NICO, you look lovely today in that LEATHER JACKET'</span>
</code></pre><p>There's obviously much more useful use cases for tagged templates than laughing at yourself. In fact, you could go crazy with tagged templates. A decidedly useful use case would be to sanitize user input in your templates automatically. Given a template where all expressions are considered user-input, we could use <a aria-label="bevacqua/insane on GitHub" href="https://github.com/bevacqua/insane"><code class="md-code md-code-inline">insane</code></a> to sanitize them out of HTML tags we dislike.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">import insane from 'insane'
function sanitize (template, ...expressions) {
  return template.slice(1).reduce((accumulator, part, i) =&gt; {
    return accumulator + <mark class="md-mark md-code-mark">insane</mark>(expressions[i]) + part
  }, template[0])
}
var comment = 'haha xss is so easy <mark class="md-mark md-code-mark">&lt;iframe src="http://evil.corp"&gt;&lt;/iframe&gt;</mark>'
var html = <mark class="md-mark md-code-mark">sanitize</mark>`&lt;div&gt;${comment}&lt;/div&gt;`
console.log(html)
// &lt;- '&lt;div&gt;haha xss is so easy &lt;/div&gt;'
</code></pre><p><em>Not so easy now!</em></p><blockquote><p>I can definitely see a future where the only strings I use in JavaScript begin and finish with a backtick.</p></blockquote></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Object Literal Features in Depth</h1>
<section class="at-corpus" itemprop="articleBody"><section class="md-markdown at-teaser" itemprop="about"><p>Once again, this is <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a>. If you haven't set foot on this series before, you might want to learn about <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, or the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>. Today's special is <em>object literals in ES6.</em> <strong>"Sure, I can use those today"</strong>, you say &ndash; object literals date all the way back to ES3. This article is about new features coming in ES6 for object literals.</p><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to internalize the concepts discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p><p>Onto the new stuff!</p></section><section class="md-markdown at-body"><h2 id="property-value-shorthands">Property Value Shorthands</h2><p>Whenever you find yourself assigning a property value that matches a property name, you can omit the property value, it's implicit in ES6.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">'bar'</span>
<span class="md-code-keyword">var</span> baz = { foo }
<span class="md-code-built_in">console</span>.log(baz.foo)
<span class="md-code-comment">// &lt;- 'bar'</span>
</code></pre><p>In the snippet shown below I re-implemented part of <code class="md-code md-code-inline">localStorage</code> in memory as a polyfill. It displays a pattern that I've followed countless times <a aria-label="See bevacqua/local-storage on GitHub" href="https://github.com/bevacqua/local-storage/blob/b9725b0fc77faabc737ba7c6ee57d343afa95102/stub.js#L3-L32">in my code</a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> ms = {}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getItem</span> <span class="md-code-params">(key)</span> </span>{
  <span class="md-code-keyword">return</span> key <span class="md-code-keyword">in</span> ms ? ms[key] : <span class="md-code-literal">null</span>
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">setItem</span> <span class="md-code-params">(key, value)</span> </span>{
  ms[key] = value
}

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">clear</span> <span class="md-code-params">()</span> </span>{
  ms = {}
}

<mark class="md-mark md-code-mark">module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
}</mark>
</code></pre><p>The reasons why <em>&ndash; most often &ndash;</em> I don't place functions directly on an object definition are <em>several.</em></p><ul><li>Less indentation needed</li><li>Public API stands out</li><li>Harder to tightly couple methods</li><li>Easier to reason about</li></ul><p>With ES6, we can throw another bullet into that list, and that's that the export can be even easier using <em>property value shorthands</em>. You can omit the property value if it matches the property name. The <code class="md-code md-code-inline">module.exports</code> from the code above thus becomes:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.exports = { getItem, setItem, clear }
</code></pre><p>So good!</p><h2 id="computed-property-names">Computed Property Names</h2><p>We already covered computed property names briefly in the <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring article</a>. This was a very common thing to do for me:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">'bar'</span>
<span class="md-code-keyword">var</span> baz = {}
baz[foo] = <span class="md-code-string">'ponyfoo'</span>
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- { bar: 'ponyfoo' }</span>
</code></pre><p>Computed property names allow you to write an <em>expression</em> wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">'bar'</span>
<span class="md-code-keyword">var</span> baz = { [foo]: <span class="md-code-string">'ponyfoo'</span> }
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- { bar: 'ponyfoo' }</span>
</code></pre><p>One limitation of computed property names is that you won't be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = <span class="md-code-string">'bar'</span>
<span class="md-code-keyword">var</span> bar = <span class="md-code-string">'ponyfoo'</span>
<span class="md-code-keyword">var</span> baz = { [foo] }
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre><p>That being said, I believe this to be the most common use case. Here our code is simpler because we don't have to spend three steps in allocating a <code class="md-code md-code-inline">foo</code> variable, assigning to <code class="md-code md-code-inline">foo[type]</code>, and returning <code class="md-code md-code-inline">foo</code>. Instead we can do all three in a single statement.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getModel</span> <span class="md-code-params">(type)</span> </span>{
  <span class="md-code-keyword">return</span> {
    [type]: {
      message: <span class="md-code-string">'hello, this is doge'</span>,
      date: <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
    }
  }
}
</code></pre><p>Neat. What else?</p><h2 id="method-definitions">Method Definitions</h2><p>Typically in ES5 you declare methods on an object like so:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  bar: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(baz)</span> </span>{
  }
}
</code></pre><p>While getters and setters have a syntax like this, where there's no need for the <code class="md-code md-code-inline">function</code> keyword. It's just inferred from context.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cart = {
  _wheels: <span class="md-code-number">4</span>,
  get wheels () {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">this</span>._wheels
  },
  set wheels (value) {
    <span class="md-code-keyword">if</span> (value &lt; <span class="md-code-keyword">this</span>._wheels) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">'hey, come back here!'</span>)  
    }
    <span class="md-code-keyword">this</span>._wheels = value
  }
}
</code></pre><p>Starting in ES6, you can declare regular methods with a similar syntax, only difference is it's not prefixed by <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var cart = {
  _wheels: 4,
  get wheels () {
    return this._wheels
  },
  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error('hey, come back here!')  
    }
    this._wheels = value
  },
  <mark class="md-mark md-code-mark">dismantle () {
    this._wheels = 0
    console.warn(`you're all going to pay for this!`)
  }</mark>
}
</code></pre><p>I think it's nice that methods converged together with getters and setter. I for one don't use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the <a href="#property-value-shorthands">shorthand</a> section. However, it's still useful in some situations and definitely useful when declaring <em>"classes"</em> &ndash; if you're into that sort of thing.</p></section><section class="at-discuss"><span>There's a </span><a aria-label="Your upvote is appreciated!" target="_blank" href="https://news.ycombinator.com/item?id=10158446">discussion on Hacker News</a><span>.</span></section></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Spread and Butter in Depth</h1>
<section class="at-corpus" itemprop="articleBody"><section class="md-markdown at-teaser" itemprop="about"><p>Welcome to yet another installment of <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> on Pony Foo. Previous ones covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, and most recently, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>. Today we'll cover a few more features coming in ES6. Those features are <em>rest parameters, the spread operator, and default parameters.</em></p><p>We've already covered some of this when we talked <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">about destructuring</a>, which supports default values as a nod to the <strong>synergy in ES6 features</strong> I've <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">mentioned yesterday</a>. This article might end up being a tad shorter than the rest because there's not so much to say about these rather simple features. However, and like I've mentioned in the first article of the <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series, the simplest features are usually <a aria-label="Destructuring on Pony Foo" href="/articles/es6-destructuring-in-depth#destructuring">the most useful</a> as well. Let's get on with it!</p></section><section class="md-markdown at-body"><h2 id="rest-parameters">Rest parameters</h2><p>You know how sometimes there's a ton of arguments and you end up having to use the <code class="md-code md-code-inline">arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>).join(<span class="md-code-string">' '</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">'this'</span>, <span class="md-code-string">'was'</span>, <span class="md-code-string">'no'</span>, <span class="md-code-string">'fun'</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- 'this was no fun'</span>
</code></pre><p>The rest parameters syntax enables you to pull a real <code class="md-code md-code-inline">Array</code> out of the <code class="md-code md-code-inline">function</code>s arguments by adding a parameter name prefixed by <code class="md-code md-code-inline">...</code>. Definitely simpler, the fact that it's a real <code class="md-code md-code-inline">Array</code> is also very convenient, and I for one am glad not to have to resort to <code class="md-code md-code-inline">arguments</code> anymore.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">(...words)</span> </span>{
  <span class="md-code-keyword">return</span> words.join(<span class="md-code-string">' '</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">'this'</span>, <span class="md-code-string">'is'</span>, <span class="md-code-string">'okay'</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- 'this is okay'</span>
</code></pre><p>When you have more parameters in your <code class="md-code md-code-inline">function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p><ul><li>Rest parameter gets all the <code class="md-code md-code-inline">arguments</code> passed to the function call</li><li>Each time a parameter is added on the left, it's as if its value is assigned by calling <code class="md-code md-code-inline">rest.shift()</code></li><li>Note that you can't actually place parameters to the right: rest parameters can only be the last argument</li></ul><p>It's easier to visualize how that would behave than try to put it into words, so let's do that. The method below computes the <code class="md-code md-code-inline">sum</code> for all <code class="md-code md-code-inline">arguments</code> except the first one, which is then used as a <code class="md-code md-code-inline">multiplier</code> for the <code class="md-code md-code-inline">sum</code>. In case you don't recall, <code class="md-code md-code-inline">.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> numbers = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>) <span class="md-code-comment">// numbers gets all arguments</span>
  <mark class="md-mark md-code-mark">var multiplier = numbers.shift()</mark>
  <mark class="md-mark md-code-mark">var base = numbers.shift()</mark>
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre><p>Here's how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don't need to use <code class="md-code md-code-inline">arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method &ndash; which now can focus on its functionality itself and not so much on rebalancing <code class="md-code md-code-inline">arguments</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(multiplier, base, <mark class="md-mark md-code-mark">...numbers</mark>)</span> </span>{
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre><h2 id="spread-operator">Spread Operator</h2><p>Typically you invoke a function by passing arguments into it.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>Sometimes however you have those arguments in a list and just don't want to access every index just for a method call <em>&ndash; or you just can't because the array is formed dynamically &ndash;</em> so you use <code class="md-code md-code-inline">.apply</code>. This feels kind of awkward because <code class="md-code md-code-inline">.apply</code> also takes a context for <code class="md-code md-code-inline">this</code>, which feels out of place when it's not relevant and you have to reiterate the host object <em>(or use <code class="md-code md-code-inline">null</code>)</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log.apply(<span class="md-code-built_in">console</span>, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>The spread operator can be used as <em>a butter knife</em> alternative over using <code class="md-code md-code-inline">.apply</code>. There is no need for a context either. You just append three dots <code class="md-code md-code-inline">...</code> to the array, just like with the rest parameter.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">...</mark>[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>As we'll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that's an <em>iterable</em>. This encompasses even things like the results of <code class="md-code md-code-inline">document.querySelectorAll('div')</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[...document.querySelectorAll(<span class="md-code-string">'div'</span>)]
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>
</code></pre><p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they'll be spread over the function call exactly how you'd expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, ...[<span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>], <span class="md-code-number">5</span>) <span class="md-code-comment">// becomes `console.log(1, 2, 3, 4, 5)`</span>
<span class="md-code-comment">// &lt;- '1 2 3 4 5'</span>
</code></pre><p>Time for a real-world example. I sometimes use the method below in Express applications to allow <a aria-label="expressjs/morgan on GitHub" href="https://github.com/expressjs/morgan"><code class="md-code md-code-inline">morgan</code></a> <em>(the request logger in Express)</em> stream its messages through <a aria-label="winstonjs/winston on GitHub" href="https://github.com/winstonjs/winston"><code class="md-code md-code-inline">winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code class="md-code md-code-inline">message</code> because <code class="md-code md-code-inline">winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code class="md-code md-code-inline">pid</code> into the arguments list, and then I <code class="md-code md-code-inline">.apply</code> everything on the <code class="md-code md-code-inline">winston</code> logging mechanism. If you take a close look at the code, the only line of code that's actually doing anything is the one I've highlighted in yellow, the rest is just playing around with <code class="md-code md-code-inline">arguments</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">var</span> bits = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>)
      <span class="md-code-keyword">var</span> message = bits.shift().replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>) <span class="md-code-comment">// remove trailing breaks</span>
      bits.unshift(message)
      bits.push({ hostname: os.hostname(), pid: process.pid })
      <mark class="md-mark md-code-mark">winston[level].apply(winston, bits)</mark>
    }
  }
}
app.use(morgan(<span class="md-code-string">':status :method :url'</span>, {
  stream: createWriteStream(<span class="md-code-string">'debug'</span>)
}))
</code></pre><p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code class="md-code md-code-inline">arguments</code>. The rest parameter already gives us a true array, so there's no casting involved either. We can grab the <code class="md-code md-code-inline">message</code> directly as the first parameter, and we can then apply everything on <code class="md-code md-code-inline">winston[level]</code> directly by combining normal arguments with the rest of the <code class="md-code md-code-inline">...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we're trying to accomplish, which is call <code class="md-code md-code-inline">winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> &ndash; <em>the method stopped being about the code we were trying to write.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, <mark class="md-mark md-code-mark">...bits</mark>)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), <mark class="md-mark md-code-mark">...bits</mark>, {
        hostname: os.hostname(), pid: process.pid
      })
    }
  }
}
</code></pre><p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won't change for the lifespan of the process. We could've done that in the ES5 code too, though.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, ...bits)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), ...bits, proc)
    }
  }
}
</code></pre><p>Another thing we could do to shorten that piece of code might be to use <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You'd have to shorten <code class="md-code md-code-inline">message</code> to <code class="md-code md-code-inline">msg</code> so that it fits in a single line, and the call to <code class="md-code md-code-inline">winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn't</em> spent the last 15 minutes thinking about the method <em>&ndash; be it a team mate or yourself the week after you wrote this function.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: (msg, ...bits) =&gt; winston[level](msg.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), ...bits, proc)
  }
}
</code></pre><p>It would be wiser to just keep our earlier version. While it's <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It's up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you're actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p><p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">while destructuring</a>, in which case it works sort of like <code class="md-code md-code-inline">...rest</code> did, and a use case that's not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code class="md-code md-code-inline">.apply</code> when using the <code class="md-code md-code-inline">new</code> operator as well.</p><table><thead><tr><th>Use Case</th><th>ES5</th><th>ES6</th></tr></thead><tbody><tr><td>Concatenation</td><td><code class="md-code md-code-inline">[1, 2].concat(more)</code></td><td><code class="md-code md-code-inline">[1, 2, ...more]</code></td></tr><tr><td>Push onto list</td><td><code class="md-code md-code-inline">list.push.apply(list, [3, 4])</code></td><td><code class="md-code md-code-inline">list.push(...[3, 4])</code></td></tr><tr><td>Destructuring</td><td><code class="md-code md-code-inline">a = list[0], rest = list.slice(1)</code></td><td><code class="md-code md-code-inline">[a, ...rest] = list</code></td></tr><tr><td><code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code></td><td><a aria-label="This is insanely unreadable. Avoid." href="http://stackoverflow.com/a/8843181/389745"><code class="md-code md-code-inline">new (Date.bind.apply(Date, [null,2015,31,8]))</code></a></td><td><code class="md-code md-code-inline">new Date(...[2015,31,8])</code></td></tr></tbody></table><h2 id="default-operator">Default Operator</h2><p>The default operator is something we've covered in <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(left=1, right=2)</span> </span>{
  <span class="md-code-keyword">return</span> left + right
}
<span class="md-code-built_in">console</span>.log(sum())
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">2</span>))
<span class="md-code-comment">// &lt;- 4</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">1</span>, <span class="md-code-number">0</span>))
<span class="md-code-comment">// &lt;- 1</span>
</code></pre><p>Consider the code that initializes options in <a aria-label="Option initialization in dragula on GitHub" href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37"><code class="md-code md-code-inline">dragula</code></a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">dragula</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">var</span> o = options || {};
  <span class="md-code-keyword">if</span> (o.moves === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.moves = always; }
  <span class="md-code-keyword">if</span> (o.accepts === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.accepts = always; }
  <span class="md-code-keyword">if</span> (o.invalid === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.invalid = invalidTarget; }
  <span class="md-code-keyword">if</span> (o.containers === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.containers = initialContainers || []; }
  <span class="md-code-keyword">if</span> (o.isContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.isContainer = never; }
  <span class="md-code-keyword">if</span> (o.copy === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.copy = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.revertOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.revertOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.removeOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.removeOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.direction === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.direction = <span class="md-code-string">'vertical'</span>; }
  <span class="md-code-keyword">if</span> (o.mirrorContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.mirrorContainer = body; }
}
</code></pre><blockquote><p>Do you think it would be useful to switch to default parameters under ES6 syntax? How would you do that?</p></blockquote></section><section class="at-discuss"><span>There's a </span><a aria-label="Your upvote is appreciated!" target="_blank" href="https://news.ycombinator.com/item?id=10151660">discussion on Hacker News</a><span>.</span></section></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Classes in Depth</h1>
<section class="at-corpus" itemprop="articleBody"><section class="md-markdown at-teaser" itemprop="about"><p>Welcome to <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a>. Are you new here? You might want to learn about <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, or <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literal features in ES6</a>. Today is going to be about <em>"classes"</em> in ES6.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p></blockquote><p>Onwards!</p></section><section class="md-markdown at-body"><h2 id="what-do-you-mean-1-classes-in-javascript"><a aria-label="Peace Sells - Megadeth" href="https://www.youtube.com/watch?v=fCEo2wfudqk">What do you mean</a>; classes in JavaScript?</h2><p>JavaScript is a prototype-based language, so what are ES6 classes really? They're syntactic sugar on top of prototypical inheritance &ndash; a device to make the language more inviting to programmers coming from other paradigms who might not be all that familiar with prototype chains. Many features in ES6 <em>(such as <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>)</em> are, in fact, syntactic sugar &ndash; and classes are no exception. I like to clarify this because it makes it much easier to understand the underlying technology behind ES6 classes. There is no huge restructuring of the language, they just made it easier for people used to classes to leverage prototypal inheritance.</p><blockquote><p>While I may dislike the term <em>"classes"</em> for this particular feature, I have to say that the syntax is in fact much easier to work with than regular prototypal inheritance syntax in ES5, and that's a win for everyone &ndash; regardless of them being called classes or not.</p></blockquote><p>Now that that's out of the way, I'll assume you understand prototypal inheritance &ndash; just because you're reading a blog about JavaScript. Here's how you would describe a <code class="md-code md-code-inline">Car</code> that can be instantiated, fueled up, and move.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Car</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.fuel = <span class="md-code-number">0</span>;
  <span class="md-code-keyword">this</span>.distance = <span class="md-code-number">0</span>;
}

Car.prototype.move = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &lt; <span class="md-code-number">1</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is depleted'</span>)
  }
  <span class="md-code-keyword">this</span>.fuel--
  <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">2</span>
}

Car.prototype.addFuel = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &gt;= <span class="md-code-number">60</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is full'</span>)
  }
  <span class="md-code-keyword">this</span>.fuel++
}
</code></pre><p>To move the car, you could use the following piece of code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> car = <span class="md-code-keyword">new</span> Car()
car.addFuel()
car.move()
car.move()
<span class="md-code-comment">// &lt;- RangeError: 'Fuel tank is depleted'</span>
</code></pre><p>Neat. What about with ES6 classes? The syntax is very similar to declaring an object, except we precede it with <code class="md-code md-code-inline">class Name</code>, where <code class="md-code md-code-inline">Name</code> is the name for our class. Here we are leveraging the <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth#method-signatures">method signature notation</a> we covered yesterday to declare the methods using a shorter syntax. The <code class="md-code md-code-inline">constructor</code> is just like the constructor method in ES5, so you can use that to initialize any variables your instances may have.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor () {
    <span class="md-code-keyword">this</span>.fuel = <span class="md-code-number">0</span>
    <span class="md-code-keyword">this</span>.distance = <span class="md-code-number">0</span>
  }
  move () {
    <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &lt; <span class="md-code-number">1</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is depleted'</span>)
    }
    <span class="md-code-keyword">this</span>.fuel--
    <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">2</span>
  }
  addFuel () {
    <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &gt;= <span class="md-code-number">60</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is full'</span>)
    }
    <span class="md-code-keyword">this</span>.fuel++
  }
}
</code></pre><p>In case you haven't noticed, and for some obscure reason that escapes me, <strong>commas are invalid</strong> in-between properties or methods in a class, as opposed to object literals where commas are <em>(still)</em> mandatory. That discrepancy is bound to cause headaches to people trying to decide whether they want a plain object literal or a class instead, but the code <em>does</em> look sort of cleaner without the commas here.</p><p>Many times <em>"classes"</em> have static methods. Think of your friend the <code class="md-code md-code-inline">Array</code> for example. Arrays have instance methods like <code class="md-code md-code-inline">.filter</code>, <code class="md-code md-code-inline">.reduce</code>, and <code class="md-code md-code-inline">.map</code>. The <code class="md-code md-code-inline">Array</code> <em>"class"</em> itself has static methods as well, like <a aria-label="Array.isArray() - MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"><code class="md-code md-code-inline">Array.isArray</code></a>. In ES5 code, it's pretty easy to add these kind of methods to our <code class="md-code md-code-inline">Car</code> <em>"class"</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Car</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.topSpeed = <span class="md-code-built_in">Math</span>.random()
}
Car.isFaster = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(left, right)</span> </span>{
  <span class="md-code-keyword">return</span> left.topSpeed &gt; right.topSpeed
}
</code></pre><p>In ES6 <code class="md-code md-code-inline">class</code> notation, we can use precede our method with <code class="md-code md-code-inline">static</code>, following a similar syntax as that of <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>. Again, just sugar on top of ES5, as it's quite trivial to transpile this down into ES5 notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor () {
    <span class="md-code-keyword">this</span>.topSpeed = <span class="md-code-built_in">Math</span>.random()
  }
  static isFaster (left, right) {
    <span class="md-code-keyword">return</span> left.topSpeed &gt; right.topSpeed
  }
}
</code></pre><p>One sweet aspect of ES6 <code class="md-code md-code-inline">class</code> sugar is that you also get an <code class="md-code md-code-inline">extends</code> keyword that enables you to easily <em>"inherit"</em> from other <em>"classes"</em>. We all know Tesla cars move further while using the same amount of fuel, thus the code below shows how <code class="md-code md-code-inline">Tesla extends Car</code> and "overrides" <em>(a concept you might be familiar with if you've ever <a aria-label="Overriding methods in C# - MSDN" href="https://msdn.microsoft.com/en-us/library/aa645768(v=vs.71).aspx">played around with C#</a>)</em> the <code class="md-code md-code-inline">move</code> method to cover a larger distance.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Tesla extends Car {
  move () {
    super.move()
    <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">4</span>
  }
}
</code></pre><p>The special <code class="md-code md-code-inline">super</code> keyword identifies the <code class="md-code md-code-inline">Car</code> class we've inherited from &ndash; and since we're speaking about C#, it's akin to <a aria-label="The base keyword ok MSDN" href="https://msdn.microsoft.com/en-us/library/hfw7t1ce.aspx"><code class="md-code md-code-inline">base</code></a>. It's <em>raison d'tre</em> is that most of the time we <em>override</em> a method by re-implementing it in the inheriting class, &ndash; <code class="md-code md-code-inline">Tesla</code> in our example &ndash; we're supposed to call the method on the base class as well. This way we don't have to copy logic over to the inheriting class whenever we re-implement a method. That'd be particularly lousy since whenever a base class changes we'd have to paste their logic into every inheriting class, turning our codebase into a maintainability nightmare.</p><p>If you now did the following, you'll notice the Tesla car moves two places because of <code class="md-code md-code-inline">base.move()</code>, which is what every regular car does as well, and it moves an additional four places because <code class="md-code md-code-inline">Tesla</code> is just that good.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> car = <span class="md-code-keyword">new</span> Tesla()
car.addFuel()
car.move()
<span class="md-code-built_in">console</span>.log(car.distance)
<span class="md-code-comment">// &lt;- 6</span>
</code></pre><p>The most common thing you'll have to override is the <code class="md-code md-code-inline">constructor</code> method. Here you can just call <code class="md-code md-code-inline">super()</code>, passing any arguments that the base class needs. Tesla cars are twice as fast, so we just call the base <code class="md-code md-code-inline">Car</code> constructor with twice the advertised <code class="md-code md-code-inline">speed</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor (speed) {
    <span class="md-code-keyword">this</span>.speed = speed
  }
}
<span class="md-code-keyword">class</span> Tesla extends Car {
  constructor (speed) {
    super(speed * <span class="md-code-number">2</span>)
  }
}
</code></pre><p>Tomorrow, we'll go over the syntax for <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and <code class="md-code md-code-inline">for ... of ...</code>. Until then!</p></section><section class="at-discuss"><span>There's a </span><a aria-label="Your upvote is appreciated!" target="_blank" href="https://news.ycombinator.com/item?id=10164538">discussion on Hacker News</a><span>.</span></section></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 for Now: Template Strings</h1>
<div class="ArticleCopy language-javascript">
    <p><em>This article is part of a web development series from Microsoft. Thank you for supporting the partners who make SitePoint possible.</em></p>
<p><strong>ES6 is the future of JavaScript and it is already here. It is a finished specification, and it brings a lot of features a language requires to stay competitive with the needs of the web of now. Not everything in ES6 is for you and in this little series of posts I will show features that are very handy and already usable.</strong></p>
<p>If you look at JavaScript code I've written you will find that I always use single quotes to define strings instead of double quotes. JavaScript is OK with either, the following two examples do exactly the same thing:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">"cow"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
</code></pre>
<p>The reason why I prefer single quotes is that, first of all, it makes it easier to assemble HTML strings with properly quoted attributes that way:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span spellcheck="true" class="token comment">// with single quotes, there's no need to</span>
<span spellcheck="true" class="token comment">// escape the quotes around the class value</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">'&lt;button class="big"&gt;Save&lt;/button&gt;'</span><span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// this is a syntax error:</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">"&lt;button class="</span>big<span class="token string">"&gt;Save&lt;/button&gt;"</span><span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// this works:</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">"&lt;button class=\"big\"&gt;Save&lt;/button&gt;"</span><span class="token punctuation">;</span>
</code></pre>
<p>The only time you need to escape now is when you use a single quote in your HTML, which should be a very rare occasion. The only thing I can think of is inline JavaScript or CSS, which means you are very likely to do something shady or desperate to your markup. Even in your texts, you are probably better off to not use a single quote but the typographically more pleasing.</p>
<p><em>Aside: Of course, HTML is forgiving enough to omit the quotes or to use single quotes around an attribute, but I prefer to create readable markup for humans rather than relying on the forgiveness of a parser. We made the HTML5 parser forgiving because people wrote terrible markup in the past, not as an excuse to keep doing so.</em></p>
<p>I've suffered enough in the DHTML days of document.write to create a document inside a frameset in a new popup window and other abominations to not want to use the escape character ever again. At times, we needed triple ones, and that was even before we had colour coding in our editors. It was a mess.</p>
<h2>Expression Substitution in Strings?</h2>
<p>Another reason why I prefer single quotes is that I wrote a lot of PHP in my time for very large web sites where performance mattered a lot. In PHP, there is a difference between single and double quotes. Single quoted strings don't have any substitution in them, double quoted ones have. That meant back in the days of PHP 3 and 4 that using single quotes was much faster as the parser doesn't have to go through the string to substitute values. Here is an example what that means:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>php
  $animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
  $sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>
 
  echo <span class="token string">'The animal is $animal and its sound is $sound'</span><span class="token punctuation">;</span>
  <span spellcheck="true" class="token comment">// =&gt; The animal is $animal and its sound is $sound</span>
 
  echo <span class="token string">"The animal is $animal and its sound is $sound"</span><span class="token punctuation">;</span>
  <span spellcheck="true" class="token comment">// =&gt; The animal is cow and its sound is moo</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre>
<p>JavaScript didn't have this substitution, which is why we had to concatenate strings to achieve the same result. This is pretty unwieldy, as you need to jump in and out of quotes all the time.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'The animal is '</span> <span class="token operator">+</span> animal <span class="token operator">+</span> <span class="token string">' and its sound is '</span> <span class="token operator">+</span> sound<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "The animal is cow and its sound is moo"</span>
</code></pre>
<h2>Multi-line Mess</h2>
<p>This gets really messy with longer and more complex strings and especially when we assemble a lot of HTML. And, most likely you will sooner or later end up with your linting tool complaining about trailing whitespace after a + at the end of a line. This is based on the issue that JavaScript has no multi-line strings:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span spellcheck="true" class="token comment">// this doesn't work</span>
<span class="token keyword">var</span> list <span class="token operator">=</span> '<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Buy Milk<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Be kind to Pandas<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Forget about Dre<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>'<span class="token punctuation">;</span> 

<span spellcheck="true" class="token comment">// This does, but urgh </span>
<span class="token keyword">var</span> list <span class="token operator">=</span> '<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>\
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Buy Milk<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Be kind to Pandas<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Forget about Dre<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>'<span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// This is the most common way, and urgh, too </span>
<span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token string">'&lt;ul&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Buy Milk&lt;/li&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Be kind to Pandas&lt;/li&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Forget about Dre&lt;/li&gt;'</span> <span class="token operator">+</span> 
 <span class="token string">'&lt;/ul&gt;'</span><span class="token punctuation">;</span>
</code></pre>
<h2>Client-side Templating Solutions</h2>
<p>In order to work around the mess that is string handling and concatenation in JavaScript, we did what we always do &ndash; we write a library. There are many HTML templating libraries with <a href="https://github.com/janl/mustache.js">Mustache.js</a> probably having been the seminal one. All of these follow an own &ndash; non standardized &ndash; syntax and work in that frame of mind. It's a bit like saying that you write your content in markdown and then realizing that there are many different ideas of what "markdown" means.</p>
<h2>Enter Template Strings</h2>
<p>With the advent of ES6 and its standardization we now can rejoice as JavaScript has now a new kid on the block when it comes to handling strings: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-static-semantics-templatestrings">Template Strings</a>. The <a href="http://kangax.github.io/compat-table/es6/#template_strings">support of template strings in current browsers</a> is encouraging: Chrome 44+, Firefox 38+, <a href="http://dev.modern.ie/platform/status/templatestringses6/?utm_source=SitePoint&amp;utm_medium=article47&amp;utm_campaign=SitePoint/?filter=f3f0000bf&amp;search=template">Microsoft Edge</a> and Webkit are all on board. Safari, sadly enough, is not, but it'll get there.</p>
<p>The genius of template strings is that it uses a new string delimiter, which isn't in use either in HTML nor in normal texts: the backtick (`).</p>
<p>Using this one we now have string expression substitution in JavaScript:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>
 
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The animal is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and its sound is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sound<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "The animal is cow and its sound is moo"</span>
</code></pre>
<p>The <code class=" language-javascript">$<span class="token punctuation">{</span><span class="token punctuation">}</span></code> construct can take any JavaScript expression that returns a value, you can for example do calculations, or access properties of an object:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token template-string"><span class="token string">`ten times two totally is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "ten times two totally is 20"</span>
 
<span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'cow'</span><span class="token punctuation">,</span>
  ilk<span class="token punctuation">:</span> <span class="token string">'bovine'</span><span class="token punctuation">,</span>
  front<span class="token punctuation">:</span> <span class="token string">'moo'</span><span class="token punctuation">,</span>
  back<span class="token punctuation">:</span> <span class="token string">'milk'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`
  The </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is of the 
  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>ilk<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ilk, 
  one end is for the </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>front<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, 
  the other for the </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>back<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; </span>
<span spellcheck="true" class="token comment">/*
  The cow is of the 
  bovine ilk, 
  one end is for the moo, 
  the other for the milk
*/</span>
</code></pre>
<p>That last example also shows you that multi line strings are not an issue at all any longer.</p>
<h2>Tagged Templates</h2>
<p>Another thing you can do with template strings is prepend them with a tag, which is the name of a function that is called and gets the string as a parameter. For example, you could encode the resulting string for URLs without having to resort to the horridly named <code class=" language-javascript">encodeURIComponent</code> all the time.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> urlify <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
urlify <span class="token template-string"><span class="token string">`http://beedogs.com`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "http%3A%2F%2Fbeedogs.com"</span>
urlify <span class="token template-string"><span class="token string">`woah$$%^$"`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "woah%24%C2%A3%24%25%C2%A3%5E%24%22"</span>
 
<span spellcheck="true" class="token comment">// nesting also works:</span>
 
<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token string">`foo ${urlify `</span></span><span class="token operator">&amp;&amp;</span><span class="token template-string"><span class="token string">`} bar`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "foo %26%26 bar"</span>
</code></pre>
<p>This works, but relies on implicit array-to-string coercion. The parameter sent to the function is not a string, but an array of strings and values. If used the way I show here, it gets converted to a string for convenience, but the correct way is to access the array members directly.</p>
<h2>Retrieving Strings and Values from a Template String</h2>
<p>Inside the tag function you can not only get the full string but also its parts.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> tag <span class="token punctuation">(</span>strings<span class="token punctuation">,</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
tag <span class="token template-string"><span class="token string">`you </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> it`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">/* =&gt;
 
Array [ "you ", " it" ]
7
it
 
*/</span>
</code></pre>
<p>There is also an array of the raw strings provided to you, which means that you get all the characters in the string, including control characters. Say, for example, you add a line break with \n. You will get the double whitespace in the string, but the \n characters in the raw strings:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> tag <span class="token punctuation">(</span>strings<span class="token punctuation">,</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span>raw<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
tag <span class="token template-string"><span class="token string">`you </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> \nit`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">/* =&gt;
 
Array [ "you ", "  it" ]
7
 
it
 \nit
*/</span>
</code></pre>
<h2>Conclusion</h2>
<p>Template strings are one of those nifty little wins in ES6 that can be used right now. If you have to support older browsers, you can of course transpile your ES6 to ES5; you can do a feature test for template string support using a library like <a href="http://featuretests.io/">featuretests.io</a> or with the following code:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> templatestrings <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span> <span class="token string">"`{2+2}`"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  templatestrings <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  templatestrings <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
 
<span class="token keyword">if</span> <span class="token punctuation">(</span>templatestrings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span spellcheck="true" class="token comment">// </span>
<span class="token punctuation">}</span>
</code></pre>
<p>More articles on template strings:</p>

  </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1 class="title-section">10 Ecmascript-6 tricks you can perform right now</h1>
		<div class="body-content">
                            <p>We live in a fluid world. I first started hearing about HTML5 several years ago now, and I've been using it for at least two, yet it won't be officially ready until&nbsp;<a target="_blank" href="http://www.maximumpc.com/article/news/when_will_html5_spec_be_finalized">next year</a>&nbsp;at the earliest. While HTML is making great strides, another leg of the stool is progressing nicely as well. New Javascript features are coming, outlined in the standard known as&nbsp;<em>Ecmascript 6</em>. Though it's not finalized, it is approaching stability and implementation is coming along in various forms.</p>
<p>You've probably heard about some of the cool features on the way, like module support, classes and a bunch of syntactic niceties, but you might not have had a chance to try them. You can try out the&nbsp;<a target="_blank" href="http://traceur-compiler.googlecode.com/git/demo/repl.html">traceur compiler</a>&nbsp;which has support for many new features. It's a wonderful tool, and you can use it to build a full webpage or app taking advanage of some of these features.</p>
<p>There are also quite a few new features already available in the browser. While several browsers have implemented some of the upcoming JS features, I've had particularly good luck with&nbsp;<a target="_blank" href="https://wiki.mozilla.org/Firefox/Aurora">Firefox Aurora</a>. Aurora is an experimental version of Firefox, esssentially a version number or two ahead of the standard release. It's more stable than nightly, but not quite ready for primetime. Nevertheless, I've found it pretty reliable, in fact I've been using it as my primary browser for months without any problems, but your mileage may vary.</p>
<p>All that is to say that if you do want to try ES6, and you aren't afraid of Firefox Aurora, here's some new features you can test out.</p>
<h2>1. Extract the weekday, month, date and year from Date() in one fell swoop:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671cf200725340">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671cf200725340-1" class="crayon-num">1</div><div data-line="crayon-55f69131671cf200725340-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671cf200725340-3" class="crayon-num">3</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671cf200725340-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671cf200725340-2" class="crayon-line crayon-striped-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-sy">[</span><span class="crayon-i">day</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">month</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">date</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">year</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">Date</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">split</span><span class="crayon-sy">(</span><span class="crayon-s">' '</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671cf200725340-3" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Using&nbsp;<em>destructured assignment</em>, you can extract multiple fields from an array and assign them to a set of variables. It doesn't quite work for objects yet, but arrays work fine.</p>
<h2>2. Set default parameter values:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671d8311828246">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671d8311828246-1" class="crayon-num">1</div><div data-line="crayon-55f69131671d8311828246-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671d8311828246-3" class="crayon-num">3</div><div data-line="crayon-55f69131671d8311828246-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671d8311828246-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671d8311828246-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671d8311828246-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-v">y</span><span class="crayon-o">=</span><span class="crayon-cn">1</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-i">y</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671d8311828246-3" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-cn">22</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671d8311828246-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 22 1</span></div><div id="crayon-55f69131671d8311828246-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Finally, we can get rid of the various (sometimes dubious) default parameter patterns, with built-in support for default parameters. Once destructured object assignments are complete, we'll be able to use those for setting defaults from named parameter objects as well.</p>
<h2>3. Use variable args without the arguments object:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671dc428468448">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671dc428468448-1" class="crayon-num">1</div><div data-line="crayon-55f69131671dc428468448-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671dc428468448-3" class="crayon-num">3</div><div data-line="crayon-55f69131671dc428468448-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671dc428468448-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671dc428468448-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671dc428468448-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-i">y</span><span class="crayon-sy">,</span><span class="crayon-i">z</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">.</span><span class="crayon-sy">.</span><span class="crayon-sy">.</span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-h"> </span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671dc428468448-3" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-cn">1</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">7</span><span class="crayon-sy">,</span><span class="crayon-cn">8</span><span class="crayon-sy">,</span><span class="crayon-cn">9</span><span class="crayon-sy">,</span><span class="crayon-s">'a'</span><span class="crayon-sy">,</span><span class="crayon-s">'b'</span><span class="crayon-sy">,</span><span class="crayon-s">'c'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671dc428468448-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 7 8 9 'a' 'b' 'c'</span></div><div id="crayon-55f69131671dc428468448-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>One word of wisdom I often see is that the arguments object is not an array, and you should not treat it like one. With the&nbsp;<em>rest</em>&nbsp;operator, you don't need the arguments object, and the rest of the parameters really do end up in a real array.</p>
<h2>4. Define a function quicker than you can type "function () {}":</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671df855591025">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671df855591025-1" class="crayon-num">1</div><div data-line="crayon-55f69131671df855591025-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671df855591025-3" class="crayon-num">3</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671df855591025-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671df855591025-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-o">&gt;</span><span class="crayon-h"> </span><span class="crayon-e ">x*</span><span class="crayon-i">x</span></div><div id="crayon-55f69131671df855591025-3" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>For a language that is arguably functional at heart, Javascript picked an unusually verbose keyword to describe functions, especially given the prevalence of callback routines and object methods which involve an awful lot of repetition of the word "function". And while not everyone loves CoffeeScript, I suspect even the haters are sometimes jealous of its arrow notation as a shortcut to describe functions. The fat arrow knocks out two birds with one stone, as it also provides a lexical&nbsp;<em>this</em>&nbsp;pointer, the lack of which confuses many a new Javascript programmer.</p>
<h2>5. Create variables with block scope:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671e3864303907">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671e3864303907-1" class="crayon-num">1</div><div data-line="crayon-55f69131671e3864303907-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671e3864303907-3" class="crayon-num">3</div><div data-line="crayon-55f69131671e3864303907-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671e3864303907-5" class="crayon-num">5</div><div data-line="crayon-55f69131671e3864303907-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671e3864303907-7" class="crayon-num">7</div><div data-line="crayon-55f69131671e3864303907-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671e3864303907-9" class="crayon-num">9</div><div data-line="crayon-55f69131671e3864303907-10" class="crayon-num crayon-striped-num">10</div><div data-line="crayon-55f69131671e3864303907-11" class="crayon-num">11</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671e3864303907-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671e3864303907-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e3864303907-3" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">let</span><span class="crayon-h"> </span><span class="crayon-v">n</span><span class="crayon-o">=</span><span class="crayon-cn">1</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">let</span><span class="crayon-h"> </span><span class="crayon-v">n</span><span class="crayon-o">=</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-v">i</span><span class="crayon-o">=</span><span class="crayon-cn">0</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">i</span><span class="crayon-o">&lt;</span><span class="crayon-i">n</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">i</span><span class="crayon-o">++</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e3864303907-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671e3864303907-7" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">n</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-8" class="crayon-line crayon-striped-line"><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-9" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-10" class="crayon-line crayon-striped-line"><span class="crayon-c">// 0 1 2 3 4 1</span></div><div id="crayon-55f69131671e3864303907-11" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>Perhaps the most anticipated feature of Ecmascript 6 is the arrival of&nbsp;<em>Block Scoping</em>. One of the single biggest drawbacks of Javascript is its scoping, especially the lack of block scoping, leading to common anti-patterns like declaring every single local variable at the top of a function, regardless of where it's used. With the new&nbsp;<em>let</em>&nbsp;statement we finally have variables with lifetimes that last only until the end of the block.</p>
<h2>6. Make things constant:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671e6393357325">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671e6393357325-1" class="crayon-num">1</div><div data-line="crayon-55f69131671e6393357325-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671e6393357325-3" class="crayon-num">3</div><div data-line="crayon-55f69131671e6393357325-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671e6393357325-5" class="crayon-num">5</div><div data-line="crayon-55f69131671e6393357325-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671e6393357325-7" class="crayon-num">7</div><div data-line="crayon-55f69131671e6393357325-8" class="crayon-num crayon-striped-num">8</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671e6393357325-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671e6393357325-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e6393357325-3" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-m">const</span><span class="crayon-h"> </span><span class="crayon-v">two</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">two</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">5</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">two</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-6" class="crayon-line crayon-striped-line"><span class="crayon-sy">}</span></div><div id="crayon-55f69131671e6393357325-7" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-8" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>In one of my first programming courses, I remember the teacher discussing the Fortran equivalent of a symbolic constant, but she said something like "I know it's good for something but I'm not sure what". These days the goodness of const is generally well understood, but the lack of it in one of the worlds most prevalent languages is not. No more; with ES6 it is finally here.</p>
<h2>7. Intercept and rewrite attribute accesses:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671ea987051653">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671ea987051653-1" class="crayon-num">1</div><div data-line="crayon-55f69131671ea987051653-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671ea987051653-3" class="crayon-num">3</div><div data-line="crayon-55f69131671ea987051653-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671ea987051653-5" class="crayon-num">5</div><div data-line="crayon-55f69131671ea987051653-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671ea987051653-7" class="crayon-num">7</div><div data-line="crayon-55f69131671ea987051653-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671ea987051653-9" class="crayon-num">9</div><div data-line="crayon-55f69131671ea987051653-10" class="crayon-num crayon-striped-num">10</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671ea987051653-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671ea987051653-2" class="crayon-line crayon-striped-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">point</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">x</span><span class="crayon-o">:</span><span class="crayon-cn">1</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-3" class="crayon-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">w</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">set</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-sy">,</span><span class="crayon-i">p</span><span class="crayon-sy">,</span><span class="crayon-i">v</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671ea987051653-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">p</span><span class="crayon-sy">,</span><span class="crayon-i">v</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671ea987051653-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-7" class="crayon-line"><span class="crayon-v">p</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">Proxy</span><span class="crayon-sy">(</span><span class="crayon-i">point</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">w</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-8" class="crayon-line crayon-striped-line"><span class="crayon-v">p</span><span class="crayon-sy">.</span><span class="crayon-v">x</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-9" class="crayon-line"><span class="crayon-c">// prints 'x 2', but doesn't change p.x</span></div><div id="crayon-55f69131671ea987051653-10" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>While&nbsp;<em>getters</em>&nbsp;and&nbsp;<em>setters</em>&nbsp;are becoming more familiar to javascript programmers,&nbsp;<em>Proxy</em>&nbsp;provides extensive functionality to wrap an object so that a number of types of access may be monitored or modified. A more comprehensive list of "proxyable" items may be found&nbsp;<a target="_blank" href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">here</a>.</p>
<h2>8. Create and manipulate&nbsp;<em>Sets</em>:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671ed376106970">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671ed376106970-1" class="crayon-num">1</div><div data-line="crayon-55f69131671ed376106970-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671ed376106970-3" class="crayon-num">3</div><div data-line="crayon-55f69131671ed376106970-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671ed376106970-5" class="crayon-num">5</div><div data-line="crayon-55f69131671ed376106970-6" class="crayon-num crayon-striped-num">6</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671ed376106970-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671ed376106970-2" class="crayon-line crayon-striped-line"><span class="crayon-v">s</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-r">new</span><span class="crayon-h"> </span><span class="crayon-e">Set</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ed376106970-3" class="crayon-line"><span class="crayon-sy">[</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-cn">4</span><span class="crayon-sy">,</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">]</span><span class="crayon-sy">.</span><span class="crayon-e">map</span><span class="crayon-sy">(</span><span class="crayon-v">x</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-o">&gt;</span><span class="crayon-h"> </span><span class="crayon-v">s</span><span class="crayon-sy">.</span><span class="crayon-e">add</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671ed376106970-4" class="crayon-line crayon-striped-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-h"> </span><span class="crayon-i">of</span><span class="crayon-h"> </span><span class="crayon-i">s</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671ed376106970-5" class="crayon-line"><span class="crayon-c">// 2 3 4 5</span></div><div id="crayon-55f69131671ed376106970-6" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p>There's a reason that mathematicians invented sets, and sometimes developers need them too. Now instead of needing to implement them or rely on another JS library, they're just there.</p>
<h2>9. Use an object as a key value:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671f1573694665">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671f1573694665-1" class="crayon-num">1</div><div data-line="crayon-55f69131671f1573694665-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671f1573694665-3" class="crayon-num">3</div><div data-line="crayon-55f69131671f1573694665-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671f1573694665-5" class="crayon-num">5</div><div data-line="crayon-55f69131671f1573694665-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671f1573694665-7" class="crayon-num">7</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671f1573694665-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671f1573694665-2" class="crayon-line crayon-striped-line"><span class="crayon-v">m</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-r">new</span><span class="crayon-h"> </span><span class="crayon-e">Map</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671f1573694665-3" class="crayon-line"><span class="crayon-v">o</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">passwd</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">"my name is my password"</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671f1573694665-4" class="crayon-line crayon-striped-line"><span class="crayon-v">m</span><span class="crayon-sy">.</span><span class="crayon-e">set</span><span class="crayon-sy">(</span><span class="crayon-i">o</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-s">"content"</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671f1573694665-5" class="crayon-line"><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-v">m</span><span class="crayon-sy">.</span><span class="crayon-e">get</span><span class="crayon-sy">(</span><span class="crayon-i">o</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671f1573694665-6" class="crayon-line crayon-striped-line"><span class="crayon-c">// "content"</span></div><div id="crayon-55f69131671f1573694665-7" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>Map may seem redundant at first, as it appears to be a more complicated version of an object, i.e. just a set of&nbsp;
			<span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-github crayon-theme-github-inline crayon-font-monaco" id="crayon-55f69131671f4120957998"><span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-pre crayon-code"><span class="crayon-i">key</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">value</span></span></span>&nbsp;pairs with less convenient syntax. But with objects, the key must be a string (dot notation is just shorthand for strings that work as JavaScript identifiers). With Maps, the key can be a javascript object, which can be really handy at times.</p>
<h2>10. Iterate and Generate:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671f7703292038">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671f7703292038-1" class="crayon-num">1</div><div data-line="crayon-55f69131671f7703292038-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671f7703292038-3" class="crayon-num">3</div><div data-line="crayon-55f69131671f7703292038-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671f7703292038-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671f7703292038-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671f7703292038-2" class="crayon-line crayon-striped-line"><span class="crayon-v">nums</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-sy">;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671f7703292038-3" class="crayon-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-h"> </span><span class="crayon-e">of </span><span class="crayon-e">nums</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671f7703292038-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 1 2 3</span></div><div id="crayon-55f69131671f7703292038-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>I must confess, while I think generators are great, when someone asks me for an example of when they are useful, I stumble a bit. You can always use a class with a next function and emulate the functionality of a generator, but generators can be cleaner and more concise. But even if you don't find uses for generators yourself, you'll want to use the "for of" loop. The "for of" construct provides the kind of functionality for iterating through an array that we always wished we had from the "for eachin" loop. Specifically, it only iterates through the iterable part of an Array, ignoring additional properties that may be part of it:</p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671fb614093853">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671fb614093853-1" class="crayon-num">1</div><div data-line="crayon-55f69131671fb614093853-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671fb614093853-3" class="crayon-num">3</div><div data-line="crayon-55f69131671fb614093853-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671fb614093853-5" class="crayon-num">5</div><div data-line="crayon-55f69131671fb614093853-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671fb614093853-7" class="crayon-num">7</div><div data-line="crayon-55f69131671fb614093853-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671fb614093853-9" class="crayon-num">9</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671fb614093853-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671fb614093853-2" class="crayon-line crayon-striped-line"><span class="crayon-v">a</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">[</span><span class="crayon-cn">1</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">4</span><span class="crayon-sy">]</span></div><div id="crayon-55f69131671fb614093853-3" class="crayon-line"><span class="crayon-v">a</span><span class="crayon-sy">.</span><span class="crayon-v">sparse</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">false</span></div><div id="crayon-55f69131671fb614093853-4" class="crayon-line crayon-striped-line">&nbsp;</div><div id="crayon-55f69131671fb614093853-5" class="crayon-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-h"> </span><span class="crayon-i">of</span><span class="crayon-h"> </span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671fb614093853-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671fb614093853-7" class="crayon-line"><span class="crayon-sy">}</span></div><div id="crayon-55f69131671fb614093853-8" class="crayon-line crayon-striped-line"><span class="crayon-c">// 1 2 3 4</span></div><div id="crayon-55f69131671fb614093853-9" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>There are a few caveats to consider. While these examples should work fine in a Firefox (Aurora) console, they don't all work in a script tag (or included .js file) unless you set&nbsp;
			<span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-github crayon-theme-github-inline crayon-font-monaco" id="crayon-55f69131671fe292503500"><span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-pre crayon-code"><span class="crayon-v">type</span><span class="crayon-o">=</span><span class="crayon-s">"application/javascript;&lt;wbr /&gt;version=1.7"</span></span></span>. Further, not everything is finalized, and/or Firefox's implementation may diverge from the unfinished standard in some areas, so take everything with a grain of salt. Finally, if you don't want to use Aurora, you could try standard Firefox. since I started working on this article Firefox has almost caught up, such that with the current Release (24) I think everything on this list except Proxy is working. There are a few things that work in traceur but not in Firefox, so that's worth exploring as well. In any case, consider it another way to prepare for the coming storm that is Ecmascript 6.</p>
<p>I mean "storm" in a good way, of course.</p>
                        </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="post clear">
      <h1 class="post__title">
        ES6 arrow functions, syntax and lexical scoping
      </h1>
      <div class="post__meta">
        
        <a href="//github.com/toddmotto/toddmotto.github.io/blob/master/_posts/2015-04-14-es6-arrow-functions-syntaxes-and-lexical-scoping.md" class="post__meta-edit">
          <i class="fa fa-github"></i>
          Edit this page on GitHub
        </a>
        
        <p>
          April 14, 2015
        </p>
      </div>

      <p>ES6/Harmony/whatever introduces a really nice feature that punches above it's weight in terms of simplicity to integrate versus time saving and feature output. This feature is the arrow function.</p>

<p>Before we dive into the features of the arrow function and what it actually does for us, let's understand what an arrow function is <em>not</em>. It's not a replacement for the <code>function</code> keyword, at all. This means you can't do a find and replace on every single <code>function</code> keyword and everything works perfectly, because it likely won't.</p>

<p>If you're competent with the way <a href="//toddmotto.com/everything-you-wanted-to-know-about-javascript-scope">JavaScript scope</a> works, and have a great understanding of lexical scope, the <code>this</code> keyword and Prototype methods such as <code>.call()</code>, <code>.apply()</code> and <code>.bind()</code>, then you're in good hands to continue reading.</p>

<h3>Syntax</h3>

<p>Let's look at what the arrow function's construct is from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN</a>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// example 1</span>
<span class="p">([</span><span class="nx">param</span><span class="p">]</span> <span class="p">[,</span> <span class="nx">param</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">statements</span>
<span class="p">}</span>

<span class="c1">// example 2</span>
<span class="nx">param</span> <span class="o">=&gt;</span> <span class="nx">expression</span></code></pre></div>


<p>The "normal JavaScript" (ES5) equivalents to help transition:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// example 1</span>
<span class="kd">function</span> <span class="p">([</span><span class="nx">param</span><span class="p">]</span> <span class="p">[,</span> <span class="nx">param</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">statements</span>
<span class="p">}</span>

<span class="c1">// example 2</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">expression</span>
<span class="p">}</span></code></pre></div>


<p>The ES6 and ES5 differences in <code>example 1</code> are that the <code>function</code> keyword is omitted, and <code>=&gt;</code> now exists <em>after</em> the arguments. In <code>example 2</code>, our function has been reduced to one line, this is great for single line function expressions that get <code>return</code>'d.</p>

<h4>Hint: arrows are anonymous</h4>

<p>Arrow functions are always anonymous, which means we can't do this with ES6:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// ES5</span>
<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span></code></pre></div>


<p>Instead of this, we could assign our anonymous arrow function it to a variable (using <code>var</code> here instead of <code>let</code> as ES6 block scoping is another topic):</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// ES6</span>
<span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span></code></pre></div>


<p>Let's look at the syntaxes a little further and then the functionality differences when using arrow functions.</p>

<h3>Syntax: single line expressions</h3>

<p>We touched briefly above on single line expressions, let's look at a great use case for them.</p>

<p>Let's take some junky ES5 example that iterates over an Array using <code>Array.prototype.map</code>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">timesTwo</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">);</span> <span class="c1">// [2, 4, 6, 8, 10]</span></code></pre></div>


<p>We can reduce this down to a single line with an arrow function, which saves us a lot of typing and can actually enhance readability in my opinion as this piece of code has one clear role:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">timesTwo</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">);</span> <span class="c1">// [2, 4, 6, 8, 10]</span></code></pre></div>


<h3>Syntax: single argument functions</h3>

<p>Arrow functions also give us a small "sugar" syntax that allows us to remove parenthesis when only using a single argument in a function.</p>

<p>Taking the last piece of code for example we had this:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<p>When we could remove the parens from <code>(number)</code> to leave us with this:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">number</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<p>This is great and a little clearer initially, but as we all know applications grow and code scales, and to save us headaches (be it forgetting syntaxes or lesser experienced developers "not knowing" to add parens back with more than one argument), I'd recommend always using the parens out of habit, even for single args:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// we still rock with ES6</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<h3>Functionality: lexical scoping "this"</h3>

<p>Now we're past the sugar syntax excitement, we can dig into the benefits of the arrow function and it's implications on execution context.</p>

<p>Typically if we're writing ES5, we'll use something like <code>Function.prototype.bind</code> to grab the <code>this</code> value from another scope to change a function's execution context. This will mainly be used in callbacks inside a different scope.</p>

<p>In Angular, I adopt the <code>controllerAs</code> syntax which allows me to use <code>this</code> inside the Controller to refer to itself (so here's an example). Inside a function the <code>this</code> value may change, so I could have a few options, use <code>that = this</code> or <code>.bind</code>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>The <code>this.foo = response;</code> won't work correctly as it's been executed in a different context. To change this we could use <code>.bind(this)</code> to give our desired effect:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>


<p>Or you may be used to keeping a top level <code>this</code> reference, which can make more sense when dealing with many nested contexts, we don't want a gross tree of <code>.bind(this), .bind(this), .bind(this)</code> and a tonne of wasted time binding those new functions (<code>.bind</code> is very slow). So we could look at <code>that = this</code> to save the day:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">that</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>With arrow functions, we have a better option, which allows us to "inherit" the scope we're in if needed. Which means if we changed our inital example to the following, the <code>this</code> value would be bound correctly:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// woo, pretty</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>We could then refactor some more into a nice single line expression, push to git and head home for the day:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>




    </article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>JavaScript ES7 Function Bind Syntax</h1>
<div class="article-wrap">
      
      
<!-- /#table-of-contents -->

<p style="font-weight: bold; font-size: 1.5em;">
  <em>Bind your functions with this one weird trick!</em>
</p>

<p>Sorry, I couldn't resist.</p>

<p>I write this post with hesitation but excitement. I have enjoyed playing around
with the new ECMAScript function bind syntax as proposed
<a href="https://github.com/zenparsing/es-function-bind">here</a>. This is a very early
proposal for addition in ES2016 (ES7, whatever) and could drastically change
or even be scrapped. Therefore, I recognize that this post may become obsolete.</p>

<p>I hope by advocating for this syntax, it will get the attention it deserves so
that it will become standard ES syntax. I find it to be a very versatile and
welcome tool in my JavaScript arsenal.</p>

<h2 id="the-syntax">The Syntax</h2>

<p>So what does the syntax actually look like?</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">syntax.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Binding a function to a context</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">log</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Calling functions with a context</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">world</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nl">foo</span><span class="p">:</span><span class="err">:</span><span class="nx">bar</span><span class="p">();</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nl">foo</span><span class="p">:</span><span class="err">:</span><span class="nx">world</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>That's pretty much it. The proposal introduces a new <code>::</code> operator that
simplifies function binding. Essentially, it offers syntactic sugar for calling
the <code>bind</code>, <code>call</code>, and <code>apply</code> methods on <code>Function.prototype</code>. The equivalent
ES5 code is below:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">syntax-compiled.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Binding a function to a context</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Calling functions with a context</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">world</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">world</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>We could call it a day at that, but I don't want to devalue the power that this
syntax affords us. Let's explore the ramifications of this syntax further.</p>

<h2 id="iteration">Iteration</h2>

<p>How often have you done something like this in your JavaScript code?</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-iteration.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">ArrayProto</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">map</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">filter</span><span class="p">;</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'ul.my-list &gt; li'</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">completedItems</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">todoItems</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">completed</span><span class="p">;</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">titles</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">todoItems</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">textContent</span><span class="p">;</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span></div></div></pre></div></figure>

<p>Granted, you might be using a framework for your Todo app or a library like
lodash for iteration, but I don't doubt we've all used the native <code>Array</code>
methods on a different context at some point. It's tedious and messy, but it gets
the job done.</p>

<p>Now, with function bind syntax, we can make this code more expressive and
elegant:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-iteration.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="p">{</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">filter</span> <span class="p">}</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'ul.my-list &gt; li'</span><span class="p">);</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">completedItems</span> <span class="o">=</span> <span class="nx">todoItems</span><span class="err">::</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">completed</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">titles</span> <span class="o">=</span> <span class="nx">todoItems</span><span class="err">::</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span></div></div></pre></div></figure>

<p>The semantics remain the same, yet this reads more naturally and hides away the
uglier syntax we're accustomed to.</p>

<p>If you visit the proposal
(<a href="https://github.com/zenparsing/es-function-bind">link</a>), you'll see another
example where we can import helper functions from a hypothetical iteration
library to iterate over a collection. This creates a better separation of
concerns between data structures and function calls on those structures through
generalization.</p>

<p>Maybe your data structure needs to provide only one function for iteration, and
then you can import iteration "methods" that depend on the function. This
creates modularization possibilities in our JavaScript code similar to Ruby's
Enumerable module (<a href="http://ruby-doc.org/core-2.2.2/Enumerable.html">link</a>).</p>

<h2 id="callbacks">Callbacks</h2>

<p>Another common pattern in JavaScript is passing callbacks to another function
like an event library. This becomes tricky when we desire a specific <code>this</code>
context for our callback. Normally, we have to create a reference to <code>this</code> in a
separate variable and refer to it in our callback, or we call
<code>Function.prototype.bind</code> on our callback, passing in <code>this</code>.</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-callbacks.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">eventLib</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'eventLib'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">self</span><span class="p">.</span><span class="nx">gotFoo</span><span class="p">();</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">gotBar</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">));</span></div></div></pre></div></figure>

<p>Again, this is a little messy and slightly ugly. But with function bind syntax,
it becomes drastically simpler:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-callbacks.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">import</span> <span class="nx">eventLib</span> <span class="nx">from</span> <span class="s1">'eventLib'</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="err">::</span><span class="k">this</span><span class="p">.</span><span class="nx">gotFoo</span><span class="p">);</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="err">::</span><span class="k">this</span><span class="p">.</span><span class="nx">gotBar</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span></div></div></pre></div></figure>

<p>This is powerfully expressive. No function wrapping. No explicit <code>bind</code> calls
(we're obviously still calling it via <code>::</code>, but we hide away those details). We
are declaring our intent that these functions should be called in response to an
event, and we're ensuring our <code>this</code> context with minimal effort.</p>

<h2 id="chaining">Chaining</h2>

<p>If I wasn't already convinced by the function bind syntax, chaining is what
really sold it for me. Recently, I have been using
<a href="https://github.com/Huddle/PhantomCSS">PhantomCSS</a> and
<a href="http://casperjs.org/">CasperJS</a> for a CSS refactoring endeavor. Of course, I'm
on the up-and-up and utilizing ES2015 via <a href="http://babeljs.io/">Babel</a> to write
my test suite. If you have not heard of PhantomCSS or CasperJS, I encourage you
to check them out. PhantomCSS is a very promising project for automating visual
regressions of your website. CasperJS is a wrapper over PhantomJS and SlimerJS,
offering a higher-level API.</p>

<p>For this particular project, I represent web pages as classes according to a
minimal interface. They each have a <code>run</code> method that takes in my <code>casper</code>
instance. From there, each class chains method calls on my <code>casper</code> instance,
returning the result. It's very "promisey." (I also added a few custom methods
to my instance to wrap over some other methods to make them more "promisey.")</p>

<p>To avoid duplication in some classes, I wanted to add some methods to the
<code>casper</code> instance that are specific to the concerns of that page. However, I
didn't want to pollute the actual object instance. Function bind syntax to the
rescue!</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-casper-chaining.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">class</span> <span class="nx">HomePage</span> <span class="p">{</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">run</span><span class="p">(</span><span class="nx">casper</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="err">`</span><span class="p">.</span><span class="nx">my</span><span class="o">-</span><span class="nx">section</span><span class="err">:</span><span class="nx">nth</span><span class="o">-</span><span class="nx">of</span><span class="o">-</span><span class="nx">type</span><span class="p">(</span><span class="nx">$</span><span class="p">{</span><span class="nx">n</span><span class="p">})</span> <span class="nx">$</span><span class="p">{</span><span class="nx">selector</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="k">return</span> <span class="nx">casper</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenVisit</span><span class="p">(</span><span class="s1">'http://my-url.com/home'</span><span class="p">)</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="s1">'home'</span><span class="p">)</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'.foo'</span><span class="p">)</span>
</div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="s1">'.cancel'</span><span class="p">)</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'.bar'</span><span class="p">)</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="p">}</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>That is amazing! I can naturally express the chaining semantics while decorating
my instance without altering it. Just as a reminder of what we would probably
have to do without function bind syntax, here is some equivalent ES2015 code:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es6-casper-chaining.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">class</span> <span class="nx">HomePage</span> <span class="p">{</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">run</span><span class="p">(</span><span class="nx">casper</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="err">`</span><span class="p">.</span><span class="nx">my</span><span class="o">-</span><span class="nx">section</span><span class="err">:</span><span class="nx">nth</span><span class="o">-</span><span class="nx">of</span><span class="o">-</span><span class="nx">type</span><span class="p">(</span><span class="nx">$</span><span class="p">{</span><span class="nx">n</span><span class="p">})</span> <span class="nx">$</span><span class="p">{</span><span class="nx">selector</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">casper</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenVisit</span><span class="p">(</span><span class="s1">'http://my-url.com/home'</span><span class="p">)</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="s1">'home'</span><span class="p">);</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'.foo'</span><span class="p">);</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">);</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="s1">'.cancel'</span><span class="p">);</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'.bar'</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="21" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="k">return</span> <span class="nx">casper</span><span class="p">;</span>
</div></div><div data-line="22" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="p">}</span>
</div></div><div data-line="23" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>It gets the job done, but it doesn't flow as nicely as our chaining example.
Function bind syntax allows us to reduce how much code we write and effectively
express this notion of flowing through each step.</p>

<h2 id="getting-started">Getting Started</h2>

<p>If you'd like to try out function bind syntax, then I encourage you check it out
with Babel. If you've not heard of Babel, it's a transpiler that transforms
ES2015/2016 code into ES5. You can learn more about Babel from its website
(<a href="http://babeljs.io/">link</a>) and learn how to use function bind syntax
<a href="http://babeljs.io/docs/usage/experimental/">here</a>.</p>

<h2 id="gripes-caveats-wishlist">Gripes, Caveats, Wishlist</h2>

<p>I don't think this syntax is without its faults. I'm not entirely sold on the
actual <code>::</code> operator yet. Maybe it's the baggage I carry from other languages
like Ruby, PHP, and CoffeeScript, each which use that operator for different
semantics. Another option might be the <code>-&gt;</code> operator, but it's not my favorite
either (burnout from PHP and C, no doubt). The <code>::</code> operator might be the best
solution, and I don't necessarily hate it.</p>

<p>I haven't dived into the discussion over this spec, but to my knowledge there is
no affordance for partial application via this syntax. Recall that the <code>bind</code>
method on <code>Function.prototype</code> can also partially apply parameters to the bound
function by passing in additional arguments.</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-partial-application.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">DEBUG</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">,</span> <span class="s1">'DEBUG:'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">add1</span> <span class="o">=</span> <span class="nx">add</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">three</span> <span class="o">=</span> <span class="nx">add1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">DEBUG</span><span class="p">(</span><span class="nx">three</span><span class="p">);</span> <span class="c1">// prints "DEBUG: 3"</span></div></div></pre></div></figure>

<p>I would like to see some type of partial application syntax, especially as we
continue to push the boundaries of functional-style programming in JavaScript.
Alas, I recognize that designing clean, efficient syntax is difficult. This may
just not be possible. Some quick ideas for a syntax could be:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-partial-application.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG1</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'DEBUG:'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Currently calls the function back on the same receiver</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// var DEBUG1 = console.log.call(console, 'DEBUG:');</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG2</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="s1">'DEBUG:'</span><span class="p">];</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// This clashes with existing [] semantics</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// var DEBUG2 = console.log['DEBUG:'].bind(console);</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG3</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="o">&lt;</span><span class="s1">'DEBUG:'</span><span class="o">&gt;</span><span class="p">;</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError</span>
</div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG4</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">{</span><span class="s1">'DEBUG:'</span><span class="p">};</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">add1</span> <span class="o">=</span> <span class="err">::</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError (we need a context for the bind operator)</span>
</div></div><div data-line="21" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="22" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// ...</span></div></div></pre></div></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Despite my small gripes and wishes, I readily welcome this proposal for ES2016
and hope the maintainers strongly consider its inclusion. This syntax opens up
the door for writing cleaner and more expressive JavaScript.</p>

      
    </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<div class="post-inner group">
					
					<h1 class="post-title">Getting started with es6 iterators and iterables</h1>
					
					
										
					
					
					<div class="entry">	
						<div class="entry-inner">
							<p><span class="caps">ES6</span> iterators provide a very simple way to iterate on objects, quite similar to the way iterators work in Java. In this post, I will briefly discuss the main concepts behind <span class="caps">ES6</span> iterators and then dive into some examples using arrays. Future posts will discuss using <span class="caps">ES6</span> iterators with other kinds of objects. This article is the second installment of our <a href="http://javascript.tutorialhorizon.com/tag/es6/">Learning <span class="caps">ES6</span> series</a>.</p>
<ul>
<li><strong>Part 1</strong>: <a href="http://javascript.tutorialhorizon.com/2015/06/23/es6-modules-examples/">Getting started with <span class="caps">ES6</span> modules</a></li>
<li><strong>Part 2</strong>: Getting started with <span class="caps">ES6</span> iterators and iterables  <strong><span class="caps">THIS</span> <span class="caps">ARTICLE</span></strong></li>
<li><strong>Part 3</strong>: <a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/"><span class="caps">ES6</span> iterators and iterables  creating custom iterators</a></li>
<li><strong>Part 4</strong>: <a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/">Getting started with <span class="caps">ES6</span> generator functions</a></li>
</ul>
<hr>
<h4>A brief introduction</h4>
<p>There are a few things you ought to know before we jump in and see some examples.</p>
<ul>
<li>There are two main types of entities to be aware of: <code>iterables</code> and <code>iterators</code>.</li>
<li>Iterables are things that can be iterated upon, like arrays, Maps,&nbsp;Sets.</li>
<li>Primitive javascript objects are not iterable.</li>
<li>Anything that implements the <code>next()</code> function can be considered to be an iterator.</li>
<li>The result of invoking <code>next()</code> is (almost) always object of the form <code>{value: some_value, done: true|false }</code>.</li>
<li>Any object/function can be turned into an iterable if it has a key called <code>Symbol.iterator</code> which refers to a function that returns an object with the <code>next()</code> function.</li>
</ul>
<p>If you didnt get all of it right away, dont worry, I didnt either. Lets bite off this cake piece by&nbsp;piece.</p>
<blockquote><p>
  <span class="caps">NOTE</span>: If your browser does not support running all the follwing examples, you can try them out at <a href="http://www.es6fiddle.net/">es6fiddle.net</a>.
</p></blockquote>
<hr>
<h4>Basic iteration</h4>
<p>Arrays are the simplest and the most common iterables. Traditionally, you could iterate on arrays as follows</p>
<pre><code class="js">var numbers = ['a', 'b'];
for (var num in numbers) {
  console.log(num);
}
</code></pre>
<p>Using the new <span class="caps">ES6</span> iterators you can iterate on an array as follows:</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter = numbers[Symbol.iterator]();
console.log(iter.next()); // Prints {value: "a", done: false}
console.log(iter.next()); // Prints {value: "b", done: false}
console.log(iter.next()); // Prints {value: undefined, done: true}
</code></pre>
<p>In <span class="caps">ES6</span> <code>Symbol.iterator</code> is a non-string key for iterables that is invoked to create an instance of an iterator. In fact, <code>Symbol</code> is a completely new primitive type in <span class="caps">ES6</span>. As you can tell in the above code, the key is already available on the Array primitive type. All we did was invoke it to create a new iterator.</p>
<p>Also, in the above code, notice how the last value of iter.next() returns the done as <code>true</code>. This can be used in your program to determine if there are more items to iterate&nbsp;on.</p>
<p>Having to invoke <code>Symbol.iterator</code> on a primitive like arrays seems like a bit of an overhead. Thats not to worry because you can also use <code>Array.prototype.entries()</code> to create the exact same iterator, albeit in a much more convenient syntax.</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter1 = numbers.entries();
// is equivalent to
var iter2 = numbers[Symbol.iterator]();
</code></pre>
<blockquote><p>
  The entries() function is available on <span class="caps">ES6</span> primitives like arrays, typed arrays, maps and sets. In fact, they also have two more useful functions  keys() and values() which do pretty much what you think they&nbsp;do.
</p></blockquote>
<hr>
<h4>Different ways to iterate</h4>
<p>Another point to note is that depending on the way you iterate, you can expect a different kind of output. For example.</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter1 = numbers.entries();

console.log(iter1.next()); // Prints {value: "a", done: false}
console.log(iter1.next()); // Prints {value: "b", done: false}
console.log(iter1.next()); // Prints {value: undefined, done: true}

// Compare the above output to the following
for (var item of numbers.entries()) {
    console.log(item);
}
// Output
// [0, "a"]
// [1, "b"]
</code></pre>
<p>Notice in the above code, we had to use the for..of loop for this to work instead of the for..in loop. As far as the output is concerned, the first item of the output array represents the <code>key</code> in the entry, which in our case is the index, and the second item in the output array is the actual value of the numbers&nbsp;array.</p>
<p>The return value of the <code>entries()</code> function makes it suitable candidate for being used along with the <strong>spread operator</strong>.</p>
<pre><code class="js">for (var [index, item] of numbers.entries()) {
    console.log(index, item);
}
// Output
// [0, "a"]
// [1, "b"]
</code></pre>
<p>If you wish to, you can also iterate on the keys itself. This isin't as useful in the case of arrays but comes in really handy when you are using <code>Maps</code>.</p>
<pre><code class="js">var coordinates = new Map();
coordinates.set('x', 10);
coordinates.set('y', 20);

for (var item of coordinates.keys()) {
    console.log(item);
}
// Output
// x
// y
</code></pre>
<blockquote><p>
  <span class="caps">NOTE</span>: <span class="caps">ES6</span> Maps, unlike regular javascript objects, return values based on insertion order when iterated&nbsp;on.
</p></blockquote>
<p>The next and final utility function on primitives is the <code>value()</code> function. And as you would expect, it lets you iterate on the values.</p>
<pre><code class="js">var coordinates = new Map();
coordinates.set('x', 10);
coordinates.set('y', 20);

for (var item of coordinates.values()) {
    console.log(item);
}
// Output
// 10
// 20
</code></pre>
<p>That covers all the ways in which you can use the new <span class="caps">ES6</span> iterators. In the next article, we will see more examples of creating and using your own iterators and also discuss some of the optional but often times necessary functions like <code>return()</code>.</p>
<hr>
<div id="crp_related" class="crp_related"><h3>Related Posts:</h3><ul><li><a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/" class="crp_title">es6 iterators and iterables  creating custom iterators</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/" class="crp_title">Getting started with es6 generator functions</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/23/es6-modules-examples/" class="crp_title">Using es6 modules with simple examples</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/01/17/d3-fundamentals-understanding-domain-range-and-scales-in-d3js/" class="crp_title">d3 Fundamentals : Understanding domain, range and scales in&nbsp;D3js</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/09/12/javascript-objects-and-arrays-useful-methods/" class="crp_title">JavaScript Objects and Arrays Useful Methods</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/08/06/the-javascript-prototype-property-visualized/" class="crp_title">The JavaScript Prototype Property  Visualized</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/18/getting-the-parameters-and-arguments-of-a-javascript-function/" class="crp_title">Getting the parameters and arguments of a javascript function</a></li></ul><div style="clear:both"></div></div>													</div>
						<div class="clear"></div>				
					</div><!--/.entry-->
					
				</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<div class="post-inner group">
					
					<h1 class="post-title">Using es6 modules with simple examples</h1>
					
					
										
					
					
					<div class="entry">	
						<div class="entry-inner">
							<p>Modules have been around in javascript for a while now. The two competing standards for module declaration have been the <span class="caps">AMD</span> and Commonjs specification. With the new <span class="caps">ES6</span> specs, module definition and consumption is now part of the language itself. This article will be the first installment of our <a href="http://javascript.tutorialhorizon.com/tag/es6/">Learning <span class="caps">ES6</span> series</a>. In this article, I am going to take some very simple examples to demonstrate the usage of <span class="caps">ES6</span> modules.</p>
<ul>
<li><strong>Part 1</strong>: Getting started with <span class="caps">ES6</span> modules  <strong><span class="caps">THIS</span> <span class="caps">ARTICLE</span></strong></li>
<li><strong>Part 2</strong>: <a href="http://javascript.tutorialhorizon.com/2015/06/27/es6-iterators-and-iterables/">Getting started with <span class="caps">ES6</span> iterators and iterables</a></li>
<li><strong>Part 3</strong>: <a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/"><span class="caps">ES6</span> iterators and iterables  creating custom iterators</a></li>
<li><strong>Part 4</strong>: <a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/">Getting started with <span class="caps">ES6</span> generator functions</a></li>
</ul>
<hr>
<p>Quite similar to Commonjs, <span class="caps">ES6</span> lets you export and import objects, albeit it does so in slightly different&nbsp;ways.</p>
<p><strong>Example&nbsp;1:</strong></p>
<p>Using a single <code>export</code> at the end of your module file. This form of usage is called a <em>named export</em> because while exporting you are defining the name of the objects being exported.</p>
<p><em>foobar.js</em></p>
<pre><code class="js">function foo() { return 'foo'; }

function bar() { return 'bar'; }

export { foo, bar };
</code></pre>
<p>Notice how we use the new javascript object shorthand notation on the last line when exporting objects.</p>
<p>You can use the exported object from another file as follows.</p>
<p><em>main.js</em></p>
<pre><code class="js">import {foo, bar} from 'foobar';
foo();
bar();

import * as lib from 'foobar';
lib.foo();
lib.bar();
</code></pre>
<hr>
<p><strong>Example&nbsp;2</strong></p>
<p>In another format for using <em>named exports</em>, you can also export objects/function as and when you create them. I find this syntax a bit more convenient than the one we saw&nbsp;above.</p>
<p><em>foobar.js</em></p>
<pre><code class="js">export function foo() { return 'foo'; }

export function bar() { return 'bar'; }
</code></pre>
<hr>
<p><strong>Example&nbsp;3</strong></p>
<p><span class="caps">ES6</span> also has something called as a <code>default</code> export. A file can have zero or 1 default export. Fortunately, you can use zero or many <em>named exports</em> in a file containing default exports. For example</p>
<p><em>foobar.js</em></p>
<pre><code class="js">export default function foo() {
  return 'default foo';
};

export function bar() { return 'bar'; };
</code></pre>
<hr>
<p>And here's how you would consume&nbsp;it</p>
<p><em>main.js</em></p>
<pre><code class="js">// These will only get you foo
import mylib from 'foobar';
import {default as mylib} from 'foobar';

// This will get you both foo and bar
import mylib, {bar} from 'foobar';
</code></pre>
<p>Notice how in the above code, you were able to use the name mylib' instead of foo'. Thats because foo was the default export in your module so you didn't have to pluck it out of the exported object the way you had to do it if you only had named exported objects.</p>
<p>And that pretty much covers the ways in which you can use the new <span class="caps">ES6</span> modules.</p>
<hr>
<div id="crp_related" class="crp_related"><h3>Related Posts:</h3><ul><li><a href="http://javascript.tutorialhorizon.com/2014/09/01/understanding-nodejs-module-exports-and-require/" class="crp_title">Understanding nodejs module exports and require</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/" class="crp_title">es6 iterators and iterables  creating custom iterators</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/27/es6-iterators-and-iterables/" class="crp_title">Getting started with es6 iterators and iterables</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/" class="crp_title">Getting started with es6 generator functions</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/20/organizing-your-expressjs-routes-in-separate-files/" class="crp_title">Organizing your expressjs routes in separate&nbsp;files.</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/07/debugging-nodejs-applications-using-node-inspector-and-chrome-dev-tools/" class="crp_title">Debugging nodejs applications using node-inspector and Chrome Dev&nbsp;Tools</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/07/configuring-jshint-as-a-pre-commit-hook-for-your-nodejs-applications/" class="crp_title">Configuring jshint as a pre-commit hook for your nodejs applications</a></li></ul><div style="clear:both"></div></div>													</div>
						<div class="clear"></div>				
					</div><!--/.entry-->
					
				</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-1-es-now--future" class="anchor" href="#chapter-1-es-now--future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: ES? Now &amp; Future</h1>

<p>Before you dive into this book, you should have a solid working proficiency over JavaScript up to the most recent standard (at the time of this writing), which is commonly called <em>ES5</em> (technically ES 5.1). Here, we plan to talk squarely about the upcoming <em>ES6</em>, as well as cast our vision beyond to understand how JS will evolve moving forward.</p>

<p>If you are still looking for confidence with JavaScript, I highly recommend you read the other titles in this series first:</p>

<ul>
<li><em>Up &amp; Going</em>: Are you new to programming and JS? This is the roadmap you need to consult as you start your learning journey.</li>
<li><em>Scope &amp; Closures</em>: Did you know that JS lexical scope is based on compiler (not interpreter!) semantics? Can you explain how closures are a direct result of lexical scope and functions as values?</li>
<li><em>this &amp; Object Prototypes</em>: Can you recite the four simple rules for how <code>this</code> is bound? Have you been muddling through fake "classes" in JS instead of adopting the simpler "behavior delegation" design pattern? Ever heard of <em>objects linked to other objects</em> (OLOO)?</li>
<li><em>Types &amp; Grammar</em>: Do you know the built-in types in JS, and more importantly, do you know how to properly and safely use coercion between types? How comfortable are you with the nuances of JS grammar/syntax?</li>
<li><em>Async &amp; Performance</em>: Are you still using callbacks to manage your asynchrony? Can you explain what a promise is and why/how it solves "callback hell"? Do you know how to use generators to improve the legibility of async code? What exactly constitutes mature optimization of JS programs and individual operations?</li>
</ul>

<p>If you've already read all those titles and you feel pretty comfortable with the topics they cover, it's time we dive into the evolution of JS to explore all the changes coming not only soon but farther over the horizon.</p>

<p>Unlike ES5, ES6 is not just a modest set of new APIs added to the language. It incorporates a whole slew of new syntactic forms, some of which may take quite a bit of getting used to. There's also a variety of new organization forms and new API helpers for various data types.</p>

<p>ES6 is a radical jump forward for the language. Even if you think you know JS in ES5, ES6 is full of new stuff you <em>don't know yet</em>, so get ready! This book explores all the major themes of ES6 that you need to get up to speed on, and even gives you a glimpse of future features coming down the track that you should be aware of.</p>

<p><strong>Warning:</strong> All code in this book assumes an ES6+ environment. At the time of this writing, ES6 support varies quite a bit in browsers and JS environments (like Node.js), so your mileage may vary.</p>

<h2><a id="user-content-versioning" class="anchor" href="#versioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Versioning</h2>

<p>The JavaScript standard is referred to officially as "ECMAScript" (abbreviated "ES"), and up until just recently has been versioned entirely by ordinal number (i.e., "5" for "5th edition").</p>

<p>The earliest versions, ES1 and ES2, were not widely known or implemented. ES3 was the first widespread baseline for JavaScript, and constitutes the JavaScript standard for browsers like IE6-8 and older Android 2.x mobile browsers. For political reasons beyond what we'll cover here, the ill-fated ES4 never came about.</p>

<p>In 2009, ES5 was officially finalized (later ES5.1 in 2011), and settled as the widespread standard for JS for the modern revolution and explosion of browsers, such as Firefox, Chrome, Opera, Safari, and many others.</p>

<p>Leading up to the expected <em>next</em> version of JS (slipped from 2013 to 2014 and then 2015), the obvious and common label in discourse has been ES6.</p>

<p>However, late into the ES6 specification timeline, suggestions have surfaced that versioning may in the future switch to a year-based schema, such as ES2016 (aka ES7) to refer to whatever version of the specification is finalized before the end of 2016. Some disagree, but ES6 will likely maintain its dominant mindshare over the late-change substitute ES2015. However, ES2016 may in fact signal the new year-based schema.</p>

<p>It has also been observed that the pace of JS evolution is much faster even than single-year versioning. As soon as an idea begins to progress through standards discussions, browsers start prototyping the feature, and early adopters start experimenting with the code.</p>

<p>Usually well before there's an official stamp of approval, a feature is de facto standardized by virtue of this early engine/tooling prototyping. So it's also valid to consider the future of JS versioning to be per-feature rather than per-arbitrary-collection-of-major-features (as it is now) or even per-year (as it may become).</p>

<p>The takeaway is that the version labels stop being as important, and JavaScript starts to be seen more as an evergreen, living standard. The best way to cope with this is to stop thinking about your code base as being "ES6-based," for instance, and instead consider it feature by feature for support.</p>

<h2><a id="user-content-transpiling" class="anchor" href="#transpiling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transpiling</h2>

<p>Made even worse by the rapid evolution of features, a problem arises for JS developers who at once may both strongly desire to use new features while at the same time being slapped with the reality that their sites/apps may need to support older browsers without such support.</p>

<p>The way ES5 appears to have played out in the broader industry, the typical mindset was that code bases waited to adopt ES5 until most if not all pre-ES5 environments had fallen out of their support spectrum. As a result, many are just recently (at the time of this writing) starting to adopt things like <code>strict</code> mode, which landed in ES5 over five years ago.</p>

<p>It's widely considered to be a harmful approach for the future of the JS ecosystem to wait around and trail the specification by so many years. All those responsible for evolving the language desire for developers to begin basing their code on the new features and patterns as soon as they stabilize in specification form and browsers have a chance to implement them.</p>

<p>So how do we resolve this seeming contradiction? The answer is tooling, specifically a technique called <em>transpiling</em> (transformation + compiling). Roughly, the idea is to use a special tool to transform your ES6 code into equivalent (or close!) matches that work in ES5 environments.</p>

<p>For example, consider shorthand property definitions (see "Object Literal Extensions" in Chapter 2). Here's the ES6 form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    foo     <span class="pl-c">// means `foo: foo`</span>
};

obj.foo;    <span class="pl-c">// [1,2,3]</span></pre></div>

<p>But (roughly) here's how that transpiles:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> foo
};

obj.foo;    <span class="pl-c">// [1,2,3]</span></pre></div>

<p>This is a minor but pleasant transformation that lets us shorten the <code>foo: foo</code> in an object literal declaration to just <code>foo</code>, if the names are the same.</p>

<p>Transpilers perform these transformations for you, usually in a build workflow step similar to how you perform linting, minification, and other similar operations.</p>

<h3><a id="user-content-shimspolyfills" class="anchor" href="#shimspolyfills" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shims/Polyfills</h3>

<p>Not all new ES6 features need a transpiler. Polyfills (aka shims) are a pattern for defining equivalent behavior from a newer environment into an older environment, when possible. Syntax cannot be polyfilled, but APIs often can be.</p>

<p>For example, <code>Object.is(..)</code> is a new utility for checking strict equality of two values but without the nuanced exceptions that <code>===</code> has for <code>NaN</code> and <code>-0</code> values. The polyfill for <code>Object.is(..)</code> is pretty easy:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Object</span>.is) {
    <span class="pl-c1">Object</span>.<span class="pl-en">is</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">v1</span>, <span class="pl-smi">v2</span>) {
        <span class="pl-c">// test for `-0`</span>
        <span class="pl-k">if</span> (v1 <span class="pl-k">===</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> v2 <span class="pl-k">===</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> v1 <span class="pl-k">===</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> v2;
        }
        <span class="pl-c">// test for `NaN`</span>
        <span class="pl-k">if</span> (v1 <span class="pl-k">!==</span> v1) {
            <span class="pl-k">return</span> v2 <span class="pl-k">!==</span> v2;
        }
        <span class="pl-c">// everything else</span>
        <span class="pl-k">return</span> v1 <span class="pl-k">===</span> v2;
    };
}</pre></div>

<p><strong>Tip:</strong> Pay attention to the outer <code>if</code> statement guard wrapped around the polyfill. This is an important detail, which means the snippet only defines its fallback behavior for older environments where the API in question isn't already defined; it would be very rare that you'd want to overwrite an existing API.</p>

<p>There's a great collection of ES6 shims called "ES6 Shim" (<a href="https://github.com/paulmillr/es6-shim/">https://github.com/paulmillr/es6-shim/</a>) that you should definitely adopt as a standard part of any new JS project!</p>

<p>It is assumed that JS will continue to evolve constantly, with browsers rolling out support for features continually rather than in large chunks. So the best strategy for keeping updated as it evolves is to just introduce polyfill shims into your code base, and a transpiler step into your build workflow, right now and get used to that new reality.</p>

<p>If you decide to keep the status quo and just wait around for all browsers without a feature supported to go away before you start using the feature, you're always going to be way behind. You'll sadly be missing out on all the innovations designed to make writing JavaScript more effective, efficient, and robust.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 (some may try to call it ES2015) is just landing as of the time of this writing, and it has lots of new stuff you need to learn!</p>

<p>But it's even more important to shift your mindset to align with the new way that JavaScript is going to evolve. It's not just waiting around for years for some official document to get a vote of approval, as many have done in the past.</p>

<p>Now, JavaScript features land in browsers as they become ready, and it's up to you whether you'll get on the train early or whether you'll be playing costly catch-up games years from now.</p>

<p>Whatever labels that future JavaScript adopts, it's going to move a lot quicker than it ever has before. Transpilers and shims/polyfills are important tools to keep you on the forefront of where the language is headed.</p>

<p>If there's any narrative important to understand about the new reality for JavaScript, it's that all JS developers are strongly implored to move from the trailing edge of the curve to the leading edge. And learning ES6 is where that all starts!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-2-syntax" class="anchor" href="#chapter-2-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: Syntax</h1>

<p>If you've been writing JS for any length of time, odds are the syntax is pretty familiar to you. There are certainly many quirks, but overall it's a fairly reasonable and straightforward syntax that draws many similarities from other languages.</p>

<p>However, ES6 adds quite a few new syntactic forms that take some getting used to. In this chapter, we'll tour through them to find out what's in store.</p>

<p><strong>Tip:</strong> At the time of this writing, some of the features discussed in this book have been implemented in various browsers (Firefox, Chrome, etc.), but some have only been partially implemented and many others have not been implemented at all. Your experience may be mixed trying these examples directly. If so, try them out with transpilers, as most of these features are covered by those tools. ES6Fiddle (<a href="http://www.es6fiddle.net/">http://www.es6fiddle.net/</a>) is a great, easy-to-use playground for trying out ES6, as is the online REPL for the Babel transpiler (<a href="http://babeljs.io/repl/">http://babeljs.io/repl/</a>).</p>

<h2><a id="user-content-block-scoped-declarations" class="anchor" href="#block-scoped-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block-Scoped Declarations</h2>

<p>You're probably aware that the fundamental unit of variable scoping in JavaScript has always been the <code>function</code>. If you needed to create a block of scope, the most prevalent way to do so other than a regular function declaration was the immediately invoked function expression (IIFE). For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 3</span>
})();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// 2</span></pre></div>

<h3><a id="user-content-let-declarations" class="anchor" href="#let-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code> Declarations</h3>

<p>However, we can now create declarations that are bound to any block, called (unsurprisingly) <em>block scoping</em>. This means all we need is a pair of <code>{ .. }</code> to create a scope. Instead of using <code>var</code>, which always declares variables attached to the enclosing function (or global, if top level) scope, use <code>let</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

{
    <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 3</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// 2</span></pre></div>

<p>It's not very common or idiomatic thus far in JS to use a standalone <code>{ .. }</code> block, but it's always been valid. And developers from other languages that have <em>block scoping</em> will readily recognize that pattern.</p>

<p>I believe this is the best way to create block-scoped variables, with a dedicated <code>{ .. }</code> block. Moreover, you should always put the <code>let</code> declaration(s) at the very top of that block. If you have more than one to declare, I'd recommend using just one <code>let</code>.</p>

<p>Stylistically, I even prefer to put the <code>let</code> on the same line as the opening <code>{</code>, to make it clearer that this block is only for the purpose of declaring the scope for those variables.</p>

<div class="highlight highlight-source-js"><pre>{   <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>, b, c;
    <span class="pl-c">// ..</span>
}</pre></div>

<p>Now, that's going to look strange and it's not likely going to match the recommendations given in most other ES6 literature. But I have reasons for my madness.</p>

<p>There's another experimental (not standardized) form of the <code>let</code> declaration called the <code>let</code>-block, which looks like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">let</span> (<span class="pl-smi">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>, <span class="pl-smi">b</span>, <span class="pl-smi">c</span>) {
    <span class="pl-c">// ..</span>
}</pre></div>

<p>That form is what I'd called <em>explicit</em> block scoping, whereas the <code>let ..</code> declaration form that mirrors <code>var</code> is more <em>implicit</em>, as it kind of hijacks whatever <code>{ .. }</code> pair it's found in. Generally developers find <em>explicit</em> mechanisms a bit more preferable than <em>implicit</em> mechanisms, and I claim this is one of those cases.</p>

<p>If you compare the previous two snippet forms, they're very similar, and in my opinion both qualify stylistically as <em>explicit</em> block scoping. Unfortunately, the <code>let (..) { .. }</code> form, the most <em>explicit</em> of the options, was not adopted in ES6. That may be revisited post-ES6, but for now the former option is our best bet, I think.</p>

<p>To reinforce the <em>implicit</em> nature of <code>let ..</code> declarations, consider these usages:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">if</span> (a <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
    <span class="pl-k">let</span> b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b );       <span class="pl-c">// 6</span>

    <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> a; i <span class="pl-k">&lt;=</span> b; i<span class="pl-k">++</span>) {
        <span class="pl-k">let</span> j <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">10</span>;
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
    }
    <span class="pl-c">// 12 13 14 15 16</span>

    <span class="pl-k">let</span> c <span class="pl-k">=</span> a <span class="pl-k">+</span> b;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( c );       <span class="pl-c">// 8</span>
}</pre></div>

<p>Quick quiz without looking back at that snippet: which variable(s) exist only inside the <code>if</code> statement, and which variable(s) exist only inside the <code>for</code> loop?</p>

<p>The answers: the <code>if</code> statement contains <code>b</code> and <code>c</code> block-scoped variables, and the <code>for</code> loop contains <code>i</code> and <code>j</code> block-scoped variables.</p>

<p>Did you have to think about it for a moment? Does it surprise you that <code>i</code> isn't added to the enclosing <code>if</code> statement scope? That mental pause and questioning -- I call it a "mental tax" -- comes from the fact that this <code>let</code> mechanism is not only new to us, but it's also <em>implicit</em>.</p>

<p>There's also hazard in the <code>let c = ..</code> declaration appearing so far down in the scope. Unlike traditional <code>var</code>-declared variables, which are attached to the entire enclosing function scope regardless of where they appear, <code>let</code> declarations attach to the block scope but are not initialized until they appear in the block.</p>

<p>Accessing a <code>let</code>-declared variable earlier than its <code>let ..</code> declaration/initialization causes an error, whereas with <code>var</code> declarations the ordering doesn't matter (except stylistically).</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// undefined</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b );   <span class="pl-c">// ReferenceError!</span>

    <span class="pl-k">var</span> a;
    <span class="pl-k">let</span> b;
}</pre></div>

<p><strong>Warning:</strong> This <code>ReferenceError</code> from accessing too-early <code>let</code>-declared references is technically called a <em>Temporal Dead Zone (TDZ)</em> error -- you're accessing a variable that's been declared but not yet initialized. This will not be the only time we see TDZ errors -- they crop up in several places in ES6. Also, note that "initialized" doesn't require explicitly assigning a value in your code, as <code>let b;</code> is totally valid. A variable that's not given an assignment at declaration time is assumed to have been assigned the <code>undefined</code> value, so <code>let b;</code> is the same as <code>let b = undefined;</code>. Explicit assignment or not, you cannot access <code>b</code> until the <code>let b</code> statement is run.</p>

<p>One last gotcha: <code>typeof</code> behaves differently with TDZ variables than it does with undeclared (or declared!) variables. For example:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-c">// `a` is not declared</span>
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> a <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// `b` is declared, but in its TDZ</span>
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> b <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span>) {     <span class="pl-c">// ReferenceError!</span>
        <span class="pl-c">// ..</span>
    }

    <span class="pl-c">// ..</span>

    <span class="pl-k">let</span> b;
}</pre></div>

<p>The <code>a</code> is not declared, so <code>typeof</code> is the only safe way to check for its existence or not. But <code>typeof b</code> throws the TDZ error because farther down in the code there happens to be a <code>let b</code> declaration. Oops.</p>

<p>Now it should be clearer why I insist that <code>let</code> declarations should all be at the top of their scope. That totally avoids the accidental errors of accessing too early. It also makes it more <em>explicit</em> when you look at the start of a block, any block, what variables it contains.</p>

<p>Your blocks (<code>if</code> statements, <code>while</code> loops, etc.) don't have to share their original behavior with scoping behavior.</p>

<p>This explicitness on your part, which is up to you to maintain with discipline, will save you lots of refactor headaches and footguns down the line.</p>

<p><strong>Note:</strong> For more information on <code>let</code> and block scoping, see Chapter 3 of the <em>Scope &amp; Closures</em> title of this series.</p>

<h4><a id="user-content-let--for" class="anchor" href="#let--for" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code> + <code>for</code></h4>

<p>The only exception I'd make to the preference for the <em>explicit</em> form of <code>let</code> declaration blocking is a <code>let</code> that appears in the header of a <code>for</code> loop. The reason may seem nuanced, but I believe it to be one of the more important ES6 features.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> funcs <span class="pl-k">=</span> [];

<span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    funcs.<span class="pl-c1">push</span>( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    } );
}

funcs[<span class="pl-c1">3</span>]();     <span class="pl-c">// 3</span></pre></div>

<p>The <code>let i</code> in the <code>for</code> header declares an <code>i</code> not just for the <code>for</code> loop itself, but it redeclares a new <code>i</code> for each iteration of the loop. That means that closures created inside the loop iteration close over those per-iteration variables the way you'd expect.</p>

<p>If you tried that same snippet but with <code>var i</code> in the <code>for</code> loop header, you'd get <code>5</code> instead of <code>3</code>, because there'd only be one <code>i</code> in the outer scope that was closed over, instead of a new <code>i</code> for each iteration's function to close over.</p>

<p>You could also have accomplished the same thing slightly more verbosely:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> funcs <span class="pl-k">=</span> [];

<span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">let</span> j <span class="pl-k">=</span> i;
    funcs.<span class="pl-c1">push</span>( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
    } );
}

funcs[<span class="pl-c1">3</span>]();     <span class="pl-c">// 3</span></pre></div>

<p>Here, we forcibly create a new <code>j</code> for each iteration, and then the closure works the same way. I prefer the former approach; that extra special capability is why I endorse the <code>for (let .. ) ..</code> form. It could be argued it's somewhat more <em>implicit</em>, but it's <em>explicit</em> enough, and useful enough, for my tastes.</p>

<p><code>let</code> also works the same way with <code>for..in</code> and <code>for..of</code> loops (see "<code>for..of</code> Loops").</p>

<h3><a id="user-content-const-declarations" class="anchor" href="#const-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>const</code> Declarations</h3>

<p>There's one other form of block-scoped declaration to consider: the <code>const</code>, which creates <em>constants</em>.</p>

<p>What exactly is a constant? It's a variable that's read-only after its initial value is set. Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-k">const</span> <span class="pl-c1">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 2</span>

    a <span class="pl-k">=</span> <span class="pl-c1">3</span>;              <span class="pl-c">// TypeError!</span>
}</pre></div>

<p>You are not allowed to change the value the variable holds once it's been set, at declaration time. A <code>const</code> declaration must have an explicit initialization. If you wanted a <em>constant</em> with the <code>undefined</code> value, you'd have to declare <code>const a = undefined</code> to get it.</p>

<p>Constants are not a restriction on the value itself, but on the variable's assignment of that value. In other words, the value is not frozen or immutable because of <code>const</code>, just the assignment of it. If the value is complex, such as an object or array, the contents of the value can still be modified:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-k">const</span> <span class="pl-c1">a</span> <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
    a.<span class="pl-c1">push</span>( <span class="pl-c1">4</span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// [1,2,3,4]</span>

    a <span class="pl-k">=</span> <span class="pl-c1">42</span>;                 <span class="pl-c">// TypeError!</span>
}</pre></div>

<p>The <code>a</code> variable doesn't actually hold a constant array; rather, it holds a constant reference to the array. The array itself is freely mutable.</p>

<p><strong>Warning:</strong> Assigning an object or array as a constant means that value will not be able to be garbage collected until that constant's lexical scope goes away, as the reference to the value can never be unset. That may be desirable, but be careful if it's not your intent!</p>

<p>Essentially, <code>const</code> declarations enforce what we've stylistically signaled with our code for years, where we declared a variable name of all uppercase letters and assigned it some literal value that we took care never to change. There's no enforcement on a <code>var</code> assignment, but there is now with a <code>const</code> assignment, which can help you catch unintended changes.</p>

<p><code>const</code> <em>can</em> be used with variable declarations of <code>for</code>, <code>for..in</code>, and <code>for..of</code> loops (see "<code>for..of</code> Loops"). However, an error will be thrown if there's any attempt to reassign, such as the typical <code>i++</code> clause of a <code>for</code> loop.</p>

<h4><a id="user-content-const-or-not" class="anchor" href="#const-or-not" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>const</code> Or Not</h4>

<p>There's some rumored assumptions that a <code>const</code> could be more optimizable by the JS engine in certain scenarios than a <code>let</code> or <code>var</code> would be. Theoretically, the engine more easily knows the variable's value/type will never change, so it can eliminate some possible tracking.</p>

<p>Whether <code>const</code> really helps here or this is just our own fantasies and intuitions, the much more important decision to make is if you intend constant behavior or not. Remember: one of the most important roles for source code is to communicate clearly, not only to you, but your future self and other code collaborators, what your intent is.</p>

<p>Some developers prefer to start out every variable declaration as a <code>const</code> and then relax a declaration back to a <code>let</code> if it becomes necessary for its value to change in the code. This is an interesting perspective, but it's not clear that it genuinely improves the readability or reason-ability of code.</p>

<p>It's not really a <em>protection</em>, as many believe, because any later developer who wants to change a value of a <code>const</code> can just blindly change <code>const</code> to <code>let</code> on the declaration. At best, it protects accidental change. But again, other than our intuitions and sensibilities, there doesn't appear to be objective and clear measure of what constitutes "accidents" or prevention thereof. Similar mindsets exist around type enforcement.</p>

<p>My advice: to avoid potentially confusing code, only use <code>const</code> for variables that you're intentionally and obviously signaling will not change. In other words, don't <em>rely on</em> <code>const</code> for code behavior, but instead use it as a tool for signaling intent, when intent can be signaled clearly.</p>

<h3><a id="user-content-block-scoped-functions" class="anchor" href="#block-scoped-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block-scoped Functions</h3>

<p>Starting with ES6, function declarations that occur inside of blocks are now specified to be scoped to that block. Prior to ES6, the specification did not call for this, but many implementations did it anyway. So now the specification meets reality.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    foo();                  <span class="pl-c">// works!</span>

    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-c">// ..</span>
    }
}

foo();                      <span class="pl-c">// ReferenceError</span></pre></div>

<p>The <code>foo()</code> function is declared inside the <code>{ .. }</code> block, and as of ES6 is block-scoped there. So it's not available outside that block. But also note that it is "hoisted" within the block, as opposed to <code>let</code> declarations, which suffer the TDZ error trap mentioned earlier.</p>

<p>Block-scoping of function declarations could be a problem if you've ever written code like this before, and relied on the old legacy non-block-scoped behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (something) {
    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> );
    }
}
<span class="pl-k">else</span> {
    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span> );
    }
}

foo();      <span class="pl-c">// ??</span></pre></div>

<p>In pre-ES6 environments, <code>foo()</code> would print <code>"2"</code> regardless of the value of <code>something</code>, because both function declarations were hoisted out of the blocks, and the second one always wins.</p>

<p>In ES6, that last line throws a <code>ReferenceError</code>.</p>

<h2><a id="user-content-spreadrest" class="anchor" href="#spreadrest" aria-hidden="true"><span class="octicon octicon-link"></span></a>Spread/Rest</h2>

<p>ES6 introduces a new <code>...</code> operator that's typically referred to as the <em>spread</em> or <em>rest</em> operator, depending on where/how it's used. Let's take a look:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo( ...[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>] );              <span class="pl-c">// 1 2 3</span></pre></div>

<p>When <code>...</code> is used in front of an array (actually, any <em>iterable</em>, which we cover in Chapter 3), it acts to "spread" it out into its individual values.</p>

<p>You'll typically see that usage as is shown in that previous snippet, when spreading out an array as a set of arguments to a function call. In this usage, <code>...</code> acts to give us a simpler syntactic replacement for the <code>apply(..)</code> method, which we would typically have used pre-ES6 as:</p>

<div class="highlight highlight-source-js"><pre>foo.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>] );     <span class="pl-c">// 1 2 3</span></pre></div>

<p>But <code>...</code> can be used to spread out/expand a value in other contexts as well, such as inside another array declaration:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, ...a, <span class="pl-c1">5</span> ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );                   <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p>In this usage, <code>...</code> is basically replacing <code>concat(..)</code>, as it behaves like <code>[1].concat( a, [5] )</code> here.</p>

<p>The other common usage of <code>...</code> can be seen as essentially the opposite; instead of spreading a value out, the <code>...</code> <em>gathers</em> a set of values together into an array. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span> );           <span class="pl-c">// 1 2 [3,4,5]</span></pre></div>

<p>The <code>...z</code> in this snippet is essentially saying: "gather the <em>rest</em> of the arguments (if any) into an array called <code>z</code>." Because <code>x</code> was assigned <code>1</code>, and <code>y</code> was assigned <code>2</code>, the rest of the arguments <code>3</code>, <code>4</code>, and <code>5</code> were gathered into <code>z</code>.</p>

<p>Of course, if you don't have any named parameters, the <code>...</code> gathers all arguments:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( args );
}

foo( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>);            <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p><strong>Note:</strong> The <code>...args</code> in the <code>foo(..)</code> function declaration is usually called "rest parameters," because you're collecting the rest of the parameters. I prefer "gather," because it's more descriptive of what it does rather than what it contains.</p>

<p>The best part about this usage is that it provides a very solid alternative to using the long-since-deprecated <code>arguments</code> array -- actually, it's not really an array, but an array-like object. Because <code>args</code> (or whatever you call it -- a lot of people prefer <code>r</code> or <code>rest</code>) is a real array, we can get rid of lots of silly pre-ES6 tricks we jumped through to make <code>arguments</code> into something we can treat as an array.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// doing things the new ES6 way</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-c">// `args` is already a real array</span>

    <span class="pl-c">// discard first element in `args`</span>
    args.<span class="pl-c1">shift</span>();

    <span class="pl-c">// pass along all of `args` as arguments</span>
    <span class="pl-c">// to `console.log(..)`</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( ...args );
}

<span class="pl-c">// doing things the old-school pre-ES6 way</span>
<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// turn `arguments` into a real array</span>
    <span class="pl-k">var</span> args <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arguments );

    <span class="pl-c">// add some elements on the end</span>
    args.<span class="pl-c1">push</span>( <span class="pl-c1">4</span>, <span class="pl-c1">5</span> );

    <span class="pl-c">// filter out odd numbers</span>
    args <span class="pl-k">=</span> args.filter( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
        <span class="pl-k">return</span> v <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>;
    } );

    <span class="pl-c">// pass along all of `args` as arguments</span>
    <span class="pl-c">// to `foo(..)`</span>
    foo.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, args );
}

bar( <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );                  <span class="pl-c">// 2 4</span></pre></div>

<p>The <code>...args</code> in the <code>foo(..)</code> function declaration gathers arguments, and the <code>...args</code> in the <code>console.log(..)</code> call spreads them out. That's a good illustration of the symmetric but opposite uses of the <code>...</code> operator.</p>

<p>Besides the <code>...</code> usage in a function declaration, there's another case where <code>...</code> is used for gathering values, and we'll look at it in the "Too Many, Too Few, Just Enough" section later in this chapter.</p>

<h2><a id="user-content-default-parameter-values" class="anchor" href="#default-parameter-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Parameter Values</h2>

<p>Perhaps one of the most common idioms in JavaScript relates to setting a default value for a function parameter. The way we've done this for years should look quite familiar:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> x <span class="pl-k">||</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> y <span class="pl-k">||</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo();              <span class="pl-c">// 42</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );        <span class="pl-c">// 11</span>
foo( <span class="pl-c1">5</span> );           <span class="pl-c">// 36</span>
foo( <span class="pl-c1">null</span>, <span class="pl-c1">6</span> );     <span class="pl-c">// 17</span></pre></div>

<p>Of course, if you've used this pattern before, you know that it's both helpful and a little bit dangerous, if for example you need to be able to pass in what would otherwise be considered a falsy value for one of the parameters. Consider:</p>

<div class="highlight highlight-source-js"><pre>foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );       <span class="pl-c">// 53 &lt;-- Oops, not 42</span></pre></div>

<p>Why? Because the <code>0</code> is falsy, and so the <code>x || 11</code> results in <code>11</code>, not the directly passed in <code>0</code>.</p>

<p>To fix this gotcha, some people will instead write the check more verbosely like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> (x <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span> x <span class="pl-k">:</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> (y <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span> y <span class="pl-k">:</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );           <span class="pl-c">// 42</span>
foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">6</span> );    <span class="pl-c">// 17</span></pre></div>

<p>Of course, that means that any value except <code>undefined</code> can be directly passed in. However, <code>undefined</code> will be assumed to signal, "I didn't pass this in." That works great unless you actually need to be able to pass <code>undefined</code> in.</p>

<p>In that case, you could test to see if the argument is actually omitted, by it actually not being present in the <code>arguments</code> array, perhaps like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> (<span class="pl-c1">0</span> <span class="pl-k">in</span> arguments) <span class="pl-k">?</span> x <span class="pl-k">:</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">in</span> arguments) <span class="pl-k">?</span> y <span class="pl-k">:</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo( <span class="pl-c1">5</span> );               <span class="pl-c">// 36</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">undefined</span> );    <span class="pl-c">// NaN</span></pre></div>

<p>But how would you omit the first <code>x</code> argument without the ability to pass in any kind of value (not even <code>undefined</code>) that signals "I'm omitting this argument"?</p>

<p><code>foo(,5)</code> is tempting, but it's invalid syntax. <code>foo.apply(null,[,5])</code> seems like it should do the trick, but <code>apply(..)</code>'s quirks here mean that the arguments are treated as <code>[undefined,5]</code>, which of course doesn't omit.</p>

<p>If you investigate further, you'll find you can only omit arguments on the end (i.e., righthand side) by simply passing fewer arguments than "expected," but you cannot omit arguments in the middle or at the beginning of the arguments list. It's just not possible.</p>

<p>There's a principle applied to JavaScript's design here that is important to remember: <code>undefined</code> means <em>missing</em>. That is, there's no difference between <code>undefined</code> and <em>missing</em>, at least as far as function arguments go.</p>

<p><strong>Note:</strong> There are, confusingly, other places in JS where this particular design principle doesn't apply, such as for arrays with empty slots. See the <em>Types &amp; Grammar</em> title of this series for more information.</p>

<p>With all this in mind, we can now examine a nice helpful syntax added as of ES6 to streamline the assignment of default values to missing arguments:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">11</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-c1">31</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo();                  <span class="pl-c">// 42</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );            <span class="pl-c">// 11</span>
foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );           <span class="pl-c">// 42</span>

foo( <span class="pl-c1">5</span> );               <span class="pl-c">// 36</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">undefined</span> );    <span class="pl-c">// 36 &lt;-- `undefined` is missing</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">null</span> );         <span class="pl-c">// 5  &lt;-- null coerces to `0`</span>

foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">6</span> );    <span class="pl-c">// 17 &lt;-- `undefined` is missing</span>
foo( <span class="pl-c1">null</span>, <span class="pl-c1">6</span> );         <span class="pl-c">// 6  &lt;-- null coerces to `0`</span></pre></div>

<p>Notice the results and how they imply both subtle differences and similarities to the earlier approaches.</p>

<p><code>x = 11</code> in a function declaration is more like <code>x !== undefined ? x : 11</code> than the much more common idiom <code>x || 11</code>, so you'll need to be careful in converting your pre-ES6 code to this ES6 default parameter value syntax.</p>

<p><strong>Note:</strong> A rest/gather parameter (see "Spread/Rest") cannot have a default value. So, while <code>function foo(...vals=[1,2,3]) {</code> might seem an intriguing capability, it's not valid syntax. You'll need to continue to apply that sort of logic manually if necessary.</p>

<h3><a id="user-content-default-value-expressions" class="anchor" href="#default-value-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Value Expressions</h3>

<p>Function default values can be more than just simple values like <code>31</code>; they can be any valid expression, even a function call:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">val</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>bar called!<span class="pl-pds">"</span></span> );
    <span class="pl-k">return</span> y <span class="pl-k">+</span> val;
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-smi">y</span> + <span class="pl-c1">3</span>, <span class="pl-smi">z</span> <span class="pl-k">=</span> <span class="pl-smi">bar</span>( <span class="pl-smi">x</span> )) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, z );
}

<span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-c1">5</span>;
foo();                              <span class="pl-c">// "bar called"</span>
                                    <span class="pl-c">// 8 13</span>
foo( <span class="pl-c1">10</span> );                          <span class="pl-c">// "bar called"</span>
                                    <span class="pl-c">// 10 15</span>
y <span class="pl-k">=</span> <span class="pl-c1">6</span>;
foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">10</span> );               <span class="pl-c">// 9 10</span></pre></div>

<p>As you can see, the default value expressions are lazily evaluated, meaning they're only run if and when they're needed -- that is, when a parameter's argument is omitted or is <code>undefined</code>.</p>

<p>It's a subtle detail, but the formal parameters in a function declaration are in their own scope (think of it as a scope bubble wrapped around just the <code>( .. )</code> of the function declaration), not in the function body's scope. That means a reference to an identifier in a default value expression first matches the formal parameters' scope before looking to an outer scope. See the <em>Scope &amp; Closures</em> title of this series for more information.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> w <span class="pl-k">=</span> <span class="pl-c1">1</span>, z <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>( <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-smi">w</span> + <span class="pl-c1">1</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-smi">x</span> + <span class="pl-c1">1</span>, <span class="pl-smi">z</span> <span class="pl-k">=</span> <span class="pl-smi">z</span> + <span class="pl-c1">1</span> ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo();                  <span class="pl-c">// ReferenceError</span></pre></div>

<p>The <code>w</code> in the <code>w + 1</code> default value expression looks for <code>w</code> in the formal parameters' scope, but does not find it, so the outer scope's <code>w</code> is used. Next, The <code>x</code> in the <code>x + 1</code> default value expression finds <code>x</code> in the formal parameters' scope, and luckily <code>x</code> has already been initialized, so the assignment to <code>y</code> works fine.</p>

<p>However, the <code>z</code> in <code>z + 1</code> finds <code>z</code> as a not-yet-initialized-at-that-moment parameter variable, so it never tries to find the <code>z</code> from the outer scope.</p>

<p>As we mentioned in the "<code>let</code> Declarations" section earlier in this chapter, ES6 has a TDZ, which prevents a variable from being accessed in its uninitialized state. As such, the <code>z + 1</code> default value expression throws a TDZ <code>ReferenceError</code> error.</p>

<p>Though it's not necessarily a good idea for code clarity, a default value expression can even be an inline function expression call -- commonly referred to as an immediately invoked function expression (IIFE):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( <span class="pl-smi">x</span> <span class="pl-k">=</span>
    (<span class="pl-smi">function</span>(<span class="pl-smi">v</span>){ <span class="pl-k">return</span> v <span class="pl-k">+</span> <span class="pl-c1">11</span>; })( <span class="pl-c1">31</span> )
) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}

foo();          <span class="pl-c">// 42</span></pre></div>

<p>There will very rarely be any cases where an IIFE (or any other executed inline function expression) will be appropriate for default value expressions. If you find yourself tempted to do this, take a step back and reevaluate!</p>

<p><strong>Warning:</strong> If the IIFE had tried to access the <code>x</code> identifier and had not declared its own <code>x</code>, this would also have been a TDZ error, just as discussed before.</p>

<p>The default value expression in the previous snippet is an IIFE in that in the sense that it's a function that's executed right inline, via <code>(31)</code>. If we had left that part off, the default value assigned to <code>x</code> would have just been a function reference itself, perhaps like a default callback. There will probably be cases where that pattern will be quite useful, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>, <span class="pl-smi">cb</span> <span class="pl-k">=</span> <span class="pl-smi">function</span>(){}) {
    <span class="pl-c">// ..</span>
}

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );</pre></div>

<p>In this case, we essentially want to default <code>cb</code> to be a no-op empty function call if not otherwise specified. The function expression is just a function reference, not a function call itself (no invoking <code>()</code> on the end of it), which accomplishes that goal.</p>

<p>Since the early days of JS, there's been a little-known but useful quirk available to us: <code>Function.prototype</code> is itself an empty no-op function. So, the declaration could have been <code>cb = Function.prototype</code> and saved the inline function expression creation.</p>

<h2><a id="user-content-destructuring" class="anchor" href="#destructuring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring</h2>

<p>ES6 introduces a new syntactic feature called <em>destructuring</em>, which may be a little less confusing if you instead think of it as <em>structured assignment</em>. To understand this meaning, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">return</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
}

<span class="pl-k">var</span> tmp <span class="pl-k">=</span> foo(),
    a <span class="pl-k">=</span> tmp[<span class="pl-c1">0</span>], b <span class="pl-k">=</span> tmp[<span class="pl-c1">1</span>], c <span class="pl-k">=</span> tmp[<span class="pl-c1">2</span>];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span></pre></div>

<p>As you can see, we created a manual assignment of the values in the array that <code>foo()</code> returns to individual variables <code>a</code>, <code>b</code>, and <code>c</code>, and to do so we (unfortunately) needed the <code>tmp</code> variable.</p>

<p>Similarly, we can do the following with objects:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">return</span> {
        x<span class="pl-k">:</span> <span class="pl-c1">4</span>,
        y<span class="pl-k">:</span> <span class="pl-c1">5</span>,
        z<span class="pl-k">:</span> <span class="pl-c1">6</span>
    };
}

<span class="pl-k">var</span> tmp <span class="pl-k">=</span> bar(),
    x <span class="pl-k">=</span> tmp.<span class="pl-c1">x</span>, y <span class="pl-k">=</span> tmp.<span class="pl-c1">y</span>, z <span class="pl-k">=</span> tmp.<span class="pl-c1">z</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>The <code>tmp.x</code> property value is assigned to the <code>x</code> variable, and likewise for <code>tmp.y</code> to <code>y</code> and <code>tmp.z</code> to <code>z</code>.</p>

<p>Manually assigning indexed values from an array or properties from an object can be thought of as <em>structured assignment</em>. ES6 adds a dedicated syntax for <em>destructuring</em>, specifically <em>array destructuring</em> and <em>object destructuring</em>. This syntax eliminates the need for the <code>tmp</code> variable in the previous snippets, making them much cleaner. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [ a, b, c ] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x<span class="pl-k">:</span> x, y<span class="pl-k">:</span> y, z<span class="pl-k">:</span> z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>You're likely more accustomed to seeing syntax like <code>[a,b,c]</code> on the righthand side of an <code>=</code> assignment, as the value being assigned.</p>

<p>Destructuring symmetrically flips that pattern, so that <code>[a,b,c]</code> on the lefthand side of the <code>=</code> assignment is treated as a kind of "pattern" for decomposing the righthand side array value into separate variable assignments.</p>

<p>Similarly, <code>{ x: x, y: y, z: z }</code> specifies a "pattern" to decompose the object value from <code>bar()</code> into separate variable assignments.</p>

<h3><a id="user-content-object-property-assignment-pattern" class="anchor" href="#object-property-assignment-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Property Assignment Pattern</h3>

<p>Let's dig into that <code>{ x: x, .. }</code> syntax from the previous snippet. If the property name being matched is the same as the variable you want to declare, you can actually shorten the syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x, y, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>Pretty cool, right?</p>

<p>But is <code>{ x, .. }</code> leaving off the <code>x:</code> part or leaving off the <code>: x</code> part? We're actually leaving off the <code>x:</code> part when we use the shorter syntax. That may not seem like an important detail, but you'll understand its importance in just a moment.</p>

<p>If you can write the shorter form, why would you ever write out the longer form? Because that longer form actually allows you to assign a property to a different variable name, which can sometimes be quite useful:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x<span class="pl-k">:</span> bam, y<span class="pl-k">:</span> baz, z<span class="pl-k">:</span> bap } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( bam, baz, bap );       <span class="pl-c">// 4 5 6</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// ReferenceError</span></pre></div>

<p>There's a subtle but super-important quirk to understand about this variation of the object destructuring form. To illustrate why it can be a gotcha you need to be careful of, let's consider the "pattern" of how normal object literals are specified:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> X <span class="pl-k">=</span> <span class="pl-c1">10</span>, Y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span> X, b<span class="pl-k">:</span> Y };

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a, o.b );            <span class="pl-c">// 10 20</span></pre></div>

<p>In <code>{ a: X, b: Y }</code>, we know that <code>a</code> is the object property, and <code>X</code> is the source value that gets assigned to it. In other words, the syntactic pattern is <code>target: source</code>, or more obviously, <code>property-alias: value</code>. We intuitively understand this because it's the same as <code>=</code> assignment, where the pattern is <code>target = source</code>.</p>

<p>However, when you use object destructuring assignment -- that is, putting the <code>{ .. }</code> object literal-looking syntax on the lefthand side of the <code>=</code> operator -- you invert that <code>target: source</code> pattern.</p>

<p>Recall:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x<span class="pl-k">:</span> bam, y<span class="pl-k">:</span> baz, z<span class="pl-k">:</span> bap } <span class="pl-k">=</span> bar();</pre></div>

<p>The syntactic pattern here is <code>source: target</code> (or <code>value: variable-alias</code>). <code>x: bam</code> means the <code>x</code> property is the source value and <code>bam</code> is the target variable to assign to. In other words, object literals are <code>target &lt;-- source</code>, and object destructuring assignments are <code>source --&gt; target</code>. See how that's flipped?</p>

<p>There's another way to think about this syntax though, which may help ease the confusion. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> aa <span class="pl-k">=</span> <span class="pl-c1">10</span>, bb <span class="pl-k">=</span> <span class="pl-c1">20</span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> { x<span class="pl-k">:</span> aa, y<span class="pl-k">:</span> bb };
<span class="pl-k">var</span>     { x<span class="pl-k">:</span> <span class="pl-c1">AA</span>, y<span class="pl-k">:</span> <span class="pl-c1">BB</span> } <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">AA</span>, <span class="pl-c1">BB</span> );              <span class="pl-c">// 10 20</span></pre></div>

<p>In the <code>{ x: aa, y: bb }</code> line, the <code>x</code> and <code>y</code> represent the object properties. In the <code>{ x: AA, y: BB }</code> line, the <code>x</code> and the <code>y</code> <em>also</em> represent the object properties.</p>

<p>Recall how earlier I asserted that <code>{ x, .. }</code> was leaving off the <code>x:</code> part? In those two lines, if you erase the <code>x:</code> and <code>y:</code> parts in that snippet, you're left only with <code>aa, bb</code> and <code>AA, BB</code>, which in effect -- only conceptually, not actually -- are assignments from <code>aa</code> to <code>AA</code> and from <code>bb</code> to <code>BB</code>.</p>

<p>So, that symmetry may help to explain why the syntactic pattern was intentionally flipped for this ES6 feature.</p>

<p><strong>Note:</strong> I would have preferred the syntax to be <code>{ AA: x , BB: y }</code> for the destructuring assignment, as that would have preserved consistency of the more familiar <code>target: source</code> pattern for both usages. Alas, I'm having to train my brain for the inversion, as some readers may also have to do.</p>

<h3><a id="user-content-not-just-declarations" class="anchor" href="#not-just-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not Just Declarations</h3>

<p>So far, we've used destructuring assignment with <code>var</code> declarations (of course, they could also use <code>let</code> and <code>const</code>), but destructuring is a general assignment operation, not just a declaration.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a, b, c, x, y, z;

[a,b,c] <span class="pl-k">=</span> foo();
( { x, y, z } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>The variables can already be declared, and then the destructuring only does assignments, exactly as we've already seen.</p>

<p><strong>Note:</strong> For the object destructuring form specifically, when leaving off a <code>var</code>/<code>let</code>/<code>const</code> declarator, we had to surround the whole assignment expression in <code>( )</code>, because otherwise the <code>{ .. }</code> on the lefthand side as the first element in the statement is taken to be a block statement instead of an object.</p>

<p>In fact, the assignment expressions (<code>a</code>, <code>y</code>, etc.) don't actually need to be just variable identifiers. Anything that's a valid assignment expression is allowed. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

[o.a, o.b, o.c] <span class="pl-k">=</span> foo();
( { x<span class="pl-k">:</span> o.<span class="pl-c1">x</span>, y<span class="pl-k">:</span> o.<span class="pl-c1">y</span>, z<span class="pl-k">:</span> o.<span class="pl-c1">z</span> } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a, o.b, o.c );       <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.<span class="pl-c1">x</span>, o.<span class="pl-c1">y</span>, o.<span class="pl-c1">z</span> );       <span class="pl-c">// 4 5 6</span></pre></div>

<p>You can even use computed property expressions in the destructuring. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> which <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>,
    o <span class="pl-k">=</span> {};

( { [which]<span class="pl-k">:</span> o[which] } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.<span class="pl-c1">x</span> );                 <span class="pl-c">// 4</span></pre></div>

<p>The <code>[which]:</code> part is the computed property, which results in <code>x</code> -- the property to destructure from the object in question as the source of the assignment. The <code>o[which]</code> part is just a normal object key reference, which equates to <code>o.x</code> as the target of the assignment.</p>

<p>You can use the general assignments to create object mappings/transformations, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    o2 <span class="pl-k">=</span> {};

( { a<span class="pl-k">:</span> o2.<span class="pl-c1">x</span>, b<span class="pl-k">:</span> o2.<span class="pl-c1">y</span>, c<span class="pl-k">:</span> o2.<span class="pl-c1">z</span> } <span class="pl-k">=</span> o1 );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o2.<span class="pl-c1">x</span>, o2.<span class="pl-c1">y</span>, o2.<span class="pl-c1">z</span> );    <span class="pl-c">// 1 2 3</span></pre></div>

<p>Or you can map an object to an array, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    a2 <span class="pl-k">=</span> [];

( { a<span class="pl-k">:</span> a2[<span class="pl-c1">0</span>], b<span class="pl-k">:</span> a2[<span class="pl-c1">1</span>], c<span class="pl-k">:</span> a2[<span class="pl-c1">2</span>] } <span class="pl-k">=</span> o1 );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a2 );                  <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Or the other way around:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ],
    o2 <span class="pl-k">=</span> {};

[ o2.a, o2.b, o2.c ] <span class="pl-k">=</span> a1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o2.a, o2.b, o2.c );    <span class="pl-c">// 1 2 3</span></pre></div>

<p>Or you could reorder one array to another:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ],
    a2 <span class="pl-k">=</span> [];

[ a2[<span class="pl-c1">2</span>], a2[<span class="pl-c1">0</span>], a2[<span class="pl-c1">1</span>] ] <span class="pl-k">=</span> a1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a2 );                  <span class="pl-c">// [2,3,1]</span></pre></div>

<p>You can even solve the traditional "swap two variables" task without a temporary variable:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">10</span>, y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

[ y, x ] <span class="pl-k">=</span> [ x, y ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );                <span class="pl-c">// 20 10</span></pre></div>

<p><strong>Warning:</strong> Be careful: you shouldn't mix in declaration with assignment unless you want all of the assignment expressions <em>also</em> to be treated as declarations. Otherwise, you'll get syntax errors. That's why in the earlier example I had to do <code>var a2 = []</code> separately from the <code>[ a2[0], .. ] = ..</code> destructuring assignment. It wouldn't make any sense to try <code>var [ a2[0], .. ] = ..</code>, because <code>a2[0]</code> isn't a valid declaration identifier; it also obviously couldn't implicitly create a <code>var a2 = []</code> declaration to use.</p>

<h3><a id="user-content-repeated-assignments" class="anchor" href="#repeated-assignments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Repeated Assignments</h3>

<p>The object destructuring form allows a source property (holding any value type) to be listed multiple times. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { a<span class="pl-k">:</span> X, a<span class="pl-k">:</span> Y } <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> };

X;  <span class="pl-c">// 1</span>
Y;  <span class="pl-c">// 1</span></pre></div>

<p>That also means you can both destructure a sub-object/array property and also capture the sub-object/array's value itself. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { a<span class="pl-k">:</span> { x<span class="pl-k">:</span> X, x<span class="pl-k">:</span> Y }, a } <span class="pl-k">=</span> { a<span class="pl-k">:</span> { x<span class="pl-k">:</span> <span class="pl-c1">1</span> } };

X;  <span class="pl-c">// 1</span>
Y;  <span class="pl-c">// 1</span>
a;  <span class="pl-c">// { x: 1 }</span>

( { a<span class="pl-k">:</span> X, a<span class="pl-k">:</span> Y, a<span class="pl-k">:</span> [ Z ] } <span class="pl-k">=</span> { a<span class="pl-k">:</span> [ <span class="pl-c1">1</span> ] } );

X.<span class="pl-c1">push</span>( <span class="pl-c1">2</span> );
Y[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;

X;  <span class="pl-c">// [10,2]</span>
Y;  <span class="pl-c">// [10,2]</span>
Z;  <span class="pl-c">// 1</span></pre></div>

<p>A word of caution about destructuring: it may be tempting to list destructuring assignments all on a single line as has been done thus far in our discussion. However, it's a much better idea to spread destructuring assignment patterns over multiple lines, using proper indentation -- much like you would in JSON or with an object literal value -- for readability sake.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// harder to read:</span>
<span class="pl-k">var</span> { a<span class="pl-k">:</span> { b<span class="pl-k">:</span> [ c, d ], e<span class="pl-k">:</span> { f } }, g } <span class="pl-k">=</span> obj;

<span class="pl-c">// better:</span>
<span class="pl-k">var</span> {
    a<span class="pl-k">:</span> {
        b<span class="pl-k">:</span> [ c, d ],
        e<span class="pl-k">:</span> { f }
    },
    g
} <span class="pl-k">=</span> obj;</pre></div>

<p>Remember: <strong>the purpose of destructuring is not just less typing, but more declarative readability.</strong></p>

<h4><a id="user-content-destructuring-assignment-expressions" class="anchor" href="#destructuring-assignment-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Assignment Expressions</h4>

<p>The assignment expression with object or array destructuring has as its completion value the full righthand object/array value. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    a, b, c, p;

p <span class="pl-k">=</span> { a, b, c } <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
p <span class="pl-k">===</span> o;                        <span class="pl-c">// true</span></pre></div>

<p>In the previous snippet, <code>p</code> was assigned the <code>o</code> object reference, not one of the <code>a</code>, <code>b</code>, or <code>c</code> values. The same is true of array destructuring:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>],
    a, b, c, p;

p <span class="pl-k">=</span> [ a, b, c ] <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
p <span class="pl-k">===</span> o;                        <span class="pl-c">// true</span></pre></div>

<p>By carrying the object/array value through as the completion, you can chain destructuring assignment expressions together:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    p <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>],
    a, b, c, x, y, z;

( {a} <span class="pl-k">=</span> {b,c} <span class="pl-k">=</span> o );
[x,y] <span class="pl-k">=</span> [z] <span class="pl-k">=</span> p;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );         <span class="pl-c">// 4 5 4</span></pre></div>

<h3><a id="user-content-too-many-too-few-just-enough" class="anchor" href="#too-many-too-few-just-enough" aria-hidden="true"><span class="octicon octicon-link"></span></a>Too Many, Too Few, Just Enough</h3>

<p>With both array destructuring assignment and object destructuring assignment, you do not have to assign all the values that are present. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [,b] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, x, z );             <span class="pl-c">// 2 4 6</span></pre></div>

<p>The <code>1</code> and <code>3</code> values that came back from <code>foo()</code> are discarded, as is the <code>5</code> value from <code>bar()</code>.</p>

<p>Similarly, if you try to assign more values than are present in the value you're destructuring/decomposing, you get graceful fallback to <code>undefined</code>, as you'd expect:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [,,c,d] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { w, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( c, z );                <span class="pl-c">// 3 6</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( d, w );                <span class="pl-c">// undefined undefined</span></pre></div>

<p>This behavior follows symmetrically from the earlier stated "<code>undefined</code> is missing" principle.</p>

<p>We examined the <code>...</code> operator earlier in this chapter, and saw that it can sometimes be used to spread an array value out into its separate values, and sometimes it can be used to do the opposite: to gather a set of values together into an array.</p>

<p>In addition to the gather/rest usage in function declarations, <code>...</code> can perform the same behavior in destructuring assignments. To illustrate, let's recall a snippet from earlier in this chapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, ...a, <span class="pl-c1">5</span> ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );                   <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p>Here we see that <code>...a</code> is spreading <code>a</code> out, because it appears in the array <code>[ .. ]</code> value position. If <code>...a</code> appears in an array destructuring position, it performs the gather behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> [ b, ...c ] <span class="pl-k">=</span> a;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, c );                <span class="pl-c">// 2 [3,4]</span></pre></div>

<p>The <code>var [ .. ] = a</code> destructuring assignment spreads <code>a</code> out to be assigned to the pattern described inside the <code>[ .. ]</code>. The first part names <code>b</code> for the first value in <code>a</code> (<code>2</code>). But then <code>...c</code> gathers the rest of the values (<code>3</code> and <code>4</code>) into an array and calls it <code>c</code>.</p>

<p><strong>Note:</strong> We've seen how <code>...</code> works with arrays, but what about with objects? It's not an ES6 feature, but see Chapter 8 for discussion of a possible "beyond ES6" feature where <code>...</code> works with spreading or gathering objects.</p>

<h3><a id="user-content-default-value-assignment" class="anchor" href="#default-value-assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Value Assignment</h3>

<p>Both forms of destructuring can offer a default value option for an assignment, using the <code>=</code> syntax similar to the default function argument values discussed earlier.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [ a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-c1">6</span>, c <span class="pl-k">=</span> <span class="pl-c1">9</span>, d <span class="pl-k">=</span> <span class="pl-c1">12</span> ] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x <span class="pl-k">=</span> <span class="pl-c1">5</span>, y <span class="pl-k">=</span> <span class="pl-c1">10</span>, z <span class="pl-k">=</span> <span class="pl-c1">15</span>, w <span class="pl-k">=</span> <span class="pl-c1">20</span> } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c, d );          <span class="pl-c">// 1 2 3 12</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, w );          <span class="pl-c">// 4 5 6 20</span></pre></div>

<p>You can combine the default value assignment with the alternative assignment expression syntax covered earlier. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x, y, z, w<span class="pl-k">:</span> <span class="pl-c1">WW</span> <span class="pl-k">=</span> <span class="pl-c1">20</span> } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, <span class="pl-c1">WW</span> );         <span class="pl-c">// 4 5 6 20</span></pre></div>

<p>Be careful about confusing yourself (or other developers who read your code) if you use an object or array as the default value in a destructuring. You can create some really hard to understand code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">200</span>, y <span class="pl-k">=</span> <span class="pl-c1">300</span>, z <span class="pl-k">=</span> <span class="pl-c1">100</span>;
<span class="pl-k">var</span> o1 <span class="pl-k">=</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> <span class="pl-c1">42</span> }, z<span class="pl-k">:</span> { y<span class="pl-k">:</span> z } };

( { y<span class="pl-k">:</span> x <span class="pl-k">=</span> { y<span class="pl-k">:</span> y } } <span class="pl-k">=</span> o1 );
( { z<span class="pl-k">:</span> y <span class="pl-k">=</span> { y<span class="pl-k">:</span> z } } <span class="pl-k">=</span> o1 );
( { x<span class="pl-k">:</span> z <span class="pl-k">=</span> { y<span class="pl-k">:</span> x } } <span class="pl-k">=</span> o1 );</pre></div>

<p>Can you tell from that snippet what values <code>x</code>, <code>y</code>, and <code>z</code> have at the end? Takes a moment of pondering, I would imagine. I'll end the suspense:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( x.<span class="pl-c1">y</span>, y.<span class="pl-c1">y</span>, z.<span class="pl-c1">y</span> );       <span class="pl-c">// 300 100 42</span></pre></div>

<p>The takeaway here: destructuring is great and can be very useful, but it's also a sharp sword that can cause injury (to someone's brain) if used unwisely.</p>

<h3><a id="user-content-nested-destructuring" class="anchor" href="#nested-destructuring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Destructuring</h3>

<p>If the values you're destructuring have nested objects or arrays, you can destructure those nested values as well:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">5</span> ];
<span class="pl-k">var</span> o1 <span class="pl-k">=</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> { z<span class="pl-k">:</span> <span class="pl-c1">6</span> } } };

<span class="pl-k">var</span> [ a, [ b, c, d ], e ] <span class="pl-k">=</span> a1;
<span class="pl-k">var</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> { z<span class="pl-k">:</span> w } } } <span class="pl-k">=</span> o1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c, d, e );       <span class="pl-c">// 1 2 3 4 5</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( w );                   <span class="pl-c">// 6</span></pre></div>

<p>Nested destructuring can be a simple way to flatten out object namespaces. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> App <span class="pl-k">=</span> {
    model<span class="pl-k">:</span> {
        <span class="pl-en">User</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){ .. }
    }
};

<span class="pl-c">// instead of:</span>
<span class="pl-c">// var User = App.model.User;</span>

<span class="pl-k">var</span> { model<span class="pl-k">:</span> { User } } <span class="pl-k">=</span> App;</pre></div>

<h3><a id="user-content-destructuring-parameters" class="anchor" href="#destructuring-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Parameters</h3>

<p>In the following snippet, can you spot the assignment?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}

foo( <span class="pl-c1">42</span> );</pre></div>

<p>The assignment is kinda hidden: <code>42</code> (the argument) is assigned to <code>x</code> (the parameter) when <code>foo(42)</code> is executed. If parameter/argument pairing is an assignment, then it stands to reason that it's an assignment that could be destructured, right? Of course!</p>

<p>Consider array destructuring for parameters:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( [ <span class="pl-smi">x</span>, <span class="pl-smi">y</span> ] ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

foo( [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ] );                    <span class="pl-c">// 1 2</span>
foo( [ <span class="pl-c1">1</span> ] );                       <span class="pl-c">// 1 undefined</span>
foo( [] );                          <span class="pl-c">// undefined undefined</span></pre></div>

<p>Object destructuring for parameters works, too:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( { <span class="pl-smi">x</span>, <span class="pl-smi">y</span> } ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

foo( { y<span class="pl-k">:</span> <span class="pl-c1">1</span>, x<span class="pl-k">:</span> <span class="pl-c1">2</span> } );              <span class="pl-c">// 2 1</span>
foo( { y<span class="pl-k">:</span> <span class="pl-c1">42</span> } );                   <span class="pl-c">// undefined 42</span>
foo( {} );                          <span class="pl-c">// undefined undefined</span></pre></div>

<p>This technique is an approximation of named arguments (a long requested feature for JS!), in that the properties on the object map to the destructured parameters of the same names. That also means that we get optional parameters (in any position) for free, as you can see leaving off the <code>x</code> "parameter" worked as we'd expect.</p>

<p>Of course, all the previously discussed variations of destructuring are available to us with parameter destructuring, including nested destructuring, default values, and more. Destructuring also mixes fine with other ES6 function parameter capabilities, like default parameter values and rest/gather parameters.</p>

<p>Consider these quick illustrations (certainly not exhaustive of the possible variations):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f1</span>([ <span class="pl-smi">x</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-smi">y</span><span class="pl-k">=</span><span class="pl-c1">3</span>, <span class="pl-smi">z</span> ]) { .. }
<span class="pl-k">function</span> <span class="pl-en">f2</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], <span class="pl-smi">w</span>) { .. }
<span class="pl-k">function</span> <span class="pl-en">f3</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], ...<span class="pl-smi">w</span>) { .. }

<span class="pl-k">function</span> <span class="pl-en">f4</span>({ <span class="pl-smi">x</span>: <span class="pl-smi">X</span>, <span class="pl-smi">y</span> }) { .. }
<span class="pl-k">function</span> <span class="pl-en">f5</span>({ <span class="pl-smi">x</span>: <span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-c1">20</span> }) { .. }
<span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) { .. }</pre></div>

<p>Let's take one example from this snippet and examine it, for illustration purposes:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f3</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], ...<span class="pl-smi">w</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, w );
}

f3( [] );                           <span class="pl-c">// undefined undefined [] []</span>
f3( [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>], <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );              <span class="pl-c">// 1 2 [3,4] [5,6]</span></pre></div>

<p>There are two <code>...</code> operators in use here, and they're both gathering values in arrays (<code>z</code> and <code>w</code>), though <code>...z</code> gathers from the rest of the values left over in the first array argument, while <code>...w</code> gathers from the rest of the main arguments left over after the first.</p>

<h4><a id="user-content-destructuring-defaults--parameter-defaults" class="anchor" href="#destructuring-defaults--parameter-defaults" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Defaults + Parameter Defaults</h4>

<p>There's one subtle point you should be particularly careful to notice -- the difference in behavior between a destructuring default value and a function parameter default value. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

f6();                               <span class="pl-c">// 10 10</span></pre></div>

<p>At first, it would seem that we've declared a default value of <code>10</code> for both the <code>x</code> and <code>y</code> parameters, but in two different ways. However, these two different approaches will behave differently in certain cases, and the difference is awfully subtle.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>f6( {}, {} );                       <span class="pl-c">// 10 undefined</span></pre></div>

<p>Wait, why did that happen? It's pretty clear that named parameter <code>x</code> is defaulting to <code>10</code> if not passed as a property of that same name in the first argument's object.</p>

<p>But what about <code>y</code> being <code>undefined</code>? The <code>{ y: 10 }</code> value is an object as a function parameter default value, not a destructuring default value. As such, it only applies if the second argument is not passed at all, or is passed as <code>undefined</code>.</p>

<p>In the previous snippet, we <em>are</em> passing a second argument (<code>{}</code>), so the default <code>{ y: 10 }</code> value is not used, and the <code>{ y }</code> destructuring occurs against the passed in <code>{}</code> empty object value.</p>

<p>Now, compare <code>{ y } = { y: 10 }</code> to <code>{ x = 10 } = {}</code>.</p>

<p>For the <code>x</code>'s form usage, if the first function argument is omitted or <code>undefined</code>, the <code>{}</code> empty object default applies. Then, whatever value is in the first argument position -- either the default <code>{}</code> or whatever you passed in -- is destructured with the <code>{ x = 10 }</code>, which checks to see if an <code>x</code> property is found, and if not found (or <code>undefined</code>), the <code>10</code> default value is applied to the <code>x</code> named parameter.</p>

<p>Deep breath. Read back over those last few paragraphs a couple of times. Let's review via code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

f6();                               <span class="pl-c">// 10 10</span>
f6( <span class="pl-c1">undefined</span>, <span class="pl-c1">undefined</span> );         <span class="pl-c">// 10 10</span>
f6( {}, <span class="pl-c1">undefined</span> );                <span class="pl-c">// 10 10</span>

f6( {}, {} );                       <span class="pl-c">// 10 undefined</span>
f6( <span class="pl-c1">undefined</span>, {} );                <span class="pl-c">// 10 undefined</span>

f6( { x<span class="pl-k">:</span> <span class="pl-c1">2</span> }, { y<span class="pl-k">:</span> <span class="pl-c1">3</span> } );           <span class="pl-c">// 2 3</span></pre></div>

<p>It would generally seem that the defaulting behavior of the <code>x</code> parameter is probably the more desirable and sensible case compared to that of <code>y</code>. As such, it's important to understand why and how <code>{ x = 10 } = {}</code> form is different from <code>{ y } = { y: 10 }</code> form.</p>

<p>If that's still a bit fuzzy, go back and read it again, and play with this yourself. Your future self will thank you for taking the time to get this very subtle gotcha nuance detail straight.</p>

<h4><a id="user-content-nested-defaults-destructured-and-restructured" class="anchor" href="#nested-defaults-destructured-and-restructured" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Defaults: Destructured and Restructured</h4>

<p>Although it may at first be difficult to grasp, an interesting idiom emerges for setting defaults for a nested object's properties: using object destructuring along with what I'd call <em>restructuring</em>.</p>

<p>Consider a set of defaults in a nested object structure, like the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// taken from: http://es-discourse.com/t/partial-default-arguments/120/7</span>

<span class="pl-k">var</span> defaults <span class="pl-k">=</span> {
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        enable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        instance<span class="pl-k">:</span> {}
    },
    log<span class="pl-k">:</span> {
        warn<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        error<span class="pl-k">:</span> <span class="pl-c1">true</span>
    }
};</pre></div>

<p>Now, let's say that you have an object called <code>config</code>, which has some of these applied, but perhaps not all, and you'd like to set all the defaults into this object in the missing spots, but not override specific settings already present:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> config <span class="pl-k">=</span> {
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        instance<span class="pl-k">:</span> <span class="pl-c1">null</span>
    }
};</pre></div>

<p>You can of course do so manually, as you might have done in the past:</p>

<div class="highlight highlight-source-js"><pre>config.<span class="pl-c1">options</span> <span class="pl-k">=</span> config.<span class="pl-c1">options</span> <span class="pl-k">||</span> {};
config.<span class="pl-c1">options</span>.remove <span class="pl-k">=</span> (config.<span class="pl-c1">options</span>.remove <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span>
    config.<span class="pl-c1">options</span>.remove <span class="pl-k">:</span> defaults.<span class="pl-c1">options</span>.remove;
config.<span class="pl-c1">options</span>.enable <span class="pl-k">=</span> (config.<span class="pl-c1">options</span>.enable <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span>
    config.<span class="pl-c1">options</span>.enable <span class="pl-k">:</span> defaults.<span class="pl-c1">options</span>.enable;
...</pre></div>

<p>Yuck.</p>

<p>Others may prefer the assign-overwrite approach to this task. You might be tempted by the ES6 <code>Object.assign(..)</code> utility (see Chapter 6) to clone the properties first from <code>defaults</code> and then overwritten with the cloned properties from <code>config</code>, as so:</p>

<div class="highlight highlight-source-js"><pre>config <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign( {}, defaults, config );</pre></div>

<p>That looks way nicer, huh? But there's a major problem! <code>Object.assign(..)</code> is shallow, which means when it copies <code>defaults.options</code>, it just copies that object reference, not deep cloning that object's properties to a <code>config.options</code> object. <code>Object.assign(..)</code> would need to be applied (sort of "recursively") at all levels of your object's tree to get the deep cloning you're expecting.</p>

<p><strong>Note:</strong> Many JS utility libraries/frameworks provide their own option for deep cloning of an object, but those approaches and their gotchas are beyond our scope to discuss here.</p>

<p>So let's examine if ES6 object destructuring with defaults can help at all:</p>

<div class="highlight highlight-source-js"><pre>config.<span class="pl-c1">options</span> <span class="pl-k">=</span> config.<span class="pl-c1">options</span> <span class="pl-k">||</span> {};
config<span class="pl-c1">.log</span> <span class="pl-k">=</span> config<span class="pl-c1">.log</span> <span class="pl-k">||</span> {};
{
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.remove <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.remove,
        enable<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.enable <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.enable,
        instance<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.instance <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.instance
    } <span class="pl-k">=</span> {},
    log<span class="pl-k">:</span> {
        warn<span class="pl-k">:</span> config<span class="pl-c1">.log.warn</span> <span class="pl-k">=</span> <span class="pl-k">default</span><span class="pl-c1">.log.warn</span>,
        error<span class="pl-k">:</span> config<span class="pl-c1">.log.error</span> <span class="pl-k">=</span> <span class="pl-k">default</span><span class="pl-c1">.log.error</span>
    } <span class="pl-k">=</span> {}
} <span class="pl-k">=</span> config;</pre></div>

<p>Not as nice as the false promise of <code>Object.assign(..)</code> (being that it's shallow only), but it's better than the manual approach by a fair bit, I think. It is still unfortunately verbose and repetitive, though.</p>

<p>The previous snippet's approach works because I'm hacking the destructuring and defaults mechansim to do the property <code>=== undefined</code> checks and assignment decisions for me. It's a trick in that I'm destructuring <code>config</code> (see the <code>= config</code> at the end of the snippet), but I'm reassigning all the destructured values right back into <code>config</code>, with the <code>config.options.enable</code> assignment references.</p>

<p>Still too much, though. Let's see if we can make anything better.</p>

<p>The following trick works best if you know that all the various properties you're destructuring are uniquely named. You can still do it even if that's not the case, but it's not as nice -- you'll have to do the destructuring in stages, or create unique local variables as temporary aliases.</p>

<p>If we fully destructure all the properties into top-level variables, we can then immediately restructure to reconstitute the original nested object structure.</p>

<p>But all those temporary variables hanging around would pollute scope. So, let's use block scoping (see "Block-Scoped Declarations" earlier in this chapter) with a general <code>{ }</code> enclosing block:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// merge `defaults` into `config`</span>
{
    <span class="pl-c">// destructure (with default value assignments)</span>
    <span class="pl-k">let</span> {
        options<span class="pl-k">:</span> {
            remove <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.remove,
            enable <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.enable,
            instance <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.instance
        } <span class="pl-k">=</span> {},
        log<span class="pl-k">:</span> {
            warn <span class="pl-k">=</span> defaults<span class="pl-c1">.log.warn</span>,
            error <span class="pl-k">=</span> defaults<span class="pl-c1">.log.error</span>
        } <span class="pl-k">=</span> {}
    } <span class="pl-k">=</span> config;

    <span class="pl-c">// restructure</span>
    config <span class="pl-k">=</span> {
        options<span class="pl-k">:</span> { remove, enable, instance },
        log<span class="pl-k">:</span> { warn, error }
    };
}</pre></div>

<p>That seems a fair bit nicer, huh?</p>

<p><strong>Note:</strong> You could also accomplish the scope enclosure with an arrow IIFE instead of the general <code>{ }</code> block and <code>let</code> declarations. Your destructuring assignments/defaults would be in the parameter list and your restructuring would be the <code>return</code> statement in the function body.</p>

<p>The <code>{ warn, error }</code> syntax in the restructuring part may look new to you; that's called "concise properties" and we cover it in the next section!</p>

<h2><a id="user-content-object-literal-extensions" class="anchor" href="#object-literal-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Literal Extensions</h2>

<p>ES6 adds a number of important convenience extensions to the humble <code>{ .. }</code> object literal.</p>

<h3><a id="user-content-concise-properties" class="anchor" href="#concise-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concise Properties</h3>

<p>You're certainly familiar with declaring object literals in this form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">2</span>, y <span class="pl-k">=</span> <span class="pl-c1">3</span>,
    o <span class="pl-k">=</span> {
        x<span class="pl-k">:</span> x,
        y<span class="pl-k">:</span> y
    };</pre></div>

<p>If it's always felt redundant to say <code>x: x</code> all over, there's good news. If you need to define a property that is the same name as a lexical identifier, you can shorten it from <code>x: x</code> to <code>x</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">2</span>, y <span class="pl-k">=</span> <span class="pl-c1">3</span>,
    o <span class="pl-k">=</span> {
        x,
        y
    };</pre></div>

<h3><a id="user-content-concise-methods" class="anchor" href="#concise-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concise Methods</h3>

<p>In a similar spirit to concise properties we just examined, functions attached to properties in object literals also have a concise form, for convenience.</p>

<p>The old way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">x</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">y</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
        <span class="pl-c">// ..</span>
    }
}</pre></div>

<p>And as of ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">x</span>() {
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">y</span>() {
        <span class="pl-c">// ..</span>
    }
}</pre></div>

<p><strong>Warning:</strong> While <code>x() { .. }</code> seems to just be shorthand for <code>x: function(){ .. }</code>, concise methods have special behaviors that their older counterparts don't; specifically, the allowance for <code>super</code> (see "Object <code>super</code>" later in this chapter).</p>

<p>Generators (see Chapter 4) also have a concise method form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-k">*</span><span class="pl-en">foo</span>() { .. }
};</pre></div>

<h4><a id="user-content-concisely-unnamed" class="anchor" href="#concisely-unnamed" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concisely Unnamed</h4>

<p>While that convenience shorthand is quite attractive, there's a subtle gotcha to be aware of. To illustrate, let's examine pre-ES6 code like the following, which you might try to refactor to use concise methods:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">runSomething</span>(<span class="pl-smi">o</span>) {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>(),
        y <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();

    <span class="pl-k">return</span> o.something( x, y );
}

runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-c">// recursively call with `x`</span>
            <span class="pl-c">// and `y` swapped</span>
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>This obviously silly code just generates two random numbers and subtracts the smaller from the bigger. But what's important here isn't what it does, but rather how it's defined. Let's focus on the object literal and function definition, as we see here:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-c">// ..</span>
    }
} );</pre></div>

<p>Why do we say both <code>something:</code> and <code>function something</code>? Isn't that redundant? Actually, no, both are needed for different purposes. The property <code>something</code> is how we can call <code>o.something(..)</code>, sort of like its public name. But the second <code>something</code> is a lexical name to refer to the function from inside itself, for recursion purposes.</p>

<p>Can you see why the line <code>return something(y,x)</code> needs the name <code>something</code> to refer to the function? There's no lexical name for the object, such that it could have said <code>return o.something(y,x)</code> or something of that sort.</p>

<p>That's actually a pretty common practice when the object literal does have an identifying name, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-c">// ..</span>
        controller.makeRequest(..);
    }
};</pre></div>

<p>Is this a good idea? Perhaps, perhaps not. You're assuming that the name <code>controller</code> will always point to the object in question. But it very well may not -- the <code>makeRequest(..)</code> function doesn't control the outer code and so can't force that to be the case. This could come back to bite you.</p>

<p>Others prefer to use <code>this</code> to define such things:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-c">// ..</span>
        <span class="pl-v">this</span>.makeRequest(..);
    }
};</pre></div>

<p>That looks fine, and should work if you always invoke the method as <code>controller.makeRequest(..)</code>. But you now have a <code>this</code> binding gotcha if you do something like:</p>

<div class="highlight highlight-source-js"><pre>btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, controller.makeRequest, <span class="pl-c1">false</span> );</pre></div>

<p>Of course, you can solve that by passing <code>controller.makeRequest.bind(controller)</code> as the handler reference to bind the event to. But yuck -- it isn't very appealing.</p>

<p>Or what if your inner <code>this.makeRequest(..)</code> call needs to be made from a nested function? You'll have another <code>this</code> binding hazard, which people will often solve with the hacky <code>var self = this</code>, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;

        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
            <span class="pl-c">// ..</span>
            self.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>More yuck.</p>

<p><strong>Note:</strong> For more information on <code>this</code> binding rules and gotchas, see Chapters 1-2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>OK, what does all this have to do with concise methods? Recall our <code>something(..)</code> method definition:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-c">// ..</span>
    }
} );</pre></div>

<p>The second <code>something</code> here provides a super convenient lexical identifier that will always point to the function itself, giving us the perfect reference for recursion, event binding/unbinding, and so on -- no messing around with <code>this</code> or trying to use an untrustable object reference.</p>

<p>Great!</p>

<p>So, now we try to refactor that function reference to this ES6 concise method form:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>Seems fine at first glance, except this code will break. The <code>return something(..)</code> call will not find a <code>something</code> identifier, so you'll get a <code>ReferenceError</code>. Oops. But why?</p>

<p>The above ES6 snippet is interpreted as meaning:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>Look closely. Do you see the problem? The concise method definition implies <code>something: function(x,y)</code>. See how the second <code>something</code> we were relying on has been omitted? In other words, concise methods imply anonymous function expressions.</p>

<p>Yeah, yuck.</p>

<p><strong>Note:</strong> You may be tempted to think that <code>=&gt;</code> arrow functions are a good solution here, but they're equally insufficient, as they're also anonymous function expressions. We'll cover them in "Arrow Functions" later in this chapter.</p>

<p>The partially redeeming news is that our <code>something(x,y)</code> concise method won't be totally anonymous. See "Function Names" in Chapter 7 for information about ES6 function name inference rules. That won't help us for our recursion, but it helps with debugging at least.</p>

<p>So what are we left to conclude about concise methods? They're short and sweet, and a nice convenience. But you should only use them if you're never going to need them to do recursion or event binding/unbinding. Otherwise, stick to your old-school <code>something: function something(..)</code> method definitions.</p>

<p>A lot of your methods are probably going to benefit from concise method definitions, so that's great news! Just be careful of the few where there's an un-naming hazard.</p>

<h4><a id="user-content-es5-gettersetter" class="anchor" href="#es5-gettersetter" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES5 Getter/Setter</h4>

<p>Technically, ES5 defined getter/setter literals forms, but they didn't seem to get used much, mostly due to the lack of transpilers to handle that new syntax (the only major new syntax added in ES5, really). So while it's not a new ES6 feature, we'll briefly refresh on that form, as it's probably going to be much more useful with ES6 going forward.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    __id<span class="pl-k">:</span> <span class="pl-c1">10</span>,
    get <span class="pl-en">id</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>.__id<span class="pl-k">++</span>; },
    set <span class="pl-en">id</span>(<span class="pl-smi">v</span>) { <span class="pl-v">this</span>.__id <span class="pl-k">=</span> v; }
}

o.<span class="pl-c1">id</span>;           <span class="pl-c">// 10</span>
o.<span class="pl-c1">id</span>;           <span class="pl-c">// 11</span>
o.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-c1">20</span>;
o.<span class="pl-c1">id</span>;           <span class="pl-c">// 20</span>

<span class="pl-c">// and:</span>
o.__id;         <span class="pl-c">// 21</span>
o.__id;         <span class="pl-c">// 21 -- still!</span></pre></div>

<p>These getter and setter literal forms are also present in classes; see Chapter 3.</p>

<p><strong>Warning:</strong> It may not be obvious, but the setter literal must have exactly one declared parameter; omitting it or listing others is illegal syntax. The single required parameter <em>can</em> use destructuring and defaults (e.g., <code>set id({ id: v = 0 }) { .. }</code>), but the gather/rest <code>...</code> is not allowed (<code>set id(...v) { .. }</code>).</p>

<h3><a id="user-content-computed-property-names" class="anchor" href="#computed-property-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computed Property Names</h3>

<p>You've probably been in a situation like the following snippet, where you have one or more property names that come from some sort of expression and thus can't be put into the object literal:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> prefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>user_<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. }
};

o[ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ] <span class="pl-k">=</span> <span class="pl-k">function</span>(..){ .. };
o[ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ] <span class="pl-k">=</span> <span class="pl-k">function</span>(..){ .. };
..</pre></div>

<p>ES6 adds a syntax to the object literal definition which allows you to specify an expression that should be computed, whose result is the property name assigned. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> prefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>user_<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. },
    [ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ]<span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. },
    [ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ]<span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. }
    ..
};</pre></div>

<p>Any valid expression can appear inside the <code>[ .. ]</code> that sits in the property name position of the object literal definition.</p>

<p>Probably the most common use of computed property names will be with <code>Symbol</code>s (which we cover in "Symbols" later in this chapter), such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    [Symbol.toStringTag]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>really cool thing<span class="pl-pds">"</span></span>,
    ..
};</pre></div>

<p><code>Symbol.toStringTag</code> is a special built-in value, which we evaluate with the <code>[ .. ]</code> syntax, so we can assign the <code>"really cool thing"</code> value to the special property name.</p>

<p>Computed property names can also appear as the name of a concise method or a concise generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    [<span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>oo<span class="pl-pds">"</span></span>]() { .. }   <span class="pl-c">// computed concise method</span>
    <span class="pl-k">*</span>[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>ar<span class="pl-pds">"</span></span>]() { .. }  <span class="pl-c">// computed concise generator</span>
};</pre></div>

<h3><a id="user-content-setting-prototype" class="anchor" href="#setting-prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting <code>[[Prototype]]</code></h3>

<p>We won't cover prototypes in detail here, so for more information, see the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>Sometimes it will be helpful to assign the <code>[[Prototype]]</code> of an object at the same time you're declaring its object literal. The following has been a nonstandard extension in many JS engines for a while, but is standardized as of ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    __proto__<span class="pl-k">:</span> o1,
    <span class="pl-c">// ..</span>
};</pre></div>

<p><code>o2</code> is declared with a normal object literal, but it's also <code>[[Prototype]]</code>-linked to <code>o1</code>. The <code>__proto__</code> property name here can also be a string <code>"__proto__"</code>, but note that it <em>cannot</em> be the result of a computed property name (see the previous section).</p>

<p><code>__proto__</code> is controversial, to say the least. It's a decades-old proprietary extension to JS that is finally standardized, somewhat begrudgingly it seems, in ES6. Many developers feel it shouldn't ever be used. In fact, it's in "Annex B" of ES6, which is the section that lists things JS feels it has to standardize for compatibility reasons only.</p>

<p><strong>Warning:</strong> Though I'm narrowly endorsing <code>__proto__</code> as a key in an object literal definition, I definitely do not endorse using it in its object property form, like <code>o.__proto__</code>. That form is both a getter and setter (again for compatibility reasons), but there are definitely better options. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<p>For setting the <code>[[Prototype]]</code> of an existing object, you can use the ES6 utility <code>Object.setPrototypeOf(..)</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );</pre></div>

<p><strong>Note:</strong> We'll discuss <code>Object</code> again in Chapter 6. "<code>Object.setPrototypeOf(..)</code> Static Function" provides additional details on <code>Object.setPrototypeOf(..)</code>. Also see "<code>Object.assign(..)</code> Static Function" for another form that relates <code>o2</code> prototypically to <code>o1</code>.</p>

<h3><a id="user-content-object-super" class="anchor" href="#object-super" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object <code>super</code></h3>

<p><code>super</code> is typically thought of as being only related to classes. However, due to JS's classless-objects-with-prototypes nature, <code>super</code> is equally effective, and nearly the same in behavior, with plain objects' concise methods.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>o1:foo<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>o2:foo<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );

o2.foo();       <span class="pl-c">// o1:foo</span>
                <span class="pl-c">// o2:foo</span></pre></div>

<p><strong>Warning:</strong> <code>super</code> is only allowed in concise methods, not regular function expression properties. It also is only allowed in <code>super.XXX</code> form (for property/method access), not in <code>super()</code> form.</p>

<p>The <code>super</code> reference in the <code>o2.foo()</code> method is locked statically to <code>o2</code>, and specifically to the <code>[[Prototype]]</code> of <code>o2</code>. <code>super</code> here would basically be <code>Object.getPrototypeOf(o2)</code> -- resolves to <code>o1</code> of course -- which is how it finds and calls <code>o1.foo()</code>.</p>

<p>For complete details on <code>super</code>, see "Classes" in Chapter 3.</p>

<h2><a id="user-content-template-literals" class="anchor" href="#template-literals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Template Literals</h2>

<p>At the very outset of this section, I'm going to have to call out the name of this ES6 feature as being awfully... misleading, depending on your experiences with what the word <em>template</em> means.</p>

<p>Many developers think of templates as being reusable renderable pieces of text, such as the capability provided by most template engines (Mustache, Handlebars, etc.). ES6's use of the word <em>template</em> would imply something similar, like a way to declare inline template literals that can be re-rendered. However, that's not at all the right way to think about this feature.</p>

<p>So, before we go on, I'm renaming to what it should have been called: <em>interpolated string literals</em> (or <em>interpoliterals</em> for short).</p>

<p>You're already well aware of declaring string literals with <code>"</code> or <code>'</code> delimiters, and you also know that these are not <em>smart strings</em> (as some languages have), where the contents would be parsed for interpolation expressions.</p>

<p>However, ES6 introduces a new type of string literal, using the <code>`</code> backtick as the delimiter. These string literals allow basic string interpolation expressions to be embedded, which are then automatically parsed and evaluated.</p>

<p>Here's the old pre-ES6 way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );            <span class="pl-c">// "Hello Kyle!"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-k">typeof</span> greeting );     <span class="pl-c">// "string"</span></pre></div>

<p>Now, consider the new ES6 way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">`</span>Hello <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );            <span class="pl-c">// "Hello Kyle!"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-k">typeof</span> greeting );     <span class="pl-c">// "string"</span></pre></div>

<p>As you can see, we used the <code>`..`</code> around a series of characters, which are interpreted as a string literal, but any expressions of the form <code>${..}</code> are parsed and evaluated inline immediately. The fancy term for such parsing and evaluating is <em>interpolation</em> (much more accurate than templating).</p>

<p>The result of the interpolated string literal expression is just a plain old normal string, assigned to the <code>greeting</code> variable.</p>

<p><strong>Warning:</strong> <code>typeof greeting == "string"</code> illustrates why it's important not to think of these entities as special template values, as you cannot assign the unevaluated form of the literal to something and reuse it. The <code>`..`</code> string literal is more like an IIFE in the sense that it's automatically evaluated inline. The result of a <code>`..`</code> string literal is, simply, just a string.</p>

<p>One really nice benefit of interpolated string literals is they are allowed to split across multiple lines:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> text <span class="pl-k">=</span>
<span class="pl-s"><span class="pl-pds">`</span>Now is the time for all good men</span>
<span class="pl-s">to come to the aid of their</span>
<span class="pl-s">country!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// Now is the time for all good men</span>
<span class="pl-c">// to come to the aid of their</span>
<span class="pl-c">// country!</span></pre></div>

<p>The line breaks (newlines) in the interpolated string literal were preserved in the string value.</p>

<p>Unless appearing as explicit escape sequences in the literal value, the value of the <code>\r</code> carriage return character (code point <code>U+000D</code>) or the value of the <code>\r\n</code> carriage return + line feed sequence (code points <code>U+000D</code> and <code>U+000A</code>) are both normalized to a <code>\n</code> line feed character (code point <code>U+000A</code>). Don't worry though; this normalization is rare and would likely only happen if copy-pasting text into your JS file.</p>

<h3><a id="user-content-interpolated-expressions" class="anchor" href="#interpolated-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interpolated Expressions</h3>

<p>Any valid expression is allowed to appear inside <code>${..}</code> in an interpolated string literal, including function calls, inline function expression calls, and even other interpolated string literals!</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">upper</span>(<span class="pl-smi">s</span>) {
    <span class="pl-k">return</span> s.<span class="pl-c1">toUpperCase</span>();
}

<span class="pl-k">var</span> who <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>reader<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span>
<span class="pl-s"><span class="pl-pds">`</span>A very <span class="pl-s1"><span class="pl-pse">${</span>upper( <span class="pl-s"><span class="pl-pds">"</span>warm<span class="pl-pds">"</span></span> )<span class="pl-pse">}</span></span> welcome</span>
<span class="pl-s">to all of you <span class="pl-s1"><span class="pl-pse">${</span>upper( <span class="pl-s"><span class="pl-pds">`</span><span class="pl-s1"><span class="pl-pse">${</span>who<span class="pl-pse">}</span></span>s<span class="pl-pds">`</span></span> )<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// A very WARM welcome</span>
<span class="pl-c">// to all of you READERS!</span></pre></div>

<p>Here, the inner <code>`${who}s`</code> interpolated string literal was a little bit nicer convenience for us when combining the <code>who</code> variable with the <code>"s"</code> string, as opposed to <code>who + "s"</code>. There will be cases that nesting interpolated string literals is helpful, but be wary if you find yourself doing that kind of thing often, or if you find yourself nesting several levels deep.</p>

<p>If that's the case, the odds are good that your string value production could benefit from some abstractions.</p>

<p><strong>Warning:</strong> As a word of caution, be very careful about the readability of your code with such new found power. Just like with default value expressions and destructuring assignment expressions, just because you <em>can</em> do something doesn't mean you <em>should</em> do it. Never go so overboard with new ES6 tricks that your code becomes more clever than you or your other team members.</p>

<h4><a id="user-content-expression-scope" class="anchor" href="#expression-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expression Scope</h4>

<p>One quick note about the scope that is used to resolve variables in expressions. I mentioned earlier that an interpolated string literal is kind of like an IIFE, and it turns out thinking about it like that explains the scoping behavior as well.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">str</span>) {
    <span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( str );
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;
    foo( <span class="pl-s"><span class="pl-pds">`</span>Hello from <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span> );
}

<span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>global<span class="pl-pds">"</span></span>;

bar();                  <span class="pl-c">// "Hello from bar!"</span></pre></div>

<p>At the moment the <code>`..`</code> string literal is expressed, inside the <code>bar()</code> function, the scope available to it finds <code>bar()</code>'s <code>name</code> variable with value <code>"bar"</code>. Neither the global <code>name</code> nor <code>foo(..)</code>'s <code>name</code> matter. In other words, an interpolated string literal is just lexically scoped where it appears, not dynamically scoped in any way.</p>

<h3><a id="user-content-tagged-template-literals" class="anchor" href="#tagged-template-literals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tagged Template Literals</h3>

<p>Again, renaming the feature for sanity sake: <em>tagged string literals</em>.</p>

<p>To be honest, this is one of the cooler tricks that ES6 offers. It may seem a little strange, and perhaps not all that generally practical at first. But once you've spent some time with it, tagged string literals may just surprise you in their usefulness.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( values );
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

foo<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Everything is ", "!"]</span>
<span class="pl-c">// [ "awesome" ]</span></pre></div>

<p>Let's take a moment to consider what's happening in the previous snippet. First, the most jarring thing that jumps out is <code>foo`Everything...`;</code>. That doesn't look like anything we've seen before. What is it?</p>

<p>It's essentially a special kind of function call that doesn't need the <code>( .. )</code>. The <em>tag</em> -- the <code>foo</code> part before the <code>`..`</code> string literal -- is a function value that should be called. Actually, it can be any expression that results in a function, even a function call that returns another function, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( values );
    }
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

bar()<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Everything is ", "!"]</span>
<span class="pl-c">// [ "awesome" ]</span></pre></div>

<p>But what gets passed to the <code>foo(..)</code> function when invoked as a tag for a string literal?</p>

<p>The first argument -- we called it <code>strings</code> -- is an array of all the plain strings (the stuff between any interpolated expressions). We get two values in the <code>strings</code> array: <code>"Everything is "</code> and <code>"!"</code>.</p>

<p>For convenience sake in our example, we then gather up all subsequent arguments into an array called <code>values</code> using the <code>...</code> gather/rest operator (see the "Spread/Rest" section earlier in this chapter), though you could of course have left them as individual named parameters following the <code>strings</code> parameter.</p>

<p>The argument(s) gathered into our <code>values</code> array are the results of the already-evaluated interpolation expressions found in the string literal. So obviously the only element in <code>values</code> in our example is <code>"awesome"</code>.</p>

<p>You can think of these two arrays as: the values in <code>values</code> are the separators if you were to splice them in between the values in <code>strings</code>, and then if you joined everything together, you'd get the complete interpolated string value.</p>

<p>A tagged string literal is like a processing step after the interpolation expressions are evaluated but before the final string value is compiled, allowing you more control over generating the string from the literal.</p>

<p>Typically, the string literal tag function (<code>foo(..)</code> in the previous snippets) should compute an appropriate string value and return it, so that you can use the tagged string literal as a value just like untagged string literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">tag</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-k">return</span> strings.reduce( <span class="pl-k">function</span>(<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>){
        <span class="pl-k">return</span> s <span class="pl-k">+</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>) <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span> tag<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );            <span class="pl-c">// Everything is awesome!</span></pre></div>

<p>In this snippet, <code>tag(..)</code> is a pass-through operation, in that it doesn't perform any special modifications, but just uses <code>reduce(..)</code> to loop over and splice/interleave <code>strings</code> and <code>values</code> together the same way an untagged string literal would have done.</p>

<p>So what are some practical uses? There are many advanced ones that are beyond our scope to discuss here. But here's a simple idea that formats numbers as U.S. dollars (sort of like basic localization):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">dollabillsyall</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-k">return</span> strings.reduce( <span class="pl-k">function</span>(<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>){
        <span class="pl-k">if</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// look, also using interpolated</span>
                <span class="pl-c">// string literals!</span>
                s <span class="pl-k">+=</span> <span class="pl-s"><span class="pl-pds">`</span>$<span class="pl-s1"><span class="pl-pse">${</span>values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>].toFixed( <span class="pl-c1">2</span> )<span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>;
            }
            <span class="pl-k">else</span> {
                s <span class="pl-k">+=</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> s <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> amt1 <span class="pl-k">=</span> <span class="pl-c1">11.99</span>,
    amt2 <span class="pl-k">=</span> amt1 <span class="pl-k">*</span> <span class="pl-c1">1.08</span>,
    name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span> dollabillsyall
<span class="pl-s"><span class="pl-pds">`</span>Thanks for your purchase, <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>! Your</span>
<span class="pl-s">product cost was <span class="pl-s1"><span class="pl-pse">${</span>amt1<span class="pl-pse">}</span></span>, which with tax</span>
<span class="pl-s">comes out to <span class="pl-s1"><span class="pl-pse">${</span>amt2<span class="pl-pse">}</span></span>.<span class="pl-pds">`</span></span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// Thanks for your purchase, Kyle! Your</span>
<span class="pl-c">// product cost was $11.99, which with tax</span>
<span class="pl-c">// comes out to $12.95.</span></pre></div>

<p>If a <code>number</code> value is encountered in the <code>values</code> array, we put <code>"$"</code> in front of it and format it to two decimal places with <code>toFixed(2)</code>. Otherwise, we let the value pass-through untouched.</p>

<h4><a id="user-content-raw-strings" class="anchor" href="#raw-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raw Strings</h4>

<p>In the previous snippets, our tag functions receive the first argument we called <code>strings</code>, which is an array. But there's an additional bit of data included: the raw unprocessed versions of all the strings. You can access those raw string values using the <code>.raw</code> property, like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">showraw</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings.raw );
}

showraw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Hello</span>
<span class="pl-c">// World" ]</span>
<span class="pl-c">// [ "Hello\nWorld" ]</span></pre></div>

<p>The raw version of the value preserves the raw escaped <code>\n</code> sequence (the <code>\</code> and the <code>n</code> are separate characters), while the processed version considers it a single newline character. However, the earlier mentioned line-ending normalization is applied to both values.</p>

<p>ES6 comes with a built-in function that can be used as a string literal tag: <code>String.raw(..)</code>. It simply passes through the raw versions of the <code>strings</code> values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span> );
<span class="pl-c">// Hello</span>
<span class="pl-c">// World</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span> );
<span class="pl-c">// Hello\nWorld</span>

<span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span>.<span class="pl-c1">length</span>;
<span class="pl-c">// 12</span></pre></div>

<p>Other uses for string literal tags included special processing for internationalization, localization, and more!</p>

<h2><a id="user-content-arrow-functions" class="anchor" href="#arrow-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arrow Functions</h2>

<p>We've touched on <code>this</code> binding complications with functions earlier in this chapter, and they're covered at length in the <em>this &amp; Object Prototypes</em> title of this series. It's important to understand the frustrations that <code>this</code>-based programming with normal functions brings, because that is the primary motivation for the new ES6 <code>=&gt;</code> arrow function feature.</p>

<p>Let's first illustrate what an arrow function looks like, as compared to normal functions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

<span class="pl-c">// versus</span>

<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> (<span class="pl-smi">x</span>,<span class="pl-smi">y</span>)<span class="pl-k"> =&gt;</span> x <span class="pl-k">+</span> y;</pre></div>

<p>The arrow function definition consists of a parameter list (of zero or more parameters, and surrounding <code>( .. )</code> if there's not exactly one parameter), followed by the <code>=&gt;</code> marker, followed by a function body.</p>

<p>So, in the previous snippet, the arrow function is just the <code>(x,y) =&gt; x + y</code> part, and that function reference happens to be assigned to the variable <code>foo</code>.</p>

<p>The body only needs to be enclosed by <code>{ .. }</code> if there's more than one expression, or if the body consists of a non-expression statement. If there's only one expression, and you omit the surrounding <code>{ .. }</code>, there's an implied <code>return</code> in front of the expression, as illustrated in the previous snippet.</p>

<p>Here's some other arrow function variations to consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">f1</span> <span class="pl-k">=</span> ()<span class="pl-k"> =&gt;</span> <span class="pl-c1">12</span>;
<span class="pl-k">var</span> f2 <span class="pl-k">=</span> x <span class="pl-k">=&gt;</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
<span class="pl-k">var</span> <span class="pl-en">f3</span> <span class="pl-k">=</span> (<span class="pl-smi">x</span>,<span class="pl-smi">y</span>)<span class="pl-k"> =&gt;</span> {
    <span class="pl-k">var</span> z <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> y;
    y<span class="pl-k">++</span>;
    x <span class="pl-k">*=</span> <span class="pl-c1">3</span>;
    <span class="pl-k">return</span> (x <span class="pl-k">+</span> y <span class="pl-k">+</span> z) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
};</pre></div>

<p>Arrow functions are <em>always</em> function expressions; there is no arrow function declaration. It also should be clear that they are anonymous function expressions -- they have no named reference for the purposes of recursion or event binding/unbinding -- though "Function Names" in Chapter 7 will describe ES6's function name inference rules for debugging purposes.</p>

<p><strong>Note:</strong> All the capabilities of normal function parameters are available to arrow functions, including default values, destructuring, rest parameters, and so on.</p>

<p>Arrow functions have a nice, shorter syntax, which makes them on the surface very attractive for writing terser code. Indeed, nearly all literature on ES6 (other than the titles in this series) seems to immediately and exclusively adopt the arrow function as "the new function."</p>

<p>It is telling that nearly all examples in discussion of arrow functions are short single statement utilities, such as those passed as callbacks to various utilities. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a <span class="pl-k">=</span> a.map( v <span class="pl-k">=&gt;</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );               <span class="pl-c">// [2,4,6,8,10]</span></pre></div>

<p>In those cases, where you have such inline function expressions, and they fit the pattern of computing a quick calculation in a single statement and returning that result, arrow functions indeed look to be an attractive and lightweight alternative to the more verbose <code>function</code> keyword and syntax.</p>

<p>Most people tend to <em>ooh and aah</em> at nice terse examples like that, as I imagine you just did!</p>

<p>However, I would caution you that it would seem to me somewhat a misapplication of this feature to use arrow function syntax with otherwise normal, multistatement functions, especially those that would otherwise be naturally expressed as function declarations.</p>

<p>Recall the <code>dollabillsyall(..)</code> string literal tag function from earlier in this chapter -- let's change it to use <code>=&gt;</code> syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">dollabillsyall</span> <span class="pl-k">=</span> (<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>)<span class="pl-k"> =&gt;</span>
    strings.reduce( (<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>)<span class="pl-k"> =&gt;</span> {
        <span class="pl-k">if</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// look, also using interpolated</span>
                <span class="pl-c">// string literals!</span>
                s <span class="pl-k">+=</span> <span class="pl-s"><span class="pl-pds">`</span>$<span class="pl-s1"><span class="pl-pse">${</span>values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>].toFixed( <span class="pl-c1">2</span> )<span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>;
            }
            <span class="pl-k">else</span> {
                s <span class="pl-k">+=</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> s <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );</pre></div>

<p>In this example,  the only modifications I made were the removal of <code>function</code>, <code>return</code>, and some <code>{ .. }</code>, and then the insertion of <code>=&gt;</code> and a <code>var</code>. Is this a significant improvement in the readability of the code? Meh.</p>

<p>I'd actually argue that the lack of <code>return</code> and outer <code>{ .. }</code> partially obscures the fact that the <code>reduce(..)</code> call is the only statement in the <code>dollabillsyall(..)</code> function and that its result is the intended result of the call. Also, the trained eye that is so used to hunting for the word <code>function</code> in code to find scope boundaries now needs to look for the <code>=&gt;</code> marker, which can definitely be harder to find in the thick of the code.</p>

<p>While not a hard-and-fast rule, I'd say that the readability gains from <code>=&gt;</code> arrow function conversion are inversely proportional to the length of the function being converted. The longer the function, the less <code>=&gt;</code> helps; the shorter the function, the more <code>=&gt;</code> can shine.</p>

<p>I think it's probably more sensible and reasonable to adopt <code>=&gt;</code> for the places in code where you do need short inline function expressions, but leave your normal-length main functions as is.</p>

<h3><a id="user-content-not-just-shorter-syntax-but-this" class="anchor" href="#not-just-shorter-syntax-but-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not Just Shorter Syntax, But <code>this</code></h3>

<p>Most of the popular attention toward <code>=&gt;</code> has been on saving those precious keystrokes by dropping <code>function</code>, <code>return</code>, and <code>{ .. }</code> from your code.</p>

<p>But there's a big detail we've skipped over so far. I said at the beginning of the section that <code>=&gt;</code> functions are closely related to <code>this</code> binding behavior. In fact, <code>=&gt;</code> arrow functions are <em>primarily designed</em> to alter <code>this</code> behavior in a specific way, solving a particular and common pain point with <code>this</code>-aware coding.</p>

<p>The saving of keystrokes is a red herring, a misleading sideshow at best.</p>

<p>Let's revisit another example from earlier in this chapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;

        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
            <span class="pl-c">// ..</span>
            self.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>We used the <code>var self = this</code> hack, and then referenced <code>self.makeRequest(..)</code>, because inside the callback function we're passing to <code>addEventListener(..)</code>, the <code>this</code> binding will not be the same as it is in <code>makeRequest(..)</code> itself. In other words, because <code>this</code> bindings are dynamic, we fall back to the predictability of lexical scope via the <code>self</code> variable.</p>

<p>Herein we finally can see the primary design characteristic of <code>=&gt;</code> arrow functions. Inside arrow functions, the <code>this</code> binding is not dynamic, but is instead lexical. In the previous snippet, if we used an arrow function for the callback, <code>this</code> will be predictably what we wanted it to be.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, ()<span class="pl-k"> =&gt;</span> {
            <span class="pl-c">// ..</span>
            <span class="pl-v">this</span>.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>Lexical <code>this</code> in the arrow function callback in the previous snippet now points to the same value as in the enclosing <code>makeRequest(..)</code> function. In other words, <code>=&gt;</code> is a syntactic stand-in for <code>var self = this</code>.</p>

<p>In cases where <code>var self = this</code> (or, alternatively, a function <code>.bind(this)</code> call) would normally be helpful, <code>=&gt;</code> arrow functions are a nicer alternative operating on the same prinicple. Sounds great, right?</p>

<p>Not quite so simple.</p>

<p>If <code>=&gt;</code> replaces <code>var self = this</code> or <code>.bind(this)</code> and it helps, guess what happens if you use <code>=&gt;</code> with a <code>this</code>-aware function that <em>doesn't</em> need <code>var self = this</code> to work? You might be able to guess that it's going to mess things up. Yeah.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    makeRequest<span class="pl-k">:</span> (..)<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// ..</span>
        <span class="pl-v">this</span>.helper(..);
    },
    helper<span class="pl-k">:</span> (..)<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// ..</span>
    }
};

controller.makeRequest(..);</pre></div>

<p>Although we invoke as <code>controller.makeRequest(..)</code>, the <code>this.helper</code> reference fails, because <code>this</code> here doesn't point to <code>controller</code> as it normally would. Where does it point? It lexically inherits <code>this</code> from the surrounding scope. In this previous snippet, that's the global scope, where <code>this</code> points to the global object. Ugh.</p>

<p>In addition to lexical <code>this</code>, arrow functions also have lexical <code>arguments</code> -- they don't have their own <code>arguments</code> array but instead inherit from their parent -- as well as lexical <code>super</code> and <code>new.target</code> (see "Classes" in Chapter 3).</p>

<p>So now we can conclude a more nuanced set of rules for when <code>=&gt;</code> is appropriate and not:</p>

<ul>
<li>If you have a short, single-statement inline function expression, where the only statement is a <code>return</code> of some computed value, <em>and</em> that function doesn't already make a <code>this</code> reference inside it, <em>and</em> there's no self-reference (recursion, event binding/unbinding), <em>and</em> you don't reasonably expect the function to ever be that way, you can probably safely refactor it to be an <code>=&gt;</code> arrow function.</li>
<li>If you have an inner function expression that's relying on a <code>var self = this</code> hack or a <code>.bind(this)</code> call on it in the enclosing function to ensure proper <code>this</code> binding, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>
<li>If you have an inner function expression that's relying on something like <code>var args = Array.prototype.slice.call(arguments)</code> in the enclosing function to make a lexical copy of <code>arguments</code>, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>
<li>For everything else -- normal function declarations, longer multistatment function expressions, functions that need a lexical name identifier self-reference (recursion, etc.), and any other function that doesn't fit the previous characteristics -- you should probably avoid <code>=&gt;</code> function syntax.</li>
</ul>

<p>Bottom line: <code>=&gt;</code> is about lexical binding of <code>this</code>, <code>arguments</code>, and <code>super</code>. These are intentional features designed to fix some common problems, not bugs, quirks, or mistakes in ES6.</p>

<p>Don't believe any hype that <code>=&gt;</code> is primarily, or even mostly, about fewer keystrokes. Whether you save keystrokes or waste them, you should know exactly what you are intentionally doing with every character typed.</p>

<p><strong>Tip:</strong> If you have a function that for any of these articulated reasons is not a good match for an <code>=&gt;</code> arrow function, but it's being declared as part of an object literal, recall from "Concise Methods" earlier in this chapter that there's another option for shorter function syntax.</p>

<p>If you prefer a visual decision chart for how/why to pick an arrow function:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/es6 &amp; beyond/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/es6 &amp; beyond/fig1.png" style="max-width:100%;"></a></p>

<h2><a id="user-content-forof-loops" class="anchor" href="#forof-loops" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>for..of</code> Loops</h2>

<p>Joining the <code>for</code> and <code>for..in</code> loops from the JavaScript we're all familiar with, ES6 adds a <code>for..of</code> loop, which loops over the set of values produced by an <em>iterator</em>.</p>

<p>The value you loop over with <code>for..of</code> must be an <em>iterable</em>, or it must be a value which can be coerced/boxed to an object (see the <em>Types &amp; Grammar</em> title of this series) that is an iterable. An iterable is simply an object that is able to produce an iterator, which the loop then uses.</p>

<p>Let's compare <code>for..of</code> to <code>for..in</code> to illustrate the difference:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> idx <span class="pl-k">in</span> a) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( idx );
}
<span class="pl-c">// 0 1 2 3 4</span>

<span class="pl-k">for</span> (<span class="pl-k">var</span> val <span class="pl-k">of</span> a) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>As you can see, <code>for..in</code> loops over the keys/indexes in the <code>a</code> array, while <code>for..of</code> loops over the values in <code>a</code>.</p>

<p>Here's the pre-ES6 version of the <code>for..of</code> from that previous snippet:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>],
    k <span class="pl-k">=</span> <span class="pl-c1">Object</span>.keys( a );

<span class="pl-k">for</span> (<span class="pl-k">var</span> val, i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> k.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
    val <span class="pl-k">=</span> a[ k[i] ];
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>And here's the ES6 but non-<code>for..of</code> equivalent, which also gives a glimpse at manually iterating an iterator (see "Iterators" in Chapter 3):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> val, ret, it <span class="pl-k">=</span> a[Symbol.iterator]();
    (ret <span class="pl-k">=</span> it.<span class="pl-c1">next</span>()) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>ret.done;
) {
    val <span class="pl-k">=</span> ret.<span class="pl-c1">value</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>Under the covers, the <code>for..of</code> loop asks the iterable for an iterator (using the built-in <code>Symbol.iterator</code>; see "Well-Known Symbols" in Chapter 7), then it repeatedly calls the iterator and assigns its produced value to the loop iteration variable.</p>

<p>Standard built-in values in JavaScript that are by default iterables (or provide them) include:</p>

<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Generators (see Chapter 3)</li>
<li>Collections / TypedArrays (see Chapter 5)</li>
</ul>

<p><strong>Warning:</strong> Plain objects are not by default suitable for <code>for..of</code> looping. That's because they don't have a default iterator, which is intentional, not a mistake. However, we won't go any further into those nuanced reasonings here. In "Iterators" in Chapter 3, we'll see how to define iterators for our own objects, which lets <code>for..of</code> loop over any object to get a set of values we define.</p>

<p>Here's how to loop over the characters in a primitive string:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> c <span class="pl-k">of</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( c );
}
<span class="pl-c">// "h" "e" "l" "l" "o"</span></pre></div>

<p>The <code>"hello"</code> primitive string value is coerced/boxed to the <code>String</code> object wrapper equivalent, which is an iterable by default.</p>

<p>In <code>for (XYZ of ABC)..</code>, the <code>XYZ</code> clause can either be an assignment expression or a declaration, identical to that same clause in <code>for</code> and <code>for..in</code> loops. So you can do stuff like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

<span class="pl-k">for</span> (o.a <span class="pl-k">of</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a );
}
<span class="pl-c">// 1 2 3</span>

<span class="pl-k">for</span> ({x<span class="pl-k">:</span> o.a} <span class="pl-k">of</span> [ {x<span class="pl-k">:</span> <span class="pl-c1">1</span>}, {x<span class="pl-k">:</span> <span class="pl-c1">2</span>}, {x<span class="pl-k">:</span> <span class="pl-c1">3</span>} ]) {
  <span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a );
}
<span class="pl-c">// 1 2 3</span></pre></div>

<p><code>for..of</code> loops can be prematurely stopped, just like other loops, with <code>break</code>, <code>continue</code>, <code>return</code> (if in a function), and thrown exceptions. In any of these cases, the iterator's <code>return(..)</code> function is automatically called (if one exists) to let the iterator perform cleanup tasks, if necessary.</p>

<p><strong>Note:</strong> See "Iterators" in Chapter 3 for more complete coverage on iterables and iterators.</p>

<h2><a id="user-content-regular-expressions" class="anchor" href="#regular-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expressions</h2>

<p>Let's face it: regular expressions haven't changed much in JS in a long time. So it's a great thing that they've finally learned a couple of new tricks in ES6. We'll briefly cover the additions here, but the overall topic of regular expressions is so dense that you'll need to turn to chapters/books dedicated to it (of which there are many!) if you need a refresher.</p>

<h3><a id="user-content-unicode-flag" class="anchor" href="#unicode-flag" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Flag</h3>

<p>We'll cover the topic of Unicode in more detail in "Unicode" later in this chapter. Here, we'll just look briefly at the new <code>u</code> flag for ES6+ regular expressions, which turns on Unicode matching for that expression.</p>

<p>JavaScript strings are typically interpreted as sequences of 16-bit characters, which correspond to the characters in the <em>Basic Multilingual Plane (BMP)</em> (<a href="http://en.wikipedia.org/wiki/Plane_%28Unicode%29">http://en.wikipedia.org/wiki/Plane_%28Unicode%29</a>). But there are many UTF-16 characters that fall outside this range, and so strings may have these multibyte characters in them.</p>

<p>Prior to ES6, regular expressions could only match based on BMP characters, which means that those extended characters were treated as two separate characters for matching purposes. This is often not ideal.</p>

<p>So, as of ES6, the <code>u</code> flag tells a regular expression to process a string with the intepretation of Unicode (UTF-16) characters, such that such an extended character will be matched as a single entity.</p>

<p><strong>Warning:</strong> Despite the name implication, "UTF-16" doesn't strictly mean 16 bits. Modern Unicode uses 21 bits, and standards like UTF-8 and UTF-16 refer roughly to how many bits are used in the representation of a character.</p>

<p>An example (straight from the ES6 specification):  (the musical symbol G-clef) is Unicode point U+1D11E (0x1D11E).</p>

<p>If this character appears in a regular expression pattern (like <code>//</code>), the standard BMP interpretation would be that it's two separate characters (0xD834 and 0xDD1E) to match with. But the new ES6 Unicode-aware mode means that <code>//u</code> (or the escaped Unicode form <code>/\u{1D11E}/u</code>) will match <code>""</code> in a string as a single matched character.</p>

<p>You might be wondering why this matters? In non-Unicode BMP mode, the pattern is treated as two separate characters, but would still find the match in a string with the <code>""</code> character in it, as you can see if you try:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-sr"><span class="pl-pds">/</span><span class="pl-pds">/</span></span>.<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>-clef<span class="pl-pds">"</span></span> );         <span class="pl-c">// true</span></pre></div>

<p>The length of the match is what matters. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span><span class="pl-c1">.</span>-clef<span class="pl-pds">/</span></span> .<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>-clef<span class="pl-pds">"</span></span> );     <span class="pl-c">// false</span>
<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span><span class="pl-c1">.</span>-clef<span class="pl-pds">/</span>u</span>.<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>-clef<span class="pl-pds">"</span></span> );     <span class="pl-c">// true</span></pre></div>

<p>The <code>^.-clef</code> in the pattern says to match only a single character at the beginning before the normal <code>"-clef"</code> text. In standard BMP mode, the match fails (two characters), but with <code>u</code> Unicode mode flagged on, the match succeeds (one character).</p>

<p>It's also important to note that <code>u</code> makes quantifiers like <code>+</code> and <code>*</code> apply to the entire Unicode code point as a single character, not just the <em>lower surrogate</em> (aka rightmost half of the symbol) of the character. The same goes for Unicode characters appearing in character classes, like <code>/[-]/u</code>.</p>

<p><strong>Note:</strong> There's plenty more nitty-gritty details about <code>u</code> behavior in regular expressions, which Mathias Bynens (<a href="https://twitter.com/mathias">https://twitter.com/mathias</a>) has written extensively about (<a href="https://mathiasbynens.be/notes/es6-unicode-regex">https://mathiasbynens.be/notes/es6-unicode-regex</a>).</p>

<h3><a id="user-content-sticky-flag" class="anchor" href="#sticky-flag" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Flag</h3>

<p>Another flag mode added to ES6 regular expressions is <code>y</code>, which is often called "sticky mode." <em>Sticky</em> essentially means the regular expression has a virtual anchor at its beginning that keeps it rooted to matching at only the position indicated by the regular expression's <code>lastIndex</code> property.</p>

<p>To illustrate, let's consider two regular expressions, the first without sticky mode and the second with:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re1 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span></span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>++foo++<span class="pl-pds">"</span></span>;

re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>
re1.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true</span>
re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0 -- not updated</span>

re1.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>;
re1.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true -- ignored `lastIndex`</span>
re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 4 -- not updated</span></pre></div>

<p>Three things to observe about this snippet:</p>

<ul>
<li><code>test(..)</code> doesn't pay any attention to <code>lastIndex</code>'s value, and always just performs its match from the beginning of the input string.</li>
<li>Because our pattern does not have a <code>^</code> start-of-input anchor, the search for <code>"foo"</code> is free to move ahead through the whole string looking for a match.</li>
<li><code>lastIndex</code> is not updated by <code>test(..)</code>.</li>
</ul>

<p>Now, let's try a sticky mode regular expression:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re2 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>y</span>,       <span class="pl-c">// &lt;-- notice the `y` sticky flag</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>++foo++<span class="pl-pds">"</span></span>;

re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>
re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// false -- "foo" not found at `0`</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>

re2.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;
re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 5 -- updated to after previous match</span>

re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// false</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0 -- reset after previous match failure</span></pre></div>

<p>And so our new observations about sticky mode:</p>

<ul>
<li><code>test(..)</code> uses <code>lastIndex</code> as the exact and only position in <code>str</code> to look to make a match. There is no moving ahead to look for the match -- it's either there at the <code>lastIndex</code> position or not.</li>
<li>If a match is made, <code>test(..)</code> updates <code>lastIndex</code> to point to the character immediately following the match. If a match fails, <code>test(..)</code> resets <code>lastIndex</code> back to <code>0</code>.</li>
</ul>

<p>Normal non-sticky patterns that aren't otherwise <code>^</code>-rooted to the start-of-input are free to move ahead in the input string looking for a match. But sticky mode restricts the pattern to matching just at the position of <code>lastIndex</code>.</p>

<p>As I suggested at the beginning of this section, another way of looking at this is that <code>y</code> implies a virtual anchor at the beginning of the pattern that is relative (aka constrains the start of the match) to exactly the <code>lastIndex</code> position.</p>

<p><strong>Warning:</strong> In previous literature on the topic, it has alternatively been asserted that this behavior is like <code>y</code> implying a <code>^</code> (start-of-input) anchor in the pattern. This is inaccurate. We'll explain in further detail in "Anchored Sticky" later.</p>

<h4><a id="user-content-sticky-positioning" class="anchor" href="#sticky-positioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Positioning</h4>

<p>It may seem strangely limiting that to use <code>y</code> for repeated matches, you have to manually ensure <code>lastIndex</code> is in the exact right position, as it has no move-ahead capability for matching.</p>

<p>Here's one possible scenario: if you know that the match you care about is always going to be at a position that's a multiple of a number (e.g., <code>0</code>, <code>10</code>, <code>20</code>, etc.), you can just construct a limited pattern matching what you care about, but then manually set <code>lastIndex</code> each time before match to those fixed positions.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>f<span class="pl-c1">..</span><span class="pl-pds">/</span>y</span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo       far       fad<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["foo"]</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>;
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["far"]</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">20</span>;
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["fad"]</span></pre></div>

<p>However, if you're parsing a string that isn't formatted in fixed positions like that, figuring out what to set <code>lastIndex</code> to before each match is likely going to be untenable.</p>

<p>There's a saving nuance to consider here. <code>y</code> requires that <code>lastIndex</code> be in the exact position for a match to occur. But it doesn't strictly require that <em>you</em> manually set <code>lastIndex</code>.</p>

<p>Instead, you can construct your expressions in such a way that they capture in each main match everything before and after the thing you care about, up to right before the next thing you'll care to match.</p>

<p>Because <code>lastIndex</code> will set to the next character beyond the end of a match, if you've matched everything up to that point, <code>lastIndex</code> will always be in the correct position for the <code>y</code> pattern to start from the next time.</p>

<p><strong>Warning:</strong> If you can't predict the structure of the input string in a sufficiently patterned way like that, this technique may not be suitable and you may not be able to use <code>y</code>.</p>

<p>Having structured string input is likely the most practical scenario where <code>y</code> will be capable of performing repeated matching throughout a string. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-c1">\d</span><span class="pl-k">+</span><span class="pl-cce">\.</span><span class="pl-c1">\s</span>(<span class="pl-c1">.</span><span class="pl-k">*?</span>)(?:<span class="pl-c1">\s</span><span class="pl-k">|</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>y</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1. foo 2. bar 3. baz<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// [ "1. foo ", "foo" ]</span>

re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 7 -- correct position!</span>
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// [ "2. bar ", "bar" ]</span>

re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 14 -- correct position!</span>
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["3. baz", "baz"]</span></pre></div>

<p>This works because I knew something ahead of time about the structure of the input string: there is always a numeral prefix like <code>"1. "</code> before the desired match (<code>"foo"</code>, etc.), and either a space after it, or the end of the string (<code>$</code> anchor). So the regular expression I constructed captures all of that in each main match, and then I use a matching group <code>( )</code> so that the stuff I really care about is separated out for convenience.</p>

<p>After the first match (<code>"1. foo "</code>), the <code>lastIndex</code> is <code>7</code>, which is already the position needed to start the next match, for <code>"2. bar "</code>, and so on.</p>

<p>If you're going to use <code>y</code> sticky mode for repeated matches, you'll probably want to look for opportunities to have <code>lastIndex</code> automatically positioned as we've just demonstrated.</p>

<h4><a id="user-content-sticky-versus-global" class="anchor" href="#sticky-versus-global" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Versus Global</h4>

<p>Some readers may be aware that you can emulate something like this <code>lastIndex</code>-relative matching with the <code>g</code> global match flag and the <code>exec(..)</code> method, as so:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>o<span class="pl-k">+</span><span class="pl-c1">.</span><span class="pl-pds">/</span>g</span>,        <span class="pl-c">// &lt;-- look, `g`!</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foot book more<span class="pl-pds">"</span></span>;

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["oot"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 4</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["ook"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 9</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["or"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 13</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// null -- no more matches!</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- starts over now!</span></pre></div>

<p>While it's true that <code>g</code> pattern matches with <code>exec(..)</code> start their matching from <code>lastIndex</code>'s current value, and also update <code>lastIndex</code> after each match (or failure), this is not the same thing as <code>y</code>'s behavior.</p>

<p>Notice in the previous snippet that <code>"ook"</code>, located at position <code>6</code>, was matched and found by the second <code>exec(..)</code> call, even though at the time, <code>lastIndex</code> was <code>4</code> (from the end of the previous match). Why? Because as we said earlier, non-sticky matches are free to move ahead in their matching. A sticky mode expression would have failed here, because it would not be allowed to move ahead.</p>

<p>In addition to perhaps undesired move-ahead matching behavior, another downside to just using <code>g</code> instead of <code>y</code> is that <code>g</code> changes the behavior of some matching methods, like <code>str.match(re)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>o<span class="pl-k">+</span><span class="pl-c1">.</span><span class="pl-pds">/</span>g</span>,        <span class="pl-c">// &lt;-- look, `g`!</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foot book more<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["oot","ook","or"]</span></pre></div>

<p>See how all the matches were returned at once? Sometimes that's OK, but sometimes that's not what you want.</p>

<p>The <code>y</code> sticky flag will give you one-at-a-time progressive matching with utilities like <code>test(..)</code> and <code>match(..)</code>. Just make sure the <code>lastIndex</code> is always in the right position for each match!</p>

<h4><a id="user-content-anchored-sticky" class="anchor" href="#anchored-sticky" aria-hidden="true"><span class="octicon octicon-link"></span></a>Anchored Sticky</h4>

<p>As we warned earlier, it's inaccurate to think of sticky mode as implying a pattern starts with <code>^</code>. The <code>^</code> anchor has a distinct meaning in regular expressions, which is <em>not altered</em> by sticky mode. <code>^</code> is an anchor that <em>always</em> refers to the beginning of the input, and <em>is not</em> in any way relative to <code>lastIndex</code>.</p>

<p>Besides poor/inaccurate documentation on this topic, the confusion is unfortunately strengthened further because an older pre-ES6 experiment with sticky mode in Firefox <em>did</em> make <code>^</code> relative to <code>lastIndex</code>, so that behavior has been around for years.</p>

<p>ES6 elected not to do it that way. <code>^</code> in a pattern means start-of-input absolutely and only.</p>

<p>As a consequence, a pattern like <code>/^foo/y</code> will always and only find a <code>"foo"</code> match at the beginning of a string, <em>if it's allowed to match there</em>. If <code>lastIndex</code> is not <code>0</code>, the match will fail. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-k">^</span>foo<span class="pl-pds">/</span>y</span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// true</span>
re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// false</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- reset after failure</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>;
re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// false -- failed for positioning</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- reset after failure</span></pre></div>

<p>Bottom line: <code>y</code> plus <code>^</code> plus <code>lastIndex &gt; 0</code> is an incompatible combination that will always cause a failed match.</p>

<p><strong>Note:</strong> While <code>y</code> does not alter the meaning of <code>^</code> in any way, the <code>m</code> multiline mode <em>does</em>, such that <code>^</code> means start-of-input <em>or</em> start of text after a newline. So, if you combine <code>y</code> and <code>m</code> flags together for a pattern, you can find multiple <code>^</code>-rooted matches in a string. But remember: because it's <code>y</code> sticky, you'll have to make sure <code>lastIndex</code> is pointing at the correct new line position (likely by matching to the end of the line) each subsequent time, or no subsequent matches will be made.</p>

<h3><a id="user-content-regular-expression-flags" class="anchor" href="#regular-expression-flags" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expression <code>flags</code></h3>

<p>Prior to ES6, if you wanted to examine a regular expression object to see what flags it had applied, you needed to parse them out -- ironically, probably with another regular expression -- from the content of the <code>source</code> property, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>ig</span>;

re.<span class="pl-c1">toString</span>();          <span class="pl-c">// "/foo/ig"</span>

<span class="pl-k">var</span> flags <span class="pl-k">=</span> re.<span class="pl-c1">toString</span>().<span class="pl-c1">match</span>(<span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-cce">\/</span>(<span class="pl-c1">[gim]</span><span class="pl-k">*</span>)<span class="pl-k">$</span><span class="pl-pds">/</span></span> )[<span class="pl-c1">1</span>];

flags;                  <span class="pl-c">// "ig"</span></pre></div>

<p>As of ES6, you can now get these values directly, with the new <code>flags</code> property:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>ig</span>;

re.flags;               <span class="pl-c">// "gi"</span></pre></div>

<p>It's a small nuance, but the ES6 specification calls for the expression's flags to be listed in this order: <code>"gimuy"</code>, regardless of what order the original pattern was specified with. That's the reason for the difference between <code>/ig</code> and <code>"gi"</code>.</p>

<p>No, the order of flags specified or listed doesn't matter.</p>

<p>Another tweak from ES6 is that the <code>RegExp(..)</code> constructor is now <code>flags</code>-aware if you pass it an existing regular expression:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re1 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-k">*</span><span class="pl-pds">/</span>y</span>;
re1.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re1.flags;                          <span class="pl-c">// "y"</span>

<span class="pl-k">var</span> re2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RegExp</span>( re1 );
re2.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re2.flags;                          <span class="pl-c">// "y"</span>

<span class="pl-k">var</span> re3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RegExp</span>( re1, <span class="pl-s"><span class="pl-pds">"</span>ig<span class="pl-pds">"</span></span> );
re3.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re3.flags;                          <span class="pl-c">// "gi"</span></pre></div>

<p>Prior to ES6, the <code>re3</code> construction would throw an error, but as of ES6 you can override the flags when duplicating.</p>

<h2><a id="user-content-number-literal-extensions" class="anchor" href="#number-literal-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Number Literal Extensions</h2>

<p>Prior to ES5, number literals looked like the following -- the octal form was not officially specified, only allowed as an extension that browsers had come to de facto agreement on:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> dec <span class="pl-k">=</span> <span class="pl-c1">42</span>,
    oct <span class="pl-k">=</span> <span class="pl-c1">052</span>,
    hex <span class="pl-k">=</span> <span class="pl-c1">0x2a</span>;</pre></div>

<p><strong>Note:</strong> Though you are specifying a number in different bases, the number's mathematic value is what is stored, and the default output interpretation is always base-10. The three variables in the previous snippet all have the <code>42</code> value stored in them.</p>

<p>To further illustrate that <code>052</code> was a nonstandard form extension, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span> );             <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>052<span class="pl-pds">"</span></span> );            <span class="pl-c">// 52</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0x2a<span class="pl-pds">"</span></span> );           <span class="pl-c">// 42</span></pre></div>

<p>ES5 continued to permit the browser-extended octal form (including such inconsistencies), except that in strict mode, the octal literal (<code>052</code>) form is disallowed. This restriction was done mainly because many developers had the habit (from other languages) of seemingly innocuously prefixing otherwise base-10 numbers with <code>0</code>'s for code alignment purposes, and then running into the accidental fact that they'd changed the number value entirely!</p>

<p>ES6 continues the legacy of changes/variations to how number literals outside base-10 numbers can be represented. There's now an official octal form, an amended hexadecimal form, and a brand-new binary form. For web compatibility reasons, the old octal <code>052</code> form will continue to be legal (though unspecified) in non-strict mode, but should really never be used anymore.</p>

<p>Here are the new ES6 number literal forms:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> dec <span class="pl-k">=</span> <span class="pl-c1">42</span>,
    oct <span class="pl-k">=</span> <span class="pl-c1">0o52</span>,         <span class="pl-c">// or `0O52` :(</span>
    hex <span class="pl-k">=</span> <span class="pl-c1">0x2a</span>,         <span class="pl-c">// or `0X2a` :/</span>
    bin <span class="pl-k">=</span> <span class="pl-c1">0b101010</span>;     <span class="pl-c">// or `0B101010` :/</span></pre></div>

<p>The only decimal form allowed is base-10. Octal, hexadecimal, and binary are all integer forms.</p>

<p>And the string representations of these forms are all able to be coerced/converted to their number equivalent:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span> );         <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0o52<span class="pl-pds">"</span></span> );       <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0x2a<span class="pl-pds">"</span></span> );       <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0b101010<span class="pl-pds">"</span></span> );   <span class="pl-c">// 42</span></pre></div>

<p>Though not strictly new to ES6, it's a little-known fact that you can actually go the opposite direction of conversion (well, sort of):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

a.<span class="pl-c1">toString</span>();           <span class="pl-c">// "42" -- also `a.toString( 10 )`</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">8</span> );        <span class="pl-c">// "52"</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );       <span class="pl-c">// "2a"</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">2</span> );        <span class="pl-c">// "101010"</span></pre></div>

<p>In fact, you can represent a number this way in any base from <code>2</code> to <code>36</code>, though it'd be rare that you'd go outside the standard bases: 2, 8, 10, and 16.</p>

<h2><a id="user-content-unicode" class="anchor" href="#unicode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode</h2>

<p>Let me just say that this section is not an exhaustive everything-you-ever-wanted-to-know-about-Unicode resource. I want to cover what you need to know that's <em>changing</em> for Unicode in ES6, but we won't go much deeper than that. Mathias Bynens (<a href="http://twitter.com/mathias">http://twitter.com/mathias</a>) has written/spoken extensively and brilliantly about JS and Unicode (see <a href="https://mathiasbynens.be/notes/javascript-unicode">https://mathiasbynens.be/notes/javascript-unicode</a> and <a href="http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode">http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode</a>).</p>

<p>The Unicode characters that range from <code>0x0000</code> to <code>0xFFFF</code> contain all the standard printed characters (in various languages) that you're likely to have seen or interacted with. This group of characters is called the <em>Basic Multilingual Plane (BMP)</em>. The BMP even contains fun symbols like this cool snowman:  (U+2603).</p>

<p>There are lots of other extended Unicode characters beyond this BMP set, which range up to <code>0x10FFFF</code>. These symbols are often referred to as <em>astral</em> symbols, as that's the name given to the set of 16 <em>planes</em> (e.g., layers/groupings) of characters beyond the BMP. Examples of astral symbols include  (U+1D11E) and <g-emoji alias="hankey" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png"><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png" class="emoji" title=":hankey:" alt=":hankey:" height="20" width="20" align="absmiddle"></g-emoji> (U+1F4A9).</p>

<p>Prior to ES6, JavaScript strings could specify Unicode characters using Unicode escaping, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> snowman <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>2603<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( snowman );         <span class="pl-c">// ""</span></pre></div>

<p>However, the <code>\uXXXX</code> Unicode escaping only supports four hexadecimal characters, so you can only represent the BMP set of characters in this way. To represent an astral character using Unicode escaping prior to ES6, you need to use a <em>surrogate pair</em> -- basically two specially calculated Unicode-escaped characters side by side, which JS interprets together as a single astral character:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>D834<span class="pl-cce">\u</span>DD1E<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( gclef );           <span class="pl-c">// ""</span></pre></div>

<p>As of ES6, we now have a new form for Unicode escaping (in strings and regular expressions), called Unicode <em>code point escaping</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>{1D11E}<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( gclef );           <span class="pl-c">// ""</span></pre></div>

<p>As you can see, the difference is the presence of the <code>{ }</code> in the escape sequence, which allows it to contain any number of hexadecimal characters. Because you only need six to represent the highest possible code point value in Unicode (i.e., 0x10FFFF), this is sufficient.</p>

<h3><a id="user-content-unicode-aware-string-operations" class="anchor" href="#unicode-aware-string-operations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode-Aware String Operations</h3>

<p>By default, JavaScript string operations and methods are not sensitive to astral symbols in string values. So, they treat each BMP character individually, even the two surrogate halves that make up an otherwise single astral character. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> snowman <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
snowman.<span class="pl-c1">length</span>;                 <span class="pl-c">// 1</span>

<span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
gclef.<span class="pl-c1">length</span>;                   <span class="pl-c">// 2</span></pre></div>

<p>So, how do we accurately calculate the length of such a string? In this scenario, the following trick will work:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

[...gclef].<span class="pl-c1">length</span>;              <span class="pl-c">// 1</span>
<span class="pl-c1">Array</span>.from( gclef ).<span class="pl-c1">length</span>;     <span class="pl-c">// 1</span></pre></div>

<p>Recall from the "<code>for..of</code> Loops" section earlier in this chapter that ES6 strings have built-in iterators. This iterator happens to be Unicode-aware, meaning it will automatically output an astral symbol as a single value. We take advantage of that using the <code>...</code> spread operator in an array literal, which creates an array of the string's symbols. Then we just inspect the length of that resultant array. ES6's <code>Array.from(..)</code> does basically the same thing as <code>[...XYZ]</code>, but we'll cover that utility in detail in Chapter 6.</p>

<p><strong>Warning:</strong> It should be noted that constructing and exhausting an iterator just to get the length of a string is quite expensive on performance, relatively speaking, compared to what a theoretically optimized native utility/property would do.</p>

<p>Unfortunately, the full answer is not as simple or straightforward. In addition to the surrogate pairs (which the string iterator takes care of), there are special Unicode code points that behave in other special ways, which is much harder to account for. For example, there's a set of code points that modify the previous adjacent character, known as <em>Combining Diacritical Marks</em>.</p>

<p>Consider these two string outputs:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// ""</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s2 );              <span class="pl-c">// ""</span></pre></div>

<p>They look the same, but they're not! Here's how we created <code>s1</code> and <code>s2</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;</pre></div>

<p>As you can probably guess, our previous <code>length</code> trick doesn't work with <code>s2</code>:</p>

<div class="highlight highlight-source-js"><pre>[...s1].<span class="pl-c1">length</span>;                 <span class="pl-c">// 1</span>
[...s2].<span class="pl-c1">length</span>;                 <span class="pl-c">// 2</span></pre></div>

<p>So what can we do? In this case, we can perform a <em>Unicode normalization</em> on the value before inquiring about its length, using the ES6 <code>String#normalize(..)</code> utility (which we'll cover more in Chapter 6):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;

s1.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 1</span>
s2.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 1</span>

s1 <span class="pl-k">===</span> s2;                      <span class="pl-c">// false</span>
s1 <span class="pl-k">===</span> s2.normalize();          <span class="pl-c">// true</span></pre></div>

<p>Essentially, <code>normalize(..)</code> takes a sequence like <code>"e\u0301"</code> and normalizes it to <code>"\xE9"</code>. Normalization can even combine multiple adjacent combining marks if there's a suitable Unicode character they combine to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>o<span class="pl-cce">\u</span>0302<span class="pl-cce">\u</span>0300<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> s1.normalize(),
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

s1.<span class="pl-c1">length</span>;                      <span class="pl-c">// 3</span>
s2.<span class="pl-c1">length</span>;                      <span class="pl-c">// 1</span>
s3.<span class="pl-c1">length</span>;                      <span class="pl-c">// 1</span>

s2 <span class="pl-k">===</span> s3;                      <span class="pl-c">// true</span></pre></div>

<p>Unfortunately, normalization isn't fully perfect here, either. If you have multiple combining marks modifying a single character, you may not get the length count you'd expect, because there may not be a single defined normalized character that represents the combination of all the marks. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-cce">\u</span>0330<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// "e"</span>

s1.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 2</span></pre></div>

<p>The further you go down this rabbit hole, the more you realize that it's difficult to get one precise definition for "length." What we see visually rendered as a single character -- more precisely called a <em>grapheme</em> -- doesn't always strictly relate to a single "character" in the program processing sense.</p>

<p><strong>Tip:</strong> If you want to see just how deep this rabbit hole goes, check out the "Grapheme Cluster Boundaries" algorithm (<a href="http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries</a>).</p>

<h3><a id="user-content-character-positioning" class="anchor" href="#character-positioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Character Positioning</h3>

<p>Similar to length complications, what does it actually mean to ask, "what is the character at position 2?" The naive pre-ES6 answer comes from <code>charAt(..)</code>, which will not respect the atomicity of an astral character, nor will it take into account combining marks.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// "abd"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s2 );              <span class="pl-c">// "abd"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s3 );              <span class="pl-c">// "abd"</span>

s1.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// "c"</span>
s2.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// ""</span>
s3.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// "" &lt;-- unprintable surrogate</span>
s3.<span class="pl-c1">charAt</span>( <span class="pl-c1">3</span> );                 <span class="pl-c">// "" &lt;-- unprintable surrogate</span></pre></div>

<p>So, is ES6 giving us a Unicode-aware verison of <code>charAt(..)</code>? Unfortunately, no. At the time of this writing, there's a proposal for such a utility that's under consideration for post-ES6.</p>

<p>But with what we explored in the previous section (and of course with the limitations noted thereof!), we can hack an ES6 answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

[...s1.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// ""</span>
[...s2.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// ""</span>
[...s3.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// ""</span></pre></div>

<p><strong>Warning:</strong> Reminder of an earlier warning: constructing and exhausting an iterator each time you want to get at a single character is... very not ideal, performance wise. Let's hope we get a built-in and optimized utility for this soon, post-ES6.</p>

<p>What about a Unicode-aware version of the <code>charCodeAt(..)</code> utility? ES6 gives us <code>codePointAt(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

s1.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "107"</span>

s2.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "107"</span>

s3.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "1d49e"</span></pre></div>

<p>What about the other direction? A Unicode-aware version of <code>String.fromCharCode(..)</code> is ES6's <code>String.fromCodePoint(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x107</span> );      <span class="pl-c">// ""</span>

<span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x1d49e</span> );    <span class="pl-c">// ""</span></pre></div>

<p>So wait, can we just combine <code>String.fromCodePoint(..)</code> and <code>codePointAt(..)</code> to get a better version of a Unicode-aware <code>charAt(..)</code> from earlier? Yep!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

<span class="pl-c1">String</span>.fromCodePoint( s1.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// ""</span>

<span class="pl-c1">String</span>.fromCodePoint( s2.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// ""</span>

<span class="pl-c1">String</span>.fromCodePoint( s3.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// ""</span></pre></div>

<p>There's quite a few other string methods we haven't addressed here, including <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring(..)</code>, <code>indexOf(..)</code>, <code>slice(..)</code>, and a dozen others. None of these have been changed or augmented for full Unicode awareness, so you should be very careful -- probably just avoid them! -- when working with strings containing astral symbols.</p>

<p>There are also several string methods that use regular expressions for their behavior, like <code>replace(..)</code> and <code>match(..)</code>. Thankfully, ES6 brings Unicode awareness to regular expressions, as we covered in "Unicode Flag" earlier in this chapter.</p>

<p>OK, there we have it! JavaScript's Unicode string support is significantly better over pre-ES6 (though still not perfect) with the various additions we've just covered.</p>

<h3><a id="user-content-unicode-identifier-names" class="anchor" href="#unicode-identifier-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Identifier Names</h3>

<p>Unicode can also be used in identifier names (variables, properties, etc.). Prior to ES6, you could do this with Unicode-escapes, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> \u03A9 <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// same as: var  = 42;</span></pre></div>

<p>As of ES6, you can also use the earlier explained code point escape syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> \u{2B400} <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// same as: var  = 42;</span></pre></div>

<p>There's a complex set of rules around exactly which Unicode characters are allowed. Furthermore, some are allowed only if they're not the first character of the identifier name.</p>

<p><strong>Note:</strong> Mathias Bynens has a great post (<a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">https://mathiasbynens.be/notes/javascript-identifiers-es6</a>) on all the nitty-gritty details.</p>

<p>The reasons for using such unusual characters in identifier names are rather rare and academic. You typically won't be best served by writing code that relies on these esoteric capabilities.</p>

<h2><a id="user-content-symbols" class="anchor" href="#symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols</h2>

<p>With ES6, for the first time in quite a while, a new primitive type has been added to JavaScript: the <code>symbol</code>. Unlike the other primitive types, however, symbols don't have a literal form.</p>

<p>Here's how you create a symbol:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> sym <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>some optional description<span class="pl-pds">"</span></span> );

<span class="pl-k">typeof</span> sym;     <span class="pl-c">// "symbol"</span></pre></div>

<p>Some things to note:</p>

<ul>
<li>You cannot and should not use <code>new</code> with <code>Symbol(..)</code>. It's not a constructor, nor are you producing an object.</li>
<li>The parameter passed to <code>Symbol(..)</code> is optional. If passed, it should be a string that gives a friendly description for the symbol's purpose.</li>
<li>The <code>typeof</code> output is a new value (<code>"symbol"</code>) that is the primary way to identify a symbol.</li>
</ul>

<p>The description, if provided, is solely used for the stringification representation of the symbol:</p>

<div class="highlight highlight-source-js"><pre>sym.<span class="pl-c1">toString</span>();     <span class="pl-c">// "Symbol(some optional description)"</span></pre></div>

<p>Similar to how primitive string values are not instances of <code>String</code>, symbols are also not instances of <code>Symbol</code>. If, for some reason, you want to construct a boxed wrapper object form of a symbol value, you can do the following:</p>

<div class="highlight highlight-source-js"><pre>sym <span class="pl-k">instanceof</span> Symbol;      <span class="pl-c">// false</span>

<span class="pl-k">var</span> symObj <span class="pl-k">=</span> <span class="pl-c1">Object</span>( sym );
symObj <span class="pl-k">instanceof</span> Symbol;   <span class="pl-c">// true</span>

symObj.<span class="pl-c1">valueOf</span>() <span class="pl-k">===</span> sym;   <span class="pl-c">// true</span></pre></div>

<p><strong>Note:</strong> <code>symObj</code> in this snippet is interchangeable with <code>sym</code>; either form can be used in all places symbols are utilized. There's not much reason to use the boxed wrapper object form (<code>symObj</code>) instead of the primitive form (<code>sym</code>). Keeping with similar advice for other primitives, it's probably best to prefer <code>sym</code> over <code>symObj</code>.</p>

<p>The internal value of a symbol itself -- referred to as its <code>name</code> -- is hidden from the code and cannot be obtained. You can think of this symbol value as an automatically generated, unique (within your application) string value.</p>

<p>But if the value is hidden and unobtainable, what's the point of having a symbol at all?</p>

<p>The main point of a symbol is to create a string-like value that can't collide with any other value. So, for example, consider using a symbol as a constant representing an event name:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">EVT_LOGIN</span> <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>event.login<span class="pl-pds">"</span></span> );</pre></div>

<p>You'd then use <code>EVT_LOGIN</code> in place of a generic string literal like <code>"event.login"</code>:</p>

<div class="highlight highlight-source-js"><pre>evthub.listen( <span class="pl-c1">EVT_LOGIN</span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>The benefit here is that <code>EVT_LOGIN</code> holds a value that cannot be duplicated (accidentally or otherwise) by any other value, so it is impossible for there to be any confusion of which event is being dispatched or handled.</p>

<p><strong>Note:</strong> Under the covers, the <code>evthub</code> utility assumed in the previous snippet would almost certainly be using the symbol value from the <code>EVT_LOGIN</code> argument directly as the property/key in some internal object (hash) that tracks event handlers. If <code>evthub</code> instead needed to use the symbol value as a real string, it would need to explicitly coerce with <code>String(..)</code> or <code>toString()</code>, as implicit string coercion of symbols is not allowed.</p>

<p>You may use a symbol directly as a property name/key in an object, such as a special property that you want to treat as hidden or meta in usage. It's important to know that although you intend to treat it as such, it is not <em>actually</em> a hidden or untouchable property.</p>

<p>Consider this module that implements the <em>singleton</em> pattern behavior -- that is, it only allows itself to be created once:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">INSTANCE</span> <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>instance<span class="pl-pds">"</span></span> );

<span class="pl-k">function</span> <span class="pl-en">HappyFace</span>() {
    <span class="pl-k">if</span> (HappyFace[<span class="pl-c1">INSTANCE</span>]) <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>];

    <span class="pl-k">function</span> <span class="pl-en">smile</span>() { .. }

    <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>] <span class="pl-k">=</span> {
        smile<span class="pl-k">:</span> smile
    };
}

<span class="pl-k">var</span> me <span class="pl-k">=</span> HappyFace(),
    you <span class="pl-k">=</span> HappyFace();

me <span class="pl-k">===</span> you;         <span class="pl-c">// true</span></pre></div>

<p>The <code>INSTANCE</code> symbol value here is a special, almost hidden, meta-like property stored statically on the <code>HappyFace()</code> function object.</p>

<p>It could alternatively have been a plain old property like <code>__instance</code>, and the behavior would have been identical. The usage of a symbol simply improves the metaprogramming style, keeping this <code>INSTANCE</code> property set apart from any other normal properties.</p>

<h3><a id="user-content-symbol-registry" class="anchor" href="#symbol-registry" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbol Registry</h3>

<p>One mild downside to using symbols as in the last few examples is that the <code>EVT_LOGIN</code> and <code>INSTANCE</code> variables had to be stored in an outer scope (perhaps even the global scope), or otherwise somehow stored in a publicly available location, so that all parts of the code that need to use the symbols can access them.</p>

<p>To aid in organizing code with access to these symbols, you can create symbol values with the <em>global symbol registry</em>. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">EVT_LOGIN</span> <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>event.login<span class="pl-pds">"</span></span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">EVT_LOGIN</span> );       <span class="pl-c">// Symbol(event.login)</span></pre></div>

<p>And:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">HappyFace</span>() {
    <span class="pl-k">const</span> <span class="pl-c1">INSTANCE</span> <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>instance<span class="pl-pds">"</span></span> );

    <span class="pl-k">if</span> (HappyFace[<span class="pl-c1">INSTANCE</span>]) <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>];

    <span class="pl-c">// ..</span>

    <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>] <span class="pl-k">=</span> { .. };
}</pre></div>

<p><code>Symbol.for(..)</code> looks in the global symbol registry to see if a symbol is already stored with the provided description text, and returns it if so. If not, it creates one to return. In other words, the global symbol registry treats symbol values, by description text, as singletons themselves.</p>

<p>But that also means that any part of your application can retrieve the symbol from the registry using <code>Symbol.for(..)</code>, as long as the matching description name is used.</p>

<p>Ironically, symbols are basically intended to replace the use of <em>magic strings</em> (arbitrary string values given special meaning) in your application. But you precisely use <em>magic</em> description string values to uniquely identify/locate them in the global symbol registry!</p>

<p>To avoid accidental collisions, you'll probably want to make your symbol descriptions quite unique. One easy way of doing that is to include prefix/context/namespacing information in them.</p>

<p>For example, consider a utility such as the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">extractValues</span>(<span class="pl-smi">str</span>) {
    <span class="pl-k">var</span> key <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>extractValues.parse<span class="pl-pds">"</span></span> ),
        re <span class="pl-k">=</span> extractValues[key] <span class="pl-k">||</span>
<span class="pl-sr">            <span class="pl-pds">/</span><span class="pl-c1">[<span class="pl-k">^</span>=&amp;]</span><span class="pl-k">+?</span>=(<span class="pl-c1">[<span class="pl-k">^</span>&amp;]</span><span class="pl-k">+?</span>)(?=&amp;<span class="pl-k">|</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>g</span>,
        values <span class="pl-k">=</span> [], match;

    <span class="pl-k">while</span> (match <span class="pl-k">=</span> re.<span class="pl-c1">exec</span>( str )) {
        values.<span class="pl-c1">push</span>( match[<span class="pl-c1">1</span>] );
    }

    <span class="pl-k">return</span> values;
}</pre></div>

<p>We use the magic string value <code>"extractValues.parse"</code> because it's quite unlikely that any other symbol in the registry would ever collide with that description.</p>

<p>If a user of this utility wants to override the parsing regular expression, they can also use the symbol registry:</p>

<div class="highlight highlight-source-js"><pre>extractValues[Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>extractValues.parse<span class="pl-pds">"</span></span> )] <span class="pl-k">=</span>
<span class="pl-sr">    <span class="pl-pds">/</span><span class="pl-c1">..</span>some pattern<span class="pl-c1">..</span><span class="pl-pds">/</span>g</span>;

extractValues( <span class="pl-s"><span class="pl-pds">"</span>..some string..<span class="pl-pds">"</span></span> );</pre></div>

<p>Aside from the assistance the symbol registry provides in globally storing these values, everything we're seeing here could have been done by just actually using the magic string <code>"extractValues.parse"</code> as the key, rather than the symbol. The improvements exist at the metaprogramming level more than the functional level.</p>

<p>You may have occasion to use a symbol value that has been stored in the registry to look up what description text (key) it's stored under. For example, you may need to signal to another part of your application how to locate a symbol in the registry because you cannot pass the symbol value itself.</p>

<p>You can retrieve a registered symbol's description text (key) using <code>Symbol.keyFor(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>something cool<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> desc <span class="pl-k">=</span> Symbol.keyFor( s );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( desc );            <span class="pl-c">// "something cool"</span>

<span class="pl-c">// get the symbol from the registry again</span>
<span class="pl-k">var</span> s2 <span class="pl-k">=</span> Symbol.for( desc );

s2 <span class="pl-k">===</span> s;                       <span class="pl-c">// true</span></pre></div>

<h3><a id="user-content-symbols-as-object-properties" class="anchor" href="#symbols-as-object-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols as Object Properties</h3>

<p>If a symbol is used as a property/key of an object, it's stored in a special way so that the property will not show up in a normal enumeration of the object's properties:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    [ Symbol( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ) ]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    baz<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

<span class="pl-c1">Object</span>.getOwnPropertyNames( o );    <span class="pl-c">// [ "foo","baz" ]</span></pre></div>

<p>To retrieve an object's symbol properties:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [ Symbol(bar) ]</span></pre></div>

<p>This makes it clear that a property symbol is not actually hidden or inaccessible, as you can always see it in the <code>Object.getOwnPropertySymbols(..)</code> list.</p>

<h4><a id="user-content-built-in-symbols" class="anchor" href="#built-in-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Built-In Symbols</h4>

<p>ES6 comes with a number of predefined built-in symbols that expose various meta behaviors on JavaScript object values. However, these symbols are <em>not</em> registered in the global symbol registry, as one might expect.</p>

<p>Instead, they're stored as properties on the <code>Symbol</code> function object. For example, in the "<code>for..of</code>" section earlier in this chapter, we introduced the <code>Symbol.iterator</code> value:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

a[Symbol.iterator];         <span class="pl-c">// native function</span></pre></div>

<p>The specification uses the <code>@@</code> prefix notation to refer to the built-in symbols, the most common ones being: <code>@@iterator</code>, <code>@@toStringTag</code>, <code>@@toPrimitive</code>. Several others are defined as well, though they probably won't be used as often.</p>

<p><strong>Note:</strong> See "Well Known Symbols" in Chapter 7 for detailed information about how these built-in symbols are used for meta programming purposes.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 adds a heap of new syntax forms to JavaScript, so there's plenty to learn!</p>

<p>Most of these are designed to ease the pain points of common programming idioms, such as setting default values to function parameters and gathering the "rest" of the parameters into an array. Destructuring is a powerful tool for more concisely expressing assignments of values from arrays and nested objects.</p>

<p>While features like <code>=&gt;</code> arrow functions appear to also be all about shorter and nicer-looking syntax, they actually have very specific behaviors that you should intentionally use only in appropriate situations.</p>

<p>Expanded Unicode support, new tricks for regular expressions, and even a new primitive <code>symbol</code> type round out the syntactic evolution of ES6.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-3-organization" class="anchor" href="#chapter-3-organization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3: Organization</h1>

<p>It's one thing to write JS code, but it's another to properly organize it. Utilizing common patterns for organization and reuse goes a long way to improving the readability and understandability of your code. Remember: code is at least as much about communicating to other developers as it is about feeding the computer instructions.</p>

<p>ES6 has several important features that help signficantly improve these patterns, including: iterators, generators, modules, and classes.</p>

<h2><a id="user-content-iterators" class="anchor" href="#iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterators</h2>

<p>An <em>iterator</em> is a structured pattern for pulling information from a source in one-at-a-time fashion. This pattern has been around programming for a long time. And to be sure, JS developers have been ad hoc designing and implementing iterators in JS programs since before anyone can remember, so it's not at all a new topic.</p>

<p>What ES6 has done is introduce an implicit standardized interface for iterators. Many of the built-in data structures in JavaScript will now expose an iterator implementing this standard. And you can also construct your own iterators adhering to the same standard, for maximal interoperability.</p>

<p>Iterators are a way of organizing ordered, sequential, pull-based consumption of data.</p>

<p>For example, you may implement a utility that produces a new unique identifier each time it's requested. Or you may produce an infinite series of values that rotate through a fixed list, in round-robin fashion. Or you could attach an iterator to a database query result to pull out new rows one at a time.</p>

<p>Although they have not commonly been used in JS in such a manner, iterators can also be thought of as controlling behavior one step at a time. This can be illustrated quite clearly when considering generators (see "Generators" later in this chapter), though you can certainly do the same without generators.</p>

<h3><a id="user-content-interfaces" class="anchor" href="#interfaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interfaces</h3>

<p>At the time of this writing, ES6 section 25.1.1.2 (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-iterator-interface">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface</a>) details the <code>Iterator</code> interface as having the following requirement:</p>

<pre><code>Iterator [required]
    next() {method}: retrieves next IteratorResult
</code></pre>

<p>There are two optional members that some iterators are extended with:</p>

<pre><code>Iterator [optional]
    return() {method}: stops iterator and returns IteratorResult
    throw() {method}: signals error and returns IteratorResult
</code></pre>

<p>The <code>IteratorResult</code> interface is specified as:</p>

<pre><code>IteratorResult
    value {property}: current iteration value or final return value
        (optional if `undefined`)
    done {property}: boolean, indicates completion status
</code></pre>

<p><strong>Note:</strong> I call these interfaces implicit not because they're not explicitly called out in the specification -- they are! -- but because they're not exposed as direct objects accessible to code. JavaScript does not, in ES6, support any notion of "interfaces," so adherence for your own code is purely conventional. However, wherever JS expects an iterator -- a <code>for..of</code> loop, for instance -- what you provide must adhere to these interfaces or the code will fail.</p>

<p>There's also an <code>Iterable</code> interface, which describes objects that must be able to produce iterators:</p>

<pre><code>Iterable
    @@iterator() {method}: produces an Iterator
</code></pre>

<p>If you recall from "Built-In Symbols" in Chapter 2, <code>@@iterator</code> is the special built-in symbol representing the method that can produce iterator(s) for the object.</p>

<h4><a id="user-content-iteratorresult" class="anchor" href="#iteratorresult" aria-hidden="true"><span class="octicon octicon-link"></span></a>IteratorResult</h4>

<p>The <code>IteratorResult</code> interface specifies that the return value from any iterator operation will be an object of the form:</p>

<div class="highlight highlight-source-js"><pre>{ value<span class="pl-k">:</span> .. , done<span class="pl-k">:</span> <span class="pl-c1">true</span> <span class="pl-k">/</span> <span class="pl-c1">false</span> }</pre></div>

<p>Built-in iterators will always return values of this form, but more properties are, of course, allowed to be present on the return value, as necessary.</p>

<p>For example, a custom iterator may add additional metadata to the result object (e.g., where the data came from, how long it took to retrieve, cache expiration length, frequency for the appropriate next request, etc.).</p>

<p><strong>Note:</strong> Technically, <code>value</code> is optional if it would otherwise be considered absent or unset, such as in the case of the value <code>undefined</code>. Because accessing <code>res.value</code> will produce <code>undefined</code> whether it's present with that value or absent entirely, the presence/absence of the property is more an implementation detail or an optimization (or both), rather than a functional issue.</p>

<h3><a id="user-content-next-iteration" class="anchor" href="#next-iteration" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>next()</code> Iteration</h3>

<p>Let's look at an array, which is an iterable, and the iterator it can produce to consume its values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> it <span class="pl-k">=</span> arr[Symbol.iterator]();

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 1, done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 2, done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 3, done: false }</span>

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Each time the method located at <code>Symbol.iterator</code> (see Chapters 2 and 7) is invoked on this <code>arr</code> value, it will produce a new fresh iterator. Most structures will do the same, including all the built-in data structures in JS.</p>

<p>However, a structure like an event queue consumer might only ever produce a single iterator (singleton pattern). Or a structure might only allow one unique iterator at a time, requiring the current one to be completed before a new one can be created.</p>

<p>The <code>it</code> iterator in the previous snippet doesn't report <code>done: true</code> when you receive the <code>3</code> value. You have to call <code>next()</code> again, in essence going beyond the end of the array's values, to get the complete signal <code>done: true</code>. It may not be clear why until later in this section, but that design decision will typically be considered a best practice.</p>

<p>Primitive string values are also iterables by default:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> it <span class="pl-k">=</span> greeting[Symbol.iterator]();

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: "h", done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: "e", done: false }</span>
..</pre></div>

<p><strong>Note:</strong> Technically, the primitive value itself isn't iterable, but thanks to "boxing", <code>"hello world"</code> is coerced/converted to its <code>String</code> object wrapper form, which <em>is</em> an iterable. See the <em>Types &amp; Grammar</em> title of this series for more information.</p>

<p>ES6 also includes several new data structures, called collections (see Chapter 5). These collections are not only iterables themselves, but they also provide API method(s) to generate an iterator, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();
m.set( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span> );
m.set( { cool<span class="pl-k">:</span> <span class="pl-c1">true</span> }, <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> m[Symbol.iterator]();
<span class="pl-k">var</span> it2 <span class="pl-k">=</span> m.entries();

it1.<span class="pl-c1">next</span>();     <span class="pl-c">// { value: [ "foo", 42 ], done: false }</span>
it2.<span class="pl-c1">next</span>();     <span class="pl-c">// { value: [ "foo", 42 ], done: false }</span>
..</pre></div>

<p>The <code>next(..)</code> method of an iterator can optionally take one or more arguments. The built-in iterators mostly do not exercise this capability, though a generator's iterator definitely does (see "Generators" later in this chapter).</p>

<p>By general convention, including all the built-in iterators, calling <code>next(..)</code> on an iterator that's already been exhausted is not an error, but will simply continue to return the result <code>{ value: undefined, done: true }</code>.</p>

<h3><a id="user-content-optional-return-and-throw" class="anchor" href="#optional-return-and-throw" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optional: <code>return(..)</code> and <code>throw(..)</code></h3>

<p>The optional methods on the iterator interface -- <code>return(..)</code> and <code>throw(..)</code> -- are not implemented on most of the built-in iterators. However, they definitely do mean something in the context of generators, so see "Generators" for more specific information.</p>

<p><code>return(..)</code> is defined as sending a signal to an iterator that the consuming code is complete and will not be pulling any more values from it. This signal can be used to notify the producer (the iterator responding to <code>next(..)</code> calls) to perform any cleanup it may need to do, such as releasing/closing network, database, or file handle resources.</p>

<p>If an iterator has a <code>return(..)</code> present and any condition occurs that can automatically be interpreted as abnormal or early termination of consuming the iterator, <code>return(..)</code> will automatically be called. You can call <code>return(..)</code> manually as well.</p>

<p><code>return(..)</code> will return an <code>IteratorResult</code> object just like <code>next(..)</code> does. In general, the optional value you send to <code>return(..)</code> would be sent back as <code>value</code> in this <code>IteratorResult</code>, though there are nuanced cases where that might not be true.</p>

<p><code>throw(..)</code> is used to signal an exception/error to an iterator, which possibly may be used differently by the iterator than the completion signal implied by <code>return(..)</code>. It does not necessarily imply a complete stop of the iterator as <code>return(..)</code> generally does.</p>

<p>For example, with generator iterators, <code>throw(..)</code> actually injects a thrown exception into the generator's paused execution context, which can be caught with a <code>try..catch</code>. An uncaught <code>throw(..)</code> exception would end up abnormally aborting the generator's iterator.</p>

<p><strong>Note:</strong> By general convention, an iterator should not produce any more results after having called <code>return(..)</code> or <code>throw(..)</code>.</p>

<h3><a id="user-content-iterator-loop" class="anchor" href="#iterator-loop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Loop</h3>

<p>As we covered in the "<code>for..of</code>" section in Chapter 2, the ES6 <code>for..of</code> loop directly consumes a conforming iterable.</p>

<p>If an iterator is also an iterable, it can be used directly with the <code>for..of</code> loop. You make an iterator an iterable by giving it a <code>Symbol.iterator</code> method that simply returns the iterator itself:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> {
    <span class="pl-c">// make the `it` iterator an iterable</span>
    [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

    <span class="pl-en">next</span>() { .. },
    ..
};

it[Symbol.iterator]() <span class="pl-k">===</span> it;       <span class="pl-c">// true</span></pre></div>

<p>Now we can consume the <code>it</code> iterator with a <code>for..of</code> loop:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> it) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}</pre></div>

<p>To fully understand how such a loop works, recall the <code>for</code> equivalent of a <code>for..of</code> loop from Chapter 2:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v, res; (res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>()) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>res.done; ) {
    v <span class="pl-k">=</span> res.<span class="pl-c1">value</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}</pre></div>

<p>If you look closely, you'll see that <code>it.next()</code> is called before each iteration, and then <code>res.done</code> is consulted. If <code>res.done</code> is <code>true</code>, the expression evaluates to <code>false</code> and the iteration doesn't occur.</p>

<p>Recall earlier that we suggested iterators should in general not return <code>done: true</code> along with the final intended value from the iterator. Now you can see why.</p>

<p>If an iterator returned <code>{ done: true, value: 42 }</code>, the <code>for..of</code> loop would completely discard the <code>42</code> value and it'd be lost. For this reason, assuming that your iterator may be consumed by patterns like the <code>for..of</code> loop or its manual <code>for</code> equivalent, you should probably wait to return <code>done: true</code> for signaling completion until after you've already returned all relevant iteration values.</p>

<p><strong>Warning:</strong> You can, of course, intentionally design your iterator to return some relevant <code>value</code> at the same time as returning <code>done: true</code>. But don't do this unless you've documented that as the case, and thus implicitly forced consumers of your iterator to use a different pattern for iteration than is implied by <code>for..of</code> or its manual equivalent we depicted.</p>

<h3><a id="user-content-custom-iterators" class="anchor" href="#custom-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom Iterators</h3>

<p>In addition to the standard built-in iterators, you can make your own! All it takes to make them interoperate with ES6's consumption facilities (e.g., the <code>for..of</code> loop and the <code>...</code> operator) is to adhere to the proper interface(s).</p>

<p>Let's try constructing an iterator that produces the infinite series of numbers in the Fibonacci sequence:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> Fib <span class="pl-k">=</span> {
    [Symbol.iterator]() {
        <span class="pl-k">var</span> n1 <span class="pl-k">=</span> <span class="pl-c1">1</span>, n2 <span class="pl-k">=</span> <span class="pl-c1">1</span>;

        <span class="pl-k">return</span> {
            <span class="pl-c">// make the iterator an iterable</span>
            [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

            <span class="pl-en">next</span>() {
                <span class="pl-k">var</span> current <span class="pl-k">=</span> n2;
                n2 <span class="pl-k">=</span> n1;
                n1 <span class="pl-k">=</span> n1 <span class="pl-k">+</span> current;
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> current, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
            },

            <span class="pl-k">return</span>(v) {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>(
                    <span class="pl-s"><span class="pl-pds">"</span>Fibonacci sequence abandoned.<span class="pl-pds">"</span></span>
                );
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> v, done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
            }
        };
    }
};

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> Fib) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );

    <span class="pl-k">if</span> (v <span class="pl-k">&gt;</span> <span class="pl-c1">50</span>) <span class="pl-k">break</span>;
}
<span class="pl-c">// 1 1 2 3 5 8 13 21 34 55</span>
<span class="pl-c">// Fibonacci sequence abandoned.</span></pre></div>

<p><strong>Warning:</strong> If we hadn't inserted the <code>break</code> condition, this <code>for..of</code> loop would have run forever, which is probably not the desired result in terms of breaking your program!</p>

<p>The <code>Fib[Symbol.iterator]()</code> method when called returns the iterator object with <code>next()</code> and <code>return(..)</code> methods on it. State is maintained via <code>n1</code> and <code>n2</code> variables, which are kept by the closure.</p>

<p>Let's <em>next</em> consider an iterator that is designed to run through a series (aka a queue) of actions, one item at a time:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> tasks <span class="pl-k">=</span> {
    [Symbol.iterator]() {
        <span class="pl-k">var</span> steps <span class="pl-k">=</span> <span class="pl-v">this</span>.actions.<span class="pl-c1">slice</span>();

        <span class="pl-k">return</span> {
            <span class="pl-c">// make the iterator an iterable</span>
            [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

            <span class="pl-en">next</span>(...<span class="pl-smi">args</span>) {
                <span class="pl-k">if</span> (steps.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                    <span class="pl-k">let</span> res <span class="pl-k">=</span> steps.<span class="pl-c1">shift</span>()( ...args );
                    <span class="pl-k">return</span> { value<span class="pl-k">:</span> res, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
                }
                <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> { done<span class="pl-k">:</span> <span class="pl-c1">true</span> }
                }
            },

            <span class="pl-k">return</span>(v) {
                steps.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> v, done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
            }
        };
    },
    actions<span class="pl-k">:</span> []
};</pre></div>

<p>The iterator on <code>tasks</code> steps through functions found in the <code>actions</code> array property, if any, and executes them one at a time, passing in whatever arguments you pass to <code>next(..)</code>, and returning any return value to you in the standard <code>IteratorResult</code> object.</p>

<p>Here's how we could could use this <code>tasks</code> queue:</p>

<div class="highlight highlight-source-js"><pre>tasks.actions.<span class="pl-c1">push</span>(
    <span class="pl-k">function</span> <span class="pl-en">step1</span>(<span class="pl-smi">x</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 1:<span class="pl-pds">"</span></span>, x );
        <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    },
    <span class="pl-k">function</span> <span class="pl-en">step2</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 2:<span class="pl-pds">"</span></span>, x, y );
        <span class="pl-k">return</span> x <span class="pl-k">+</span> (y <span class="pl-k">*</span> <span class="pl-c1">2</span>);
    },
    <span class="pl-k">function</span> <span class="pl-en">step3</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 3:<span class="pl-pds">"</span></span>, x, y, z );
        <span class="pl-k">return</span> (x <span class="pl-k">*</span> y) <span class="pl-k">+</span> z;
    }
);

<span class="pl-k">var</span> it <span class="pl-k">=</span> tasks[Symbol.iterator]();

it.<span class="pl-c1">next</span>( <span class="pl-c1">10</span> );          <span class="pl-c">// step 1: 10</span>
                        <span class="pl-c">// { value:   20, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">20</span>, <span class="pl-c1">50</span> );      <span class="pl-c">// step 2: 20 50</span>
                        <span class="pl-c">// { value:  120, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">120</span> ); <span class="pl-c">// step 3: 20 50 120</span>
                        <span class="pl-c">// { value: 1120, done: false }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { done: true }</span></pre></div>

<p>This particular usage reinforces that iterators can be a pattern for organizing functionality, not just data. It's also reminiscent of what we'll see with generators in the next section.</p>

<p>You could even get creative and define an iterator that represents meta operations on a single piece of data. For example, we could define an iterator for numbers that by default ranges from <code>0</code> up to (or down to, for negative numbers) the number in question.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Number</span>.<span class="pl-c1">prototype</span>[Symbol.iterator]) {
    <span class="pl-c1">Object</span>.defineProperty(
        <span class="pl-c1">Number</span>.<span class="pl-c1">prototype</span>,
        Symbol.iterator,
        {
            writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
            configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
            enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
            <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">iterator</span>(){
                <span class="pl-k">var</span> i, inc, done <span class="pl-k">=</span> <span class="pl-c1">false</span>, top <span class="pl-k">=</span> <span class="pl-k">+</span><span class="pl-v">this</span>;

                <span class="pl-c">// iterate positively or negatively?</span>
                inc <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">*</span> (top <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>);

                <span class="pl-k">return</span> {
                    <span class="pl-c">// make the iterator itself an iterable!</span>
                    [Symbol.iterator](){ <span class="pl-k">return</span> <span class="pl-v">this</span>; },

                    <span class="pl-en">next</span>() {
                        <span class="pl-k">if</span> (<span class="pl-k">!</span>done) {
                            <span class="pl-c">// initial iteration always 0</span>
                            <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                                i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                            }
                            <span class="pl-c">// iterating positively</span>
                            <span class="pl-k">else</span> <span class="pl-k">if</span> (top <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
                                i <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">min</span>(top,i <span class="pl-k">+</span> inc);
                            }
                            <span class="pl-c">// iterating negatively</span>
                            <span class="pl-k">else</span> {
                                i <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">max</span>(top,i <span class="pl-k">+</span> inc);
                            }

                            <span class="pl-c">// done after this iteration?</span>
                            <span class="pl-k">if</span> (i <span class="pl-k">==</span> top) done <span class="pl-k">=</span> <span class="pl-c1">true</span>;

                            <span class="pl-k">return</span> { value<span class="pl-k">:</span> i, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
                        }
                        <span class="pl-k">else</span> {
                            <span class="pl-k">return</span> { done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
                        }
                    }
                };
            }
        }
    );
}</pre></div>

<p>Now, what tricks does this creativity afford us?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">of</span> <span class="pl-c1">3</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}
<span class="pl-c">// 0 1 2 3</span>

[...<span class="pl-k">-</span><span class="pl-c1">3</span>];                <span class="pl-c">// [0,-1,-2,-3]</span></pre></div>

<p>Those are some fun tricks, though the practical utility is somewhat debatable. But then again, one might wonder why ES6 didn't just ship with such a minor but delightful feature easter egg!?</p>

<p>I'd be remiss if I didn't at least remind you that extending native prototypes as I'm doing in the previous snippet is something you should only do with caution and awareness of potential hazards.</p>

<p>In this case, the chances that you'll have a collision with other code or even a future JS feature is probably exceedingly low. But just beware of the slight possibility. And document what you're doing verbosely for posterity's sake.</p>

<p><strong>Note:</strong> I've expounded on this particular technique in this blog post (<a href="http://blog.getify.com/iterating-es6-numbers/">http://blog.getify.com/iterating-es6-numbers/</a>) if you want more details. And this comment (<a href="http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294">http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294</a>) even suggests a similar trick but for making string character ranges.</p>

<h3><a id="user-content-iterator-consumption" class="anchor" href="#iterator-consumption" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Consumption</h3>

<p>We've already shown consuming an iterator item by item with the <code>for..of</code> loop. But there are other ES6 structures that can consume iterators.</p>

<p>Let's consider the iterator attached to this array (though any iterator we choose would have the following behaviors):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];</pre></div>

<p>The <code>...</code> spread operator fully exhausts an iterator. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>,<span class="pl-smi">w</span>,<span class="pl-smi">p</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y <span class="pl-k">+</span> z <span class="pl-k">+</span> w <span class="pl-k">+</span> p );
}

foo( ...a );            <span class="pl-c">// 15</span></pre></div>

<p><code>...</code> can also spread an iterator inside an array:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">0</span>, ...a, <span class="pl-c1">6</span> ];
b;                      <span class="pl-c">// [0,1,2,3,4,5,6]</span></pre></div>

<p>Array destructuring (see "Destructuring" in Chapter 2) can partially or completely (if paired with a <code>...</code> rest/gather operator) consume an iterator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> a[Symbol.iterator]();

<span class="pl-k">var</span> [x,y] <span class="pl-k">=</span> it;         <span class="pl-c">// take just the first two elements from `it`</span>
<span class="pl-k">var</span> [z, ...w] <span class="pl-k">=</span> it;     <span class="pl-c">// take the third, then the rest all at once</span>

<span class="pl-c">// is `it` fully exhausted? Yep.</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span>

x;                      <span class="pl-c">// 1</span>
y;                      <span class="pl-c">// 2</span>
z;                      <span class="pl-c">// 3</span>
w;                      <span class="pl-c">// [4,5]</span></pre></div>

<h2><a id="user-content-generators" class="anchor" href="#generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators</h2>

<p>All functions run to completion, right? In other words, once a function starts running, it finishes before anything else can interrupt.</p>

<p>At least that's how it's been for the whole history of JavaScript up to this point. As of ES6, a new somewhat exotic form of function is being introduced, called a generator. A generator can pause itself in mid-execution, and can be resumed either right away or at a later time. So it clearly does not hold the run-to-completion guarantee that normal functions do.</p>

<p>Moreover, each pause/resume cycle in mid-execution is an opportunity for two-way message passing, where the generator can return a value, and the controlling code that resumes it can send a value back in.</p>

<p>As with iterators in the previous section, there are multiple ways to think about what a generator is, or rather what it's most useful for. There's no one right answer, but we'll try to consider several angles.</p>

<p><strong>Note:</strong> See the <em>Async &amp; Performance</em> title of this series for more information about generators, and also see Chapter 4 of this current title.</p>

<h3><a id="user-content-syntax" class="anchor" href="#syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax</h3>

<p>The generator function is declared with this new syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// ..</span>
}</pre></div>

<p>The position of the <code>*</code> is not functionally relevant. The same declaration could be written as any of the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>()  { .. }
<span class="pl-k">function*</span> <span class="pl-en">foo</span>()  { .. }
<span class="pl-k">function</span> <span class="pl-k">*</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">function</span><span class="pl-k">*</span><span class="pl-en">foo</span>()   { .. }
..</pre></div>

<p>The <em>only</em> difference here is stylistic preference. Most other literature seems to prefer <code>function* foo(..) { .. }</code>. I prefer <code>function *foo(..) { .. }</code>, so that's how I'll present them for the rest of this title.</p>

<p>My reason is purely didactic in nature. In this text, when referring to a generator function, I will use <code>*foo(..)</code>, as opposed to <code>foo(..)</code> for a normal function. I observe that <code>*foo(..)</code> more closely matches the <code>*</code> positioning of <code>function *foo(..) { .. }</code>.</p>

<p>Moreover, as we saw in Chapter 2 with concise methods, there's a concise generator form in object literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> {
    <span class="pl-k">*</span><span class="pl-en">foo</span>() { .. }
};</pre></div>

<p>I would say that with concise generators, <code>*foo() { .. }</code> is rather more natural than <code>* foo() { .. }</code>. So that further argues for matching the consistency with <code>*foo()</code>.</p>

<p>Consistency eases understanding and learning.</p>

<h4><a id="user-content-executing-a-generator" class="anchor" href="#executing-a-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Executing a Generator</h4>

<p>Though a generator is declared with <code>*</code>, you still execute it like a normal function:</p>

<div class="highlight highlight-source-js"><pre>foo();</pre></div>

<p>You can still pass it arguments, as in:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-c">// ..</span>
}

foo( <span class="pl-c1">5</span>, <span class="pl-c1">10</span> );</pre></div>

<p>The major difference is that executing a generator, like <code>foo(5,10)</code> doesn't actually run the code in the generator. Instead, it produces an iterator that will control the generator to execute its code.</p>

<p>We'll come back to this later in "Iterator Control," but briefly:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

<span class="pl-c">// to start/advanced `*foo()`, call</span>
<span class="pl-c">// `it.next(..)`</span></pre></div>

<h4><a id="user-content-yield" class="anchor" href="#yield" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>yield</code></h4>

<p>Generators also have a new keyword you can use inside them, to signal the pause point: <code>yield</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">10</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

    <span class="pl-k">yield</span>;

    <span class="pl-k">var</span> z <span class="pl-k">=</span> x <span class="pl-k">+</span> y;
}</pre></div>

<p>In this <code>*foo()</code> generator, the operations on the first two lines would run at the beginning, then <code>yield</code> would pause the generator. If and when resumed, the last line of <code>*foo()</code> would run. <code>yield</code> can appear any number of times (or not at all, technically!) in a generator.</p>

<p>You can even put <code>yield</code> inside a loop, and it can represent a repeated pause point. In fact, a loop that never completes just means a generator that never completes, which is completely valid, and sometimes entirely what you need.</p>

<p><code>yield</code> is not just a pause point. It's an expression that sends out a value when pausing the generator. Here's a <code>while..true</code> loop in a generator that for each iteration <code>yield</code>s a new random number:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
        <span class="pl-k">yield</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();
    }
}</pre></div>

<p>The <code>yield ..</code> expression not only sends a value -- <code>yield</code> without a value is the same as <code>yield undefined</code> -- but also receives (e.g., is replaced by) the eventual resumption value. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">10</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}</pre></div>

<p>This generator will first <code>yield</code> out the value <code>10</code> when pausing itself. When you resume the generator -- using the <code>it.next(..)</code> we referred to earlier -- whatever value (if any) you resume with will replace/complete the whole <code>yield 10</code> expression, meaning that value will be assigned to the <code>x</code> variable.</p>

<p>A <code>yield ..</code> expression can appear anywhere a normal expression can. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> arr <span class="pl-k">=</span> [ <span class="pl-k">yield</span> <span class="pl-c1">1</span>, <span class="pl-k">yield</span> <span class="pl-c1">2</span>, <span class="pl-k">yield</span> <span class="pl-c1">3</span> ];
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( arr, <span class="pl-k">yield</span> <span class="pl-c1">4</span> );
}</pre></div>

<p><code>*foo()</code> here has four <code>yield ..</code> expressions. Each <code>yield</code> results in the generator pausing to wait for a resumption value that's then used in the various expression contexts.</p>

<p><code>yield</code> is not technically an operator, though when used like <code>yield 1</code> it sure looks like it. Because <code>yield</code> can be used all by itself as in <code>var x = yield;</code>, thinking of it as an operator can sometimes be confusing.</p>

<p>Technically, <code>yield ..</code> is of the same "expression precedence" -- similar conceptually to operator precedence -- as an assignment expression like <code>a = 3</code>. That means <code>yield ..</code> can basically appear anywhere <code>a = 3</code> can validly appear.</p>

<p>Let's illustrate the symmetry:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">3</span>;                  <span class="pl-c">// valid</span>
b <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;          <span class="pl-c">// invalid</span>
b <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> (a <span class="pl-k">=</span> <span class="pl-c1">3</span>);        <span class="pl-c">// valid</span>

<span class="pl-k">yield</span> <span class="pl-c1">3</span>;                <span class="pl-c">// valid</span>
a <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-k">yield</span> <span class="pl-c1">3</span>;        <span class="pl-c">// invalid</span>
a <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> (<span class="pl-k">yield</span> <span class="pl-c1">3</span>);      <span class="pl-c">// valid</span></pre></div>

<p><strong>Note:</strong> If you think about it, it makes a sort of conceptual sense that a <code>yield ..</code> expression would behave similar to an assignment expression. When a paused <code>yield</code> expression is resumed, it's completed/replaced by the resumption value in a way that's not terribly dissimilar from being "assigned" that value.</p>

<p>The takeaway: if you need <code>yield ..</code> to appear in a position where an assignment like <code>a = 3</code> would not itself be allowed, it needs to be wrapped in a <code>( )</code>.</p>

<p>Because of the low precedence of the <code>yield</code> keyword, almost any expression after a <code>yield ..</code> will be computed first before being sent with <code>yield</code>. Only the <code>...</code> spread operator and the <code>,</code> comma operator have lower precedence, meaning they'd bind after the <code>yield</code> has been evaluated.</p>

<p>So just like with multiple operators in normal statements, another case where <code>( )</code> might be needed is to override (elevate) the low precedence of <code>yield</code>, such as the difference between these expressions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">yield</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>;            <span class="pl-c">// same as `yield (2 + 3)`</span>

(<span class="pl-k">yield</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">3</span>;          <span class="pl-c">// `yield 2` first, then `+ 3`</span></pre></div>

<p>Just like <code>=</code> assignment, <code>yield</code> is also "right-associative," which means that multiple <code>yield</code> expressions in succession are treated as having been <code>( .. )</code> grouped from right to left. So, <code>yield yield yield 3</code> is treated as <code>yield (yield (yield 3))</code>. A "left-associative" interpretation like <code>((yield) yield) yield 3</code> would make no sense.</p>

<p>Just like with operators, it's a good idea to use <code>( .. )</code> grouping, even if not strictly required, to disambiguate your intent if <code>yield</code> is combined with other operators or <code>yield</code>s.</p>

<p><strong>Note:</strong> See the <em>Types &amp; Grammar</em> title of this series for more information about operator precedence and associativity.</p>

<h4><a id="user-content-yield-" class="anchor" href="#yield-" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>yield *</code></h4>

<p>In the same way that the <code>*</code> makes a <code>function</code> declaration into <code>function *</code> generator declaration, a <code>*</code> makes <code>yield</code> into <code>yield *</code>, which is a very different mechanism, called <em>yield delegation</em>. Grammatically, <code>yield *..</code> will behave the same as a <code>yield ..</code>, as discussed in the previous section.</p>

<p><code>yield * ..</code> requires an iterable; it then invokes that iterable's iterator, and delegates its own host generator's control to that iterator until it's exhausted. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-k">*</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
}</pre></div>

<p><strong>Note:</strong> As with the <code>*</code> position in a generator's declaration (discussed earlier), the <code>*</code> positioning in <code>yield *</code> expressions is stylistically up to you. Most other literature prefers <code>yield* ..</code>, but I prefer <code>yield *..</code>, for very symmetrical reasons as already discussed.</p>

<p>The <code>[1,2,3]</code> value produces an iterator that will step through its values, so the <code>*foo()</code> generator will yield those values out as it's consumed. Another way to illustrate the behavior is in yield delegating to another generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();
}</pre></div>

<p>The iterator produced when <code>*bar()</code> calls <code>*foo()</code> is delegated to via <code>yield *</code>, meaning whatever value(s) <code>*foo()</code> produces will be produced by <code>*bar()</code>.</p>

<p>Whereas with <code>yield ..</code> the completion value of the expression comes from resuming the generator with <code>it.next(..)</code>, the completion value of the <code>yield *..</code> expression comes from the return value (if any) from the delegated-to iterator.</p>

<p>Built-in iterators generally don't have return values, as we covered at the end of the "Iterator Loop" section earlier in this chapter. But if you define your own custom iterator (or generator), you can design it to <code>return</code> a value, which <code>yield *..</code> would capture:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    <span class="pl-k">return</span> <span class="pl-c1">4</span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>x:<span class="pl-pds">"</span></span>, x );
}

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> bar()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span>
<span class="pl-c">// x: 4</span></pre></div>

<p>While the <code>1</code>, <code>2</code>, and <code>3</code> values are <code>yield</code>ed out of <code>*foo()</code> and then out of <code>*bar()</code>, the <code>4</code> value returned from <code>*foo()</code> is the completion value of the <code>yield *foo()</code> expression, which then gets assigned to <code>x</code>.</p>

<p>Because <code>yield *</code> can call another generator (by way of delegating to its iterator), it can also perform a sort of generator recursion by calling itself:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) {
        x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

foo( <span class="pl-c1">1</span> );</pre></div>

<p>The result from <code>foo(1)</code> and then calling the iterator's <code>next()</code> to run it through its recursive steps will be <code>24</code>. The first <code>*foo(..)</code> run has <code>x</code> at value <code>1</code>, which is <code>x &lt; 3</code>. <code>x + 1</code> is passed recursively to <code>*foo(..)</code>, so <code>x</code> is then <code>2</code>. One more recursive call results in <code>x</code> of <code>3</code>.</p>

<p>Now, because <code>x &lt; 3</code> fails, the recursion stops, and <code>return 3 * 2</code> gives <code>6</code> back to the previous call's <code>yield *..</code> expression, which is then assigned to <code>x</code>. Another <code>return 6 * 2</code> returns <code>12</code> back to the previous call's <code>x</code>. Finally <code>12 * 2</code>, or <code>24</code>, is returned from the completed run of the <code>*foo(..)</code> generator.</p>

<h3><a id="user-content-iterator-control" class="anchor" href="#iterator-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Control</h3>

<p>Earlier, we briefly introduced the concept that generators are controlled by iterators. Let's fully dig into that now.</p>

<p>Recall the recursive <code>*foo(..)</code> from the previous section. Here's how we'd run it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) {
        x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-c1">1</span> );
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 24, done: true }</span></pre></div>

<p>In this case, the generator doesn't really ever pause, as there's no <code>yield ..</code> expression. Instead, <code>yield *</code> just keeps the current iteration step going via the recursive call. So, just one call to the iterator's <code>next()</code> function fully runs the generator.</p>

<p>Now let's consider a generator that will have multiple steps and thus multiple produced values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}</pre></div>

<p>We already know we can consume an iterator, even one attached to a generator like <code>*foo()</code>, with a <code>for..of</code> loop:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> foo()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span></pre></div>

<p><strong>Note:</strong> The <code>for..of</code> loop requires an iterable. A generator function reference (like <code>foo</code>) by itself is not an iterable; you must execute it with <code>foo()</code> to get the iterator (which is also an iterable, as we explained earlier in this chapter). You could theoretically extend the <code>GeneratorPrototype</code> (the prototype of all generator functions) with a <code>Symbol.iterator</code> function that essentially just does <code>return this()</code>. That would make the <code>foo</code> reference itself an iterable, which means <code>for (var v of foo) { .. }</code> (notice no <code>()</code> on <code>foo</code>) will work.</p>

<p>Let's instead iterate the generator manually:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 2, done: false }</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 3, done: false }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>If you look closely, there are three <code>yield</code> statements and four <code>next()</code> calls. That may seem like a strange mismatch. In fact, there will always be one more <code>next()</code> call than <code>yield</code> expression, assuming all are evaluated and the generator is fully run to completion.</p>

<p>But if you look at it from the opposite perspective (inside-out instead of outside-in), the matching between <code>yield</code> and <code>next()</code> makes more sense.</p>

<p>Recall that the <code>yield ..</code> expression will be completed by the value you resume the generator with. That means the argument you pass to <code>next(..)</code> completes whatever <code>yield ..</code> expression is currently paused waiting for a completion.</p>

<p>Let's illustrate this perspective this way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">var</span> z <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}</pre></div>

<p>In this snippet, each <code>yield ..</code> is sending a value out (<code>1</code>, <code>2</code>, <code>3</code>), but more directly, it's pausing the generator to wait for a value. In other words, it's almost like asking the question, "What value should I use here? I'll wait to hear back."</p>

<p>Now, here's how we control <code>*foo()</code> to start it up:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span></pre></div>

<p>That first <code>next()</code> call is starting up the generator from its initial paused state, and running it to the first <code>yield</code>. At the moment you call that first <code>next()</code>, there's no <code>yield ..</code> expression waiting for a completion. If you passed a value to that first <code>next()</code> call, it would currently just be thrown away, because no <code>yield</code> is waiting to receive such a value.</p>

<p><strong>Note:</strong> An early proposal for the "beyond ES6" timeframe <em>would</em> let you access a value passed to an initial <code>next(..)</code> call via a separate meta property (see Chapter 7) inside the generator.</p>

<p>Now, let's answer the currently pending question, "What value should I assign to <code>x</code>?" We'll answer it by sending a value to the <em>next</em> <code>next(..)</code> call:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 2, done: false }</span></pre></div>

<p>Now, the <code>x</code> will have the value <code>"foo"</code>, but we've also asked a new question, "What value should I assign to <code>y</code>?" And we answer:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 3, done: false }</span></pre></div>

<p>Answer given, another question asked. Final answer:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> );       <span class="pl-c">// "foo" "bar" "baz"</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Now it should be clearer how each <code>yield ..</code> "question" is answered by the <em>next</em> <code>next(..)</code> call, and so the "extra" <code>next()</code> call we observed is always just the initial one that starts everything going.</p>

<p>Let's put all those steps together:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

<span class="pl-c">// start up the generator</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-c">// answer first question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 2, done: false }</span>

<span class="pl-c">// answer second question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 3, done: false }</span>

<span class="pl-c">// answer third question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> );       <span class="pl-c">// "foo" "bar" "baz"</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>You can think of a generator as a producer of values, in which case each iteration is simply producing a value to be consumed.</p>

<p>But in a more general sense, perhaps it's appropriate to think of generators as controlled, progressive code execution, much like the <code>tasks</code> queue example from the earlier "Custom Iterators" section.</p>

<p><strong>Note:</strong> That perspective is exactly the motivation for how we'll revisit generators in Chapter 4. Specifically, there's no reason that <code>next(..)</code> has to be called right away after the previous <code>next(..)</code> finishes. While the generator's inner execution context is paused, the rest of the program continues unblocked, including the ability for asynchronous actions to control when the generator is resumed.</p>

<h3><a id="user-content-early-completion" class="anchor" href="#early-completion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Early Completion</h3>

<p>As we covered earlier in this chapter, the iterator attached to a generator supports the optional <code>return(..)</code> and <code>throw(..)</code> methods. Both of them have the effect of aborting a paused generator immediately.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

it.return( <span class="pl-c1">42</span> );        <span class="pl-c">// { value: 42, done: true }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p><code>return(x)</code> is kind of like forcing a <code>return x</code> to be processed at exactly that moment, such that you get the specified value right back. Once a generator is completed, either normally or early as shown, it no longer processes any code or returns any values.</p>

<p>In addition to <code>return(..)</code> being callable manually, it's also called automatically at the end of iteration by any of the ES6 constructs that consume iterators, such as the <code>for..of</code> loop and the <code>...</code> spread operator.</p>

<p>The purpose for this capability is so the generator can be notified if the controlling code is no longer going to iterate over it anymore, so that it can perhaps do any cleanup tasks (freeing up resources, resetting status, etc.). Identical to a normal function cleanup pattern, the main way to accomplish this is to use a <code>finally</code> clause:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
        <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
        <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    }
    <span class="pl-k">finally</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cleanup!<span class="pl-pds">"</span></span> );
    }
}

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> foo()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span>
<span class="pl-c">// cleanup!</span>

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>
it.return( <span class="pl-c1">42</span> );        <span class="pl-c">// cleanup!</span>
                        <span class="pl-c">// { value: 42, done: true }</span></pre></div>

<p><strong>Warning:</strong> Do not put a <code>yield</code> statement inside the <code>finally</code> clause! It's valid and legal, but it's a really terrible idea. It acts in a sense as deferring the completion of the <code>return(..)</code> call you made, as any <code>yield ..</code> expressions in the <code>finally</code> clause are respected to pause and send messages; you don't immediately get a completed generator as expected. There's basically no good reason to opt in to that crazy <em>bad part</em>, so avoid doing so!</p>

<p>In addition to the previous snippet showing how <code>return(..)</code> aborts the generator while still triggering the <code>finally</code> clause, it also demonstrates that a generator produces a whole new iterator each time it's called. In fact, you can use multiple iterators attached to the same generator concurrently:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> foo();
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 1, done: false }</span>
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 2, done: false }</span>

<span class="pl-k">var</span> it2 <span class="pl-k">=</span> foo();
it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 1, done: false }</span>

it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 3, done: false }</span>

it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 2, done: false }</span>
it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 3, done: false }</span>

it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: undefined, done: true }</span>
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<h4><a id="user-content-early-abort" class="anchor" href="#early-abort" aria-hidden="true"><span class="octicon octicon-link"></span></a>Early Abort</h4>

<p>Instead of calling <code>return(..)</code>, you can call <code>throw(..)</code>. Just like <code>return(x)</code> is essentially injecting a <code>return x</code> into the generator at its current pause point, calling <code>throw(x)</code> is essentially like injecting a <code>throw x</code> at the pause point.</p>

<p>Other than the exception behavior (we cover what that means to <code>try</code> clauses in the next section), <code>throw(..)</code> produces the same sort of early completion that aborts the generator's run at its current pause point. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-k">try</span> {
    it.throw( <span class="pl-s"><span class="pl-pds">"</span>Oops!<span class="pl-pds">"</span></span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// Exception: Oops!</span>
}

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Because <code>throw(..)</code> basically injects a <code>throw ..</code> in replacement of the <code>yield 1</code> line of the generator, and nothing handles this exception, it immediately propagates back out to the calling code, which handles it with a <code>try..catch</code>.</p>

<p>Unlike <code>return(..)</code>, the iterator's <code>throw(..)</code> method is never called automatically.</p>

<p>Of course, though not shown in the previous snippet, if a <code>try..finally</code> clause was waiting inside the generator when you call <code>throw(..)</code>, the <code>finally</code> clause would be given a chance to complete before the exception is propagated back to the calling code.</p>

<h3><a id="user-content-error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Handling</h3>

<p>As we've already hinted, error handling with generators can be expressed with <code>try..catch</code>, which works in both inbound and outbound directions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }

    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;

    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-k">try</span> {
    it.throw( <span class="pl-s"><span class="pl-pds">"</span>Hi!<span class="pl-pds">"</span></span> );  <span class="pl-c">// Hi!</span>
                        <span class="pl-c">// { value: 2, done: false }</span>
    it.<span class="pl-c1">next</span>();

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// Hello!</span>
}</pre></div>

<p>Errors can also propagate in both directions through <code>yield *</code> delegation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }

    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;

    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>foo: e2<span class="pl-pds">"</span></span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();

        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

<span class="pl-k">try</span> {
    it.<span class="pl-c1">next</span>();          <span class="pl-c">// { value: 1, done: false }</span>

    it.throw( <span class="pl-s"><span class="pl-pds">"</span>e1<span class="pl-pds">"</span></span> );   <span class="pl-c">// e1</span>
                        <span class="pl-c">// { value: 2, done: false }</span>

    it.<span class="pl-c1">next</span>();          <span class="pl-c">// foo: e2</span>
                        <span class="pl-c">// { value: undefined, done: true }</span>
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
}

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>When <code>*foo()</code> calls <code>yield 1</code>, the <code>1</code> value passes through <code>*bar()</code> untouched, as we've already seen.</p>

<p>But what's most interesting about this snippet is that when <code>*foo()</code> calls <code>throw "foo: e2"</code>, this error propagates to <code>*bar()</code> and is immediately caught by <code>*bar()</code>'s <code>try..catch</code> block. The error doesn't pass through <code>*bar()</code> like the <code>1</code> value did.</p>

<p><code>*bar()</code>'s <code>catch</code> then does a normal output of <code>err</code> (<code>"foo: e2"</code>) and then <code>*bar()</code> finishes normally, which is why the <code>{ value: undefined, done: true }</code> iterator result comes back from <code>it.next()</code>.</p>

<p>If <code>*bar()</code> didn't have a <code>try..catch</code> around the <code>yield *..</code> expression, the error would of course propagate all the way out, and on the way through it still would complete (abort) <code>*bar()</code>.</p>

<h3><a id="user-content-transpiling-a-generator" class="anchor" href="#transpiling-a-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transpiling a Generator</h3>

<p>Is it possible to represent a generator's capabilities prior to ES6? It turns out it is, and there are several great tools that do so, including most notably Facebook's Regenerator tool (<a href="https://facebook.github.io/regenerator/">https://facebook.github.io/regenerator/</a>).</p>

<p>But just to better understand generators, let's try our hand at manually converting. Basically, we're going to create a simple closure-based state machine.</p>

<p>We'll keep our source generator really simple:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">42</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}</pre></div>

<p>To start, we'll need a function called <code>foo()</code> that we can execute, which needs to return an iterator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>

    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-c">// ..</span>
        }

        <span class="pl-c">// we'll skip `return(..)` and `throw(..)`</span>
    };
}</pre></div>

<p>Now, we need some inner variable to keep track of where we are in the steps of our "generator"'s logic. We'll call it <code>state</code>. There will be three states: <code>0</code> initially, <code>1</code> while waiting to fulfill the <code>yield</code> expression, and <code>2</code> once the generator is complete.</p>

<p>Each time <code>next(..)</code> is called, we need to process the next step, and then increment <code>state</code>. For convenience, we'll put each step into a <code>case</code> clause of a <code>switch</code> statement, and we'll hold that in an inner function called <code>nextState(..)</code> that <code>next(..)</code> can call. Also, because <code>x</code> is a variable across the overall scope of the "generator," it needs to live outside the <code>nextState(..)</code> function.</p>

<p>Here it is all together (obviously somewhat simplified, to keep the conceptual illustration clearer):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">function</span> <span class="pl-en">nextState</span>(<span class="pl-smi">v</span>) {
        <span class="pl-k">switch</span> (state) {
            <span class="pl-k">case</span> <span class="pl-c1">0</span><span class="pl-k">:</span>
                state<span class="pl-k">++</span>;

                <span class="pl-c">// the `yield` expression</span>
                <span class="pl-k">return</span> <span class="pl-c1">42</span>;
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
                state<span class="pl-k">++</span>;

                <span class="pl-c">// `yield` expression fulfilled</span>
                x <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );

                <span class="pl-c">// the implicit `return`</span>
                <span class="pl-k">return</span> <span class="pl-c1">undefined</span>;

            <span class="pl-c">// no need to handle state `2`</span>
        }
    }

    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-c1">0</span>, x;

    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-k">var</span> ret <span class="pl-k">=</span> nextState( v );

            <span class="pl-k">return</span> { value<span class="pl-k">:</span> ret, done<span class="pl-k">:</span> (state <span class="pl-k">==</span> <span class="pl-c1">2</span>) };
        }

        <span class="pl-c">// we'll skip `return(..)` and `throw(..)`</span>
    };
}</pre></div>

<p>And finally, let's test our pre-ES6 "generator":</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 42, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">10</span> );          <span class="pl-c">// 10</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Not bad, huh? Hopefully this exercise solidifies in your mind that generators are actually just simple syntax for state machine logic. That makes them widely applicable.</p>

<h3><a id="user-content-generator-uses" class="anchor" href="#generator-uses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Uses</h3>

<p>So, now that we much more deeply understand how generators work, what are they useful for?</p>

<p>We've seen two major patterns:</p>

<ul>
<li><p><em>Producing a series of values:</em> This usage can be simple (e.g., random strings or incremented numbers), or it can represent more structured data access (e.g., iterating over rows returned from a database query).</p>

<p>Either way, we use the iterator to control a generator so that some logic can be invoked for each call to <code>next(..)</code>. Normal iterators on data structures merely pull values without any controlling logic.</p></li>
<li><p><em>Queue of tasks to perform serially:</em> This usage often represents flow control for the steps in an algorithm, where each step requires retrieval of data from some external source. The fulfillment of each piece of data may be immediate, or may be asynchronously delayed.</p>

<p>From the perspective of the code inside the generator, the details of sync or async at a <code>yield</code> point are entirely opaque. Moreover, these details are intentionally abstracted away, such as not to obscure the natural sequential expression of steps with such implementation complications. Abstraction also means the implementations can be swapped/refactored often without touching the code in the generator at all.</p></li>
</ul>

<p>When generators are viewed in light of these uses, they become a lot more than just a different or nicer syntax for a manual state machine. They are a powerful abstraction tool for organizing and controlling orderly production and consumption of data.</p>

<h2><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h2>

<p>I don't think it's an exaggeration to suggest that the single most important code organization pattern in all of JavaScript is, and always has been, the module. For myself, and I think for a large cross-section of the community, the module pattern drives the vast majority of code.</p>

<h3><a id="user-content-the-old-way" class="anchor" href="#the-old-way" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Old Way</h3>

<p>The traditional module pattern is based on an outer function with inner variables and functions, and a returned "public API" with methods that have closure over the inner data and capabilities. It's often expressed like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Hello</span>(<span class="pl-smi">name</span>) {
    <span class="pl-k">function</span> <span class="pl-en">greeting</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// public API</span>
    <span class="pl-k">return</span> {
        greeting<span class="pl-k">:</span> greeting
    };
}

<span class="pl-k">var</span> me <span class="pl-k">=</span> Hello( <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span> );
me.greeting();          <span class="pl-c">// Hello Kyle!</span></pre></div>

<p>This <code>Hello(..)</code> module can produce multiple instances by being called subsequent times. Sometimes, a module is only called for as a singleton (i.e., it just needs one instance), in which case a slight variation on the previous snippet, using an IIFE, is common:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> me <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">Hello</span>(<span class="pl-smi">name</span>){
    <span class="pl-k">function</span> <span class="pl-en">greeting</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// public API</span>
    <span class="pl-k">return</span> {
        greeting<span class="pl-k">:</span> greeting
    };
})( <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span> );

me.greeting();          <span class="pl-c">// Hello Kyle!</span></pre></div>

<p>This pattern is tried and tested. It's also flexible enough to have a wide assortment of variations for a number of different scenarios.</p>

<p>One of the most common is the Asynchronous Module Definition (AMD), and another is the Universal Module Definition (UMD). We won't cover the particulars of these patterns and techniques here, but they're explained extensively in many places online.</p>

<h3><a id="user-content-moving-forward" class="anchor" href="#moving-forward" aria-hidden="true"><span class="octicon octicon-link"></span></a>Moving Forward</h3>

<p>As of ES6, we no longer need to rely on the enclosing function and closure to provide us with module support. ES6 modules have first class syntactic and functional support.</p>

<p>Before we get into the specific syntax, it's important to understand some fairly significant conceptual differences with ES6 modules compared to how you may have dealt with modules in the past:</p>

<ul>
<li><p>ES6 uses file-based modules, meaning one module per file. At this time, there is no standardized way of combining multiple modules into a single file.</p>

<p>That means that if you are going to load ES6 modules directly into a browser web application, you will be loading them individually, not as a large bundle in a single file as has been common in performance optimization efforts.</p>

<p>It's expected that the contemporaneous advent of HTTP/2 will significantly mitigate any such performance concerns, as it operates on a persistent socket connection and thus can very efficiently load many smaller files in parallel and interleaved with one another.</p></li>
<li><p>The API of an ES6 module is static. That is, you define statically what all the top-level exports are on your module's public API, and those cannot be amended later.</p>

<p>Some uses are accustomed to being able to provide dynamic API definitions, where methods can be added/removed/replaced in response to runtime conditions. Either these uses will have to change to fit with ES6 static APIs, or they will have to restrain the dynamic changes to properties/methods of a second-level object.</p></li>
<li>ES6 modules are singletons. That is, there's only one instance of the module, which maintains its state. Every time you import that module into another module, you get a reference to the one centralized instance. If you want to be able to produce multiple module instances, your module will need to provide some sort of factory to do it.</li>
<li><p>The properties and methods you expose on a module's public API are not just normal assignments of values or references. They are actual bindings (almost like pointers) to the identifiers in your inner module definition.</p>

<p>In pre-ES6 modules, if you put a property on your public API that holds a primitive value like a number or string, that property assignment was by value-copy, and any internal update of a corresponding variable would be separate and not affect the public copy on the API object.</p>

<p>With ES6, exporting a local private variable, even if it currently holds a primitive string/number/etc, exports a binding to the variable. If the module changes the  variable's value, the external import binding now resolves to that new value.</p></li>
<li><p>Importing a module is the same thing as statically requesting it to load (if it hasn't already). If you're in a browser, that implies a blocking load over the network. If you're on a server (i.e., Node.js), it's a blocking load from the filesystem.</p>

<p>However, don't panic about the performance implications. Because ES6 modules have static definitions, the import requirements can be statically scanned, and loads will happen preemptively, even before you've used the module.</p>

<p>ES6 doesn't actually specify or handle the mechanics of how these load requests work. There's a separate notion of a Module Loader, where each hosting environment (browser, Node.js, etc.) provides a default Loader appropriate to the environment. The importing of a module uses a string value to represent where to get the module (URL, file path, etc.), but this value is opaque in your program and only meaningful to the Loader itself.</p>

<p>You can define your own custom Loader if you want more fine-grained control than the default Loader affords -- which is basically none, as it's totally hidden from your program's code.</p></li>
</ul>

<p>As you can see, ES6 modules will serve the overall use case of organizing code with encapsulation, controlling public APIs, and referencing dependency imports. But they have a very particular way of doing so, and that may or may not fit very closely with how you've already been doing modules for years.</p>

<h4><a id="user-content-commonjs" class="anchor" href="#commonjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>CommonJS</h4>

<p>There's a similar, but not fully compatible, module syntax called CommonJS, which is familiar to those in the Node.js ecosystem.</p>

<p>For lack of a more tactful way to say this, in the long run, ES6 modules essentially are bound to supercede all previous formats and standards for modules, even CommonJS, as they are built on syntactic support in the language. This will, in time, inevitably win out as the superior approach, if for no other reason than ubiquity.</p>

<p>We face a fairly long road to get to that point, though. There are literally hundreds of thousands of CommonJS style modules in the server-side JavaScript world, and 10 times that many modules of varying format standards (UMD, AMD, ad hoc) in the browser world. It will take many years for the transitions to make any significant progress.</p>

<p>In the interim, module transpilers/converters will be an absolute necessity. You might as well just get used to that new reality. Whether you author in regular modules, AMD, UMD, CommonJS, or ES6, these tools will have to parse and convert to a format that is suitable for whatever environment your code will run in.</p>

<p>For Node.js, that probably means (for now) that the target is CommonJS. For the browser, it's probably UMD or AMD. Expect lots of flux on this over the next few years as these tools mature and best practices emerge.</p>

<p>From here on out, my best advice on modules is this: whatever format you've been religiously attached to with strong affinity, also develop an appreciation for and understanding of ES6 modules, such as they are, and let your other module tendencies fade. They <em>are</em> the future of modules in JS, even if that reality is a bit of a ways off.</p>

<h3><a id="user-content-the-new-way" class="anchor" href="#the-new-way" aria-hidden="true"><span class="octicon octicon-link"></span></a>The New Way</h3>

<p>The two main new keywords that enable ES6 classes are <code>import</code> and <code>export</code>. There's lots of nuance to the syntax, so let's take a deeper look.</p>

<p><strong>Warning:</strong> An important detail that's easy to overlook: both <code>import</code> and <code>export</code> must always appear in the top-level scope of their respective usage. For example, you cannot put either an <code>import</code> or <code>export</code> inside an <code>if</code> conditional; they must appear outside of all blocks and functions.</p>

<h4><a id="user-content-exporting-api-members" class="anchor" href="#exporting-api-members" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>export</code>ing API Members</h4>

<p>The <code>export</code> keyword is either put in front of a declaration, or used as an operator (of sorts) with a special list of bindings to export. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> <span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-k">var</span> bar <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
<span class="pl-k">export</span> { bar };</pre></div>

<p>Another way of expressing the same exports:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">var</span> bar <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">export</span> { foo, awesome, bar };</pre></div>

<p>These are all called <em>named exports</em>, as you are in effect exporting the name bindings of the variables/functions/etc.</p>

<p>Anything you don't <em>label</em> with <code>export</code> stays private inside the scope of the module. That is, although something like <code>var bar = ..</code> looks like it's declaring at the top-level global scope, the top-level scope is actually the module itself; there is no global scope in modules.</p>

<p><strong>Note:</strong> Modules <em>do</em> still have access to <code>window</code> and all the "globals" that hang off it, just not as lexical top-level scope. However, you really should stay away from the globals in your modules if at all possible.</p>

<p>You can also "rename" (aka alias) a module member during named export:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> { foo as bar };</pre></div>

<p>When this module is imported, only the <code>bar</code> member name is available to import; <code>foo</code> stays hidden inside the module.</p>

<p>Module exports are not just normal assignments of values or references, as you're accustomed to with the <code>=</code> assignment operator. Actually, when you export something, you're exporting a binding (kinda like a pointer) to that thing (variable, etc.).</p>

<p>Within your module, if you change the value of a variable you already exported a binding to, even if it's already been imported (see the next section), the imported binding will resolve to the current (updated) value.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> { awesome };

<span class="pl-c">// later</span>
awesome <span class="pl-k">=</span> <span class="pl-c1">100</span>;</pre></div>

<p>When this module is imported, regardless of whether that's before or after the <code>awesome = 100</code> setting, once that assignment has happened, the imported binding resolves to the <code>100</code> value, not <code>42</code>.</p>

<p>That's because the binding is, in essence, a reference to, or a pointer to, the <code>awesome</code> variable itself, rather than a copy of its value. This is a mostly unprecedented concept for JS introduced with ES6 module bindings.</p>

<p>Though you can clearly use <code>export</code> multiple times inside a module's definition, ES6 definitely prefers the approach that a module has a single export, which is known as a <em>default export</em>. In the words of some members of the TC39 committee, you're "rewarded with simpler <code>import</code> syntax" if you follow that pattern, and conversely "penalized" with more verbose syntax if you don't.</p>

<p>A default export sets a particular exported binding to be the default when importing the module. The name of the binding is literally <code>default</code>. As you'll see later, when importing module bindings you can also rename them, as you commonly will with a default export.</p>

<p>There can only be one <code>default</code> per module definition. We'll cover <code>import</code> in the next section, and you'll see how the <code>import</code> syntax is more concise if the module has a default export.</p>

<p>There's a subtle nuance to default export syntax that you should pay close attention to. Compare these two snippets:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> <span class="pl-k">default</span> foo;</pre></div>

<p>And this one:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };</pre></div>

<p>In the first snippet, you are exporting a binding to the function expression value at that moment, <em>not</em> to the identifier <code>foo</code>. In other words, <code>export default ..</code> takes an expression. If you later assign <code>foo</code> to a different value inside your module, the module import still reveals the function originally exported, not the new value.</p>

<p>By the way, the first snippet could also have been written as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}</pre></div>

<p><strong>Warning:</strong> Although the <code>function foo..</code> part here is technically a function expression, for the purposes of the internal scope of the module, it's treated like a function declaration, in that the <code>foo</code> name is bound in the module's top-level scope (often called "hoisting"). The same is true for <code>export default class Foo..</code>. However, while you <em>can</em> do <code>export var foo = ..</code>, you currently cannot do <code>export default var foo = ..</code> (or <code>let</code> or <code>const</code>), in a frustrating case of inconsistency. At the time of this writing, there's already discussion of adding that capability in soon, post-ES6, for consistency sake.</p>

<p>Recall the second snippet again:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };</pre></div>

<p>In this version of the module export, the default export binding is actually to the <code>foo</code> identifier rather than its value, so you get the previously described binding behavior (i.e., if you later change <code>foo</code>'s value, the value seen on the import side will also be updated).</p>

<p>Be very careful of this subtle gotcha in default export syntax, especially if your logic calls for export values to be updated. If you never plan to update a default export's value, <code>export default ..</code> is fine. If you do plan to update the value, you must use <code>export { .. as default }</code>. Either way, make sure to comment your code to explain your intent!</p>

<p>Because there can only be one <code>default</code> per module, you may be tempted to design your module with one default export of an object with all your API methods on it, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> {
    <span class="pl-en">foo</span>() { .. },
    <span class="pl-en">bar</span>() { .. },
    ..
};</pre></div>

<p>That pattern seems to map closely to how a lot of developers have already structured their pre-ES6 modules, so it seems like a natural approach. Unfortunately, it has some downsides and is officially discouraged.</p>

<p>In particular, the JS engine cannot statically analyze the contents of a plain object, which means it cannot do some optimizations for static <code>import</code> performance. The advantage of having each member individually and explicitly exported is that the engine <em>can</em> do the static analysis and optimization.</p>

<p>If your API has more than one member already, it seems like these principles -- one default export per module, and all API members as named exports -- are in conflict, doesn't it? But you <em>can</em> have a single default export as well as other named exports; they are not mutually exclusive.</p>

<p>So, instead of this (discouraged) pattern:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-c1">foo</span>.<span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() { .. };
<span class="pl-c1">foo</span>.<span class="pl-en">baz</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() { .. };</pre></div>

<p>You can do:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p><strong>Note:</strong> In this previous snippet, I used the name <code>foo</code> for the function that <code>default</code> labels. That <code>foo</code> name, however, is ignored for the purposes of export -- <code>default</code> is actually the exported name. When you import this default binding, you can give it whatever name you want, as you'll see in the next section.</p>

<p>Alternatively, some will prefer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span>, bar, baz, .. };</pre></div>

<p>The effects of mixing default and named exports will be more clear when we cover <code>import</code> shortly. But essentially it means that the most concise default import form would only retrieve the <code>foo()</code> function. The user could additionally manually list <code>bar</code> and <code>baz</code> as named imports, if they want them.</p>

<p>You can probably imagine how tedious that's going to be for consumers of your module if you have lots of named export bindings. There is a wildcard import form where you import all of a module's exports within a single namespace object, but there's no way to wildcard import to top-level bindings.</p>

<p>Again, the ES6 module mechanism is intentionally designed to discourage modules with lots of exports; relatively speaking, it's desired that such approaches be a little more difficult, as a sort of social engineering to encourage simple module design in favor of large/complex module design.</p>

<p>I would probably recommend you not mix default export with named exports, especially if you have a large API and refactoring to separate modules isn't practical or desired. In that case, just use all named exports, and document that consumers of your module should probably use the <code>import * as ..</code> (namespace import, discussed in the next section) approach to bring the whole API in at once on a single namespace.</p>

<p>We mentioned this earlier, but let's come back to it in more detail. Other than the <code>export default ...</code> form that exports an expression value binding, all other export forms are exporting bindings to local identifiers. For those bindings, if you change the value of a variable inside a module after exporting, the external imported binding will access the updated value:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };

<span class="pl-k">export</span> <span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

foo <span class="pl-k">=</span> <span class="pl-c1">10</span>;
bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;</pre></div>

<p>When you import this module, the <code>default</code> and <code>bar</code> exports will be bound to the local variables <code>foo</code> and <code>bar</code>, meaning they will reveal the updated <code>10</code> and <code>"cool"</code> values. The values at time of export are irrelevant. The values at time of import are irrelevant. The bindings are live links, so all that matters is what the current value is when you access the binding.</p>

<p><strong>Warning:</strong> Two-way bindings are not allowed. If you import a <code>foo</code> from a module, and try to change the value of your imported <code>foo</code> variable, an error will be thrown! We'll revisit that in the next section.</p>

<p>You can also re-export another module's exports, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> { foo, bar } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;
<span class="pl-k">export</span> { foo as <span class="pl-c1">FOO</span>, bar as <span class="pl-c1">BAR</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;
<span class="pl-k">export</span> <span class="pl-k">*</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;</pre></div>

<p>Those forms are similar to just first importing from the <code>"baz"</code> module then listing its members explicitly for export from your module. However, in these forms, the members of the <code>"baz"</code> module are never imported to your module's local scope; they sort of pass through untouched.</p>

<h4><a id="user-content-importing-api-members" class="anchor" href="#importing-api-members" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>import</code>ing API Members</h4>

<p>To import a module, unsurprisingly you use the <code>import</code> statement. Just as <code>export</code> has several nuanced variations, so does <code>import</code>, so spend plenty of time considering the following issues and experimenting with your options.</p>

<p>If you want to import certain specific named members of a module's API into your top-level scope, you use this syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo, bar, baz } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><strong>Warning:</strong> The <code>{ .. }</code> syntax here may look like an object literal, or even an object destructuring syntax. However, its form is special just for modules, so be careful not to confuse it with other <code>{ .. }</code> patterns elsewhere.</p>

<p>The <code>"foo"</code> string is called a <em>module specifier</em>. Because the whole goal is statically analyzable syntax, the module specifier must be a string literal; it cannot be a variable holding the string value.</p>

<p>From the perspective of your ES6 code and the JS engine itself, the contents of this string literal are completely opaque and meaningless. The module loader will interpret this string as an instruction of where to find the desired module, either as a URL path or a local filesystem path.</p>

<p>The <code>foo</code>, <code>bar</code>, and <code>baz</code> identifiers listed must match named exports on the module's API (static analysis and error assertion apply). They are bound as top-level identifiers in your current scope:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

foo();</pre></div>

<p>You can rename the bound identifiers imported, as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo <span class="pl-k">as</span> theFooFunc } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

theFooFunc();</pre></div>

<p>If the module has just a default export that you want to import and bind to an identifier, you can opt to skip the <code>{ .. }</code> surrounding syntax for that binding. The <code>import</code> in this preferred case gets the nicest and most concise of the <code>import</code> syntax forms:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c">// or:</span>
<span class="pl-k">import</span> { default <span class="pl-k">as</span> foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><strong>Note:</strong> As explained in the previous section, the <code>default</code> keyword in a module's <code>export</code> specifies a named export where the name is actually <code>default</code>, as is illustrated by the second more verbose syntax option. The renaming from <code>default</code> to, in this case, <code>foo</code>, is explicit in the latter syntax and is identical yet implicit in the former syntax.</p>

<p>You can also import a default export along with other named exports, if the module has such a definition. Recall this module definition from earlier:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>To import that module's default export and its two named exports:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> FOOFN, { bar, baz <span class="pl-k">as</span> BAZ } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">FOOFN</span>();
bar();
<span class="pl-c1">BAZ</span>();</pre></div>

<p>The strongly suggested approach from ES6's module philosophy is that you only import the specific bindings from a module that you need. If a module provides 10 API methods, but you only need two of them, some believe it wasteful to bring in the entire set of API bindings.</p>

<p>One benefit, besides code being more explicit, is that narrow imports make static analysis and error detection (accidentally using the wrong binding name, for instance) more robust.</p>

<p>Of course, that's just the standard position influenced by ES6 design philosophy; there's nothing that requires adherence to that approach.</p>

<p>Many developers would be quick to point out that such approaches can be more tedious, requiring you to regularly revisit and update your <code>import</code> statement(s) each time you realize you need something else from a module. The trade-off is in exchange for convenience.</p>

<p>In that light, the preference might be to import everything from the module into a single namespace, rather than importing individual members, each directly into the scope. Fortunately, the <code>import</code> statement has a syntax variation that can support this style of module consumption, called <em>namespace import</em>.</p>

<p>Consider a <code>"foo"</code> module exported as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>You can import that entire API to a single module namespace binding:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> * <span class="pl-k">as</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

foo.bar();
foo.<span class="pl-c1">x</span>;          <span class="pl-c">// 42</span>
foo.baz();</pre></div>

<p><strong>Note:</strong> The <code>* as ..</code> clause requires the <code>*</code> wildcard. In other words, you cannot do something like <code>import { bar, x } as foo from "foo"</code> to bring in only part of the API but still bind to the <code>foo</code> namespace. I would have liked something like that, but for ES6 it's all or nothing with the namespace import.</p>

<p>If the module you're importing with <code>* as ..</code> has a default export, it is named <code>default</code> in the namespace specified. You can additionaly name the default import outside of the namespace binding, as a top-level identifier. Consider a <code>"world"</code> module exported as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>And this <code>import</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foofn, * <span class="pl-k">as</span> hello <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>;

foofn();
hello.default();
hello.bar();
hello.baz();</pre></div>

<p>While this syntax is valid, it can be rather confusing that one method of the module (the default export) is bound at the top-level of your scope, whereas the rest of the named exports (and one called <code>default</code>) are bound as properties on a differently named (<code>hello</code>) identifier namespace.</p>

<p>As I mentioned earlier, my suggestion would be to avoid designing your module exports in this way, to reduce the chances that your module's users will suffer these strange quirks.</p>

<p>All imported bindings are immutable and/or read-only. Consider the previous import; all of these subsequent assignment attempts will throw <code>TypeError</code>s:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foofn, * <span class="pl-k">as</span> hello <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>;

foofn <span class="pl-k">=</span> <span class="pl-c1">42</span>;         <span class="pl-c">// (runtime) TypeError!</span>
hello.default <span class="pl-k">=</span> <span class="pl-c1">42</span>; <span class="pl-c">// (runtime) TypeError!</span>
hello.bar <span class="pl-k">=</span> <span class="pl-c1">42</span>;     <span class="pl-c">// (runtime) TypeError!</span>
hello.baz <span class="pl-k">=</span> <span class="pl-c1">42</span>;     <span class="pl-c">// (runtime) TypeError!</span></pre></div>

<p>Recall earlier in the "<code>export</code>ing API Members" section that we talked about how the <code>bar</code> and <code>baz</code> bindings are bound to the actual identifiers inside the <code>"world"</code> module. That means if the module changes those values, <code>hello.bar</code> and <code>hello.baz</code> now reference the updated values.</p>

<p>But the immutable/read-only nature of your local imported bindings enforces that you cannot change them from the imported bindings, hence the <code>TypeError</code>s. That's pretty important, because without those protections, your changes would end up affecting all other consumers of the module (remember: singleton), which could create some very surprising side effects!</p>

<p>Moreover, though a module <em>can</em> change its API members from the inside, you should be very cautious of intentionally designing your modules in that fashion. ES6 modules are <em>intended</em> to be static, so deviations from that principle should be rare and should be carefully and verbosely documented.</p>

<p><strong>Warning:</strong> There are module design philosophies where you actually intend to let a consumer change the value of a property on your API, or module APIs are designed to be "extended" by having other "plug-ins" add to the API namespace. As we just asserted, ES6 module APIs should be thought of and designed as static and unchangeable, which strongly restricts and discourages these alternative module design patterns. You can get around these limitations by exporting a plain object, which of course can then be changed at will. But be careful and think twice before going down that road.</p>

<p>Declarations that occur as a result of an <code>import</code> are "hoisted" (see the <em>Scope &amp; Closures</em> title of this series). Consider:</p>

<div class="highlight highlight-source-js"><pre>foo();

<span class="pl-k">import</span> { foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><code>foo()</code> can run because not only did the static resolution of the <code>import ..</code> statement figure out what <code>foo</code> is during compilation, but it also "hoisted" the declaration to the top of the module's scope, thus making it available throughout the module.</p>

<p>Finally, the most basic form of the <code>import</code> looks like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p>This form does not actually import any of the module's bindings into your scope. It loads (if not already loaded), compiles (if not already compiled), and evaluates (if not already run) the <code>"foo"</code> module.</p>

<p>In general, that sort of import is probably not going to be terribly useful. There may be niche cases where a module's definition has side effects (such as assigning things to the <code>window</code>/global object). You could also envision using <code>import "foo"</code> as a sort of preload for a module that may be needed later.</p>

<h3><a id="user-content-circular-module-dependency" class="anchor" href="#circular-module-dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Circular Module Dependency</h3>

<p>A imports B. B imports A. How does this actually work?</p>

<p>I'll state off the bat that designing systems with intentional circular dependency is generally something I try to avoid. That having been said, I recognize there are reasons people do this and it can solve some sticky design situations.</p>

<p>Let's consider how ES6 handles this. First, module <code>"A"</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>;

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>) <span class="pl-k">return</span> bar( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}</pre></div>

<p>Now, module <code>"B"</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>;

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">y</span>) {
    <span class="pl-k">if</span> (y <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) <span class="pl-k">return</span> foo( y <span class="pl-k">/</span> <span class="pl-c1">2</span> );
    <span class="pl-k">return</span> y <span class="pl-k">*</span> <span class="pl-c1">3</span>;
}</pre></div>

<p>These two functions, <code>foo(..)</code> and <code>bar(..)</code>, would work as standard function declarations if they were in the same scope, because the declarations are "hoisted" to the whole scope and thus available to each other regardless of authoring order.</p>

<p>With modules, you have declarations in entirely different scopes, so ES6 has to do extra work to help make these circular references work.</p>

<p>In a rough conceptual sense, this is how circular <code>import</code> dependencies are validated and resolved:</p>

<ul>
<li>If the <code>"A"</code> module is loaded first, the first step is to scan the file and analyze all the exports, so it can register all those bindings available for import. Then it processes the <code>import .. from "B"</code>, which signals that it needs to go fetch <code>"B"</code>.</li>
<li>Once the engine loads <code>"B"</code>, it does the same analysis of its export bindings. When it sees the <code>import .. from "A"</code>, it knows the API of <code>"A"</code> already, so it can verify the <code>import</code> is valid. Now that it knows the <code>"B"</code> API, it can also validate the <code>import .. from "B"</code> in the waiting <code>"A"</code> module.</li>
</ul>

<p>In essence, the mutual imports, along with the static verification that's done to validate both <code>import</code> statements, virtually composes the two separate module scopes (via the bindings), such that <code>foo(..)</code> can call <code>bar(..)</code> and vice versa. This is symmetric to if they had originally been declared in the same scope.</p>

<p>Now let's try using the two modules together. First, we'll try <code>foo(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
foo( <span class="pl-c1">25</span> );              <span class="pl-c">// 11</span></pre></div>

<p>Or we can try <code>bar(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;
bar( <span class="pl-c1">25</span> );              <span class="pl-c">// 11.5</span></pre></div>

<p>By the time either the <code>foo(25)</code> or <code>bar(25)</code> calls are executed, all the analysis/compilation of all modules has completed. That means <code>foo(..)</code> internally knows directly about <code>bar(..)</code> and <code>bar(..)</code> internally knows directly about <code>foo(..)</code>.</p>

<p>If all we need is to interact with <code>foo(..)</code>, then we only need to import the <code>"foo"</code> module. Likewise with <code>bar(..)</code> and the <code>"bar"</code> module.</p>

<p>Of course, we <em>can</em> import and use both of them if we want to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
<span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

foo( <span class="pl-c1">25</span> );              <span class="pl-c">// 11</span>
bar( <span class="pl-c1">25</span> );              <span class="pl-c">// 11.5</span></pre></div>

<p>The static loading semantics of the <code>import</code> statement mean that a <code>"foo"</code> and <code>"bar"</code> that mutually depend on each other via <code>import</code> will ensure that both are loaded, parsed, and compiled before either of them runs. So their circular dependency is statically resolved and this works as you'd expect.</p>

<h3><a id="user-content-module-loading" class="anchor" href="#module-loading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Module Loading</h3>

<p>We asserted at the beginning of this "Modules" section that the <code>import</code> statement uses a separate mechanism, provided by the hosting environment (browser, Node.js, etc.), to actually resolve the module specifier string into some useful instruction for finding and loading the desired module. That mechanism is the system <em>Module Loader</em>.</p>

<p>The default module loader provided by the environment will interpret a module specifier as a URL if in the browser, and (generally) as a local filesystem path if on a server such as Node.js. The default behavior is to assume the loaded file is authored in the ES6 standard module format.</p>

<p>Moreover, you will be able to load a module into the browser via an HTML tag, similar to how current script programs are loaded. At the time of this writing, it's not fully clear if this tag will be <code>&lt;script type="module"&gt;</code> or <code>&lt;module&gt;</code>. ES6 doesn't control that decision, but discussions in the appropriate standards bodies are already well along in parallel of ES6.</p>

<p>Whatever the tag looks like, you can be sure that under the covers it will use the default loader (or a customized one you've pre-specified, as we'll discuss in the next section).</p>

<p>Just like the tag you'll use in markup, the module loader itself is not specified by ES6. It is a separate, parallel standard (<a href="http://whatwg.github.io/loader/">http://whatwg.github.io/loader/</a>) controlled currently by the WHATWG browser standards group.</p>

<p>At the time of this writing, the following discussions reflect an early pass at the API design, and things are likely to change.</p>

<h4><a id="user-content-loading-modules-outside-of-modules" class="anchor" href="#loading-modules-outside-of-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loading Modules Outside of Modules</h4>

<p>One use for interacting directly with the module loader is if a non-module needs to load a module. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// normal script loaded in browser via `&lt;script&gt;`,</span>
<span class="pl-c">// `import` is illegal here</span>

Reflect.Loader.import( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ) <span class="pl-c">// returns a promise for `"foo"`</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">foo</span>){
    foo.bar();
} );</pre></div>

<p>The <code>Reflect.Loader.import(..)</code> utility imports the entire module onto the named parameter (as a namespace), just like the <code>import * as foo ..</code> namespace import we discussed earlier.</p>

<p><strong>Note:</strong> The <code>Reflect.Loader.import(..)</code> utility returns a promise that is fulfilled once the module is ready. To import multiple modules, you can compose promises from multiple <code>Reflect.Loader.import(..)</code> calls using <code>Promise.all([ .. ])</code>. For more information about Promises, see "Promises" in Chapter 4.</p>

<p>You can also use <code>Reflect.Loader.import(..)</code> in a real module to dynamically/conditionally load a module, where <code>import</code> itself would not work. You might, for instance, choose to load a module containing a polyfill for some ES7+ feature if a feature test reveals it's not defined by the current engine.</p>

<p>For performance reasons, you'll want to avoid dynamic loading whenever possible, as it hampers the ability of the JS engine to fire off early fetches from its static analysis.</p>

<h4><a id="user-content-customized-loading" class="anchor" href="#customized-loading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Customized Loading</h4>

<p>Another use for directly interacting with the module loader is if you want to customize its behavior through configuration or even redefinition.</p>

<p>At the time of this writing, there's a polyfill for the module loader API being developed (<a href="https://github.com/ModuleLoader/es6-module-loader">https://github.com/ModuleLoader/es6-module-loader</a>). While details are scarce and highly subject to change, we can explore what possibilities may eventually land.</p>

<p>The <code>Reflect.Loader.import(..)</code> call may support a second argument for specifying various options to customize the import/load task. For example:</p>

<div class="highlight highlight-source-js"><pre>Reflect.Loader.import( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, { address<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>/path/to/foo.js<span class="pl-pds">"</span></span> } )
.then( <span class="pl-k">function</span>(<span class="pl-smi">foo</span>){
    <span class="pl-c">// ..</span>
} )</pre></div>

<p>It's also expected that a customization will be provided (through some means) for hooking into the process of loading a module, where a translation/transpilation could occur after load but before the engine compiles the module.</p>

<p>For example, you could load something that's not already an ES6-compliant module format (e.g., CoffeeScript, TypeScript, CommonJS, AMD). Your translation step could then convert it to an ES6-compliant module for the engine to then process.</p>

<h2><a id="user-content-classes" class="anchor" href="#classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Classes</h2>

<p>From nearly the beginning of JavaScript, syntax and development patterns have all strived (read: struggled) to put on a facade of supporting class-oriented development. With things like <code>new</code> and <code>instanceof</code> and a <code>.constructor</code> property, who couldn't help but be teased that JS had classes hidden somewhere inside its prototype system?</p>

<p>Of course, JS "classes" aren't nearly the same as classical classes. The differences are well documented, so I won't belabor that point any further here.</p>

<p><strong>Note:</strong> To learn more about the patterns used in JS to fake "classes," and an alternative view of prototypes called "delegation," see the second half of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<h3><a id="user-content-class" class="anchor" href="#class" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>class</code></h3>

<p>Although JS's prototype mechanism doesn't work like traditional classes, that doesn't stop the strong tide of demand on the language to extend the syntactic sugar so that expressing "classes" looks more like real classes. Enter the ES6 <code>class</code> keyword and its associated mechanism.</p>

<p>This feature is the result of a highly contentious and drawn-out debate, and represents a smaller subset compromise from several strongly opposed views on how to approach JS classes. Most developers who want full classes in JS will find parts of the new syntax quite inviting, but will find important bits still missing. Don't worry, though. TC39 is already working on additional features to augment classes in the post-ES6 timeframe.</p>

<p>At the heart of the new ES6 class mechanism is the <code>class</code> keyword, which identifies a <em>block</em> where the contents define the members of a function's prototype. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
        <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">=</span> a;
        <span class="pl-v">this</span>.<span class="pl-c1">y</span> <span class="pl-k">=</span> b;
    }

    <span class="pl-en">gimmeXY</span>() {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">y</span>;
    }
}</pre></div>

<p>Some things to note:</p>

<ul>
<li><code>class Foo</code> implies creating a (special) function of the name <code>Foo</code>, much like you did pre-ES6.</li>
<li><code>constructor(..)</code> identifies the signature of that <code>Foo(..)</code> function, as well as its body contents.</li>
<li>Class methods use the same "concise method" syntax available to object literals, as discussed in Chapter 2. This also includes the concise generator form as discussed earlier in this chapter, as well as the ES5 getter/setter syntax. However, class methods are non-enumerable whereas object methods are by default enumerable.</li>
<li>Unlike object literals, there are no commas separating members in a <code>class</code> body! In fact, they're not even allowed.</li>
</ul>

<p>The <code>class</code> syntax definition in the previous snippet can be roughly thought of as this pre-ES6 equivalent, which probably will look fairly familiar to those who've done prototype-style coding before:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">=</span> a;
    <span class="pl-v">this</span>.<span class="pl-c1">y</span> <span class="pl-k">=</span> b;
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">gimmeXY</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">y</span>;
}</pre></div>

<p>In either the pre-ES6 form or the new ES6 <code>class</code> form, this "class" can now be instantiated and used just as you'd expect:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> f <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-c1">5</span>, <span class="pl-c1">15</span> );

f.<span class="pl-c1">x</span>;                        <span class="pl-c">// 5</span>
f.<span class="pl-c1">y</span>;                        <span class="pl-c">// 15</span>
f.gimmeXY();                <span class="pl-c">// 75</span></pre></div>

<p>Caution! Though <code>class Foo</code> seems much like <code>function Foo()</code>, there are important differences:</p>

<ul>
<li>A <code>Foo(..)</code> call of <code>class Foo</code> <em>must</em> be made with <code>new</code>, as the pre-ES6 option of <code>Foo.call( obj )</code> will <em>not</em> work.</li>
<li>While <code>function Foo</code> is "hoisted" (see the <em>Scope &amp; Closures</em> title of this series), <code>class Foo</code> is not; the <code>extends ..</code> clause specifies an expression that cannot be "hoisted." So, you must declare a <code>class</code> before you can instantiate it.</li>
<li><code>class Foo</code> in the top global scope creates a lexical <code>Foo</code> identifier in that scope, but unlike <code>function Foo</code> does not create a global object property of that name.</li>
</ul>

<p>The established <code>instanceof</code> operator still works with ES6 classes, because <code>class</code> just creates a constructor function of the same name. However, ES6 introduces a way to customize how <code>instanceof</code> works, using <code>Symbol.hasInstance</code> (see "Well-Known Symbols" in Chapter 7).</p>

<p>Another way of thinking about <code>class</code>, which I find more convenient, is as a <em>macro</em> that is used to automatically populate a <code>prototype</code> object. Optionally, it also wires up the <code>[[Prototype]]</code> relationship if using <code>extends</code> (see the next section).</p>

<p>An ES6 <code>class</code> isn't really an entity itself, but a meta concept that wraps around other concrete entities, such as functions and properties, and ties them together.</p>

<p><strong>Tip:</strong> In addition to the declaration form, a <code>class</code> can also be an expression, as in: <code>var x = class Y { .. }</code>. This is primarily useful for passing a class definition (technically, the constructor itself) as a function argument or assigning it to an object property.</p>

<h3><a id="user-content-extends-and-super" class="anchor" href="#extends-and-super" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>extends</code> and <code>super</code></h3>

<p>ES6 classes also have syntactic sugar for establishing the <code>[[Prototype]]</code> delegation link between two function prototypes -- commonly mislabeled "inheritance" or confusingly labeled "prototype inheritance" -- using the class-oriented familiar terminology <code>extends</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>,<span class="pl-smi">c</span>) {
        <span class="pl-v">super</span>( a, b );
        <span class="pl-v">this</span>.<span class="pl-c1">z</span> <span class="pl-k">=</span> c;
    }

    <span class="pl-en">gimmeXYZ</span>() {
        <span class="pl-k">return</span> <span class="pl-v">super</span>.gimmeXY() <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">z</span>;
    }
}

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-c1">5</span>, <span class="pl-c1">15</span>, <span class="pl-c1">25</span> );

b.<span class="pl-c1">x</span>;                        <span class="pl-c">// 5</span>
b.<span class="pl-c1">y</span>;                        <span class="pl-c">// 15</span>
b.<span class="pl-c1">z</span>;                        <span class="pl-c">// 25</span>
b.gimmeXYZ();               <span class="pl-c">// 1875</span></pre></div>

<p>A significant new addition is <code>super</code>, which is actually something not directly possible pre-ES6 (without some unfortunate hack trade-offs). In the constructor, <code>super</code> automatically refers to the "parent constructor," which in the previous example is <code>Foo(..)</code>. In a method, it refers to the "parent object," such that you can then make a property/method access off it, such as <code>super.gimmeXY()</code>.</p>

<p><code>Bar extends Foo</code> of course means to link the <code>[[Prototype]]</code> of <code>Bar.prototype</code> to <code>Foo.prototype</code>. So, <code>super</code> in a method like <code>gimmeXYZ()</code> specifically means <code>Foo.prototype</code>, whereas <code>super</code> means <code>Foo</code> when used in the <code>Bar</code> constructor.</p>

<p><strong>Note:</strong> <code>super</code> is not limited to <code>class</code> declarations. It also works in object literals, in much the same way we're discussing here. See "Object <code>super</code>" in Chapter 2 for more information.</p>

<h4><a id="user-content-there-be-super-dragons" class="anchor" href="#there-be-super-dragons" aria-hidden="true"><span class="octicon octicon-link"></span></a>There Be <code>super</code> Dragons</h4>

<p>It is not insignificant to note that <code>super</code> behaves differently depending on where it appears. In fairness, most of the time, that won't be a problem. But surprises await if you deviate from a narrow norm.</p>

<p>There may be cases where in the constructor you would want to reference the <code>Foo.prototype</code>, such as to directly access one of its properties/methods. However, <code>super</code> in the constructor cannot be used in that way; <code>super.prototype</code> will not work. <code>super(..)</code> means roughly to call <code>new Foo(..)</code>, but isn't actually a usable reference to <code>Foo</code> itself.</p>

<p>Symmetrically, you may want to reference the <code>Foo(..)</code> function from inside a non-constructor method. <code>super.constructor</code> will point at <code>Foo(..)</code> the function, but beware that this function can <em>only</em> be invoked with <code>new</code>. <code>new super.constructor(..)</code> would be valid, but it wouldn't be terribly useful in most cases, because you can't make that call use or reference the current <code>this</code> object context, which is likely what you'd want.</p>

<p>Also, <code>super</code> looks like it might be driven by a function's context just like <code>this</code> -- that is, that they'd both be dynamically bound. However, <code>super</code> is not dynamic like <code>this</code> is. When a constructor or method makes a <code>super</code> reference inside it at declaration time (in the <code>class</code> body), that <code>super</code> is statically bound to that specific class hierarchy, and cannot be overridden (at least in ES6).</p>

<p>What does that mean? It means that if you're in the habit of taking a method from one "class" and "borrowing" it for another class by overriding its <code>this</code>, say with <code>call(..)</code> or <code>apply(..)</code>, that may very well create surprises if the method you're borrowing has a <code>super</code> in it. Consider this class hierarchy:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">ParentA</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>; }
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ParentA:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">ParentB</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>; }
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ParentB:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">ChildA</span> <span class="pl-k">extends</span> <span class="pl-en">ParentA</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ChildA:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
    }
}

<span class="pl-k">class</span> <span class="pl-en">ChildB</span> <span class="pl-k">extends</span> <span class="pl-en">ParentB</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ChildB:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
    }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ChildA</span>();
a.foo();                    <span class="pl-c">// ParentA: a</span>
                            <span class="pl-c">// ChildA: a</span>
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ChildB</span>();       <span class="pl-c">// ParentB: b</span>
b.foo();                    <span class="pl-c">// ChildB: b</span></pre></div>

<p>All seems fairly natural and expected in this previous snippet. However, if you try to borrow <code>b.foo()</code> and use it in the context of <code>a</code> -- by virtue of dynamic <code>this</code> binding, such borrowing is quite common and used in many different ways, including mixins most notably -- you may find this result an ugly surprise:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// borrow `b.foo()` to use in `a` context</span>
b.foo.<span class="pl-c1">call</span>( a );            <span class="pl-c">// ParentB: a</span>
                            <span class="pl-c">// ChildB: a</span></pre></div>

<p>As you can see, the <code>this.id</code> reference was dynamically rebound so that <code>: a</code> is reported in both cases instead of <code>: b</code>. But <code>b.foo()</code>'s <code>super.foo()</code> reference wasn't dynamically rebound, so it still reported <code>ParentB</code> instead of the expected <code>ParentA</code>.</p>

<p>Because <code>b.foo()</code> references <code>super</code>, it is statically bound to the <code>ChildB</code>/<code>ParentB</code> hierarchy and cannot be used against the <code>ChildA</code>/<code>ParentA</code> hierarchy. There is no ES6 solution to this limitation.</p>

<p><code>super</code> seems to work intuitively if you have a static class hierarchy with no cross-pollination. But in all fairness, one of the main benefits of doing <code>this</code>-aware coding is exactly that sort of flexibility. Simply, <code>class</code> + <code>super</code> requires you to avoid such techniques.</p>

<p>The choice boils down to narrowing your object design to these static hierarchies -- <code>class</code>, <code>extends</code>, and <code>super</code> will be quite nice -- or dropping all attempts to "fake" classes and instead embrace dynamic and flexible, classless objects and <code>[[Prototype]]</code> delegation (see the <em>this &amp; Object Prototypes</em> title of this series).</p>

<h4><a id="user-content-subclass-constructor" class="anchor" href="#subclass-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subclass Constructor</h4>

<p>Constructors are not required for classes or subclasses; a default constructor is substituted in both cases if omitted. However, the default substituted constructor is different for a direct class versus an extended class.</p>

<p>Specifically, the default subclass constructor automatically calls the parent constructor, and passes along any arguments. In other words, you could think of the default subclass constructor sort of like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">constructor</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-v">super</span>(...args);
}</pre></div>

<p>This is an important detail to note. Not all class languages have the subclass constructor automatically call the parent constructor. C++ does, but Java does not. But more importantly, in pre-ES6 classes, such automatic "parent constructor" calling does not happen. Be careful when converting to ES6 <code>class</code> if you've been relying on such calls <em>not</em> happening.</p>

<p>Another perhaps surprising deviation/limitation of ES6 subclass constructors: in a constructor of a subclass, you cannot access <code>this</code> until <code>super(..)</code> has been called. The reason is nuanced and complicated, but it boils down to the fact that the parent constructor is actually the one creating/initializing your instance's <code>this</code>. Pre-ES6, it works oppositely; the <code>this</code> object is created by the "subclass constructor," and then you  call a "parent constructor" with the context of the "subclass" <code>this</code>.</p>

<p>Let's illustrate. This works pre-ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-v">this</span>.a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">function</span> <span class="pl-en">Bar</span>() {
    <span class="pl-v">this</span>.b <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    Foo.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
}

<span class="pl-c">// `Bar` "extends" `Foo`</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );</pre></div>

<p>But this ES6 equivalent is not allowed:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.a <span class="pl-k">=</span> <span class="pl-c1">1</span>; }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-v">this</span>.b <span class="pl-k">=</span> <span class="pl-c1">2</span>;         <span class="pl-c">// not allowed before `super()`</span>
        <span class="pl-v">super</span>();            <span class="pl-c">// to fix swap these two statements</span>
    }
}</pre></div>

<p>In this case, the fix is simple. Just swap the two statements in the subclass <code>Bar</code> constructor. However, if you've been relying pre-ES6 on being able to skip calling the "parent constructor," beware because that won't be allowed anymore.</p>

<h4><a id="user-content-extending-natives" class="anchor" href="#extending-natives" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>extend</code>ing Natives</h4>

<p>One of the most heralded benefits to the new <code>class</code> and <code>extend</code> design is the ability to (finally!) subclass the built-in natives, like <code>Array</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-en">first</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>[<span class="pl-c1">0</span>]; }
    <span class="pl-en">last</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>[<span class="pl-v">this</span>.<span class="pl-c1">length</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>]; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

a.<span class="pl-c1">length</span>;                   <span class="pl-c">// 3</span>
a;                          <span class="pl-c">// [1,2,3]</span>

a.first();                  <span class="pl-c">// 1</span>
a.last();                   <span class="pl-c">// 3</span></pre></div>

<p>Prior to ES6, a fake "subclass" of <code>Array</code> using manual object creation and linking to <code>Array.prototype</code> only partially worked. It missed out on the special behaviors of a real array, such as the automatically updating <code>length</code> property. ES6 subclasses should fully work with "inherited" and augmented behaviors as expected!</p>

<p>Another common pre-ES6 "subclass" limitation is with the <code>Error</code> object, in creating custom error "subclasses." When genuine <code>Error</code> objects are created, they automatically capture special <code>stack</code> information, including the line number and file where the error is created. Pre-ES6 custom error "subclasses" have no such special behavior, which severely limits their usefulness.</p>

<p>ES6 to the rescue:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Oops</span> <span class="pl-k">extends</span> <span class="pl-en">Error</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">reason</span>) {
        <span class="pl-v">this</span>.oops <span class="pl-k">=</span> reason;
    }
}

<span class="pl-c">// later:</span>
<span class="pl-k">var</span> ouch <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Oops</span>( <span class="pl-s"><span class="pl-pds">"</span>I messed up!<span class="pl-pds">"</span></span> );
<span class="pl-k">throw</span> ouch;</pre></div>

<p>The <code>ouch</code> custom error object in this previous snippet will behave like any other genuine error object, including capturing <code>stack</code>. That's a big improvement!</p>

<h3><a id="user-content-newtarget" class="anchor" href="#newtarget" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>new.target</code></h3>

<p>ES6 introduces a new concept called a <em>meta property</em> (see Chapter 7), in the form of <code>new.target</code>.</p>

<p>If that looks strange, it is; pairing a keyword with a <code>.</code> and a property name is definitely an out-of-the-ordinary pattern for JS.</p>

<p><code>new.target</code> is a new "magical" value available in all functions, though in normal functions it will always be <code>undefined</code>. In any constructor, <code>new.target</code> always points at the constructor that <code>new</code> actually directly invoked, even if the constructor is in a parent class and was delegated to by a <code>super(..)</code> call from a child constructor. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Foo: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span>.<span class="pl-c1">name</span> );
    }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-v">super</span>();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Bar: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span>.<span class="pl-c1">name</span> );
    }
    <span class="pl-en">baz</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>baz: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span> );
    }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
<span class="pl-c">// Foo: Foo</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
<span class="pl-c">// Foo: Bar   &lt;-- respects the `new` call-site</span>
<span class="pl-c">// Bar: Bar</span>

b.baz();
<span class="pl-c">// baz: undefined</span></pre></div>

<p>The <code>new.target</code> meta property doesn't have much purpose in class constructors, except accessing a static property/method (see the next section).</p>

<p>If <code>new.target</code> is <code>undefined</code>, you know the function was not called with <code>new</code>. You can then force a <code>new</code> invocation if that's necessary.</p>

<h3><a id="user-content-static" class="anchor" href="#static" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>static</code></h3>

<p>When a subclass <code>Bar</code> extends a parent class <code>Foo</code>, we already observed that <code>Bar.prototype</code> is <code>[[Prototype]]</code>-linked to <code>Foo.prototype</code>. But additionally, <code>Bar()</code> is <code>[[Prototype]]</code>-linked to <code>Foo()</code>. That part may not have such an obvious reasoning.</p>

<p>However, it's quite useful in the case where you declare <code>static</code> methods (not just properties) for a class, as these are added directly to that class's function object, not to the function object's <code>prototype</code> object. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-k">static</span> <span class="pl-en">cool</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span> ); }
    <span class="pl-en">wow</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>wow<span class="pl-pds">"</span></span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-k">static</span> <span class="pl-en">awesome</span>() {
        <span class="pl-v">super</span>.cool();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span> );
    }
    <span class="pl-en">neat</span>() {
        <span class="pl-v">super</span>.wow();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>neat<span class="pl-pds">"</span></span> );
    }
}

Foo.cool();                 <span class="pl-c">// "cool"</span>
Bar.cool();                 <span class="pl-c">// "cool"</span>
Bar.awesome();              <span class="pl-c">// "cool"</span>
                            <span class="pl-c">// "awesome"</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
b.neat();                   <span class="pl-c">// "wow"</span>
                            <span class="pl-c">// "neat"</span>

b.awesome;                  <span class="pl-c">// undefined</span>
b.cool;                     <span class="pl-c">// undefined</span></pre></div>

<p>Be careful not to get confused that <code>static</code> members are on the class's prototype chain. They're actually on the dual/parallel chain between the function constructors.</p>

<h4><a id="user-content-symbolspecies-constructor-getter" class="anchor" href="#symbolspecies-constructor-getter" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.species</code> Constructor Getter</h4>

<p>One place where <code>static</code> can be useful is in setting the <code>Symbol.species</code> getter (known internally in the specification as <code>@@species</code>) for a derived (child) class. This capability allows a child class to signal to a parent class what constructor should be used -- when not intending the child class's constructor itself -- if any parent class method needs to vend a new instance.</p>

<p>For example, many methods on <code>Array</code> create and return a new <code>Array</code> instance. If you define a derived class from <code>Array</code>, but you want those methods to continue to vend actual <code>Array</code> instances instead of from your derived class, this works:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ),
    b <span class="pl-k">=</span> a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){ <span class="pl-k">return</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span>; } );

b <span class="pl-k">instanceof</span> MyCoolArray;   <span class="pl-c">// false</span>
b <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;         <span class="pl-c">// true</span></pre></div>

<p>To illustrate how a parent class method can use a child's species declaration somewhat like <code>Array#map(..)</code> is doing, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-c">// defer `species` to derived constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; }
    <span class="pl-en">spawn</span>() {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">this.constructor</span>[Symbol.species]();
    }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> Foo; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
<span class="pl-k">var</span> b <span class="pl-k">=</span> a.spawn();
b <span class="pl-k">instanceof</span> Foo;                   <span class="pl-c">// true</span>

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
<span class="pl-k">var</span> y <span class="pl-k">=</span> x.spawn();
y <span class="pl-k">instanceof</span> Bar;                   <span class="pl-c">// false</span>
y <span class="pl-k">instanceof</span> Foo;                   <span class="pl-c">// true</span></pre></div>

<p>The parent class <code>Symbol.species</code> does <code>return this</code> to defer to any derived class, as you'd normally expect. <code>Bar</code> then overrides to manually declare <code>Foo</code> to be used for such instance creation. Of course, a derived class can still vend instances of itself using <code>new this.constructor(..)</code>.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 introduces several new features that aid in code organization:</p>

<ul>
<li>Iterators provide sequential access to data or operations. They can be consumed by new language features like <code>for..of</code> and <code>...</code>.</li>
<li>Generators are locally pause/resume capable functions controlled by an iterator. They can be used to programmatically (and interactively, through <code>yield</code>/<code>next(..)</code> message passing) <em>generate</em> values to be consumed via iteration.</li>
<li>Modules allow private encapsulation of implementation details with a publicly exported API. Module definitions are file-based, singleton instances, and statically resolved at compile time.</li>
<li>Classes provide cleaner syntax around prototype-based coding. The addition of <code>super</code> also solves tricky issues with relative references in the <code>[[Prototype]]</code> chain.</li>
</ul>

<p>These new tools should be your first stop when trying to improve the architecture of your JS projects by embracing ES6.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-4-async-flow-control" class="anchor" href="#chapter-4-async-flow-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4: Async Flow Control</h1>

<p>It's no secret if you've written any significant amount of JavaScript that asynchronous programming is a required skill. The primary mechanism for managing asynchrony has been the function callback.</p>

<p>However, ES6 adds a new feature that helps address significant shortcomings in the callbacks-only approach to async: <em>Promises</em>. In addition, we can revisit generators (from the previous chapter) and see a pattern for combining the two that's a major step forward in async flow control programming in JavaScript.</p>

<h2><a id="user-content-promises" class="anchor" href="#promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promises</h2>

<p>Let's clear up some misconceptions: Promises are not about replacing callbacks. Promises provide a trustable intermediary -- that is, between your calling code and the async code that will perform the task -- to manage callbacks.</p>

<p>Another way of thinking about a Promise is as an event listener, on which you can register to listen for an event that lets you know when a task has completed. It's an event that will only ever fire once, but it can be thought of as an event nonetheless.</p>

<p>Promises can be chained together, which can sequence a series of asychronously completing steps. Together with higher-level abstractions like the <code>all(..)</code> method (in classic terms, a "gate") and the <code>race(..)</code> method (in classic terms, a "latch"), promise chains provide a mechanism for async flow control.</p>

<p>Yet another way of conceptualizing a Promise is that it's a <em>future value</em>, a time-independent container wrapped around a value. This container can be reasoned about identically whether the underlying value is final or not. Observing the resolution of a Promise extracts this value once available. In other words, a Promise is said to be the async version of a sync function's return value.</p>

<p>A Promise can only have one of two possible resolution outcomes: fulfilled or rejected, with an optional single value. If a Promise is fulfilled, the final value is called a fulfillment. If it's rejected, the final value is called a reason (as in, a "reason for rejection"). Promises can only be resolved (fulfillment or rejection) <em>once</em>. Any further attempts to fulfill or reject are simply ignored. Thus, once a Promise is resolved, it's an immutable value that cannot be changed.</p>

<p>Clearly, there are several different ways to think about what a Promise is. No single perspective is fully sufficient, but each provides a separate aspect of the whole. The big takeaway is that they offer a significant improvement over callbacks-only async, namely that they provide order, predictability, and trustability.</p>

<h3><a id="user-content-making-and-using-promises" class="anchor" href="#making-and-using-promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Making and Using Promises</h3>

<p>To construct a promise instance, use the <code>Promise(..)</code> constructor:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>The <code>Promise(..)</code> constructor takes a single function (<code>pr(..)</code>), which is called immediately and receives two control functions as arguments, usually named <code>resolve(..)</code> and <code>reject(..)</code>. They are used as:</p>

<ul>
<li>If you call <code>reject(..)</code>, the promise is rejected, and if any value is passed to <code>reject(..)</code>, it is set as the reason for rejection.</li>
<li>If you call <code>resolve(..)</code> with no value, or any non-promise value, the promise is fulfilled.</li>
<li>If you call <code>resolve(..)</code> and pass another promise, this promise simply adopts the state -- whether immediate or eventual -- of the passed promise (either fulfillment or rejection).</li>
</ul>

<p>Here's how you'd typically use a promise to refactor a callback-reliant function call. If you start out with an <code>ajax(..)</code> utility that expects to be able to call an error-first style callback:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>,<span class="pl-smi">cb</span>) {
    <span class="pl-c">// make request, eventually call `cb(..)`</span>
}

<span class="pl-c">// ..</span>

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">handler</span>(<span class="pl-smi">err</span>,<span class="pl-smi">contents</span>){
    <span class="pl-k">if</span> (err) {
        <span class="pl-c">// handle ajax error</span>
    }
    <span class="pl-k">else</span> {
        <span class="pl-c">// handle `contents` success</span>
    }
} );</pre></div>

<p>You can convert it to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// make request, eventually call</span>
        <span class="pl-c">// either `resolve(..)` or `reject(..)`</span>
    } );
}

<span class="pl-c">// ..</span>

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-c">// handle `contents` success</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// handle ajax error reason</span>
    }
);</pre></div>

<p>Promises have a <code>then(..)</code> method that accepts one or two callback functions. The first function (if present) is treated as the handler to call if the promise is fulfilled successfully. The second function (if present) is treated as the handler to call if the promise is rejected explicitly, or if any error/exception is caught during resolution.</p>

<p>If one of the arguments is omitted or otherwise not a valid function -- typically you'll use <code>null</code> instead -- a default placeholder equivalent is used. The default success callback passes its fulfillment value along and the default error callback propagates its rejection reason along.</p>

<p>The shorthand for calling <code>then(null,handleRejection)</code> is <code>catch(handleRejection)</code>.</p>

<p>Both <code>then(..)</code> and <code>catch(..)</code> automatically construct and return another promise instance, which is wired to receive the resolution from whatever the return value is from the original promise's fulfillment or rejection handler (whichever is actually called). Consider:</p>

<div class="highlight highlight-source-js"><pre>ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-k">return</span> contents.<span class="pl-c1">toUpperCase</span>();
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>DEFAULT VALUE<span class="pl-pds">"</span></span>;
    }
)
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// handle data from original promise's</span>
    <span class="pl-c">// handlers</span>
} );</pre></div>

<p>In this snippet, we're returning an immediate value from either <code>fulfilled(..)</code> or <code>rejected(..)</code>, which then is received on the next event turn in the second <code>then(..)</code>'s <code>fulfilled(..)</code>. If we instead return a new promise, that new promise is subsumed and adopted as the resolution:</p>

<div class="highlight highlight-source-js"><pre>ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-k">return</span> ajax(
            <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> contents
        );
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-k">return</span> ajax(
            <span class="pl-s"><span class="pl-pds">"</span>http://backup.url.3?err=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> reason
        );
    }
)
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
    <span class="pl-c">// `contents` comes from the subsequent</span>
    <span class="pl-c">// `ajax(..)` call, whichever it was</span>
} );</pre></div>

<p>It's important to note that an exception (or rejected promise) in the first <code>fulfilled(..)</code> will <em>not</em> result in the first <code>rejected(..)</code> being called, as that handler only responds to the resolution of the first original promise. Instead, the second promise, which the second <code>then(..)</code> is called against, receives that rejection.</p>

<p>In this previous snippet, we are not listening for that rejection, which means it will be silently held onto for future observation. If you never observe it by calling a <code>then(..)</code> or <code>catch(..)</code>, then it will go unhandled. Some browser developer consoles may detect these unhandled rejections and report them, but this is not reliably guaranteed; you should always observe promise rejections.</p>

<p><strong>Note:</strong> This was just a brief overview of Promise theory and behavior. For a much more in-depth exploration, see Chapter 3 of the <em>Async &amp; Performance</em> title of this series.</p>

<h3><a id="user-content-thenables" class="anchor" href="#thenables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thenables</h3>

<p>Promises are genuine instances of the <code>Promise(..)</code> constructor. However, there are promise-like objects called <em>thenables</em> that generally can interoperate with the Promise mechanisms.</p>

<p>Any object (or function) with a <code>then(..)</code> function on it is assumed to be a thenable. Any place where the Promise mechanisms can accept and adopt the state of a genuine promise, they can also handle a thenable.</p>

<p>Thenables are basically a general label for any promise-like value that may have been created by some other system than the actual <code>Promise(..)</code> constructor. In that perspective, a thenable is generally less trustable than a genuine Promise. Consider this misbehaving thenable, for example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> th <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">thener</span>( <span class="pl-smi">fulfilled</span> ) {
        <span class="pl-c">// call `fulfilled(..)` once every 100ms forever</span>
        <span class="pl-c1">setInterval</span>( fulfilled, <span class="pl-c1">100</span> );
    }
};</pre></div>

<p>If you received that thenable and chained it with <code>th.then(..)</code>, you'd likely be surprised that your fulfillment handler is called repeatedly, when normal Promises are supposed to only ever be resolved once.</p>

<p>Generally, if you're receiving what purports to be a promise or thenable back from some other system, you shouldn't just trust it blindly. In the next section, we'll see a utility included with ES6 Promises that helps address this trust concern.</p>

<p>But to further understand the perils of this issue, consider that <em>any</em> object in <em>any</em> piece of code that's ever been defined to have a method on it called <code>then(..)</code> can be potentially confused as a thenable -- if used with Promises, of course -- regardless of if that thing was ever intended to even remotely be related to Promise-style async coding.</p>

<p>Prior to ES6, there was never any special reservation made on methods called <code>then(..)</code>, and as you can imagine there's been at least a few cases where that method name has been chosen prior to Promises ever showing up on the radar screen. The most likely case of mistaken thenable will be async libraries that use <code>then(..)</code> but which are not strictly Promises-compliant -- there are several out in the wild.</p>

<p>The onus will be on you to guard against directly using values with the Promise mechanism that would be incorrectly assumed to be a thenable.</p>

<h3><a id="user-content-promise-api" class="anchor" href="#promise-api" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Promise</code> API</h3>

<p>The <code>Promise</code> API also provides some static methods for working with Promises.</p>

<p><code>Promise.resolve(..)</code> creates a promise resolved to the value passed in. Let's compare how it works to the more manual approach:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    resolve( <span class="pl-c1">42</span> );
} );</pre></div>

<p><code>p1</code> and <code>p2</code> will have essentially identical behavior. The same goes for resolving with a promise:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> theP <span class="pl-k">=</span> ajax( .. );

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( theP );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    resolve( theP );
} );</pre></div>

<p><strong>Tip:</strong> <code>Promise.resolve(..)</code> is the solution to the thenable trust issue raised in the previous section. Any value that you are not already certain is a trustable promise -- even if it could be an immediate value -- can be normalized by passing it to <code>Promise.resolve(..)</code>. If the value is already a recognizable promise or thenable, its state/resolution will simply be adopted, insulating you from misbehavior. If it's instead an immediate value, it will be "wrapped" in a genuine promise, thereby normalizing its behavior to be async.</p>

<p><code>Promise.reject(..)</code> creates an immediately rejected promise, the same as its <code>Promise(..)</code> constructor counterpart:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
} );</pre></div>

<p>While <code>resolve(..)</code> and <code>Promise.resolve(..)</code> can accept a promise and adopt its state/resolution, <code>reject(..)</code> and <code>Promise.reject(..)</code> do not differentiate what value they receive. So, if you reject with a promise or thenable, the promise/thenable itself will be set as the rejection reason, not its underlying value.</p>

<p><code>Promise.all([ .. ])</code> accepts an array of one or more values (e.g., immediate values, promises, thenables). It returns a promise back that will be fulfilled if all the values fulfill, or reject immediately once the first of any of them rejects.</p>

<p>Starting with these values/promises:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        resolve( <span class="pl-c1">43</span> );
    }, <span class="pl-c1">100</span> );
} );
<span class="pl-k">var</span> v3 <span class="pl-k">=</span> <span class="pl-c1">44</span>;
<span class="pl-k">var</span> p4 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
    }, <span class="pl-c1">10</span> );
} );</pre></div>

<p>Let's consider how <code>Promise.all([ .. ])</code> works with combinations of those values:</p>

<div class="highlight highlight-source-js"><pre>Promise.<span class="pl-c1">all</span>( [p1,p2,v3] )
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">vals</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( vals );            <span class="pl-c">// [42,43,44]</span>
} );

Promise.<span class="pl-c1">all</span>( [p1,p2,v3,p4] )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">vals</span>){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( reason );      <span class="pl-c">// Oops</span>
    }
);</pre></div>

<p>While <code>Promise.all([ .. ])</code> waits for all fulfillments (or the first rejection), <code>Promise.race([ .. ])</code> waits only for either the first fulfillment or rejection. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// NOTE: re-setup all test values to</span>
<span class="pl-c">// avoid timing issues misleading you!</span>

Promise.race( [p2,p1,v3] )
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );             <span class="pl-c">// 42</span>
} );

Promise.race( [p2,p1,v3,p4] )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( reason );      <span class="pl-c">// Oops</span>
    }
);</pre></div>

<p><strong>Warning:</strong> While <code>Promise.all([])</code> will fulfill right away (with no values), <code>Promise.race([])</code> will hang forever. This is a strange inconsistency, and speaks to the suggestion that you should never use these methods with empty arrays.</p>

<h2><a id="user-content-generators--promises" class="anchor" href="#generators--promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators + Promises</h2>

<p>It <em>is</em> possible to express a series of promises in a chain to represent the async flow control of your program. Consider:</p>

<div class="highlight highlight-source-js"><pre>step1()
.then(
    step2,
    step2Failed
)
.then(
    <span class="pl-k">function</span> <span class="pl-en">step3</span>(<span class="pl-smi">msg</span>) {
        <span class="pl-k">return</span> Promise.<span class="pl-c1">all</span>( [
            step3a( msg ),
            step3b( msg ),
            step3c( msg )
        ] )
    }
)
.then(step4);</pre></div>

<p>However, there's a much better option for expressing async flow control, and it will probably be much more preferable in terms of coding style than long promise chains. We can use what we learned in Chapter 3 about generators to express our async flow control.</p>

<p>The important pattern to recognize: a generator can yield a promise, and that promise can then be wired to resume the generator with its fulfillment value.</p>

<p>Consider the previous snippet's async flow control expressed with a generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2Failed( err );
    }

    <span class="pl-c">// step 3</span>
    ret <span class="pl-k">=</span> <span class="pl-k">yield</span> Promise.<span class="pl-c1">all</span>( [
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ] );

    <span class="pl-k">yield</span> step4( ret );
}</pre></div>

<p>On the surface, this snippet may seem more verbose than the promise chain equivalent in the earlier snippet. However, it offers a much more attractive -- and more importantly, a more understandable and reason-able -- synchronous-looking coding style (with <code>=</code> assignment of "return" values, etc.) That's especially true in that <code>try..catch</code> error handling can be used across those hidden async boundaries.</p>

<p>Why are we using Promises with the generator? It's certainly possible to do async generator coding without Promises.</p>

<p>Promises are a trustable system that uninverts the inversion of control of normal callbacks or thunks (see the <em>Async &amp; Performance</em> title of this series). So, combining the trustability of Promises and the synchronicity of code in generators effectively addresses all the major deficiencies of callbacks. Also, utilities like <code>Promise.all([ .. ])</code> are a nice, clean way to express concurrency at a generator's single <code>yield</code> step.</p>

<p>So how does this magic work? We're going to need a <em>runner</em> that can run our generator, receive a <code>yield</code>ed promise, and wire it up to resume the generator with either the fulfillment success value, or throw an error into the generator with the rejection reason.</p>

<p>Many async-capable utilities/libraries have such a "runner"; for example, <code>Q.spawn(..)</code> and my asynquence's <code>runner(..)</code> plug-in. But here's a stand-alone runner to illustrate how the process works:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">run</span>(<span class="pl-smi">gen</span>) {
    <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span>), it;

    it <span class="pl-k">=</span> gen.<span class="pl-c1">apply</span>( <span class="pl-v">this</span>, args );

    <span class="pl-k">return</span> Promise.resolve()
        .then( <span class="pl-k">function</span> <span class="pl-en">handleNext</span>(<span class="pl-smi">value</span>){
            <span class="pl-k">var</span> next <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( value );

            <span class="pl-k">return</span> (<span class="pl-k">function</span> <span class="pl-en">handleResult</span>(<span class="pl-smi">next</span>){
                <span class="pl-k">if</span> (next.done) {
                    <span class="pl-k">return</span> next.<span class="pl-c1">value</span>;
                }
                <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> Promise.resolve( next.<span class="pl-c1">value</span> )
                        .then(
                            handleNext,
                            <span class="pl-k">function</span> <span class="pl-en">handleErr</span>(<span class="pl-smi">err</span>) {
                                <span class="pl-k">return</span> Promise.resolve(
                                    it.throw( err )
                                )
                                .then( handleResult );
                            }
                        );
                }
            })( next );
        } );
}</pre></div>

<p><strong>Note:</strong> For a more prolifically commented version of this utility, see the <em>Async &amp; Performance</em> title of this series. Also, the run utilities provided with various async libraries are often more powerful/capable than what we've shown here. For example, asynquence's <code>runner(..)</code> can handle <code>yield</code>ed promises, sequences, thunks, and immediate (non-promise) values, giving you ultimate flexibility.</p>

<p>So now running <code>*main()</code> as listed in the earlier snippet is as easy as:</p>

<div class="highlight highlight-source-js"><pre>run( main )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `*main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>Essentially, anywhere that you have more than two asynchronous steps of flow control logic in your program, you can <em>and should</em> use a promise-yielding generator driven by a run utility to express the flow control in a synchronous fashion. This will make for much easier to understand and maintain code.</p>

<p>This yield-a-promise-resume-the-generator pattern is going to be so common and so powerful, the next version of JavaScript after ES6 is almost certainly going to introduce a new function type that will do it automatically without needing the run utility. We'll cover <code>async function</code>s (as they're expected to be called) in Chapter 8.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>As JavaScript continues to mature and grow in its widespread adoption, asynchronous programming is more and more of a central concern. Callbacks are not fully sufficient for these tasks, and totally fall down the more sophisticated the need.</p>

<p>Thankfully, ES6 adds Promises to address one of the major shortcomings of callbacks: lack of trust in predictable behavior. Promises represent the future completion value from a potentially async task, normalizing behavior across sync and async boundaries.</p>

<p>But it's the combination of Promises with generators that fully realizes the benefits of rearranging our async flow control code to de-emphasize and abstract away that ugly callback soup (aka "hell").</p>

<p>Right now, we can manage these interactions with the aide of various async libraries' runners, but JavaScript is eventually going to support this interaction pattern with dedicated syntax alone!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-5-collections" class="anchor" href="#chapter-5-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 5: Collections</h1>

<p>Structured collection and access to data is a critical component of just about any JS program. From the beginning of the language up to this point, the array and the object have been our primary mechanism for creating data structures. Of course, many higher-level data structures have been built on top of these, as user-land libraries.</p>

<p>As of ES6, some of the most useful (and performance-optimizing!) data structure abstractions have been added as native components of the language.</p>

<p>We'll start this chapter first by looking at <em>TypedArrays</em>, technically contemporary to ES5 efforts several years ago, but only standardized as companions to WebGL and not JavaScript itself. As of ES6, these have been adopted directly by the language specification, which gives them first-class status.</p>

<p>Maps are like objects (key/value pairs), but instead of just a string for the key, you can use any value -- even another object or map! Sets are similar to arrays (lists of values), but the values are unique; if you add a duplicate, it's ignored. There are also weak (in relation to memory/garbage collection) counterparts: WeakMap and WeakSet.</p>

<h2><a id="user-content-typedarrays" class="anchor" href="#typedarrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypedArrays</h2>

<p>As we cover in the <em>Types &amp; Grammar</em> title of this series, JS does have a set of built-in types, like <code>number</code> and <code>string</code>. It'd be tempting to look at a feature named "typed array" and assume it means an array of a specific type of values, like an array of only strings.</p>

<p>However, typed arrays are really more about providing structured access to binary data using array-like semantics (indexed access, etc.). The "type" in the name refers to a "view" layered on type of the bucket of bits, which is essentially a mapping of whether the bits should be viewed as an array of 8-bit signed integers, 16-bit signed integers, and so on.</p>

<p>How do you construct such a bit-bucket? It's called a "buffer," and you construct it most directly with the <code>ArrayBuffer(..)</code> constructor:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> buf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">32</span> );
buf.byteLength;                         <span class="pl-c">// 32</span></pre></div>

<p><code>buf</code> is now a binary buffer that is 32-bytes long (256-bits), that's pre-initialized to all <code>0</code>s. A buffer by itself doesn't really allow you any interaction exception for checking its <code>byteLength</code> property.</p>

<p><strong>Tip:</strong> Several web platform features use or return array buffers, such as <code>FileReader#readAsArrayBuffer(..)</code>, <code>XMLHttpRequest#send(..)</code>, and <code>ImageData</code> (canvas data).</p>

<p>But on top of this array buffer, you can then layer a "view," which comes in the form of a typed array. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf );
arr.<span class="pl-c1">length</span>;                         <span class="pl-c">// 16</span></pre></div>

<p><code>arr</code> is a typed array of 16-bit unsigned integers mapped over the 256-bit <code>buf</code> buffer, meaning you get 16 elements.</p>

<h3><a id="user-content-endianness" class="anchor" href="#endianness" aria-hidden="true"><span class="octicon octicon-link"></span></a>Endianness</h3>

<p>It's very important to understand that the <code>arr</code> is mapped using the endian-setting (big-endian or little-endian) of the platform the JS is running on. This can be an issue if the binary data is created with one endianness but interpreted on a platform with the opposite endianness.</p>

<p>Endian means if the low-order byte (collection of 8-bits) of a multi-byte number -- such as the 16-bit unsigned ints we created in the earlier snippet -- is on the right or the left of the number's bytes.</p>

<p>For example, let's imagine the base-10 number <code>3085</code>, which takes 16-bits to represent. If you have just one 16-bit number container, it'd be represented in binary as <code>0000110000001101</code> (hexadecimal <code>0c0d</code>) regardless of endianness.</p>

<p>But if <code>3085</code> was represented with two 8-bit numbers, the endianness would significantly affect its storage in memory:</p>

<ul>
<li><code>0000110000001101</code> / <code>0c0d</code> (big endian)</li>
<li><code>0000110100001100</code> / <code>0d0c</code> (little endian)</li>
</ul>

<p>If you received the bits of <code>3085</code> as <code>0000110100001100</code> from a little-endian system, but you layered a view on top of it in a big-endian system, you'd instead see value <code>3340</code> (base-10) and <code>0d0c</code> (base-16).</p>

<p>Little endian is the most common representation on the web these days, but there are definitely browsers where that's not true. It's important that you understand the endianness of both the producer and consumer of a chunk of binary data.</p>

<p>From MDN, here's a quick way to test the endianness of your JavaScript:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> littleEndian <span class="pl-k">=</span> (<span class="pl-k">function</span>() {
    <span class="pl-k">var</span> buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">2</span> );
    <span class="pl-k">new</span> <span class="pl-en">DataView</span>( buffer ).setInt16( <span class="pl-c1">0</span>, <span class="pl-c1">256</span>, <span class="pl-c1">true</span> );
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Int16Array</span>( buffer )[<span class="pl-c1">0</span>] <span class="pl-k">===</span> <span class="pl-c1">256</span>;
})();</pre></div>

<p><code>littleEndian</code> will be <code>true</code> or <code>false</code>; for most browsers, it should return <code>true</code>. This test uses <code>DataView(..)</code>, which allows more low-level, fine-grained control over accessing (setting/getting) the bits from the view you layer over the buffer. The third parameter of the <code>setInt16(..)</code> method in the previous snippet is for telling the <code>DataView</code> what endianness you're wanting it to use for that operation.</p>

<p><strong>Warning:</strong> Do not confuse endianness of underlying binary storage in array buffers with how a given number is represented when exposed in a JS program. For example, <code>(3085).toString(2)</code> returns <code>"110000001101"</code>, which with an assumed leading four <code>"0"</code>s appears to be the big-endian representation. In fact, this representation is based on a single 16-bit view, not a view of two 8-bit bytes. The <code>DataView</code> test above is the best way to determine endianness for your JS environment.</p>

<h3><a id="user-content-multiple-views" class="anchor" href="#multiple-views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Views</h3>

<p>A single buffer can have multiple views attached to it, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> buf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">2</span> );

<span class="pl-k">var</span> view8 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf );
<span class="pl-k">var</span> view16 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf );

view16[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">3085</span>;
view8[<span class="pl-c1">0</span>];                       <span class="pl-c">// 13</span>
view8[<span class="pl-c1">1</span>];                       <span class="pl-c">// 12</span>

view8[<span class="pl-c1">0</span>].<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );        <span class="pl-c">// "d"</span>
view8[<span class="pl-c1">1</span>].<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );        <span class="pl-c">// "c"</span>

<span class="pl-c">// swap (as if endian!)</span>
<span class="pl-k">var</span> tmp <span class="pl-k">=</span> view8[<span class="pl-c1">0</span>];
view8[<span class="pl-c1">0</span>] <span class="pl-k">=</span> view8[<span class="pl-c1">1</span>];
view8[<span class="pl-c1">1</span>] <span class="pl-k">=</span> tmp;

view16[<span class="pl-c1">0</span>];                      <span class="pl-c">// 3340</span></pre></div>

<p>The typed array constructors have multiple signature variations. We've shown so far only passing them an existing buffer. However, that form also takes two extra parameters: <code>byteOffset</code> and <code>length</code>. In other words, you can start the typed array view at a location other than <code>0</code> and you can make it span less than the full length of the buffer.</p>

<p>If the buffer of binary data includes data in non-uniform size/location, this technique can be quite useful.</p>

<p>For example, consider a binary buffer that has a 2-byte number (aka "word") at the beginning, followed by two 1-byte numbers, followed by a 32-bit floating point number. Here's how you can access that data with multiple views on the same buffer, offsets, and lengths:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> first <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf, <span class="pl-c1">0</span>, <span class="pl-c1">2</span> )[<span class="pl-c1">0</span>],
    second <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf, <span class="pl-c1">2</span>, <span class="pl-c1">1</span> )[<span class="pl-c1">0</span>],
    third <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf, <span class="pl-c1">3</span>, <span class="pl-c1">1</span> )[<span class="pl-c1">0</span>],
    fourth <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Float32Array</span>( buf, <span class="pl-c1">4</span>, <span class="pl-c1">4</span> )[<span class="pl-c1">0</span>];</pre></div>

<h3><a id="user-content-typedarray-constructors" class="anchor" href="#typedarray-constructors" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypedArray Constructors</h3>

<p>In addition to the <code>(buffer,[offset, [length]])</code> form examined in the previous section, typed array constructors also support these forms:</p>

<ul>
<li>[constructor]<code>(length)</code>: Creates a new view over a new buffer of <code>length</code> bytes</li>
<li>[constructor]<code>(typedArr)</code>: Creates a new view and buffer, and copies the contents from the <code>typedArr</code> view</li>
<li>[constructor]<code>(obj)</code>: Creates a new view and buffer, and iterates over the array-like or object <code>obj</code> to copy its contents</li>
</ul>

<p>The following typed array constructors are available as of ES6:</p>

<ul>
<li><code>Int8Array</code> (8-bit signed integers), <code>Uint8Array</code> (8-bit unsigned integers)

<ul>
<li><code>Uint8ClampedArray</code> (8-bit unsigned integers, each value clamped on setting to the <code>0</code>-<code>255</code> range)</li>
</ul></li>
<li><code>Int16Array</code> (16-bit signed integers), <code>Uint16Array</code> (16-bit unsigned integers)</li>
<li><code>Int32Array</code> (32-bit signed integers), <code>Uint32Array</code> (32-bit unsigned integers)</li>
<li><code>Float32Array</code> (32-bit floating point, IEEE-754)</li>
<li><code>Float64Array</code> (64-bit floating point, IEEE-754)</li>
</ul>

<p>Instances of typed array constructors are almost the same as regular native arrays. Some differences include having a fixed length and the values all being of the same "type."</p>

<p>However, they share most of the same <code>prototype</code> methods. As such, you likely will be able to use them as regular arrays without needing to convert.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Int32Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );
<span class="pl-c">// 10 20 30</span>

a.<span class="pl-c1">join</span>( <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> );
<span class="pl-c">// "10-20-30"</span></pre></div>

<p><strong>Warning:</strong> You can't use certain <code>Array.prototype</code> methods with TypedArrays that don't make sense, such as the mutators (<code>splice(..)</code>, <code>push(..)</code>, etc.) and <code>concat(..)</code>.</p>

<p>Be aware that the elements in TypedArrays really are constrained to the declared bit sizes. If you have a <code>Uint8Array</code> and try to assign something larger than an 8-bit value into one of its elements, the value wraps around so as to stay within the bit length.</p>

<p>This could cause problems if you were trying to, for instance, square all the values in a TypedArray. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">*</span> v;
} );

b;              <span class="pl-c">// [100, 144, 132]</span></pre></div>

<p>The <code>20</code> and <code>30</code> values, when squared, resulted in bit overflow. To get around such a limitation, you can use the <code>TypedArray#from(..)</code> function:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> Uint16Array.from( a, <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">*</span> v;
} );

b;              <span class="pl-c">// [100, 400, 900]</span></pre></div>

<p>See the "<code>Array.from(..)</code> Static Function" section in Chapter 6 for more information about the <code>Array.from(..)</code> that is shared with TypedArrays. Specifically, the "Mapping" section explains the mapping function accepted as its second argument.</p>

<p>One interesting behavior to consider is that TypedArrays have a <code>sort(..)</code> method much like regular arrays, but this one defaults to numeric sort comparisons instead of coercing values to strings for lexicographic comparison. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [ <span class="pl-c1">10</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, ];
a.<span class="pl-c1">sort</span>();                               <span class="pl-c">// [1,10,2]</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( [ <span class="pl-c1">10</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ] );
b.<span class="pl-c1">sort</span>();                               <span class="pl-c">// [1,2,10]</span></pre></div>

<p>The <code>TypedArray#sort(..)</code> takes an optional compare function argument just like <code>Array#sort(..)</code>, which works in exactly the same way.</p>

<h2><a id="user-content-maps" class="anchor" href="#maps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maps</h2>

<p>If you have a lot of JS experience, you know that objects are the primary mechanism for creating unordered key/value-pair data structures, otherwise known as maps. However, the major drawback with objects-as-maps is the inability to use a non-string value as the key.</p>

<p>For example, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> {};

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m[x] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
m[y] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

m[x];                           <span class="pl-c">// "bar"</span>
m[y];                           <span class="pl-c">// "bar"</span></pre></div>

<p>What's going on here? The two objects <code>x</code> and <code>y</code> both stringify to <code>"[object Object]"</code>, so only that one key is being set in <code>m</code>.</p>

<p>Some have implemented fake maps by maintaining a parallel array of non-string keys alongside an array of the values, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> keys <span class="pl-k">=</span> [], vals <span class="pl-k">=</span> [];

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

keys.<span class="pl-c1">push</span>( x );
vals.<span class="pl-c1">push</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

keys.<span class="pl-c1">push</span>( y );
vals.<span class="pl-c1">push</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;                  <span class="pl-c">// true</span>
vals[<span class="pl-c1">0</span>];                        <span class="pl-c">// "foo"</span>

keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;                  <span class="pl-c">// true</span>
vals[<span class="pl-c1">1</span>];                        <span class="pl-c">// "bar"</span></pre></div>

<p>Of course, you wouldn't want to manage those parallel arrays yourself, so you could define a data structure with methods that automatically do the management under the covers. Besides having to do that work yourself, the main drawback is that access is no longer O(1) time-complexity, but instead is O(n).</p>

<p>But as of ES6, there's no longer any need to do this! Just use <code>Map(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

m.get( x );                     <span class="pl-c">// "foo"</span>
m.get( y );                     <span class="pl-c">// "bar"</span></pre></div>

<p>The only drawback is that you can't use the <code>[ ]</code> bracket access syntax for setting and retrieving values. But <code>get(..)</code> and <code>set(..)</code> work perfectly suitably instead.</p>

<p>To delete an element from a map, don't use the <code>delete</code> operator, but instead use the <code>delete(..)</code> method:</p>

<div class="highlight highlight-source-js"><pre>m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

m.delete( y );</pre></div>

<p>You can clear the entire map's contents with <code>clear()</code>. To get the length of a map (i.e., the number of keys), use the <code>size</code> property (not <code>length</code>):</p>

<div class="highlight highlight-source-js"><pre>m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );
m.<span class="pl-c1">size</span>;                         <span class="pl-c">// 2</span>

m.<span class="pl-c1">clear</span>();
m.<span class="pl-c1">size</span>;                         <span class="pl-c">// 0</span></pre></div>

<p>The <code>Map(..)</code> constructor can also receive an iterable (see "Iterators" in Chapter 3), which must produce a list of arrays, where the first item in each array is the key and the second item is the value. This format for iteration is identical to that produced by the <code>entries()</code> method, explained in the next section. That makes it easy to make a copy of a map:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( m.entries() );

<span class="pl-c">// same as:</span>
<span class="pl-k">var</span> m2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( m );</pre></div>

<p>Because a map instance is an iterable, and its default iterator is the same as <code>entries()</code>, the second shorter form is more preferable.</p>

<p>Of course, you can just manually specify an <em>entries</em> list (array of key/value arrays) in the <code>Map(..)</code> constructor form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( [
    [ x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ],
    [ y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ]
] );

m.get( x );                     <span class="pl-c">// "foo"</span>
m.get( y );                     <span class="pl-c">// "bar"</span></pre></div>

<h3><a id="user-content-map-values" class="anchor" href="#map-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map Values</h3>

<p>To get the list of values from a map, use <code>values(..)</code>, which returns an iterator. In Chapters 2 and 3, we covered various ways to process an iterator sequentially (like an array), such as the <code>...</code> spread operator and the <code>for..of</code> loop. Also, "Arrays" in Chapter 6 covers the <code>Array.from(..)</code> method in detail. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> vals <span class="pl-k">=</span> [ ...m.values() ];

vals;                           <span class="pl-c">// ["foo","bar"]</span>
<span class="pl-c1">Array</span>.from( m.values() );       <span class="pl-c">// ["foo","bar"]</span></pre></div>

<p>As discussed in the previous section, you can iterate over a map's entries using <code>entries()</code> (or the default map iterator). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> vals <span class="pl-k">=</span> [ ...m.entries() ];

vals[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;               <span class="pl-c">// true</span>
vals[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>];                     <span class="pl-c">// "foo"</span>

vals[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> y;               <span class="pl-c">// true</span>
vals[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>];                     <span class="pl-c">// "bar"</span></pre></div>

<h3><a id="user-content-map-keys" class="anchor" href="#map-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map Keys</h3>

<p>To get the list of keys, use <code>keys()</code>, which returns an iterator over the keys in the map:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> keys <span class="pl-k">=</span> [ ...m.keys() ];

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;                  <span class="pl-c">// true</span>
keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;                  <span class="pl-c">// true</span></pre></div>

<p>To determine if a map has a given key, use <code>has(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

m.has( x );                     <span class="pl-c">// true</span>
m.has( y );                     <span class="pl-c">// false</span></pre></div>

<p>Maps essentially let you associate some extra piece of information (the value) with an object (the key) without actually putting that information on the object itself.</p>

<p>While you can use any kind of value as a key for a map, you typically will use objects, as strings and other primitives are already eligible as keys of normal objects. In other words, you'll probably want to continue to use normal objects for maps unless some or all of the keys need to be objects, in which case map is more appropriate.</p>

<p><strong>Warning:</strong> If you use an object as a map key and that object is later discarded (all references unset) in attempt to have garbage collection (GC) reclaim its memory, the map itself will still retain its entry. You will need to remove the entry from the map for it to be GC-eligible. In the next section, we'll see WeakMaps as a better option for object keys and GC.</p>

<h2><a id="user-content-weakmaps" class="anchor" href="#weakmaps" aria-hidden="true"><span class="octicon octicon-link"></span></a>WeakMaps</h2>

<p>WeakMaps are a variation on maps, which has most of the same external behavior but differs underneath in how the memory allocation (specifically its GC) works.</p>

<p>WeakMaps take (only) objects as keys. Those objects are held <em>weakly</em>, which means if the object itself is GC'd, the entry in the WeakMap is also removed. This isn't observable behavior, though, as the only way an object can be GC'd is if there's no more references to it -- once there are no more references to it, you have no object reference to check if it exists in the WeakMap.</p>

<p>Otherwise, the API for WeakMap is similar, though more limited:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakMap</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

m.has( x );                     <span class="pl-c">// true</span>
m.has( y );                     <span class="pl-c">// false</span></pre></div>

<p>WeakMaps do not have a <code>size</code> property or <code>clear()</code> method, nor do they expose any iterators over their keys, values, or entries. So even if you unset the <code>x</code> reference, which will remove its entry from <code>m</code> upon GC, there is no way to tell. You'll just have to take JavaScript's word for it!</p>

<p>Just like Maps, WeakMaps let you soft-associate information with an object. But they are particularly useful if the object is not one you completely control, such as a DOM element. If the object you're using as a map key can be deleted and should be GC-eligible when it is, then a WeakMap is a more appropriate option.</p>

<p>It's important to note that a WeakMap only holds its <em>keys</em> weakly, not its values. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakMap</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    z <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    w <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">4</span> };

m.set( x, y );

x <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 1 } is GC-eligible</span>
y <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 2 } is GC-eligible</span>
                                <span class="pl-c">// only because { id: 1 } is</span>

m.set( z, w );

w <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 4 } is not GC-eligible</span></pre></div>

<p>For this reason, WeakMaps are in my opinion better named "WeakKeyMaps."</p>

<h2><a id="user-content-sets" class="anchor" href="#sets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sets</h2>

<p>A set is a collection of unique values (duplicates are ignored).</p>

<p>The API for a set is similar to map. The <code>add(..)</code> method takes the place of the <code>set(..)</code> method (somewhat ironically), and there is no <code>get(..)</code> method.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );
s.<span class="pl-c1">add</span>( y );
s.<span class="pl-c1">add</span>( x );

s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 2</span>

s.delete( y );
s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 1</span>

s.<span class="pl-c1">clear</span>();
s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 0</span></pre></div>

<p>The <code>Set(..)</code> constructor form is similar to <code>Map(..)</code>, in that it can receive an iterable, like another set or simply an array of values. However, unlike how <code>Map(..)</code> expects <em>entries</em> list (array of key/value arrays), <code>Set(..)</code> expects a <em>values</em> list (array of values):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>( [x,y] );</pre></div>

<p>A set doesn't need a <code>get(..)</code> because you don't retrieve a value from a set, but rather test if it is present or not, using <code>has(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );

s.has( x );                     <span class="pl-c">// true</span>
s.has( y );                     <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> The comparison algorithm in <code>has(..)</code> is almost identical to <code>Object.is(..)</code> (see Chapter 6), except that <code>-0</code> and <code>0</code> are treated as the same rather than distinct.</p>

<h3><a id="user-content-set-iterators" class="anchor" href="#set-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Set Iterators</h3>

<p>Sets have the same iterator methods as maps. Their behavior is different for sets, but symmetric with the behavior of map iterators. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x ).<span class="pl-c1">add</span>( y );

<span class="pl-k">var</span> keys <span class="pl-k">=</span> [ ...s.keys() ],
    vals <span class="pl-k">=</span> [ ...s.values() ],
    entries <span class="pl-k">=</span> [ ...s.entries() ];

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;

vals[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
vals[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;

entries[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
entries[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">===</span> x;
entries[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> y;
entries[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;</pre></div>

<p>The <code>keys()</code> and <code>values()</code> iterators both yield a list of the unique values in the set. The <code>entries()</code> iterator yields a list of entry arrays, where both items of the array are the unique set value. The default iterator for a set is its <code>values()</code> iterator.</p>

<p>The inherent uniqueness of a set is its most useful trait. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>( [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>,<span class="pl-c1">2</span>,<span class="pl-c1">4</span>,<span class="pl-s"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>] ),
    uniques <span class="pl-k">=</span> [ ...s ];

uniques;                        <span class="pl-c">// [1,2,3,4,"1","5"]</span></pre></div>

<p>Set uniqueness does not allow coercion, so <code>1</code> and <code>"1"</code> are considered distinct values.</p>

<h2><a id="user-content-weaksets" class="anchor" href="#weaksets" aria-hidden="true"><span class="octicon octicon-link"></span></a>WeakSets</h2>

<p>Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet holds its values weakly (there aren't really keys).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakSet</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );
s.<span class="pl-c1">add</span>( y );

x <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// `x` is GC-eligible</span>
y <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// `y` is GC-eligible</span></pre></div>

<p><strong>Warning:</strong> WeakSet values must be objects, not primitive values as is allowed with sets.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 defines a number of useful collections that make working with data in structured ways more efficient and effective.</p>

<p>TypedArrays provide "view"s of binary data buffers that align with various integer types, like 8-bit unsigned integers and 32-bit floats. The array access to binary data makes operations much easier to express and maintain, which enables you to more easily work with complex data like video, audio, canvas data, and so on.</p>

<p>Maps are key-value pairs where the key can be an object instead of just a string/primitive. Sets are unique lists of values (of any type).</p>

<p>WeakMaps are maps where the key (object) is weakly held, so that GC is free to collect the entry if it's the last reference to an object. WeakSets are sets where the value is weakly held, again so that GC can remove the entry if it's the last reference to that object.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-6-api-additions" class="anchor" href="#chapter-6-api-additions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 6: API Additions</h1>

<p>From conversions of values to mathematic calculations, ES6 adds many static properties and methods to various built-in natives and objects to help with common tasks. In addition, instances of some of the natives have new capabilities via various new prototype methods.</p>

<p><strong>Note:</strong> Most of these features can be faithfully polyfilled. We will not dive into such details here, but check out "ES6 Shim" (<a href="https://github.com/paulmillr/es6-shim/">https://github.com/paulmillr/es6-shim/</a>) for standards-compliant shims/polyfills.</p>

<h2><a id="user-content-array" class="anchor" href="#array" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array</code></h2>

<p>One of the most commonly extended features in JS by various user libraries is the Array type. It should be no surprise that ES6 adds a number of helpers to Array, both static and prototype (instance).</p>

<h3><a id="user-content-arrayof-static-function" class="anchor" href="#arrayof-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array.of(..)</code> Static Function</h3>

<p>There's a well known gotcha with the <code>Array(..)</code> constructor, which is that if there's only one argument passed, and that argument is a number, instead of making an array of one element with that number value in it, it constructs an empty array with a <code>length</code> property equal to the number. This action produces the unfortunate and quirky "empty slots" behavior that's reviled about JS arrays.</p>

<p><code>Array.of(..)</code> replaces <code>Array(..)</code> as the preferred function-form constructor for arrays, because <code>Array.of(..)</code> does not have that special single-number-argument case. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">3</span> );
a.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3</span>
a[<span class="pl-c1">0</span>];                           <span class="pl-c">// undefined</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Array</span>.of( <span class="pl-c1">3</span> );
b.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
b[<span class="pl-c1">0</span>];                           <span class="pl-c">// 3</span>

<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">Array</span>.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );
c.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3</span>
c;                              <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Under what circumstances would you want to use <code>Array.of(..)</code> instead of just creating an array with literal syntax, like <code>c = [1,2,3]</code>? There's two possible cases.</p>

<p>If you have a callback that's supposed to wrap argument(s) passed to it in an array, <code>Array.of(..)</code> fits the bill perfectly. That's probably not terribly common, but it may scratch an itch for you.</p>

<p>The other scenario is if you subclass <code>Array</code> (see "Classes" in Chapter 3) and want to be able to create and initialize elements in an instance of your subclass, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-en">sum</span>() {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.reduce( <span class="pl-k">function</span> <span class="pl-en">reducer</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">curr</span>){
            <span class="pl-k">return</span> acc <span class="pl-k">+</span> curr;
        }, <span class="pl-c1">0</span> );
    }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">3</span> );
x.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3 -- oops!</span>
x.sum();                        <span class="pl-c">// 0 -- oops!</span>

<span class="pl-k">var</span> y <span class="pl-k">=</span> [<span class="pl-c1">3</span>];                    <span class="pl-c">// Array, not MyCoolArray</span>
y.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
y.sum();                        <span class="pl-c">// `sum` is not a function</span>

<span class="pl-k">var</span> z <span class="pl-k">=</span> MyCoolArray.of( <span class="pl-c1">3</span> );
z.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
z.sum();                        <span class="pl-c">// 3</span></pre></div>

<p>You can't just (easily) create a constructor for <code>MyCoolArray</code> that overrides the behavior of the <code>Array</code> parent constructor, because that constructor is necessary to actually create a well-behaving array value (initializing the <code>this</code>). The "inherited" static <code>of(..)</code> method on the <code>MyCoolArray</code> subclass provides a nice solution.</p>

<h3><a id="user-content-arrayfrom-static-function" class="anchor" href="#arrayfrom-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array.from(..)</code> Static Function</h3>

<p>An "array-like object" in JavaScript is an object that has a <code>length</code> property on it, specifically with an integer value of zero or higher.</p>

<p>These values have been notoriously frustrating to work with in JS; it's been quite common to need to transform them into an actual array, so that the various <code>Array.prototype</code> methods (<code>map(..)</code>, <code>indexOf(..)</code> etc.) are available to use with it. That process usually looks like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// array-like object</span>
<span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">3</span>,
    <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>,
    <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
};

<span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arrLike );</pre></div>

<p>Another common task where <code>slice(..)</code> is often used is in duplicating a real array:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr2 <span class="pl-k">=</span> arr.<span class="pl-c1">slice</span>();</pre></div>

<p>In both cases, the new ES6 <code>Array.from(..)</code> method can be a more understandable and graceful -- if also less verbose -- approach:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( arrLike );

<span class="pl-k">var</span> arrCopy <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( arr );</pre></div>

<p><code>Array.from(..)</code> looks to see if the first argument is an iterable (see "Iterators" in Chapter 3), and if so, it uses the iterator to produce values to "copy" into the returned array. Because real arrays have an iterator for those values, that iterator is automatically used.</p>

<p>But if you pass an array-like object as the first argument to <code>Array.from(..)</code>, it behaves basically the same as <code>slice()</code> (no arguments!) or <code>apply(..)</code> does, which is that it simply loops over the value, accessing numerically named properties from <code>0</code> up to whatever the value of <code>length</code> is.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">4</span>,
    <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>
};

<span class="pl-c1">Array</span>.from( arrLike );
<span class="pl-c">// [ undefined, undefined, "foo", undefined ]</span></pre></div>

<p>Because positions <code>0</code>, <code>1</code>, and <code>3</code> didn't exist on <code>arrLike</code>, the result was the <code>undefined</code> value for each of those slots.</p>

<p>You could produce a similar outcome like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> emptySlotsArr <span class="pl-k">=</span> [];
emptySlotsArr.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>;
emptySlotsArr[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">Array</span>.from( emptySlotsArr );
<span class="pl-c">// [ undefined, undefined, "foo", undefined ]</span></pre></div>

<h4><a id="user-content-avoiding-empty-slots" class="anchor" href="#avoiding-empty-slots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Avoiding Empty Slots</h4>

<p>There's a subtle but important difference in the previous snippet between the <code>emptySlotsArr</code> and the result of the <code>Array.from(..)</code> call. <code>Array.from(..)</code> never produces empty slots.</p>

<p>Prior to ES6, if you wanted to produce an array initialized to a certain length with actual <code>undefined</code> values in each slot (no empty slots!), you had to do extra work:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">4</span> );                             <span class="pl-c">// four empty slots!</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, { length<span class="pl-k">:</span> <span class="pl-c1">4</span> } );     <span class="pl-c">// four `undefined` values</span></pre></div>

<p>But <code>Array.from(..)</code> now makes this easier:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( { length<span class="pl-k">:</span> <span class="pl-c1">4</span> } );            <span class="pl-c">// four `undefined` values</span></pre></div>

<p><strong>Warning:</strong> Using an empty slot array like <code>a</code> in the previous snippets would work with some array functions, but others ignore empty slots (like <code>map(..)</code>, etc.). You should never intentionally work with empty slots, as it will almost certainly lead to strange/unpredictable behavior in your programs.</p>

<h4><a id="user-content-mapping" class="anchor" href="#mapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mapping</h4>

<p>The <code>Array.from(..)</code> utility has another helpful trick up its sleeve. The second argument, if provided, is a mapping callback (almost the same as the regular <code>Array#map(..)</code> expects) which is called to map/transform each value from the source to the returned target. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">4</span>,
    <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>
};

<span class="pl-c1">Array</span>.from( arrLike, <span class="pl-k">function</span> <span class="pl-en">mapper</span>(<span class="pl-smi">val</span>,<span class="pl-smi">idx</span>){
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> val <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
        <span class="pl-k">return</span> val.<span class="pl-c1">toUpperCase</span>();
    }
    <span class="pl-k">else</span> {
        <span class="pl-k">return</span> idx;
    }
} );
<span class="pl-c">// [ 0, 1, "FOO", 3 ]</span></pre></div>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>Array.from(..)</code> takes an optional third argument that if set will specify the <code>this</code> binding for the callback passed as the second argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<p>See "TypedArrays" in Chapter 5 for an example of using <code>Array.from(..)</code> in translating values from an array of 8-bit values to an array of 16-bit values.</p>

<h3><a id="user-content-creating-arrays-and-subtypes" class="anchor" href="#creating-arrays-and-subtypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating Arrays and Subtypes</h3>

<p>In the last couple of sections, we've discussed <code>Array.of(..)</code> and <code>Array.from(..)</code>, both of which create a new array in a similar way to a constructor. But what do they do in subclasses? Do they create instances of the base <code>Array</code> or the derived subclass?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    ..
}

<span class="pl-c1">Array</span>.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                  <span class="pl-c">// true</span>
<span class="pl-c1">Array</span>.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;              <span class="pl-c">// true</span>

MyCoolArray.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;            <span class="pl-c">// false</span>
MyCoolArray.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;        <span class="pl-c">// false</span>

MyCoolArray.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> MyCoolArray;      <span class="pl-c">// true</span>
MyCoolArray.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> MyCoolArray;  <span class="pl-c">// true</span></pre></div>

<p>Both <code>of(..)</code> and <code>from(..)</code> use the constructor that they're accessed from to construct the array. So if you use the base <code>Array.of(..)</code> you'll get an <code>Array</code> instance, but if you use <code>MyCoolArray.of(..)</code>, you'll get a <code>MyCoolArray</code> instance.</p>

<p>In "Classes" in Chapter 3, we covered the <code>@@species</code> setting which all the built-in classes (like <code>Array</code>) have defined, which is used by any prototype methods if they create a new instance. <code>slice(..)</code> is a great example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> MyCoolArray;                <span class="pl-c">// true</span></pre></div>

<p>Generally, that default behavior will probably be desired, but as we discussed in Chapter 3, you <em>can</em> override if you want:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> MyCoolArray;                <span class="pl-c">// false</span>
x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                      <span class="pl-c">// true</span></pre></div>

<p>It's important to note that the <code>@@species</code> setting is only used for the prototype methods, like <code>slice(..)</code>. It's not used by <code>of(..)</code> and <code>from(..)</code>; they both just use the <code>this</code> binding (whatever constructor is used to make the reference). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                      <span class="pl-c">// true</span>

MyCoolArray.from( x ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;             <span class="pl-c">// false</span>
MyCoolArray.of( [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;          <span class="pl-c">// false</span>

MyCoolArray.from( x ) <span class="pl-k">instanceof</span> MyCoolArray;       <span class="pl-c">// true</span>
MyCoolArray.of( [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ) <span class="pl-k">instanceof</span> MyCoolArray;    <span class="pl-c">// true</span></pre></div>

<h3><a id="user-content-copywithin-prototype-method" class="anchor" href="#copywithin-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>copyWithin(..)</code> Prototype Method</h3>

<p><code>Array#copyWithin(..)</code> is a new mutator method available to all arrays (including Typed Arrays; see Chapter 5). <code>copyWithin(..)</code> copies a portion of an array to another location in the same array, overwriting whatever was there before.</p>

<p>The arguments are <em>target</em> (the index to copy to), <em>start</em> (the inclusive index to start the copying from), and optionally <em>end</em> (the exclusive index to stop copying). If any of the arguments are negative, they're taken to be relative from the end of the array.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">3</span>, <span class="pl-c1">0</span> );         <span class="pl-c">// [1,2,3,1,2]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span> );      <span class="pl-c">// [1,2,3,1,5]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">2</span> );        <span class="pl-c">// [4,5,3,4,5]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span> );    <span class="pl-c">// [4,2,3,4,5]</span></pre></div>

<p>The <code>copyWithin(..)</code> method does not extend the array's length, as the first example in the previous snippet shows. Copying simply stops when the end of the array is reached.</p>

<p>Contrary to what you might think, the copying doesn't always go in left-to-right (ascending index) order. It's possible this would result in repeatedly copying an already copied value if the from and target ranges overlap, which is presumably not desired behavior.</p>

<p>So internally, the algorithm avoids this case by copying in reverse order to avoid that gotcha. Consider:</p>

<div class="highlight highlight-source-js"><pre>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">2</span>, <span class="pl-c1">1</span> );     <span class="pl-c">// ???</span></pre></div>

<p>If the algorithm was strictly moving left to right, then the <code>2</code> should be copied to overwrite the <code>3</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>4</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>5</code>, and you'd end up with <code>[1,2,2,2,2]</code>.</p>

<p>Instead, the copying algorithm reverses direction and copies <code>4</code> to overwrite <code>5</code>, then copies <code>3</code> to overwrite <code>4</code>, then copies <code>2</code> to overwrite <code>3</code>, and the final result is <code>[1,2,2,3,4]</code>. That's probably more "correct" in terms of expectation, but it can be confusing if you're only thinking about the copying algorithm in a naive left-to-right fashion.</p>

<h3><a id="user-content-fill-prototype-method" class="anchor" href="#fill-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fill(..)</code> Prototype Method</h3>

<p>Filling an existing array entirely (or partially) with a specified value is natively supported as of ES6 with the <code>Array#fill(..)</code> method:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">4</span> ).fill( <span class="pl-c1">undefined</span> );
a;
<span class="pl-c">// [undefined,undefined,undefined,undefined]</span></pre></div>

<p><code>fill(..)</code> optionally takes <em>start</em> and <em>end</em> parameters, which indicate a subset portion of the array to fill, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [ <span class="pl-c1">null</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span> ].fill( <span class="pl-c1">42</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span> );

a;                                  <span class="pl-c">// [null,42,42,null]</span></pre></div>

<h3><a id="user-content-find-prototype-method" class="anchor" href="#find-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>find(..)</code> Prototype Method</h3>

<p>The most common way to search for a value in an array has generally been the <code>indexOf(..)</code> method, which returns the index the value is found at or <code>-1</code> if not found:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

(a.<span class="pl-c1">indexOf</span>( <span class="pl-c1">3</span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);             <span class="pl-c">// true</span>
(a.<span class="pl-c1">indexOf</span>( <span class="pl-c1">7</span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);             <span class="pl-c">// false</span>

(a.<span class="pl-c1">indexOf</span>( <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);           <span class="pl-c">// false</span></pre></div>

<p>The <code>indexOf(..)</code> comparison requires a strict <code>===</code> match, so a search for <code>"2"</code> fails to find a value of <code>2</code>, and vice versa. There's no way to override the matching algorithm for <code>indexOf(..)</code>. It's also unfortunate/ungraceful to have to make the manual comparison to the <code>-1</code> value.</p>

<p><strong>Tip:</strong> See the <em>Types &amp; Grammar</em> title of this series for an interesting (and controversially confusing) technique to work around the <code>-1</code> ugliness with the <code>~</code> operator.</p>

<p>Since ES5, the most common workaround to have control over the matching logic has been the <code>some(..)</code> method. It works by calling a function callback for each element, until one of those calls returns a <code>true</code>/truthy value, and then it stops. Because you get to define the callback function, you have full control over how a match is made:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a.some( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>;
} );                                <span class="pl-c">// true</span>

a.some( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-c1">7</span>;
} );                                <span class="pl-c">// false</span></pre></div>

<p>But the downside to this approach is that you only get the <code>true</code>/<code>false</code> indicating if a suitably matched value was found, but not what the actual matched value was.</p>

<p>ES6's <code>find(..)</code> addresses this. It works basically the same as <code>some(..)</code>, except that once the callback returns a <code>true</code>/truthy value, the actual array value is returned:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>;
} );                                <span class="pl-c">// 2</span>

a.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-c1">7</span>;                  <span class="pl-c">// undefined</span>
});</pre></div>

<p>Using a custom <code>matcher(..)</code> function also lets you match against complex values like objects:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> points <span class="pl-k">=</span> [
    { x<span class="pl-k">:</span> <span class="pl-c1">10</span>, y<span class="pl-k">:</span> <span class="pl-c1">20</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">20</span>, y<span class="pl-k">:</span> <span class="pl-c1">30</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">30</span>, y<span class="pl-k">:</span> <span class="pl-c1">40</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">40</span>, y<span class="pl-k">:</span> <span class="pl-c1">50</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">50</span>, y<span class="pl-k">:</span> <span class="pl-c1">60</span> }
];

points.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// { x: 30, y: 40 }</span></pre></div>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<h3><a id="user-content-findindex-prototype-method" class="anchor" href="#findindex-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>findIndex(..)</code> Prototype Method</h3>

<p>While the previous section illustrates how <code>some(..)</code> yields a boolean result for a search of an array, and <code>find(..)</code> yields the matched value itself from the array search, there's also a need for finding the positional index of the matched value.</p>

<p><code>indexOf(..)</code> does that, but there's no control over its matching logic; it always uses <code>===</code> strict equality. So ES6's <code>findIndex(..)</code> is the answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> points <span class="pl-k">=</span> [
    { x<span class="pl-k">:</span> <span class="pl-c1">10</span>, y<span class="pl-k">:</span> <span class="pl-c1">20</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">20</span>, y<span class="pl-k">:</span> <span class="pl-c1">30</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">30</span>, y<span class="pl-k">:</span> <span class="pl-c1">40</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">40</span>, y<span class="pl-k">:</span> <span class="pl-c1">50</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">50</span>, y<span class="pl-k">:</span> <span class="pl-c1">60</span> }
];

points.findIndex( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// 2</span>

points.findIndex( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// -1</span></pre></div>

<p>Don't use <code>findIndex(..) != -1</code> (the way it's always been done with <code>indexOf(..)</code>) to get a boolean from the search, because <code>some(..)</code> already yields the <code>true</code>/<code>false</code> you want. And don't do <code>a[ a.findIndex(..) ]</code> to get the matched value, because that's what <code>find(..)</code> accomplishes. And finally, use <code>indexOf(..)</code> if you need the index of a strict match, or <code>findIndex(..)</code> if you need the index of a more customized match.</p>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<h3><a id="user-content-entries-values-keys-prototype-methods" class="anchor" href="#entries-values-keys-prototype-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>entries()</code>, <code>values()</code>, <code>keys()</code> Prototype Methods</h3>

<p>In Chapter 3, we illustrated how data structures can provide a patterned item-by-item enumeration of their values, via an iterator. We then expounded on this approach in Chapter 5, as we explored how the new ES6 collections (Map, Set, etc.) provide several methods for producing different kinds of iterations.</p>

<p>Because it's not new to ES6, <code>Array</code> might not be thought of traditionally as a "collection," but it is one in the sense that it provides these same iterator methods: <code>entries()</code>, <code>values()</code>, and <code>keys()</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

[...a.values()];                    <span class="pl-c">// [1,2,3]</span>
[...a.keys()];                      <span class="pl-c">// [0,1,2]</span>
[...a.entries()];                   <span class="pl-c">// [ [0,1], [1,2], [2,3] ]</span>

[...a[Symbol.iterator]()];          <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Just like with <code>Set</code>, the default <code>Array</code> iterator is the same as what <code>values()</code> returns.</p>

<p>In "Avoiding Empty Slots" earlier in this chapter, we illustrated how <code>Array.from(..)</code> treats empty slots in an array as just being present slots with <code>undefined</code> in them. That's actually because under the covers, the array iterators behave that way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [];
a.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>;

[...a.values()];        <span class="pl-c">// [undefined,2,undefined]</span>
[...a.keys()];          <span class="pl-c">// [0,1,2]</span>
[...a.entries()];       <span class="pl-c">// [ [0,undefined], [1,2], [2,undefined] ]</span></pre></div>

<h2><a id="user-content-object" class="anchor" href="#object" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object</code></h2>

<p>A few additional static helpers have been added to <code>Object</code>. Traditionally, functions of this sort have been seen as focused on the behaviors/capabilities of object values.</p>

<p>However, starting with ES6, <code>Object</code> static functions will also be for general-purpose global APIs of any sort that don't already belong more naturally in some other location (i.e., <code>Array.from(..)</code>).</p>

<h3><a id="user-content-objectis-static-function" class="anchor" href="#objectis-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.is(..)</code> Static Function</h3>

<p>The <code>Object.is(..)</code> static function makes value comparisons in an even more strict fashion than the <code>===</code> comparison.</p>

<p><code>Object.is(..)</code> invokes the underlying <code>SameValue</code> algorithm (ES6 spec, section 7.2.9). The <code>SameValue</code> algorithm is basically the same as the <code>===</code> Strict Equality Comparison Algorithm (ES6 spec, section 7.2.13), with two important exceptions.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, y <span class="pl-k">=</span> <span class="pl-c1">0</span>, z <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0</span>;

x <span class="pl-k">===</span> x;                            <span class="pl-c">// false</span>
y <span class="pl-k">===</span> z;                            <span class="pl-c">// true</span>

<span class="pl-c1">Object</span>.is( x, x );                  <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.is( y, z );                  <span class="pl-c">// false</span></pre></div>

<p>You should continue to use <code>===</code> for strict equality comparisons; <code>Object.is(..)</code> shouldn't be thought of as a replacement for the operator. However, in cases where you're trying to strictly identify a <code>NaN</code> or <code>-0</code> value, <code>Object.is(..)</code> is now the preferred option.</p>

<p><strong>Note:</strong> ES6 also adds a <code>Number.isNaN(..)</code> utility (discussed later in this chapter) which may be a slightly more convenient test; you may prefer <code>Number.isNaN(x)</code> over <code>Object.is(x,NaN)</code>. You <em>can</em> accurately test for <code>-0</code> with a clumsy <code>x == 0 &amp;&amp; 1 / x === -Infinity</code>, but in this case <code>Object.is(x,-0)</code> is much better.</p>

<h3><a id="user-content-objectgetownpropertysymbols-static-function" class="anchor" href="#objectgetownpropertysymbols-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.getOwnPropertySymbols(..)</code> Static Function</h3>

<p>The "Symbols" section in Chapter 2 discusses the new Symbol primitive value type in ES6.</p>

<p>Symbols are likely going to be mostly used as special (meta) properties on objects. So the <code>Object.getOwnPropertySymbols(..)</code> utility was introduced, which retrieves only the symbol properties directly on an object:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    [ Symbol( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ) ]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    baz<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

<span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [ Symbol(bar) ]</span></pre></div>

<h3><a id="user-content-objectsetprototypeof-static-function" class="anchor" href="#objectsetprototypeof-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.setPrototypeOf(..)</code> Static Function</h3>

<p>Also in Chapter 2, we mentioned the <code>Object.setPrototypeOf(..)</code> utility, which (unsurprisingly) sets the <code>[[Prototype]]</code> of an object for the purposes of <em>behavior delegation</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};
<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-c">// .. o2's definition ..</span>
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p>Alternatively:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.setPrototypeOf( {
    <span class="pl-c">// .. o2's definition ..</span>
}, o1 );

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p>In both previous snippets, the relationship between <code>o2</code> and <code>o1</code> appears at the end of the <code>o2</code> definition. More commonly, the relationship between an <code>o2</code> and <code>o1</code> is specified at the top of the <code>o2</code> definition, as it is with classes, and also with <code>__proto__</code> in object literals (see "Setting <code>[[Prototype]]</code>" in Chapter 2).</p>

<p><strong>Warning:</strong> Setting a <code>[[Prototype]]</code> right after object creation is reasonable, as shown. But changing it much later is generally not a good idea and will usually lead to more confusion than clarity.</p>

<h3><a id="user-content-objectassign-static-function" class="anchor" href="#objectassign-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.assign(..)</code> Static Function</h3>

<p>Many JavaScript libraries/frameworks provide utilities for copying/mixing one object's properties into another (e.g., jQuery's <code>extend(..)</code>). There are various nuanced differences between these different utilities, such as whether a property with value <code>undefined</code> is ignored or not.</p>

<p>ES6 adds <code>Object.assign(..)</code>, which is a simplified version of these algorithms. The first argument is the <em>target</em>, and any other arguments passed are the <em>sources</em>, which will be processed in listed order. For each source, its enumerable and own (e.g., not "inherited") keys, including symbols, are copied as if by plain <code>=</code> assignment. <code>Object.assign(..)</code> returns the target object.</p>

<p>Consider this object setup:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> target <span class="pl-k">=</span> {},
    o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> }, o2 <span class="pl-k">=</span> { b<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    o3 <span class="pl-k">=</span> { c<span class="pl-k">:</span> <span class="pl-c1">3</span> }, o4 <span class="pl-k">=</span> { d<span class="pl-k">:</span> <span class="pl-c1">4</span> };

<span class="pl-c">// setup read-only property</span>
<span class="pl-c1">Object</span>.defineProperty( o3, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">5</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

<span class="pl-c">// setup non-enumerable property</span>
<span class="pl-c1">Object</span>.defineProperty( o3, <span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">6</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

o3[ Symbol( <span class="pl-s"><span class="pl-pds">"</span>g<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> <span class="pl-c1">7</span>;

<span class="pl-c">// setup non-enumerable symbol</span>
<span class="pl-c1">Object</span>.defineProperty( o3, Symbol( <span class="pl-s"><span class="pl-pds">"</span>h<span class="pl-pds">"</span></span> ), {
    value<span class="pl-k">:</span> <span class="pl-c1">8</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

<span class="pl-c1">Object</span>.setPrototypeOf( o3, o4 );</pre></div>

<p>Only the properties <code>a</code>, <code>b</code>, <code>c</code>, <code>e</code>, and <code>Symbol("g")</code> will be copied to <code>target</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Object</span>.assign( target, o1, o2, o3 );

target.a;                           <span class="pl-c">// 1</span>
target.b;                           <span class="pl-c">// 2</span>
target.c;                           <span class="pl-c">// 3</span>

<span class="pl-c1">Object</span>.getOwnPropertyDescriptor( target, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span> );
<span class="pl-c">// { value: 5, writable: true, enumerable: true,</span>
<span class="pl-c">//   configurable: true }</span>

<span class="pl-c1">Object</span>.getOwnPropertySymbols( target );
<span class="pl-c">// [Symbol("g")]</span></pre></div>

<p>The <code>d</code>, <code>f</code>, and <code>Symbol("h")</code> properties are omitted from copying; non-enumerable properties and non-owned properties are all excluded from the assignment. Also, <code>e</code> is copied as a normal property assignment, not duplicated as a read-only property.</p>

<p>In an earlier section, we showed using <code>setPrototypeOf(..)</code> to set up a <code>[[Prototype]]</code> relationship between an <code>o2</code> and <code>o1</code> object. There's another form that leverages <code>Object.assign(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign(
    <span class="pl-c1">Object</span>.create( o1 ),
    {
        <span class="pl-c">// .. o2's definition ..</span>
    }
);

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p><strong>Note:</strong> <code>Object.create(..)</code> is the ES5 standard utility that creates an empty object that is <code>[[Prototype]]</code>-linked. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<h2><a id="user-content-math" class="anchor" href="#math" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Math</code></h2>

<p>ES6 adds several new mathematic utilities that fill in holes or aid with common operations. All of these can be manually calculated, but most of them are now defined natively so that in some cases the JS engine can either more optimally perform the calculations, or perform them with better decimal precision than their manual counterparts.</p>

<p>It's likely that asm.js/transpiled JS code (see the <em>Async &amp; Performance</em> title of this series) is the more likely consumer of many of these utilities rather than direct developers.</p>

<p>Trigonometry:</p>

<ul>
<li><code>cosh(..)</code> - Hyperbolic cosine</li>
<li><code>acosh(..)</code> - Hyperbolic arccosine</li>
<li><code>sinh(..)</code> - Hyperbolic sine</li>
<li><code>asinh(..)</code> - Hyperbolic arcsine</li>
<li><code>tanh(..)</code> - Hyperbolic tangent</li>
<li><code>atanh(..)</code> - Hyperbolic arctangent</li>
<li><code>hypot(..)</code> - The squareroot of the sum of the squares (i.e., the generalized Pythagorean theorem)</li>
</ul>

<p>Arithmetic:</p>

<ul>
<li><code>cbrt(..)</code> - Cube root</li>
<li><code>clz32(..)</code> - Count leading zeros in 32-bit binary representation</li>
<li><code>expm1(..)</code> - The same as <code>exp(x) - 1</code></li>
<li><code>log2(..)</code> - Binary logarithm (log base 2)</li>
<li><code>log10(..)</code> - Log base 10</li>
<li><code>log1p(..)</code> - The same as <code>log(x + 1)</code></li>
<li><code>imul(..)</code> - 32-bit integer multiplication of two numbers</li>
</ul>

<p>Meta:</p>

<ul>
<li><code>sign(..)</code> - Returns the sign of the number</li>
<li><code>trunc(..)</code> - Returns only the integer part of a number</li>
<li><code>fround(..)</code> - Rounds to nearest 32-bit (single precision) floating-point value</li>
</ul>

<h2><a id="user-content-number" class="anchor" href="#number" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number</code></h2>

<p>Importantly, for your program to properly work, it must accurately handle numbers. ES6 adds some additional properties and functions to assist with common numeric operations.</p>

<p>Two additions to <code>Number</code> are just references to the preexisting globals: <code>Number.parseInt(..)</code> and <code>Number.parseFloat(..)</code>.</p>

<h3><a id="user-content-static-properties" class="anchor" href="#static-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Static Properties</h3>

<p>ES6 adds some helpful numeric constants as static properties:</p>

<ul>
<li><code>Number.EPSILON</code> - The minimum value between any two numbers: <code>2^-52</code> (see Chapter 2 of the <em>Types &amp; Grammar</em> title of this series regarding using this value as a tolerance for imprecision in floating-point arithmetic)</li>
<li><code>Number.MAX_SAFE_INTEGER</code> - The highest integer that can "safely" be represented unambiguously in a JS number value: <code>2^53 - 1</code></li>
<li><code>Number.MIN_SAFE_INTEGER</code> - The lowest integer that can "safely" be represented unambiguously in a JS number value: <code>-(2^53 - 1)</code> or <code>(-2)^53 + 1</code>.</li>
</ul>

<p><strong>Note:</strong> See Chapter 2 of the <em>Types &amp; Grammar</em> title of this series for more information about "safe" integers.</p>

<h3><a id="user-content-numberisnan-static-function" class="anchor" href="#numberisnan-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number.isNaN(..)</code> Static Function</h3>

<p>The standard global <code>isNaN(..)</code> utility has been broken since its inception, in that it returns <code>true</code> for things that are not numbers, not just for the actual <code>NaN</code> value, because it coerces the argument to a number type (which can falsely result in a NaN). ES6 adds a fixed utility <code>Number.isNaN(..)</code> that works as it should:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NaN<span class="pl-pds">"</span></span>, c <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c1">isNaN</span>( a );                         <span class="pl-c">// true</span>
<span class="pl-c1">isNaN</span>( b );                         <span class="pl-c">// true -- oops!</span>
<span class="pl-c1">isNaN</span>( c );                         <span class="pl-c">// false</span>

<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( a );                  <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( b );                  <span class="pl-c">// false -- fixed!</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( c );                  <span class="pl-c">// false</span></pre></div>

<h3><a id="user-content-numberisfinite-static-function" class="anchor" href="#numberisfinite-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number.isFinite(..)</code> Static Function</h3>

<p>There's a temptation to look at a function name like <code>isFinite(..)</code> and assume it's simply "not infinite". That's not quite correct, though. There's more nuance to this new ES6 utility. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, b <span class="pl-k">=</span> <span class="pl-c1">Infinity</span>, c <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( a );               <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( b );               <span class="pl-c">// false</span>

<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( c );               <span class="pl-c">// true</span></pre></div>

<p>The standard global <code>isFinite(..)</code> coerces its argument, but <code>Number.isFinite(..)</code> omits the coercive behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;

<span class="pl-c1">isFinite</span>( a );                      <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( a );               <span class="pl-c">// false</span></pre></div>

<p>You may still prefer the coercion, in which case using the global <code>isFinite(..)</code> is a valid choice. Alternatively, and perhaps more sensibly, you can use <code>Number.isFinite(+x)</code>, which explicitly coerces <code>x</code> to a number before passing it in (see Chapter 4 of the <em>Types &amp; Grammar</em> title of this series).</p>

<h3><a id="user-content-integer-related-static-functions" class="anchor" href="#integer-related-static-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Integer-Related Static Functions</h3>

<p>JavaScript number valuess are always floating point (IEE-754). So the notion of determining if a number is an "integer" is not about checking its type, because JS makes no such distinction.</p>

<p>Instead, you need to check if there's any non-zero decimal portion of the value. The easiest way to do that has commonly been:</p>

<div class="highlight highlight-source-js"><pre>x <span class="pl-k">===</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>( x );</pre></div>

<p>ES6 adds a <code>Number.isInteger(..)</code> helper utility that potentially can determine this quality slightly more efficiently:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">4</span> );              <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">4.2</span> );            <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> In JavaScript, there's no difference between <code>4</code>, <code>4.</code>, <code>4.0</code>, or <code>4.0000</code>. All of these would be considered an "integer", and would thus yield <code>true</code> from <code>Number.isInteger(..)</code>.</p>

<p>In addition, <code>Number.isInteger(..)</code> filters out some clearly not-integer values that <code>x === Math.floor(x)</code> could potentially mix up:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">NaN</span> );            <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">Infinity</span> );       <span class="pl-c">// false</span></pre></div>

<p>Working with "integers" is sometimes an important bit of information, as it can simplify certain kinds of algorithms. JS code by itself will not run faster just from filtering for only integers, but there are optimization techniques the engine can take (e.g., asm.js) when only integers are being used.</p>

<p>Because of <code>Number.isInteger(..)</code>'s handling of <code>NaN</code> and <code>Infinity</code> values, defining a <code>isFloat(..)</code> utility would not be just as simple as <code>!Number.isInteger(..)</code>. You'd need to do something like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">isFloat</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> <span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( x ) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span><span class="pl-c1">Number</span>.isInteger( x );
}

isFloat( <span class="pl-c1">4.2</span> );                     <span class="pl-c">// true</span>
isFloat( <span class="pl-c1">4</span> );                       <span class="pl-c">// false</span>

isFloat( <span class="pl-c1">NaN</span> );                     <span class="pl-c">// false</span>
isFloat( <span class="pl-c1">Infinity</span> );                <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> It may seem strange, but Infinity should neither be considered an integer nor a float.</p>

<p>ES6 also defines a <code>Number.isSafeInteger(..)</code> utility, which checks to make sure the value is both an integer and within the range of <code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code> (inclusive).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">pow</span>( <span class="pl-c1">2</span>, <span class="pl-c1">53</span> ),
    y <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">pow</span>( <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">53</span> );

<span class="pl-c1">Number</span>.isSafeInteger( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );      <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.isSafeInteger( y <span class="pl-k">+</span> <span class="pl-c1">1</span> );      <span class="pl-c">// true</span>

<span class="pl-c1">Number</span>.isSafeInteger( x );          <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.isSafeInteger( y );          <span class="pl-c">// false</span></pre></div>

<h2><a id="user-content-string" class="anchor" href="#string" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>String</code></h2>

<p>Strings already have quite a few helpers prior to ES6, but even more have been added to the mix.</p>

<h3><a id="user-content-unicode-functions" class="anchor" href="#unicode-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Functions</h3>

<p>"Unicode-Aware String Operations" in Chapter 2 discusses <code>String.fromCodePoint(..)</code>, <code>String#codePointAt(..)</code>, and <code>String#normalize(..)</code> in detail. They have been added to improve Unicode support in JS string values.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x1d49e</span> );            <span class="pl-c">// ""</span>

<span class="pl-s"><span class="pl-pds">"</span>abd<span class="pl-pds">"</span></span>.codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );      <span class="pl-c">// "1d49e"</span></pre></div>

<p>The <code>normalize(..)</code> string prototype method is used to perform Unicode normalizations that either combine characters with adjacent "combining marks" or decompose combined characters.</p>

<p>Generally, the normalization won't create a visible effect on the contents of the string, but will change the contents of the string, which can affect how things like the <code>length</code> property are reported, as well as how character access by position behave:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;
s1.<span class="pl-c1">length</span>;                          <span class="pl-c">// 2</span>

<span class="pl-k">var</span> s2 <span class="pl-k">=</span> s1.normalize();
s2.<span class="pl-c1">length</span>;                          <span class="pl-c">// 1</span>
s2 <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>;                      <span class="pl-c">// true</span></pre></div>

<p><code>normalize(..)</code> takes an optional argument that specifies the normalization form to use. This argument must be one of the following four values: <code>"NFC"</code> (default), <code>"NFD"</code>, <code>"NFKC"</code>, or <code>"NFKD"</code>.</p>

<p><strong>Note:</strong> Normalization forms and their effects on strings is well beyond the scope of what we'll discuss here. See "Unicode Normalization Forms" (<a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a>) for more information.</p>

<h3><a id="user-content-stringraw-static-function" class="anchor" href="#stringraw-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>String.raw(..)</code> Static Function</h3>

<p>The <code>String.raw(..)</code> utility is provided as a built-in tag function to use with template string literals (see Chapter 2) for obtaining the raw string value without any processing of escape sequences.</p>

<p>This function will almost never be called manually, but will be used with tagged template literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bc<span class="pl-pds">"</span></span>;

<span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span><span class="pl-cce">\t</span>a<span class="pl-s1"><span class="pl-pse">${</span>str<span class="pl-pse">}</span></span>d<span class="pl-cce">\x</span>E9<span class="pl-pds">`</span></span>;
<span class="pl-c">// "\tabcd\xE9", not "  abcd"</span></pre></div>

<p>In the resultant string, <code>\</code> and <code>t</code> are separate raw characters, not the one escape sequence character <code>\t</code>. The same is true with the Unicode escape sequence.</p>

<h3><a id="user-content-repeat-prototype-function" class="anchor" href="#repeat-prototype-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>repeat(..)</code> Prototype Function</h3>

<p>In languages like Python and Ruby, you can repeat a string as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">3</span>;                          <span class="pl-c">// "foofoofoo"</span></pre></div>

<p>That doesn't work in JS, because <code>*</code> multiplication is only defined for numbers, and thus <code>"foo"</code> coerces to the <code>NaN</code> number.</p>

<p>However, ES6 defines a string prototype method <code>repeat(..)</code> to accomplish the task:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>.repeat( <span class="pl-c1">3</span> );                  <span class="pl-c">// "foofoofoo"</span></pre></div>

<h3><a id="user-content-string-inspection-functions" class="anchor" href="#string-inspection-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>String Inspection Functions</h3>

<p>In addition to <code>String#indexOf(..)</code> and <code>String#lastIndexOf(..)</code> from prior to ES6, three new methods for searching/inspection have been added: <code>startsWith(..)</code>, <code>endsWidth(..)</code>, and <code>includes(..)</code>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> palindrome <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>step on no pets<span class="pl-pds">"</span></span>;

palindrome.startsWith( <span class="pl-s"><span class="pl-pds">"</span>step on<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
palindrome.startsWith( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span>, <span class="pl-c1">5</span> );   <span class="pl-c">// true</span>

palindrome.endsWith( <span class="pl-s"><span class="pl-pds">"</span>no pets<span class="pl-pds">"</span></span> );   <span class="pl-c">// true</span>
palindrome.endsWith( <span class="pl-s"><span class="pl-pds">"</span>no<span class="pl-pds">"</span></span>, <span class="pl-c1">10</span> );    <span class="pl-c">// true</span>

palindrome.includes( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span> );        <span class="pl-c">// true</span>
palindrome.includes( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span>, <span class="pl-c1">6</span> );     <span class="pl-c">// false</span></pre></div>

<p>For all the string search/inspection methods, if you look for an empty string <code>""</code>, it will either be found at the beginning or the end of the string.</p>

<p><strong>Warning:</strong> These methods will not by default accept a regular expression for the search string. See "Regular Expression Symbols" in Chapter 7 for information about disabling the <code>isRegExp</code> check that is performed on this first argument.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 adds many extra API helpers on the various built-in native objects:</p>

<ul>
<li><code>Array</code> adds <code>of(..)</code> and <code>from(..)</code> static functions, as well as prototype functions like <code>copyWithin(..)</code> and <code>fill(..)</code>.</li>
<li><code>Object</code> adds static functions like <code>is(..)</code> and <code>assign(..)</code>.</li>
<li><code>Math</code> adds static functions like <code>acosh(..)</code> and <code>clz32(..)</code>.</li>
<li><code>Number</code> adds static properties like <code>Number.EPSILON</code>, as well as static functions like <code>Number.isFinite(..)</code>.</li>
<li><code>String</code> adds static functions like <code>String.fromCodePoint(..)</code> and <code>String.raw(..)</code>, as well as prototype functions like <code>repeat(..)</code> and <code>includes(..)</code>.</li>
</ul>

<p>Most of these additions can be polyfilled (see ES6 Shim), and were inspired by utilities in common JS libraries/frameworks.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-7-meta-programming" class="anchor" href="#chapter-7-meta-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 7: Meta Programming</h1>

<p>Meta programming is programming where the operation targets the behavior of the program itself. In other words, it's programming the programming of your program. Yeah, a mouthful, huh?</p>

<p>For example, if you probe the relationship between one object <code>a</code> and another <code>b</code> -- are they <code>[[Prototype]]</code> linked? -- using <code>a.isPrototype(b)</code>, this is commonly referred to as introspection, a form of meta programming. Macros (which don't exist in JS, yet) --  where the code modifies itself at compile time -- are another obvious example of meta programming. Enumerating the keys of an object with a <code>for..in</code> loop, or checking if an object is an <em>instance of</em> a "class constructor", are other common meta programming tasks.</p>

<p>Meta programming focuses on one or more of the following: code inspecting itself, code modifying itself, or code modifying default language behavior so other code is affected.</p>

<p>The goal of meta programming is to leverage the language's own intrinsic capabilities to make the rest of your code more descriptive, expressive, and/or flexible. Because of the <em>meta</em> nature of meta programming, it's somewhat difficult to put a more precise definition on it than that. The best way to understand meta programming is to see it through examples.</p>

<p>ES6 adds several new forms/features for meta programming on top of what JS already had.</p>

<h2><a id="user-content-function-names" class="anchor" href="#function-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Names</h2>

<p>There are cases where your code may want to introspect on itself and ask what the name of some function is. If you ask what a function's name is, the answer is surprisingly somewhat ambiguous. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">daz</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">bar</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() {
        <span class="pl-c">// ..</span>
    },
    bam<span class="pl-k">:</span> daz,
    <span class="pl-en">zim</span>() {
        <span class="pl-c">// ..</span>
    }
};</pre></div>

<p>In this previous snippet, "what is the name of <code>obj.foo()</code>" is slightly nuanced. Is it <code>"foo"</code>, <code>""</code>, or <code>undefined</code>? And what about <code>obj.bar()</code> -- is it named <code>"bar"</code> or <code>"baz"</code>? Is <code>obj.bam()</code> named <code>"bam"</code> or <code>"daz"</code>? What about <code>obj.zim()</code>?</p>

<p>Moreover, what about functions which are passed as callbacks, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-c">// what is the name of `cb()` here?</span>
}

foo( <span class="pl-k">function</span>(){
    <span class="pl-c">// I'm anonymous!</span>
} );</pre></div>

<p>There are quite a few ways that functions can be expressed in programs, and it's not always clear and unambiguous what the "name" of that function should be.</p>

<p>More importantly, we need to distinguish whether the "name" of a function refers to its <code>name</code> property -- yes, functions have a property called <code>name</code> -- or whether it refers to the lexical binding name, such as <code>bar</code> in <code>function bar() { .. }</code>.</p>

<p>The lexical binding name is what you use for things like recursion:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">i</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>) <span class="pl-k">return</span> foo( i <span class="pl-k">*</span> <span class="pl-c1">2</span> );
    <span class="pl-k">return</span> i;
}</pre></div>

<p>The <code>name</code> property is what you'd use for meta programming purposes, so that's what we'll focus on in this discussion.</p>

<p>The confusion comes because by default, the lexical name a function has (if any) is also set as its <code>name</code> property. Actually there was no official requirement for that behavior by the ES5 (and prior) specifications. The setting of the <code>name</code> property was nonstandard but still fairly reliable. As of ES6, it has been standardized.</p>

<p><strong>Tip:</strong> If a function has a <code>name</code> value assigned, that's typically the name used in stack traces in developer tools.</p>

<h3><a id="user-content-inferences" class="anchor" href="#inferences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inferences</h3>

<p>But what happens to the <code>name</code> property if a function has no lexical name?</p>

<p>As of ES6, there are now inference rules which can determine a sensible <code>name</code> property value to assign a function even if that function doesn't have a lexical name to use.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">abc</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c">// ..</span>
};

abc.<span class="pl-c1">name</span>;               <span class="pl-c">// "abc"</span></pre></div>

<p>Had we given the function a lexical name like <code>abc = function def() { .. }</code>, the <code>name</code> property would of course be <code>"def"</code>. But in the absence of the lexical name, intuitively the <code>"abc"</code> name seems appropriate.</p>

<p>Here are other forms that will infer a name (or not) in ES6:</p>

<div class="highlight highlight-source-js"><pre>(<span class="pl-k">function</span>(){ .. });                 <span class="pl-c">// name:</span>
(<span class="pl-k">function*</span>(){ .. });                <span class="pl-c">// name:</span>
<span class="pl-c1">window</span>.<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){ .. };      <span class="pl-c">// name:</span>

<span class="pl-k">class</span> <span class="pl-en">Awesome</span> {
    <span class="pl-en">constructor</span>() { .. }            <span class="pl-c">// name: Awesome</span>
    <span class="pl-en">funny</span>() { .. }                  <span class="pl-c">// name: funny</span>
}

<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-k">class</span> <span class="pl-en">Awesome</span> { .. };       <span class="pl-c">// name: Awesome</span>

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { .. },                   <span class="pl-c">// name: foo</span>
    <span class="pl-k">*</span><span class="pl-en">bar</span>() { .. },                  <span class="pl-c">// name: bar</span>
    baz<span class="pl-k">:</span> ()<span class="pl-k"> =&gt;</span> { .. },              <span class="pl-c">// name: baz</span>
    <span class="pl-en">bam</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){ .. },          <span class="pl-c">// name: bam</span>
    get <span class="pl-en">qux</span>() { .. },               <span class="pl-c">// name: get qux</span>
    set <span class="pl-en">fuz</span>() { .. },               <span class="pl-c">// name: set fuz</span>
    [<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>iz<span class="pl-pds">"</span></span>]<span class="pl-k">:</span>
        <span class="pl-k">function</span>(){ .. },           <span class="pl-c">// name: biz</span>
    [Symbol( <span class="pl-s"><span class="pl-pds">"</span>buz<span class="pl-pds">"</span></span> )]<span class="pl-k">:</span>
        <span class="pl-k">function</span>(){ .. }            <span class="pl-c">// name: [buz]</span>
};

<span class="pl-k">var</span> x <span class="pl-k">=</span> o.foo.bind( o );            <span class="pl-c">// name: bound foo</span>
(<span class="pl-k">function</span>(){ .. }).bind( o );       <span class="pl-c">// name: bound</span>

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span>() { .. }    <span class="pl-c">// name: default</span>

<span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Function</span>();             <span class="pl-c">// name: anonymous</span>
<span class="pl-k">var</span> GeneratorFunction <span class="pl-k">=</span>
    <span class="pl-k">function*</span>(){}.__proto__.<span class="pl-c1">constructor</span>;
<span class="pl-k">var</span> z <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GeneratorFunction</span>();    <span class="pl-c">// name: anonymous</span></pre></div>

<p>The <code>name</code> property is not writable by default, but it is configurable, meaning you can use <code>Object.defineProperty(..)</code> to manually change it if so desired.</p>

<h2><a id="user-content-meta-properties" class="anchor" href="#meta-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meta Properties</h2>

<p>In the "<code>new.target</code>" section of Chapter 3, we introduced a concept new to JS in ES6: the meta property. As the name suggests, meta properties are intended to provide special meta information in the form of a property access that would otherwise not have been possible.</p>

<p>In the case of <code>new.target</code>, the keyword <code>new</code> serves as the context for a property access. Clearly <code>new</code> is itself not an object, which makes this capability special. However, when <code>new.target</code> is used inside a constructor call (a function/method invoked with <code>new</code>), <code>new</code> becomes a virtual context, so that <code>new.target</code> can refer to the target constructor that <code>new</code> invoked.</p>

<p>This is a clear example of a meta programming operation, as the intent is to determine from inside a constructor call what the original <code>new</code> target was, generally for the purposes of introspection (examining typing/structure) or static property access.</p>

<p>For example, you may want to have different behavior in a constructor depending on if it's directly invoked or invoked via a child class:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Parent</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-k">if</span> (<span class="pl-k">new</span>.<span class="pl-c1">target</span> <span class="pl-k">===</span> Parent) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Parent instantiated<span class="pl-pds">"</span></span> );
        }
        <span class="pl-k">else</span> {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>A child instantiated<span class="pl-pds">"</span></span> );
        }
    }
}

<span class="pl-k">class</span> <span class="pl-en">Child</span> <span class="pl-k">extends</span> <span class="pl-en">Parent</span> {}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Parent</span>();
<span class="pl-c">// Parent instantiated</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Child</span>();
<span class="pl-c">// A child instantiated</span></pre></div>

<p>There's a slight nuance here, which is that the <code>constructor()</code> inside the <code>Parent</code> class definition is actually given the lexical name of the class (<code>Parent</code>), even though the syntax implies that the class is a separate entity from the constructor.</p>

<p><strong>Warning:</strong> As with all meta programming techniques, be careful of creating code that's too clever for your future self or others maintaining your code to understand. Use these tricks with caution.</p>

<h2><a id="user-content-well-known-symbols" class="anchor" href="#well-known-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Well Known Symbols</h2>

<p>In the "Symbols" section of Chapter 2, we covered the new ES6 primitive type <code>symbol</code>. In addition to symbols you can define in your own program, JS predefines a number of built-in symbols, referred to as <em>Well Known Symbols</em> (WKS).</p>

<p>These symbol values are defined primarily to expose special meta properties that are being exposed to your JS programs to give you more control over JS's behavior.</p>

<p>We'll briefly introduce each and discuss their purpose.</p>

<h3><a id="user-content-symboliterator" class="anchor" href="#symboliterator" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.iterator</code></h3>

<p>In Chapters 2 and 3, we introduced and used the <code>@@iterator</code> symbol, automatically used by <code>...</code> spreads and <code>for..of</code> loops. We also saw <code>@@iterator</code> as defined on the new ES6 collections as defined in Chapter 5.</p>

<p><code>Symbol.iterator</code> represents the special location (property) on any object where the language mechanisms automatically look to find a method that will construct an iterator instance for consuming that object's values. Many objects come with a default one defined.</p>

<p>However, we can define our own iterator logic for any object value by setting the <code>Symbol.iterator</code> property, even if that's overriding the default iterator. The meta programming aspect is that we are defining behavior which other parts of JS (namely, operators and looping constructs) use when processing an object value we define.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> arr) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 4 5 6 7 8 9</span>

<span class="pl-c">// define iterator that only produces values</span>
<span class="pl-c">// from odd indexes</span>
arr[Symbol.iterator] <span class="pl-k">=</span> <span class="pl-k">function*</span>() {
    <span class="pl-k">var</span> idx <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">do</span> {
        <span class="pl-k">yield</span> <span class="pl-v">this</span>[idx];
    } <span class="pl-k">while</span> ((idx <span class="pl-k">+=</span> <span class="pl-c1">2</span>) <span class="pl-k">&lt;</span> <span class="pl-v">this</span>.<span class="pl-c1">length</span>);
};

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> arr) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 5 7 9</span></pre></div>

<h3><a id="user-content-symboltostringtag-and-symbolhasinstance" class="anchor" href="#symboltostringtag-and-symbolhasinstance" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.toStringTag</code> and <code>Symbol.hasInstance</code></h3>

<p>One of the most common meta programming tasks is to introspect on a value to find out what <em>kind</em> it is, usually to decide what operations are appropriate to perform on it. With objects, the two most common inspection techniques are <code>toString()</code> and <code>instanceof</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

a.<span class="pl-c1">toString</span>();               <span class="pl-c">// [object Object]</span>
a <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// true</span></pre></div>

<p>As of ES6, you can control the behavior of these operations:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">greeting</span>) {
    <span class="pl-v">this</span>.greeting <span class="pl-k">=</span> greeting;
}

Foo.<span class="pl-c1">prototype</span>[Symbol.toStringTag] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">Object</span>.defineProperty( Foo, Symbol.hasInstance, {
    <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">inst</span>) {
        <span class="pl-k">return</span> inst.greeting <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
    }
} );

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span> ),
    b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span> );

b[Symbol.toStringTag] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;

a.<span class="pl-c1">toString</span>();               <span class="pl-c">// [object Foo]</span>
<span class="pl-c1">String</span>( b );                <span class="pl-c">// [object cool]</span>

a <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// true</span>
b <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// false</span></pre></div>

<p>The <code>@@toStringTag</code> symbol on the prototype (or instance itself) specifies a string value to use in the <code>[object ___]</code> stringification.</p>

<p>The <code>@@hasInstance</code> symbol is a method on the constructor function which receives the instance object value and lets you decide by returning <code>true</code> or <code>false</code> if the value should be considered an instance or not.</p>

<p><strong>Note:</strong> To set <code>@@hasInstance</code> on a function, you must use <code>Object.defineProperty(..)</code>, as the default one on <code>Function.prototype</code> is <code>writable: false</code>. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<h3><a id="user-content-symbolspecies" class="anchor" href="#symbolspecies" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.species</code></h3>

<p>In "Classes" in Chapter 3, we introduced the <code>@@species</code> symbol, which controls which constructor is used by built-in methods of a class that needs to spawn new instances.</p>

<p>The most common example is when subclassing <code>Array</code> and wanting to define which constructor (<code>Array(..)</code> or your subclass) inherited methods like <code>slice(..)</code> should use. By default, <code>slice(..)</code> called on an instance of a subclass of <code>Array</code> would produce a new instance of that subclass, which is frankly what you'll likely often want.</p>

<p>However, you can meta program by overriding a class's default <code>@@species</code> definition:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Cool</span> {
    <span class="pl-c">// defer `@@species` to derived constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; }

    <span class="pl-en">again</span>() {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">this.constructor</span>[Symbol.species]();
    }
}

<span class="pl-k">class</span> <span class="pl-en">Fun</span> <span class="pl-k">extends</span> <span class="pl-en">Cool</span> {}

<span class="pl-k">class</span> <span class="pl-en">Awesome</span> <span class="pl-k">extends</span> <span class="pl-en">Cool</span> {
    <span class="pl-c">// force `@@species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> Cool; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fun</span>(),
    b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Awesome</span>(),
    c <span class="pl-k">=</span> a.again(),
    d <span class="pl-k">=</span> b.again();

c <span class="pl-k">instanceof</span> Fun;           <span class="pl-c">// true</span>
d <span class="pl-k">instanceof</span> Awesome;       <span class="pl-c">// false</span>
d <span class="pl-k">instanceof</span> Cool;          <span class="pl-c">// true</span></pre></div>

<p>The <code>Symbol.species</code> setting defaults on the built-in native constructors to the <code>return this</code> behavior as illustrated in the previous snippet in the <code>Cool</code> definition. It has no default on user classes, but as shown that behaivor is easy to emulate.</p>

<p>If you need to define methods that generate new instances, use the meta programming of the <code>new this.constructor[Symbol.species](..)</code> pattern instead of the hard-wiring of <code>new this.constructor(..)</code> or <code>new XYZ(..)</code>. Derived classes will then be able to customize <code>Symbol.species</code> to control which constructor vends those instances.</p>

<h3><a id="user-content-symboltoprimitive" class="anchor" href="#symboltoprimitive" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.toPrimitive</code></h3>

<p>In the <em>Types &amp; Grammar</em> title of this series, we discussed the <code>ToPrimitive</code> abstract coercion operation, which is used when an object must be coerced to a primitive value for some operation (such as <code>==</code> comparison or <code>+</code> addition). Prior to ES6, there was no way to control this behavior.</p>

<p>As of ES6, the <code>@@toPrimitive</code> symbol as a property on any object value can customize that <code>ToPrimitive</code> coercion by specifying a method.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

arr <span class="pl-k">+</span> <span class="pl-c1">10</span>;               <span class="pl-c">// 1,2,3,4,510</span>

arr[Symbol.toPrimitive] <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">hint</span>) {
    <span class="pl-k">if</span> (hint <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span> <span class="pl-k">||</span> hint <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
        <span class="pl-c">// sum all numbers</span>
        <span class="pl-k">return</span> <span class="pl-v">this</span>.reduce( <span class="pl-k">function</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">curr</span>){
            <span class="pl-k">return</span> acc <span class="pl-k">+</span> curr;
        }, <span class="pl-c1">0</span> );
    }
};

arr <span class="pl-k">+</span> <span class="pl-c1">10</span>;               <span class="pl-c">// 25</span></pre></div>

<p>The <code>Symbol.toPrimitive</code> method will be provided with a <em>hint</em> of <code>"string"</code>, <code>"number"</code>, or <code>"default"</code> (which should be interpreted as <code>"number"</code>), depending on what type the operation invoking <code>ToPrimitive</code> is expecting. In the previous snippet, the additive <code>+</code> operation has no hint (<code>"default"</code> is passed). A multiplicative <code>*</code> operation would hint <code>"number"</code> and a <code>String(arr)</code> would hint <code>"string"</code>.</p>

<p><strong>Warning:</strong> The <code>==</code> operator will invoke the <code>ToPrimitive</code> operation with no hint -- the <code>@@toPrimitive</code> method, if any is called with hint <code>"default"</code> -- on an object if the other value being compared is not an object. However, if both comparison values are objects, the behavior of <code>==</code> is identical to <code>===</code>, which is that the references themselves are directly compared. In this case, <code>@@toPrimitive</code> is not invoked at all. See the <em>Types &amp; Grammar</em> title of this series for more information about coercion and the abstract operations.</p>

<h3><a id="user-content-regular-expression-symbols" class="anchor" href="#regular-expression-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expression Symbols</h3>

<p>There are four well known symbols that can be overridden for regular expression objects, which control how those regular expressions are used by the four corresponding <code>String.prototype</code> functions of the same name:</p>

<ul>
<li><p><code>@@match</code>: The <code>Symbol.match</code> value of a regular expression is the method used to match all or part of a string value with the given regular expression. It's used by <code>String.prototype.match(..)</code> if you pass it a regular expression for the pattern matching.</p>

<p>The default algorithm for matching is laid out in section 21.2.5.6 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@match">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@match</a>). You could override this default algorithm and provide extra regex features, such as look-behind assertions.</p>

<p><code>Symbol.match</code> is also used by the <code>isRegExp</code> abstract operation (see the note in "String Inspection Functions" in Chapter 6) to determine if an object is intended to be used as a regular expression. To force this check to fail for an object so it's not treated as a regular expression, set the <code>Symbol.match</code> value to <code>false</code> (or something falsy).</p></li>
<li><p><code>@@replace</code>: The <code>Symbol.replace</code> value of a regular expression is the method used by <code>String.prototype.replace(..)</code> to replace within a string one or all occurrences of character sequences that match the given regular expression pattern.</p>

<p>The default algorithm for replacing is laid out in section 21.2.5.8 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@replace">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@replace</a>).</p>

<p>One cool use for overriding the default algorithm is to provide additional <code>replacer</code> argument options, such as supporting <code>"abaca".replace(/a/g,[1,2,3])</code> producing <code>"1b2c3"</code> by consuming the iterable for successive replacement values.</p></li>
<li><p><code>@@search</code>: The <code>Symbol.search</code> value of a regular expression is the method used by <code>String.prototype.search(..)</code> to search for a sub-string within another string as matched by the given regular expression.</p>

<p>The default algorithm for searching is laid out in section 21.2.5.9 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@search">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@search</a>).</p></li>
<li><p><code>@@split</code>: The <code>Symbol.split</code> value of a regular expression is the method used by <code>String.prototype.split(..)</code> to split a string into sub-strings at the location(s) of the delimiter as matched by the given regular expression.</p>

<p>The default algorithm for splitting is laid out in section 21.2.5.11 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@split">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@split</a>).</p></li>
</ul>

<p>Overriding the built-in regular expression algorithms is not for the faint of heart! JS ships with a highly optimized regular expression engine, so your own user code will likely be a lot slower. This kind of meta programming is neat and powerful, but it should only be used in cases where it's really necessary or beneficial.</p>

<h3><a id="user-content-symbolisconcatspreadable" class="anchor" href="#symbolisconcatspreadable" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.isConcatSpreadable</code></h3>

<p>The <code>@@isConcatSpreadable</code> symbol can be defined as a boolean property (<code>Symbol.isConcatSpreadable</code>) on any object (like an array or other iterable) to indicate if it should be <em>spread out</em> if passed to an array <code>concat(..)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>],
    b <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>];

b[Symbol.isConcatSpreadable] <span class="pl-k">=</span> <span class="pl-c1">false</span>;

[].<span class="pl-c1">concat</span>( a, b );      <span class="pl-c">// [1,2,3,[4,5,6]]</span></pre></div>

<h3><a id="user-content-symbolunscopables" class="anchor" href="#symbolunscopables" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.unscopables</code></h3>

<p>The <code>@@unscopables</code> symbol can be defined as an object property (<code>Symbol.unscopables</code>) on any object to indicate which properties can and cannot be exposed as lexical variables in a <code>with</code> statement.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    a <span class="pl-k">=</span> <span class="pl-c1">10</span>, b <span class="pl-k">=</span> <span class="pl-c1">20</span>, c <span class="pl-k">=</span> <span class="pl-c1">30</span>;

o[Symbol.unscopables] <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    b<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    c<span class="pl-k">:</span> <span class="pl-c1">false</span>
};

<span class="pl-k">with</span> (o) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );     <span class="pl-c">// 1 20 3</span>
}</pre></div>

<p>A <code>true</code> in the <code>@@unscopables</code> object indicates the property should be <em>unscopable</em>, and thus filtered out from the lexical scope variables. <code>false</code> means it's OK to be included in the lexical scope variables.</p>

<p><strong>Warning:</strong> The <code>with</code> statement is disallowed entirely in <code>strict</code> mode, and as such should be considered deprecated from the language. Don't use it. See the <em>Scope &amp; Closures</em> title of this series for more information. Because <code>with</code> should be avoided, the <code>@@unscopables</code> symbol is also moot.</p>

<h2><a id="user-content-proxies" class="anchor" href="#proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxies</h2>

<p>One of the most obviously meta programming features added to ES6 is the <code>Proxy</code> feature.</p>

<p>A proxy is a special kind of object you create that "wraps" -- or sits in front of -- another normal object. You can register special handlers (aka <em>traps</em>) on the proxy object which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to <em>forwarding</em> the operations on to the original target/wrapped object.</p>

<p>One example of the kind of <em>trap</em> handler you can define on a proxy is <code>get</code> that intercepts the <code>[[Get]]</code> operation -- performed when you try to access a property on an object. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-c">// note: target === obj,</span>
            <span class="pl-c">// context === pobj</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>accessing: <span class="pl-pds">"</span></span>, key );
            <span class="pl-k">return</span> Reflect.get(
                target, key, context
            );
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

obj.a;
<span class="pl-c">// 1</span>

pobj.a;
<span class="pl-c">// accessing: a</span>
<span class="pl-c">// 1</span></pre></div>

<p>We declare a <code>get(..)</code> handler as a named method on the <em>handler</em> object (second argument to <code>Proxy(..)</code>), which receives a reference to the <em>target</em> object (<code>obj</code>), the <em>key</em> property name (<code>"a"</code>), and the <code>self</code>/receiver/proxy (<code>pobj</code>).</p>

<p>After the <code>console.log(..)</code> tracing statement, we "forward" the operation onto <code>obj</code> via <code>Reflect.get(..)</code>. We will cover the <code>Reflect</code> API in the next section, but note that each available proxy trap has a corresponding <code>Reflect</code> function of the same name.</p>

<p>These mappings are symmetric on purpose. The proxy handlers each intercept when a respective meta programming task is performed, and the <code>Reflect</code> utilities each perform the respective meta programming task on an object. Each proxy handler has a default definition that automatically calls the corresponding <code>Reflect</code> utility. You will almost certainly use both <code>Proxy</code> and <code>Reflect</code> in tandem.</p>

<p>Here's a list of handlers you can define on a proxy for a <em>target</em> object/function, and how/when they are triggered:</p>

<ul>
<li><code>get(..)</code>: via <code>[[Get]]</code>, a property is accessed on the proxy (<code>Reflect.get(..)</code>, <code>.</code> property operator, or <code>[ .. ]</code> property operator)</li>
<li><code>set(..)</code>: via <code>[[Set]]</code>, a property value is set on the proxy (<code>Reflect.set(..)</code>, the <code>=</code> assignment operator, or destructuring assignment if it targets an object property)</li>
<li><code>deleteProperty(..)</code>: via <code>[[Delete]]</code>, a property is deleted from the proxy (<code>Reflect.deleteProperty(..)</code> or <code>delete</code>)</li>
<li><code>apply(..)</code> (if <em>target</em> is a function): via <code>[[Call]]</code>, the proxy is invoked as a normal function/method (<code>Reflect.apply(..)</code>, <code>call(..)</code>, <code>apply(..)</code>, or the <code>(..)</code> call operator)</li>
<li><code>construct(..)</code> (if <em>target</em> is a constructor function): via <code>[[Construct]]</code>, the proxy is invoked as a constructor function (<code>Reflect.construct(..)</code> or <code>new</code>)</li>
<li><code>getOwnPropertyDescriptor(..)</code>: via <code>[[GetOwnProperty]]</code>, a property descriptor is retrieved from the proxy (<code>Object.getOwnPropertyDescriptor(..)</code> or <code>Reflect.getOwnPropertyDescriptor(..)</code>)</li>
<li><code>defineProperty(..)</code>: via <code>[[DefineOwnProperty]]</code>, a property descriptor is set on the proxy (<code>Object.defineProperty(..)</code> or <code>Reflect.defineProperty(..)</code>)</li>
<li><code>getPrototypeOf(..)</code>: via <code>[[GetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is retrieved (<code>Object.getPrototypeOf(..)</code>, <code>Reflect.getPrototypeOf(..)</code>, <code>__proto__</code>, <code>Object#isPrototypeOf(..)</code>, or <code>instanceof</code>)</li>
<li><code>setPrototypeOf(..)</code>: via <code>[[SetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is set (<code>Object.setPrototypeOf(..)</code>, <code>Reflect.setPrototypeOf(..)</code>, or <code>__proto__</code>)</li>
<li><code>preventExtensions(..)</code>: via <code>[[PreventExtensions]]</code>, the proxy is made non-extensible (<code>Object.preventExtensions(..)</code> or <code>Reflect.preventExtensions(..)</code>)</li>
<li><code>isExtensible(..)</code>: via <code>[[IsExtensible]]</code>, the extensibility of the proxy is probed (<code>Object.isExtensible(..)</code> or <code>Reflect.isExtensible(..)</code>)</li>
<li><code>ownKeys(..)</code>: via <code>[[OwnPropertyKeys]]</code>, the set of owned properties and/or owned symbol properties of the proxy is retrieved (<code>Object.keys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, <code>Object.getOwnSymbolProperties(..)</code>, <code>Reflect.ownKeys(..)</code>, or <code>JSON.stringify(..)</code>)</li>
<li><code>enumerate(..)</code>: via <code>[[Enumerate]]</code>, an iterator is requested for the proxy's enumerable owned and "inherited" properties (<code>Reflect.enumerate(..)</code> or <code>for..in</code>)</li>
<li><code>has(..)</code>: via <code>[[HasProperty]]</code>, the proxy is probed to see if it has an owned or "inherited" property (<code>Reflect.has(..)</code>, <code>Object#hasOwnProperty(..)</code>, or <code>"prop" in obj</code>)</li>
</ul>

<p><strong>Tip:</strong> For more information about each of these meta programming tasks, see the "<code>Reflect</code> API" section later in this chapter.</p>

<p>In addition to the notations in the preceding list about actions that will trigger the various traps, some traps are triggered indirectly by the default actions of another trap. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">getOwnPropertyDescriptor</span>(<span class="pl-smi">target</span>,<span class="pl-smi">prop</span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(
                <span class="pl-s"><span class="pl-pds">"</span>getOwnPropertyDescriptor<span class="pl-pds">"</span></span>
            );
            <span class="pl-k">return</span> <span class="pl-c1">Object</span>.getOwnPropertyDescriptor(
                target, prop
            );
        },
        <span class="pl-en">defineProperty</span>(<span class="pl-smi">target</span>,<span class="pl-smi">prop</span>,<span class="pl-smi">desc</span>){
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>defineProperty<span class="pl-pds">"</span></span> );
            <span class="pl-k">return</span> <span class="pl-c1">Object</span>.defineProperty(
                target, prop, desc
            );
        }
    },
    proxy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers );

proxy.a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
<span class="pl-c">// getOwnPropertyDescriptor</span>
<span class="pl-c">// defineProperty</span></pre></div>

<p>The <code>getOwnPropertyDescriptor(..)</code> and <code>defineProperty(..)</code> handlers are triggered by the default <code>set(..)</code> handler's steps when setting a property value (whether newly adding or updating). If you also define your own <code>set(..)</code> handler, you may or may not make the corresponding calls against <code>context</code> (not <code>target</code>!) which would trigger these proxy traps.</p>

<h3><a id="user-content-proxy-limitations" class="anchor" href="#proxy-limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy Limitations</h3>

<p>These meta programming handlers trap a wide array of fundamental operations you can perform against an object. However, there are some operations which are not (yet, at least) available to intercept.</p>

<p>For example, none of these operations are trapped and forwarded from <code>pobj</code> proxy to <code>obj</code> target:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span> },
    handlers <span class="pl-k">=</span> { .. },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

<span class="pl-k">typeof</span> obj;
<span class="pl-c1">String</span>( obj );
obj <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
obj <span class="pl-k">==</span> pobj;
obj <span class="pl-k">===</span> pobj</pre></div>

<p>Perhaps in the future, more of these underlying fundamental operations in the language will be interceptable, giving us even more power to extend JavaScript from within itself.</p>

<p><strong>Warning:</strong> There are certain <em>invariants</em> -- behaviors which cannot be overridden -- that apply to the use of proxy handlers. For example, the result from the <code>isExtensible(..)</code> handler is always coerced to a <code>boolean</code>. These invariants restrict some of your ability to customize behaviors with proxies, but they do so only to prevent you from creating strange and unusual (or inconsistent) behavior. The conditions for these invariants are complicated so we won't fully go into them here, but this post (<a href="http://www.2ality.com/2014/12/es6-proxies.html#invariants">http://www.2ality.com/2014/12/es6-proxies.html#invariants</a>) does a great job of covering them.</p>

<h3><a id="user-content-revocable-proxies" class="anchor" href="#revocable-proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Revocable Proxies</h3>

<p>A regular proxy always traps for the target object, and cannot be modified after creation -- as long as a reference is kept to the proxy, proxying remains possible. However, there may be cases where you want to create a proxy that can be disabled when you want to stop allowing it to proxy. The solution is to create a <em>revocable proxy</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-c">// note: target === obj,</span>
            <span class="pl-c">// context === pobj</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>accessing: <span class="pl-pds">"</span></span>, key );
            <span class="pl-k">return</span> target[key];
        }
    },
    { proxy<span class="pl-k">:</span> pobj, revoke<span class="pl-k">:</span> prevoke } <span class="pl-k">=</span>
        Proxy.revocable( obj, handlers );

pobj.a;
<span class="pl-c">// accessing: a</span>
<span class="pl-c">// 1</span>

<span class="pl-c">// later:</span>
prevoke();

pobj.a;
<span class="pl-c">// TypeError</span></pre></div>

<p>A revocable proxy is created with <code>Proxy.revocable(..)</code>, which is a regular function, not a constructor like <code>Proxy(..)</code>. Otherwise, it takes the same two arguments: <em>target</em> and <em>handlers</em>.</p>

<p>The return value of <code>Proxy.revocable(..)</code> is not the proxy itself as with <code>new Proxy(..)</code>. Instead, it's an object with two properties: <em>proxy</em> and <em>revoke</em> -- we used object destructuring (see "Destructuring" in Chapter 2) to assign these properties to <code>pobj</code> and <code>prevoke()</code> variables, respectively.</p>

<p>Once a revocable proxy is revoked, any attempts to access it (trigger any of its traps) will throw a <code>TypeError</code>.</p>

<p>An example of using a revocable proxy might be handing out a proxy to another party in your application that manages data in your model, instead of giving them a reference to the real model object itself. If your model object changes or is replaced, you want to invalidate the proxy you handed out so the other party knows (via the errors!) to request an updated reference to the model.</p>

<h3><a id="user-content-using-proxies" class="anchor" href="#using-proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Proxies</h3>

<p>The meta programming benefits of these Proxy handlers should be obvious. We can almost fully intercept (and thus override) the behavior of objects, meaning we can extend object behavior beyond core JS in some very powerful ways. We'll look at a few example patterns to explore the possibilities.</p>

<h4><a id="user-content-proxy-first-proxy-last" class="anchor" href="#proxy-first-proxy-last" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy First, Proxy Last</h4>

<p>As we mentioned earlier, you typically think of a proxy as "wrapping" the target object. In that sense, the proxy becomes the primary object that the code interfaces with, and the actual target object remains hidden/protected.</p>

<p>You might do this because you want to pass the object somewhere that can't be fully "trusted," and so you need to enforce special rules around its access rather than passing the object itself.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> messages <span class="pl-k">=</span> [],
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>) {
            <span class="pl-c">// string value?</span>
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> target[key] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// filter out punctuation</span>
                <span class="pl-k">return</span> target[key]
                    .<span class="pl-c1">replace</span>(<span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-c1">[<span class="pl-k">^</span><span class="pl-c1">\w</span>]</span><span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
            }

            <span class="pl-c">// pass everything else through</span>
            <span class="pl-k">return</span> target[key];
        },
        <span class="pl-en">set</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">val</span>) {
            <span class="pl-c">// only set unique strings, lowercased</span>
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> val <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
                val <span class="pl-k">=</span> val.<span class="pl-c1">toLowerCase</span>();
                <span class="pl-k">if</span> (target.<span class="pl-c1">indexOf</span>( val ) <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) {
                    target.<span class="pl-c1">push</span>(
                        val.<span class="pl-c1">toLowerCase</span>()
                    );
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
    },
    messages_proxy <span class="pl-k">=</span>
        <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( messages, handlers );

<span class="pl-c">// elsewhere:</span>
messages_proxy.<span class="pl-c1">push</span>(
    <span class="pl-s"><span class="pl-pds">"</span>heLLo...<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>wOrlD!!<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>WoRld!!<span class="pl-pds">"</span></span>
);

messages_proxy.forEach( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(val);
} );
<span class="pl-c">// hello world</span>

messages.forEach( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(val);
} );
<span class="pl-c">// hello... world!!</span></pre></div>

<p>I call this <em>proxy first</em> design, as we interact first (primarily, entirely) with the proxy.</p>

<p>We enforce some special rules on interacting with <code>messages_proxy</code> that aren't enforced for <code>messages</code> itself. We only add elements if the value is a string and is also unique; we also lowercase the value. When retrieving values from <code>messages_proxy</code>, we filter out any punctuation in the strings.</p>

<p>Alternatively, we can completely invert this pattern, where the target interacts with the proxy instead of the proxy interacting with the target. Thus, code really only interacts with the main object. The easiest way to accomplish this fallback is to have the proxy object in the <code>[[Prototype]]</code> chain of the main object.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">return</span> <span class="pl-k">function</span>() {
                context.speak(key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>);
            };
        }
    },
    catchall <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers ),
    greeter <span class="pl-k">=</span> {
        <span class="pl-en">speak</span>(<span class="pl-smi">who</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>someone<span class="pl-pds">"</span></span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>, who );
        }
    };

<span class="pl-c">// setup `greeter` to fall back to `catchall`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( greeter, catchall );

greeter.speak();                <span class="pl-c">// hello someone</span>
greeter.speak( <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span> );       <span class="pl-c">// hello world</span>

greeter.everyone();             <span class="pl-c">// hello everyone!</span></pre></div>

<p>We interact directly with <code>greeter</code> instead of <code>catchall</code>. When we call <code>speak(..)</code>, it's found on <code>greeter</code> and used directly. But when we try to access a method like <code>everyone()</code>, that function doesn't exist on <code>greeter</code>.</p>

<p>The default object property behavior is to check up the <code>[[Prototype]]</code> chain (see the <em>this &amp; Object Prototypes</em> title of this series), so <code>catchall</code> is consulted for an <code>everyone</code> property. The proxy <code>get()</code> handler then kicks in and returns a function that calls <code>speak(..)</code> with the name of the property being accessed (<code>"everyone"</code>).</p>

<p>I call this pattern <em>proxy last</em>, as the proxy is used only as a last resort.</p>

<h4><a id="user-content-no-such-propertymethod" class="anchor" href="#no-such-propertymethod" aria-hidden="true"><span class="octicon octicon-link"></span></a>"No Such Property/Method"</h4>

<p>A common complaint about JS is that objects aren't by default very defensive in the situation where you try to access or set a property that doesn't already exist. You may wish to predefine all the properties/methods for an object, and have an error thrown if a nonexistent property name is subsequently used.</p>

<p>We can accomplish this with a proxy, either in <em>proxy first</em> or <em>proxy last</em> design. Let's consider both.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
        a<span class="pl-k">:</span> <span class="pl-c1">1</span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.a );
        }
    },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
            }
        },
        <span class="pl-en">set</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">val</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.set(
                    target, key, val, context
                );
            }
            <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
            }
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

pobj.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
pobj.foo();         <span class="pl-c">// a: 3</span>

pobj.b <span class="pl-k">=</span> <span class="pl-c1">4</span>;         <span class="pl-c">// Error: No such property/method!</span>
pobj.bar();         <span class="pl-c">// Error: No such property/method!</span></pre></div>

<p>For both <code>get(..)</code> and <code>set(..)</code>, we only forward the operation if the target object's property already exists; error thrown otherwise. The proxy object (<code>pobj</code>) is the main object code should interact with, as it intercepts these actions to provide the protections.</p>

<p>Now, let's consider inverting with <em>proxy last</em> design:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>() {
            <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
        },
        <span class="pl-en">set</span>() {
            <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers ),
    obj <span class="pl-k">=</span> {
        a<span class="pl-k">:</span> <span class="pl-c1">1</span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.a );
        }
    };

<span class="pl-c">// setup `obj` to fall back to `pobj`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( obj, pobj );

obj.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
obj.foo();          <span class="pl-c">// a: 3</span>

obj.b <span class="pl-k">=</span> <span class="pl-c1">4</span>;          <span class="pl-c">// Error: No such property/method!</span>
obj.bar();          <span class="pl-c">// Error: No such property/method!</span></pre></div>

<p>The <em>proxy last</em> design here is a fair bit simpler with respect to how the handlers are defined. Instead of needing to intercept the <code>[[Get]]</code> and <code>[[Set]]</code> operations and only forward them if the target property exists, we instead rely on the fact that if either <code>[[Get]]</code> or <code>[[Set]]</code> get to our <code>pobj</code> fallback, the action has already traversed the whole <code>[[Prototype]]</code> chain and not found a matching property. We are free at that point to unconditionally throw the error. Cool, huh?</p>

<h4><a id="user-content-proxy-hacking-the-prototype-chain" class="anchor" href="#proxy-hacking-the-prototype-chain" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy Hacking the <code>[[Prototype]]</code> Chain</h4>

<p>The <code>[[Get]]</code> operation is the primary channel by which the <code>[[Prototype]]</code> mechanism is invoked. When a property is not found on the immediate object, <code>[[Get]]</code> automatically hands off the operation to the <code>[[Prototype]]</code> object.</p>

<p>That means you can use the <code>get(..)</code> trap of a proxy to emulate or extend the notion of this <code>[[Prototype]]</code> mechanism.</p>

<p>The first hack we'll consider is creating two objects which are circularly linked via <code>[[Prototype]]</code> (or, at least it appears that way!). You cannot actually create a real circular <code>[[Prototype]]</code> chain, as the engine will throw an error. But a proxy can fake it!</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-c">// fake circular `[[Prototype]]`</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">return</span> Reflect.get(
                    target[
                        Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> )
                    ],
                    key,
                    context
                );
            }
        }
    },
    obj1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>(
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-1<span class="pl-pds">"</span></span>,
            <span class="pl-en">foo</span>() {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
            }
        },
        handlers
    ),
    obj2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign(
        <span class="pl-c1">Object</span>.create( obj1 ),
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-2<span class="pl-pds">"</span></span>,
            <span class="pl-en">bar</span>() {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>bar:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
                <span class="pl-v">this</span>.foo();
            }
        }
    );

<span class="pl-c">// fake circular `[[Prototype]]` link</span>
obj1[ Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> obj2;

obj1.bar();
<span class="pl-c">// bar: obj-1 &lt;-- through proxy faking [[Prototype]]</span>
<span class="pl-c">// foo: obj-1 &lt;-- `this` context still preserved</span>

obj2.foo();
<span class="pl-c">// foo: obj-2 &lt;-- through [[Prototype]]</span></pre></div>

<p><strong>Note:</strong> We didn't need to proxy/forward <code>[[Set]]</code> in this example, so we kept things simpler. To be fully <code>[[Prototype]]</code> emulation compliant, you'd want to implement a <code>set(..)</code> handler that searches the <code>[[Prototype]]</code> chain for a matching property and respects its descriptor behavior (e.g., set, writable). See the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>In the previous snippet, <code>obj2</code> is <code>[[Prototype]]</code> linked to <code>obj1</code> by virtue of the <code>Object.create(..)</code> statement. But to create the reverse (circular) linkage, we create property on <code>obj1</code> at the symbol location <code>Symbol.for("[[Prototype]]")</code> (see "Symbols" in Chapter 2). This symbol may look sort of special/magical, but it isn't. It just allows me a conveniently named hook that semantically appears related to the task I'm performing.</p>

<p>Then, the proxy's <code>get(..)</code> handler looks first to see if a requested <code>key</code> is on the proxy. If not, the operation is manually handed off to the object reference stored in the <code>Symbol.for("[[Prototype]]")</code> location of <code>target</code>.</p>

<p>One important advantage of this pattern is that the definitions of <code>obj1</code> and <code>obj2</code> are mostly not intruded by the setting up of this circular relationship between them. Although the previous snippet has all the steps intertwined for brevity's sake, if you look closely, the proxy handler logic is entirely generic (doesn't know about <code>obj1</code> or <code>obj2</code> specifically). So, that logic could be pulled out into a simple helper that wires them up, like a <code>setCircularPrototypeOf(..)</code> for example. We'll leave that as an exercise for the reader.</p>

<p>Now that we've seen how we can use <code>get(..)</code> to emulate a <code>[[Prototype]]</code> link, let's push the hackery a bit further. Instead of a circular <code>[[Prototype]]</code>, what about multiple <code>[[Prototype]]</code> linkages (aka "multiple inheritance")? This turns out to be fairly straightforward:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-1<span class="pl-pds">"</span></span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj1.foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        },
    },
    obj2 <span class="pl-k">=</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-2<span class="pl-pds">"</span></span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj2.foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        },
        <span class="pl-en">bar</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj2.bar:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        }
    },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-c">// fake multiple `[[Prototype]]`</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">for</span> (<span class="pl-k">var</span> P <span class="pl-k">of</span> target[
                    Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> )
                ]) {
                    <span class="pl-k">if</span> (Reflect.has( P, key )) {
                        <span class="pl-k">return</span> Reflect.get(
                            P, key, context
                        );
                    }
                }
            }
        }
    },
    obj3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>(
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-3<span class="pl-pds">"</span></span>,
            <span class="pl-en">baz</span>() {
                <span class="pl-v">this</span>.foo();
                <span class="pl-v">this</span>.bar();
            }
        },
        handlers
    );

<span class="pl-c">// fake multiple `[[Prototype]]` links</span>
obj3[ Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> [
    obj1, obj2
];

obj3.baz();
<span class="pl-c">// obj1.foo: obj-3</span>
<span class="pl-c">// obj2.bar: obj-3</span></pre></div>

<p><strong>Note:</strong> As mentioned in the note after the earlier circular <code>[[Prototype]]</code> example, we didn't implement the <code>set(..)</code> handler, but it would be necessary for a complete solution that emulates <code>[[Set]]</code> actions as normal <code>[[Prototype]]</code>s behave.</p>

<p><code>obj3</code> is set up to multiple-delegate to both <code>obj1</code> and <code>obj2</code>. In <code>obj3.baz()</code>, the <code>this.foo()</code> call ends up pulling <code>foo()</code> from <code>obj1</code> (first-come, first-served, even though there's also a <code>foo()</code> on <code>obj2</code>). If we reordered the linkage as <code>obj2, obj1</code>, the <code>obj2.foo()</code> would have been found and used.</p>

<p>But as is, the <code>this.bar()</code> call doesn't find a <code>bar()</code> on <code>obj1</code>, so it falls over to check <code>obj2</code>, where it finds a match.</p>

<p><code>obj1</code> and <code>obj2</code> represent two parallel <code>[[Prototype]]</code> chains of <code>obj3</code>. <code>obj1</code> and/or <code>obj2</code> could themselves have normal <code>[[Prototype]]</code> delegation to other objects, or either could themself be a proxy (like <code>obj3</code> is) that can multiple-delegate.</p>

<p>Just as with the circular <code>[[Prototype]]</code> example earlier, the definitions of <code>obj1</code>, <code>obj2</code>, and <code>obj3</code> are almost entirely separate from the generic proxy logic that handles the multiple-delegation. It would be trivial to define a utility like <code>setPrototypesOf(..)</code> (notice the "s"!) that takes a main object and a list of objects to fake the multiple <code>[[Prototype]]</code> linkage to. Again, we'll leave that as an exercise for the reader.</p>

<p>Hopefully the power of proxies is now becoming clearer after these various examples. There are many other powerful meta programming tasks that proxies enable.</p>

<h2><a id="user-content-reflect-api" class="anchor" href="#reflect-api" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Reflect</code> API</h2>

<p>The <code>Reflect</code> object is a plain object (like <code>Math</code>), not a function/constructor like the other built-in natives.</p>

<p>It holds static functions which correspond to various meta programming tasks that you can control. These functions correspond one-to-one with the handler methods (<em>traps</em>) that Proxies can define.</p>

<p>Some of the functions will look familiar as functions of the same names on <code>Object</code>:</p>

<ul>
<li><code>Reflect.getOwnPropertyDescriptor(..)</code></li>
<li><code>Reflect.defineProperty(..)</code></li>
<li><code>Reflect.getPrototypeOf(..)</code></li>
<li><code>Reflect.setPrototypeOf(..)</code></li>
<li><code>Reflect.preventExtensions(..)</code></li>
<li><code>Reflect.isExtensible(..)</code></li>
</ul>

<p>These utilities in general behave the same as their <code>Object.*</code> counterparts. However, one difference is that the <code>Object.*</code> counterparts attempt to coerce their first argument (the target object) to an object if it's not already one. The <code>Reflect.*</code> methods simply throw an error in that case.</p>

<p>An object's keys can be accessed/inspected using these utilities:</p>

<ul>
<li><code>Reflect.ownKeys(..)</code>: Returns the list of all owned keys (not "inherited"), as returned by both <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>. See the "Property Enumeration Order" section for information about the order of keys.</li>
<li><code>Reflect.enumerate(..)</code>: Returns an iterator that produces the set of all non-symbol keys (owned and "inherited") that are <em>enumerable</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Essentially, this set of keys is the same as those processed by a <code>for..in</code> loop. See the "Property Enumeration Order" section for information about the order of keys.</li>
<li><code>Reflect.has(..)</code>: Essentially the same as the <code>in</code> operator for checking if a property is on an object or its <code>[[Prototype]]</code> chain. For example, <code>Reflect.has(o,"foo")</code> essentially performs <code>"foo" in o</code>.</li>
</ul>

<p>Function calls and constructor invocations can be performed manually, separate of the normal syntax (e.g., <code>(..)</code> and <code>new</code>) using these utilities:</p>

<ul>
<li><code>Reflect.apply(..)</code>: For example, <code>Reflect.apply(foo,thisObj,[42,"bar"])</code> calls the <code>foo(..)</code> function with <code>thisObj</code> as its <code>this</code>, and passes in the <code>42</code> and <code>"bar"</code> arguments.</li>
<li><code>Reflect.construct(..)</code>: For example, <code>Reflect.construct(foo,[42,"bar"])</code> essentially calls <code>new foo(42,"bar")</code>.</li>
</ul>

<p>Object property access, setting, and deletion can be performed manually using these utilities:</p>

<ul>
<li><code>Reflect.get(..)</code>: For example, <code>Reflect.get(o,"foo")</code> retrieves <code>o.foo</code>.</li>
<li><code>Reflect.set(..)</code>: For example, <code>Reflect.set(o,"foo",42)</code> essentially performs <code>o.foo = 42</code>.</li>
<li><code>Reflect.deleteProperty(..)</code>: For example, <code>Reflect.deleteProperty(o,"foo")</code> essentially performs <code>delete o.foo</code>.</li>
</ul>

<p>The meta programming capabilities of <code>Reflect</code> give you programmtic equivalents to emulate various syntactic features, exposing previously hidden-only abstract operations. For example, you can use these capabilities to extend features and APIs for <em>domain specific languages</em> (DSLs).</p>

<h3><a id="user-content-property-ordering" class="anchor" href="#property-ordering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property Ordering</h3>

<p>Prior to ES6, the order used to list an object's keys/properties was implementation dependent and undefined by the specification. Generally, most engines have enumerated them in creation order, though developers have been strongly encouraged not to ever rely on this ordering.</p>

<p>As of ES6, the order for listing owned properties is now defined (ES6 specification, section 9.1.12) by the <code>[[OwnPropertyKeys]]</code> algorithm, which produces all owned properties (strings or symbols), regardless of enumerability. This ordering is only guaranteed for <code>Reflect.ownKeys(..)</code> (and by extension, <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>).</p>

<p>The ordering is:</p>

<ol>
<li>First, enumerate any owned properties that are integer indexes, in ascending numeric order.</li>
<li>Next, enumerate the rest of the owned string property names in creation order.</li>
<li>Finally, enumerate owned symbol properities in creation order.</li>
</ol>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

o[Symbol(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>yay<span class="pl-pds">"</span></span>;
o[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
o[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
o.b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;
o.a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;

Reflect.ownKeys( o );               <span class="pl-c">// [1,2,"b","a",Symbol(c)]</span>
<span class="pl-c1">Object</span>.getOwnPropertyNames( o );    <span class="pl-c">// [1,2,"b","a"]</span>
<span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [Symbol(c)]</span></pre></div>

<p>On the other hand, the <code>[[Enumerate]]</code> algorithm (ES6 specification, section 9.1.11) produces only enumerable properties, from the target object as well as its <code>[[Prototype]]</code> chain. It is used by both <code>Reflect.enumerate(..)</code> and <code>for..in</code>. The observable ordering is implementation dependent and not controlled by the specification.</p>

<p>By contrast, <code>Object.keys(..)</code> invokes the <code>[[OwnPropertyKeys]]</code> algorithm to get a list of all owned keys. However, it filters out non-enumerable properties and then reorders the list to match legacy implementation-dependent behavior, specifically with <code>JSON.stringify(..)</code> and <code>for..in</code>. So, by extension the ordering <em>also</em> matches that of <code>Reflect.enumerate(..)</code>.</p>

<p>In other words, all four mechanisms (<code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, <code>for..in</code>, and <code>JSON.stringify(..)</code>) will  match with the same implementation-dependent ordering, though they technically get there in different ways.</p>

<p>Implementations are allowed to match these four to the ordering of <code>[[OwnPropertyKeys]]</code>, but are not required to. Nevertheless, you will likely observe the following ordering behavior from them:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };
<span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( o );
p.c <span class="pl-k">=</span> <span class="pl-c1">3</span>;
p.d <span class="pl-k">=</span> <span class="pl-c1">4</span>;

<span class="pl-k">for</span> (<span class="pl-k">var</span> prop <span class="pl-k">of</span> Reflect.enumerate( p )) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( prop );
}
<span class="pl-c">// c d a b</span>

<span class="pl-k">for</span> (<span class="pl-k">var</span> prop <span class="pl-k">in</span> p) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( prop );
}
<span class="pl-c">// c d a b</span>

<span class="pl-c1">JSON</span>.stringify( p );
<span class="pl-c">// {"c":3,"d":4}</span>

<span class="pl-c1">Object</span>.keys( p );
<span class="pl-c">// ["c","d"]</span></pre></div>

<p>Boiling this all down: as of ES6, <code>Reflect.ownKeys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, and <code>Object.getOwnPropertySymbols(..)</code> all have predictable and reliable ordering guaranteed by the specification. So it's safe to build code that relies on this ordering.</p>

<p><code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, and <code>for..in</code> (as well as <code>JSON.stringification(..)</code> by extension) continue to share an observable ordering with each other, as they always have. But that ordering will not necessarily be the same as that of <code>Reflect.ownKeys(..)</code>. Care should still be taken in relying on their implementation-dependent ordering.</p>

<h2><a id="user-content-feature-testing" class="anchor" href="#feature-testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feature Testing</h2>

<p>What is a feature test? It's a test that you run to determine if a feature is available or not. Sometimes, the test is not just for existence, but for conformance to specified behavior -- features can exist but be buggy.</p>

<p>This is a meta programming technique, to test the environment your program runs in to then determine how your program should behave.</p>

<p>The most common use of feature tests in JS is checking for the existence of an API and if it's not present, defining a polyfill (see Chapter 1). For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Number</span>.isNaN) {
    <span class="pl-c1">Number</span>.<span class="pl-en">isNaN</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> x <span class="pl-k">!==</span> x;
    };
}</pre></div>

<p>The <code>if</code> statement in this snippet is meta programming: we're probing our program and its runtime environment to determine if and how we should proceed.</p>

<p>But what about testing for features that involve new syntax?</p>

<p>You might try something like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">try</span> {
    <span class="pl-en">a</span> <span class="pl-k">=</span> ()<span class="pl-k"> =&gt;</span> {};
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>Unfortunately, this doesn't work, because our JS programs are compiled. Thus, the engine will choke on the <code>() =&gt; {}</code> syntax if it is not already supporting ES6 arrow functions. Having a syntax error in your program prevents it from running, which prevents your program from subsequently responding differently if the feature is supported or not.</p>

<p>To meta program with feature tests around syntax-related features, we need a way to insulate the test from the initial compile step our program runs through. For instance, if we could store the code for the test in a string, then the JS engine wouldn't by default try to compile the contents of that string, until we asked it to.</p>

<p>Did your mind just jump to using <code>eval(..)</code>?</p>

<p>Not so fast. See the <em>Scope &amp; Closures</em> title of this series for why <code>eval(..)</code> is a bad idea. But there's another option with less downsides: the <code>Function(..)</code> constructor.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">try</span> {
    <span class="pl-k">new</span> <span class="pl-en">Function</span>( <span class="pl-s"><span class="pl-pds">"</span>( () =&gt; {} )<span class="pl-pds">"</span></span> );
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>OK, so now we're meta programming by determining if a feature like arrow functions <em>can</em> compile in the current engine or not. You might then wonder, what would we do with this information?</p>

<p>With existence checks for APIs, and defining fallback API polyfills, there's a clear path for what to do with either test success or failure. But what can we do with the information that we get from <code>ARROW_FUNCS_ENABLED</code> being <code>true</code> or <code>false</code>?</p>

<p>Because the syntax can't appear in a file if the engine doesn't support that feature, you can't just have different functions defined in the file with and without the syntax in question.</p>

<p>What you can do is use the test to determine which of a set of JS files you should load. For example, if you had a set of these feature tests in a bootstrapper for your JS application, it could then test the environment to determine if your ES6 code can be loaded and run directly, or if you need to load a transpiled version of your code (see Chapter 1).</p>

<p>This technique is called <em>split delivery</em>.</p>

<p>It recognizes the reality that your ES6 authored JS programs will sometimes be able to entirely run "natively" in ES6+ browsers, but other times need transpilation to run in pre-ES6 browsers. If you always load and use the transpiled code, even in the new ES6-compliant environments, you're running suboptimal code at least some of the time. This is not ideal.</p>

<p>Split delivery is more complicated and sophisticated, but it represents a more mature and robust approach to bridging the gap between the code you write and the feature support in browsers your programs must run in.</p>

<h3><a id="user-content-featuretestsio" class="anchor" href="#featuretestsio" aria-hidden="true"><span class="octicon octicon-link"></span></a>FeatureTests.io</h3>

<p>Defining feature tests for all of the ES6+ syntax, as well as the semantic behaviors, is a daunting task you probably don't want to tackle yourself. Because these tests require dynamic compilation (<code>new Function(..)</code>), there's some unfortunate performance cost.</p>

<p>Moreover, running these tests every single time your app runs is probably wasteful, as on average a user's browser only updates once in a several week period at most, and even then, new features aren't necessarily showing up with every update.</p>

<p>Finally, managing the list of feature tests that apply to your specific code base -- rarely will your programs use the entirety of ES6 -- is unruly and error-prone.</p>

<p>The "<a href="https://featuretests.io">https://featuretests.io</a>" feature-tests-as-a-service offers solutions to these frustrations.</p>

<p>You can load the service's library into your page, and it loads the latest test definitions and runs all the feature tests. It does so using background processing with Web Workers, if possible, to reduce the performance overhead. It also uses LocalStorage persistence to cache the results in a way that can be shared across all sites you visit which use the service, which drastically reduces how often the tests need to run on each browser instance.</p>

<p>You get runtime feature tests in each of your users' browsers, and you can use those tests results dynamically to serve users the most appropriate code (no more, no less) for their environments.</p>

<p>Moreover, the service provides tools and APIs to scan your files to determine what features you need, so you can fully automate your split delivery build processes.</p>

<p>FeatureTests.io makes it practical to use feature tests for all parts of ES6 and beyond to make sure that only the best code is ever loaded and run for any given environment.</p>

<h2><a id="user-content-tail-call-optimization-tco" class="anchor" href="#tail-call-optimization-tco" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tail Call Optimization (TCO)</h2>

<p>Normally, when a function call is made from inside another function, a second <em>stack frame</em> is allocated to separately manage the variables/state of that other function invocation. Not only does this allocation cost some processing time, but it also takes up some extra memory.</p>

<p>A call stack chain typically has at most 10-15 jumps from one function to another and another. In those scenarios, the memory usage is not likely any kind of practical problem.</p>

<p>However, when you consider recursive programming (a function calling itself repeatedly) -- or mutual recursion with two or more functions calling each other -- the call stack could easily be hundreds, thousands, or more levels deep. You can probably see the problems that could cause, if memory usage grows unbounded.</p>

<p>JavaScript engines have to set an arbitrary limit to prevent such programming techniques from crashing by running the browser and device out of memory. That's why we get the frustrating "RangeError: Maximum call stack size exceeded" thrown if the limit is hit.</p>

<p><strong>Warning:</strong> The limit of call stack depth is not controlled by the specification. It's implementation dependent, and will vary between browsers and devices. You should never code with strong assumptions of exact observable limits, as they may very well change from release to release.</p>

<p>Certain patterns of function calls, called <em>tail calls</em>, can be optimized in a way to avoid the extra allocation of stack frames. If the extra allocation can be avoided, there's no reason to arbitrarily limit the call stack depth, so the engines can let them run unbounded.</p>

<p>A tail call is a <code>return</code> statement with a function call, where nothing has to happen after the call except returning its value.</p>

<p>This optimization can only be applied in <code>strict</code> mode. Yet another reason to always be writing all your code as <code>strict</code>!</p>

<p>Here's a function call that is <em>not</em> in tail position:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// not a tail call</span>
    <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> foo( x );
}

bar( <span class="pl-c1">10</span> );              <span class="pl-c">// 21</span></pre></div>

<p><code>1 + ..</code> has to be performed after the <code>foo(x)</code> call completes, so the state of that <code>bar(..)</code> invocation needs to be preserved.</p>

<p>But the following snippet demonstrates calls to <code>foo(..)</code> and <code>bar(..)</code> where both <em>are</em> in tail position, as they're the last thing to happen in their code path (other than the <code>return</code>):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    x <span class="pl-k">=</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>) {
        <span class="pl-k">return</span> foo( x );
    }
    <span class="pl-k">else</span> {
        <span class="pl-k">return</span> bar( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
}

bar( <span class="pl-c1">5</span> );               <span class="pl-c">// 24</span>
bar( <span class="pl-c1">15</span> );              <span class="pl-c">// 32</span></pre></div>

<p>In this program, <code>bar(..)</code> is clearly recursive, but <code>foo(..)</code> is just a regular function call. In both cases, the function calls are in <em>proper tail position</em>. The <code>x + 1</code> is evaluated before the <code>bar(..)</code> call, and whenever that call finishes, all that happens is the <code>return</code>.</p>

<p>Proper Tail Calls (PTC) of these forms can be optimized -- called tail call optimization (TCO) -- so that the extra stack frame allocation is unnecessary. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn't need to preserve any of the current state, as nothing happens with that state after the PTC.</p>

<p>TCO means there's practically no limit to how deep the call stack can be. That trick slightly improves regular function calls in normal programs, but more importantly opens the door to using recursion for program expression even if the call stack could be tens of thousands of calls deep.</p>

<p>We're no longer relegated to simply theorizing about recursion for problem solving, but can actually use it in real JavaScript programs!</p>

<p>As of ES6, all PTC should be optimizable in this way, recursion or not.</p>

<h3><a id="user-content-tail-call-rewrite" class="anchor" href="#tail-call-rewrite" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tail Call Rewrite</h3>

<p>The hitch, however, is that only PTC can be optimized; non-PTC will still work of course, but will cause stack frame allocation as they always did. You'll have to be careful about structuring your functions with PTC if you expect the optimizations to kick in.</p>

<p>If you have a function that's not written with PTC, you may find the need to manually rearrange your code to be eligible for TCO.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    <span class="pl-k">return</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> foo( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// RangeError</span></pre></div>

<p>The call to <code>foo(x-1)</code> isn't a PTC because its result has to be added to <code>(x / 2)</code> before <code>return</code>ing.</p>

<p>However, to make this code eligible for TCO in an ES6 engine, we can rewrite it as follows:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> acc;
        <span class="pl-k">return</span> _foo( (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc, x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
    }

    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> _foo( <span class="pl-c1">1</span>, x );
    };
})();

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>If you run the previous snippet in an ES6 engine that implements TCO, you'll get the <code>3810376848.5</code> answer as shown. However, it'll still fail with a <code>RangeError</code> in non-TCO engines.</p>

<h3><a id="user-content-non-tco-optimizations" class="anchor" href="#non-tco-optimizations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-TCO Optimizations</h3>

<p>There are other techniques to rewrite the code so that the call stack isn't growing with each call.</p>

<p>One such technique is called <em>trampolining</em>, which amounts to having each partial result represented as a function that either returns another partial result function or the final result. Then you can simply loop until you stop getting a function, and you'll have the result. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">trampoline</span>( <span class="pl-smi">res</span> ) {
    <span class="pl-k">while</span> (<span class="pl-k">typeof</span> res <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>) {
        res <span class="pl-k">=</span> res();
    }
    <span class="pl-k">return</span> res;
}

<span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> acc;
        <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">partial</span>(){
            <span class="pl-k">return</span> _foo( (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc, x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
        };
    }

    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> trampoline( _foo( <span class="pl-c1">1</span>, x ) );
    };
})();

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This reworking required minimal changes to factor out the recursion into the loop in <code>trampoline(..)</code>:</p>

<ol>
<li>First, we wrapped the <code>return _foo ..</code> line in the <code>return partial() { ..</code> function expression.</li>
<li>Then we wrapped the <code>_foo(1,x)</code> call in the <code>trampoline(..)</code> call.</li>
</ol>

<p>The reason this technique doesn't suffer the call stack limitiation is that each of those inner <code>partial(..)</code> functions is just returned back to the <code>while</code> loop in <code>trampoline(..)</code>, which runs it and then loop iterates again. In other words, <code>partial(..)</code> doesn't recursively call itself, it just returns another function. The stack depth remains constant, so it can run as long as it needs to.</p>

<p>Trampolining expressed in this way uses the closure that the inner <code>partial()</code> function has over the <code>x</code> and <code>acc</code> variables to keep the state from iteration to iteration. The advantage is that the looping logic is pulled out into a reusable <code>trampoline(..)</code> utility function, which many libraries provide versions of. You can reuse <code>trampoline(..)</code> multiple times in your program with different trampolined algorithms.</p>

<p>Of course, if you really wanted to deeply optimize (and the reusability wasn't a concern), you could discard the closure state and inline the state tracking of <code>acc</code> into just one function's scope along with a loop. This technique is generally called <em>recursion unrolling</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">var</span> acc <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
        acc <span class="pl-k">=</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc;
        x <span class="pl-k">=</span> x <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> acc;
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This expression of the algorithm is simpler to read, and will likely perform the best (strictly speaking) of the various forms we've explored. That may seem like a clear winner, and you may wonder why you would ever try the other approaches.</p>

<p>There are some reasons why you might not want to always manually unroll your recursions:</p>

<ul>
<li>Instead of factoring out the trampolining (loop) logic for reusability, we've inlined it. This works great when there's only one example to consider, but as soon as you have a half dozen or more of these in your program, there's a good chance you'll want some reusabilty to keep things shorter and more manageable.</li>
<li><p>The example here is deliberately simple enough to illustrate the different forms. In practice, there are many more complications in recursion algorithms, such as mutual recursion (more than just one function calling itself).</p>

<p>The farther you go down this rabbit hole, the more manual and intricate the <em>unrolling</em> optimizations are. You'll quickly lose all the perceived value of readability. The primary advantage of recursion, even in the PTC form, is that it preserves the algorithm readability, and offloads the performance optimization to the engine.</p></li>
</ul>

<p>If you write your algorithms with PTC, the ES6 engine will apply TCO to let your code run in constant stack depth (by reusing stack frames). You get the readability of recursion with most of the performance benefits and no limitations of run length.</p>

<h3><a id="user-content-meta" class="anchor" href="#meta" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meta?</h3>

<p>What does TCO have to do with meta programming?</p>

<p>As we covered in the "Feature Testing" section earlier, you can determine at runtime what features an engine supports. This includes TCO, though determining it is quite brute force. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">try</span> {
    (<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>){
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">5E5</span>) <span class="pl-k">return</span> foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    })( <span class="pl-c1">1</span> );

    <span class="pl-c1">TCO_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">TCO_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>In a non-TCO engine, the recursive loop will fail out eventually, throwing an exception caught by the <code>try..catch</code>. Otherwise, the loop completes easily thanks to TCO.</p>

<p>Yuck, right?</p>

<p>But how could meta programming around the TCO feature (or rather, the lack thereof) benefit our code? The simple answer is that you could use such a feature test to decide to load a version of your application's code that uses recursion, or an alternative one that's been converted/transpiled to not need recursion.</p>

<h4><a id="user-content-self-adjusting-code" class="anchor" href="#self-adjusting-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Self-Adjusting Code</h4>

<p>But here's another way of looking at the problem:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>() {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
            acc <span class="pl-k">=</span> acc <span class="pl-k">+</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>);
            x <span class="pl-k">=</span> x <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            <span class="pl-k">return</span> _foo();
        }
    }

    <span class="pl-k">var</span> acc <span class="pl-k">=</span> <span class="pl-c1">1</span>;

    <span class="pl-k">while</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
        <span class="pl-k">try</span> {
            _foo();
        }
        <span class="pl-k">catch</span> (err) { }
    }

    <span class="pl-k">return</span> acc;
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This algorithm works by attempting to do as much of the work with recursion as possible, but keeping track of the progress via scoped variables <code>x</code> and <code>acc</code>. If the entire problem can be solved with recursion without an error, great. If the engine kills the recursion at some point, we simply catch that with the <code>try..catch</code> and then try again, picking up where we left off.</p>

<p>I consider this a form of meta programming in that you are probing during runtime the ability of the engine to fully (recursively) finish the task, and working around any (non-TCO) engine limitations that may restrict you.</p>

<p>At first (or even second!) glance, my bet is this code seems much uglier to you compared to some of the earlier versions. It also runs a fair bit slower (on larger runs in a non-TCO environment).</p>

<p>The primary advantage, other than it being able to complete any size task even in non-TCO engines, is that this "solution" to the recursion stack limitation is much more flexible than the trampolining or manual unrolling techniques shown previously.</p>

<p>Essentially, <code>_foo()</code> in this case is a sort of stand-in for practically any recursive task, even mutual recursion. The rest is the boilerplate that should work for just about any algorithm.</p>

<p>The only "catch" is that to be able to resume in the event of a recursion limit being hit, the state of the recursion must be in scoped variables that exist outside the recursive function(s). We did that by leaving <code>x</code> and <code>acc</code> outside of the <code>_foo()</code> function, instead of passing them as arguments to <code>_foo()</code> as earlier.</p>

<p>Almost any recursive algorithm can be adapted to work this way. That means it's the most widely applicable way of leveraging TCO with recursion in your programs, with minimal rewriting.</p>

<p>This approach still uses a PTC, meaning that this code will <em>progressively enhance</em> from running using the loop many times (recursion batches) in an older browser to fully leveraging TCO'd recursion in an ES6+ environment. I think that's pretty cool!</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Meta programming is when you turn the logic of your program to focus on itself (or its runtime environment), either to inspect its own structure or to modify it. The primary value of meta programming is to extend the normal mechanisms of the language to provide additional capabilities.</p>

<p>Prior to ES6, JavaScript already had quite a bit of meta programming capability, but ES6 significantly ramps that up with several new features.</p>

<p>From function name inferences for anonymous functions to meta properties that give you information about things like how a constructor was invoked, you can inspect the program structure while it runs more than ever before. Well Known Symbols let you override intrinsic behaviors, such as coercion of an object to a primitive value. Proxies can intercept and customize various low-level operations on objects, and <code>Reflect</code> provides utilities to emulate them.</p>

<p>Feature testing, even for subtle semantic behaviors like Tail Call Optimization, shifts the meta programming focus from your program to the JS engine capabilities itself. By knowing more about what the environment can do, your programs can adjust themselves to the best fit as they run.</p>

<p>Should you meta program? My advice is: first focus on learning how the core mechanics of the language really work. But once you fully know what JS itself can do, it's time to start leveraging these powerful meta programming capabilities to push the language further!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-8-beyond-es6" class="anchor" href="#chapter-8-beyond-es6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 8: Beyond ES6</h1>

<p>At the time of this writing, the final draft of ES6 (<em>ECMAScript 2015</em>) is shortly headed toward its final official vote of approval by ECMA. But even as ES6 is being finalized, the TC39 committee is already hard at work at on features for ES7/2016 and beyond.</p>

<p>As we discussed in Chapter 1, it's expected that the cadence of progress for JS is going to accelerate from updating once every several years to having an official version update once per year (hence the year-based naming). That alone is going to radically change how JS developers learn about and keep up with the language.</p>

<p>But even more importantly, the committee is actually going to work feature by feature. As soon as a feature is spec-complete and has its kinks worked out through implementation experiments in a few browsers, that feature will be considered stable enough to start using. We're all strongly encouraged to adopt features once they're ready instead of waiting for some official standards vote. If you haven't already learned ES6, the time is <em>past due</em> to get on board!</p>

<p>As the time of this writing, a list of future proposals and their status can be seen here (<a href="https://github.com/tc39/ecma262#current-proposals">https://github.com/tc39/ecma262#current-proposals</a>).</p>

<p>Transpilers and polyfills are how we'll bridge to these new features even before all browsers we support have implemented them. Babel, Traceur, and several other major transpilers already have support for some of the post-ES6 features that are most likely to stabilize.</p>

<p>With that in mind, it's already time for us to look at some of them. Let's jump in!</p>

<p><strong>Warning:</strong> These features are all in various stages of development. While they're likely to land, and probably will look similar, take the contents of this chapter with more than a few grains of salt. This chapter will evolve in future editions of this title as these (and other!) features finalize.</p>

<h2><a id="user-content-async-functions" class="anchor" href="#async-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>async function</code>s</h2>

<p>In "Generators + Promises" in Chapter 4, we mentioned that there's a proposal for direct syntactic support for the pattern of generators <code>yield</code>ing promises to a runner-like utility that will resume it on promise completion. Let's take a brief look at that proposed feature, called <code>async function</code>.</p>

<p>Recall this generator example from Chapter 4:</p>

<div class="highlight highlight-source-js"><pre>run( <span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2Failed( err );
    }

    ret <span class="pl-k">=</span> <span class="pl-k">yield</span> Promise.<span class="pl-c1">all</span>([
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ]);

    <span class="pl-k">yield</span> step4( ret );
} )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `*main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>The proposed <code>async function</code> syntax can express this same flow control logic without needing the <code>run(..)</code> utility, because JS will automatically know how to look for promises to wait and resume. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">async</span> <span class="pl-k">function</span> <span class="pl-en">main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">await</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">await</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">await</span> step2Failed( err );
    }

    ret <span class="pl-k">=</span> <span class="pl-k">await</span> Promise.<span class="pl-c1">all</span>( [
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ] );

    <span class="pl-k">await</span> step4( ret );
}

main()
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>Instead of the <code>function *main() { ..</code> declaration, we declare with the <code>async function main() { ..</code> form. And instead of <code>yield</code>ing a promise, we <code>await</code> the promise. The call to run the function <code>main()</code> actually returns a promise that we can directly observe. That's the equivalent to the promise that we get back from a <code>run(main)</code> call.</p>

<p>Do you see the symmetry? <code>async function</code> is essentially syntactic sugar for the generators + promises + <code>run(..)</code> pattern; under the covers, it operates the same!</p>

<p>If you're a C# developer and this <code>async</code>/<code>await</code> looks familiar, it's because this feature is directly inspired by C#'s feature. It's nice to see language precedence informing convergence!</p>

<p>Babel, Traceur and other transpilers already have early support for the current status of <code>async function</code>s, so you can start using them already. However, in the next section "Caveats", we'll see why you perhaps shouldn't jump on that ship quite yet.</p>

<p><strong>Note:</strong> There's also a proposal for <code>async function*</code>, which would be called an "async generator." You can both <code>yield</code> and <code>await</code> in the same code, and even combine those operations in the same statement: <code>x = await yield y</code>. The "async generator" proposal seems to be more in flux -- namely, its return value is not fully worked out yet. Some feel it should be an <em>observable</em>, which is kind of like the combination of an iterator and a promise. For now, we won't go further into that topic, but stay tuned as it evolves.</p>

<h3><a id="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caveats</h3>

<p>One unresolved point of contention with <code>async function</code> is that because it only returns a promise, there's no way from the outside to <em>cancel</em> an <code>async function</code> instance that's currently running. This can be a problem if the async operation is resource intensive, and you want to free up the resources as soon as you're sure the result won't be needed.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">async</span> <span class="pl-k">function</span> <span class="pl-en">request</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">var</span> resp <span class="pl-k">=</span> <span class="pl-k">await</span> (
        <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
            <span class="pl-k">var</span> xhr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">XMLHttpRequest</span>();
            xhr.<span class="pl-c1">open</span>( <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>, url );
            <span class="pl-c1">xhr</span>.<span class="pl-en">onreadystatechange</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
                <span class="pl-k">if</span> (xhr.<span class="pl-c1">readyState</span> <span class="pl-k">==</span> <span class="pl-c1">4</span>) {
                    <span class="pl-k">if</span> (xhr.<span class="pl-c1">status</span> <span class="pl-k">==</span> <span class="pl-c1">200</span>) {
                        resolve( xhr );
                    }
                    <span class="pl-k">else</span> {
                        reject( xhr.<span class="pl-c1">statusText</span> );
                    }
                }
            };
            xhr.<span class="pl-c1">send</span>();
        } )
    );

    <span class="pl-k">return</span> resp.responseText;
}

<span class="pl-k">var</span> pr <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

pr.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">responseText</span>){
        <span class="pl-c">// ajax success</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>This <code>request(..)</code> that I've conceived is somewhat like the <code>fetch(..)</code> utility that's recently been proposed for inclusion into the web platform. So the concern is, what happens if you want to use the <code>pr</code> value to somehow indicate that you want to cancel a long-running Ajax request, for example?</p>

<p>Promises are not cancelable (at the time of writing, anyway). In my opinion, as well as many others, they never should be (see the <em>Async &amp; Performance</em> title of this series). And even if a promise did have a <code>cancel()</code> method on it, does that necessarily mean that calling <code>pr.cancel()</code> should actually propagate a cancelation signal all the way back up the promise chain to the <code>async function</code>?</p>

<p>Several possible resolutions to this debate have surfaced:</p>

<ul>
<li><code>async function</code>s won't be cancelable at all (status quo)</li>
<li>A "cancel token" can be passed to an async function at call time</li>
<li>Return value changes to a cancelable-promise type that's added</li>
<li>Return value changes to something else non-promise (e.g., observable, or control token with promise and cancel capabilities)</li>
</ul>

<p>At the time of this writing, <code>async function</code>s return regular promises, so it's less likely that the return value will entirely change. But it's too early to tell where things will land. Keep an eye on this discussion.</p>

<h2><a id="user-content-objectobserve" class="anchor" href="#objectobserve" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.observe(..)</code></h2>

<p>One of the holy grails of front-end web development is data binding -- listening for updates to a data object and syncing the DOM representation of that data. Most JS frameworks provide some mechanism for these sorts of operations.</p>

<p>It appears likely that post ES6, we'll see support added directly to the language, via a utility called <code>Object.observe(..)</code>. Essentially, the idea is that you can set up a listener to observe an object's changes, and have a callback called any time a change occurs. You can then update the DOM accordingly, for instance.</p>

<p>There are six types of changes that you can observe:</p>

<ul>
<li>add</li>
<li>update</li>
<li>delete</li>
<li>reconfigure</li>
<li>setPrototype</li>
<li>preventExtensions</li>
</ul>

<p>By default, you'll be notified of all these change types, but you can filter down to only the ones you care about.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-c1">Object</span>.observe(
    obj,
    <span class="pl-k">function</span>(<span class="pl-smi">changes</span>){
        <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( change );
        }
    },
    [ <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>update<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>delete<span class="pl-pds">"</span></span> ]
);

obj.c <span class="pl-k">=</span> <span class="pl-c1">3</span>;
<span class="pl-c">// { name: "c", object: obj, type: "add" }</span>

obj.a <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-c">// { name: "a", object: obj, type: "update", oldValue: 1 }</span>

<span class="pl-k">delete</span> obj.b;
<span class="pl-c">// { name: "b", object: obj, type: "delete", oldValue: 2 }</span></pre></div>

<p>In addition to the main <code>"add"</code>, <code>"update"</code>, and <code>"delete"</code> change types:</p>

<ul>
<li>The <code>"reconfigure"</code> change event is fired if one of the object's properties is reconfigured with <code>Object.defineProperty(..)</code>, such as changing its <code>writable</code> attribute. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</li>
<li><p>The <code>"preventExtensions"</code> change event is fired if the object is made non-extensible via <code>Object.preventExtensions(..)</code>.</p>

<p>Because both <code>Object.seal(..)</code> and <code>Object.freeze(..)</code> also imply <code>Object.preventExtensions(..)</code>, they'll also fire its corresponding change event. In addition, <code>"reconfigure"</code> change events will also be fired for each property on the object.</p></li>
<li>The <code>"setPrototype"</code> change event is fired if the <code>[[Prototype]]</code> of an object is changed, either by setting it with the <code>__proto__</code> setter, or using <code>Object.setPrototypeOf(..)</code>.</li>
</ul>

<p>Notice that these change events are notified immediately after said change. Don't confuse this with proxies (see Chapter 7) where you can intercept the actions before they occur. Object observation lets you respond after a change (or set of changes) occurs.</p>

<h3><a id="user-content-custom-change-events" class="anchor" href="#custom-change-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom Change Events</h3>

<p>In addition to the six built-in change event types, you can also listen for and fire custom change events.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">observer</span>(<span class="pl-smi">changes</span>){
    <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
        <span class="pl-k">if</span> (change.<span class="pl-c1">type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>) {
            change.<span class="pl-c1">object</span>.c <span class="pl-k">=</span>
                change.<span class="pl-c1">object</span>.oldValue <span class="pl-k">+</span>
                change.<span class="pl-c1">object</span>.a <span class="pl-k">+</span>
                change.<span class="pl-c1">object</span>.b;
        }
    }
}

<span class="pl-k">function</span> <span class="pl-en">changeObj</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-k">var</span> notifier <span class="pl-k">=</span> <span class="pl-c1">Object</span>.getNotifier( obj );

    obj.a <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    obj.b <span class="pl-k">=</span> b <span class="pl-k">*</span> <span class="pl-c1">3</span>;

    <span class="pl-c">// queue up change events into a set</span>
    notifier.notify( {
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>,
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,
        oldValue<span class="pl-k">:</span> obj.c
    } );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> };

<span class="pl-c1">Object</span>.observe(
    obj,
    observer,
    [<span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>]
);

changeObj( <span class="pl-c1">3</span>, <span class="pl-c1">11</span> );

obj.a;          <span class="pl-c">// 12</span>
obj.b;          <span class="pl-c">// 30</span>
obj.c;          <span class="pl-c">// 3</span></pre></div>

<p>The change set (<code>"recalc"</code> custom event) has been queued for delivery to the observer, but not delivered yet, which is why <code>obj.c</code> is still <code>3</code>.</p>

<p>The changes are by default delivered at the end of the current event loop (see the <em>Async &amp; Performance</em> title of this series). If you want to deliver them immediately, use <code>Object.deliverChangeRecords(observer)</code>. Once the change events are delivered, you can observe <code>obj.c</code> updated as expected:</p>

<div class="highlight highlight-source-js"><pre>obj.c;          <span class="pl-c">// 42</span></pre></div>

<p>In the previous example, we called <code>notifier.notify(..)</code> with the complete change event record. An alternative form for queuing change records is to use <code>performChange(..)</code>, which separates specifying the type of the event from the rest of event record's properties (via a function callback). Consider:</p>

<div class="highlight highlight-source-js"><pre>notifier.performChange( <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,
        <span class="pl-c">// `this` is the object under observation</span>
        oldValue<span class="pl-k">:</span> <span class="pl-v">this</span>.c
    };
} );</pre></div>

<p>In certain circumstances, this separation of concerns may map more cleanly to your usage pattern.</p>

<h3><a id="user-content-ending-observation" class="anchor" href="#ending-observation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ending Observation</h3>

<p>Just like with normal event listeners, you may wish to stop observing an object's change events. For that, you use <code>Object.unobserve(..)</code>.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-c1">Object</span>.observe( obj, <span class="pl-k">function</span> <span class="pl-en">observer</span>(<span class="pl-smi">changes</span>) {
    <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
        <span class="pl-k">if</span> (change.<span class="pl-c1">type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>setPrototype<span class="pl-pds">"</span></span>) {
            <span class="pl-c1">Object</span>.unobserve(
                change.<span class="pl-c1">object</span>, observer
            );
            <span class="pl-k">break</span>;
        }
    }
} );</pre></div>

<p>In this trivial example, we listen for change events until we see the <code>"setPrototype"</code> event come through, at which time we stop observing any more change events.</p>

<h2><a id="user-content-exponentiation-operator" class="anchor" href="#exponentiation-operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exponentiation Operator</h2>

<p>An operator has been proposed for JavaScript to perform exponentiation in the same way that <code>Math.pow(..)</code> does. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

a <span class="pl-k">**</span> <span class="pl-c1">4</span>;         <span class="pl-c">// Math.pow( a, 4 ) == 16</span>

a <span class="pl-k">**=</span> <span class="pl-c1">3</span>;        <span class="pl-c">// a = Math.pow( a, 3 )</span>
a;              <span class="pl-c">// 8</span></pre></div>

<p><strong>Note:</strong> <code>**</code> is essentially the same as it appears in Python, Ruby, Perl, and others.</p>

<h2><a id="user-content-objects-properties-and-" class="anchor" href="#objects-properties-and-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objects Properties and <code>...</code></h2>

<p>As we saw in the "Too Many, Too Few, Just Enough" section of Chapter 2, the <code>...</code> operator is pretty obvious in how it relates to spreading or gathering arrays. But what about objects?</p>

<p>Such a feature was considered for ES6, but was deferred to be considered after ES6 (aka "ES7" or "ES2016" or ...). Here's how it might work in that "beyond ES6" timeframe:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    o2 <span class="pl-k">=</span> { c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    o3 <span class="pl-k">=</span> { ...o1, ...o2, d<span class="pl-k">:</span> <span class="pl-c1">4</span> };

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o3.a, o3.b, o3.c, o3.d );
<span class="pl-c">// 1 2 3 4</span></pre></div>

<p>The <code>...</code> operator might also be used to gather an object's destructured properties back into an object:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span>, d<span class="pl-k">:</span> <span class="pl-c1">4</span> };
<span class="pl-k">var</span> { b, ...o2 } <span class="pl-k">=</span> o1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, o2.c, o2.d );       <span class="pl-c">// 2 3 4</span></pre></div>

<p>Here, the <code>...o2</code> re-gathers the destructured <code>c</code> and <code>d</code> properties back into an <code>o2</code> object (<code>o2</code> does not have a <code>b</code> property like <code>o1</code> does).</p>

<p>Again, these are just proposals under consideration beyond ES6. But it'll be cool if they do land.</p>

<h2><a id="user-content-arrayincludes" class="anchor" href="#arrayincludes" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array#includes(..)</code></h2>

<p>One extremely common task JS developers need to perform is searching for a value inside an array of values. The way this has always been done is:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (vals.<span class="pl-c1">indexOf</span>( <span class="pl-c1">42</span> ) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p>The reason for the <code>&gt;= 0</code> check is because <code>indexOf(..)</code> returns a numeric value of <code>0</code> or greater if found, or <code>-1</code> if not found. In other words, we're using an index-returning function in a boolean context. But because <code>-1</code> is truthy instead of falsy, we have to be more manual with our checks.</p>

<p>In the <em>Types &amp; Grammar</em> title of this series, I explored another pattern that I slightly prefer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (<span class="pl-k">~</span>vals.<span class="pl-c1">indexOf</span>( <span class="pl-c1">42</span> )) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p>The <code>~</code> operator here conforms the return value of <code>indexOf(..)</code> to a value range that is suitably boolean coercible. That is, <code>-1</code> produces <code>0</code> (falsy), and anything else produces a non-zero (truthy) value, which is what we for deciding if we found the value or not.</p>

<p>While I think that's an improvement, others strongly disagree. However, no one can argue that <code>indexOf(..)</code>'s searching logic is perfect. It fails to find <code>NaN</code> values in the array, for example.</p>

<p>So a proposal has surfaced and gained a lot of support for adding a real boolean-returning array search method, called <code>includes(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (vals.includes( <span class="pl-c1">42</span> )) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p><strong>Note:</strong> <code>Array#includes(..)</code> uses matching logic that will find <code>NaN</code> values, but will not distinguish between <code>-0</code> and <code>0</code> (see the <em>Types &amp; Grammar</em> title of this series). If you don't care about <code>-0</code> values in your programs, this will likely be exactly what you're hoping for. If you <em>do</em> care about <code>-0</code>, you'll need to do your own searching logic, likely using the <code>Object.is(..)</code> utility (see Chapter 6).</p>

<h2><a id="user-content-simd" class="anchor" href="#simd" aria-hidden="true"><span class="octicon octicon-link"></span></a>SIMD</h2>

<p>We cover Single Instruction, Multiple Data (SIMD) in more detail in the <em>Async &amp; Performance</em> title of this series, but it bears a brief mention here, as it's one of the next likely features to land in a future JS.</p>

<p>The SIMD API exposes various low-level (CPU) instructions that can operate on more than a single number value at a time. For example, you'll be able to specify two <em>vectors</em> of 4 or 8 numbers each, and multiply the respective elements all at once (data parallelism!).</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> v1 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">3.14159</span>, <span class="pl-c1">21.0</span>, <span class="pl-c1">32.3</span>, <span class="pl-c1">55.55</span> );
<span class="pl-k">var</span> v2 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">2.1</span>, <span class="pl-c1">3.2</span>, <span class="pl-c1">4.3</span>, <span class="pl-c1">5.4</span> );

<span class="pl-c1">SIMD</span>.float32x4.mul( v1, v2 );
<span class="pl-c">// [ 6.597339, 67.2, 138.89, 299.97 ]</span></pre></div>

<p>SIMD will include several other operations besides <code>mul(..)</code> (multiplication), such as <code>sub()</code>, <code>div()</code>, <code>abs()</code>, <code>neg()</code>, <code>sqrt()</code>, and many more.</p>

<p>Parallel math operations are critical for the next generations of high performance JS applications.</p>

<h2><a id="user-content-webassembly-wasm" class="anchor" href="#webassembly-wasm" aria-hidden="true"><span class="octicon octicon-link"></span></a>WebAssembly (WASM)</h2>

<p>Brendan Eich made a late breaking announcement near the completion of the first edition of this title that has the potential to significantly impact the future path of JavaScript: WebAssembly (WASM). We will not be able to cover WASM in detail here, as it's extremely early at the time of this writing. But this title would be incomplete without at least a brief mention of it.</p>

<p>One of the strongest pressures on the recent (and near future) design changes of the JS language has been the desire that it become a more suitable target for transpilation/cross-compilation from other languages (like C/C++, ClojureScript, etc.). Obviously, performance of code running as JavaScript has been a primary concern.</p>

<p>As discussed in the <em>Async &amp; Performance</em> title of this series, a few years ago a group of developers at Mozilla introduced an idea to JavaScript called ASM.js. ASM.js is a subset of valid JS that most signficantly restricts certain actions that make code hard for the JS engine to optimize. The result is that ASM.js compatible code running in an ASM-aware engine can run remarkably faster, nearly on par with native optimized C equivalents. Many viewed ASM.js as the most likely backbone on which performance-hungry applications would ride in JavaScript.</p>

<p>In other words, all roads to running code in the browser <em>lead through JavaScript</em>.</p>

<p>That is, until the WASM announcement. WASM provides an alternate path for other languages to target the browser's runtime environment without having to first pass through JavaScript. Essentially, if WASM takes off, JS engines will grow an extra capability to execute a binary format of code that can be seen as somewhat similar to a bytecode (like that which runs on the JVM).</p>

<p>WASM proposes a format for a binary representation of a highly compressed AST (syntax tree) of code, which can then give instructions directly to the JS engine and its underpinnings, without having to be parsed by JS, or even behave by the rules of JS. Languages like C or C++ can be compiled directly to the WASM format instead of ASM.js, and gain an extra speed advantage by skipping the JS parsing.</p>

<p>The near term for WASM is to have parity with ASM.js and indeed JS. But eventually, it's expected that WASM would grow new capabilities that surpass anything JS could do. For example, the pressure for JS to evolve radical features like threads -- a change that would certainly send major shockwaves through the JS ecosystem -- has a more hopeful future as a future WASM extension, relieving the pressure to change JS.</p>

<p>In fact, this new roadmap opens up many new roads for many languages to target the web runtime. That's an exciting new future path for the web platform!</p>

<p>What does it mean for JS? Will JS become irrelevant or "die"? Absolutely not. ASM.js will likely not see much of a future beyond the next couple of years, but the majority of JS is quite safely anchored in the web platform story.</p>

<p>Proponents of WASM suggest its success will mean that the design of JS will be protected from pressures that would have eventually stretched it beyond assumed breaking points of reasonability. It is projected that WASM will become the preferred target for high-performance parts of applications, as authored in any of a myriad of different languages.</p>

<p>Interestingly, JavaScript is one of the lesser likely languages to target WASM in the future. There may be future changes that carve out subsets of JS that might be tenable for such targeting, but that path doesn't seem high on the priority list.</p>

<p>While JS likely won't be much of a WASM funnel, JS code and WASM code will be able to interoperate in the most significant ways, just as naturally as current module interactions. You can imagine calling a JS function like <code>foo()</code> and having that actually invoke a WASM function of that name with the power to run well outside the constraints of the rest of your JS.</p>

<p>Things which are currently written in JS will probably continue to always be written in JS, at least for the foreseeable future. Things which are transpiled to JS will probably eventually at least consider targeting WASM instead. For things which need the utmost in performance with minimal tolerance for layers of abstraction, the likely choice will be to find a suitable non-JS language to author in, then targeting WASM.</p>

<p>There's a good chance this shift will be slow, and will be years in the making. WASM landing in all the major browser platforms is probably a few years out at best. In the meantime, the WASM project (<a href="https://github.com/WebAssembly">https://github.com/WebAssembly</a>) has an early polyfill to demonstrate proof-of-concept for its basic tenets.</p>

<p>But as time goes on, and as WASM learns new non-JS tricks, it's not too much a stretch of imagination to see some currently-JS things being refactored to a WASM-targetable language. For example, the performance sensitive parts of frameworks, game engines, and other heavily used tools might very well benefit from such a shift. Developers using these tools in their web applications likely won't notice much difference in usage or integration, but will just automatically take advantage of the performance and capabilities.</p>

<p>What's certain is that the more real WASM becomes over time, the more it means to the trajectory and design of JavaScript. It's perhaps one of the most important "beyond ES6" topics developers should keep an eye on.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>If all the other books in this series essentially propose this challenge, "you (may) not know JS (as much as you thought)," this book has instead suggested, "you don't know JS anymore." The book has covered a ton of new stuff added to the language in ES6. It's an exciting collection of new language features and paradigms that will forever improve our JS programs.</p>

<p>But JS is not done with ES6! Not even close. There's already quite a few features in various stages of development for the "beyond ES6" timeframe. In this chapter, we briefly looked at some of the most likely candidates to land in JS very soon.</p>

<p><code>async function</code>s are powerful syntactic sugar on top of the generators + promises pattern (see Chapter 4). <code>Object.observe(..)</code> adds direct native support for observing object change events, which is critical for implementing data binding. The <code>**</code> exponentiation operator, <code>...</code> for object properties, and <code>Array#includes(..)</code> are all simple but helpful improvements to existing mechanisms. Finally, SIMD ushers in a new era in the evolution of high performance JS.</p>

<p>Clich as it sounds, the future of JS is really bright! The challenge of this series, and indeed of this book, is incumbent on every reader now. What are you waiting for? It's time to get learning and exploring!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
	</body>
</html>