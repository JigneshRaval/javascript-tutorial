<html>
	<head>
		<title>ES6 Tutorials :: Part 1</title>
		<style>
			@font-face {
			font-family: 'pt_sansregular';
			src: url('fonts/PTS55F-webfont.eot');
			src: url('fonts/PTS55F-webfont.eot?#iefix') format('embedded-opentype'),
			url('fonts/PTS55F-webfont.woff') format('woff'),
			url('fonts/PTS55F-webfont.ttf') format('truetype'),
			url('fonts/PTS55F-webfont.svg#pt_sansregular') format('svg');
			font-weight: normal;
			font-style: normal;
			}
			body { font-family: 'pt_sansregular', Arial, Tahoma, Helvetica, FreeSans, sans-serif; line-height: 1.7; font-size: 14px; }
			pre {
			border: 1px dashed #888;
			padding: 15px;
			word-break: normal;
			word-break: break-all;
			word-wrap: break-word;
			font-size: 13px;
			line-height: 1.42857143;
			white-space: pre-wrap;       /* css-3 */
			white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
			white-space: -pre-wrap;      /* Opera 4-6 */
			white-space: -o-pre-wrap;    /* Opera 7 */
			word-wrap: break-word;       /* Internet Explorer 5.5+ */
			position: relative;
			}
			pre:after {
			content: "CODE";
			position: absolute;
			right: 0;
			top: 0;
			padding: 5px 10px;
			border-left: 1px dashed #888;
			border-bottom: 1px dashed #888;
			}
			h1{ border-top: 1px solid #666; border-bottom: 2px solid #888; padding: 10px 0; font-size: 20px; text-align: center; }
			h2, h3 { font-size: 16px; border-left: 6px solid #666; padding: 5px 15px; }
			code, kbd, pre, samp {
			font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
			}
			code {
			padding: 2px 4px;
			font-size: 90%;
			background-color: #f9f2f4;
			border-radius: 4px;
			}
			blockquote {
			letter-spacing: .01rem;
			font-weight: 400;
			font-style: italic;
			border-left: 3px solid rgba(0,0,0,0.8);
			padding-left: 20px;
			margin-left: -0;
			margin-bottom: 30px;
			padding-bottom: 3px;
			}
			@media print {
			img {
			display: block;
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			pre, code, pre code, pre span, code span, pre code span {
			page-break-inside: avoid;
			-webkit-column-break-inside : avoid;
			}
			}
		</style>
	</head>
	<body>
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<div class="read">

<h1>
Understanding ECMAScript 6
</h1>




</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<div class="read">

<h1>
ECMAScript 2015
</h1>
<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="#leanpub-auto-es6-guide">ES6-guide</a>
  </li>
  <li>
    <a href="#leanpub-auto-let--const">let + const</a>
    <ul>
      <li>
        <a href="#leanpub-auto-let">let</a>
      </li>
      <li>
        <a href="#leanpub-auto-const">const</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-arrow-functions">arrow functions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-syntactic-sugar">Syntactic sugar</a>
      </li>
      <li>
        <a href="#leanpub-auto-fixed-this--lexical-this">Fixed "this" = lexical "this"</a>
      </li>
      <li>
        <a href="#leanpub-auto-the-same-function">The same function</a>
      </li>
      <li>
        <a href="#leanpub-auto-limitations">Limitations</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-default--rest--spread">default + rest + spread</a>
    <ul>
      <li>
        <a href="#leanpub-auto-default">default</a>
      </li>
      <li>
        <a href="#leanpub-auto-rest">rest</a>
      </li>
      <li>
        <a href="#leanpub-auto-spread">spread</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-destructuring">destructuring</a>
    <ul>
      <li>
        <a href="#leanpub-auto-arrays">arrays</a>
      </li>
      <li>
        <a href="#leanpub-auto-objects">objects</a>
      </li>
      <li>
        <a href="#leanpub-auto-mixed">mixed</a>
      </li>
      <li>
        <a href="#leanpub-auto-attention">attention!</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-strings">strings</a>
    <ul>
      <li>
        <a href="#leanpub-auto-template-strings">template strings</a>
      </li>
      <li>
        <a href="#leanpub-auto-extended-support-for-unicode">extended support for Unicode</a>
      </li>
      <li>
        <a href="#leanpub-auto-strings-are-iterable">strings are iterable</a>
      </li>
      <li>
        <a href="#leanpub-auto-new-string-methods">new string methods</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-iterators">iterators</a>
    <ul>
      <li>
        <a href="#leanpub-auto-iterator--iterable">iterator &amp; iterable</a>
      </li>
      <li>
        <a href="#leanpub-auto-for-of-loop">for-of loop</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-generators">generators</a>
  </li>
  <li>
    <a href="#leanpub-auto-classes-and-inheritance">classes and inheritance</a>
    <ul>
      <li>
        <a href="#leanpub-auto-overviewan-example-of-es6-class-syntax-and-es5-equivalent">Overview&hairsp;&mdash;&hairsp;an example of ES6 class syntax and ES5 equivalent</a>
      </li>
      <li>
        <a href="#leanpub-auto-inheritance">inheritance</a>
      </li>
      <li>
        <a href="#leanpub-auto-static">static</a>
      </li>
      <li>
        <a href="#leanpub-auto-get--set">get / set</a>
      </li>
      <li>
        <a href="#leanpub-auto-enhanced-object-properties">Enhanced Object Properties</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-modules">modules</a>
    <ul>
      <li>
        <a href="#leanpub-auto-named-export">Named export</a>
      </li>
      <li>
        <a href="#leanpub-auto-default-export">Default export</a>
      </li>
      <li>
        <a href="#leanpub-auto-api">API</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-promises">promises</a>
    <ul>
      <li>
        <a href="#leanpub-auto-callbacks-and-callback-hell">Callbacks and callback hell</a>
      </li>
      <li>
        <a href="#leanpub-auto-promises-1">Promises</a>
      </li>
      <li>
        <a href="#leanpub-auto-pitfall">Pitfall</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-set-map-weak">set, map, weak</a>
    <ul>
      <li>
        <a href="#leanpub-auto-map">Map</a>
      </li>
      <li>
        <a href="#leanpub-auto-set">Set</a>
      </li>
      <li>
        <a href="#leanpub-auto-weakmap">WeakMap</a>
      </li>
      <li>
        <a href="#leanpub-auto-weakset">WeakSet</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main">
<h2 id="leanpub-auto-es6-guide">ES6-guide</h2>

<p><strong>ECMAScript 6 (ES6) guide</strong></p>

<div class="image-with-caption center image-with-caption center">
  <img alt="" src="/site_images/ecmascript2015es6guide/javascript.jpg"><p class="caption"></p>
</div>

<p><strong>CHECK SUMMARY TO SEE TABLE OF CONTENT</strong></p>

<p>I want to share with you some thoughts, snippets of code and tell you a little about the upcoming <strong>ES6</strong>. It's my own road to know it before it will be a standard.</p>

<p>You might have noticed about ES6 a lot lately. This is because the standard is targeting ratification in June 2015.</p>

<p>See draft - <a href="https://people.mozilla.org/~jorendorff/es6-draft.html">ECMAScript 2015</a></p>

<p>ECMAScript 2015 is a significant update to the language. Previous (ES5) was standardized in 2009. Frameworks like <strong>AngularJS</strong>, <strong>Aurelia</strong>, <strong>ReactJS</strong>, <strong>Ionic</strong> start using it today.</p>

<p>ES6 includes a lot of new features:</p>

<ul>
<li>arrows</li>
  <li>classes</li>
  <li>enhanced object literals</li>
  <li>template strings</li>
  <li>destructuring</li>
  <li>default + rest + spread</li>
  <li>let + const</li>
  <li>iterators + for..of</li>
  <li>generators</li>
  <li>unicode</li>
  <li>modules</li>
  <li>module loaders</li>
  <li>map + set + weakmap + weakset</li>
  <li>proxies</li>
  <li>symbols</li>
  <li>subclassable built-ins</li>
  <li>promises</li>
  <li>math + number + string + object APIs</li>
  <li>binary and octal literals</li>
  <li>reflect api</li>
  <li>tail calls</li>
</ul>
<p>I will try to describe each of these in the next stories, so stay updated.</p>

<p>Thanks to the use of transpilers (Babel, Traceur and others) we can actually use it right now until browsers fully catch up.</p>

<p><a href="https://kangax.github.io/compat-table/es6/">Browser support matrix</a></p>

<p>ES6 Repl in Chrome Devl Tools - <a href="https://chrome.google.com/webstore/detail/scratch-js/alploljligeomonipppgaahpkenfnfkn">Scratch JS</a></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">Future</code> <code class="nx">is</code> <code class="nx">bright</code><code class="p">.</code>
</pre></div>

</div>

<p>People from the community denounced these words. I have only one to add: we can handle it easily!</p>

<div class="image-with-caption center image-with-caption center">
  <img alt="" src="/site_images/ecmascript2015es6guide/future_is_bright.jpg"><p class="caption"></p>
</div>

<h2 id="leanpub-auto-let--const">let + const</h2>

<p>First topic about ECMAScript 2015 is <strong>let + const</strong>. If you are familiar with JavaScript, you have probably known the term: <strong>scope</strong>. If you are not that lucky, don't worry about it. I'll explain that in a few words below.</p>

<p>Why I mentioned something about JavaScript <strong>scope</strong>? This is because <strong>let</strong> and <strong>const</strong> have a very strong connection with that word. Firstly, imagine and old way (and still valid) to declare a new variable in your JS code using ES5:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES5</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="k">if</code> <code class="p">(</code><code class="mi">1</code> <code class="o">===</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">c</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">c</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="c1">// …</code>
<code class="lineno">11</code> <code class="p">}</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kd">function</code> <code class="nx">letsDeclareAnotherOne</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="kd">var</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// ReferenceError: d is not defined</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="c1">// window</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">25</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<ol class="numeric numeric">
<li>We can see that variable <strong>a</strong> is declared as global. Nothing surprising.</li>
  <li>Variable <strong>b</strong> is inside an <strong>if block</strong>, but in JavaScript it doesn't create a new scope. If you are familiar with other languages, you can be disappointed, but this is JavaScript and it works as you see.</li>
  <li>The next statement is a <strong>for loop</strong>. <strong>C</strong> variable is declared in this for loop, but also in the global scope.</li>
  <li>Until variable <strong>d</strong> is declared in his own scope. It's inside a function and only <strong>function creates new scopes</strong>.</li>
</ol>
<p><strong>Variables in JavaScript are hoisted to the top!</strong></p>

<p><strong>Hoisting</strong> is JavaScript's default behavior of moving all declarations to the top of the current scope (<strong>to the top of the current script</strong> or <strong>the current function</strong>).</p>

<p>In JavaScript, a variable can be declared after it has been used. In other words - a variable can be used before it has been declared!</p>

<p>One more rule, more aware: JavaScript only hoists declarations, not initialization.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// scope and variable hoisting</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">var</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
<code class="lineno"> 7</code>   <code class="kd">var</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 8</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="p">})();</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
</pre></div>

</div>

<p>Let's look for the new keywords in JavaScript ECMAScript 2015: <strong>let</strong> and <strong>const</strong>.</p>

<h3 id="leanpub-auto-let">let</h3>

<p>We can imagine that <strong>let</strong> is a new var statement. What is the difference? let is block scoped. Let's see an example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6 &mdash; let</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="k">if</code> <code class="p">(</code><code class="mi">1</code> <code class="o">===</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">c</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">c</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="c1">// …</code>
<code class="lineno">11</code> <code class="p">}</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kd">function</code> <code class="nx">letsDeclareAnotherOne</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// ReferenceError: b is not defined</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// ReferenceError: c is not defined</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// ReferenceError: d is not defined</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="c1">// window</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// undefined</code>
<code class="lineno">25</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// undefined</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">window</code><code class="p">.</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<p>As we can see, this time only variable <strong>a</strong> is declared as a global. <strong>let</strong> gives us a way to declare block scoped variables, which is undefined outside it.</p>

<p><strong>I use Chrome (stable version) with #enable-javascript-harmony flag enabled. Visit chrome://flags/#enable-javascript-harmony, enable this flag, restart Chrome and you will get many new features.</strong></p>

<p>You can also use <strong>BabelJS repl</strong> or <strong>Traceur repl</strong> and compare results.</p>

<h3 id="leanpub-auto-const">const</h3>

<p><strong>const</strong> is single-assignment and like a <strong>let</strong>, block-scoped declaration.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES6 const</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.141593</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14</code><code class="p">;</code> <code class="c1">// throws "PI" is read-only</code>
<code class="lineno">6</code> <code class="p">}</code>
<code class="lineno">7</code> 
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">PI</code><code class="p">);</code> <code class="c1">// throws ReferenceError: PI is not defined</code>
</pre></div>

</div>

<p>const cannot be reinitialized. It will throw an Error when we try to assign another value.</p>

<p>Let's look for the equivalent in ES5:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES5 const</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">PI</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="kd">var</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.141593</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">PI</code><code class="p">;</code> <code class="p">};</code>
<code class="lineno">6</code> <code class="p">})();</code>
</pre></div>

</div>

<h2 id="leanpub-auto-arrow-functions">arrow functions</h2>

<p>A new syntactic sugar which ES6 brings us soon, called <strong>arrow functions</strong> (also known as a fat arrow function). It's a shorter syntax compared to function expressions and lexically binds <strong>this</strong> value.</p>

<p>REMEMBER - <strong>Arrow functions are always anonymous.</strong></p>

<h3 id="leanpub-auto-syntactic-sugar">Syntactic sugar</h3>

<p>How does it look? It's a signature:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">([</code><code class="nx">param</code><code class="p">]</code> <code class="p">[,</code> <code class="nx">param</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>  <code class="nx">statements</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code>            <code class="nx">param</code> <code class="o">=&gt;</code> <code class="nx">expression</code>
<code class="lineno">6</code> <code class="p">(</code><code class="nx">param1</code><code class="p">,</code> <code class="nx">param2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">block</code> <code class="p">}</code>
</pre></div>

</div>

<p>..and it could be translated to:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code>     <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err">…</code> <code class="p">}</code>       <code class="c1">// no argument</code>
<code class="lineno">2</code>      <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err">…</code> <code class="p">}</code>       <code class="c1">// one argument</code>
<code class="lineno">3</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="err">…</code> <code class="p">}</code>       <code class="c1">// several arguments</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code> <code class="p">}</code> <code class="c1">// block</code>
<code class="lineno">6</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code>            <code class="c1">// expression, same as above</code>
</pre></div>

</div>

<p>Lambda expressions in JavaScript! Cool!</p>

<p>Instead of writing:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">});</code>
</pre></div>

</div>

<p>..you can write something like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>
</pre></div>

</div>

<p>Awesome. Isn't it? There is more!</p>

<h3 id="leanpub-auto-fixed-this--lexical-this">Fixed "this" = lexical "this"</h3>

<p><strong>The value of this inside of the function is determined by where the arrow function is defined not where it is used.</strong></p>

<p>No more <strong>bind</strong>, <strong>call</strong> and <strong>apply</strong>! No more:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
</pre></div>

</div>

<p>It solves a major pain point (from my point of view) and has the added bonus of improving performance through JavaScript engine optimizations.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES5</code>
<code class="lineno"> 2</code> <code class="kd">function</code> <code class="nx">FancyObject</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 3</code>  <code class="kd">var</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code>  <code class="nx">self</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'FancyObject'</code><code class="p">;</code>
<code class="lineno"> 6</code>  <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="nx">self</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'Hello World!'</code><code class="p">;</code>
<code class="lineno"> 8</code>  <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="c1">// ES6</code>
<code class="lineno">12</code> <code class="kd">function</code> <code class="nx">FancyObject</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'FancyObject'</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">15</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'Hello World!'</code><code class="p">;</code> <code class="c1">// properly refers to FancyObject</code>
<code class="lineno">16</code>   <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">17</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-the-same-function">The same function</h3>

<ul>
<li>
<strong>typeof</strong> returns <strong>function</strong>
</li>
  <li>
<strong>instanceof</strong> returns <strong>Function</strong>
</li>
</ul>
<h3 id="leanpub-auto-limitations">Limitations</h3>

<ul>
<li>It's cannot be used as a constructor and will throw an error when used with <strong>new</strong>.</li>
  <li>Fixed <strong>this</strong> means that you cannot change the <strong>value of this</strong> inside of the function. It remains the same value throughout the entire lifecycle of the function.</li>
  <li>Regular functions can be <strong>named</strong>.</li>
  <li>Functions declarations are <strong>hoisted</strong> (can be used before they are declared).</li>
</ul>
<h2 id="leanpub-auto-default--rest--spread">default + rest + spread</h2>

<p>ECMAScript 2015 functions made a significant progress, taking into account years of complaints. The result is a number of improvements that make programming in JavaScript <strong>less error-prone</strong> and <strong>more powerful</strong>.</p>

<p>Let's see three new features which give us <strong>extended parameter handling</strong>.</p>

<h3 id="leanpub-auto-default">default</h3>

<p>It's a simple, little addition that makes it much easier to handle function parameters. Functions in JavaScript allow any number of parameters to be passed regardless of the number of declared parameters in the function definition. You probably know <strong>commonly seen pattern</strong> in current JavaScript code:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// set default to 1 if increment not passed</code>
<code class="lineno">3</code>   <code class="c1">// (or passed as undefined)</code>
<code class="lineno">4</code>   <code class="nx">increment</code> <code class="o">=</code> <code class="nx">increment</code> <code class="o">||</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno">6</code> <code class="p">}</code>
<code class="lineno">7</code> 
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<p>The logical <strong>OR operator</strong> (||) always returns the second operand when the first is falsy.</p>

<p><strong>ES6</strong> gives us a way to set default function parameters. Any parameters with a default value are considered to be optional.</p>

<p>ES6 version of <strong>inc</strong> function looks like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<p>You can also set default values to parameters that appear <strong>before arguments</strong> without default values:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">10</code><code class="p">));</code>         <code class="c1">// 16 -&gt; b === 5</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">10</code><code class="p">));</code> <code class="c1">// 13 -&gt; b as default</code>
</pre></div>

</div>

<p>You can even execute a function to set default parameter. It's not restricted to <strong>primitive values</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">getDefaultIncrement</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code> <code class="p">}</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="kd">function</code> <code class="nx">inc</code><code class="p">(</code><code class="nx">number</code><code class="p">,</code> <code class="nx">increment</code> <code class="o">=</code> <code class="nx">getDefaultIncrement</code><code class="p">())</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="k">return</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">increment</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code> <code class="c1">// 4</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">inc</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>    <code class="c1">// 3</code>
</pre></div>

</div>

<h3 id="leanpub-auto-rest">rest</h3>

<p>Let's rewrite <strong>sum</strong> function to handle all arguments passed to it (without validation - just to be clear). If we want to use <strong>ES5</strong>, we probably also want to use <strong>arguments</strong> object.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>    <code class="kd">var</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">arguments</code><code class="p">),</code>
<code class="lineno"> 3</code>        <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 4</code>    <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 5</code>        <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno"> 6</code>    <code class="p">});</code>
<code class="lineno"> 7</code>    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">}</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>             <code class="c1">// 1</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code> <code class="c1">// 15</code>
</pre></div>

</div>

<p>But it's not obvious that the function is capable of handling any parameters. W have to scan body of the function and find <strong>arguments</strong> object.</p>

<p><strong>ECMAScript 6</strong> introduces <strong>rest</strong> parameters to help us with this and other pitfalls.</p>

<p><strong>arguments - contains all parameters including named parameters</strong></p>

<p>Rest parameters are indicated by three dots <strong>…</strong> preceding a parameter. Named parameter becomes an <strong>array</strong> which contain the rest of the parameters.</p>

<p><strong>sum</strong> function can be rewritten using ES6 syntax:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="err">…</code><code class="nx">numbers</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="p">});</code>
<code class="lineno"> 6</code>   <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 1</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code> <code class="c1">// 15</code>
</pre></div>

</div>

<p>Restriction: <strong>no other named arguments can follow in the function declaration.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="err">…</code><code class="nx">numbers</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// causes a syntax error</code>
<code class="lineno">2</code>   <code class="kd">var</code> <code class="nx">result</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">numbers</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>     <code class="nx">result</code> <code class="o">+=</code> <code class="nx">number</code><code class="p">;</code>
<code class="lineno">5</code>   <code class="p">});</code>
<code class="lineno">6</code>   <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="lineno">7</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-spread">spread</h3>

<p>The <strong>spread</strong> is closely related to rest parameters, because of <strong>…</strong> (three dots) notation. It allows to split an array to single arguments which are passed to the function as separate arguments.</p>

<p>Let's define our <strong>sum</strong> function an pass <strong>spread</strong> to it:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="err">…</code><code class="nx">args</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>ES5 equivalent is:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="nx">args</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>Instead using an <strong>apply</strong> function, we can just type <strong>…args</strong> and pass all array argument separately.</p>

<p>We can also mix standard arguments with spread operator:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">}</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="err">…</code><code class="nx">args</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code> <code class="c1">// 6</code>
</pre></div>

</div>

<p>The result is the same. First two arguments are from args array, and the last passed argument is 3.</p>

<h2 id="leanpub-auto-destructuring">destructuring</h2>

<p><strong>Destructuring</strong> is one more little addition to the upcoming JavaScript standard, which helps us write code more flexibly and effectively.</p>

<p>It allows binding using pattern matching. We can use it for matching arrays and objects. It's similar to standard object look up and returns <strong>undefined</strong> when value is not found.</p>

<h3 id="leanpub-auto-arrays">arrays</h3>

<p>Today it's common to see the code such as this.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES5</code>
<code class="lineno">2</code> <code class="kd">var</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">xVal</code> <code class="o">=</code> <code class="nx">point</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code>
<code class="lineno">4</code>     <code class="nx">yVal</code> <code class="o">=</code> <code class="nx">point</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>ES6 gives us destructuring of arrays into individual variables during assignment which is intuitive and flexible.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">xVal</code><code class="p">,</code> <code class="nx">yVal</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno"> 7</code> <code class="c1">// .. and reverse!</code>
<code class="lineno"> 8</code> <code class="p">[</code><code class="nx">xVal</code><code class="p">,</code> <code class="nx">yVal</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">yVal</code><code class="p">,</code> <code class="nx">xVal</code><code class="p">];</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">xVal</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">yVal</code><code class="p">);</code> <code class="c1">// 1</code>
</pre></div>

</div>

<p>We can even omit some values..</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">threeD</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="p">,</code> <code class="nx">c</code><code class="p">]</code> <code class="o">=</code> <code class="nx">threeD</code><code class="p">;</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
</pre></div>

</div>

<p>..and have nested array destructuring.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">nested</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="mi">4</code><code class="p">];</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="p">[</code><code class="nx">b</code><code class="p">],</code> <code class="nx">d</code><code class="p">]</code> <code class="o">=</code> <code class="nx">nested</code><code class="p">;</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</div>

<h3 id="leanpub-auto-objects">objects</h3>

<p>As well as the array syntax, ES6 also has the ability to destructure objects. It uses an object literal on the left side of an assignment operation. Object pattern is very similar to array pattern seen above. Let's see:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno">3</code>   <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code>
<code class="lineno">4</code> <code class="p">};</code>
<code class="lineno">5</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>It supports nested object as well as array pattern.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>   <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">z</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">one</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
<code class="lineno"> 6</code>     <code class="nx">two</code><code class="o">:</code> <code class="mi">4</code>
<code class="lineno"> 7</code>   <code class="p">}</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">d</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="c1">// 4</code>
</pre></div>

</div>

<h3 id="leanpub-auto-mixed">mixed</h3>

<p>We can also mix objects and arrays together and use theirs literals.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">mixed</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">one</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>   <code class="nx">two</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]</code>
<code class="lineno"> 5</code> <code class="p">};</code>
<code class="lineno"> 6</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="nx">c</code><code class="p">,</code> <code class="p">,</code> <code class="nx">e</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">mixed</code><code class="p">;</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code> <code class="c1">// 5</code>
</pre></div>

</div>

<p>But I think the most interesting is that we are able to use <strong>functions</strong> which return destructuring assignment.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">mixed</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="nx">one</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">two</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 5</code>     <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]</code>
<code class="lineno"> 6</code>   <code class="p">};</code>
<code class="lineno"> 7</code> <code class="p">}</code>
<code class="lineno"> 8</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">two</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="nx">c</code><code class="p">,</code> <code class="p">,</code> <code class="nx">e</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">mixed</code><code class="p">();</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code> <code class="c1">// 5</code>
</pre></div>

</div>

<p>The same result! It gives us a lot of possibilities to use it in our code.</p>

<h3 id="leanpub-auto-attention">attention!</h3>

<p><strong>If the value of a destructuring assignment isn't match, it evaluates to undefined.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> <code class="kd">let</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">b</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code> <code class="c1">// undefined</code>
</pre></div>

</div>

<p><strong>If we try to omit var, let or const, it will throw an error, because block code can't be destructuring assignment.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code> <code class="c1">// throws error</code>
</pre></div>

</div>

<p>We have to wrap it in parentheses. Just that ☺</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> <code class="p">({</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">a</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">point</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code> <code class="c1">// 1</code>
</pre></div>

</div>

<h2 id="leanpub-auto-strings">strings</h2>

<p>I gonna show you a couple of changes to <strong>strings</strong> in JavaScript, which will be available when ES6 comes. A syntactic sugar, which could be helpful in daily work.</p>

<h3 id="leanpub-auto-template-strings">template strings</h3>

<p>First, a <strong>string interpolation</strong>. Yep, template strings (finally) support string interpolation. ES6 brings us also support for <strong>multi-line</strong> syntax and <strong>raw literals</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">let</code> <code class="nx">sumTpl</code> <code class="o">=</code> <code class="err">`</code><code class="nx">$</code><code class="p">{</code><code class="nx">x</code><code class="p">}</code> <code class="o">+</code> <code class="nx">$</code><code class="p">{</code><code class="nx">y</code><code class="p">}</code> <code class="o">=</code> <code class="nx">$</code><code class="p">{</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">}</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sumTpl</code><code class="p">);</code> <code class="c1">// 1 + 2 = 3</code>
</pre></div>

</div>

<p>As you can see, we can inject values to string by using <strong>${value}</strong> syntax. Another thing to consider is <strong>grave accent</strong> - a char under the tilde (~) on a keyboard. A template literal string must be wrapped by it, to work properly.</p>

<p>The example above is an equivalent (in ES5) to simply (Babel version):</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">var</code> <code class="nx">sumTpl</code> <code class="o">=</code> <code class="s2">""</code> <code class="o">+</code> <code class="nx">x</code> <code class="o">+</code> <code class="s2">" + "</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="s2">" = "</code> <code class="o">+</code> <code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">);</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sumTpl</code><code class="p">);</code> <code class="c1">// 1 + 2 = 3</code>
</pre></div>

</div>

<p>This feature is very useful and almost removes the need for a template system.</p>

<p>Template strings provide also <strong>multi-line syntax</strong>, which is not legal in ES5 and earlier.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">types</code> <code class="o">=</code> <code class="err">`</code><code class="nb">Number</code>
<code class="lineno">2</code> <code class="nb">String</code>
<code class="lineno">3</code> <code class="nb">Array</code>
<code class="lineno">4</code> <code class="nb">Object</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">types</code><code class="p">);</code> <code class="c1">// Number</code>
<code class="lineno">6</code>                     <code class="c1">// String</code>
<code class="lineno">7</code>                     <code class="c1">// Array</code>
<code class="lineno">8</code>                     <code class="c1">// Object</code>
</pre></div>

</div>

<p>ES5 equivalent:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">types</code> <code class="o">=</code> <code class="s2">"Number\nString\nArray\nObject"</code><code class="p">;</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">types</code><code class="p">);</code> <code class="c1">// Number</code>
<code class="lineno">3</code>                     <code class="c1">// String</code>
<code class="lineno">4</code>                     <code class="c1">// Array</code>
<code class="lineno">5</code>                     <code class="c1">// Object</code>
</pre></div>

</div>

<p>The last thing is access the <strong>raw template string</strong> content where backslashes are not interpreted. We don't have equivalent in ES5 here.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">interpreted</code> <code class="o">=</code> <code class="s1">'raw\nstring'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">esaped</code> <code class="o">=</code> <code class="s1">'raw\\nstring'</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kd">let</code> <code class="nx">raw</code> <code class="o">=</code> <code class="nb">String</code><code class="p">.</code><code class="nx">raw</code><code class="err">`</code><code class="nx">raw</code><code class="err">\</code><code class="nx">nstring</code><code class="err">`</code><code class="p">;</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">interpreted</code><code class="p">);</code>    <code class="c1">// raw</code>
<code class="lineno">6</code>                              <code class="c1">// string</code>
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">raw</code> <code class="o">===</code> <code class="nx">esaped</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<h3 id="leanpub-auto-extended-support-for-unicode">extended support for Unicode</h3>

<p>ES6 gives us full support for <strong>Unicode</strong> within strings and regular expressions. It's non-breaking addition allows to building global apps.</p>

<p>Let's see an example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">'𠮷'</code><code class="p">;</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>             <code class="c1">// 2</code>
<code class="lineno">4</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code> <code class="o">===</code> <code class="s1">'\uD842\uDFB7'</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<p>You can see that character <strong>𠮷</strong>* represented by two 16-bit code units. It's a surrogate pair in which we have a single code point represented by two code units. The length of that string is also 2.</p>

<p><strong>Surrogate pairs are used in UTF-16 to represent code points above U+FFFF.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code> <code class="c1">// 55362</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 57271</code>
</pre></div>

</div>

<p>The <strong>charCodeAt()</strong> method returns the 16-bit number for each code unit.</p>

<p>ES6 allows encoding of strings in UTF-16. JavaScript can now support work with surrogate pairs. It gives us also a new method <strong>codePointAt()</strong> that returns Unicode code point instead of Unicode code unit.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code> <code class="c1">// 134071</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code> <code class="c1">// 57271</code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code> <code class="o">===</code> <code class="mh">0x20BB7</code><code class="p">);</code> <code class="c1">// true</code>
</pre></div>

</div>

<p>It works the same as <strong>charCodeAt()</strong> except for non-BMP characters.</p>

<p><strong>BMP - Basic Multilingual Plane - the first 2^16 code points.</strong></p>

<p><strong>codePointAt()</strong> returns full code point at the 0 <strong>position</strong>. codePointAt() and charCodeAt() return the same value for <strong>position 1</strong>.</p>

<p>We can also do a reverse operation with another new method added to ES6: <strong>fromCodePoint()</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code><code class="mi">134071</code><code class="p">));</code>  <code class="c1">// "𠮷"</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code><code class="mh">0x20BB7</code><code class="p">));</code> <code class="c1">// "𠮷"</code>
</pre></div>

</div>

<p><strong>Unicode code unit escape sequences consist of six characters, namely \u plus four hexadecimal digits, and contribute one code unit.</strong></p>

<p><strong>Unicode code point escape sequences consist of five to ten characters, namely
\u{ 1&ndash;6 hexadecimal digits }, and contribute one or two code units.</strong></p>

<p>Dealing with that two definitions, above example could be represented by one code point in <strong>ES6</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// ES6</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u{20BB7}'</code><code class="p">);</code> <code class="c1">// 𠮷</code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u{20BB7}'</code> <code class="o">===</code> <code class="s1">'\uD842\uDFB7'</code><code class="p">);</code> <code class="c1">// true</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="c1">// ES5</code>
<code class="lineno">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'\u20BB7); // 7!</code>
<code class="lineno">7</code> <code class="s1">console.log('</code><code class="err">\</code><code class="nx">u20BB7</code><code class="s1">' === '</code><code class="err">\</code><code class="nx">uD842</code><code class="err">\</code><code class="nx">uDFB7</code><code class="err">'</code><code class="p">);</code> <code class="c1">// false</code>
</pre></div>

</div>

<p>In ES5 we get an unexpected result when we try to match one single character using regular expression.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sr">/^.$/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">str</code><code class="p">));</code> <code class="c1">// false - length is 2</code>
</pre></div>

</div>

<p>ES6 allows us to use new RegExp <strong>u mode</strong> to handle code points. It is simply a new <strong>u</strong> flag (u == Unicode).</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">/^.$/u.test(str)); // true</code>
</pre></div>

</div>

<p>Adding u flag allows to correctly match the string by characters instead of code units.</p>

<h3 id="leanpub-auto-strings-are-iterable">strings are iterable</h3>

<p>Strings are iterable by using the <strong>for-of</strong> loop which I will cover in more detail in iterators article later. I write about it now because it enumerate Unicode code points and each may comprise one or two characters.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">'abc\uD842\uDFB7'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">str</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 5</code>
<code class="lineno">3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">c</code> <code class="nx">of</code> <code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code> <code class="c1">// a</code>
<code class="lineno">5</code>                   <code class="c1">// b</code>
<code class="lineno">6</code>                   <code class="c1">// c</code>
<code class="lineno">7</code>                   <code class="c1">// 𠮷</code>
<code class="lineno">8</code> <code class="p">}</code>
</pre></div>

</div>

<p>We can also use <strong>spread</strong> operator to transform string into an array with full Unicode support.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s1">'abc\uD842\uDFB7'</code><code class="p">;</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">chars</code> <code class="o">=</code> <code class="p">[</code><code class="err">…</code><code class="nx">str</code><code class="p">];</code>
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">chars</code><code class="p">);</code> <code class="c1">// ['a', 'b', 'c', '𠮷']</code>
</pre></div>

</div>

<h3 id="leanpub-auto-new-string-methods">new string methods</h3>

<p><strong>repeat(n)</strong> - string repeats by <strong>n</strong> times</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'abc|'</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code> <code class="c1">// 'abc|abc|abc|'</code>
</pre></div>

</div>

<p><strong>startsWith(str, starts = 0) : boolean</strong> - check if string starts with <strong>str</strong>, starting from <strong>starts</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">));</code>      <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'script'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<p><strong>endsWith(str, ends = str.length) : boolean</strong> - check if string ends with <strong>str</strong>, <strong>ends</strong> - where the string to be checked ends</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s1">'script'</code><code class="p">));</code>  <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<p><strong>includes(str, starts = 0) : boolean</strong> - check if string contain <strong>str</strong>, starting from <strong>starts</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s1">'ecma'</code><code class="p">));</code>      <code class="c1">// true</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ecmascript'</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s1">'script'</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c1">// true</code>
</pre></div>

</div>

<h2 id="leanpub-auto-iterators">iterators</h2>

<h3 id="leanpub-auto-iterator--iterable">iterator &amp; iterable</h3>

<p><strong>An iterator is an object with a next method that returns { done, value } tuples.</strong></p>

<p>ES6 gives us a pattern for creating custom iterators and it has a similar implementation to Java <strong>Iterable</strong> or .NET <strong>IEnumerable</strong>. It has also built-in <strong>iterables</strong>: <strong>String</strong>, <strong>Array</strong>, <strong>TypedArray</strong>, <strong>Map</strong> and <strong>Set</strong>. An iterator object can be any object with a next() method.</p>

<p><strong>Iterable is an object which has <a href="">Symbol.iterator</a> method inside.</strong></p>

<p><strong>Symbol is in turn an unique and immutable data type which can be used as an identifier for object properties&hairsp;&mdash;&hairsp;no equivalent in ES5.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// Symbol</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">s1</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'abc'</code><code class="p">);</code>
<code class="lineno"> 3</code> <code class="kd">let</code> <code class="nx">s2</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'abc'</code><code class="p">);</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">s1</code> <code class="o">!==</code> <code class="nx">s2</code><code class="p">);</code> <code class="c1">// true</code>
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">s1</code><code class="p">);</code> <code class="c1">// 'symbol'</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{};</code>
<code class="lineno"> 9</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">s1</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'abc'</code><code class="p">;</code>
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { Symbol(abc): 'abc' }</code>
</pre></div>

</div>

<p>Let's see a simple iterator written from scratch, which allows us to iterate through random numbers which are dynamically generated by <strong>next()</strong> method. A function returning iterable object take one argument (<strong>items</strong>) which is used to determine if the iterator should stop and returns <strong>done = true</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">random1_10</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">items</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="kd">let</code> <code class="nx">cur</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 5</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 6</code>         <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>           <code class="kd">let</code> <code class="nx">done</code> <code class="o">=</code> <code class="nx">cur</code> <code class="o">===</code> <code class="nx">items</code><code class="p">,</code>
<code class="lineno"> 8</code>               <code class="nx">random</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 9</code>           <code class="o">++</code><code class="nx">cur</code><code class="p">;</code>
<code class="lineno">10</code>           <code class="k">return</code> <code class="p">{</code>
<code class="lineno">11</code>             <code class="nx">done</code><code class="o">:</code> <code class="nx">done</code><code class="p">,</code>
<code class="lineno">12</code>             <code class="nx">value</code><code class="o">:</code> <code class="nx">random</code>
<code class="lineno">13</code>           <code class="p">}</code>
<code class="lineno">14</code>         <code class="p">}</code>
<code class="lineno">15</code>       <code class="p">}</code>
<code class="lineno">16</code>     <code class="p">}</code>
<code class="lineno">17</code>   <code class="p">};</code>
<code class="lineno">18</code> <code class="p">};</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="nx">of</code> <code class="nx">random1_10</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code> <code class="p">{</code>
<code class="lineno">21</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code> <code class="c1">// prints 5 random numbers</code>
<code class="lineno">22</code> <code class="p">}</code>
</pre></div>

</div>

<p>Every time <strong>for-of</strong> loop call <strong>next()</strong> method, an iterator generate a random number and returns it to the loop.</p>

<p><strong>If the iterator returns done = true, you can omit value, so the result will be { done: true }</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">random1_10</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">items</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="kd">let</code> <code class="nx">cur</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="lineno"> 5</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 6</code>         <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>           <code class="k">if</code> <code class="p">(</code><code class="nx">cur</code> <code class="o">===</code> <code class="nx">items</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>             <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 9</code>               <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code>
<code class="lineno">10</code>             <code class="p">}</code>
<code class="lineno">11</code>           <code class="p">}</code>
<code class="lineno">12</code>           <code class="o">++</code><code class="nx">cur</code><code class="p">;</code>
<code class="lineno">13</code>           <code class="k">return</code> <code class="p">{</code>
<code class="lineno">14</code>             <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
<code class="lineno">15</code>             <code class="nx">value</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code>
<code class="lineno">16</code>           <code class="p">}</code>
<code class="lineno">17</code>         <code class="p">}</code>
<code class="lineno">18</code>       <code class="p">}</code>
<code class="lineno">19</code>     <code class="p">}</code>
<code class="lineno">20</code>   <code class="p">};</code>
<code class="lineno">21</code> <code class="p">};</code>
<code class="lineno">22</code> 
<code class="lineno">23</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="nx">of</code> <code class="nx">random1_10</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code> <code class="p">{</code>
<code class="lineno">24</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code> <code class="c1">// prints 5 random numbers</code>
<code class="lineno">25</code> <code class="p">}</code>
</pre></div>

</div>

<h3 id="leanpub-auto-for-of-loop">for-of loop</h3>

<p>ES6 has a new loop&hairsp;&mdash;&hairsp;<strong>for-of</strong>. It works with iterables. Let's look at his signature:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">for</code> <code class="p">(</code><code class="nx">LET</code> <code class="nx">of</code> <code class="nx">ITERABLE</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="nx">CODE</code> <code class="nx">BLOCK</code>
<code class="lineno">3</code> <code class="p">}</code>
</pre></div>

</div>

<p>It's similar to <strong>for-in</strong> loop, which can be used to iterate through object properties (plain old Objects).</p>

<p><strong>Arrays</strong> in ES6 are iterable by default, so we finally can use <strong>for-of</strong> for looping over the elements.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">item</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">5</code>                      <code class="c1">// 2</code>
<code class="lineno">6</code>                      <code class="c1">// 3</code>
<code class="lineno">7</code>                      <code class="c1">// 4</code>
<code class="lineno">8</code>                      <code class="c1">// 5</code>
<code class="lineno">9</code> <code class="p">}</code>
</pre></div>

</div>

<p>Inside the for-of loop, we can even use a <strong>break</strong>, <strong>continue</strong> and <strong>return</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">item</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>   <code class="k">if</code> <code class="p">(</code><code class="nx">item</code> <code class="o">&gt;</code> <code class="mi">4</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="k">break</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code>   <code class="k">if</code> <code class="p">(</code><code class="mi">0</code> <code class="o">!==</code> <code class="nx">item</code> <code class="o">%</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="k">continue</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="p">}</code>
<code class="lineno">10</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code> <code class="c1">// 2</code>
<code class="lineno">11</code>                      <code class="c1">// 4</code>
<code class="lineno">12</code> <code class="p">}</code>
</pre></div>

</div>

<h2 id="leanpub-auto-generators">generators</h2>

<p><strong>Generators</strong> are simply subtypes of <strong>Iterators</strong> which I wrote about previously. They are a special kind of function that can be suspended and resumed, which is making a difference to iterators. Generators use <strong>function</strong>* and <strong>yield</strong> operators to work their magic.</p>

<p><strong>The yield operator returns a value from the function and when the generator is resumed, execution continues after the yield.</strong></p>

<p><strong>We also have to use function* (with star character) instead of a function to return a generator instance.</strong></p>

<p><strong>!!! Generators have been borrowed from Python language.</strong></p>

<p><strong>The most magical feature in ES6!</strong></p>

<p>Why? Take a look:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">generator</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="c1">// pause</code>
<code class="lineno"> 4</code>   <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="c1">// pause</code>
<code class="lineno"> 6</code>   <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
<code class="lineno"> 7</code>   <code class="c1">// pause</code>
<code class="lineno"> 8</code>   <code class="k">yield</code> <code class="s1">'done?'</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="c1">// done</code>
<code class="lineno">10</code> <code class="p">}</code>
<code class="lineno">11</code> <code class="kd">let</code> <code class="nx">gen</code> <code class="o">=</code> <code class="nx">generator</code><code class="p">();</code> <code class="c1">// [object Generator]</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 1, done: false}</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 2, done: false}</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 3, done: false}</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: 'done?', done: false}</code>
<code class="lineno">17</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: undefined, done: true}</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">gen</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code> <code class="c1">// Object {value: undefined, done: true}</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">val</code> <code class="nx">of</code> <code class="nx">generator</code><code class="p">())</code> <code class="p">{</code>
<code class="lineno">21</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">val</code><code class="p">);</code> <code class="c1">// 1</code>
<code class="lineno">22</code>                     <code class="c1">// 2</code>
<code class="lineno">23</code>                     <code class="c1">// 3</code>
<code class="lineno">24</code>                     <code class="c1">// 'done?'</code>
<code class="lineno">25</code> <code class="p">}</code>
</pre></div>

</div>

<p>As you can see, the generator has four <strong>yield</strong> statements. Each returns a value, pauses execution and moves to the next yield when <strong>next()</strong> method is called. Calling a function produces an object for controlling generator execution, a so-called <strong>generator object</strong>.</p>

<p>Use is similar to iterators. We have <strong>next()</strong> method as I mentioned above and we can even use it with <strong>for-of</strong> loop.</p>

<p>Below is an example of a generator called <strong>random1_10</strong>, which returns random numbers from 1 to 10.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random1_10</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="k">yield</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 4</code>   <code class="p">}</code>
<code class="lineno"> 5</code> <code class="p">}</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_10</code><code class="p">();</code>
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">10</code> <code class="c1">// …</code>
</pre></div>

</div>

<p>Generator has never ending <strong>while</strong> loop. It produces random numbers every time when you call <strong>next()</strong> method.</p>

<p>ES5 implementation:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">random1_10</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 3</code>     <code class="nx">next</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="k">return</code> <code class="p">{</code>
<code class="lineno"> 5</code>         <code class="nx">value</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 6</code>         <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code>
<code class="lineno"> 7</code>       <code class="p">};</code>
<code class="lineno"> 8</code>     <code class="p">}</code>
<code class="lineno"> 9</code>   <code class="p">};</code>
<code class="lineno">10</code> <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_10</code><code class="p">();</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">15</code> <code class="c1">// …</code>
</pre></div>

</div>

<p>We can also mix generators together:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random</code> <code class="p">(</code><code class="nx">max</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">yield</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">max</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 3</code> <code class="p">}</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">random1_20</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 6</code>   <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 7</code>     <code class="k">yield</code><code class="o">*</code> <code class="nx">random</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code>
<code class="lineno"> 8</code>   <code class="p">}</code>
<code class="lineno"> 9</code> <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="kd">let</code> <code class="nx">rand</code> <code class="o">=</code> <code class="nx">random1_20</code><code class="p">();</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">13</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>
<code class="lineno">14</code> <code class="c1">// …</code>
</pre></div>

</div>

<p><strong>random1_20</strong> generator returns random values from 1 to 20. It uses <strong>random</strong> generator inside to create random number each time when yield statement is reached.</p>

<h2 id="leanpub-auto-classes-and-inheritance">classes and inheritance</h2>

<p><strong>OO</strong> keywords is probably the most awaited features in ES6. <strong>Classes</strong> are something like another syntactic sugar over the prototype-based OO pattern. We now have one, concise way to make class patterns easier to use.</p>

<p><strong>Over the prototype-based OO pattern to ensure backwards compatibility.</strong></p>

<h3 id="leanpub-auto-overviewan-example-of-es6-class-syntax-and-es5-equivalent">Overview&hairsp;&mdash;&hairsp;an example of ES6 class syntax and ES5 equivalent</h3>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>It's naive example, but we can see a new keywords as class and constructor.</p>

<p>ES5 equivalent could be something like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">Vehicle</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getType</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">12</code> <code class="p">};</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="kd">var</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p><strong>Classes support prototype-based inheritance, super calls, instance and static methods and constructors.</strong></p>

<p>It's simple. We instantiate our classes the same way, but let's add some..</p>

<h3 id="leanpub-auto-inheritance">inheritance</h3>

<p>..to it and start from ES5 example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">function</code> <code class="nx">Vehicle</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 8</code> <code class="p">};</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getType</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">12</code> <code class="p">};</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="kd">function</code> <code class="nx">Car</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">15</code>   <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
<code class="lineno">19</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">=</code> <code class="nx">Car</code><code class="p">;</code>
<code class="lineno">20</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">parent</code> <code class="o">=</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>
<code class="lineno">21</code> <code class="nx">Car</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">22</code>   <code class="k">return</code> <code class="s1">'It is a car: '</code><code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">23</code> <code class="p">};</code>
<code class="lineno">24</code> 
<code class="lineno">25</code> <code class="kd">var</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">26</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// It is a car: Tesla</code>
<code class="lineno">27</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>And now look at the ES6 version:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="p">}</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="kr">class</code> <code class="nx">Car</code> <code class="kr">extends</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno">19</code> 
<code class="lineno">20</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">21</code>     <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">22</code>   <code class="p">}</code>
<code class="lineno">23</code> 
<code class="lineno">24</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">25</code>     <code class="k">return</code> <code class="s1">'It is a car: '</code> <code class="o">+</code> <code class="kr">super</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code>
<code class="lineno">26</code>   <code class="p">}</code>
<code class="lineno">27</code> 
<code class="lineno">28</code> <code class="p">}</code>
<code class="lineno">29</code> 
<code class="lineno">30</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">31</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// It is a car: Tesla</code>
<code class="lineno">32</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>We see how easy is to implement inheritance with ES6. It's finally looking like in other OO programming languages. We use <strong>extends</strong> to inherit from another class and the <strong>super</strong> keyword to call the parent class (function). Moreover, <strong>getName()</strong> method was overridden in subclass <strong>Car</strong>.</p>

<p><strong>super&hairsp;&mdash;&hairsp;previously to achieve such functionality in Javascript required the use of call or apply</strong></p>

<h3 id="leanpub-auto-static">static</h3>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Vehicle</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>     <code class="k">this</code><code class="p">.</code><code class="nx">type</code> <code class="o">=</code> <code class="nx">type</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code>   <code class="nx">getName</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> 
<code class="lineno">12</code>   <code class="nx">getType</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code>
<code class="lineno">14</code>   <code class="p">}</code>
<code class="lineno">15</code> 
<code class="lineno">16</code>   <code class="kr">static</code> <code class="nx">create</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">17</code>     <code class="k">return</code> <code class="k">new</code> <code class="nx">Vehicle</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">type</code><code class="p">);</code>
<code class="lineno">18</code>   <code class="p">}</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="p">}</code>
<code class="lineno">21</code> 
<code class="lineno">22</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="nx">Vehicle</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">,</code> <code class="s1">'car'</code><code class="p">);</code>
<code class="lineno">23</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getName</code><code class="p">());</code> <code class="c1">// Tesla</code>
<code class="lineno">24</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">getType</code><code class="p">());</code> <code class="c1">// car</code>
</pre></div>

</div>

<p>Classes give us an opportunity to create static members. We don't have to use the <strong>new</strong> keyword later to instantiate a class.</p>

<p>static methods (properties) are also inherited
and could be called by super</p>

<h3 id="leanpub-auto-get--set">get / set</h3>

<p>Other great things in upcoming ES6 are <strong>getters</strong> and <strong>setters</strong> for object properties. They allow us to run the code on the reading or writing of a property.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">class</code> <code class="nx">Car</code> <code class="p">{</code>
<code class="lineno"> 2</code> 
<code class="lineno"> 3</code>   <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 4</code>     <code class="k">this</code><code class="p">.</code><code class="nx">_name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 5</code>   <code class="p">}</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code>   <code class="nx">set</code> <code class="nx">name</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="k">this</code><code class="p">.</code><code class="nx">_name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 9</code>   <code class="p">}</code>
<code class="lineno">10</code> 
<code class="lineno">11</code>   <code class="nx">get</code> <code class="nx">name</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">12</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_name</code><code class="p">;</code>
<code class="lineno">13</code>   <code class="p">}</code>
<code class="lineno">14</code> 
<code class="lineno">15</code> <code class="p">}</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="kd">let</code> <code class="nx">car</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Car</code><code class="p">(</code><code class="s1">'Tesla'</code><code class="p">);</code>
<code class="lineno">18</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Tesla</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">car</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s1">'BMW'</code><code class="p">;</code>
<code class="lineno">21</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">car</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// BMW</code>
</pre></div>

</div>

<p>I use ‘_' prefix to create a (<strong>tmp</strong>) field to store name property.</p>

<h3 id="leanpub-auto-enhanced-object-properties">Enhanced Object Properties</h3>

<p>The last thing I have to mention is <strong>property shorthand</strong>, <strong>computed property names</strong> and <strong>method properties</strong>.</p>

<p>ES6 gives us shorter syntax for common <strong>object property</strong> definition:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { x: 1, y: 2 }</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="c1">// ES5</code>
<code class="lineno"> 9</code> <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="lineno">10</code>     <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="lineno">11</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">12</code>       <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code>
<code class="lineno">13</code>       <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code>
<code class="lineno">14</code>     <code class="p">};</code>
<code class="lineno">15</code> 
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { x: 1, y: 2 }</code>
</pre></div>

</div>

<p>As you can see, this works because the property value has the same name as the property identifier.</p>

<p>Another thing is ES6 support for <strong>computed names</strong> in object property definitions:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">getKey</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'123'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">foo</code><code class="o">:</code> <code class="s1">'bar'</code><code class="p">,</code>
<code class="lineno"> 5</code>       <code class="p">[</code><code class="s1">'key_'</code> <code class="o">+</code> <code class="nx">getKey</code><code class="p">()]</code><code class="o">:</code> <code class="mi">123</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { foo: 'bar', key_123: 123 }</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="c1">// ES5</code>
<code class="lineno">11</code> <code class="kd">var</code> <code class="nx">getKey</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">12</code>       <code class="k">return</code> <code class="s1">'123'</code><code class="p">;</code>
<code class="lineno">13</code>     <code class="p">},</code>
<code class="lineno">14</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">15</code>       <code class="nx">foo</code><code class="o">:</code> <code class="s1">'bar'</code>
<code class="lineno">16</code>     <code class="p">};</code>
<code class="lineno">17</code> <code class="nx">obj</code><code class="p">[</code><code class="s1">'key_'</code> <code class="o">+</code> <code class="nx">getKey</code><code class="p">()]</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="lineno">18</code> 
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code> <code class="c1">// Object { foo: 'bar', key_123: 123 }</code>
</pre></div>

</div>

<p>The one last thing is <strong>method properties</strong> seen in classes above. We can even use it in object definitions:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// ES6</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="nx">name</code><code class="o">:</code> <code class="s1">'object name'</code><code class="p">,</code>
<code class="lineno"> 4</code>   <code class="nx">toString</code> <code class="p">()</code> <code class="p">{</code> <code class="c1">// 'function' keyword is omitted here</code>
<code class="lineno"> 5</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno"> 6</code>   <code class="p">}</code>
<code class="lineno"> 7</code> <code class="p">};</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// object name</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="c1">// ES5</code>
<code class="lineno">13</code> <code class="kd">var</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno">14</code>   <code class="nx">name</code><code class="o">:</code> <code class="s1">'object name'</code><code class="p">,</code>
<code class="lineno">15</code>   <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno">16</code>     <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
<code class="lineno">17</code>   <code class="p">}</code>
<code class="lineno">18</code> <code class="p">};</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// object name</code>
</pre></div>

</div>

<h2 id="leanpub-auto-modules">modules</h2>

<p>Today we have a couple of ways to create <strong>modules</strong>, export &amp; import them. JavaScript doesn't have any built-in module loader yet. Upcoming ECMAScript 2015 standard gives us a reason to make people happy. Finally ;)</p>

<p>We have third party standards: <strong>CommonJS</strong> and <strong>AMD</strong>. The most popular, but, unfortunately, incompatible standards for module loaders.</p>

<p><strong>CommonJS is known from <a href="https://nodejs.org/">Node.js</a>. It's mostly dedicated for servers and it supports synchronous loading. It also has a compact syntax focused on export and require keywords.</strong></p>

<p><strong>AMD and the most popular implementation - <a href="http://requirejs.org/">RequireJS</a> are dedicated for browsers. AMD supports asynchronous loading, but has more complicated syntax than CommonJS.</strong></p>

<p>The goal for ES6 is (was) to mix these two standards and make both user groups happy.</p>

<p>ES6 gives us an easy syntax and support for asynchronous and configurable module loading.</p>

<p><strong>Async model</strong>&hairsp;&mdash;&hairsp;no code executes until requested modules are available and processed.</p>

<h3 id="leanpub-auto-named-export">Named export</h3>

<p>Modules can export multiple objects, which could be simple variables or functions.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">export</code> <code class="kd">function</code> <code class="nx">multiply</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can also export a function stored in a variable, but we have to wrap the variable in a set of curly braces.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">var</code> <code class="nx">multiply</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kr">export</code> <code class="p">{</code> <code class="nx">multiply</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can even export many objects and like in the above example&hairsp;&mdash;&hairsp;we have to wrap exported statements in a set of curly braces if we use one export keyword.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kr">export</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">;</code>
<code class="lineno"> 2</code> <code class="kr">export</code> <code class="kd">function</code> <code class="nx">multiply</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno"> 4</code> <code class="p">};</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="c1">// === OR ===</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="kd">var</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">,</code>
<code class="lineno"> 9</code>     <code class="nx">multiply</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">10</code>       <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">11</code>     <code class="p">};</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="kr">export</code> <code class="p">{</code> <code class="nx">hello</code><code class="p">,</code> <code class="nx">multiply</code> <code class="p">};</code>
</pre></div>

</div>

<p>Let's just imagine that we have <strong>modules.js</strong> file with all exported statements. To import them in another file (<strong>in the same directory</strong>) we use … <strong>import { .. } from</strong> .. syntax:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">hello</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p><strong>We can omit .js extension just like in CommonJS and AMD.</strong></p>

<p>We can even import many statements:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">hello</code><code class="p">,</code> <code class="nx">multiply</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p>Imports may also be <strong>aliased</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="p">{</code> <code class="nx">multiply</code> <code class="nx">as</code> <code class="nx">pow2</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p>..and use <strong>wildcard</strong> (*) to import all exported statemets:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="o">*</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<h3 id="leanpub-auto-default-export">Default export</h3>

<p>In our module, we can have many named exports, but we can also have a <strong>default export</strong>. It's because our module could be a large library and with default export we can import then an entire module. It could be also useful when our module has single value or model (class / constructor).</p>

<p><strong>One default export per module.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">3</code> <code class="p">};</code>
</pre></div>

</div>

<p>This time we don't have to use curly braces for importing and we have a chance to name imported statement as we wish.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kr">import</code> <code class="nx">multiply</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="c1">// === OR ===</code>
<code class="lineno">4</code> 
<code class="lineno">5</code> <code class="kr">import</code> <code class="nx">pow2</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="c1">// === OR ===</code>
<code class="lineno">8</code> 
<code class="lineno">9</code> <code class="p">...</code>
</pre></div>

</div>

<p><strong>Module can have both named exports and a default export.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// modules.js</code>
<code class="lineno">2</code> <code class="kr">export</code> <code class="nx">hello</code> <code class="o">=</code> <code class="s1">'Hello World'</code><code class="p">;</code>
<code class="lineno">3</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">4</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">5</code> <code class="p">};</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="c1">// app.js</code>
<code class="lineno">8</code> <code class="kr">import</code> <code class="nx">pow2</code><code class="p">,</code> <code class="p">{</code> <code class="nx">hello</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<p><strong>The default export is just a named export with the special name default.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// modules.js</code>
<code class="lineno">2</code> <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">3</code>   <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>
<code class="lineno">4</code> <code class="p">};</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="c1">// app.js</code>
<code class="lineno">7</code> <code class="kr">import</code> <code class="p">{</code> <code class="k">default</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'modules'</code><code class="p">;</code>
</pre></div>

</div>

<h3 id="leanpub-auto-api">API</h3>

<p>In addition, there is also a programmatic API and it allows to:</p>

<ul>
<li>Programmatically work with modules and scripts</li>
  <li>Configure module loading</li>
</ul>
<p><strong><a href="https://github.com/systemjs/systemjs">SystemJS</a>&hairsp;&mdash;&hairsp;universal dynamic module loader&hairsp;&mdash;&hairsp;loads ES6 modules, AMD, CommonJS and global scripts in the browser and NodeJS. Works with both Traceur and Babel.</strong></p>

<p>Module loader should support:
* Dynamic loading</p>

<ul>
<li>Global namespace isolation</li>
  <li>Nested virtualization</li>
  <li>Compilation hooks</li>
</ul>
<h2 id="leanpub-auto-promises">promises</h2>

<p>Promises aren't a new and shiny idea. I use it every day in my AngularJS code. It's based on <a href="https://github.com/kriskowal/q">kriskowal / q</a> library:</p>

<p><strong>A tool for creating and composing asynchronous promises in JavaScript.</strong></p>

<p>It's a library for asynchronous programming, to make our life easier. But, before I describe promises, I have to write something about callbacks.</p>

<h3 id="leanpub-auto-callbacks-and-callback-hell">Callbacks and callback hell</h3>

<p>Until I remember, JavaScript coders use callbacks for all browser-based asynchronous functions (setTimeout, XMLHttpRequest, etc.).</p>

<p>Look at naive example:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'start!'</code><code class="p">);</code>
<code class="lineno"> 2</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 3</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'ping'</code><code class="p">);</code>
<code class="lineno"> 4</code>   <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'pong'</code><code class="p">);</code>
<code class="lineno"> 6</code>     <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
<code class="lineno"> 7</code>       <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'end!'</code><code class="p">);</code>
<code class="lineno"> 8</code>     <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno"> 9</code>   <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">10</code> <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="c1">// start!</code>
<code class="lineno">13</code> <code class="c1">// after 1 sec: ping</code>
<code class="lineno">14</code> <code class="c1">// .. 1 sec later: pong</code>
<code class="lineno">15</code> <code class="c1">// .. and: end!</code>
</pre></div>

</div>

<p>We have simple code which prints some statements to the console. I used a <strong>setTimeout</strong> function here, to show callback functions passed to invoke later (1 sec here). It looks terrible and we have only 3 steps here. Let's imagine more steps. It will look like you build a pyramid, not nice, readable code. Awful, right? It's called <strong>callback hell</strong> and we have it everywhere.</p>

<p><a href="http://callbackhell.com/">Callback Hell</a></p>

<h3 id="leanpub-auto-promises-1">Promises</h3>

<p>Support for promises is a very nice addition to the language. It's finally native in the ES6.</p>

<p><strong>Promises are a first class representation of a value that may be made available in the future.</strong></p>

<p>A promise can be:</p>

<ul>
<li>
<strong>fulfilled</strong> - promise succeeded</li>
  <li>
<strong>rejected</strong> - promise failed</li>
  <li>
<strong>pending</strong> - not fulfilled or not rejected yet</li>
  <li>
<strong>settled</strong> - fulfilled or rejected</li>
</ul>
<p>Every returned <strong>promise object</strong> also has a <strong>then</strong> method to execute code when a promise is <strong>settled</strong>.</p>

<p>Yep, promise <strong>object</strong>, because..</p>

<p><strong>callbacks are functions, promises are objects.</strong></p>

<p>Callbacks are blocks of code to execute in response to.. something (event). Promises are objects which store an information about the state.</p>

<p>How does it look like? Let's see:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno">3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno">7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>Promise calls its <strong>resolve function</strong> when it's fulfilled (success) and <strong>reject function</strong> otherwise (failure).</p>

<p>Promises are objects, so it's not passed as arguments like callbacks, it's <strong>returned</strong>. The return statement is an object which is a placeholder for the result, which will be available in the future.</p>

<p>Promises have just one responsibility-<strong>they represent only one</strong> event. Callbacks can handle multiple events, many times.</p>

<p>We can assign returned value (object) to the <strong>let statement</strong>:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno">3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">5</code> 
<code class="lineno">6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno">7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>As I mentioned above-promise object also has a <strong>then</strong> method to execute code when the promise is settled.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">onResolve</code><code class="p">,</code> <code class="nx">onReject</code><code class="p">)</code>
</pre></div>

</div>

<p>We can use this function to handle <strong>onResolve</strong> and <strong>onReject</strong> values returned by a promise. We can handle <strong>success</strong>, <strong>failure</strong> or <strong>both</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="c1">// when success, resolve</code>
<code class="lineno"> 3</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno"> 4</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code>   <code class="c1">// when an error occurred, reject</code>
<code class="lineno"> 7</code>   <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Something happened!'</code><code class="p">));</code>
<code class="lineno"> 8</code> <code class="p">});</code>
<code class="lineno"> 9</code> 
<code class="lineno">10</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">11</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
<code class="lineno">12</code> <code class="p">},</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
<code class="lineno">14</code> <code class="p">});</code>
<code class="lineno">15</code> <code class="c1">// success</code>
</pre></div>

</div>

<p>Our code above never executes <strong>reject</strong> function, so we can omit it for simplicity:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">4</code> <code class="p">});</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// success</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>Handlers passed to <strong>promise.then</strong> don't just handle the result of the previous promise-they return is turned into a <strong>new promise</strong>.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="s1">'success'</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno"> 4</code> <code class="p">});</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// success</code>
<code class="lineno"> 8</code>   <code class="k">return</code> <code class="s1">'another success'</code><code class="p">;</code>
<code class="lineno"> 9</code> <code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">10</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code> <code class="c1">// another success</code>
<code class="lineno">11</code> <code class="p">});</code>
</pre></div>

</div>

<p>You can see, that the code based on promises is always <em>flat</em>. No more <strong>callback hell</strong>.</p>

<p>If you are only interested in rejections, you can omit the first parameter.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="kd">let</code> <code class="nx">reason</code> <code class="o">=</code> <code class="s1">'failure'</code><code class="p">;</code>
<code class="lineno"> 3</code>   <code class="nx">reject</code><code class="p">(</code><code class="nx">reason</code><code class="p">);</code>
<code class="lineno"> 4</code> <code class="p">});</code>
<code class="lineno"> 5</code> 
<code class="lineno"> 6</code> <code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code>
<code class="lineno"> 7</code>   <code class="kc">null</code><code class="p">,</code>
<code class="lineno"> 8</code>   <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 9</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">10</code>   <code class="p">}</code>
<code class="lineno">11</code> <code class="p">);</code>
</pre></div>

</div>

<p>But is a more compact way of doing the same thing-<strong>catch()</strong> method.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">2</code>   <code class="kd">let</code> <code class="nx">reason</code> <code class="o">=</code> <code class="s1">'failure'</code><code class="p">;</code>
<code class="lineno">3</code>   <code class="nx">reject</code><code class="p">(</code><code class="nx">reason</code><code class="p">);</code>
<code class="lineno">4</code> <code class="p">});</code>
<code class="lineno">5</code> 
<code class="lineno">6</code> <code class="nx">promise</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">7</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">8</code> <code class="p">});</code>
</pre></div>

</div>

<p>If we have more than one <strong>then()</strong> call, the error is passed on until there is an error handler.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>   <code class="nx">resolve</code><code class="p">();</code>
<code class="lineno"> 3</code> <code class="p">});</code>
<code class="lineno"> 4</code> 
<code class="lineno"> 5</code> <code class="nx">promise</code>
<code class="lineno"> 6</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 7</code>     <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
<code class="lineno"> 8</code>   <code class="p">})</code>
<code class="lineno"> 9</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">10</code>     <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'failure'</code><code class="p">);</code>
<code class="lineno">11</code>   <code class="p">})</code>
<code class="lineno">12</code>   <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">13</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code> <code class="c1">// failure</code>
<code class="lineno">14</code>   <code class="p">});</code>
</pre></div>

</div>

<p>We can even combine <strong>one or more promises</strong> into new promises without having to take care of ordering of the underlying asynchronous operations yourself.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">doSmth</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 2</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'doSmth'</code><code class="p">);</code>
<code class="lineno"> 3</code>   <code class="p">}),</code>
<code class="lineno"> 4</code>   <code class="nx">doSmthElse</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 5</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'doSmthElse'</code><code class="p">);</code>
<code class="lineno"> 6</code>   <code class="p">}),</code>
<code class="lineno"> 7</code>   <code class="nx">oneMore</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno"> 8</code>     <code class="nx">resolve</code><code class="p">(</code><code class="s1">'oneMore'</code><code class="p">);</code>
<code class="lineno"> 9</code>   <code class="p">});</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
<code class="lineno">12</code>     <code class="nx">doSmth</code><code class="p">,</code>
<code class="lineno">13</code>     <code class="nx">doSmthElse</code><code class="p">,</code>
<code class="lineno">14</code>     <code class="nx">oneMore</code>
<code class="lineno">15</code>   <code class="p">])</code>
<code class="lineno">16</code>   <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="lineno">17</code>     <code class="kd">let</code> <code class="p">[</code><code class="nx">one</code><code class="p">,</code> <code class="nx">two</code><code class="p">,</code> <code class="nx">three</code><code class="p">]</code> <code class="o">=</code> <code class="nx">response</code><code class="p">;</code>
<code class="lineno">18</code>     <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">one</code><code class="p">,</code> <code class="nx">two</code><code class="p">,</code> <code class="nx">three</code><code class="p">);</code> <code class="c1">// doSmth doSmthElse oneMore</code>
<code class="lineno">19</code>   <code class="p">});</code>
</pre></div>

</div>

<p><strong>Promise.all()</strong> takes an array of promises and when all of them are fulfilled, it put their values into the array.</p>

<p>There are two more functions which are useful:</p>

<ul>
<li>
<strong>Promise.resolve(value)</strong> - it returns a promise which resolves to a <strong>value</strong> or returns <strong>value</strong> if <strong>value</strong> is already a promise</li>
  <li>
<strong>Promise.reject(value)</strong> - returns rejected promise with <strong>value</strong> as <strong>value</strong>
</li>
</ul>
<h3 id="leanpub-auto-pitfall">Pitfall</h3>

<p>Promises have its pitfall as well. Let's image that when any exception is thrown within a <strong>then</strong> or the function passed to <strong>new Promise</strong>, will be silently disposed of <strong>unless manually handled</strong>.</p>

<h2 id="leanpub-auto-set-map-weak">set, map, weak</h2>

<p>Sets and maps will be (are) finally available in ES6! No more spartan way to manipulate data structures. This chapter explains how we can deal with <strong>Map</strong>, <strong>Set</strong>, <strong>WeakMap</strong> and <strong>WeakSet</strong>.</p>

<h3 id="leanpub-auto-map">Map</h3>

<p>Maps are a store for <strong>key</strong> / <strong>value</strong> pairs. Key and value could be a primitives or object references.</p>

<p>Let's create a map:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code> <code class="c1">// Map {0 =&gt; 'val1', '1' =&gt; 'val2', Object {key: 2} =&gt; Object \</code>
<code class="lineno">12</code> <code class="p">{</code><code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code><code class="p">}}</code>
</pre></div>

</div>

<p>We can also use a constructor to create the sam map, based on array param passed to the constructor:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code><code class="p">,</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">],</code> <code class="p">[</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">],</code> <code class="p">[{</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">]]);</code>
<code class="lineno"> 8</code> 
<code class="lineno"> 9</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code> <code class="c1">// Map {0 =&gt; 'val1', '1' =&gt; 'val2', Object {key: 2} =&gt; Object \</code>
<code class="lineno">10</code> <code class="p">{</code><code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code><code class="p">}}</code>
</pre></div>

</div>

<p>To get a value by using a key, we have to use a <strong>get()</strong> method to do it (surprising):</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'1'</code><code class="p">));</code> <code class="c1">// val2</code>
</pre></div>

</div>

<p>To iterate over the map collection, we can use built-in <strong>forEach</strong> method or use new <strong>for..of</strong> structure:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// forEach</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 3</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 5</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno">10</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="nx">map</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Key</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">key</code><code class="p">}</code> <code class="nx">has</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">value</code><code class="p">}</code><code class="err">`</code><code class="p">);</code>
<code class="lineno">14</code>   <code class="c1">// Key: 0 has value: val1</code>
<code class="lineno">15</code>   <code class="c1">// Key: 1 has value: val2</code>
<code class="lineno">16</code>   <code class="c1">// Key: [object Object] has value: [object Object]</code>
<code class="lineno">17</code> <code class="p">});</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="c1">// for..of</code>
<code class="lineno"> 2</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 3</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 4</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 5</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 6</code>     <code class="p">};</code>
<code class="lineno"> 7</code> 
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno">10</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">11</code> 
<code class="lineno">12</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="nx">of</code> <code class="nx">map</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">13</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">`</code><code class="nx">Key</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">entry</code><code class="p">[</code><code class="mi">0</code><code class="p">]}</code> <code class="nx">has</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">$</code><code class="p">{</code><code class="nx">entry</code><code class="p">[</code><code class="mi">1</code><code class="p">]}</code><code class="err">`</code><code class="p">);</code>
<code class="lineno">14</code>   <code class="c1">// Key: 0 has value: val1</code>
<code class="lineno">15</code>   <code class="c1">// Key: 1 has value: val2</code>
<code class="lineno">16</code>   <code class="c1">// Key: [object Object] has value: [object Object]</code>
<code class="lineno">17</code> <code class="p">};</code>
</pre></div>

</div>

<p>We can also use a couple of methods to iterate:</p>

<ul>
<li>
<strong>entries()</strong>&hairsp;&mdash;&hairsp;get all entries</li>
  <li>
<strong>keys()</strong>&hairsp;&mdash;&hairsp;get only all keys</li>
  <li>
<strong>values()</strong>&hairsp;&mdash;&hairsp;get only all values</li>
</ul>
<p>To check if value is stored in our map, we can use <strong>has()</strong> method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="mi">0</code><code class="p">));</code>     <code class="c1">// true</code>
<code class="lineno">12</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="s1">'key'</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>

<p>To delete entry, we have <strong>delete()</strong> method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>     <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>       <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>     <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code> <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">12</code> 
<code class="lineno">13</code> <code class="nx">map</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="s1">'1'</code><code class="p">);</code>
<code class="lineno">14</code> 
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 2</code>
</pre></div>

</div>

<p>..and to clear all collection, we use clear() method:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code>  <code class="kd">let</code> <code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">(),</code>
<code class="lineno"> 2</code>      <code class="nx">val2</code> <code class="o">=</code> <code class="s1">'val2'</code><code class="p">,</code>
<code class="lineno"> 3</code>      <code class="nx">val3</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 4</code>        <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code>
<code class="lineno"> 5</code>      <code class="p">};</code>
<code class="lineno"> 6</code> 
<code class="lineno"> 7</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno"> 8</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'1'</code><code class="p">,</code> <code class="nx">val2</code><code class="p">);</code>
<code class="lineno"> 9</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="nx">val3</code><code class="p">);</code>
<code class="lineno">10</code> 
<code class="lineno">11</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 3</code>
<code class="lineno">12</code> 
<code class="lineno">13</code>  <code class="nx">map</code><code class="p">.</code><code class="nx">clear</code><code class="p">();</code>
<code class="lineno">14</code> 
<code class="lineno">15</code>  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 0</code>
</pre></div>

</div>

<h3 id="leanpub-auto-set">Set</h3>

<p>It's a collection for <em>unique</em> values. The values could be also a primitives or object references.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">();</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="lineno">4</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s1">'1'</code><code class="p">);</code>
<code class="lineno">5</code> <code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">({</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">});</code>
<code class="lineno">6</code> 
<code class="lineno">7</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">);</code> <code class="c1">// Set {1, '1', Object {key: 'value'}}</code>
</pre></div>

</div>

<p>Like a map, set allows to create collection by passing an array to its constructor:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">);</code> <code class="c1">// Set {1, '1', Object {key: 'value'}}</code>
</pre></div>

</div>

<p>To iterate over sets we have the same two options&hairsp;&mdash;&hairsp;built-in <strong>forEach</strong> function or <strong>for..of</strong> structure:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// forEach</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="nx">set</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">5</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">6</code>   <code class="c1">// 1</code>
<code class="lineno">7</code>   <code class="c1">// '1'</code>
<code class="lineno">8</code>   <code class="c1">// Object {key: 'value'}</code>
<code class="lineno">9</code> <code class="p">});</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="c1">// for..of</code>
<code class="lineno">2</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'1'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'value'</code> <code class="p">}]);</code>
<code class="lineno">3</code> 
<code class="lineno">4</code> <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">value</code> <code class="nx">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
<code class="lineno">5</code>   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
<code class="lineno">6</code>   <code class="c1">// 1</code>
<code class="lineno">7</code>   <code class="c1">// '1'</code>
<code class="lineno">8</code>   <code class="c1">// Object {key: 'value'}</code>
<code class="lineno">9</code> <code class="p">};</code>
</pre></div>

</div>

<p><strong>Set doesn't allow to add duplicates.</strong></p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">9</code><code class="p">]);</code>
<code class="lineno">2</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">set</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code> <code class="c1">// 5!</code>
</pre></div>

</div>

<p>We can also use <strong>has()</strong>, <strong>delete()</strong>, <strong>clear()</strong> methods, which are similar to the Map versions.</p>

<h3 id="leanpub-auto-weakmap">WeakMap</h3>

<p>WeakMaps provides leak-free object keyed side tables. It's a Map that doesn't prevent its keys from being <strong>garbage-collected</strong>. We don't have to worry about memory leaks.</p>

<p>If the object is destroyed, the garbage collector removes an entry from the WeakMap and frees memory.</p>

<p><strong>Keys must be objects.</strong></p>

<p>It has almost the same API like a Map, but we <strong>can't iterate</strong> over the WeakMap collection. We can't even determine the length of the collection because we don't have <strong>size</strong> attribute here.</p>

<p>The API looks like this:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">WeakMap</code><code class="p">([</code><code class="nx">iterable</code><code class="p">])</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>        <code class="o">:</code> <code class="nx">any</code>
<code class="lineno">4</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="o">:</code> <code class="k">this</code>
<code class="lineno">5</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>        <code class="o">:</code> <code class="kr">boolean</code>
<code class="lineno">6</code> <code class="nx">WeakMap</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>     <code class="o">:</code> <code class="kr">boolean</code>
</pre></div>

</div>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">wm</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakMap</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>       <code class="nx">key1</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 4</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v1'</code>
<code class="lineno"> 5</code>       <code class="p">},</code>
<code class="lineno"> 6</code>       <code class="nx">key2</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 7</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v2'</code>
<code class="lineno"> 8</code>       <code class="p">}</code>
<code class="lineno"> 9</code>    <code class="p">};</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">wm</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">,</code> <code class="s1">'val1'</code><code class="p">);</code>
<code class="lineno">12</code> <code class="nx">wm</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key2</code><code class="p">,</code> <code class="s1">'val2'</code><code class="p">);</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">);</code> <code class="c1">// WeakMap {Object {k: 'v1'} =&gt; 'val1', Object {k: 'v2'} =&gt; 'va\</code>
<code class="lineno">15</code> <code class="nx">l2</code><code class="err">'</code><code class="p">}</code>
<code class="lineno">16</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// true</code>
<code class="lineno">17</code> 
<code class="lineno">18</code> <code class="k">delete</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">;</code>
<code class="lineno">19</code> 
<code class="lineno">20</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wm</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>

<h3 id="leanpub-auto-weakset">WeakSet</h3>

<p>Like a WeakMap, WeakSet is a Seat that doesn't prevent its values from being garbage-collected. It has simpler API than WeakMap, because has only three methods:</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno">1</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">([</code><code class="nx">iterable</code><code class="p">])</code>
<code class="lineno">2</code> 
<code class="lineno">3</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>    <code class="o">:</code> <code class="nx">any</code>
<code class="lineno">4</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>    <code class="o">:</code> <code class="kr">boolean</code>
<code class="lineno">5</code> <code class="nx">WeakSet</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">:</code> <code class="kr">boolean</code>
</pre></div>

</div>

<p><strong>WeakSets are collections of unique objects only.</strong></p>

<p>WeakSet collection can't be iterated and we cannot determine its size.</p>

<div class="code-block">
<div class="highlight"><pre><code class="lineno"> 1</code> <code class="kd">let</code> <code class="nx">ws</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">(),</code>
<code class="lineno"> 2</code>     <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
<code class="lineno"> 3</code>       <code class="nx">key1</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 4</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v1'</code>
<code class="lineno"> 5</code>       <code class="p">},</code>
<code class="lineno"> 6</code>       <code class="nx">key2</code><code class="o">:</code> <code class="p">{</code>
<code class="lineno"> 7</code>         <code class="nx">k</code><code class="o">:</code> <code class="s1">'v2'</code>
<code class="lineno"> 8</code>       <code class="p">}</code>
<code class="lineno"> 9</code>    <code class="p">};</code>
<code class="lineno">10</code> 
<code class="lineno">11</code> <code class="nx">ws</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">);</code>
<code class="lineno">12</code> <code class="nx">ws</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key2</code><code class="p">);</code>
<code class="lineno">13</code> 
<code class="lineno">14</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">);</code> <code class="c1">// WeakSet {Object {k: 'v1'}, Object {k: 'v2'}}</code>
<code class="lineno">15</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// true</code>
<code class="lineno">16</code> 
<code class="lineno">17</code> <code class="k">delete</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">;</code>
<code class="lineno">18</code> 
<code class="lineno">19</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ws</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">key1</code><code class="p">));</code> <code class="c1">// false</code>
</pre></div>

</div>
</div>


</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Symbols in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>Buon giorno! Willkommen to <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 &ndash; <em>"I can't believe this is yet another installment"</em> &ndash; in Depth</a>. If you have no idea how you got here or what ES6 even is, I recommend reading <a aria-label="A Brief History of ES6 Tooling on Pony Foo" href="/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, and <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a>. Today we'll be discussing <em>Symbols</em>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for listening to that, and let's go into symbols now! For a bit of context, you may want to check out the last two articles, &ndash; on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a> and <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a> &ndash; where we first talked about Symbols.</p></section>
		<section class="md-markdown at-body"><h2 id="what-are-symbols">What are Symbols?</h2><p>Symbols are a new primitive type in ES6. If you ask me, they're <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code class="md-code md-code-inline">Symbol</code> wrapper object.</p><p>We can create our own Symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol()
</code></pre><p>Note that there was no <code class="md-code md-code-inline">new</code>. The <code class="md-code md-code-inline">new</code> operator even throws a <code class="md-code md-code-inline">TypeError</code> when we try it on <code class="md-code md-code-inline">Symbol</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> oops = <span class="md-code-keyword">new</span> Symbol()
<span class="md-code-comment">// &lt;- TypeError</span>
</code></pre><p>For debugging purposes, you can describe symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> mystery = Symbol(<span class="md-code-string">'this is a descriptive description'</span>)
</code></pre><p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol() === Symbol())
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log(Symbol(<span class="md-code-string">'foo'</span>) === Symbol(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre><p>Symbols are <em>symbols</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol())
<span class="md-code-comment">// &lt;- 'symbol'</span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-keyword">typeof</span> Symbol(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- 'symbol'</span>
</code></pre><p>There are three different flavors of symbols &ndash; each flavor is accessed in a different way. We'll explore each of these and slowly figure out what all of this means.</p><ul><li>You can access local symbols by obtaining a reference to them <em>directly</em></li><li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li><li>"Well-known" symbols exist across <em>realms</em> &ndash; but you can't create them and they're not on the <em>global registry</em></li></ul><p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code class="md-code md-code-inline">&lt;iframe&gt;</code> within your page.</p><h2 id="the-runtime-wide-symbol-registry">The "Runtime-Wide" Symbol Registry</h2><p>There's two methods you can use to add symbols to the runtime-wide symbol registry: <code class="md-code md-code-inline">Symbol.for(key)</code> and <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code>. What do these do?</p><h3 id="symbolfor-key"><code class="md-code md-code-inline">Symbol.for(key)</code></h3><p>This method looks up <code class="md-code md-code-inline">key</code> in the runtime-wide symbol registry. If a symbol with that <code class="md-code md-code-inline">key</code> exists in the global registry, that symbol is returned. If no symbol with that <code class="md-code md-code-inline">key</code> is found in the registry, one is created. That's to say, <code class="md-code md-code-inline">Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code class="md-code md-code-inline">Symbol.for('foo')</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code class="md-code md-code-inline">key</code> is already in the registry by then &ndash; and associated to the symbol returned by the first call.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">Symbol.for(<span class="md-code-string">'foo'</span>) === Symbol.for(<span class="md-code-string">'foo'</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code class="md-code md-code-inline">key</code>. Note that your <code class="md-code md-code-inline">key</code> will also be used as a <code class="md-code md-code-inline">description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don't just name your symbols <code class="md-code md-code-inline">'user'</code> or some generic name like that.</p><h3 id="symbolkeyfor-symbol"><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code></h3><p>Given a symbol <code class="md-code md-code-inline">symbol</code>, <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> returns the <code class="md-code md-code-inline">key</code> that was associated with <code class="md-code md-code-inline">symbol</code> when the symbol was added to the global registry.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> symbol = Symbol.for(<span class="md-code-string">'foo'</span>)
<span class="md-code-built_in">console</span>.log(Symbol.keyFor(symbol))
<span class="md-code-comment">// &lt;- 'foo'</span>
</code></pre><h3 id="how-wide-is-runtime-wide">How Wide is Runtime-Wide?</h3><p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I'll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">'iframe'</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.for(<span class="md-code-string">'foo'</span>) === frame.contentWindow.Symbol.for(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><h2 id="the-well-known-symbols">The "Well-Known" Symbols</h2><p>Let me put you at ease: <strong>these aren't actually well-known at all.</strong> Far from it. I didn't have any idea these things existed until a few months ago. Why are they <em>"well-known"</em>, then? That's because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren't exposed to user code before ES6, but now you can fiddle with them.</p><p>A great example of a <em>"well-known"</em> symbol is something we've already been playing with on Pony Foo: the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code class="md-code md-code-inline">@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There's <a aria-label="Well-known symbols on MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p><p>One of the well-known symbols that <em>is</em> documented at this time is <a aria-label="Symbol.match on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match"><code class="md-code md-code-inline">Symbol.match</code></a>. According to MDN, you can set the <code class="md-code md-code-inline">Symbol.match</code> property on regular expressions to <code class="md-code md-code-inline">false</code> and have them behave as string literals when matching <em>(instead of regular expressions, which don't play nice with <a aria-label="String.prototype.startsWith() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith"><code class="md-code md-code-inline">.startsWith</code></a>, <a aria-label="String.prototype.endsWith() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith"><code class="md-code md-code-inline">.endsWith</code></a>, or <a aria-label="String.prototype.includes() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes"><code class="md-code md-code-inline">.includes</code></a>)</em>.</p><p>This part of the spec hasn't been implemented in Babel yet, <em>&ndash; I assume that's just because it's not worth the trouble &ndash;</em> but supposedly it goes like this.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">'/foo/'</span>
<span class="md-code-keyword">var</span> literal = <span class="md-code-regexp">/foo/</span>
<mark class="md-mark md-code-mark">literal[Symbol.match] = false</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(literal))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Why you'd want to do that instead of just casting <code class="md-code md-code-inline">literal</code> to a string <em>is beyond me</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">'/foo/'</span>
<span class="md-code-keyword">var</span> casted = <span class="md-code-regexp">/foo/</span><mark class="md-mark md-code-mark">.toString()</mark>
<span class="md-code-built_in">console</span>.log(text.startsWith(casted))
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don't think it'll become a front-end development staple anytime soon.</p><blockquote><p>Regardless, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> is actually very useful, and I'm sure other well-known symbols are useful as well.</p></blockquote><p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they're not accessible through the <em>global registry</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> frame = <span class="md-code-built_in">document</span>.createElement(<span class="md-code-string">'iframe'</span>)
<span class="md-code-built_in">document</span>.body.appendChild(frame)
<span class="md-code-built_in">console</span>.log(Symbol.iterator === frame.contentWindow.Symbol.iterator)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Not accessible through the <em>global registry</em>? Nope!</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(Symbol.keyFor(Symbol.iterator))
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre><p>Accessing them statically from anywhere should be more than enough, though.</p><h2 id="symbols-and-iteration">Symbols and Iteration</h2><p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol()]: <span class="md-code-string">'foo'</span>,
  [Symbol(<span class="md-code-string">'foo'</span>)]: <span class="md-code-string">'bar'</span>,
  [Symbol.for(<span class="md-code-string">'bar'</span>)]: <span class="md-code-string">'baz'</span>,
  what: <span class="md-code-string">'ever'</span>
}
<span class="md-code-built_in">console</span>.log([...foo])
<span class="md-code-comment">// &lt;- []</span>
</code></pre><p>The ES5 <code class="md-code md-code-inline">Object.keys</code> method ignores symbols.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.keys(foo))
<span class="md-code-comment">// &lt;- ['what']</span>
</code></pre><p>Same goes for <code class="md-code md-code-inline">JSON.stringify</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">JSON</span>.stringify(foo))
<span class="md-code-comment">// &lt;- {"what":"ever"}</span>
</code></pre><p>So, <code class="md-code md-code-inline">for..in</code> then? Nope.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> key <span class="md-code-keyword">in</span> foo) {
  <span class="md-code-built_in">console</span>.log(key)
  <span class="md-code-comment">// &lt;- 'what'</span>
}
</code></pre><p>I know, <code class="md-code md-code-inline">Object.getOwnPropertyNames</code>. Nah! <em>&ndash; but close.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertyNames(foo))
<span class="md-code-comment">// &lt;- ['what']</span>
</code></pre><p>You need to be explicitly looking for symbols to stumble upon them. They're like JavaScript neutrinos. You can use <a aria-label="Object.getOwnPropertySymbols() &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> to detect them.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo))
<span class="md-code-comment">// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')]</span>
</code></pre><p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code class="md-code md-code-inline">for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won't be as disappointing as the flukes in the snippet below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> symbol of <span class="md-code-built_in">Object</span>.getOwnPropertySymbols(foo)) {
  <span class="md-code-built_in">console</span>.log(foo[symbol])
  <span class="md-code-comment">// &lt;- 'foo'</span>
  <span class="md-code-comment">// &lt;- 'bar'</span>
  <span class="md-code-comment">// &lt;- 'baz'</span>
}
</code></pre><h2 id="why-would-i-want-symbols">Why Would I Want Symbols?</h2><p>There's a few different uses for symbols.</p><h3 id="name-clashes">Name Clashes</h3><p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>"objects as hash maps"</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p><h3 id="privacy">"Privacy"?</h3><p>Symbols are <em>invisible to all "reflection" methods before ES6</em>. This can be useful in some scenarios, but they're not private by any stretch of imagination, as we've just demonstrated with the <a aria-label="Object.getOwnPropertySymbols() &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> API.</p><p>That being said, the fact that you have to actively look for symbols to find them means they're useful in situations where you want to define metadata that shouldn't be part of iterable sequences for arrays or any <em>iterable</em> objects.</p><h3 id="defining-protocols">Defining Protocols</h3><p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> &ndash; just like there's <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p><p>Imagine for instance a library like <a aria-label="bevacqua/dragula on GitHub" href="https://github.com/bevacqua/dragula"><code class="md-code md-code-inline">dragula</code></a> defining a protocol through <code class="md-code md-code-inline">Symbol.for('dragula.moves')</code>, where you could add a method on that <code class="md-code md-code-inline">Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code class="md-code md-code-inline">dragula</code> could call the <code class="md-code md-code-inline">el[Symbol.for('dragula.moves')]()</code> user-defined method to assert whether the element can be moved.</p><p>This way, the logic about elements being draggable by <code class="md-code md-code-inline">dragula</code> is shifted from a single place for the entire <code class="md-code md-code-inline">drake</code> <em>(the <code class="md-code md-code-inline">options</code> for an instance of <code class="md-code md-code-inline">dragula</code>)</em>, to each individual DOM element. That'd make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code class="md-code md-code-inline">options.moves</code> method.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 JavaScript Destructuring in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>I've briefly mentioned a few ES6 features <em>(and how to <a aria-label="Setting up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">get started with Babel</a>)</em> in the React article series I've been writing about, and now I want to <strong>focus on the language features</strong> themselves. I've read a <em>ton</em> about ES6 and ES7 and it's about time we started discussing ES6 and ES7 features here in Pony Foo.</p><p>This article <strong>warns about going overboard</strong> with ES6 language features. Then we'll start off the series by discussing about Destructuring in ES6, and when it's most useful, as well as some of its gotchas and caveats.</p><h2 id="a-word-of-caution">A word of caution</h2><p>When uncertain, chances are <mark class="md-mark">you probably should default to ES5 and older syntax instead of adopting ES6 just because you can</mark>. By this I don't mean that using ES6 syntax is a bad idea &ndash; quite the opposite, see I'm writing an article about ES6! My concern lies with the fact that when we adopt ES6 features we must do it because <strong>they'll absolutely improve our code quality</strong>, and not just because of the <em>"cool factor"</em> &ndash; whatever that may be.</p><p>The approach I've been taking thus far is to write things in <em>plain ES5</em>, and then adding ES6 sugar on top where it'd genuinely improve my code. I presume over time I'll be able to more quickly identify scenarios where a ES6 feature may be worth using over ES5, but when getting started it might be a good idea <em>not</em> to go overboard too soon. Instead, carefully analyze what would fit your code best first, and <strong>be mindful of adopting ES6</strong>.</p><blockquote><p>This way, you'll <strong>learn to use</strong> the new features in your favor, rather than just <em>learning the syntax</em>.</p></blockquote><p>Onto the cool stuff now!</p></section>
		<section class="md-markdown at-body"><h2 id="destructuring">Destructuring</h2><p>This is easily one of the features I've been using the most. It's also one of the simplest. It binds properties to as many variables as you need and it works with both Arrays and Objects.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: <span class="md-code-string">'pony'</span>, baz: <span class="md-code-number">3</span> }
<span class="md-code-keyword">var</span> {bar, baz} = foo
<span class="md-code-built_in">console</span>.log(bar)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(baz)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>It makes it very quick to pull out a specific property from an object. You're also allowed to map properties into aliases as well.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: <span class="md-code-string">'pony'</span>, baz: <span class="md-code-number">3</span> }
<span class="md-code-keyword">var</span> {bar: a, baz: b} = foo
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>You can also pull properties as deep as you want, and you could also alias those deep bindings.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = { bar: { deep: <span class="md-code-string">'pony'</span>, dangerouslySetInnerHTML: <span class="md-code-string">'lol'</span> } }
<span class="md-code-keyword">var</span> {bar: { deep, dangerouslySetInnerHTML: sure }} = foo
<span class="md-code-built_in">console</span>.log(deep)
<span class="md-code-comment">// &lt;- 'pony'</span>
<span class="md-code-built_in">console</span>.log(sure)
<span class="md-code-comment">// &lt;- 'lol'</span>
</code></pre><p>By default, properties that aren't found will be <code class="md-code md-code-inline">undefined</code>, just like when accessing properties on an object with the dot or bracket notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo} = {bar: <span class="md-code-string">'baz'</span>}
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- undefined</span>
</code></pre><p>If you're trying to access a deeply nested property of a parent that doesn't exist, then you'll get an exception, though.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo:{bar}} = {baz: <span class="md-code-string">'ouch'</span>}
<span class="md-code-comment">// &lt;- Exception</span>
</code></pre><p>That makes a lot of sense, if you think of destructuring as sugar for ES5 like the code below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> _temp = { baz: <span class="md-code-string">'ouch'</span> }
<span class="md-code-keyword">var</span> bar = _temp.foo.bar
<span class="md-code-comment">// &lt;- Exception</span>
</code></pre><p>A cool property of destructuring is that it allows you to swap variables without the need for the infamous <code class="md-code md-code-inline">aux</code> variable.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">es5</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> left = <span class="md-code-number">10</span>
  <span class="md-code-keyword">var</span> right = <span class="md-code-number">20</span>
  <span class="md-code-keyword">var</span> aux
  <span class="md-code-keyword">if</span> (right &gt; left) {
    aux = right
    right = left
    left = aux
  }
}
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">es6</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> left = <span class="md-code-number">10</span>
  <span class="md-code-keyword">var</span> right = <span class="md-code-number">20</span>
  <span class="md-code-keyword">if</span> (right &gt; left) {
    <mark class="md-mark md-code-mark">[left, right] = [right, left]</mark>
  }
}
</code></pre><p>Another convenient aspect of destructuring is the ability to pull keys using <a aria-label="Computed Property Names &ndash; MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names">computed property names</a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> key = <span class="md-code-string">'such_dynamic'</span>
<span class="md-code-keyword">var</span> { <mark class="md-mark md-code-mark">[key]</mark>: foo } = { such_dynamic: <span class="md-code-string">'bar'</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 'bar'</span>
</code></pre><p>In ES5, that'd take an extra statement and variable allocation on your behalf.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> key = <span class="md-code-string">'such_dynamic'</span>
<span class="md-code-keyword">var</span> baz = { such_dynamic: <span class="md-code-string">'bar'</span> }
<span class="md-code-keyword">var</span> foo = baz[key]
<span class="md-code-built_in">console</span>.log(foo)
</code></pre><p>You can also define default values, for the case where the pulled property evaluates to <code class="md-code md-code-inline">undefined</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { foo: <span class="md-code-number">2</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 2</span>
<span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { foo: <span class="md-code-literal">undefined</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-keyword">var</span> {foo=<span class="md-code-number">3</span>} = { bar: <span class="md-code-number">2</span> }
<span class="md-code-built_in">console</span>.log(foo)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>Destructuring works for Arrays as well, as we mentioned earlier. Note how I'm <strong>using square brackets</strong> in the destructuring side of the declaration now.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [a] = [<span class="md-code-number">10</span>]
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 10</span>
</code></pre><p>Here, again, we can use the default values and follow the same rules.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [a] = []
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- undefined</span>
<span class="md-code-keyword">var</span> [b=<span class="md-code-number">10</span>] = [<span class="md-code-literal">undefined</span>]
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 10</span>
<span class="md-code-keyword">var</span> [c=<span class="md-code-number">10</span>] = []
<span class="md-code-built_in">console</span>.log(c)
<span class="md-code-comment">// &lt;- 10</span>
</code></pre><p>When it comes to Arrays you can conveniently skip over elements that you don't care about.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> [,,a,b] = [<span class="md-code-number">1</span>,<span class="md-code-number">2</span>,<span class="md-code-number">3</span>,<span class="md-code-number">4</span>,<span class="md-code-number">5</span>]
<span class="md-code-built_in">console</span>.log(a)
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(b)
<span class="md-code-comment">// &lt;- 4</span>
</code></pre><p>You can also use destructuring in a <code class="md-code md-code-inline">function</code>‘s parameter list.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">function greet ({ age, name:greeting='she' }) {
  console.log(<mark class="md-mark md-code-mark">`${greeting} is ${age} years old.`</mark>)
}
greet({ name: 'nico', age: 27 })
// &lt;- 'nico is 27 years old'
greet({ age: 24 })
// &lt;- 'she is 24 years old'
</code></pre><p>That's roughly <strong>how</strong> you can use destructuring. What is destructuring <strong>good</strong> for?</p><h2 id="use-cases-for-destructuring">Use Cases for Destructuring</h2><p>There are many situations where destructuring comes in handy. Here's some of the most common ones. Whenever you have a method that returns an object, destructuring makes it much terser to interact with.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getCoords</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> {
    x: <span class="md-code-number">10</span>,
    y: <span class="md-code-number">22</span>
  }
}
<span class="md-code-keyword">var</span> {x, y} = getCoords()
<span class="md-code-built_in">console</span>.log(x)
<span class="md-code-comment">// &lt;- 10</span>
<span class="md-code-built_in">console</span>.log(y)
<span class="md-code-comment">// &lt;- 22</span>
</code></pre><p>A similar use case but in the opposite direction is being able to define default options when you have a method with a bunch of options that need default values. This is particularly interesting as an alternative to named parameters in other languages like Python and C#.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">random</span> <span class="md-code-params">({ min=1, max=300 })</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.floor(<span class="md-code-built_in">Math</span>.random() * (max - min)) + min
}
<span class="md-code-built_in">console</span>.log(random({}))
<span class="md-code-comment">// &lt;- 174</span>
<span class="md-code-built_in">console</span>.log(random({max: <span class="md-code-number">24</span>}))
<span class="md-code-comment">// &lt;- 18</span>
</code></pre><p>If you wanted to make the options object <em>entirely optional</em> you could change the syntax to the following.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">random</span> <span class="md-code-params">({ min=1, max=300 }<mark class="md-mark md-code-mark"> = {}</mark>)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.floor(<span class="md-code-built_in">Math</span>.random() * (max - min)) + min
}
<span class="md-code-built_in">console</span>.log(random())
<span class="md-code-comment">// &lt;- 133</span>
</code></pre><p>A great fit for destructuring are things like regular expressions, where you would just love to name parameters without having to resort to index numbers. Here's an example parsing a URL with a random <code class="md-code md-code-inline">RegExp</code> <a aria-label="Getting parts of a URL on StackOverflow" href="http://stackoverflow.com/a/27755/389745">I got on StackOverflow</a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">getUrlParts</span> <span class="md-code-params">(url)</span> </span>{
  <span class="md-code-keyword">var</span> magic = <span class="md-code-regexp">/^(https?):\/\/(ponyfoo\.com)(\/articles\/([a-z0-9-]+))$/</span>
  <span class="md-code-keyword">return</span> magic.exec(url)
}
<span class="md-code-keyword">var</span> parts = getUrlParts(<span class="md-code-string">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)
<span class="md-code-keyword">var</span> [,protocol,host,pathname,slug] = parts
<span class="md-code-built_in">console</span>.log(protocol)
<span class="md-code-comment">// &lt;- 'http'</span>
<span class="md-code-built_in">console</span>.log(host)
<span class="md-code-comment">// &lt;- 'ponyfoo.com'</span>
<span class="md-code-built_in">console</span>.log(pathname)
<span class="md-code-comment">// &lt;- '/articles/es6-destructuring-in-depth'</span>
<span class="md-code-built_in">console</span>.log(slug)
<span class="md-code-comment">// &lt;- 'es6-destructuring-in-depth'</span>
</code></pre><h3 id="special-case-import-statements">Special Case: <code class="md-code md-code-inline">import</code> Statements</h3><p>Even though <code class="md-code md-code-inline">import</code> statements don't follow destructuring rules, they behave a bit similarly. This is probably the <em>"destructuring-like"</em> use case I find myself using the most, even though it's not actually destructuring. Whenever you're writing module <code class="md-code md-code-inline">import</code> statements, you can pull just what you need from a module's public API. An example using <a aria-label="bevacqua/contra on GitHub" href="https://github.com/bevacqua/contra"><code class="md-code md-code-inline">contra</code></a>:</p><pre class="md-code-block"><code class="md-code md-lang-javascript">import {series, concurrent, map } from <span class="md-code-string">'contra'</span>
series(tasks, done)
concurrent(tasks, done)
map(items, mapper, done)
</code></pre><p>Note that, however, <code class="md-code md-code-inline">import</code> statements have a different syntax. When compared against destructuring, none of the following <code class="md-code md-code-inline">import</code> statements will work.</p><ul><li>Use defaults values such as <code class="md-code md-code-inline">import {series = noop} from 'contra'</code></li><li>"Deep" destructuring style like <code class="md-code md-code-inline">import {map: { series }} from 'contra'</code></li><li>Aliasing syntax <code class="md-code md-code-inline">import {map: mapAsync} from 'contra'</code></li></ul><p>The main reason for these limitations is that the <code class="md-code md-code-inline">import</code> statement brings in a <em>binding</em>, and not a reference or a value. This is an important differentiation that we'll explore more in depth in a future article about ES6 modules.</p><blockquote><p>I'll keep posting about ES6 &amp; ES7 features every day, so make sure to subscribe if you want to know more!</p></blockquote><p><sub><mark class="md-mark">*</mark> How about we visit string interpolation tomorrow?</sub><br><sub><mark class="md-mark">**</mark>We'll leave arrow functions for monday!</sub></p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Generators in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>This is <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a>, the longest-running article series in the history of Pony Foo! Trapped in the ES5 bubble? Welcome! Let me get you started with <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, and <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">Iterators</a>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for listening to that, and let's go into generators now! If you haven't yet, you should read yesterday's article on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, as this article pretty much assumes that you've read it.</p></section>
		<section class="md-markdown at-body"><h2 id="generator-functions-and-generator-objects">Generator Functions and Generator Objects</h2><p>Generators are a new feature in ES6. You declare a <em>generator function</em> which returns generator objects <code class="md-code md-code-inline">g</code> that can then be iterated using any of <a aria-label="Array.from() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"><code class="md-code md-code-inline">Array.from(g)</code></a>, <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth"><code class="md-code md-code-inline">[...g]</code></a>, or <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">for value of g</code></a> loops. Generator functions allow you to declare a special kind of <em>iterator</em>. These iterators can suspend execution while retaining their context. We already examined iterators in <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">the previous article</a> and how their <code class="md-code md-code-inline">.next()</code> method is called once at a time to pull values from a sequence.</p><p>Here is an example generator function. Note the <code class="md-code md-code-inline">*</code> after <code class="md-code md-code-inline">function</code>. That's not a typo, that's how you mark a generator function as a <em>generator</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
}
</code></pre><p>Generator objects conform to both the <em>iterable</em> protocol and the <em>iterator</em> protocol. This means…</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> g = <mark class="md-mark md-code-mark">generator()</mark>
<span class="md-code-comment">// a generator object g is built using the generator function</span>
<span class="md-code-keyword">typeof</span> g[Symbol.iterator] === <span class="md-code-string">'function'</span>
<span class="md-code-comment">// it's an iterable because it has an @@iterator</span>
<span class="md-code-keyword">typeof</span> g.next === <span class="md-code-string">'function'</span>
<span class="md-code-comment">// it's also an iterator because it has a .next method</span>
g[Symbol.iterator]() === g
<span class="md-code-comment">// the iterator for a generator object is the generator object itself</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">[...g]</mark>)
<span class="md-code-comment">// &lt;- ['f', 'o', 'o']</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">Array.from(g)</mark>)
<span class="md-code-comment">// &lt;- ['f', 'o', 'o']</span>
</code></pre><p><sub><em>(This article is starting to sound an awful lot like a Math course…)</em></sub></p><p>When you create a generator object <em>(I'll just call them "generator" from here on out)</em>, you'll get an <em>iterator</em> that uses the generator to produce its <em>sequence</em>. Whenever a <code class="md-code md-code-inline">yield</code> expression is reached, that value is emitted by the iterator and <strong>function execution is suspended</strong>.</p><p>Let's use a different example, this time with some other statements mixed in between <code class="md-code md-code-inline">yield</code> expressions. This is a simple generator but it behaves in an interesting enough way for our purposes here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'p'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'n'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'y'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'!'</span>)
}
</code></pre><p>If we use a <code class="md-code md-code-inline">for..of</code> loop, this will print <code class="md-code md-code-inline">ponyfoo!</code> one character at a time, as expected.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = generator()
<span class="md-code-keyword">for</span> (<mark class="md-mark md-code-mark">let pony of foo</mark>) {
  <span class="md-code-built_in">console</span>.log(pony)
  <span class="md-code-comment">// &lt;- 'p'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- 'n'</span>
  <span class="md-code-comment">// &lt;- 'y'</span>
  <span class="md-code-comment">// &lt;- 'f'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- 'o'</span>
  <span class="md-code-comment">// &lt;- '!'</span>
}
</code></pre><p>What about using the spread <code class="md-code md-code-inline">[...foo]</code> syntax? Things turn out a little different here. This might be a little unexpected, but that's how generators work, everything that's not yielded ends up becoming <strong>a side effect</strong>. As the sequence is being constructed, the <code class="md-code md-code-inline">console.log</code> statements in between <code class="md-code md-code-inline">yield</code> calls are executed, and they print characters to the console before <code class="md-code md-code-inline">foo</code> is spread over an array. The previous example worked because we were printing characters as soon as they were pulled from the sequence, instead of waiting to construct a range for the entire sequence first.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = generator()
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">[...foo]</mark>)
<span class="md-code-comment">// &lt;- 'o'</span>
<span class="md-code-comment">// &lt;- 'y'</span>
<span class="md-code-comment">// &lt;- 'o'</span>
<span class="md-code-comment">// &lt;- '!'</span>
<span class="md-code-comment">// &lt;- ['p', 'n', 'f', 'o']</span>
</code></pre><p>A neat aspect of generator functions is that you can also use <code class="md-code md-code-inline">yield*</code> to delegate to another generator function. Want a very contrived way to split <code class="md-code md-code-inline">'ponyfoo'</code> into individual characters? Since strings in ES6 adhere to the <em>iterable</em> protocol, you could do the following.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span>* <span class="md-code-string">'ponyfoo'</span>
}
<span class="md-code-built_in">console</span>.log([...generator()])
<span class="md-code-comment">// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']</span>
</code></pre><p>Of course, in the real world you could just do <code class="md-code md-code-inline">[...'ponyfoo']</code>, since spread supports iterables just fine. Just like you could <code class="md-code md-code-inline">yield*</code> a string, you can <code class="md-code md-code-inline">yield*</code> anything that adheres to the iterable protocol. That includes other generators, arrays, and come ES6 &ndash; <em>just about anything.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> foo = {
  [Symbol.iterator]: () =&gt; ({
    items: <mark class="md-mark md-code-mark">[<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>, <span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>, <span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>, <span class="md-code-string">'o'</span>]</mark>,
    next: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">next</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">return</span> {
        done: <span class="md-code-keyword">this</span>.items.length === <span class="md-code-number">0</span>,
        value: <span class="md-code-keyword">this</span>.items.shift()
      }
    }
  })
}
<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">multiplier</span> <span class="md-code-params">(value)</span> </span>{
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">2</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">3</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">4</span>
  <span class="md-code-keyword">yield</span> value * <span class="md-code-number">5</span>
}
<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">trailmix</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">0</span>
  <span class="md-code-keyword">yield</span>* [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]
  <span class="md-code-keyword">yield</span>* <mark class="md-mark md-code-mark">[...multiplier(<span class="md-code-number">2</span>)]</mark>
  <span class="md-code-keyword">yield</span>* multiplier(<span class="md-code-number">3</span>)
  <span class="md-code-keyword">yield</span>* <mark class="md-mark md-code-mark">foo</mark>
}
<span class="md-code-built_in">console</span>.log([...trailmix()])
<span class="md-code-comment">// &lt;- [0, 1, 2, <mark class="md-mark md-code-mark">4, 6, 8, 10</mark>, 6, 9, 12, 15, <mark class="md-mark md-code-mark">'p', 'o', 'n', 'y', 'f', 'o', 'o'</mark>]</span>
</code></pre><p>You could also iterate the sequence by hand, calling <code class="md-code md-code-inline">.next()</code>. This approach gives you the most control over the iteration, but it's also the most involved. There's a few features you can leverage here that give you even more control over the iteration.</p><h2 id="iterating-over-generators-by-hand">Iterating Over Generators by Hand</h2><p>Besides iterating over <code class="md-code md-code-inline">trailmix</code> as we've already covered, using <code class="md-code md-code-inline">[...trailmix()]</code>, <code class="md-code md-code-inline">for value of trailmix()</code>, and <code class="md-code md-code-inline">Array.from(trailmix())</code>, we could use the generator returned by <code class="md-code md-code-inline">trailmix()</code> directly, and iterate over that. But <code class="md-code md-code-inline">trailmix</code> was an overcomplicated showcase of <code class="md-code md-code-inline">yield*</code>, let's go back to the <em>side-effects</em> <code class="md-code md-code-inline">generator</code> for this one.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'p'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'n'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'y'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'f'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'o'</span>)
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'o'</span>
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'!'</span>)
}
<span class="md-code-keyword">var</span> g = generator()
<span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
  <span class="md-code-keyword">let</span> item = <mark class="md-mark md-code-mark">g.next()</mark>
  <span class="md-code-keyword">if</span> (item.done) {
    <span class="md-code-keyword">break</span>
  }
  <span class="md-code-built_in">console</span>.log(item.value)
}
</code></pre><p>Just like we <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">learned yesterday</a>, any items returned by an iterator will have a <code class="md-code md-code-inline">done</code> property that indicates whether the sequence has reached its end, and a <code class="md-code md-code-inline">value</code> indicating the current value in the sequence.</p><blockquote><p>If you're confused as to <strong>why the <code class="md-code md-code-inline">'!'</code> is printed</strong> even though there are no more <code class="md-code md-code-inline">yield</code> expressions after it, that's because <code class="md-code md-code-inline">g.next()</code> doesn't know that. The way it works is that each time its called, it executes the method until a <code class="md-code md-code-inline">yield</code> expression is reached, emits its value and <em>suspends execution</em>. The next time <code class="md-code md-code-inline">g.next()</code> is called, _execution is resumed _from where it left off <em>(the last <code class="md-code md-code-inline">yield</code> expression)</em>, until the next <code class="md-code md-code-inline">yield</code> expression is reached. When no <code class="md-code md-code-inline">yield</code> expression is reached, the generator returns <code class="md-code md-code-inline">{ done: true }</code>, signaling that the sequence has ended. At this point, the <code class="md-code md-code-inline">console.log('!')</code> statement has been already executed, though.</p><p>It's also worth noting that <strong>context is preserved</strong> across suspensions and resumptions. That means generators can be stateful. Generators are, in fact, the underlying implementation for <code class="md-code md-code-inline">async</code>/<code class="md-code md-code-inline">await</code> semantics coming in ES7.</p></blockquote><p>Whenever <code class="md-code md-code-inline">.next()</code> is called on a generator, there's four "events" that will suspend execution in the generator, returning an <em><code class="md-code md-code-inline">IteratorResult</code></em> to the caller of <code class="md-code md-code-inline">.next()</code>.</p><ul><li>A <code class="md-code md-code-inline">yield</code> expression returning the <em>next</em> value in the sequence</li><li>A <code class="md-code md-code-inline">return</code> statement returning the <em>last</em> value in the sequence</li><li>A <code class="md-code md-code-inline">throw</code> statement halts execution in the generator entirely</li><li>Reaching the end of the generator function signals <code class="md-code md-code-inline">{ done: true }</code></li></ul><p>Once the <code class="md-code md-code-inline">g</code> generator ended iterating over a sequence, subsequent calls to <code class="md-code md-code-inline">g.next()</code> will have no effect and just return <code class="md-code md-code-inline">{ done: true }</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">generator</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'only'</span>
}
<span class="md-code-keyword">var</span> g = generator()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 'only' }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><h2 id="generators-the-del-weird-del-ins-awesome-ins-parts">Generators: The <del>Weird</del> <ins><em>Awesome</em></ins> Parts</h2><p>Generator objects come with a couple more methods besides <a aria-label="Generator.prototype.next() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next"><code class="md-code md-code-inline">.next</code></a>. These are <a aria-label="Generator.prototype.return() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return"><code class="md-code md-code-inline">.return</code></a> and <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">.throw</code></a>. We've already covered <code class="md-code md-code-inline">.next</code> extensively, but not quite. You could also use <code class="md-code md-code-inline">.next(value)</code> to send values <em>into the generator</em>.</p><p>Let's make <strong>a magic 8-ball generator</strong>. First off, you'll need some answers. Wikipedia obliges, yielding <a aria-label="Magic 8 Ball Possible Answers on Wikipedia" href="https://en.wikipedia.org/wiki/Magic_8-Ball#Possible_answers">20 possible answers</a> for our magic 8-ball.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var answers = [
  `It is certain`, `It is decidedly so`, `Without a doubt`,
  `Yes definitely`, `You may rely on it`, `As I see it, yes`,
  `Most likely`, `Outlook good`, `Yes`, `Signs point to yes`,
  `Reply hazy try again`, `Ask again later`, `Better not tell you now`,
  `Cannot predict now`, `Concentrate and ask again`,
  `Don't count on it`, `My reply is no`, `My sources say no`,
  `Outlook not so good`, `Very doubtful`
]
function answer () {
  return answers[Math.floor(Math.random() * answers.length)]
}
</code></pre><p>The following generator function can act as a <em>"genie"</em> that answers any questions you might have for them. Note how we discard the first result from <code class="md-code md-code-inline">g.next()</code>. That's because the first call to <code class="md-code md-code-inline">.next</code> enters the generator and there's no <code class="md-code md-code-inline">yield</code> expression waiting to capture the <code class="md-code md-code-inline">value</code> from <code class="md-code md-code-inline">g.next(value)</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">chat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">let</span> question = <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Genie] '</span> + answer()
    <span class="md-code-built_in">console</span>.log(question)
  }
}
<span class="md-code-keyword">var</span> g = chat()
<mark class="md-mark md-code-mark">g.next()</mark>
<span class="md-code-built_in">console</span>.log(g.next(<span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>).value)
<span class="md-code-comment">// &lt;- '[Me] Will ES6 die a painful death?'</span>
<span class="md-code-comment">// &lt;- '[Genie] My sources say no'</span>
<span class="md-code-built_in">console</span>.log(g.next(<span class="md-code-string">'[Me] How youuu doing?'</span>).value)
<span class="md-code-comment">// &lt;- '[Me] How youuu doing?'</span>
<span class="md-code-comment">// &lt;- '[Genie] Concentrate and ask again'</span>
</code></pre><p>Randomly dropping <code class="md-code md-code-inline">g.next()</code> feels like a very dirty coding practice, though. What else could we do? We could flip responsibilities around.</p><h3 id="inversion-of-control">Inversion of Control</h3><p>We could have the Genie be in control, and have the generator ask the questions. How would that look like? At first, you might think that the code below is unconventional, but in fact, most libraries built around generators work by inverting responsibility.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">chat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
}
<span class="md-code-keyword">var</span> g = chat()
<span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
  <span class="md-code-keyword">let</span> question = g.next()
  <span class="md-code-keyword">if</span> (question.done) {
    <span class="md-code-keyword">break</span>
  }
  <span class="md-code-built_in">console</span>.log(question.value)
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + answer())
  <span class="md-code-comment">// &lt;- '[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-comment">// &lt;- '[Genie] Very doubtful'</span>
  <span class="md-code-comment">// &lt;- '[Me] How youuu doing?'</span>
  <span class="md-code-comment">// &lt;- '[Genie] My reply is no'</span>
}
</code></pre><p>You would expect the <strong>generator to do the heavy lifting</strong> of an iteration, but in fact generators make it easy to iterate over things by suspending execution of themselves &ndash; and deferring the heavy lifting. That's one of the most powerful aspects of generators. Suppose now that the iterator is a <code class="md-code md-code-inline">genie</code> method in a library, like so:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  <span class="md-code-keyword">while</span> (<span class="md-code-literal">true</span>) {
    <span class="md-code-keyword">let</span> question = g.next()
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">break</span>
    }
    <span class="md-code-built_in">console</span>.log(question.value)
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + answer())
  }
}
</code></pre><p>To use it, all you'd have to do is pass in a simple generator like the one we just made.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">questions</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
})
</code></pre><p>Compare that to the generator we had before, where questions were sent to the generator instead of the other way around. See how much more complicated the logic would have to be to achieve the same goal? Letting the library deal with the flow control means you can <strong>just worry about the <em>thing</em> you want to iterate</strong> over, and you can <strong>delegate <em>how</em> to iterate over it</strong>. But yes, it does mean your code now has an asterisk in it. <em>Weird.</em></p><h3 id="dealing-with-asynchronous-flows">Dealing with asynchronous flows</h3><p>Imagine now that the <code class="md-code md-code-inline">genie</code> library gets its magic 8-ball answers from an API. How does that look then? Probably something like the snippet below. Assume the <a aria-label="Raynos/xhr on GitHub" href="https://github.com/Raynos/xhr"><code class="md-code md-code-inline">xhr</code></a> pseudocode call always yields JSON responses like <code class="md-code md-code-inline">{ answer: 'No' }</code>. Keep in mind this is a simple example that just processes each question in series. You could put together different and more complex flow control algorithms depending on what you're looking for.</p><p>This is just a demonstration of the sheer power of generators.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  pull()
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">pull</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">let</span> question = <mark class="md-mark md-code-mark">g.next()</mark>
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">return</span>
    }
    ask(question.value, pull)
  }
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ask</span> <span class="md-code-params">(q, next)</span> </span>{
    <mark class="md-mark md-code-mark">xhr(<span class="md-code-string">'https://computer.genie/?q='</span> + <span class="md-code-built_in">encodeURIComponent</span>(q), got)</mark>
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">got</span> <span class="md-code-params">(err, res, body)</span> </span>{
      <span class="md-code-keyword">if</span> (err) {
        <span class="md-code-comment">// todo</span>
      }
      <span class="md-code-built_in">console</span>.log(q)
      <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + body.answer)
      next()
    }
  }
}
</code></pre><p><sub>See <a aria-label="Babel REPL of async generator for genie responses" href="http://buff.ly/1UimWsZ">this link for a live demo</a> on the Babel REPL</sub></p><p>Even though we've just made our <code class="md-code md-code-inline">genie</code> method asynchronous and are now using an API to fetch responses to the user's questions, the way the consumer uses the <code class="md-code md-code-inline">genie</code> library by passing a <code class="md-code md-code-inline">questions</code> generator function <em>remains unchanged!</em> That's awesome.</p><p>We haven't handled the case for an <code class="md-code md-code-inline">err</code> coming out of the API. That's inconvenient. What can we do about that one?</p><h3 id="throwing-at-a-generator">Throwing <em>at</em> a Generator</h3><p>Now that we've figured out that the most important aspect of generators is <em>actually the control flow code</em> that decides when to call <code class="md-code md-code-inline">g.next()</code>, we can look at the other two methods and actually understand their purpose. Before shifting our thinking into <em>"the generator defines <strong>what</strong> to iterate over, not the <strong>how</strong>"</em>, we would've been hard pressed to find a user case for <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">g.throw</code></a>. Now however it seems immediately obvious. The flow control that leverages a generator needs to be able to tell the generator that's yielding the sequence to be iterated when something goes wrong processing an item in the sequence.</p><p>In the case of our <code class="md-code md-code-inline">genie</code> flow, that is now using <a aria-label="Raynos/xhr on GitHub" href="https://github.com/Raynos/xhr"><code class="md-code md-code-inline">xhr</code></a>, we may experience network issues and be unable to continue processing items, or we may want to warn the user about unexpected errors. Here's how, we simply add <code class="md-code md-code-inline">g.throw(error)</code> in our control flow code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">genie</span> <span class="md-code-params">(questions)</span> </span>{
  <span class="md-code-keyword">var</span> g = questions()
  pull()
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">pull</span> <span class="md-code-params">()</span> </span>{
    <span class="md-code-keyword">let</span> question = g.next()
    <span class="md-code-keyword">if</span> (question.done) {
      <span class="md-code-keyword">return</span>
    }
    ask(question.value, pull)
  }
  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ask</span> <span class="md-code-params">(q, next)</span> </span>{
    xhr(<span class="md-code-string">'https://computer.genie/?q='</span> + <span class="md-code-built_in">encodeURIComponent</span>(q), got)
    <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">got</span> <span class="md-code-params">(err, res, body)</span> </span>{
      <span class="md-code-keyword">if</span> (err) {
        <mark class="md-mark md-code-mark">g.throw(err)</mark>
      }
      <span class="md-code-built_in">console</span>.log(q)
      <span class="md-code-built_in">console</span>.log(<span class="md-code-string">'[Genie] '</span> + body.answer)
      next()
    }
  }
}
</code></pre><p>The <em>user code</em> is still unchanged, though. In between <code class="md-code md-code-inline">yield</code> statements it may throw errors now. You could use <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> blocks to address those issues. If you do this, execution will be able to resume. The good thing is that this is up to the user, it's still perfectly sequential on their end, and they can leverage <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> semantics just like in high-school.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">questions</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] Will ES6 die a painful death?'</span>
  } <span class="md-code-keyword">catch</span> (e) {
    <span class="md-code-built_in">console</span>.error(<span class="md-code-string">'Error'</span>, e.message)
  }
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-string">'[Me] How youuu doing?'</span>
  } <span class="md-code-keyword">catch</span> (e) {
    <span class="md-code-built_in">console</span>.error(<span class="md-code-string">'Error'</span>, e.message)
  }
})
</code></pre><h3 id="returning-on-behalf-of-a-generator">Returning on Behalf of a Generator</h3><p>Usually not as interesting in asynchronous control flow mechanisms in general, the <a aria-label="Generator.prototype.return() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return"><code class="md-code md-code-inline">g.return()</code></a> method allows you to resume execution inside a generator function, much like <a aria-label="Generator.prototype.throw() on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw"><code class="md-code md-code-inline">g.throw()</code></a> did moments earlier. The key difference is that <code class="md-code md-code-inline">g.return()</code> won't result in an exception at the generator level, although <strong>it will end the sequence.</strong></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">3</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">g.return()</mark>)
<span class="md-code-comment">// &lt;- { done: true }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }, <mark class="md-mark md-code-mark">as we know</mark></span>
</code></pre><p>You could also return a <code class="md-code md-code-inline">value</code> using <code class="md-code md-code-inline">g.return(value)</code>, and the resulting <code class="md-code md-code-inline">IteratorResult</code> will contain said <code class="md-code md-code-inline">value</code>. This is equivalent to having <code class="md-code md-code-inline">return value</code> somewhere in the generator function. You should be careful there though &ndash; as neither <code class="md-code md-code-inline">for..of</code>, <code class="md-code md-code-inline">[...generator()]</code>, nor <code class="md-code md-code-inline">Array.from(generator())</code> include the <code class="md-code md-code-inline">value</code> in the <code class="md-code md-code-inline">IteratorResult</code> that signals <code class="md-code md-code-inline">{ done: true }</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <mark class="md-mark md-code-mark">return <span class="md-code-number">3</span></mark>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
}
<span class="md-code-built_in">console</span>.log([...numbers()])
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">[1, 2]</mark></span>
<span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Array</span>.from(numbers()))
<span class="md-code-comment">// &lt;- [1, 2]</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> n of numbers()) {
  <span class="md-code-built_in">console</span>.log(n)
  <span class="md-code-comment">// &lt;- 1</span>
  <span class="md-code-comment">// &lt;- 2</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 2 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 3</mark> }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><p>Using <code class="md-code md-code-inline">g.return</code> is no different in this regard, think of it as the programmatic equivalent of what we just did.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  <span class="md-code-keyword">return</span> <span class="md-code-number">3</span>
  <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.return(<span class="md-code-number">5</span>))
<span class="md-code-comment">// &lt;- { done: true, value: 5 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true }</span>
</code></pre><p>You can avoid the impending sequence termination, <a aria-label="ES6 generators in depth by Dr. Axel Rauschmayer" href="http://www.2ality.com/2015/03/es6-generators.html">as Axel points out</a>, if the code in the generator function when <code class="md-code md-code-inline">g.return()</code> got called is wrapped in <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">finally</code>. Once the <code class="md-code md-code-inline">yield</code> expressions in the <code class="md-code md-code-inline">finally</code> block are over, the sequence <em>will</em> end with the <code class="md-code md-code-inline">value</code> passed to <code class="md-code md-code-inline">g.return(value)</code></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span>* <span class="md-code-title">numbers</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">yield</span> <span class="md-code-number">1</span>
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-number">2</span>
  } <span class="md-code-keyword">finally</span> {
    <span class="md-code-keyword">yield</span> <span class="md-code-number">3</span>
    <span class="md-code-keyword">yield</span> <span class="md-code-number">4</span>
  }
  <span class="md-code-keyword">yield</span> <span class="md-code-number">5</span>
}
<span class="md-code-keyword">var</span> g = numbers()
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 1 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 2 }</span>
<span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">g.return(<span class="md-code-number">6</span>)</mark>)
<span class="md-code-comment">// &lt;- { done: false, value: 3 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: false, value: 4 }</span>
<span class="md-code-built_in">console</span>.log(g.next())
<span class="md-code-comment">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 6</mark> }</span>
</code></pre><p>That's all there is to know when it comes to generators <em>in terms of functionality.</em></p><h2 id="use-cases-for-es6-generators">Use Cases for ES6 Generators</h2><p>At this point in the article you should feel comfortable with the concepts of iterators, iterables, and generators in ES6. If you feel like reading more on the subject, I highly recommend you go over <a aria-label="ES6 generators in depth by Dr. Axel Rauschmayer" href="http://www.2ality.com/2015/03/es6-generators.html">Axel's article on generators</a>, as he put together an amazing write-up on use cases for generators just <em>a few months ago</em>.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Arrow Functions in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>The daily saga of <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">es6-in-depth</a> articles continues. Today we'll be discussing Arrow Functions. In previous articles we've covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a> and <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>. I strive to cover <em>all the things</em> when it comes to the ES6 feature-set &ndash; and eventually we'll move onto ES7. I find that writing about these features makes it way easier for them to become <strong>engraved in my skull</strong> as well.</p><p>Since you're reading these articles, I suggest you <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel and <code class="md-code md-code-inline">babel-node</code></a>, and follow along by copying the self-contained examples into a file. You can then run them using <code class="md-code md-code-inline">babel-node yourfile</code> in the terminal. Running these examples on your own and maybe tweaking them a little bit <strong>will help you better internalize these new features</strong> &ndash; even if you're just adding <code class="md-code md-code-inline">console.log</code> statements to figure out what's going on.</p><blockquote><p>Now onto the topic of the day.</p></blockquote><p>We've already kind of went over <em>arrow functions</em> in previous articles, using them in passing without a lot of explaining going on. This article will focus mainly in arrow functions and keep the rest of ES6 in the back burner. I think that's the best way to write about ES6 &ndash; making a single feature "stand out" in each article, and gradually adding the others and interconnecting the different concepts so that we can understand <em>how they interact together</em>. I've observed <strong>a lot of synergy</strong> in ES6 features, which is <em>awesome</em>. It's still important to make a gradual dive into ES6 syntax and features and not jump into the water as it's warming up, because otherwise you'll have a bad time adjusting to the new temperature &ndash; that was probably a bad analogy, moving on.</p></section>
		<section class="md-markdown at-body"><h2 id="using-arrow-functions-in-javascript">Using Arrow Functions in JavaScript</h2><p>Arrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they're now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it's nice to have a terse alternative.</p><p>Here's how the syntax looks like if we have a single argument and just want to return the results for an expression.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(num =&gt; num * <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>The ES5 equivalent would be as below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(num)</span> </span>{ <span class="md-code-keyword">return</span> num * <span class="md-code-number">2</span> })
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>If we need to declare more arguments <em>(or no arguments)</em>, we'll have to use parenthesis.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; num * <span class="md-code-number">2</span> + index)
<span class="md-code-comment">// &lt;- [2, 5, 8, 11]</span>
</code></pre><p>You might want to have some other statements and not just an expression to return. In this case you'll have to use bracket notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map(num =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + num
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [3, 8, 15, 24]</span>
</code></pre><p>You could also add more arguments with the parenthesis syntax here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>].map((num, index) =&gt; {
  <span class="md-code-keyword">var</span> multiplier = <span class="md-code-number">2</span> + index
  <span class="md-code-keyword">return</span> num * multiplier
})
<span class="md-code-comment">// &lt;- [2, 6, 12, 20]</span>
</code></pre><p>At that point, however, chances are you'd be better off using a named function declaration for a number of reasons.</p><ul><li><code class="md-code md-code-inline">(num, index) =&gt;</code> is only marginally shorter than <code class="md-code md-code-inline">function (num, index)</code></li><li>The <code class="md-code md-code-inline">function</code> form allows you to name the method, improving code quality</li><li>When a function has multiple arguments and multiple statements, I'd say it's improbable that six extra characters will make a difference</li><li>However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile</li></ul><p>Moving on, if we need to return an object literal, we'll have to wrap the expression in parenthesis. That way the object literal won't be interpreted as a statement block (which would result in a silent error or worse, a <strong>syntax error</strong> because <code class="md-code md-code-inline">number: n</code> isn't a valid expression in the example below. The first example interprets <code class="md-code md-code-inline">number</code> as a label and then figures out we have an <code class="md-code md-code-inline">n</code> expression. Since we're in a block and not returning anything, the mapped values will be <code class="md-code md-code-inline">undefined</code>. In the second case, after the label and the <code class="md-code md-code-inline">n</code> expression, <code class="md-code md-code-inline">, something: 'else'</code> makes no sense to the compiler, and a <code class="md-code md-code-inline">SyntaxError</code> is thrown.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n })
<span class="md-code-comment">// [undefined, undefined, undefined]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; { number: n, something: <span class="md-code-string">'else'</span> })
<span class="md-code-comment">// &lt;- SyntaxError</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n }))
<span class="md-code-comment">// &lt;- [{ number: 1 }, { number: 2 }, { number: 3 }]</span>
[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>].map(n =&gt; ({ number: n, something: <span class="md-code-string">'else'</span> }))
<span class="md-code-comment">/* &lt;- [
  { number: 1, something: 'else' },
  { number: 2, something: 'else' },
  { number: 3, something: 'else' }]
*/</span>
</code></pre><p>A cool aspect of arrow functions in ES6 is that they're bound to their lexical scope. That means that you can say goodbye to <code class="md-code md-code-inline">var self = this</code> and similar hacks <em>&ndash; such as using <code class="md-code md-code-inline">.bind(this)</code> &ndash;</em> to preserve the context from within deeply nested methods.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Timer</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.seconds = <span class="md-code-number">0</span>
  setInterval(() =&gt; <span class="md-code-keyword">this</span>.seconds++, <span class="md-code-number">1000</span>)
}
<span class="md-code-keyword">var</span> timer = <span class="md-code-keyword">new</span> Timer()
setTimeout(() =&gt; <span class="md-code-built_in">console</span>.log(timer.seconds), <span class="md-code-number">3100</span>)
<span class="md-code-comment">// &lt;- 3</span>
</code></pre><p>Keep in mind that the lexical <code class="md-code md-code-inline">this</code> binding in ES6 arrow functions means that <code class="md-code md-code-inline">.call</code> and <code class="md-code md-code-inline">.apply</code> won't be able to change the context. Usually however, that's more of a feature than a bug.</p><h2 id="conclusions">Conclusions</h2><p>Arrow functions are neat when it comes to defining anonymous functions that should probably be <em>lexically bound anyways</em>, and they can definitely make your code more terse in some situations.</p><p>There's no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I'm a big proponent of named function declarations, because they improve readability of the codebase without the need for comments &ndash; which means I'll have <em>"a hard time"</em> adopting arrow functions in most situations.</p><p>That being said, I think arrow functions are particularly useful in most functional programming situations such as when using <code class="md-code md-code-inline">.map</code>, <code class="md-code md-code-inline">.filter</code>, or <code class="md-code md-code-inline">.reduce</code> on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.</p></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Maps in Depth</h1>
<section class="md-markdown at-teaser" itemprop="about"><p>Hello, this is <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 &ndash; <em>"Please make them stop"</em> &ndash; in Depth</a>. New here? Start with <a aria-label="A Brief History of ES6 Tooling on Pony Foo" href="/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a aria-label="ES6 Classes in Depth on Pony Foo" href="/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a aria-label="ES6 Let, Const and the "Temporal Dead Zone" (TDZ) in Depth on Pony Foo" href="/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>"Temporal Dead Zone"</em></a>, <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a>, <a aria-label="ES6 Generators in Depth on Pony Foo" href="/articles/es6-generators-in-depth">generators</a>, and <a aria-label="ES6 Symbols in Depth on Pony Foo" href="/articles/es6-symbols-in-depth">Symbols</a>. Today we'll be discussing a new collection data structure objects coming in ES6 &ndash; I'm talking about <code class="md-code md-code-inline">Map</code>.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that's also quite useful is to use Babel's <a aria-label="Babel Online REPL" href="http://babeljs.io/repl/">online REPL</a> <em>&ndash; it'll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote><p>Before getting into it, let me <a aria-label="Support Pony Foo on Patreon" href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you're enjoying my <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p><p>Thanks for reading that, and let's go into collections now! For a bit of context, you may want to check out the article on <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth">iterators</a> <em>&ndash; which are closely related to ES6 collections &ndash;</em> and the one on <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread and rest parameters</a>.</p><p>Now, let's start with <code class="md-code md-code-inline">Map</code>. I moved the rest of the ES6 collections to tomorrow's publication in order to keep the series sane, as otherwise this would've been too long for a single article!</p></section>
<section class="md-markdown at-body"><h1 id="before-es6-there-were-hash-maps">Before ES6, There Were Hash-Maps</h1><p>A very common <em>ab</em>use case of JavaScript objects is hash-maps, where we map string keys to arbitrary values. For example, one might use an object to map <code class="md-code md-code-inline">npm</code> package names to their metadata, like so:</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> registry = {}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span> <span class="md-code-params">(name, meta)</span> </span>{
  registry[name] = meta
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">get</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">return</span> registry[name]
}
add(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
add(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
add(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>There's several issues with this approach, to wit:</p><ul><li><strong>Security issues</strong> where user-provided keys like <code class="md-code md-code-inline">__proto__</code>, <code class="md-code md-code-inline">toString</code>, or anything in <code class="md-code md-code-inline">Object.prototype</code> break expectations and make interaction with these kinds of <em>hash-map</em> data structures more cumbersome</li><li>Iteration over list items is verbose with <code class="md-code md-code-inline">Object.keys(registry).forEach</code> or implementing the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> on the <code class="md-code md-code-inline">registry</code></li><li>Keys are limited to strings, making it hard to create hash-maps where you'd like to index values by DOM elements or other non-string references</li></ul><p>The first problem could be fixed using a prefix, and being careful to always get or set values in the hash-map through methods. It would be even better to use <a aria-label="Proxy Objects in ES6 on MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy">ES6 proxies</a>, but we <em>won't be covering those until tomorrow!</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> registry = {}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span> <span class="md-code-params">(name, meta)</span> </span>{
  registry[<mark class="md-mark md-code-mark"><span class="md-code-string">'map:'</span> + </mark>name] = meta
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">get</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">return</span> registry[<mark class="md-mark md-code-mark"><span class="md-code-string">'map:'</span> + </mark>name]
}
add(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
add(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
add(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>Luckily for us, though, <em>ES6 maps</em> provide us with an even better solution to the key-naming security issue. At the same time they facilitate collection behaviors out the box that may also come in handy. Let's plunge into their practical usage and inner workings.</p><h1 id="es6-maps">ES6 Maps</h1><p>Map is a key/value data structure in ES6. It provides a better data structure to be used for hash-maps. Here's how what we had earlier looks like with ES6 maps.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <mark class="md-mark md-code-mark">new Map()</mark>
<mark class="md-mark md-code-mark">map.set</mark>(<span class="md-code-string">'contra'</span>, { description: <span class="md-code-string">'Asynchronous flow control'</span> })
map.set(<span class="md-code-string">'dragula'</span>, { description: <span class="md-code-string">'Drag and drop'</span> })
map.set(<span class="md-code-string">'woofmark'</span>, { description: <span class="md-code-string">'Markdown and WYSIWYG editor'</span> })
</code></pre><p>One of the important differences is also that you're able to use anything for the keys. You're not just limited to primitive values like symbols, numbers, or strings, but you can even use functions, objects and dates &ndash; too. Keys won't be casted to strings like with regular objects, either.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{})
map.set(() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> })
map.set(Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>])
</code></pre><p>You can also provide <code class="md-code md-code-inline">Map</code> objects with any object that follows the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> and produces a collection such as <code class="md-code md-code-inline">[['key', 'value'], ['key', 'value']]</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([
  [<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{}],
  [() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> }],
  [Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]]
])
</code></pre><p>The above would be effectively the same as the following. Note how we're using destructuring in the parameters of <code class="md-code md-code-inline">items.forEach</code> to <em>effortlessly</em> pull the <code class="md-code md-code-inline">key</code> and <code class="md-code md-code-inline">value</code> out of the two-dimensional <code class="md-code md-code-inline">item</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> items = [
  [<span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>(), <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">today</span> <span class="md-code-params">()</span> </span>{}],
  [() =&gt; <span class="md-code-string">'key'</span>, { pony: <span class="md-code-string">'foo'</span> }],
  [Symbol(<span class="md-code-string">'items'</span>), [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>]]
]
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
items.forEach((<mark class="md-mark md-code-mark">[key, value]</mark>) =&gt; map.set(key, value))
</code></pre><p>Of course, it's kind of silly to go through the trouble of adding items one by one when you can just feed an iterable to your <code class="md-code md-code-inline">Map</code>. Speaking of iterables &ndash; <code class="md-code md-code-inline">Map</code> adheres to the <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><em>iterable</em></a> protocol. It's very easy to pull a key-value pair collection much like the ones you can feed to the <code class="md-code md-code-inline">Map</code> constructor.</p><p>Naturally, we can use the spread operator to this effect.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>)
map.set(<span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'o'</span>, <span class="md-code-string">'!'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [['p', 'o'], ['n', 'y'], ['f', 'o'], ['o', '!']]</span>
</code></pre><p>You could also use a <code class="md-code md-code-inline">for..of</code> loop, and we could combine that with <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a> to make it seriously terse. Also, remember <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>?</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'p'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'n'</span>, <span class="md-code-string">'y'</span>)
map.set(<span class="md-code-string">'f'</span>, <span class="md-code-string">'o'</span>)
map.set(<span class="md-code-string">'o'</span>, <span class="md-code-string">'!'</span>)
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> <mark class="md-mark md-code-mark">[key, value]</mark> of map) {
  <span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">`${key}: ${value}`</mark>)
  <span class="md-code-comment">// &lt;- 'p: o'</span>
  <span class="md-code-comment">// &lt;- 'n: y'</span>
  <span class="md-code-comment">// &lt;- 'f: o'</span>
  <span class="md-code-comment">// &lt;- 'o: !'</span>
}
</code></pre><p>Even though maps have a programmatic API to add items, keys are unique, just like with hash-maps. Setting a key over and over again will only overwrite its value.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'a'</span>)
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'b'</span>)
map.set(<span class="md-code-string">'a'</span>, <span class="md-code-string">'c'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [['a', 'c']]</span>
</code></pre><p>In ES6 <code class="md-code md-code-inline">Map</code>, <code class="md-code md-code-inline">NaN</code> becomes a "corner-case" that gets <strong>treated as a value that's equal to itself</strong> even though the following expression actually evaluates to <code class="md-code md-code-inline">true</code> &ndash; <code class="md-code md-code-inline">NaN !== NaN</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-literal">NaN</span> === <span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map()
map.set(<span class="md-code-literal">NaN</span>, <span class="md-code-string">'foo'</span>)
map.set(<span class="md-code-literal">NaN</span>, <span class="md-code-string">'bar'</span>)
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- [[NaN, 'bar']]</span>
</code></pre><h2 id="hash-maps-and-the-dom">Hash-Maps and the DOM</h2><p>In ES5, whenever we had a DOM element we wanted to associate with an API object for some library, we had to follow a verbose and slow pattern like the one below. The following piece of code just returns an API object with a bunch of methods for a given DOM element, allowing us to put and remove DOM elements from the cache, and also allowing us to retrieve the API object for a DOM element &ndash; if one already exists.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = []
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">put</span> <span class="md-code-params">(el, api)</span> </span>{
  cache.push({ el: el, api: api })
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">find</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">for</span> (i = <span class="md-code-number">0</span>; i &lt; cache.length; i++) {
    <span class="md-code-keyword">if</span> (cache[i].el === el) {
      <span class="md-code-keyword">return</span> cache[i].api
    }
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">destroy</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">for</span> (i = <span class="md-code-number">0</span>; i &lt; cache.length; i++) {
    <span class="md-code-keyword">if</span> (cache[i].el === el) {
      cache.splice(i, <span class="md-code-number">1</span>)
      <span class="md-code-keyword">return</span>
    }
  }
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = find(el)
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.bind(<span class="md-code-literal">null</span>, el)
  }
  put(el, api)
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>One of the coolest aspects of <code class="md-code md-code-inline">Map</code>, <em>as I've previously mentioned</em>, is the ability to index by DOM elements. The fact that <code class="md-code md-code-inline">Map</code> also has collection manipulation abilities also greatly simplifies things.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = <span class="md-code-keyword">new</span> Map()
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">put</span> <span class="md-code-params">(el, api)</span> </span>{
  <mark class="md-mark md-code-mark">cache.set(el, api)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">find</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">cache.get(el)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">destroy</span> <span class="md-code-params">(el)</span> </span>{
  <mark class="md-mark md-code-mark">cache.delete(el)</mark>
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = find(el)
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.bind(<span class="md-code-literal">null</span>, el)
  }
  put(el, api)
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>The fact that these methods have now become one liners means we can just inline them, as readability is no longer an issue. We just went from <em>~30 LOC</em> to <strong>half that amount</strong>. Needless to say, at some point in the future this will also perform <em>much</em> faster than the haystack alternative.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> cache = <span class="md-code-keyword">new</span> Map()
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">thing</span> <span class="md-code-params">(el)</span> </span>{
  <span class="md-code-keyword">var</span> api = <mark class="md-mark md-code-mark">cache.get(el)</mark>
  <span class="md-code-keyword">if</span> (api) {
    <span class="md-code-keyword">return</span> api
  }
  api = {
    method: method,
    method2: method2,
    method3: method3,
    destroy: () =&gt; <mark class="md-mark md-code-mark">cache.delete(el)</mark>
  }
  <mark class="md-mark md-code-mark">cache.set(el, api)</mark>
  <span class="md-code-keyword">return</span> api
}
</code></pre><p>The simplicity of <code class="md-code md-code-inline">Map</code> is amazing. If you ask me, we desperately needed this feature in JavaScript. Being to index a collection by arbitrary objects is <strong>super important</strong>.</p><blockquote><p>What else can we do with <code class="md-code md-code-inline">Map</code>?</p></blockquote><h2 id="collection-methods-in-map">Collection Methods in <code class="md-code md-code-inline">Map</code></h2><p>Maps make it very easy to probe the collection and figure out whether a <code class="md-code md-code-inline">key</code> is defined in the <code class="md-code md-code-inline">Map</code>. As we noted earlier, <code class="md-code md-code-inline">NaN</code> equals <code class="md-code md-code-inline">NaN</code> as far as <code class="md-code md-code-inline">Map</code> is concerned. However, <code class="md-code md-code-inline">Symbol</code> values are always different, so you'll have to use them by value!</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [Symbol(), <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-literal">NaN</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(Symbol()))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'foo'</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'bar'</span>))
<span class="md-code-comment">// &lt;- false</span>
</code></pre><p>As long as you keep a <code class="md-code md-code-inline">Symbol</code> reference around, you'll be okay. <em>Keep your references close, and your <code class="md-code md-code-inline">Symbol</code>s closer?</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark">var sym = Symbol()</mark>
<span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [sym, <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(sym))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre><p>Also, remember the <strong>no key-casting</strong> thing? <em>Beware!</em> We are so used to objects casting keys to strings that this may bite you if you're not careful.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-string">'a'</span>]])
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-number">1</span>))
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-string">'1'</span>))
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre><p>You can also clear a <code class="md-code md-code-inline">Map</code> entirely of entries without losing a reference to it. This can be very handy sometimes.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
map.clear()
<span class="md-code-built_in">console</span>.log(map.has(<span class="md-code-number">1</span>))
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-built_in">console</span>.log([...map])
<span class="md-code-comment">// &lt;- []</span>
</code></pre><p>When you use <code class="md-code md-code-inline">Map</code> as an iterable, you are actually looping over its <code class="md-code md-code-inline">.entries()</code>. That means that you don't need to <strong>explicitly</strong> iterate over <code class="md-code md-code-inline">.entries()</code>. It'll be done on your behalf anyways. You do remember <a aria-label="ES6 Iterators in Depth on Pony Foo" href="/articles/es6-iterators-in-depth"><code class="md-code md-code-inline">Symbol.iterator</code></a>, right?</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(map[<mark class="md-mark md-code-mark">Symbol.iterator</mark>] === map.entries)
<span class="md-code-comment">// &lt;- true</span>
</code></pre><p>Just like <code class="md-code md-code-inline">.entries()</code>, <code class="md-code md-code-inline">Map</code> has two other iterators you can leverage. These are <code class="md-code md-code-inline">.keys()</code> and <code class="md-code md-code-inline">.values()</code>. I'm sure you guessed what sequences of values they yield, but here's a code snippet anyways.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
<span class="md-code-built_in">console</span>.log([...map.keys()])
<span class="md-code-comment">// &lt;- [1, 3, 5]</span>
<span class="md-code-built_in">console</span>.log([...map.values()])
<span class="md-code-comment">// &lt;- [2, 4, 6]</span>
</code></pre><p>Maps also come with a <em>read-only</em> <code class="md-code md-code-inline">.size</code> property that behaves sort of like <code class="md-code md-code-inline">Array.prototype.length</code> &ndash; at any point in time it gives you the current amount of entries in the map.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>], [<span class="md-code-number">3</span>, <span class="md-code-number">4</span>], [<span class="md-code-number">5</span>, <span class="md-code-number">6</span>]])
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 3</span>
map.delete(<span class="md-code-number">3</span>)
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 2</span>
map.clear()
<span class="md-code-built_in">console</span>.log(map.size)
<span class="md-code-comment">// &lt;- 0</span>
</code></pre><p>One more aspect of <code class="md-code md-code-inline">Map</code> that's worth mentioning is that their entries are always iterated in <strong>insertion order</strong>. This is in contrast with <code class="md-code md-code-inline">Object.keys</code> loops which follow <a aria-label="for..in on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">an arbitrary order</a>.</p><blockquote><p>The <a aria-label="for..in on MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code class="md-code md-code-inline">for..in</code></a> statement iterates over the enumerable properties of an object, in arbitrary order.</p></blockquote><p>Maps also have a <code class="md-code md-code-inline">.forEach</code> method that's identical in <em>behavior</em> to that in ES5 <code class="md-code md-code-inline">Array</code> objects. Once again, keys do not get casted into strings here.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> map = <span class="md-code-keyword">new</span> Map([[<span class="md-code-literal">NaN</span>, <span class="md-code-number">1</span>], [Symbol(), <span class="md-code-number">2</span>], [<span class="md-code-string">'foo'</span>, <span class="md-code-string">'bar'</span>]])
map.forEach(<mark class="md-mark md-code-mark">(value, key)</mark> =&gt; <span class="md-code-built_in">console</span>.log(key, value))
<span class="md-code-comment">// &lt;- NaN 1</span>
<span class="md-code-comment">// &lt;- Symbol() 2</span>
<span class="md-code-comment">// &lt;- 'foo' 'bar'</span>
</code></pre><blockquote><p>Get up early tomorrow morning, we'll be having <a aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth on Pony Foo" href="http://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth"><code class="md-code md-code-inline">WeakMap</code>, <code class="md-code md-code-inline">Set</code>, and <code class="md-code md-code-inline">WeakSet</code></a> for breakfast :)</p></blockquote></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1>ES6 Template Literals in Depth</h1>
		<section class="md-markdown at-teaser" itemprop="about"><p>Yesterday we've covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">ES6 destructuring in depth</a>, as well as some of its most common use cases. Today we'll be moving to <strong>template literals</strong>. What they are, and how we can use them and what good they're for.</p><p>Template literals are a new feature in ES6 to make working with strings and string templates easier. You wrap your text in <code class="md-code md-code-inline">`backticks`</code> and you'll get the features described below.</p><ul><li>You can interpolate variables in them</li><li>You can actually interpolate using <em>any kind of expression</em>, not just variables</li><li>They can be <strong>multi-line</strong>. <em>Finally!</em></li><li>You can construct <em>raw templates</em> that don't interpret backslashes</li></ul><p>In addition, you can also define <em>a method</em> that will decide what to make of the template, instead of using the default templating behavior. There are some interesting use cases for this one.</p><blockquote><p>Let's dig into template literals and see what we can come up with.</p></blockquote></section>
		<section class="md-markdown at-body"><h2 id="using-template-literals">Using Template Literals</h2><p>We've already covered the basic <em><code class="md-code md-code-inline">`I'm just a string`</code></em>. One aspect of template literals that may be worth mentioning is that you're now able to declare strings with both <code class="md-code md-code-inline">'</code> and <code class="md-code md-code-inline">"</code> quotation marks in them without having to escape anything.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var text = `I'm "amazed" that we have so many quotation marks to choose from!`
</code></pre><p>That was neat, but surely there's more useful stuff we can apply template literals to. How about some <em>actual interpolation</em>? You can use the <code class="md-code md-code-inline">${expression}</code> notation for that.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> host = <span class="md-code-string">'ponyfoo.com'</span>
<span class="md-code-keyword">var</span> text = `<span class="md-code-keyword">this</span> blog lives at <mark class="md-mark md-code-mark">${host}</mark>`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre><p>I've already mentioned you can have any kind of expressions you want in <mark class="md-mark">there</mark>. Think of whatever expressions you put in there as defining a variable before the template runs, and then concatenating that value with the rest of the string. That means that variables you use, methods you call, and so on, should all be available to the current scope.</p><p>The following expressions would all work just as well. It'll be up to us to decide how much logic we cram into the interpolation expressions.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = `<span class="md-code-keyword">this</span> blog lives at ${<span class="md-code-string">'ponyfoo.com'</span>}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> today = <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
<span class="md-code-keyword">var</span> text = `the time and date is ${today.toLocaleString()}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'the time and date is 8/26/2015, 3:15:20 PM'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript">import moment from <span class="md-code-string">'moment'</span>
<span class="md-code-keyword">var</span> today = <span class="md-code-keyword">new</span> <span class="md-code-built_in">Date</span>()
<span class="md-code-keyword">var</span> text = `today is the ${moment(today).format(<span class="md-code-string">'Do [of] MMMM'</span>)}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'today is the 26th of August'</span>
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = `such ${<span class="md-code-literal">Infinity</span>/<span class="md-code-number">0</span>}, very uncertain`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'such Infinity, very uncertain'</span>
</code></pre><p>Multi-line strings mean that you no longer have to use methods like these anymore.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = (
  <span class="md-code-string">'foo\n'</span> +
  <span class="md-code-string">'bar\n'</span> +
  <span class="md-code-string">'baz'</span>
)
</code></pre><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = [
  <span class="md-code-string">'foo'</span>,
  <span class="md-code-string">'bar'</span>,
  <span class="md-code-string">'baz'</span>
].join(<span class="md-code-string">'\n'</span>)
</code></pre><p>Instead, you can now just use backticks! Note that spacing matters, so you might still want to use parenthesis in order to keep the first line of text away from the variable declaration.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = (
`foo
bar
baz`)
</code></pre><p>Multi-line strings really shine when you have, <em>for instance</em>, a chunk of HTML you want to interpolate some variables to. Much like with <a aria-label="React, JSX and ES6: The Weird Parts on Pony Foo" href="/articles/react-jsx-and-es6-the-weird-parts">JSX</a>, you're perfectly able to use an expression to iterate over a collection and <code class="md-code md-code-inline">return</code> yet another template literal to declare list items. This makes it a breeze to declare sub-components in your templates. Note also how I'm <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">using destructuring</a> to avoid having to prefix every expression of mine with <code class="md-code md-code-inline">article.</code>, I like to think of it as <em>"a <code class="md-code md-code-inline">with</code> block, but not as insane"</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> article = {
  title: <span class="md-code-string">'Hello Template Literals'</span>,
  teaser: <span class="md-code-string">'String interpolation is awesome. Here are some features'</span>,
  body: <span class="md-code-string">'Lots and lots of sanitized HTML'</span>,
  tags: [<span class="md-code-string">'es6'</span>, <span class="md-code-string">'template-literals'</span>, <span class="md-code-string">'es6-in-depth'</span>]
}
<span class="md-code-keyword">var</span> {title,teaser,body,tags} = article
<span class="md-code-keyword">var</span> html = `&lt;article&gt;
  <span><span class="md-code-tag">&lt;<span class="md-code-title">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>${title}<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>${teaser}<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>${body}<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">ul</span>&gt;</span>
      <mark class="md-mark md-code-mark">${tags.map(tag =&gt; `<span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>${tag}<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>`).join('\n      ')}</mark>
    <span class="md-code-tag">&lt;/<span class="md-code-title">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">article</span>&gt;</span>`
</span></code></pre><p>The above will produce output as shown below. Note how the spacing trick was enough to properly indent the <code class="md-code md-code-inline">&lt;li&gt;</code> tags.</p><pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="md-code-title">article</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">h1</span>&gt;</span>Hello Template Literals<span class="md-code-tag">&lt;/<span class="md-code-title">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>String interpolation is awesome. Here are some features<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>Lots and lots of sanitized HTML<span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="md-code-title">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="md-code-title">ul</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>es6<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>template-literals<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">li</span>&gt;</span>es6-in-depth<span class="md-code-tag">&lt;/<span class="md-code-title">li</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="md-code-title">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="md-code-title">article</span>&gt;</span>
</code></pre><p>Raw templates are the same in essence, you just have to prepend your template literal with <code class="md-code md-code-inline">String.raw</code>. This can be very convenient in some use cases.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">var text = String.raw`The "\n" newline won't result in a new line.
It'll be escaped.`
console.log(text)
// The "\n" newline won't result in a new line.
// It'll be escaped.
</code></pre><p>You might've noticed that <code class="md-code md-code-inline">String.raw</code> seems to be a special part of the template literal syntax, and you'd be right! The method you choose will be used to parse the template. Template literal methods &ndash; called <em>"tagged templates"</em> &ndash; receive an array containing a list of the static parts of the template, as well as each expression on their own variables.</p><p>For instance a template literal like <code class="md-code md-code-inline">`hello ${name}. I am ${emotion}!`</code> will pass arguments to the <em>"tagged template"</em> in a function call like the one below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">fn([<span class="md-code-string">'hello '</span>, <span class="md-code-string">'. I am'</span>, <span class="md-code-string">'!'</span>], <span class="md-code-string">'nico'</span>, <span class="md-code-string">'confused'</span>)
</code></pre><p>You might be confused by the seeming oddity in which the arguments are laid out, but they start to make sense when you think of it this way: for every item in the template array, there's an expression result after it.</p><h2 id="demystifying-tagged-templates">Demystifying Tagged Templates</h2><p>I wrote an example <code class="md-code md-code-inline">normal</code> method below, and it works <em>exactly like the default behavior</em>. This might help you better understand what happens under the hood for template literals.</p><blockquote><p>If you don't know what <code class="md-code md-code-inline">.reduce</code> does, refer to <a aria-label="Array.prototype.reduce() &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN</a> or my <a aria-label="Computing with .reduce, .reduceRight on Pony Foo" href="/articles/fun-with-native-arrays#computing-with-reduce-reduceright">"Fun with Native Arrays"</a> article. Reduce is always useful when you're trying to map a collection of values into a single value that can be computed from the collection.</p></blockquote><p>In this case we can reduce the <code class="md-code md-code-inline">template</code> starting from <code class="md-code md-code-inline">template[0]</code> and then reducing all other parts by adding the preceding <code class="md-code md-code-inline">expression</code> and the subsequent <code class="md-code md-code-inline">part</code>. Note that I would've used <code class="md-code md-code-inline">template.shift()</code> for the initial value of the reducer <em>(thus avoiding the <code class="md-code md-code-inline">.slice(1)</code> call)</em>, but Babel seals the <code class="md-code md-code-inline">template</code> so we can't mutate it.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">normal</span> <span class="md-code-params">(template, <mark class="md-mark md-code-mark">...expressions</mark>)</span> </span>{
  <span class="md-code-keyword">return</span> template.slice(<span class="md-code-number">1</span>).reduce((accumulator, part, i) =&gt; {
    <span class="md-code-keyword">return</span> accumulator + expressions[i] + part
  }, template[<span class="md-code-number">0</span>])
}
</code></pre><p>The <code class="md-code md-code-inline">...expressions</code> syntax is new in ES6 as well. It's called the <a aria-label="Rest parameters in ES6 &ndash; MDN" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters"><em>"rest parameters syntax"</em></a>, and it'll basically place all the arguments passed to <code class="md-code md-code-inline">normal</code> that come after <code class="md-code md-code-inline">template</code> into a single array. You can try the tagged template as seen below, and you'll notice you get the same output as if you omitted <code class="md-code md-code-inline">normal</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> name = <span class="md-code-string">'nico'</span>
<span class="md-code-keyword">var</span> outfit = <span class="md-code-string">'leather jacket'</span>
<span class="md-code-keyword">var</span> text = <mark class="md-mark md-code-mark">normal</mark>`hello ${name}, you look lovely today <span class="md-code-keyword">in</span> that ${outfit}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'hello nico, you look lovely today in that leather jacket'</span>
</code></pre><p>Now that we've figured out how tagged templates work, what can we do with them? Well, whatever we want. One possible use case might be to make user input uppercase, turning our greeting into something that sounds more satirical &ndash; <em>I read the result out loud in my head with Gob's voice from Arrested Development, now I'm laughing alone. I've made a huge mistake</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">upperExpr</span> <span class="md-code-params">(template, ...expressions)</span> </span>{
  <span class="md-code-keyword">return</span> template.slice(<span class="md-code-number">1</span>).reduce((accumulator, part, i) =&gt; {
    <span class="md-code-keyword">return</span> accumulator + expressions[i].toUpperCase() + part
  }, template[<span class="md-code-number">0</span>])
}
<span class="md-code-keyword">var</span> name = <span class="md-code-string">'nico'</span>
<span class="md-code-keyword">var</span> outfit = <span class="md-code-string">'leather jacket'</span>
<span class="md-code-keyword">var</span> text = <mark class="md-mark md-code-mark">upperExpr</mark>`hello ${name}, you look lovely today <span class="md-code-keyword">in</span> that ${outfit}`
<span class="md-code-built_in">console</span>.log(text)
<span class="md-code-comment">// &lt;- 'hello NICO, you look lovely today in that LEATHER JACKET'</span>
</code></pre><p>There's obviously much more useful use cases for tagged templates than laughing at yourself. In fact, you could go crazy with tagged templates. A decidedly useful use case would be to sanitize user input in your templates automatically. Given a template where all expressions are considered user-input, we could use <a aria-label="bevacqua/insane on GitHub" href="https://github.com/bevacqua/insane"><code class="md-code md-code-inline">insane</code></a> to sanitize them out of HTML tags we dislike.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">import insane from 'insane'
function sanitize (template, ...expressions) {
  return template.slice(1).reduce((accumulator, part, i) =&gt; {
    return accumulator + <mark class="md-mark md-code-mark">insane</mark>(expressions[i]) + part
  }, template[0])
}
var comment = 'haha xss is so easy <mark class="md-mark md-code-mark">&lt;iframe src="http://evil.corp"&gt;&lt;/iframe&gt;</mark>'
var html = <mark class="md-mark md-code-mark">sanitize</mark>`&lt;div&gt;${comment}&lt;/div&gt;`
console.log(html)
// &lt;- '&lt;div&gt;haha xss is so easy &lt;/div&gt;'
</code></pre><p><em>Not so easy now!</em></p><blockquote><p>I can definitely see a future where the only strings I use in JavaScript begin and finish with a backtick.</p></blockquote></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Spread and Butter in Depth</h1>
<section class="at-corpus" itemprop="articleBody"><section class="md-markdown at-teaser" itemprop="about"><p>Welcome to yet another installment of <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> on Pony Foo. Previous ones covered <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, and most recently, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>. Today we'll cover a few more features coming in ES6. Those features are <em>rest parameters, the spread operator, and default parameters.</em></p><p>We've already covered some of this when we talked <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">about destructuring</a>, which supports default values as a nod to the <strong>synergy in ES6 features</strong> I've <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">mentioned yesterday</a>. This article might end up being a tad shorter than the rest because there's not so much to say about these rather simple features. However, and like I've mentioned in the first article of the <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a> series, the simplest features are usually <a aria-label="Destructuring on Pony Foo" href="/articles/es6-destructuring-in-depth#destructuring">the most useful</a> as well. Let's get on with it!</p></section><section class="md-markdown at-body"><h2 id="rest-parameters">Rest parameters</h2><p>You know how sometimes there's a ton of arguments and you end up having to use the <code class="md-code md-code-inline">arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>).join(<span class="md-code-string">' '</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">'this'</span>, <span class="md-code-string">'was'</span>, <span class="md-code-string">'no'</span>, <span class="md-code-string">'fun'</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- 'this was no fun'</span>
</code></pre><p>The rest parameters syntax enables you to pull a real <code class="md-code md-code-inline">Array</code> out of the <code class="md-code md-code-inline">function</code>‘s arguments by adding a parameter name prefixed by <code class="md-code md-code-inline">...</code>. Definitely simpler, the fact that it's a real <code class="md-code md-code-inline">Array</code> is also very convenient, and I for one am glad not to have to resort to <code class="md-code md-code-inline">arguments</code> anymore.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">concat</span> <span class="md-code-params">(...words)</span> </span>{
  <span class="md-code-keyword">return</span> words.join(<span class="md-code-string">' '</span>)
}
<span class="md-code-keyword">var</span> result = concat(<span class="md-code-string">'this'</span>, <span class="md-code-string">'is'</span>, <span class="md-code-string">'okay'</span>)
<span class="md-code-built_in">console</span>.log(result)
<span class="md-code-comment">// &lt;- 'this is okay'</span>
</code></pre><p>When you have more parameters in your <code class="md-code md-code-inline">function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p><ul><li>Rest parameter gets all the <code class="md-code md-code-inline">arguments</code> passed to the function call</li><li>Each time a parameter is added on the left, it's as if its value is assigned by calling <code class="md-code md-code-inline">rest.shift()</code></li><li>Note that you can't actually place parameters to the right: rest parameters can only be the last argument</li></ul><p>It's easier to visualize how that would behave than try to put it into words, so let's do that. The method below computes the <code class="md-code md-code-inline">sum</code> for all <code class="md-code md-code-inline">arguments</code> except the first one, which is then used as a <code class="md-code md-code-inline">multiplier</code> for the <code class="md-code md-code-inline">sum</code>. In case you don't recall, <code class="md-code md-code-inline">.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">var</span> numbers = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>) <span class="md-code-comment">// numbers gets all arguments</span>
  <mark class="md-mark md-code-mark">var multiplier = numbers.shift()</mark>
  <mark class="md-mark md-code-mark">var base = numbers.shift()</mark>
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre><p>Here's how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don't need to use <code class="md-code md-code-inline">arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method &ndash; which now can focus on its functionality itself and not so much on rebalancing <code class="md-code md-code-inline">arguments</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(multiplier, base, <mark class="md-mark md-code-mark">...numbers</mark>)</span> </span>{
  <span class="md-code-keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)
  <span class="md-code-keyword">return</span> multiplier * sum
}
<span class="md-code-keyword">var</span> total = sum(<span class="md-code-number">2</span>, <span class="md-code-number">6</span>, <span class="md-code-number">10</span>, <span class="md-code-number">8</span>, <span class="md-code-number">9</span>)
<span class="md-code-built_in">console</span>.log(total)
<span class="md-code-comment">// &lt;- 66</span>
</code></pre><h2 id="spread-operator">Spread Operator</h2><p>Typically you invoke a function by passing arguments into it.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>Sometimes however you have those arguments in a list and just don't want to access every index just for a method call <em>&ndash; or you just can't because the array is formed dynamically &ndash;</em> so you use <code class="md-code md-code-inline">.apply</code>. This feels kind of awkward because <code class="md-code md-code-inline">.apply</code> also takes a context for <code class="md-code md-code-inline">this</code>, which feels out of place when it's not relevant and you have to reiterate the host object <em>(or use <code class="md-code md-code-inline">null</code>)</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log.apply(<span class="md-code-built_in">console</span>, [<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>The spread operator can be used as <em>a butter knife</em> alternative over using <code class="md-code md-code-inline">.apply</code>. There is no need for a context either. You just append three dots <code class="md-code md-code-inline">...</code> to the array, just like with the rest parameter.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">...</mark>[<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>])
<span class="md-code-comment">// &lt;- '1 2 3'</span>
</code></pre><p>As we'll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that's an <em>iterable</em>. This encompasses even things like the results of <code class="md-code md-code-inline">document.querySelectorAll('div')</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript">[...document.querySelectorAll(<span class="md-code-string">'div'</span>)]
<span class="md-code-comment">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>
</code></pre><p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they'll be spread over the function call exactly how you'd expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-number">1</span>, ...[<span class="md-code-number">2</span>, <span class="md-code-number">3</span>, <span class="md-code-number">4</span>], <span class="md-code-number">5</span>) <span class="md-code-comment">// becomes `console.log(1, 2, 3, 4, 5)`</span>
<span class="md-code-comment">// &lt;- '1 2 3 4 5'</span>
</code></pre><p>Time for a real-world example. I sometimes use the method below in Express applications to allow <a aria-label="expressjs/morgan on GitHub" href="https://github.com/expressjs/morgan"><code class="md-code md-code-inline">morgan</code></a> <em>(the request logger in Express)</em> stream its messages through <a aria-label="winstonjs/winston on GitHub" href="https://github.com/winstonjs/winston"><code class="md-code md-code-inline">winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code class="md-code md-code-inline">message</code> because <code class="md-code md-code-inline">winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code class="md-code md-code-inline">pid</code> into the arguments list, and then I <code class="md-code md-code-inline">.apply</code> everything on the <code class="md-code md-code-inline">winston</code> logging mechanism. If you take a close look at the code, the only line of code that's actually doing anything is the one I've highlighted in yellow, the rest is just playing around with <code class="md-code md-code-inline">arguments</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
      <span class="md-code-keyword">var</span> bits = <span class="md-code-built_in">Array</span>.prototype.slice.call(<span class="md-code-built_in">arguments</span>)
      <span class="md-code-keyword">var</span> message = bits.shift().replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>) <span class="md-code-comment">// remove trailing breaks</span>
      bits.unshift(message)
      bits.push({ hostname: os.hostname(), pid: process.pid })
      <mark class="md-mark md-code-mark">winston[level].apply(winston, bits)</mark>
    }
  }
}
app.use(morgan(<span class="md-code-string">':status :method :url'</span>, {
  stream: createWriteStream(<span class="md-code-string">'debug'</span>)
}))
</code></pre><p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code class="md-code md-code-inline">arguments</code>. The rest parameter already gives us a true array, so there's no casting involved either. We can grab the <code class="md-code md-code-inline">message</code> directly as the first parameter, and we can then apply everything on <code class="md-code md-code-inline">winston[level]</code> directly by combining normal arguments with the rest of the <code class="md-code md-code-inline">...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we're trying to accomplish, which is call <code class="md-code md-code-inline">winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> &ndash; <em>the method stopped being about the code we were trying to write.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, <mark class="md-mark md-code-mark">...bits</mark>)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), <mark class="md-mark md-code-mark">...bits</mark>, {
        hostname: os.hostname(), pid: process.pid
      })
    }
  }
}
</code></pre><p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won't change for the lifespan of the process. We could've done that in the ES5 code too, though.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(message, ...bits)</span> </span>{
      winston[level](message.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), ...bits, proc)
    }
  }
}
</code></pre><p>Another thing we could do to shorten that piece of code might be to use <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You'd have to shorten <code class="md-code md-code-inline">message</code> to <code class="md-code md-code-inline">msg</code> so that it fits in a single line, and the call to <code class="md-code md-code-inline">winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn't</em> spent the last 15 minutes thinking about the method <em>&ndash; be it a team mate or yourself the week after you wrote this function.</em></p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> proc = { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">createWriteStream</span> <span class="md-code-params">(level)</span> </span>{
  <span class="md-code-keyword">return</span> {
    write: (msg, ...bits) =&gt; winston[level](msg.replace(<span class="md-code-regexp">/\n+$/</span>, <span class="md-code-string">''</span>), ...bits, proc)
  }
}
</code></pre><p>It would be wiser to just keep our earlier version. While it's <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It's up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you're actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p><p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">while destructuring</a>, in which case it works sort of like <code class="md-code md-code-inline">...rest</code> did, and a use case that's not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code class="md-code md-code-inline">.apply</code> when using the <code class="md-code md-code-inline">new</code> operator as well.</p><table><thead><tr><th>Use Case</th><th>ES5</th><th>ES6</th></tr></thead><tbody><tr><td>Concatenation</td><td><code class="md-code md-code-inline">[1, 2].concat(more)</code></td><td><code class="md-code md-code-inline">[1, 2, ...more]</code></td></tr><tr><td>Push onto list</td><td><code class="md-code md-code-inline">list.push.apply(list, [3, 4])</code></td><td><code class="md-code md-code-inline">list.push(...[3, 4])</code></td></tr><tr><td>Destructuring</td><td><code class="md-code md-code-inline">a = list[0], rest = list.slice(1)</code></td><td><code class="md-code md-code-inline">[a, ...rest] = list</code></td></tr><tr><td><code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code></td><td><a aria-label="This is insanely unreadable. Avoid." href="http://stackoverflow.com/a/8843181/389745"><code class="md-code md-code-inline">new (Date.bind.apply(Date, [null,2015,31,8]))</code></a></td><td><code class="md-code md-code-inline">new Date(...[2015,31,8])</code></td></tr></tbody></table><h2 id="default-operator">Default Operator</h2><p>The default operator is something we've covered in <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span> <span class="md-code-params">(left=1, right=2)</span> </span>{
  <span class="md-code-keyword">return</span> left + right
}
<span class="md-code-built_in">console</span>.log(sum())
<span class="md-code-comment">// &lt;- 3</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">2</span>))
<span class="md-code-comment">// &lt;- 4</span>
<span class="md-code-built_in">console</span>.log(sum(<span class="md-code-number">1</span>, <span class="md-code-number">0</span>))
<span class="md-code-comment">// &lt;- 1</span>
</code></pre><p>Consider the code that initializes options in <a aria-label="Option initialization in dragula on GitHub" href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37"><code class="md-code md-code-inline">dragula</code></a>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">dragula</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">var</span> o = options || {};
  <span class="md-code-keyword">if</span> (o.moves === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.moves = always; }
  <span class="md-code-keyword">if</span> (o.accepts === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.accepts = always; }
  <span class="md-code-keyword">if</span> (o.invalid === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.invalid = invalidTarget; }
  <span class="md-code-keyword">if</span> (o.containers === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.containers = initialContainers || []; }
  <span class="md-code-keyword">if</span> (o.isContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.isContainer = never; }
  <span class="md-code-keyword">if</span> (o.copy === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.copy = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.revertOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.revertOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.removeOnSpill === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.removeOnSpill = <span class="md-code-literal">false</span>; }
  <span class="md-code-keyword">if</span> (o.direction === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.direction = <span class="md-code-string">'vertical'</span>; }
  <span class="md-code-keyword">if</span> (o.mirrorContainer === <span class="md-code-keyword">void</span> <span class="md-code-number">0</span>) { o.mirrorContainer = body; }
}
</code></pre><blockquote><p>Do you think it would be useful to switch to default parameters under ES6 syntax? How would you do that?</p></blockquote></section><section class="at-discuss"><span>There's a </span><a aria-label="Your upvote is appreciated!" target="_blank" href="https://news.ycombinator.com/item?id=10151660">discussion on Hacker News</a><span>.</span></section></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 Classes in Depth</h1>
<section class="at-corpus" itemprop="articleBody"><section class="md-markdown at-teaser" itemprop="about"><p>Welcome to <a aria-label="Articles tagged es6-in-depth on Pony Foo" href="/articles/tagged/es6-in-depth">ES6 in Depth</a>. Are you new here? You might want to learn about <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>, <a aria-label="ES6 Template Literals in Depth on Pony Foo" href="/articles/es6-template-strings-in-depth">template literals</a>, <a aria-label="ES6 Arrow Functions in Depth on Pony Foo" href="/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a aria-label="ES6 Spread and Butter in Depth on Pony Foo" href="/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, or <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth">object literal features in ES6</a>. Today is going to be about <em>"classes"</em> in ES6.</p><blockquote><p>Like I did in previous articles on the series, I would love to point out that you should probably <a aria-label="Setting Up Babel on Pony Foo" href="/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That'll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren't the <em>"install things on my computer"</em> kind of human, you might prefer to hop on <a aria-label="CodePen is like JSFiddle but pretty" href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript &ndash; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p></blockquote><p>Onwards!</p></section><section class="md-markdown at-body"><h2 id="what-do-you-mean-1-classes-in-javascript"><a aria-label="Peace Sells - Megadeth" href="https://www.youtube.com/watch?v=fCEo2wfudqk">What do you mean</a>; classes in JavaScript?</h2><p>JavaScript is a prototype-based language, so what are ES6 classes really? They're syntactic sugar on top of prototypical inheritance &ndash; a device to make the language more inviting to programmers coming from other paradigms who might not be all that familiar with prototype chains. Many features in ES6 <em>(such as <a aria-label="ES6 JavaScript Destructuring in Depth on Pony Foo" href="/articles/es6-destructuring-in-depth">destructuring</a>)</em> are, in fact, syntactic sugar &ndash; and classes are no exception. I like to clarify this because it makes it much easier to understand the underlying technology behind ES6 classes. There is no huge restructuring of the language, they just made it easier for people used to classes to leverage prototypal inheritance.</p><blockquote><p>While I may dislike the term <em>"classes"</em> for this particular feature, I have to say that the syntax is in fact much easier to work with than regular prototypal inheritance syntax in ES5, and that's a win for everyone &ndash; regardless of them being called classes or not.</p></blockquote><p>Now that that's out of the way, I'll assume you understand prototypal inheritance &ndash; just because you're reading a blog about JavaScript. Here's how you would describe a <code class="md-code md-code-inline">Car</code> that can be instantiated, fueled up, and move.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Car</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.fuel = <span class="md-code-number">0</span>;
  <span class="md-code-keyword">this</span>.distance = <span class="md-code-number">0</span>;
}

Car.prototype.move = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &lt; <span class="md-code-number">1</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is depleted'</span>)
  }
  <span class="md-code-keyword">this</span>.fuel--
  <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">2</span>
}

Car.prototype.addFuel = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &gt;= <span class="md-code-number">60</span>) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is full'</span>)
  }
  <span class="md-code-keyword">this</span>.fuel++
}
</code></pre><p>To move the car, you could use the following piece of code.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> car = <span class="md-code-keyword">new</span> Car()
car.addFuel()
car.move()
car.move()
<span class="md-code-comment">// &lt;- RangeError: 'Fuel tank is depleted'</span>
</code></pre><p>Neat. What about with ES6 classes? The syntax is very similar to declaring an object, except we precede it with <code class="md-code md-code-inline">class Name</code>, where <code class="md-code md-code-inline">Name</code> is the name for our class. Here we are leveraging the <a aria-label="ES6 Object Literal Features in Depth on Pony Foo" href="/articles/es6-object-literal-features-in-depth#method-signatures">method signature notation</a> we covered yesterday to declare the methods using a shorter syntax. The <code class="md-code md-code-inline">constructor</code> is just like the constructor method in ES5, so you can use that to initialize any variables your instances may have.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor () {
    <span class="md-code-keyword">this</span>.fuel = <span class="md-code-number">0</span>
    <span class="md-code-keyword">this</span>.distance = <span class="md-code-number">0</span>
  }
  move () {
    <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &lt; <span class="md-code-number">1</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is depleted'</span>)
    }
    <span class="md-code-keyword">this</span>.fuel--
    <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">2</span>
  }
  addFuel () {
    <span class="md-code-keyword">if</span> (<span class="md-code-keyword">this</span>.fuel &gt;= <span class="md-code-number">60</span>) {
      <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">RangeError</span>(<span class="md-code-string">'Fuel tank is full'</span>)
    }
    <span class="md-code-keyword">this</span>.fuel++
  }
}
</code></pre><p>In case you haven't noticed, and for some obscure reason that escapes me, <strong>commas are invalid</strong> in-between properties or methods in a class, as opposed to object literals where commas are <em>(still)</em> mandatory. That discrepancy is bound to cause headaches to people trying to decide whether they want a plain object literal or a class instead, but the code <em>does</em> look sort of cleaner without the commas here.</p><p>Many times <em>"classes"</em> have static methods. Think of your friend the <code class="md-code md-code-inline">Array</code> for example. Arrays have instance methods like <code class="md-code md-code-inline">.filter</code>, <code class="md-code md-code-inline">.reduce</code>, and <code class="md-code md-code-inline">.map</code>. The <code class="md-code md-code-inline">Array</code> <em>"class"</em> itself has static methods as well, like <a aria-label="Array.isArray() - MDN" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"><code class="md-code md-code-inline">Array.isArray</code></a>. In ES5 code, it's pretty easy to add these kind of methods to our <code class="md-code md-code-inline">Car</code> <em>"class"</em>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Car</span> <span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">this</span>.topSpeed = <span class="md-code-built_in">Math</span>.random()
}
Car.isFaster = <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(left, right)</span> </span>{
  <span class="md-code-keyword">return</span> left.topSpeed &gt; right.topSpeed
}
</code></pre><p>In ES6 <code class="md-code md-code-inline">class</code> notation, we can use precede our method with <code class="md-code md-code-inline">static</code>, following a similar syntax as that of <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>. Again, just sugar on top of ES5, as it's quite trivial to transpile this down into ES5 notation.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor () {
    <span class="md-code-keyword">this</span>.topSpeed = <span class="md-code-built_in">Math</span>.random()
  }
  static isFaster (left, right) {
    <span class="md-code-keyword">return</span> left.topSpeed &gt; right.topSpeed
  }
}
</code></pre><p>One sweet aspect of ES6 <code class="md-code md-code-inline">class</code> sugar is that you also get an <code class="md-code md-code-inline">extends</code> keyword that enables you to easily <em>"inherit"</em> from other <em>"classes"</em>. We all know Tesla cars move further while using the same amount of fuel, thus the code below shows how <code class="md-code md-code-inline">Tesla extends Car</code> and "overrides" <em>(a concept you might be familiar with if you've ever <a aria-label="Overriding methods in C# - MSDN" href="https://msdn.microsoft.com/en-us/library/aa645768(v=vs.71).aspx">played around with C#</a>)</em> the <code class="md-code md-code-inline">move</code> method to cover a larger distance.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Tesla extends Car {
  move () {
    super.move()
    <span class="md-code-keyword">this</span>.distance += <span class="md-code-number">4</span>
  }
}
</code></pre><p>The special <code class="md-code md-code-inline">super</code> keyword identifies the <code class="md-code md-code-inline">Car</code> class we've inherited from &ndash; and since we're speaking about C#, it's akin to <a aria-label="The base keyword ok MSDN" href="https://msdn.microsoft.com/en-us/library/hfw7t1ce.aspx"><code class="md-code md-code-inline">base</code></a>. It's <em>raison d'être</em> is that most of the time we <em>override</em> a method by re-implementing it in the inheriting class, &ndash; <code class="md-code md-code-inline">Tesla</code> in our example &ndash; we're supposed to call the method on the base class as well. This way we don't have to copy logic over to the inheriting class whenever we re-implement a method. That'd be particularly lousy since whenever a base class changes we'd have to paste their logic into every inheriting class, turning our codebase into a maintainability nightmare.</p><p>If you now did the following, you'll notice the Tesla car moves two places because of <code class="md-code md-code-inline">base.move()</code>, which is what every regular car does as well, and it moves an additional four places because <code class="md-code md-code-inline">Tesla</code> is just that good.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> car = <span class="md-code-keyword">new</span> Tesla()
car.addFuel()
car.move()
<span class="md-code-built_in">console</span>.log(car.distance)
<span class="md-code-comment">// &lt;- 6</span>
</code></pre><p>The most common thing you'll have to override is the <code class="md-code md-code-inline">constructor</code> method. Here you can just call <code class="md-code md-code-inline">super()</code>, passing any arguments that the base class needs. Tesla cars are twice as fast, so we just call the base <code class="md-code md-code-inline">Car</code> constructor with twice the advertised <code class="md-code md-code-inline">speed</code>.</p><pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Car {
  constructor (speed) {
    <span class="md-code-keyword">this</span>.speed = speed
  }
}
<span class="md-code-keyword">class</span> Tesla extends Car {
  constructor (speed) {
    super(speed * <span class="md-code-number">2</span>)
  }
}
</code></pre><p>Tomorrow, we'll go over the syntax for <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and <code class="md-code md-code-inline">for ... of ...</code>. Until then!</p></section><section class="at-discuss"><span>There's a </span><a aria-label="Your upvote is appreciated!" target="_blank" href="https://news.ycombinator.com/item?id=10164538">discussion on Hacker News</a><span>.</span></section></section>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>ES6 for Now: Template Strings</h1>
<div class="ArticleCopy language-javascript">
    <p><em>This article is part of a web development series from Microsoft. Thank you for supporting the partners who make SitePoint possible.</em></p>
<p><strong>ES6 is the future of JavaScript and it is already here. It is a finished specification, and it brings a lot of features a language requires to stay competitive with the needs of the web of now. Not everything in ES6 is for you and in this little series of posts I will show features that are very handy and already usable.</strong></p>
<p>If you look at JavaScript code I've written you will find that I always use single quotes to define strings instead of double quotes. JavaScript is OK with either, the following two examples do exactly the same thing:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">"cow"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
</code></pre>
<p>The reason why I prefer single quotes is that, first of all, it makes it easier to assemble HTML strings with properly quoted attributes that way:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span spellcheck="true" class="token comment">// with single quotes, there's no need to</span>
<span spellcheck="true" class="token comment">// escape the quotes around the class value</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">'&lt;button class="big"&gt;Save&lt;/button&gt;'</span><span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// this is a syntax error:</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">"&lt;button class="</span>big<span class="token string">"&gt;Save&lt;/button&gt;"</span><span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// this works:</span>
<span class="token keyword">var</span> but <span class="token operator">=</span> <span class="token string">"&lt;button class=\"big\"&gt;Save&lt;/button&gt;"</span><span class="token punctuation">;</span>
</code></pre>
<p>The only time you need to escape now is when you use a single quote in your HTML, which should be a very rare occasion. The only thing I can think of is inline JavaScript or CSS, which means you are very likely to do something shady or desperate to your markup. Even in your texts, you are probably better off to not use a single quote but the typographically more pleasing.</p>
<p><em>Aside: Of course, HTML is forgiving enough to omit the quotes or to use single quotes around an attribute, but I prefer to create readable markup for humans rather than relying on the forgiveness of a parser. We made the HTML5 parser forgiving because people wrote terrible markup in the past, not as an excuse to keep doing so.</em></p>
<p>I've suffered enough in the DHTML days of document.write to create a document inside a frameset in a new popup window and other abominations to not want to use the escape character ever again. At times, we needed triple ones, and that was even before we had colour coding in our editors. It was a mess.</p>
<h2>Expression Substitution in Strings?</h2>
<p>Another reason why I prefer single quotes is that I wrote a lot of PHP in my time for very large web sites where performance mattered a lot. In PHP, there is a difference between single and double quotes. Single quoted strings don't have any substitution in them, double quoted ones have. That meant back in the days of PHP 3 and 4 that using single quotes was much faster as the parser doesn't have to go through the string to substitute values. Here is an example what that means:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>php
  $animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
  $sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>
 
  echo <span class="token string">'The animal is $animal and its sound is $sound'</span><span class="token punctuation">;</span>
  <span spellcheck="true" class="token comment">// =&gt; The animal is $animal and its sound is $sound</span>
 
  echo <span class="token string">"The animal is $animal and its sound is $sound"</span><span class="token punctuation">;</span>
  <span spellcheck="true" class="token comment">// =&gt; The animal is cow and its sound is moo</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre>
<p>JavaScript didn't have this substitution, which is why we had to concatenate strings to achieve the same result. This is pretty unwieldy, as you need to jump in and out of quotes all the time.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'The animal is '</span> <span class="token operator">+</span> animal <span class="token operator">+</span> <span class="token string">' and its sound is '</span> <span class="token operator">+</span> sound<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "The animal is cow and its sound is moo"</span>
</code></pre>
<h2>Multi-line Mess</h2>
<p>This gets really messy with longer and more complex strings and especially when we assemble a lot of HTML. And, most likely you will sooner or later end up with your linting tool complaining about trailing whitespace after a + at the end of a line. This is based on the issue that JavaScript has no multi-line strings:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span spellcheck="true" class="token comment">// this doesn't work</span>
<span class="token keyword">var</span> list <span class="token operator">=</span> '<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Buy Milk<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Be kind to Pandas<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Forget about Dre<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>'<span class="token punctuation">;</span> 

<span spellcheck="true" class="token comment">// This does, but urgh… </span>
<span class="token keyword">var</span> list <span class="token operator">=</span> '<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>\
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Buy Milk<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Be kind to Pandas<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>Forget about Dre<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>\ 
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>'<span class="token punctuation">;</span>

<span spellcheck="true" class="token comment">// This is the most common way, and urgh, too… </span>
<span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token string">'&lt;ul&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Buy Milk&lt;/li&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Be kind to Pandas&lt;/li&gt;'</span> <span class="token operator">+</span>
 <span class="token string">' &lt;li&gt;Forget about Dre&lt;/li&gt;'</span> <span class="token operator">+</span> 
 <span class="token string">'&lt;/ul&gt;'</span><span class="token punctuation">;</span>
</code></pre>
<h2>Client-side Templating Solutions</h2>
<p>In order to work around the mess that is string handling and concatenation in JavaScript, we did what we always do &ndash; we write a library. There are many HTML templating libraries with <a href="https://github.com/janl/mustache.js">Mustache.js</a> probably having been the seminal one. All of these follow an own &ndash; non standardized &ndash; syntax and work in that frame of mind. It's a bit like saying that you write your content in markdown and then realizing that there are many different ideas of what "markdown" means.</p>
<h2>Enter Template Strings</h2>
<p>With the advent of ES6 and its standardization we now can rejoice as JavaScript has now a new kid on the block when it comes to handling strings: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-static-semantics-templatestrings">Template Strings</a>. The <a href="http://kangax.github.io/compat-table/es6/#template_strings">support of template strings in current browsers</a> is encouraging: Chrome 44+, Firefox 38+, <a href="http://dev.modern.ie/platform/status/templatestringses6/?utm_source=SitePoint&amp;utm_medium=article47&amp;utm_campaign=SitePoint/?filter=f3f0000bf&amp;search=template">Microsoft Edge</a> and Webkit are all on board. Safari, sadly enough, is not, but it'll get there.</p>
<p>The genius of template strings is that it uses a new string delimiter, which isn't in use either in HTML nor in normal texts: the backtick (`).</p>
<p>Using this one we now have string expression substitution in JavaScript:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token string">'cow'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> sound <span class="token operator">=</span> <span class="token string">'moo'</span><span class="token punctuation">;</span>
 
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The animal is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and its sound is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sound<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "The animal is cow and its sound is moo"</span>
</code></pre>
<p>The <code class=" language-javascript">$<span class="token punctuation">{</span><span class="token punctuation">}</span></code> construct can take any JavaScript expression that returns a value, you can for example do calculations, or access properties of an object:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token template-string"><span class="token string">`ten times two totally is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "ten times two totally is 20"</span>
 
<span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'cow'</span><span class="token punctuation">,</span>
  ilk<span class="token punctuation">:</span> <span class="token string">'bovine'</span><span class="token punctuation">,</span>
  front<span class="token punctuation">:</span> <span class="token string">'moo'</span><span class="token punctuation">,</span>
  back<span class="token punctuation">:</span> <span class="token string">'milk'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`
  The </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is of the 
  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>ilk<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ilk, 
  one end is for the </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>front<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, 
  the other for the </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>animal<span class="token punctuation">.</span>back<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; </span>
<span spellcheck="true" class="token comment">/*
  The cow is of the 
  bovine ilk, 
  one end is for the moo, 
  the other for the milk
*/</span>
</code></pre>
<p>That last example also shows you that multi line strings are not an issue at all any longer.</p>
<h2>Tagged Templates</h2>
<p>Another thing you can do with template strings is prepend them with a tag, which is the name of a function that is called and gets the string as a parameter. For example, you could encode the resulting string for URLs without having to resort to the horridly named <code class=" language-javascript">encodeURIComponent</code> all the time.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> urlify <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
urlify <span class="token template-string"><span class="token string">`http://beedogs.com`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "http%3A%2F%2Fbeedogs.com"</span>
urlify <span class="token template-string"><span class="token string">`woah$£$%£^$"`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "woah%24%C2%A3%24%25%C2%A3%5E%24%22"</span>
 
<span spellcheck="true" class="token comment">// nesting also works:</span>
 
<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token string">`foo ${urlify `</span></span><span class="token operator">&amp;&amp;</span><span class="token template-string"><span class="token string">`} bar`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">// =&gt; "foo %26%26 bar"</span>
</code></pre>
<p>This works, but relies on implicit array-to-string coercion. The parameter sent to the function is not a string, but an array of strings and values. If used the way I show here, it gets converted to a string for convenience, but the correct way is to access the array members directly.</p>
<h2>Retrieving Strings and Values from a Template String</h2>
<p>Inside the tag function you can not only get the full string but also its parts.</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> tag <span class="token punctuation">(</span>strings<span class="token punctuation">,</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
tag <span class="token template-string"><span class="token string">`you </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> it`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">/* =&gt;
 
Array [ "you ", " it" ]
7
it
 
*/</span>
</code></pre>
<p>There is also an array of the raw strings provided to you, which means that you get all the characters in the string, including control characters. Say, for example, you add a line break with \n. You will get the double whitespace in the string, but the \n characters in the raw strings:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> tag <span class="token punctuation">(</span>strings<span class="token punctuation">,</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span>raw<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
tag <span class="token template-string"><span class="token string">`you </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> \nit`</span></span><span class="token punctuation">;</span>
<span spellcheck="true" class="token comment">/* =&gt;
 
Array [ "you ", "  it" ]
7
 
it
 \nit
*/</span>
</code></pre>
<h2>Conclusion</h2>
<p>Template strings are one of those nifty little wins in ES6 that can be used right now. If you have to support older browsers, you can of course transpile your ES6 to ES5; you can do a feature test for template string support using a library like <a href="http://featuretests.io/">featuretests.io</a> or with the following code:</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> templatestrings <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span> <span class="token string">"`{2+2}`"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  templatestrings <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  templatestrings <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
 
<span class="token keyword">if</span> <span class="token punctuation">(</span>templatestrings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span spellcheck="true" class="token comment">// …</span>
<span class="token punctuation">}</span>
</code></pre>
<p>More articles on template strings:</p>

  </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<h1 class="title-section">10 Ecmascript-6 tricks you can perform right now</h1>
		<div class="body-content">
                            <p>We live in a fluid world. I first started hearing about HTML5 several years ago now, and I've been using it for at least two, yet it won't be officially ready until&nbsp;<a target="_blank" href="http://www.maximumpc.com/article/news/when_will_html5_spec_be_finalized">next year</a>&nbsp;at the earliest. While HTML is making great strides, another leg of the stool is progressing nicely as well. New Javascript features are coming, outlined in the standard known as&nbsp;<em>Ecmascript 6</em>. Though it's not finalized, it is approaching stability and implementation is coming along in various forms.</p>
<p>You've probably heard about some of the cool features on the way, like module support, classes and a bunch of syntactic niceties, but you might not have had a chance to try them. You can try out the&nbsp;<a target="_blank" href="http://traceur-compiler.googlecode.com/git/demo/repl.html">traceur compiler</a>&nbsp;which has support for many new features. It's a wonderful tool, and you can use it to build a full webpage or app taking advanage of some of these features.</p>
<p>There are also quite a few new features already available in the browser. While several browsers have implemented some of the upcoming JS features, I've had particularly good luck with&nbsp;<a target="_blank" href="https://wiki.mozilla.org/Firefox/Aurora">Firefox Aurora</a>. Aurora is an experimental version of Firefox, esssentially a version number or two ahead of the standard release. It's more stable than nightly, but not quite ready for primetime. Nevertheless, I've found it pretty reliable, in fact I've been using it as my primary browser for months without any problems, but your mileage may vary.</p>
<p>All that is to say that if you do want to try ES6, and you aren't afraid of Firefox Aurora, here's some new features you can test out.</p>
<h2>1. Extract the weekday, month, date and year from Date() in one fell swoop:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671cf200725340">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671cf200725340-1" class="crayon-num">1</div><div data-line="crayon-55f69131671cf200725340-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671cf200725340-3" class="crayon-num">3</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671cf200725340-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671cf200725340-2" class="crayon-line crayon-striped-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-sy">[</span><span class="crayon-i">day</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">month</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">date</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">year</span><span class="crayon-sy">]</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">Date</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">.</span><span class="crayon-e">split</span><span class="crayon-sy">(</span><span class="crayon-s">' '</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671cf200725340-3" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Using&nbsp;<em>destructured assignment</em>, you can extract multiple fields from an array and assign them to a set of variables. It doesn't quite work for objects yet, but arrays work fine.</p>
<h2>2. Set default parameter values:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671d8311828246">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671d8311828246-1" class="crayon-num">1</div><div data-line="crayon-55f69131671d8311828246-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671d8311828246-3" class="crayon-num">3</div><div data-line="crayon-55f69131671d8311828246-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671d8311828246-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671d8311828246-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671d8311828246-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-v">y</span><span class="crayon-o">=</span><span class="crayon-cn">1</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-i">y</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671d8311828246-3" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-cn">22</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671d8311828246-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 22 1</span></div><div id="crayon-55f69131671d8311828246-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0007 seconds] -->
<p>Finally, we can get rid of the various (sometimes dubious) default parameter patterns, with built-in support for default parameters. Once destructured object assignments are complete, we'll be able to use those for setting defaults from named parameter objects as well.</p>
<h2>3. Use variable args without the arguments object:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671dc428468448">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671dc428468448-1" class="crayon-num">1</div><div data-line="crayon-55f69131671dc428468448-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671dc428468448-3" class="crayon-num">3</div><div data-line="crayon-55f69131671dc428468448-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671dc428468448-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671dc428468448-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671dc428468448-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">,</span><span class="crayon-i">y</span><span class="crayon-sy">,</span><span class="crayon-i">z</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-sy">.</span><span class="crayon-sy">.</span><span class="crayon-sy">.</span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-h"> </span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671dc428468448-3" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-cn">1</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">7</span><span class="crayon-sy">,</span><span class="crayon-cn">8</span><span class="crayon-sy">,</span><span class="crayon-cn">9</span><span class="crayon-sy">,</span><span class="crayon-s">'a'</span><span class="crayon-sy">,</span><span class="crayon-s">'b'</span><span class="crayon-sy">,</span><span class="crayon-s">'c'</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671dc428468448-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 7 8 9 'a' 'b' 'c'</span></div><div id="crayon-55f69131671dc428468448-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0011 seconds] -->
<p>One word of wisdom I often see is that the arguments object is not an array, and you should not treat it like one. With the&nbsp;<em>rest</em>&nbsp;operator, you don't need the arguments object, and the rest of the parameters really do end up in a real array.</p>
<h2>4. Define a function quicker than you can type "function () {}":</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671df855591025">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671df855591025-1" class="crayon-num">1</div><div data-line="crayon-55f69131671df855591025-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671df855591025-3" class="crayon-num">3</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671df855591025-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671df855591025-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-o">&gt;</span><span class="crayon-h"> </span><span class="crayon-e ">x*</span><span class="crayon-i">x</span></div><div id="crayon-55f69131671df855591025-3" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->
<p>For a language that is arguably functional at heart, Javascript picked an unusually verbose keyword to describe functions, especially given the prevalence of callback routines and object methods which involve an awful lot of repetition of the word "function". And while not everyone loves CoffeeScript, I suspect even the haters are sometimes jealous of its arrow notation as a shortcut to describe functions. The fat arrow knocks out two birds with one stone, as it also provides a lexical&nbsp;<em>this</em>&nbsp;pointer, the lack of which confuses many a new Javascript programmer.</p>
<h2>5. Create variables with block scope:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671e3864303907">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671e3864303907-1" class="crayon-num">1</div><div data-line="crayon-55f69131671e3864303907-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671e3864303907-3" class="crayon-num">3</div><div data-line="crayon-55f69131671e3864303907-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671e3864303907-5" class="crayon-num">5</div><div data-line="crayon-55f69131671e3864303907-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671e3864303907-7" class="crayon-num">7</div><div data-line="crayon-55f69131671e3864303907-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671e3864303907-9" class="crayon-num">9</div><div data-line="crayon-55f69131671e3864303907-10" class="crayon-num crayon-striped-num">10</div><div data-line="crayon-55f69131671e3864303907-11" class="crayon-num">11</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671e3864303907-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671e3864303907-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e3864303907-3" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-i">let</span><span class="crayon-h"> </span><span class="crayon-v">n</span><span class="crayon-o">=</span><span class="crayon-cn">1</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">let</span><span class="crayon-h"> </span><span class="crayon-v">n</span><span class="crayon-o">=</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-v">i</span><span class="crayon-o">=</span><span class="crayon-cn">0</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">i</span><span class="crayon-o">&lt;</span><span class="crayon-i">n</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">i</span><span class="crayon-o">++</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e3864303907-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671e3864303907-7" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">n</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-8" class="crayon-line crayon-striped-line"><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-9" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e3864303907-10" class="crayon-line crayon-striped-line"><span class="crayon-c">// 0 1 2 3 4 1</span></div><div id="crayon-55f69131671e3864303907-11" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>Perhaps the most anticipated feature of Ecmascript 6 is the arrival of&nbsp;<em>Block Scoping</em>. One of the single biggest drawbacks of Javascript is its scoping, especially the lack of block scoping, leading to common anti-patterns like declaring every single local variable at the top of a function, regardless of where it's used. With the new&nbsp;<em>let</em>&nbsp;statement we finally have variables with lifetimes that last only until the end of the block.</p>
<h2>6. Make things constant:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671e6393357325">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671e6393357325-1" class="crayon-num">1</div><div data-line="crayon-55f69131671e6393357325-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671e6393357325-3" class="crayon-num">3</div><div data-line="crayon-55f69131671e6393357325-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671e6393357325-5" class="crayon-num">5</div><div data-line="crayon-55f69131671e6393357325-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671e6393357325-7" class="crayon-num">7</div><div data-line="crayon-55f69131671e6393357325-8" class="crayon-num crayon-striped-num">8</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671e6393357325-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671e6393357325-2" class="crayon-line crayon-striped-line"><span class="crayon-v">f</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671e6393357325-3" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-m">const</span><span class="crayon-h"> </span><span class="crayon-v">two</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">two</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">5</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">two</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-6" class="crayon-line crayon-striped-line"><span class="crayon-sy">}</span></div><div id="crayon-55f69131671e6393357325-7" class="crayon-line"><span class="crayon-e">f</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671e6393357325-8" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>In one of my first programming courses, I remember the teacher discussing the Fortran equivalent of a symbolic constant, but she said something like "I know it's good for something but I'm not sure what". These days the goodness of const is generally well understood, but the lack of it in one of the worlds most prevalent languages is not. No more; with ES6 it is finally here.</p>
<h2>7. Intercept and rewrite attribute accesses:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671ea987051653">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671ea987051653-1" class="crayon-num">1</div><div data-line="crayon-55f69131671ea987051653-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671ea987051653-3" class="crayon-num">3</div><div data-line="crayon-55f69131671ea987051653-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671ea987051653-5" class="crayon-num">5</div><div data-line="crayon-55f69131671ea987051653-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671ea987051653-7" class="crayon-num">7</div><div data-line="crayon-55f69131671ea987051653-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671ea987051653-9" class="crayon-num">9</div><div data-line="crayon-55f69131671ea987051653-10" class="crayon-num crayon-striped-num">10</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671ea987051653-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671ea987051653-2" class="crayon-line crayon-striped-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">point</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">x</span><span class="crayon-o">:</span><span class="crayon-cn">1</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-3" class="crayon-line"><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">w</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">set</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-sy">,</span><span class="crayon-i">p</span><span class="crayon-sy">,</span><span class="crayon-i">v</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671ea987051653-4" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">p</span><span class="crayon-sy">,</span><span class="crayon-i">v</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-5" class="crayon-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671ea987051653-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-7" class="crayon-line"><span class="crayon-v">p</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-e">Proxy</span><span class="crayon-sy">(</span><span class="crayon-i">point</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-i">w</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-8" class="crayon-line crayon-striped-line"><span class="crayon-v">p</span><span class="crayon-sy">.</span><span class="crayon-v">x</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ea987051653-9" class="crayon-line"><span class="crayon-c">// prints 'x 2', but doesn't change p.x</span></div><div id="crayon-55f69131671ea987051653-10" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0014 seconds] -->
<p>While&nbsp;<em>getters</em>&nbsp;and&nbsp;<em>setters</em>&nbsp;are becoming more familiar to javascript programmers,&nbsp;<em>Proxy</em>&nbsp;provides extensive functionality to wrap an object so that a number of types of access may be monitored or modified. A more comprehensive list of "proxyable" items may be found&nbsp;<a target="_blank" href="http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies">here</a>.</p>
<h2>8. Create and manipulate&nbsp;<em>Sets</em>:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671ed376106970">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671ed376106970-1" class="crayon-num">1</div><div data-line="crayon-55f69131671ed376106970-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671ed376106970-3" class="crayon-num">3</div><div data-line="crayon-55f69131671ed376106970-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671ed376106970-5" class="crayon-num">5</div><div data-line="crayon-55f69131671ed376106970-6" class="crayon-num crayon-striped-num">6</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671ed376106970-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671ed376106970-2" class="crayon-line crayon-striped-line"><span class="crayon-v">s</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-r">new</span><span class="crayon-h"> </span><span class="crayon-e">Set</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671ed376106970-3" class="crayon-line"><span class="crayon-sy">[</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-cn">4</span><span class="crayon-sy">,</span><span class="crayon-cn">5</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">]</span><span class="crayon-sy">.</span><span class="crayon-e">map</span><span class="crayon-sy">(</span><span class="crayon-v">x</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-o">&gt;</span><span class="crayon-h"> </span><span class="crayon-v">s</span><span class="crayon-sy">.</span><span class="crayon-e">add</span><span class="crayon-sy">(</span><span class="crayon-i">x</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671ed376106970-4" class="crayon-line crayon-striped-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-h"> </span><span class="crayon-i">of</span><span class="crayon-h"> </span><span class="crayon-i">s</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671ed376106970-5" class="crayon-line"><span class="crayon-c">// 2 3 4 5</span></div><div id="crayon-55f69131671ed376106970-6" class="crayon-line crayon-striped-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0012 seconds] -->
<p>There's a reason that mathematicians invented sets, and sometimes developers need them too. Now instead of needing to implement them or rely on another JS library, they're just there.</p>
<h2>9. Use an object as a key value:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671f1573694665">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671f1573694665-1" class="crayon-num">1</div><div data-line="crayon-55f69131671f1573694665-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671f1573694665-3" class="crayon-num">3</div><div data-line="crayon-55f69131671f1573694665-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671f1573694665-5" class="crayon-num">5</div><div data-line="crayon-55f69131671f1573694665-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671f1573694665-7" class="crayon-num">7</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671f1573694665-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671f1573694665-2" class="crayon-line crayon-striped-line"><span class="crayon-v">m</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-r">new</span><span class="crayon-h"> </span><span class="crayon-e">Map</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671f1573694665-3" class="crayon-line"><span class="crayon-v">o</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">passwd</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-s">"my name is my password"</span><span class="crayon-sy">}</span><span class="crayon-sy">;</span></div><div id="crayon-55f69131671f1573694665-4" class="crayon-line crayon-striped-line"><span class="crayon-v">m</span><span class="crayon-sy">.</span><span class="crayon-e">set</span><span class="crayon-sy">(</span><span class="crayon-i">o</span><span class="crayon-sy">,</span><span class="crayon-h"> </span><span class="crayon-s">"content"</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671f1573694665-5" class="crayon-line"><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-v">m</span><span class="crayon-sy">.</span><span class="crayon-e">get</span><span class="crayon-sy">(</span><span class="crayon-i">o</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671f1573694665-6" class="crayon-line crayon-striped-line"><span class="crayon-c">// "content"</span></div><div id="crayon-55f69131671f1573694665-7" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>Map may seem redundant at first, as it appears to be a more complicated version of an object, i.e. just a set of&nbsp;
			<span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-github crayon-theme-github-inline crayon-font-monaco" id="crayon-55f69131671f4120957998"><span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-pre crayon-code"><span class="crayon-i">key</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-i">value</span></span></span>&nbsp;pairs with less convenient syntax. But with objects, the key must be a string (dot notation is just shorthand for strings that work as JavaScript identifiers). With Maps, the key can be a javascript object, which can be really handy at times.</p>
<h2>10. Iterate and Generate:</h2>
<p></p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671f7703292038">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671f7703292038-1" class="crayon-num">1</div><div data-line="crayon-55f69131671f7703292038-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671f7703292038-3" class="crayon-num">3</div><div data-line="crayon-55f69131671f7703292038-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671f7703292038-5" class="crayon-num">5</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671f7703292038-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671f7703292038-2" class="crayon-line crayon-striped-line"><span class="crayon-v">nums</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">function</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">1</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">2</span><span class="crayon-sy">;</span><span class="crayon-h"> </span><span class="crayon-i">yield</span><span class="crayon-h"> </span><span class="crayon-cn">3</span><span class="crayon-sy">;</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671f7703292038-3" class="crayon-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-h"> </span><span class="crayon-e">of </span><span class="crayon-e">nums</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">i</span><span class="crayon-sy">)</span><span class="crayon-sy">}</span></div><div id="crayon-55f69131671f7703292038-4" class="crayon-line crayon-striped-line"><span class="crayon-c">// 1 2 3</span></div><div id="crayon-55f69131671f7703292038-5" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0010 seconds] -->
<p>I must confess, while I think generators are great, when someone asks me for an example of when they are useful, I stumble a bit. You can always use a class with a next function and emulate the functionality of a generator, but generators can be cleaner and more concise. But even if you don't find uses for generators yourself, you'll want to use the "for of" loop. The "for of" construct provides the kind of functionality for iterating through an array that we always wished we had from the "for each…in" loop. Specifically, it only iterates through the iterable part of an Array, ignoring additional properties that may be part of it:</p><!-- Crayon Syntax Highlighter v2.4.0 -->

		<div style="margin-top: 12px; margin-bottom: 12px; float: none; clear: both; font-size: 13px ! important; line-height: 15px ! important; height: auto;" data-settings=" minimize scroll-always" class="crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes" id="crayon-55f69131671fb614093853">
		
			<div class="crayon-plain-wrap"></div>
			<div style="position: relative; z-index: 1;" class="crayon-main">
				<table class="crayon-table" style="margin-left: -28px;">
					<tbody><tr class="crayon-row">
				<td data-settings="hide" class="crayon-nums ">
					<div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-nums-content"><div data-line="crayon-55f69131671fb614093853-1" class="crayon-num">1</div><div data-line="crayon-55f69131671fb614093853-2" class="crayon-num crayon-striped-num">2</div><div data-line="crayon-55f69131671fb614093853-3" class="crayon-num">3</div><div data-line="crayon-55f69131671fb614093853-4" class="crayon-num crayon-striped-num">4</div><div data-line="crayon-55f69131671fb614093853-5" class="crayon-num">5</div><div data-line="crayon-55f69131671fb614093853-6" class="crayon-num crayon-striped-num">6</div><div data-line="crayon-55f69131671fb614093853-7" class="crayon-num">7</div><div data-line="crayon-55f69131671fb614093853-8" class="crayon-num crayon-striped-num">8</div><div data-line="crayon-55f69131671fb614093853-9" class="crayon-num">9</div></div>
				</td>
						<td class="crayon-code"><div style="font-size: 13px !important; line-height: 15px !important;" class="crayon-pre"><div id="crayon-55f69131671fb614093853-1" class="crayon-line">&nbsp;</div><div id="crayon-55f69131671fb614093853-2" class="crayon-line crayon-striped-line"><span class="crayon-v">a</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-sy">[</span><span class="crayon-cn">1</span><span class="crayon-sy">,</span><span class="crayon-cn">2</span><span class="crayon-sy">,</span><span class="crayon-cn">3</span><span class="crayon-sy">,</span><span class="crayon-cn">4</span><span class="crayon-sy">]</span></div><div id="crayon-55f69131671fb614093853-3" class="crayon-line"><span class="crayon-v">a</span><span class="crayon-sy">.</span><span class="crayon-v">sparse</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-t">false</span></div><div id="crayon-55f69131671fb614093853-4" class="crayon-line crayon-striped-line">&nbsp;</div><div id="crayon-55f69131671fb614093853-5" class="crayon-line"><span class="crayon-st">for</span><span class="crayon-h"> </span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-h"> </span><span class="crayon-i">of</span><span class="crayon-h"> </span><span class="crayon-i">a</span><span class="crayon-sy">)</span><span class="crayon-h"> </span><span class="crayon-sy">{</span></div><div id="crayon-55f69131671fb614093853-6" class="crayon-line crayon-striped-line"><span class="crayon-h">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v">console</span><span class="crayon-sy">.</span><span class="crayon-e">log</span><span class="crayon-sy">(</span><span class="crayon-i">t</span><span class="crayon-sy">)</span></div><div id="crayon-55f69131671fb614093853-7" class="crayon-line"><span class="crayon-sy">}</span></div><div id="crayon-55f69131671fb614093853-8" class="crayon-line crayon-striped-line"><span class="crayon-c">// 1 2 3 4</span></div><div id="crayon-55f69131671fb614093853-9" class="crayon-line">&nbsp;</div></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0009 seconds] -->
<p>There are a few caveats to consider. While these examples should work fine in a Firefox (Aurora) console, they don't all work in a script tag (or included .js file) unless you set&nbsp;
			<span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-syntax crayon-syntax-inline  crayon-theme-github crayon-theme-github-inline crayon-font-monaco" id="crayon-55f69131671fe292503500"><span style="font-size: 13px !important; line-height: 15px !important;font-size: 13px !important;" class="crayon-pre crayon-code"><span class="crayon-v">type</span><span class="crayon-o">=</span><span class="crayon-s">"application/javascript;&lt;wbr /&gt;version=1.7"</span></span></span>. Further, not everything is finalized, and/or Firefox's implementation may diverge from the unfinished standard in some areas, so take everything with a grain of salt. Finally, if you don't want to use Aurora, you could try standard Firefox. since I started working on this article Firefox has almost caught up, such that with the current Release (24) I think everything on this list except Proxy is working. There are a few things that work in traceur but not in Firefox, so that's worth exploring as well. In any case, consider it another way to prepare for the coming storm that is Ecmascript 6.</p>
<p>I mean "storm" in a good way, of course.</p>
                        </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<article class="post clear">
      <h1 class="post__title">
        ES6 arrow functions, syntax and lexical scoping
      </h1>
      <div class="post__meta">
        
        <a href="//github.com/toddmotto/toddmotto.github.io/blob/master/_posts/2015-04-14-es6-arrow-functions-syntaxes-and-lexical-scoping.md" class="post__meta-edit">
          <i class="fa fa-github"></i>
          Edit this page on GitHub
        </a>
        
        <p>
          April 14, 2015
        </p>
      </div>

      <p>ES6/Harmony/whatever introduces a really nice feature that punches above it's weight in terms of simplicity to integrate versus time saving and feature output. This feature is the arrow function.</p>

<p>Before we dive into the features of the arrow function and what it actually does for us, let's understand what an arrow function is <em>not</em>. It's not a replacement for the <code>function</code> keyword, at all. This means you can't do a find and replace on every single <code>function</code> keyword and everything works perfectly, because it likely won't.</p>

<p>If you're competent with the way <a href="//toddmotto.com/everything-you-wanted-to-know-about-javascript-scope">JavaScript scope</a> works, and have a great understanding of lexical scope, the <code>this</code> keyword and Prototype methods such as <code>.call()</code>, <code>.apply()</code> and <code>.bind()</code>, then you're in good hands to continue reading.</p>

<h3>Syntax</h3>

<p>Let's look at what the arrow function's construct is from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN</a>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// example 1</span>
<span class="p">([</span><span class="nx">param</span><span class="p">]</span> <span class="p">[,</span> <span class="nx">param</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">statements</span>
<span class="p">}</span>

<span class="c1">// example 2</span>
<span class="nx">param</span> <span class="o">=&gt;</span> <span class="nx">expression</span></code></pre></div>


<p>The "normal JavaScript" (ES5) equivalents to help transition:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// example 1</span>
<span class="kd">function</span> <span class="p">([</span><span class="nx">param</span><span class="p">]</span> <span class="p">[,</span> <span class="nx">param</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">statements</span>
<span class="p">}</span>

<span class="c1">// example 2</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">expression</span>
<span class="p">}</span></code></pre></div>


<p>The ES6 and ES5 differences in <code>example 1</code> are that the <code>function</code> keyword is omitted, and <code>=&gt;</code> now exists <em>after</em> the arguments. In <code>example 2</code>, our function has been reduced to one line, this is great for single line function expressions that get <code>return</code>'d.</p>

<h4>Hint: arrows are anonymous</h4>

<p>Arrow functions are always anonymous, which means we can't do this with ES6:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// ES5</span>
<span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span></code></pre></div>


<p>Instead of this, we could assign our anonymous arrow function it to a variable (using <code>var</code> here instead of <code>let</code> as ES6 block scoping is another topic):</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// ES6</span>
<span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span></code></pre></div>


<p>Let's look at the syntaxes a little further and then the functionality differences when using arrow functions.</p>

<h3>Syntax: single line expressions</h3>

<p>We touched briefly above on single line expressions, let's look at a great use case for them.</p>

<p>Let's take some junky ES5 example that iterates over an Array using <code>Array.prototype.map</code>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">timesTwo</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">);</span> <span class="c1">// [2, 4, 6, 8, 10]</span></code></pre></div>


<p>We can reduce this down to a single line with an arrow function, which saves us a lot of typing and can actually enhance readability in my opinion as this piece of code has one clear role:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">timesTwo</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">timesTwo</span><span class="p">);</span> <span class="c1">// [2, 4, 6, 8, 10]</span></code></pre></div>


<h3>Syntax: single argument functions</h3>

<p>Arrow functions also give us a small "sugar" syntax that allows us to remove parenthesis when only using a single argument in a function.</p>

<p>Taking the last piece of code for example we had this:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<p>When we could remove the parens from <code>(number)</code> to leave us with this:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">number</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<p>This is great and a little clearer initially, but as we all know applications grow and code scales, and to save us headaches (be it forgetting syntaxes or lesser experienced developers "not knowing" to add parens back with more than one argument), I'd recommend always using the parens out of habit, even for single args:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="c1">// we still rock with ES6</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span></code></pre></div>


<h3>Functionality: lexical scoping "this"</h3>

<p>Now we're past the sugar syntax excitement, we can dig into the benefits of the arrow function and it's implications on execution context.</p>

<p>Typically if we're writing ES5, we'll use something like <code>Function.prototype.bind</code> to grab the <code>this</code> value from another scope to change a function's execution context. This will mainly be used in callbacks inside a different scope.</p>

<p>In Angular, I adopt the <code>controllerAs</code> syntax which allows me to use <code>this</code> inside the Controller to refer to itself (so here's an example). Inside a function the <code>this</code> value may change, so I could have a few options, use <code>that = this</code> or <code>.bind</code>:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>The <code>this.foo = response;</code> won't work correctly as it's been executed in a different context. To change this we could use <code>.bind(this)</code> to give our desired effect:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>


<p>Or you may be used to keeping a top level <code>this</code> reference, which can make more sense when dealing with many nested contexts, we don't want a gross tree of <code>.bind(this), .bind(this), .bind(this)</code> and a tonne of wasted time binding those new functions (<code>.bind</code> is very slow). So we could look at <code>that = this</code> to save the day:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nx">that</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">that</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>With arrow functions, we have a better option, which allows us to "inherit" the scope we're in if needed. Which means if we changed our inital example to the following, the <code>this</code> value would be bound correctly:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// woo, pretty</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre></div>


<p>We could then refactor some more into a nice single line expression, push to git and head home for the day:</p>

<div class="highlight"><pre><code data-lang="javascript" class="language-javascript"><span class="kd">function</span> <span class="nx">FooCtrl</span> <span class="p">(</span><span class="nx">FooService</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Hello'</span><span class="p">;</span>
  <span class="nx">FooService</span>
  <span class="p">.</span><span class="nx">doSomething</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="nx">response</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>




    </article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<h1>JavaScript ES7 Function Bind Syntax</h1>
<div class="article-wrap">
      
      
<!-- /#table-of-contents -->

<p style="font-weight: bold; font-size: 1.5em;">
  <em>Bind your functions with this one weird trick!</em>
</p>

<p>Sorry, I couldn't resist.</p>

<p>I write this post with hesitation but excitement. I have enjoyed playing around
with the new ECMAScript function bind syntax as proposed
<a href="https://github.com/zenparsing/es-function-bind">here</a>. This is a very early
proposal for addition in ES2016 (ES7, whatever) and could drastically change
or even be scrapped. Therefore, I recognize that this post may become obsolete.</p>

<p>I hope by advocating for this syntax, it will get the attention it deserves so
that it will become standard ES syntax. I find it to be a very versatile and
welcome tool in my JavaScript arsenal.</p>

<h2 id="the-syntax">The Syntax</h2>

<p>So what does the syntax actually look like?</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">syntax.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Binding a function to a context</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">log</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Calling functions with a context</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">world</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nl">foo</span><span class="p">:</span><span class="err">:</span><span class="nx">bar</span><span class="p">();</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nl">foo</span><span class="p">:</span><span class="err">:</span><span class="nx">world</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>That's pretty much it. The proposal introduces a new <code>::</code> operator that
simplifies function binding. Essentially, it offers syntactic sugar for calling
the <code>bind</code>, <code>call</code>, and <code>apply</code> methods on <code>Function.prototype</code>. The equivalent
ES5 code is below:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">syntax-compiled.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Binding a function to a context</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">);</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Calling functions with a context</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{};</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">world</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">world</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>We could call it a day at that, but I don't want to devalue the power that this
syntax affords us. Let's explore the ramifications of this syntax further.</p>

<h2 id="iteration">Iteration</h2>

<p>How often have you done something like this in your JavaScript code?</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-iteration.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">ArrayProto</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">map</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">filter</span><span class="p">;</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'ul.my-list &gt; li'</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">completedItems</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">todoItems</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">completed</span><span class="p">;</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">titles</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">todoItems</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">textContent</span><span class="p">;</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span></div></div></pre></div></figure>

<p>Granted, you might be using a framework for your Todo app or a library like
lodash for iteration, but I don't doubt we've all used the native <code>Array</code>
methods on a different context at some point. It's tedious and messy, but it gets
the job done.</p>

<p>Now, with function bind syntax, we can make this code more expressive and
elegant:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-iteration.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="p">{</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">filter</span> <span class="p">}</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'ul.my-list &gt; li'</span><span class="p">);</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">completedItems</span> <span class="o">=</span> <span class="nx">todoItems</span><span class="err">::</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">completed</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">titles</span> <span class="o">=</span> <span class="nx">todoItems</span><span class="err">::</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">textContent</span><span class="p">);</span></div></div></pre></div></figure>

<p>The semantics remain the same, yet this reads more naturally and hides away the
uglier syntax we're accustomed to.</p>

<p>If you visit the proposal
(<a href="https://github.com/zenparsing/es-function-bind">link</a>), you'll see another
example where we can import helper functions from a hypothetical iteration
library to iterate over a collection. This creates a better separation of
concerns between data structures and function calls on those structures through
generalization.</p>

<p>Maybe your data structure needs to provide only one function for iteration, and
then you can import iteration "methods" that depend on the function. This
creates modularization possibilities in our JavaScript code similar to Ruby's
Enumerable module (<a href="http://ruby-doc.org/core-2.2.2/Enumerable.html">link</a>).</p>

<h2 id="callbacks">Callbacks</h2>

<p>Another common pattern in JavaScript is passing callbacks to another function
like an event library. This becomes tricky when we desire a specific <code>this</code>
context for our callback. Normally, we have to create a reference to <code>this</code> in a
separate variable and refer to it in our callback, or we call
<code>Function.prototype.bind</code> on our callback, passing in <code>this</code>.</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-callbacks.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">eventLib</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'eventLib'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">self</span><span class="p">.</span><span class="nx">gotFoo</span><span class="p">();</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">});</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">gotBar</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">));</span></div></div></pre></div></figure>

<p>Again, this is a little messy and slightly ugly. But with function bind syntax,
it becomes drastically simpler:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-callbacks.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">import</span> <span class="nx">eventLib</span> <span class="nx">from</span> <span class="s1">'eventLib'</span><span class="p">;</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="err">::</span><span class="k">this</span><span class="p">.</span><span class="nx">gotFoo</span><span class="p">);</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">,</span> <span class="err">::</span><span class="k">this</span><span class="p">.</span><span class="nx">gotBar</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">eventLib</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'log'</span><span class="p">,</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">);</span></div></div></pre></div></figure>

<p>This is powerfully expressive. No function wrapping. No explicit <code>bind</code> calls
(we're obviously still calling it via <code>::</code>, but we hide away those details). We
are declaring our intent that these functions should be called in response to an
event, and we're ensuring our <code>this</code> context with minimal effort.</p>

<h2 id="chaining">Chaining</h2>

<p>If I wasn't already convinced by the function bind syntax, chaining is what
really sold it for me. Recently, I have been using
<a href="https://github.com/Huddle/PhantomCSS">PhantomCSS</a> and
<a href="http://casperjs.org/">CasperJS</a> for a CSS refactoring endeavor. Of course, I'm
on the up-and-up and utilizing ES2015 via <a href="http://babeljs.io/">Babel</a> to write
my test suite. If you have not heard of PhantomCSS or CasperJS, I encourage you
to check them out. PhantomCSS is a very promising project for automating visual
regressions of your website. CasperJS is a wrapper over PhantomJS and SlimerJS,
offering a higher-level API.</p>

<p>For this particular project, I represent web pages as classes according to a
minimal interface. They each have a <code>run</code> method that takes in my <code>casper</code>
instance. From there, each class chains method calls on my <code>casper</code> instance,
returning the result. It's very "promisey." (I also added a few custom methods
to my instance to wrap over some other methods to make them more "promisey.")</p>

<p>To avoid duplication in some classes, I wanted to add some methods to the
<code>casper</code> instance that are specific to the concerns of that page. However, I
didn't want to pollute the actual object instance. Function bind syntax to the
rescue!</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-casper-chaining.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">class</span> <span class="nx">HomePage</span> <span class="p">{</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">run</span><span class="p">(</span><span class="nx">casper</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="err">`</span><span class="p">.</span><span class="nx">my</span><span class="o">-</span><span class="nx">section</span><span class="err">:</span><span class="nx">nth</span><span class="o">-</span><span class="nx">of</span><span class="o">-</span><span class="nx">type</span><span class="p">(</span><span class="nx">$</span><span class="p">{</span><span class="nx">n</span><span class="p">})</span> <span class="nx">$</span><span class="p">{</span><span class="nx">selector</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="k">return</span> <span class="nx">casper</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenVisit</span><span class="p">(</span><span class="s1">'http://my-url.com/home'</span><span class="p">)</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="s1">'home'</span><span class="p">)</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'.foo'</span><span class="p">)</span>
</div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="s1">'.cancel'</span><span class="p">)</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'.bar'</span><span class="p">)</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="err">::</span><span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="p">}</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>That is amazing! I can naturally express the chaining semantics while decorating
my instance without altering it. Just as a reminder of what we would probably
have to do without function bind syntax, here is some equivalent ES2015 code:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es6-casper-chaining.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">class</span> <span class="nx">HomePage</span> <span class="p">{</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="nx">run</span><span class="p">(</span><span class="nx">casper</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="err">`</span><span class="p">.</span><span class="nx">my</span><span class="o">-</span><span class="nx">section</span><span class="err">:</span><span class="nx">nth</span><span class="o">-</span><span class="nx">of</span><span class="o">-</span><span class="nx">type</span><span class="p">(</span><span class="nx">$</span><span class="p">{</span><span class="nx">n</span><span class="p">})</span> <span class="nx">$</span><span class="p">{</span><span class="nx">selector</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="kd">function</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="k">return</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'#container'</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="p">}</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">casper</span>
</div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenVisit</span><span class="p">(</span><span class="s1">'http://my-url.com/home'</span><span class="p">)</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line">      <span class="p">.</span><span class="nx">thenScreenshot</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="s1">'home'</span><span class="p">);</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'.foo'</span><span class="p">);</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">);</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">casper</span><span class="p">.</span><span class="nx">thenClick</span><span class="p">(</span><span class="s1">'.cancel'</span><span class="p">);</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenClickInMySection</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'.bar'</span><span class="p">);</span>
</div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="nx">casper</span> <span class="o">=</span> <span class="nx">thenScreenshotContainer</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="21" class="code-highlight-row numbered"><div class="code-highlight-line">    <span class="k">return</span> <span class="nx">casper</span><span class="p">;</span>
</div></div><div data-line="22" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="p">}</span>
</div></div><div data-line="23" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span></div></div></pre></div></figure>

<p>It gets the job done, but it doesn't flow as nicely as our chaining example.
Function bind syntax allows us to reduce how much code we write and effectively
express this notion of flowing through each step.</p>

<h2 id="getting-started">Getting Started</h2>

<p>If you'd like to try out function bind syntax, then I encourage you check it out
with Babel. If you've not heard of Babel, it's a transpiler that transforms
ES2015/2016 code into ES5. You can learn more about Babel from its website
(<a href="http://babeljs.io/">link</a>) and learn how to use function bind syntax
<a href="http://babeljs.io/docs/usage/experimental/">here</a>.</p>

<h2 id="gripes-caveats-wishlist">Gripes, Caveats, Wishlist</h2>

<p>I don't think this syntax is without its faults. I'm not entirely sold on the
actual <code>::</code> operator yet. Maybe it's the baggage I carry from other languages
like Ruby, PHP, and CoffeeScript, each which use that operator for different
semantics. Another option might be the <code>-&gt;</code> operator, but it's not my favorite
either (burnout from PHP and C, no doubt). The <code>::</code> operator might be the best
solution, and I don't necessarily hate it.</p>

<p>I haven't dived into the discussion over this spec, but to my knowledge there is
no affordance for partial application via this syntax. Recall that the <code>bind</code>
method on <code>Function.prototype</code> can also partially apply parameters to the bound
function by passing in additional arguments.</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es5-partial-application.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">DEBUG</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">,</span> <span class="s1">'DEBUG:'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">add1</span> <span class="o">=</span> <span class="nx">add</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">var</span> <span class="nx">three</span> <span class="o">=</span> <span class="nx">add1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="nx">DEBUG</span><span class="p">(</span><span class="nx">three</span><span class="p">);</span> <span class="c1">// prints "DEBUG: 3"</span></div></div></pre></div></figure>

<p>I would like to see some type of partial application syntax, especially as we
continue to push the boundaries of functional-style programming in JavaScript.
Alas, I recognize that designing clean, efficient syntax is difficult. This may
just not be possible. Some quick ideas for a syntax could be:</p>

<figure class="code-highlight-figure"><figcaption class="code-highlight-caption"><span class="code-highlight-caption-title">es7-partial-application.js</span><a class="code-highlight-caption-link" href="https://gist.github.com/c64db36d16a2719d7a1d">link</a></figcaption><div class="code-highlight"><pre class="code-highlight-pre"><div data-line="1" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG1</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'DEBUG:'</span><span class="p">);</span>
</div></div><div data-line="2" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// Currently calls the function back on the same receiver</span>
</div></div><div data-line="3" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// var DEBUG1 = console.log.call(console, 'DEBUG:');</span>
</div></div><div data-line="4" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="5" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG2</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">[</span><span class="s1">'DEBUG:'</span><span class="p">];</span>
</div></div><div data-line="6" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// This clashes with existing [] semantics</span>
</div></div><div data-line="7" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// var DEBUG2 = console.log['DEBUG:'].bind(console);</span>
</div></div><div data-line="8" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="9" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG3</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="o">&lt;</span><span class="s1">'DEBUG:'</span><span class="o">&gt;</span><span class="p">;</span>
</div></div><div data-line="10" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError</span>
</div></div><div data-line="11" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="12" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kr">const</span> <span class="nx">DEBUG4</span> <span class="o">=</span> <span class="err">::</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">{</span><span class="s1">'DEBUG:'</span><span class="p">};</span>
</div></div><div data-line="13" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError</span>
</div></div><div data-line="14" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="15" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</div></div><div data-line="16" class="code-highlight-row numbered"><div class="code-highlight-line">  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</div></div><div data-line="17" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="p">}</span>
</div></div><div data-line="18" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="19" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="kd">let</span> <span class="nx">add1</span> <span class="o">=</span> <span class="err">::</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</div></div><div data-line="20" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// SyntaxError (we need a context for the bind operator)</span>
</div></div><div data-line="21" class="code-highlight-row numbered"><div class="code-highlight-line"> </div></div><div data-line="22" class="code-highlight-row numbered"><div class="code-highlight-line"><span class="c1">// ...</span></div></div></pre></div></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Despite my small gripes and wishes, I readily welcome this proposal for ES2016
and hope the maintainers strongly consider its inclusion. This syntax opens up
the door for writing cleaner and more expressive JavaScript.</p>

      
    </div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<div class="post-inner group">
					
					<h1 class="post-title">Getting started with es6 iterators and iterables</h1>
					
					
										
					
					
					<div class="entry">	
						<div class="entry-inner">
							<p><span class="caps">ES6</span> iter­a­tors pro­vide a very sim­ple way to iter­ate on objects, quite sim­i­lar to the way iter­a­tors work in Java. In this post, I will briefly dis­cuss the main con­cepts behind <span class="caps">ES6</span> iter­a­tors and then dive into some exam­ples using arrays. Future posts will dis­cuss using <span class="caps">ES6</span> iter­a­tors with other kinds of objects. This arti­cle is the sec­ond install­ment of our <a href="http://javascript.tutorialhorizon.com/tag/es6/">Learn­ing <span class="caps">ES6</span> series</a>.</p>
<ul>
<li><strong>Part 1</strong>: <a href="http://javascript.tutorialhorizon.com/2015/06/23/es6-modules-examples/">Get­ting started with <span class="caps">ES6</span> modules</a></li>
<li><strong>Part 2</strong>: Get­ting started with <span class="caps">ES6</span> iter­a­tors and iter­ables — <strong><span class="caps">THIS</span> <span class="caps">ARTICLE</span></strong></li>
<li><strong>Part 3</strong>: <a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/"><span class="caps">ES6</span> iter­a­tors and iter­ables — cre­at­ing cus­tom iterators</a></li>
<li><strong>Part 4</strong>: <a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/">Get­ting started with <span class="caps">ES6</span> gen­er­a­tor functions</a></li>
</ul>
<hr>
<h4>A brief introduction</h4>
<p>There are a few things you ought to know before we jump in and see some examples.</p>
<ul>
<li>There are two main types of enti­ties to be aware of: <code>iterables</code> and <code>iterators</code>.</li>
<li>Iter­ables are things that can be iter­ated upon, like arrays, Maps,&nbsp;Sets.</li>
<li>Prim­i­tive javascript objects are not iterable.</li>
<li>Any­thing that imple­ments the <code>next()</code> func­tion can be con­sid­ered to be an iterator.</li>
<li>The result of invok­ing <code>next()</code> is (almost) always object of the form <code>{value: some_value, done: true|false }</code>.</li>
<li>Any object/function can be turned into an iter­able if it has a key called <code>Symbol.iterator</code> which refers to a func­tion that returns an object with the <code>next()</code> function.</li>
</ul>
<p>If you didnt get all of it right away, dont worry, I didnt either. Lets bite off this cake piece by&nbsp;piece.</p>
<blockquote><p>
  <span class="caps">NOTE</span>: If your browser does not sup­port run­ning all the foll­wing exam­ples, you can try them out at <a href="http://www.es6fiddle.net/">es6fiddle.net</a>.
</p></blockquote>
<hr>
<h4>Basic iter­a­tion</h4>
<p>Arrays are the sim­plest and the most com­mon iter­ables. Tra­di­tion­ally, you could iter­ate on arrays as follows</p>
<pre><code class="js">var numbers = ['a', 'b'];
for (var num in numbers) {
  console.log(num);
}
</code></pre>
<p>Using the new <span class="caps">ES6</span> iter­a­tors you can iter­ate on an array as follows:</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter = numbers[Symbol.iterator]();
console.log(iter.next()); // Prints {value: "a", done: false}
console.log(iter.next()); // Prints {value: "b", done: false}
console.log(iter.next()); // Prints {value: undefined, done: true}
</code></pre>
<p>In <span class="caps">ES6</span> <code>Symbol.iterator</code> is a non-string key for iter­ables that is invoked to cre­ate an instance of an iter­a­tor. In fact, <code>Symbol</code> is a com­pletely new prim­i­tive type in <span class="caps">ES6</span>. As you can tell in the above code, the key is already avail­able on the Array prim­i­tive type. All we did was invoke it to cre­ate a new iterator.</p>
<p>Also, in the above code, notice how the last value of iter.next() returns the done as <code>true</code>. This can be used in your pro­gram to deter­mine if there are more items to iter­ate&nbsp;on.</p>
<p>Hav­ing to invoke <code>Symbol.iterator</code> on a prim­i­tive like arrays seems like a bit of an over­head. Thats not to worry because you can also use <code>Array.prototype.entries()</code> to cre­ate the exact same iter­a­tor, albeit in a much more con­ve­nient syntax.</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter1 = numbers.entries();
// is equivalent to
var iter2 = numbers[Symbol.iterator]();
</code></pre>
<blockquote><p>
  The entries() func­tion is avail­able on <span class="caps">ES6</span> prim­i­tives like arrays, typed arrays, maps and sets. In fact, they also have two more use­ful func­tions — keys() and val­ues() which do pretty much what you think they&nbsp;do.
</p></blockquote>
<hr>
<h4>Dif­fer­ent ways to iterate</h4>
<p>Another point to note is that depend­ing on the way you iter­ate, you can expect a dif­fer­ent kind of out­put. For example.</p>
<pre><code class="js">var numbers = ['a', 'b'];
var iter1 = numbers.entries();

console.log(iter1.next()); // Prints {value: "a", done: false}
console.log(iter1.next()); // Prints {value: "b", done: false}
console.log(iter1.next()); // Prints {value: undefined, done: true}

// Compare the above output to the following
for (var item of numbers.entries()) {
    console.log(item);
}
// Output
// [0, "a"]
// [1, "b"]
</code></pre>
<p>Notice in the above code, we had to use the for..of loop for this to work instead of the for..in loop. As far as the out­put is con­cerned, the first item of the out­put array rep­re­sents the <code>key</code> in the entry, which in our case is the index, and the sec­ond item in the out­put array is the actual value of the num­bers&nbsp;array.</p>
<p>The return value of the <code>entries()</code> func­tion makes it suit­able can­di­date for being used along with the <strong>spread oper­a­tor</strong>.</p>
<pre><code class="js">for (var [index, item] of numbers.entries()) {
    console.log(index, item);
}
// Output
// [0, "a"]
// [1, "b"]
</code></pre>
<p>If you wish to, you can also iter­ate on the keys itself. This isin't as use­ful in the case of arrays but comes in really handy when you are using <code>Maps</code>.</p>
<pre><code class="js">var coordinates = new Map();
coordinates.set('x', 10);
coordinates.set('y', 20);

for (var item of coordinates.keys()) {
    console.log(item);
}
// Output
// x
// y
</code></pre>
<blockquote><p>
  <span class="caps">NOTE</span>: <span class="caps">ES6</span> Maps, unlike reg­u­lar javascript objects, return val­ues based on inser­tion order when iter­ated&nbsp;on.
</p></blockquote>
<p>The next and final util­ity func­tion on prim­i­tives is the <code>value()</code> func­tion. And as you would expect, it lets you iter­ate on the values.</p>
<pre><code class="js">var coordinates = new Map();
coordinates.set('x', 10);
coordinates.set('y', 20);

for (var item of coordinates.values()) {
    console.log(item);
}
// Output
// 10
// 20
</code></pre>
<p>That cov­ers all the ways in which you can use the new <span class="caps">ES6</span> iter­a­tors. In the next arti­cle, we will see more exam­ples of cre­at­ing and using your own iter­a­tors and also dis­cuss some of the optional but often times nec­es­sary func­tions like <code>return()</code>.</p>
<hr>
<div id="crp_related" class="crp_related"><h3>Related Posts:</h3><ul><li><a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/" class="crp_title">es6 iter­a­tors and iter­ables — cre­at­ing cus­tom iterators</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/" class="crp_title">Get­ting started with es6 gen­er­a­tor functions</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/23/es6-modules-examples/" class="crp_title">Using es6 mod­ules with sim­ple examples</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/01/17/d3-fundamentals-understanding-domain-range-and-scales-in-d3js/" class="crp_title">d3 Fun­da­men­tals : Under­stand­ing domain, range and scales in&nbsp;D3js</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/09/12/javascript-objects-and-arrays-useful-methods/" class="crp_title">JavaScript Objects and Arrays Use­ful Methods</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/08/06/the-javascript-prototype-property-visualized/" class="crp_title">The JavaScript Pro­to­type Prop­erty — Visualized</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/18/getting-the-parameters-and-arguments-of-a-javascript-function/" class="crp_title">Get­ting the para­me­ters and argu­ments of a javascript function</a></li></ul><div style="clear:both"></div></div>													</div>
						<div class="clear"></div>				
					</div><!--/.entry-->
					
				</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		<div class="post-inner group">
					
					<h1 class="post-title">Using es6 modules with simple examples</h1>
					
					
										
					
					
					<div class="entry">	
						<div class="entry-inner">
							<p>Mod­ules have been around in javascript for a while now. The two com­pet­ing stan­dards for mod­ule dec­la­ra­tion have been the <span class="caps">AMD</span> and Com­monjs spec­i­fi­ca­tion. With the new <span class="caps">ES6</span> specs, mod­ule def­i­n­i­tion and con­sump­tion is now part of the lan­guage itself. This arti­cle will be the first install­ment of our <a href="http://javascript.tutorialhorizon.com/tag/es6/">Learn­ing <span class="caps">ES6</span> series</a>. In this arti­cle, I am going to take some very sim­ple exam­ples to demon­strate the usage of <span class="caps">ES6</span> modules.</p>
<ul>
<li><strong>Part 1</strong>: Get­ting started with <span class="caps">ES6</span> mod­ules — <strong><span class="caps">THIS</span> <span class="caps">ARTICLE</span></strong></li>
<li><strong>Part 2</strong>: <a href="http://javascript.tutorialhorizon.com/2015/06/27/es6-iterators-and-iterables/">Get­ting started with <span class="caps">ES6</span> iter­a­tors and iterables</a></li>
<li><strong>Part 3</strong>: <a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/"><span class="caps">ES6</span> iter­a­tors and iter­ables — cre­at­ing cus­tom iterators</a></li>
<li><strong>Part 4</strong>: <a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/">Get­ting started with <span class="caps">ES6</span> gen­er­a­tor functions</a></li>
</ul>
<hr>
<p>Quite sim­i­lar to Com­monjs, <span class="caps">ES6</span> lets you export and import objects, albeit it does so in slightly dif­fer­ent&nbsp;ways.</p>
<p><strong>Exam­ple&nbsp;1:</strong></p>
<p>Using a sin­gle <code>export</code> at the end of your mod­ule file. This form of usage is called a <em>named export</em> because while export­ing you are defin­ing the name of the objects being exported.</p>
<p><em>foobar.js</em></p>
<pre><code class="js">function foo() { return 'foo'; }

function bar() { return 'bar'; }

export { foo, bar };
</code></pre>
<p>Notice how we use the new javascript object short­hand nota­tion on the last line when export­ing objects.</p>
<p>You can use the exported object from another file as follows.</p>
<p><em>main.js</em></p>
<pre><code class="js">import {foo, bar} from 'foobar';
foo();
bar();

import * as lib from 'foobar';
lib.foo();
lib.bar();
</code></pre>
<hr>
<p><strong>Exam­ple&nbsp;2</strong></p>
<p>In another for­mat for using <em>named exports</em>, you can also export objects/function as and when you cre­ate them. I find this syn­tax a bit more con­ve­nient than the one we saw&nbsp;above.</p>
<p><em>foobar.js</em></p>
<pre><code class="js">export function foo() { return 'foo'; }

export function bar() { return 'bar'; }
</code></pre>
<hr>
<p><strong>Exam­ple&nbsp;3</strong></p>
<p><span class="caps">ES6</span> also has some­thing called as a <code>default</code> export. A file can have zero or 1 default export. For­tu­nately, you can use zero or many <em>named exports</em> in a file con­tain­ing default exports. For example</p>
<p><em>foobar.js</em></p>
<pre><code class="js">export default function foo() {
  return 'default foo';
};

export function bar() { return 'bar'; };
</code></pre>
<hr>
<p>And here's how you would con­sume&nbsp;it</p>
<p><em>main.js</em></p>
<pre><code class="js">// These will only get you foo
import mylib from 'foobar';
import {default as mylib} from 'foobar';

// This will get you both foo and bar
import mylib, {bar} from 'foobar';
</code></pre>
<p>Notice how in the above code, you were able to use the name ‘mylib' instead of ‘foo'. Thats because foo was the default export in your mod­ule so you didn't have to pluck it out of the exported object the way you had to do it if you only had named exported objects.</p>
<p>And that pretty much cov­ers the ways in which you can use the new <span class="caps">ES6</span> modules.</p>
<hr>
<div id="crp_related" class="crp_related"><h3>Related Posts:</h3><ul><li><a href="http://javascript.tutorialhorizon.com/2014/09/01/understanding-nodejs-module-exports-and-require/" class="crp_title">Under­stand­ing nodejs mod­ule exports and require</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/07/23/es6-iterators-part-2-creating-custom-iterators/" class="crp_title">es6 iter­a­tors and iter­ables — cre­at­ing cus­tom iterators</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/06/27/es6-iterators-and-iterables/" class="crp_title">Get­ting started with es6 iter­a­tors and iterables</a></li><li><a href="http://javascript.tutorialhorizon.com/2015/08/19/getting-started-with-es6-generator-functions/" class="crp_title">Get­ting started with es6 gen­er­a­tor functions</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/20/organizing-your-expressjs-routes-in-separate-files/" class="crp_title">Orga­niz­ing your expressjs routes in sep­a­rate&nbsp;files.</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/07/debugging-nodejs-applications-using-node-inspector-and-chrome-dev-tools/" class="crp_title">Debug­ging nodejs appli­ca­tions using node-inspector and Chrome Dev&nbsp;Tools</a></li><li><a href="http://javascript.tutorialhorizon.com/2014/09/07/configuring-jshint-as-a-pre-commit-hook-for-your-nodejs-applications/" class="crp_title">Con­fig­ur­ing jshint as a pre-commit hook for your nodejs applications</a></li></ul><div style="clear:both"></div></div>													</div>
						<div class="clear"></div>				
					</div><!--/.entry-->
					
				</div>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-1-es-now--future" class="anchor" href="#chapter-1-es-now--future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1: ES? Now &amp; Future</h1>

<p>Before you dive into this book, you should have a solid working proficiency over JavaScript up to the most recent standard (at the time of this writing), which is commonly called <em>ES5</em> (technically ES 5.1). Here, we plan to talk squarely about the upcoming <em>ES6</em>, as well as cast our vision beyond to understand how JS will evolve moving forward.</p>

<p>If you are still looking for confidence with JavaScript, I highly recommend you read the other titles in this series first:</p>

<ul>
<li><em>Up &amp; Going</em>: Are you new to programming and JS? This is the roadmap you need to consult as you start your learning journey.</li>
<li><em>Scope &amp; Closures</em>: Did you know that JS lexical scope is based on compiler (not interpreter!) semantics? Can you explain how closures are a direct result of lexical scope and functions as values?</li>
<li><em>this &amp; Object Prototypes</em>: Can you recite the four simple rules for how <code>this</code> is bound? Have you been muddling through fake "classes" in JS instead of adopting the simpler "behavior delegation" design pattern? Ever heard of <em>objects linked to other objects</em> (OLOO)?</li>
<li><em>Types &amp; Grammar</em>: Do you know the built-in types in JS, and more importantly, do you know how to properly and safely use coercion between types? How comfortable are you with the nuances of JS grammar/syntax?</li>
<li><em>Async &amp; Performance</em>: Are you still using callbacks to manage your asynchrony? Can you explain what a promise is and why/how it solves "callback hell"? Do you know how to use generators to improve the legibility of async code? What exactly constitutes mature optimization of JS programs and individual operations?</li>
</ul>

<p>If you've already read all those titles and you feel pretty comfortable with the topics they cover, it's time we dive into the evolution of JS to explore all the changes coming not only soon but farther over the horizon.</p>

<p>Unlike ES5, ES6 is not just a modest set of new APIs added to the language. It incorporates a whole slew of new syntactic forms, some of which may take quite a bit of getting used to. There's also a variety of new organization forms and new API helpers for various data types.</p>

<p>ES6 is a radical jump forward for the language. Even if you think you know JS in ES5, ES6 is full of new stuff you <em>don't know yet</em>, so get ready! This book explores all the major themes of ES6 that you need to get up to speed on, and even gives you a glimpse of future features coming down the track that you should be aware of.</p>

<p><strong>Warning:</strong> All code in this book assumes an ES6+ environment. At the time of this writing, ES6 support varies quite a bit in browsers and JS environments (like Node.js), so your mileage may vary.</p>

<h2><a id="user-content-versioning" class="anchor" href="#versioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Versioning</h2>

<p>The JavaScript standard is referred to officially as "ECMAScript" (abbreviated "ES"), and up until just recently has been versioned entirely by ordinal number (i.e., "5" for "5th edition").</p>

<p>The earliest versions, ES1 and ES2, were not widely known or implemented. ES3 was the first widespread baseline for JavaScript, and constitutes the JavaScript standard for browsers like IE6-8 and older Android 2.x mobile browsers. For political reasons beyond what we'll cover here, the ill-fated ES4 never came about.</p>

<p>In 2009, ES5 was officially finalized (later ES5.1 in 2011), and settled as the widespread standard for JS for the modern revolution and explosion of browsers, such as Firefox, Chrome, Opera, Safari, and many others.</p>

<p>Leading up to the expected <em>next</em> version of JS (slipped from 2013 to 2014 and then 2015), the obvious and common label in discourse has been ES6.</p>

<p>However, late into the ES6 specification timeline, suggestions have surfaced that versioning may in the future switch to a year-based schema, such as ES2016 (aka ES7) to refer to whatever version of the specification is finalized before the end of 2016. Some disagree, but ES6 will likely maintain its dominant mindshare over the late-change substitute ES2015. However, ES2016 may in fact signal the new year-based schema.</p>

<p>It has also been observed that the pace of JS evolution is much faster even than single-year versioning. As soon as an idea begins to progress through standards discussions, browsers start prototyping the feature, and early adopters start experimenting with the code.</p>

<p>Usually well before there's an official stamp of approval, a feature is de facto standardized by virtue of this early engine/tooling prototyping. So it's also valid to consider the future of JS versioning to be per-feature rather than per-arbitrary-collection-of-major-features (as it is now) or even per-year (as it may become).</p>

<p>The takeaway is that the version labels stop being as important, and JavaScript starts to be seen more as an evergreen, living standard. The best way to cope with this is to stop thinking about your code base as being "ES6-based," for instance, and instead consider it feature by feature for support.</p>

<h2><a id="user-content-transpiling" class="anchor" href="#transpiling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transpiling</h2>

<p>Made even worse by the rapid evolution of features, a problem arises for JS developers who at once may both strongly desire to use new features while at the same time being slapped with the reality that their sites/apps may need to support older browsers without such support.</p>

<p>The way ES5 appears to have played out in the broader industry, the typical mindset was that code bases waited to adopt ES5 until most if not all pre-ES5 environments had fallen out of their support spectrum. As a result, many are just recently (at the time of this writing) starting to adopt things like <code>strict</code> mode, which landed in ES5 over five years ago.</p>

<p>It's widely considered to be a harmful approach for the future of the JS ecosystem to wait around and trail the specification by so many years. All those responsible for evolving the language desire for developers to begin basing their code on the new features and patterns as soon as they stabilize in specification form and browsers have a chance to implement them.</p>

<p>So how do we resolve this seeming contradiction? The answer is tooling, specifically a technique called <em>transpiling</em> (transformation + compiling). Roughly, the idea is to use a special tool to transform your ES6 code into equivalent (or close!) matches that work in ES5 environments.</p>

<p>For example, consider shorthand property definitions (see "Object Literal Extensions" in Chapter 2). Here's the ES6 form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    foo     <span class="pl-c">// means `foo: foo`</span>
};

obj.foo;    <span class="pl-c">// [1,2,3]</span></pre></div>

<p>But (roughly) here's how that transpiles:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> foo
};

obj.foo;    <span class="pl-c">// [1,2,3]</span></pre></div>

<p>This is a minor but pleasant transformation that lets us shorten the <code>foo: foo</code> in an object literal declaration to just <code>foo</code>, if the names are the same.</p>

<p>Transpilers perform these transformations for you, usually in a build workflow step similar to how you perform linting, minification, and other similar operations.</p>

<h3><a id="user-content-shimspolyfills" class="anchor" href="#shimspolyfills" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shims/Polyfills</h3>

<p>Not all new ES6 features need a transpiler. Polyfills (aka shims) are a pattern for defining equivalent behavior from a newer environment into an older environment, when possible. Syntax cannot be polyfilled, but APIs often can be.</p>

<p>For example, <code>Object.is(..)</code> is a new utility for checking strict equality of two values but without the nuanced exceptions that <code>===</code> has for <code>NaN</code> and <code>-0</code> values. The polyfill for <code>Object.is(..)</code> is pretty easy:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Object</span>.is) {
    <span class="pl-c1">Object</span>.<span class="pl-en">is</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">v1</span>, <span class="pl-smi">v2</span>) {
        <span class="pl-c">// test for `-0`</span>
        <span class="pl-k">if</span> (v1 <span class="pl-k">===</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> v2 <span class="pl-k">===</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> v1 <span class="pl-k">===</span> <span class="pl-c1">1</span> <span class="pl-k">/</span> v2;
        }
        <span class="pl-c">// test for `NaN`</span>
        <span class="pl-k">if</span> (v1 <span class="pl-k">!==</span> v1) {
            <span class="pl-k">return</span> v2 <span class="pl-k">!==</span> v2;
        }
        <span class="pl-c">// everything else</span>
        <span class="pl-k">return</span> v1 <span class="pl-k">===</span> v2;
    };
}</pre></div>

<p><strong>Tip:</strong> Pay attention to the outer <code>if</code> statement guard wrapped around the polyfill. This is an important detail, which means the snippet only defines its fallback behavior for older environments where the API in question isn't already defined; it would be very rare that you'd want to overwrite an existing API.</p>

<p>There's a great collection of ES6 shims called "ES6 Shim" (<a href="https://github.com/paulmillr/es6-shim/">https://github.com/paulmillr/es6-shim/</a>) that you should definitely adopt as a standard part of any new JS project!</p>

<p>It is assumed that JS will continue to evolve constantly, with browsers rolling out support for features continually rather than in large chunks. So the best strategy for keeping updated as it evolves is to just introduce polyfill shims into your code base, and a transpiler step into your build workflow, right now and get used to that new reality.</p>

<p>If you decide to keep the status quo and just wait around for all browsers without a feature supported to go away before you start using the feature, you're always going to be way behind. You'll sadly be missing out on all the innovations designed to make writing JavaScript more effective, efficient, and robust.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 (some may try to call it ES2015) is just landing as of the time of this writing, and it has lots of new stuff you need to learn!</p>

<p>But it's even more important to shift your mindset to align with the new way that JavaScript is going to evolve. It's not just waiting around for years for some official document to get a vote of approval, as many have done in the past.</p>

<p>Now, JavaScript features land in browsers as they become ready, and it's up to you whether you'll get on the train early or whether you'll be playing costly catch-up games years from now.</p>

<p>Whatever labels that future JavaScript adopts, it's going to move a lot quicker than it ever has before. Transpilers and shims/polyfills are important tools to keep you on the forefront of where the language is headed.</p>

<p>If there's any narrative important to understand about the new reality for JavaScript, it's that all JS developers are strongly implored to move from the trailing edge of the curve to the leading edge. And learning ES6 is where that all starts!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-2-syntax" class="anchor" href="#chapter-2-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2: Syntax</h1>

<p>If you've been writing JS for any length of time, odds are the syntax is pretty familiar to you. There are certainly many quirks, but overall it's a fairly reasonable and straightforward syntax that draws many similarities from other languages.</p>

<p>However, ES6 adds quite a few new syntactic forms that take some getting used to. In this chapter, we'll tour through them to find out what's in store.</p>

<p><strong>Tip:</strong> At the time of this writing, some of the features discussed in this book have been implemented in various browsers (Firefox, Chrome, etc.), but some have only been partially implemented and many others have not been implemented at all. Your experience may be mixed trying these examples directly. If so, try them out with transpilers, as most of these features are covered by those tools. ES6Fiddle (<a href="http://www.es6fiddle.net/">http://www.es6fiddle.net/</a>) is a great, easy-to-use playground for trying out ES6, as is the online REPL for the Babel transpiler (<a href="http://babeljs.io/repl/">http://babeljs.io/repl/</a>).</p>

<h2><a id="user-content-block-scoped-declarations" class="anchor" href="#block-scoped-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block-Scoped Declarations</h2>

<p>You're probably aware that the fundamental unit of variable scoping in JavaScript has always been the <code>function</code>. If you needed to create a block of scope, the most prevalent way to do so other than a regular function declaration was the immediately invoked function expression (IIFE). For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

(<span class="pl-k">function</span> <span class="pl-en">IIFE</span>(){
    <span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 3</span>
})();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// 2</span></pre></div>

<h3><a id="user-content-let-declarations" class="anchor" href="#let-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code> Declarations</h3>

<p>However, we can now create declarations that are bound to any block, called (unsurprisingly) <em>block scoping</em>. This means all we need is a pair of <code>{ .. }</code> to create a scope. Instead of using <code>var</code>, which always declares variables attached to the enclosing function (or global, if top level) scope, use <code>let</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

{
    <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 3</span>
}

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// 2</span></pre></div>

<p>It's not very common or idiomatic thus far in JS to use a standalone <code>{ .. }</code> block, but it's always been valid. And developers from other languages that have <em>block scoping</em> will readily recognize that pattern.</p>

<p>I believe this is the best way to create block-scoped variables, with a dedicated <code>{ .. }</code> block. Moreover, you should always put the <code>let</code> declaration(s) at the very top of that block. If you have more than one to declare, I'd recommend using just one <code>let</code>.</p>

<p>Stylistically, I even prefer to put the <code>let</code> on the same line as the opening <code>{</code>, to make it clearer that this block is only for the purpose of declaring the scope for those variables.</p>

<div class="highlight highlight-source-js"><pre>{   <span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>, b, c;
    <span class="pl-c">// ..</span>
}</pre></div>

<p>Now, that's going to look strange and it's not likely going to match the recommendations given in most other ES6 literature. But I have reasons for my madness.</p>

<p>There's another experimental (not standardized) form of the <code>let</code> declaration called the <code>let</code>-block, which looks like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">let</span> (<span class="pl-smi">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>, <span class="pl-smi">b</span>, <span class="pl-smi">c</span>) {
    <span class="pl-c">// ..</span>
}</pre></div>

<p>That form is what I'd called <em>explicit</em> block scoping, whereas the <code>let ..</code> declaration form that mirrors <code>var</code> is more <em>implicit</em>, as it kind of hijacks whatever <code>{ .. }</code> pair it's found in. Generally developers find <em>explicit</em> mechanisms a bit more preferable than <em>implicit</em> mechanisms, and I claim this is one of those cases.</p>

<p>If you compare the previous two snippet forms, they're very similar, and in my opinion both qualify stylistically as <em>explicit</em> block scoping. Unfortunately, the <code>let (..) { .. }</code> form, the most <em>explicit</em> of the options, was not adopted in ES6. That may be revisited post-ES6, but for now the former option is our best bet, I think.</p>

<p>To reinforce the <em>implicit</em> nature of <code>let ..</code> declarations, consider these usages:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">let</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">if</span> (a <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
    <span class="pl-k">let</span> b <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b );       <span class="pl-c">// 6</span>

    <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> a; i <span class="pl-k">&lt;=</span> b; i<span class="pl-k">++</span>) {
        <span class="pl-k">let</span> j <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">10</span>;
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
    }
    <span class="pl-c">// 12 13 14 15 16</span>

    <span class="pl-k">let</span> c <span class="pl-k">=</span> a <span class="pl-k">+</span> b;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( c );       <span class="pl-c">// 8</span>
}</pre></div>

<p>Quick quiz without looking back at that snippet: which variable(s) exist only inside the <code>if</code> statement, and which variable(s) exist only inside the <code>for</code> loop?</p>

<p>The answers: the <code>if</code> statement contains <code>b</code> and <code>c</code> block-scoped variables, and the <code>for</code> loop contains <code>i</code> and <code>j</code> block-scoped variables.</p>

<p>Did you have to think about it for a moment? Does it surprise you that <code>i</code> isn't added to the enclosing <code>if</code> statement scope? That mental pause and questioning -- I call it a "mental tax" -- comes from the fact that this <code>let</code> mechanism is not only new to us, but it's also <em>implicit</em>.</p>

<p>There's also hazard in the <code>let c = ..</code> declaration appearing so far down in the scope. Unlike traditional <code>var</code>-declared variables, which are attached to the entire enclosing function scope regardless of where they appear, <code>let</code> declarations attach to the block scope but are not initialized until they appear in the block.</p>

<p>Accessing a <code>let</code>-declared variable earlier than its <code>let ..</code> declaration/initialization causes an error, whereas with <code>var</code> declarations the ordering doesn't matter (except stylistically).</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// undefined</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( b );   <span class="pl-c">// ReferenceError!</span>

    <span class="pl-k">var</span> a;
    <span class="pl-k">let</span> b;
}</pre></div>

<p><strong>Warning:</strong> This <code>ReferenceError</code> from accessing too-early <code>let</code>-declared references is technically called a <em>Temporal Dead Zone (TDZ)</em> error -- you're accessing a variable that's been declared but not yet initialized. This will not be the only time we see TDZ errors -- they crop up in several places in ES6. Also, note that "initialized" doesn't require explicitly assigning a value in your code, as <code>let b;</code> is totally valid. A variable that's not given an assignment at declaration time is assumed to have been assigned the <code>undefined</code> value, so <code>let b;</code> is the same as <code>let b = undefined;</code>. Explicit assignment or not, you cannot access <code>b</code> until the <code>let b</code> statement is run.</p>

<p>One last gotcha: <code>typeof</code> behaves differently with TDZ variables than it does with undeclared (or declared!) variables. For example:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-c">// `a` is not declared</span>
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> a <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// `b` is declared, but in its TDZ</span>
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> b <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span>undefined<span class="pl-pds">"</span></span>) {     <span class="pl-c">// ReferenceError!</span>
        <span class="pl-c">// ..</span>
    }

    <span class="pl-c">// ..</span>

    <span class="pl-k">let</span> b;
}</pre></div>

<p>The <code>a</code> is not declared, so <code>typeof</code> is the only safe way to check for its existence or not. But <code>typeof b</code> throws the TDZ error because farther down in the code there happens to be a <code>let b</code> declaration. Oops.</p>

<p>Now it should be clearer why I insist that <code>let</code> declarations should all be at the top of their scope. That totally avoids the accidental errors of accessing too early. It also makes it more <em>explicit</em> when you look at the start of a block, any block, what variables it contains.</p>

<p>Your blocks (<code>if</code> statements, <code>while</code> loops, etc.) don't have to share their original behavior with scoping behavior.</p>

<p>This explicitness on your part, which is up to you to maintain with discipline, will save you lots of refactor headaches and footguns down the line.</p>

<p><strong>Note:</strong> For more information on <code>let</code> and block scoping, see Chapter 3 of the <em>Scope &amp; Closures</em> title of this series.</p>

<h4><a id="user-content-let--for" class="anchor" href="#let--for" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>let</code> + <code>for</code></h4>

<p>The only exception I'd make to the preference for the <em>explicit</em> form of <code>let</code> declaration blocking is a <code>let</code> that appears in the header of a <code>for</code> loop. The reason may seem nuanced, but I believe it to be one of the more important ES6 features.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> funcs <span class="pl-k">=</span> [];

<span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    funcs.<span class="pl-c1">push</span>( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
    } );
}

funcs[<span class="pl-c1">3</span>]();     <span class="pl-c">// 3</span></pre></div>

<p>The <code>let i</code> in the <code>for</code> header declares an <code>i</code> not just for the <code>for</code> loop itself, but it redeclares a new <code>i</code> for each iteration of the loop. That means that closures created inside the loop iteration close over those per-iteration variables the way you'd expect.</p>

<p>If you tried that same snippet but with <code>var i</code> in the <code>for</code> loop header, you'd get <code>5</code> instead of <code>3</code>, because there'd only be one <code>i</code> in the outer scope that was closed over, instead of a new <code>i</code> for each iteration's function to close over.</p>

<p>You could also have accomplished the same thing slightly more verbosely:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> funcs <span class="pl-k">=</span> [];

<span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>; i<span class="pl-k">++</span>) {
    <span class="pl-k">let</span> j <span class="pl-k">=</span> i;
    funcs.<span class="pl-c1">push</span>( <span class="pl-k">function</span>(){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( j );
    } );
}

funcs[<span class="pl-c1">3</span>]();     <span class="pl-c">// 3</span></pre></div>

<p>Here, we forcibly create a new <code>j</code> for each iteration, and then the closure works the same way. I prefer the former approach; that extra special capability is why I endorse the <code>for (let .. ) ..</code> form. It could be argued it's somewhat more <em>implicit</em>, but it's <em>explicit</em> enough, and useful enough, for my tastes.</p>

<p><code>let</code> also works the same way with <code>for..in</code> and <code>for..of</code> loops (see "<code>for..of</code> Loops").</p>

<h3><a id="user-content-const-declarations" class="anchor" href="#const-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>const</code> Declarations</h3>

<p>There's one other form of block-scoped declaration to consider: the <code>const</code>, which creates <em>constants</em>.</p>

<p>What exactly is a constant? It's a variable that's read-only after its initial value is set. Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-k">const</span> <span class="pl-c1">a</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );   <span class="pl-c">// 2</span>

    a <span class="pl-k">=</span> <span class="pl-c1">3</span>;              <span class="pl-c">// TypeError!</span>
}</pre></div>

<p>You are not allowed to change the value the variable holds once it's been set, at declaration time. A <code>const</code> declaration must have an explicit initialization. If you wanted a <em>constant</em> with the <code>undefined</code> value, you'd have to declare <code>const a = undefined</code> to get it.</p>

<p>Constants are not a restriction on the value itself, but on the variable's assignment of that value. In other words, the value is not frozen or immutable because of <code>const</code>, just the assignment of it. If the value is complex, such as an object or array, the contents of the value can still be modified:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-k">const</span> <span class="pl-c1">a</span> <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
    a.<span class="pl-c1">push</span>( <span class="pl-c1">4</span> );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a );       <span class="pl-c">// [1,2,3,4]</span>

    a <span class="pl-k">=</span> <span class="pl-c1">42</span>;                 <span class="pl-c">// TypeError!</span>
}</pre></div>

<p>The <code>a</code> variable doesn't actually hold a constant array; rather, it holds a constant reference to the array. The array itself is freely mutable.</p>

<p><strong>Warning:</strong> Assigning an object or array as a constant means that value will not be able to be garbage collected until that constant's lexical scope goes away, as the reference to the value can never be unset. That may be desirable, but be careful if it's not your intent!</p>

<p>Essentially, <code>const</code> declarations enforce what we've stylistically signaled with our code for years, where we declared a variable name of all uppercase letters and assigned it some literal value that we took care never to change. There's no enforcement on a <code>var</code> assignment, but there is now with a <code>const</code> assignment, which can help you catch unintended changes.</p>

<p><code>const</code> <em>can</em> be used with variable declarations of <code>for</code>, <code>for..in</code>, and <code>for..of</code> loops (see "<code>for..of</code> Loops"). However, an error will be thrown if there's any attempt to reassign, such as the typical <code>i++</code> clause of a <code>for</code> loop.</p>

<h4><a id="user-content-const-or-not" class="anchor" href="#const-or-not" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>const</code> Or Not</h4>

<p>There's some rumored assumptions that a <code>const</code> could be more optimizable by the JS engine in certain scenarios than a <code>let</code> or <code>var</code> would be. Theoretically, the engine more easily knows the variable's value/type will never change, so it can eliminate some possible tracking.</p>

<p>Whether <code>const</code> really helps here or this is just our own fantasies and intuitions, the much more important decision to make is if you intend constant behavior or not. Remember: one of the most important roles for source code is to communicate clearly, not only to you, but your future self and other code collaborators, what your intent is.</p>

<p>Some developers prefer to start out every variable declaration as a <code>const</code> and then relax a declaration back to a <code>let</code> if it becomes necessary for its value to change in the code. This is an interesting perspective, but it's not clear that it genuinely improves the readability or reason-ability of code.</p>

<p>It's not really a <em>protection</em>, as many believe, because any later developer who wants to change a value of a <code>const</code> can just blindly change <code>const</code> to <code>let</code> on the declaration. At best, it protects accidental change. But again, other than our intuitions and sensibilities, there doesn't appear to be objective and clear measure of what constitutes "accidents" or prevention thereof. Similar mindsets exist around type enforcement.</p>

<p>My advice: to avoid potentially confusing code, only use <code>const</code> for variables that you're intentionally and obviously signaling will not change. In other words, don't <em>rely on</em> <code>const</code> for code behavior, but instead use it as a tool for signaling intent, when intent can be signaled clearly.</p>

<h3><a id="user-content-block-scoped-functions" class="anchor" href="#block-scoped-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block-scoped Functions</h3>

<p>Starting with ES6, function declarations that occur inside of blocks are now specified to be scoped to that block. Prior to ES6, the specification did not call for this, but many implementations did it anyway. So now the specification meets reality.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>{
    foo();                  <span class="pl-c">// works!</span>

    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-c">// ..</span>
    }
}

foo();                      <span class="pl-c">// ReferenceError</span></pre></div>

<p>The <code>foo()</code> function is declared inside the <code>{ .. }</code> block, and as of ES6 is block-scoped there. So it's not available outside that block. But also note that it is "hoisted" within the block, as opposed to <code>let</code> declarations, which suffer the TDZ error trap mentioned earlier.</p>

<p>Block-scoping of function declarations could be a problem if you've ever written code like this before, and relied on the old legacy non-block-scoped behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (something) {
    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> );
    }
}
<span class="pl-k">else</span> {
    <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span> );
    }
}

foo();      <span class="pl-c">// ??</span></pre></div>

<p>In pre-ES6 environments, <code>foo()</code> would print <code>"2"</code> regardless of the value of <code>something</code>, because both function declarations were hoisted out of the blocks, and the second one always wins.</p>

<p>In ES6, that last line throws a <code>ReferenceError</code>.</p>

<h2><a id="user-content-spreadrest" class="anchor" href="#spreadrest" aria-hidden="true"><span class="octicon octicon-link"></span></a>Spread/Rest</h2>

<p>ES6 introduces a new <code>...</code> operator that's typically referred to as the <em>spread</em> or <em>rest</em> operator, depending on where/how it's used. Let's take a look:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo( ...[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>] );              <span class="pl-c">// 1 2 3</span></pre></div>

<p>When <code>...</code> is used in front of an array (actually, any <em>iterable</em>, which we cover in Chapter 3), it acts to "spread" it out into its individual values.</p>

<p>You'll typically see that usage as is shown in that previous snippet, when spreading out an array as a set of arguments to a function call. In this usage, <code>...</code> acts to give us a simpler syntactic replacement for the <code>apply(..)</code> method, which we would typically have used pre-ES6 as:</p>

<div class="highlight highlight-source-js"><pre>foo.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>] );     <span class="pl-c">// 1 2 3</span></pre></div>

<p>But <code>...</code> can be used to spread out/expand a value in other contexts as well, such as inside another array declaration:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, ...a, <span class="pl-c1">5</span> ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );                   <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p>In this usage, <code>...</code> is basically replacing <code>concat(..)</code>, as it behaves like <code>[1].concat( a, [5] )</code> here.</p>

<p>The other common usage of <code>...</code> can be seen as essentially the opposite; instead of spreading a value out, the <code>...</code> <em>gathers</em> a set of values together into an array. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span> );           <span class="pl-c">// 1 2 [3,4,5]</span></pre></div>

<p>The <code>...z</code> in this snippet is essentially saying: "gather the <em>rest</em> of the arguments (if any) into an array called <code>z</code>." Because <code>x</code> was assigned <code>1</code>, and <code>y</code> was assigned <code>2</code>, the rest of the arguments <code>3</code>, <code>4</code>, and <code>5</code> were gathered into <code>z</code>.</p>

<p>Of course, if you don't have any named parameters, the <code>...</code> gathers all arguments:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( args );
}

foo( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>);            <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p><strong>Note:</strong> The <code>...args</code> in the <code>foo(..)</code> function declaration is usually called "rest parameters," because you're collecting the rest of the parameters. I prefer "gather," because it's more descriptive of what it does rather than what it contains.</p>

<p>The best part about this usage is that it provides a very solid alternative to using the long-since-deprecated <code>arguments</code> array -- actually, it's not really an array, but an array-like object. Because <code>args</code> (or whatever you call it -- a lot of people prefer <code>r</code> or <code>rest</code>) is a real array, we can get rid of lots of silly pre-ES6 tricks we jumped through to make <code>arguments</code> into something we can treat as an array.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// doing things the new ES6 way</span>
<span class="pl-k">function</span> <span class="pl-en">foo</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-c">// `args` is already a real array</span>

    <span class="pl-c">// discard first element in `args`</span>
    args.<span class="pl-c1">shift</span>();

    <span class="pl-c">// pass along all of `args` as arguments</span>
    <span class="pl-c">// to `console.log(..)`</span>
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( ...args );
}

<span class="pl-c">// doing things the old-school pre-ES6 way</span>
<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-c">// turn `arguments` into a real array</span>
    <span class="pl-k">var</span> args <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arguments );

    <span class="pl-c">// add some elements on the end</span>
    args.<span class="pl-c1">push</span>( <span class="pl-c1">4</span>, <span class="pl-c1">5</span> );

    <span class="pl-c">// filter out odd numbers</span>
    args <span class="pl-k">=</span> args.filter( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
        <span class="pl-k">return</span> v <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>;
    } );

    <span class="pl-c">// pass along all of `args` as arguments</span>
    <span class="pl-c">// to `foo(..)`</span>
    foo.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, args );
}

bar( <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );                  <span class="pl-c">// 2 4</span></pre></div>

<p>The <code>...args</code> in the <code>foo(..)</code> function declaration gathers arguments, and the <code>...args</code> in the <code>console.log(..)</code> call spreads them out. That's a good illustration of the symmetric but opposite uses of the <code>...</code> operator.</p>

<p>Besides the <code>...</code> usage in a function declaration, there's another case where <code>...</code> is used for gathering values, and we'll look at it in the "Too Many, Too Few, Just Enough" section later in this chapter.</p>

<h2><a id="user-content-default-parameter-values" class="anchor" href="#default-parameter-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Parameter Values</h2>

<p>Perhaps one of the most common idioms in JavaScript relates to setting a default value for a function parameter. The way we've done this for years should look quite familiar:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> x <span class="pl-k">||</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> y <span class="pl-k">||</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo();              <span class="pl-c">// 42</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );        <span class="pl-c">// 11</span>
foo( <span class="pl-c1">5</span> );           <span class="pl-c">// 36</span>
foo( <span class="pl-c1">null</span>, <span class="pl-c1">6</span> );     <span class="pl-c">// 17</span></pre></div>

<p>Of course, if you've used this pattern before, you know that it's both helpful and a little bit dangerous, if for example you need to be able to pass in what would otherwise be considered a falsy value for one of the parameters. Consider:</p>

<div class="highlight highlight-source-js"><pre>foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );       <span class="pl-c">// 53 &lt;-- Oops, not 42</span></pre></div>

<p>Why? Because the <code>0</code> is falsy, and so the <code>x || 11</code> results in <code>11</code>, not the directly passed in <code>0</code>.</p>

<p>To fix this gotcha, some people will instead write the check more verbosely like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> (x <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span> x <span class="pl-k">:</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> (y <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span> y <span class="pl-k">:</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );           <span class="pl-c">// 42</span>
foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">6</span> );    <span class="pl-c">// 17</span></pre></div>

<p>Of course, that means that any value except <code>undefined</code> can be directly passed in. However, <code>undefined</code> will be assumed to signal, "I didn't pass this in." That works great unless you actually need to be able to pass <code>undefined</code> in.</p>

<p>In that case, you could test to see if the argument is actually omitted, by it actually not being present in the <code>arguments</code> array, perhaps like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    x <span class="pl-k">=</span> (<span class="pl-c1">0</span> <span class="pl-k">in</span> arguments) <span class="pl-k">?</span> x <span class="pl-k">:</span> <span class="pl-c1">11</span>;
    y <span class="pl-k">=</span> (<span class="pl-c1">1</span> <span class="pl-k">in</span> arguments) <span class="pl-k">?</span> y <span class="pl-k">:</span> <span class="pl-c1">31</span>;

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo( <span class="pl-c1">5</span> );               <span class="pl-c">// 36</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">undefined</span> );    <span class="pl-c">// NaN</span></pre></div>

<p>But how would you omit the first <code>x</code> argument without the ability to pass in any kind of value (not even <code>undefined</code>) that signals "I'm omitting this argument"?</p>

<p><code>foo(,5)</code> is tempting, but it's invalid syntax. <code>foo.apply(null,[,5])</code> seems like it should do the trick, but <code>apply(..)</code>'s quirks here mean that the arguments are treated as <code>[undefined,5]</code>, which of course doesn't omit.</p>

<p>If you investigate further, you'll find you can only omit arguments on the end (i.e., righthand side) by simply passing fewer arguments than "expected," but you cannot omit arguments in the middle or at the beginning of the arguments list. It's just not possible.</p>

<p>There's a principle applied to JavaScript's design here that is important to remember: <code>undefined</code> means <em>missing</em>. That is, there's no difference between <code>undefined</code> and <em>missing</em>, at least as far as function arguments go.</p>

<p><strong>Note:</strong> There are, confusingly, other places in JS where this particular design principle doesn't apply, such as for arrays with empty slots. See the <em>Types &amp; Grammar</em> title of this series for more information.</p>

<p>With all this in mind, we can now examine a nice helpful syntax added as of ES6 to streamline the assignment of default values to missing arguments:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">11</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-c1">31</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y );
}

foo();                  <span class="pl-c">// 42</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );            <span class="pl-c">// 11</span>
foo( <span class="pl-c1">0</span>, <span class="pl-c1">42</span> );           <span class="pl-c">// 42</span>

foo( <span class="pl-c1">5</span> );               <span class="pl-c">// 36</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">undefined</span> );    <span class="pl-c">// 36 &lt;-- `undefined` is missing</span>
foo( <span class="pl-c1">5</span>, <span class="pl-c1">null</span> );         <span class="pl-c">// 5  &lt;-- null coerces to `0`</span>

foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">6</span> );    <span class="pl-c">// 17 &lt;-- `undefined` is missing</span>
foo( <span class="pl-c1">null</span>, <span class="pl-c1">6</span> );         <span class="pl-c">// 6  &lt;-- null coerces to `0`</span></pre></div>

<p>Notice the results and how they imply both subtle differences and similarities to the earlier approaches.</p>

<p><code>x = 11</code> in a function declaration is more like <code>x !== undefined ? x : 11</code> than the much more common idiom <code>x || 11</code>, so you'll need to be careful in converting your pre-ES6 code to this ES6 default parameter value syntax.</p>

<p><strong>Note:</strong> A rest/gather parameter (see "Spread/Rest") cannot have a default value. So, while <code>function foo(...vals=[1,2,3]) {</code> might seem an intriguing capability, it's not valid syntax. You'll need to continue to apply that sort of logic manually if necessary.</p>

<h3><a id="user-content-default-value-expressions" class="anchor" href="#default-value-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Value Expressions</h3>

<p>Function default values can be more than just simple values like <code>31</code>; they can be any valid expression, even a function call:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">val</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>bar called!<span class="pl-pds">"</span></span> );
    <span class="pl-k">return</span> y <span class="pl-k">+</span> val;
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-smi">y</span> + <span class="pl-c1">3</span>, <span class="pl-smi">z</span> <span class="pl-k">=</span> <span class="pl-smi">bar</span>( <span class="pl-smi">x</span> )) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, z );
}

<span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-c1">5</span>;
foo();                              <span class="pl-c">// "bar called"</span>
                                    <span class="pl-c">// 8 13</span>
foo( <span class="pl-c1">10</span> );                          <span class="pl-c">// "bar called"</span>
                                    <span class="pl-c">// 10 15</span>
y <span class="pl-k">=</span> <span class="pl-c1">6</span>;
foo( <span class="pl-c1">undefined</span>, <span class="pl-c1">10</span> );               <span class="pl-c">// 9 10</span></pre></div>

<p>As you can see, the default value expressions are lazily evaluated, meaning they're only run if and when they're needed -- that is, when a parameter's argument is omitted or is <code>undefined</code>.</p>

<p>It's a subtle detail, but the formal parameters in a function declaration are in their own scope (think of it as a scope bubble wrapped around just the <code>( .. )</code> of the function declaration), not in the function body's scope. That means a reference to an identifier in a default value expression first matches the formal parameters' scope before looking to an outer scope. See the <em>Scope &amp; Closures</em> title of this series for more information.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> w <span class="pl-k">=</span> <span class="pl-c1">1</span>, z <span class="pl-k">=</span> <span class="pl-c1">2</span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>( <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-smi">w</span> + <span class="pl-c1">1</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-smi">x</span> + <span class="pl-c1">1</span>, <span class="pl-smi">z</span> <span class="pl-k">=</span> <span class="pl-smi">z</span> + <span class="pl-c1">1</span> ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}

foo();                  <span class="pl-c">// ReferenceError</span></pre></div>

<p>The <code>w</code> in the <code>w + 1</code> default value expression looks for <code>w</code> in the formal parameters' scope, but does not find it, so the outer scope's <code>w</code> is used. Next, The <code>x</code> in the <code>x + 1</code> default value expression finds <code>x</code> in the formal parameters' scope, and luckily <code>x</code> has already been initialized, so the assignment to <code>y</code> works fine.</p>

<p>However, the <code>z</code> in <code>z + 1</code> finds <code>z</code> as a not-yet-initialized-at-that-moment parameter variable, so it never tries to find the <code>z</code> from the outer scope.</p>

<p>As we mentioned in the "<code>let</code> Declarations" section earlier in this chapter, ES6 has a TDZ, which prevents a variable from being accessed in its uninitialized state. As such, the <code>z + 1</code> default value expression throws a TDZ <code>ReferenceError</code> error.</p>

<p>Though it's not necessarily a good idea for code clarity, a default value expression can even be an inline function expression call -- commonly referred to as an immediately invoked function expression (IIFE):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( <span class="pl-smi">x</span> <span class="pl-k">=</span>
    (<span class="pl-smi">function</span>(<span class="pl-smi">v</span>){ <span class="pl-k">return</span> v <span class="pl-k">+</span> <span class="pl-c1">11</span>; })( <span class="pl-c1">31</span> )
) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}

foo();          <span class="pl-c">// 42</span></pre></div>

<p>There will very rarely be any cases where an IIFE (or any other executed inline function expression) will be appropriate for default value expressions. If you find yourself tempted to do this, take a step back and reevaluate!</p>

<p><strong>Warning:</strong> If the IIFE had tried to access the <code>x</code> identifier and had not declared its own <code>x</code>, this would also have been a TDZ error, just as discussed before.</p>

<p>The default value expression in the previous snippet is an IIFE in that in the sense that it's a function that's executed right inline, via <code>(31)</code>. If we had left that part off, the default value assigned to <code>x</code> would have just been a function reference itself, perhaps like a default callback. There will probably be cases where that pattern will be quite useful, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>, <span class="pl-smi">cb</span> <span class="pl-k">=</span> <span class="pl-smi">function</span>(){}) {
    <span class="pl-c">// ..</span>
}

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );</pre></div>

<p>In this case, we essentially want to default <code>cb</code> to be a no-op empty function call if not otherwise specified. The function expression is just a function reference, not a function call itself (no invoking <code>()</code> on the end of it), which accomplishes that goal.</p>

<p>Since the early days of JS, there's been a little-known but useful quirk available to us: <code>Function.prototype</code> is itself an empty no-op function. So, the declaration could have been <code>cb = Function.prototype</code> and saved the inline function expression creation.</p>

<h2><a id="user-content-destructuring" class="anchor" href="#destructuring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring</h2>

<p>ES6 introduces a new syntactic feature called <em>destructuring</em>, which may be a little less confusing if you instead think of it as <em>structured assignment</em>. To understand this meaning, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">return</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
}

<span class="pl-k">var</span> tmp <span class="pl-k">=</span> foo(),
    a <span class="pl-k">=</span> tmp[<span class="pl-c1">0</span>], b <span class="pl-k">=</span> tmp[<span class="pl-c1">1</span>], c <span class="pl-k">=</span> tmp[<span class="pl-c1">2</span>];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span></pre></div>

<p>As you can see, we created a manual assignment of the values in the array that <code>foo()</code> returns to individual variables <code>a</code>, <code>b</code>, and <code>c</code>, and to do so we (unfortunately) needed the <code>tmp</code> variable.</p>

<p>Similarly, we can do the following with objects:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">return</span> {
        x<span class="pl-k">:</span> <span class="pl-c1">4</span>,
        y<span class="pl-k">:</span> <span class="pl-c1">5</span>,
        z<span class="pl-k">:</span> <span class="pl-c1">6</span>
    };
}

<span class="pl-k">var</span> tmp <span class="pl-k">=</span> bar(),
    x <span class="pl-k">=</span> tmp.<span class="pl-c1">x</span>, y <span class="pl-k">=</span> tmp.<span class="pl-c1">y</span>, z <span class="pl-k">=</span> tmp.<span class="pl-c1">z</span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>The <code>tmp.x</code> property value is assigned to the <code>x</code> variable, and likewise for <code>tmp.y</code> to <code>y</code> and <code>tmp.z</code> to <code>z</code>.</p>

<p>Manually assigning indexed values from an array or properties from an object can be thought of as <em>structured assignment</em>. ES6 adds a dedicated syntax for <em>destructuring</em>, specifically <em>array destructuring</em> and <em>object destructuring</em>. This syntax eliminates the need for the <code>tmp</code> variable in the previous snippets, making them much cleaner. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [ a, b, c ] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x<span class="pl-k">:</span> x, y<span class="pl-k">:</span> y, z<span class="pl-k">:</span> z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>You're likely more accustomed to seeing syntax like <code>[a,b,c]</code> on the righthand side of an <code>=</code> assignment, as the value being assigned.</p>

<p>Destructuring symmetrically flips that pattern, so that <code>[a,b,c]</code> on the lefthand side of the <code>=</code> assignment is treated as a kind of "pattern" for decomposing the righthand side array value into separate variable assignments.</p>

<p>Similarly, <code>{ x: x, y: y, z: z }</code> specifies a "pattern" to decompose the object value from <code>bar()</code> into separate variable assignments.</p>

<h3><a id="user-content-object-property-assignment-pattern" class="anchor" href="#object-property-assignment-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Property Assignment Pattern</h3>

<p>Let's dig into that <code>{ x: x, .. }</code> syntax from the previous snippet. If the property name being matched is the same as the variable you want to declare, you can actually shorten the syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x, y, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>Pretty cool, right?</p>

<p>But is <code>{ x, .. }</code> leaving off the <code>x:</code> part or leaving off the <code>: x</code> part? We're actually leaving off the <code>x:</code> part when we use the shorter syntax. That may not seem like an important detail, but you'll understand its importance in just a moment.</p>

<p>If you can write the shorter form, why would you ever write out the longer form? Because that longer form actually allows you to assign a property to a different variable name, which can sometimes be quite useful:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x<span class="pl-k">:</span> bam, y<span class="pl-k">:</span> baz, z<span class="pl-k">:</span> bap } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( bam, baz, bap );       <span class="pl-c">// 4 5 6</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// ReferenceError</span></pre></div>

<p>There's a subtle but super-important quirk to understand about this variation of the object destructuring form. To illustrate why it can be a gotcha you need to be careful of, let's consider the "pattern" of how normal object literals are specified:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> X <span class="pl-k">=</span> <span class="pl-c1">10</span>, Y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span> X, b<span class="pl-k">:</span> Y };

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a, o.b );            <span class="pl-c">// 10 20</span></pre></div>

<p>In <code>{ a: X, b: Y }</code>, we know that <code>a</code> is the object property, and <code>X</code> is the source value that gets assigned to it. In other words, the syntactic pattern is <code>target: source</code>, or more obviously, <code>property-alias: value</code>. We intuitively understand this because it's the same as <code>=</code> assignment, where the pattern is <code>target = source</code>.</p>

<p>However, when you use object destructuring assignment -- that is, putting the <code>{ .. }</code> object literal-looking syntax on the lefthand side of the <code>=</code> operator -- you invert that <code>target: source</code> pattern.</p>

<p>Recall:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x<span class="pl-k">:</span> bam, y<span class="pl-k">:</span> baz, z<span class="pl-k">:</span> bap } <span class="pl-k">=</span> bar();</pre></div>

<p>The syntactic pattern here is <code>source: target</code> (or <code>value: variable-alias</code>). <code>x: bam</code> means the <code>x</code> property is the source value and <code>bam</code> is the target variable to assign to. In other words, object literals are <code>target &lt;-- source</code>, and object destructuring assignments are <code>source --&gt; target</code>. See how that's flipped?</p>

<p>There's another way to think about this syntax though, which may help ease the confusion. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> aa <span class="pl-k">=</span> <span class="pl-c1">10</span>, bb <span class="pl-k">=</span> <span class="pl-c1">20</span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> { x<span class="pl-k">:</span> aa, y<span class="pl-k">:</span> bb };
<span class="pl-k">var</span>     { x<span class="pl-k">:</span> <span class="pl-c1">AA</span>, y<span class="pl-k">:</span> <span class="pl-c1">BB</span> } <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">AA</span>, <span class="pl-c1">BB</span> );              <span class="pl-c">// 10 20</span></pre></div>

<p>In the <code>{ x: aa, y: bb }</code> line, the <code>x</code> and <code>y</code> represent the object properties. In the <code>{ x: AA, y: BB }</code> line, the <code>x</code> and the <code>y</code> <em>also</em> represent the object properties.</p>

<p>Recall how earlier I asserted that <code>{ x, .. }</code> was leaving off the <code>x:</code> part? In those two lines, if you erase the <code>x:</code> and <code>y:</code> parts in that snippet, you're left only with <code>aa, bb</code> and <code>AA, BB</code>, which in effect -- only conceptually, not actually -- are assignments from <code>aa</code> to <code>AA</code> and from <code>bb</code> to <code>BB</code>.</p>

<p>So, that symmetry may help to explain why the syntactic pattern was intentionally flipped for this ES6 feature.</p>

<p><strong>Note:</strong> I would have preferred the syntax to be <code>{ AA: x , BB: y }</code> for the destructuring assignment, as that would have preserved consistency of the more familiar <code>target: source</code> pattern for both usages. Alas, I'm having to train my brain for the inversion, as some readers may also have to do.</p>

<h3><a id="user-content-not-just-declarations" class="anchor" href="#not-just-declarations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not Just Declarations</h3>

<p>So far, we've used destructuring assignment with <code>var</code> declarations (of course, they could also use <code>let</code> and <code>const</code>), but destructuring is a general assignment operation, not just a declaration.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a, b, c, x, y, z;

[a,b,c] <span class="pl-k">=</span> foo();
( { x, y, z } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );             <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );             <span class="pl-c">// 4 5 6</span></pre></div>

<p>The variables can already be declared, and then the destructuring only does assignments, exactly as we've already seen.</p>

<p><strong>Note:</strong> For the object destructuring form specifically, when leaving off a <code>var</code>/<code>let</code>/<code>const</code> declarator, we had to surround the whole assignment expression in <code>( )</code>, because otherwise the <code>{ .. }</code> on the lefthand side as the first element in the statement is taken to be a block statement instead of an object.</p>

<p>In fact, the assignment expressions (<code>a</code>, <code>y</code>, etc.) don't actually need to be just variable identifiers. Anything that's a valid assignment expression is allowed. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

[o.a, o.b, o.c] <span class="pl-k">=</span> foo();
( { x<span class="pl-k">:</span> o.<span class="pl-c1">x</span>, y<span class="pl-k">:</span> o.<span class="pl-c1">y</span>, z<span class="pl-k">:</span> o.<span class="pl-c1">z</span> } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a, o.b, o.c );       <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.<span class="pl-c1">x</span>, o.<span class="pl-c1">y</span>, o.<span class="pl-c1">z</span> );       <span class="pl-c">// 4 5 6</span></pre></div>

<p>You can even use computed property expressions in the destructuring. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> which <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>,
    o <span class="pl-k">=</span> {};

( { [which]<span class="pl-k">:</span> o[which] } <span class="pl-k">=</span> bar() );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o.<span class="pl-c1">x</span> );                 <span class="pl-c">// 4</span></pre></div>

<p>The <code>[which]:</code> part is the computed property, which results in <code>x</code> -- the property to destructure from the object in question as the source of the assignment. The <code>o[which]</code> part is just a normal object key reference, which equates to <code>o.x</code> as the target of the assignment.</p>

<p>You can use the general assignments to create object mappings/transformations, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    o2 <span class="pl-k">=</span> {};

( { a<span class="pl-k">:</span> o2.<span class="pl-c1">x</span>, b<span class="pl-k">:</span> o2.<span class="pl-c1">y</span>, c<span class="pl-k">:</span> o2.<span class="pl-c1">z</span> } <span class="pl-k">=</span> o1 );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o2.<span class="pl-c1">x</span>, o2.<span class="pl-c1">y</span>, o2.<span class="pl-c1">z</span> );    <span class="pl-c">// 1 2 3</span></pre></div>

<p>Or you can map an object to an array, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    a2 <span class="pl-k">=</span> [];

( { a<span class="pl-k">:</span> a2[<span class="pl-c1">0</span>], b<span class="pl-k">:</span> a2[<span class="pl-c1">1</span>], c<span class="pl-k">:</span> a2[<span class="pl-c1">2</span>] } <span class="pl-k">=</span> o1 );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a2 );                  <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Or the other way around:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ],
    o2 <span class="pl-k">=</span> {};

[ o2.a, o2.b, o2.c ] <span class="pl-k">=</span> a1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o2.a, o2.b, o2.c );    <span class="pl-c">// 1 2 3</span></pre></div>

<p>Or you could reorder one array to another:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ],
    a2 <span class="pl-k">=</span> [];

[ a2[<span class="pl-c1">2</span>], a2[<span class="pl-c1">0</span>], a2[<span class="pl-c1">1</span>] ] <span class="pl-k">=</span> a1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a2 );                  <span class="pl-c">// [2,3,1]</span></pre></div>

<p>You can even solve the traditional "swap two variables" task without a temporary variable:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">10</span>, y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

[ y, x ] <span class="pl-k">=</span> [ x, y ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );                <span class="pl-c">// 20 10</span></pre></div>

<p><strong>Warning:</strong> Be careful: you shouldn't mix in declaration with assignment unless you want all of the assignment expressions <em>also</em> to be treated as declarations. Otherwise, you'll get syntax errors. That's why in the earlier example I had to do <code>var a2 = []</code> separately from the <code>[ a2[0], .. ] = ..</code> destructuring assignment. It wouldn't make any sense to try <code>var [ a2[0], .. ] = ..</code>, because <code>a2[0]</code> isn't a valid declaration identifier; it also obviously couldn't implicitly create a <code>var a2 = []</code> declaration to use.</p>

<h3><a id="user-content-repeated-assignments" class="anchor" href="#repeated-assignments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Repeated Assignments</h3>

<p>The object destructuring form allows a source property (holding any value type) to be listed multiple times. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { a<span class="pl-k">:</span> X, a<span class="pl-k">:</span> Y } <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> };

X;  <span class="pl-c">// 1</span>
Y;  <span class="pl-c">// 1</span></pre></div>

<p>That also means you can both destructure a sub-object/array property and also capture the sub-object/array's value itself. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { a<span class="pl-k">:</span> { x<span class="pl-k">:</span> X, x<span class="pl-k">:</span> Y }, a } <span class="pl-k">=</span> { a<span class="pl-k">:</span> { x<span class="pl-k">:</span> <span class="pl-c1">1</span> } };

X;  <span class="pl-c">// 1</span>
Y;  <span class="pl-c">// 1</span>
a;  <span class="pl-c">// { x: 1 }</span>

( { a<span class="pl-k">:</span> X, a<span class="pl-k">:</span> Y, a<span class="pl-k">:</span> [ Z ] } <span class="pl-k">=</span> { a<span class="pl-k">:</span> [ <span class="pl-c1">1</span> ] } );

X.<span class="pl-c1">push</span>( <span class="pl-c1">2</span> );
Y[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;

X;  <span class="pl-c">// [10,2]</span>
Y;  <span class="pl-c">// [10,2]</span>
Z;  <span class="pl-c">// 1</span></pre></div>

<p>A word of caution about destructuring: it may be tempting to list destructuring assignments all on a single line as has been done thus far in our discussion. However, it's a much better idea to spread destructuring assignment patterns over multiple lines, using proper indentation -- much like you would in JSON or with an object literal value -- for readability sake.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// harder to read:</span>
<span class="pl-k">var</span> { a<span class="pl-k">:</span> { b<span class="pl-k">:</span> [ c, d ], e<span class="pl-k">:</span> { f } }, g } <span class="pl-k">=</span> obj;

<span class="pl-c">// better:</span>
<span class="pl-k">var</span> {
    a<span class="pl-k">:</span> {
        b<span class="pl-k">:</span> [ c, d ],
        e<span class="pl-k">:</span> { f }
    },
    g
} <span class="pl-k">=</span> obj;</pre></div>

<p>Remember: <strong>the purpose of destructuring is not just less typing, but more declarative readability.</strong></p>

<h4><a id="user-content-destructuring-assignment-expressions" class="anchor" href="#destructuring-assignment-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Assignment Expressions</h4>

<p>The assignment expression with object or array destructuring has as its completion value the full righthand object/array value. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    a, b, c, p;

p <span class="pl-k">=</span> { a, b, c } <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
p <span class="pl-k">===</span> o;                        <span class="pl-c">// true</span></pre></div>

<p>In the previous snippet, <code>p</code> was assigned the <code>o</code> object reference, not one of the <code>a</code>, <code>b</code>, or <code>c</code> values. The same is true of array destructuring:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>],
    a, b, c, p;

p <span class="pl-k">=</span> [ a, b, c ] <span class="pl-k">=</span> o;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
p <span class="pl-k">===</span> o;                        <span class="pl-c">// true</span></pre></div>

<p>By carrying the object/array value through as the completion, you can chain destructuring assignment expressions together:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    p <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>],
    a, b, c, x, y, z;

( {a} <span class="pl-k">=</span> {b,c} <span class="pl-k">=</span> o );
[x,y] <span class="pl-k">=</span> [z] <span class="pl-k">=</span> p;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );         <span class="pl-c">// 1 2 3</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );         <span class="pl-c">// 4 5 4</span></pre></div>

<h3><a id="user-content-too-many-too-few-just-enough" class="anchor" href="#too-many-too-few-just-enough" aria-hidden="true"><span class="octicon octicon-link"></span></a>Too Many, Too Few, Just Enough</h3>

<p>With both array destructuring assignment and object destructuring assignment, you do not have to assign all the values that are present. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [,b] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, x, z );             <span class="pl-c">// 2 4 6</span></pre></div>

<p>The <code>1</code> and <code>3</code> values that came back from <code>foo()</code> are discarded, as is the <code>5</code> value from <code>bar()</code>.</p>

<p>Similarly, if you try to assign more values than are present in the value you're destructuring/decomposing, you get graceful fallback to <code>undefined</code>, as you'd expect:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [,,c,d] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { w, z } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( c, z );                <span class="pl-c">// 3 6</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( d, w );                <span class="pl-c">// undefined undefined</span></pre></div>

<p>This behavior follows symmetrically from the earlier stated "<code>undefined</code> is missing" principle.</p>

<p>We examined the <code>...</code> operator earlier in this chapter, and saw that it can sometimes be used to spread an array value out into its separate values, and sometimes it can be used to do the opposite: to gather a set of values together into an array.</p>

<p>In addition to the gather/rest usage in function declarations, <code>...</code> can perform the same behavior in destructuring assignments. To illustrate, let's recall a snippet from earlier in this chapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, ...a, <span class="pl-c1">5</span> ];

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b );                   <span class="pl-c">// [1,2,3,4,5]</span></pre></div>

<p>Here we see that <code>...a</code> is spreading <code>a</code> out, because it appears in the array <code>[ .. ]</code> value position. If <code>...a</code> appears in an array destructuring position, it performs the gather behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>];
<span class="pl-k">var</span> [ b, ...c ] <span class="pl-k">=</span> a;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, c );                <span class="pl-c">// 2 [3,4]</span></pre></div>

<p>The <code>var [ .. ] = a</code> destructuring assignment spreads <code>a</code> out to be assigned to the pattern described inside the <code>[ .. ]</code>. The first part names <code>b</code> for the first value in <code>a</code> (<code>2</code>). But then <code>...c</code> gathers the rest of the values (<code>3</code> and <code>4</code>) into an array and calls it <code>c</code>.</p>

<p><strong>Note:</strong> We've seen how <code>...</code> works with arrays, but what about with objects? It's not an ES6 feature, but see Chapter 8 for discussion of a possible "beyond ES6" feature where <code>...</code> works with spreading or gathering objects.</p>

<h3><a id="user-content-default-value-assignment" class="anchor" href="#default-value-assignment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Default Value Assignment</h3>

<p>Both forms of destructuring can offer a default value option for an assignment, using the <code>=</code> syntax similar to the default function argument values discussed earlier.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> [ a <span class="pl-k">=</span> <span class="pl-c1">3</span>, b <span class="pl-k">=</span> <span class="pl-c1">6</span>, c <span class="pl-k">=</span> <span class="pl-c1">9</span>, d <span class="pl-k">=</span> <span class="pl-c1">12</span> ] <span class="pl-k">=</span> foo();
<span class="pl-k">var</span> { x <span class="pl-k">=</span> <span class="pl-c1">5</span>, y <span class="pl-k">=</span> <span class="pl-c1">10</span>, z <span class="pl-k">=</span> <span class="pl-c1">15</span>, w <span class="pl-k">=</span> <span class="pl-c1">20</span> } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c, d );          <span class="pl-c">// 1 2 3 12</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, w );          <span class="pl-c">// 4 5 6 20</span></pre></div>

<p>You can combine the default value assignment with the alternative assignment expression syntax covered earlier. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> { x, y, z, w<span class="pl-k">:</span> <span class="pl-c1">WW</span> <span class="pl-k">=</span> <span class="pl-c1">20</span> } <span class="pl-k">=</span> bar();

<span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, <span class="pl-c1">WW</span> );         <span class="pl-c">// 4 5 6 20</span></pre></div>

<p>Be careful about confusing yourself (or other developers who read your code) if you use an object or array as the default value in a destructuring. You can create some really hard to understand code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">200</span>, y <span class="pl-k">=</span> <span class="pl-c1">300</span>, z <span class="pl-k">=</span> <span class="pl-c1">100</span>;
<span class="pl-k">var</span> o1 <span class="pl-k">=</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> <span class="pl-c1">42</span> }, z<span class="pl-k">:</span> { y<span class="pl-k">:</span> z } };

( { y<span class="pl-k">:</span> x <span class="pl-k">=</span> { y<span class="pl-k">:</span> y } } <span class="pl-k">=</span> o1 );
( { z<span class="pl-k">:</span> y <span class="pl-k">=</span> { y<span class="pl-k">:</span> z } } <span class="pl-k">=</span> o1 );
( { x<span class="pl-k">:</span> z <span class="pl-k">=</span> { y<span class="pl-k">:</span> x } } <span class="pl-k">=</span> o1 );</pre></div>

<p>Can you tell from that snippet what values <code>x</code>, <code>y</code>, and <code>z</code> have at the end? Takes a moment of pondering, I would imagine. I'll end the suspense:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( x.<span class="pl-c1">y</span>, y.<span class="pl-c1">y</span>, z.<span class="pl-c1">y</span> );       <span class="pl-c">// 300 100 42</span></pre></div>

<p>The takeaway here: destructuring is great and can be very useful, but it's also a sharp sword that can cause injury (to someone's brain) if used unwisely.</p>

<h3><a id="user-content-nested-destructuring" class="anchor" href="#nested-destructuring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Destructuring</h3>

<p>If the values you're destructuring have nested objects or arrays, you can destructure those nested values as well:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a1 <span class="pl-k">=</span> [ <span class="pl-c1">1</span>, [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>], <span class="pl-c1">5</span> ];
<span class="pl-k">var</span> o1 <span class="pl-k">=</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> { z<span class="pl-k">:</span> <span class="pl-c1">6</span> } } };

<span class="pl-k">var</span> [ a, [ b, c, d ], e ] <span class="pl-k">=</span> a1;
<span class="pl-k">var</span> { x<span class="pl-k">:</span> { y<span class="pl-k">:</span> { z<span class="pl-k">:</span> w } } } <span class="pl-k">=</span> o1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c, d, e );       <span class="pl-c">// 1 2 3 4 5</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( w );                   <span class="pl-c">// 6</span></pre></div>

<p>Nested destructuring can be a simple way to flatten out object namespaces. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> App <span class="pl-k">=</span> {
    model<span class="pl-k">:</span> {
        <span class="pl-en">User</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){ .. }
    }
};

<span class="pl-c">// instead of:</span>
<span class="pl-c">// var User = App.model.User;</span>

<span class="pl-k">var</span> { model<span class="pl-k">:</span> { User } } <span class="pl-k">=</span> App;</pre></div>

<h3><a id="user-content-destructuring-parameters" class="anchor" href="#destructuring-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Parameters</h3>

<p>In the following snippet, can you spot the assignment?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}

foo( <span class="pl-c1">42</span> );</pre></div>

<p>The assignment is kinda hidden: <code>42</code> (the argument) is assigned to <code>x</code> (the parameter) when <code>foo(42)</code> is executed. If parameter/argument pairing is an assignment, then it stands to reason that it's an assignment that could be destructured, right? Of course!</p>

<p>Consider array destructuring for parameters:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( [ <span class="pl-smi">x</span>, <span class="pl-smi">y</span> ] ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

foo( [ <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ] );                    <span class="pl-c">// 1 2</span>
foo( [ <span class="pl-c1">1</span> ] );                       <span class="pl-c">// 1 undefined</span>
foo( [] );                          <span class="pl-c">// undefined undefined</span></pre></div>

<p>Object destructuring for parameters works, too:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>( { <span class="pl-smi">x</span>, <span class="pl-smi">y</span> } ) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

foo( { y<span class="pl-k">:</span> <span class="pl-c1">1</span>, x<span class="pl-k">:</span> <span class="pl-c1">2</span> } );              <span class="pl-c">// 2 1</span>
foo( { y<span class="pl-k">:</span> <span class="pl-c1">42</span> } );                   <span class="pl-c">// undefined 42</span>
foo( {} );                          <span class="pl-c">// undefined undefined</span></pre></div>

<p>This technique is an approximation of named arguments (a long requested feature for JS!), in that the properties on the object map to the destructured parameters of the same names. That also means that we get optional parameters (in any position) for free, as you can see leaving off the <code>x</code> "parameter" worked as we'd expect.</p>

<p>Of course, all the previously discussed variations of destructuring are available to us with parameter destructuring, including nested destructuring, default values, and more. Destructuring also mixes fine with other ES6 function parameter capabilities, like default parameter values and rest/gather parameters.</p>

<p>Consider these quick illustrations (certainly not exhaustive of the possible variations):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f1</span>([ <span class="pl-smi">x</span><span class="pl-k">=</span><span class="pl-c1">2</span>, <span class="pl-smi">y</span><span class="pl-k">=</span><span class="pl-c1">3</span>, <span class="pl-smi">z</span> ]) { .. }
<span class="pl-k">function</span> <span class="pl-en">f2</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], <span class="pl-smi">w</span>) { .. }
<span class="pl-k">function</span> <span class="pl-en">f3</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], ...<span class="pl-smi">w</span>) { .. }

<span class="pl-k">function</span> <span class="pl-en">f4</span>({ <span class="pl-smi">x</span>: <span class="pl-smi">X</span>, <span class="pl-smi">y</span> }) { .. }
<span class="pl-k">function</span> <span class="pl-en">f5</span>({ <span class="pl-smi">x</span>: <span class="pl-smi">X</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>, <span class="pl-smi">y</span> <span class="pl-k">=</span> <span class="pl-c1">20</span> }) { .. }
<span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) { .. }</pre></div>

<p>Let's take one example from this snippet and examine it, for illustration purposes:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f3</span>([ <span class="pl-smi">x</span>, <span class="pl-smi">y</span>, ...<span class="pl-smi">z</span>], ...<span class="pl-smi">w</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z, w );
}

f3( [] );                           <span class="pl-c">// undefined undefined [] []</span>
f3( [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>], <span class="pl-c1">5</span>, <span class="pl-c1">6</span> );              <span class="pl-c">// 1 2 [3,4] [5,6]</span></pre></div>

<p>There are two <code>...</code> operators in use here, and they're both gathering values in arrays (<code>z</code> and <code>w</code>), though <code>...z</code> gathers from the rest of the values left over in the first array argument, while <code>...w</code> gathers from the rest of the main arguments left over after the first.</p>

<h4><a id="user-content-destructuring-defaults--parameter-defaults" class="anchor" href="#destructuring-defaults--parameter-defaults" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring Defaults + Parameter Defaults</h4>

<p>There's one subtle point you should be particularly careful to notice -- the difference in behavior between a destructuring default value and a function parameter default value. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

f6();                               <span class="pl-c">// 10 10</span></pre></div>

<p>At first, it would seem that we've declared a default value of <code>10</code> for both the <code>x</code> and <code>y</code> parameters, but in two different ways. However, these two different approaches will behave differently in certain cases, and the difference is awfully subtle.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>f6( {}, {} );                       <span class="pl-c">// 10 undefined</span></pre></div>

<p>Wait, why did that happen? It's pretty clear that named parameter <code>x</code> is defaulting to <code>10</code> if not passed as a property of that same name in the first argument's object.</p>

<p>But what about <code>y</code> being <code>undefined</code>? The <code>{ y: 10 }</code> value is an object as a function parameter default value, not a destructuring default value. As such, it only applies if the second argument is not passed at all, or is passed as <code>undefined</code>.</p>

<p>In the previous snippet, we <em>are</em> passing a second argument (<code>{}</code>), so the default <code>{ y: 10 }</code> value is not used, and the <code>{ y }</code> destructuring occurs against the passed in <code>{}</code> empty object value.</p>

<p>Now, compare <code>{ y } = { y: 10 }</code> to <code>{ x = 10 } = {}</code>.</p>

<p>For the <code>x</code>'s form usage, if the first function argument is omitted or <code>undefined</code>, the <code>{}</code> empty object default applies. Then, whatever value is in the first argument position -- either the default <code>{}</code> or whatever you passed in -- is destructured with the <code>{ x = 10 }</code>, which checks to see if an <code>x</code> property is found, and if not found (or <code>undefined</code>), the <code>10</code> default value is applied to the <code>x</code> named parameter.</p>

<p>Deep breath. Read back over those last few paragraphs a couple of times. Let's review via code:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">f6</span>({ <span class="pl-smi">x</span> <span class="pl-k">=</span> <span class="pl-c1">10</span> } <span class="pl-k">=</span> {}, { <span class="pl-smi">y</span> } <span class="pl-k">=</span> { <span class="pl-smi">y</span>: <span class="pl-c1">10</span> }) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y );
}

f6();                               <span class="pl-c">// 10 10</span>
f6( <span class="pl-c1">undefined</span>, <span class="pl-c1">undefined</span> );         <span class="pl-c">// 10 10</span>
f6( {}, <span class="pl-c1">undefined</span> );                <span class="pl-c">// 10 10</span>

f6( {}, {} );                       <span class="pl-c">// 10 undefined</span>
f6( <span class="pl-c1">undefined</span>, {} );                <span class="pl-c">// 10 undefined</span>

f6( { x<span class="pl-k">:</span> <span class="pl-c1">2</span> }, { y<span class="pl-k">:</span> <span class="pl-c1">3</span> } );           <span class="pl-c">// 2 3</span></pre></div>

<p>It would generally seem that the defaulting behavior of the <code>x</code> parameter is probably the more desirable and sensible case compared to that of <code>y</code>. As such, it's important to understand why and how <code>{ x = 10 } = {}</code> form is different from <code>{ y } = { y: 10 }</code> form.</p>

<p>If that's still a bit fuzzy, go back and read it again, and play with this yourself. Your future self will thank you for taking the time to get this very subtle gotcha nuance detail straight.</p>

<h4><a id="user-content-nested-defaults-destructured-and-restructured" class="anchor" href="#nested-defaults-destructured-and-restructured" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Defaults: Destructured and Restructured</h4>

<p>Although it may at first be difficult to grasp, an interesting idiom emerges for setting defaults for a nested object's properties: using object destructuring along with what I'd call <em>restructuring</em>.</p>

<p>Consider a set of defaults in a nested object structure, like the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// taken from: http://es-discourse.com/t/partial-default-arguments/120/7</span>

<span class="pl-k">var</span> defaults <span class="pl-k">=</span> {
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        enable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        instance<span class="pl-k">:</span> {}
    },
    log<span class="pl-k">:</span> {
        warn<span class="pl-k">:</span> <span class="pl-c1">true</span>,
        error<span class="pl-k">:</span> <span class="pl-c1">true</span>
    }
};</pre></div>

<p>Now, let's say that you have an object called <code>config</code>, which has some of these applied, but perhaps not all, and you'd like to set all the defaults into this object in the missing spots, but not override specific settings already present:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> config <span class="pl-k">=</span> {
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> <span class="pl-c1">false</span>,
        instance<span class="pl-k">:</span> <span class="pl-c1">null</span>
    }
};</pre></div>

<p>You can of course do so manually, as you might have done in the past:</p>

<div class="highlight highlight-source-js"><pre>config.<span class="pl-c1">options</span> <span class="pl-k">=</span> config.<span class="pl-c1">options</span> <span class="pl-k">||</span> {};
config.<span class="pl-c1">options</span>.remove <span class="pl-k">=</span> (config.<span class="pl-c1">options</span>.remove <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span>
    config.<span class="pl-c1">options</span>.remove <span class="pl-k">:</span> defaults.<span class="pl-c1">options</span>.remove;
config.<span class="pl-c1">options</span>.enable <span class="pl-k">=</span> (config.<span class="pl-c1">options</span>.enable <span class="pl-k">!==</span> <span class="pl-c1">undefined</span>) <span class="pl-k">?</span>
    config.<span class="pl-c1">options</span>.enable <span class="pl-k">:</span> defaults.<span class="pl-c1">options</span>.enable;
...</pre></div>

<p>Yuck.</p>

<p>Others may prefer the assign-overwrite approach to this task. You might be tempted by the ES6 <code>Object.assign(..)</code> utility (see Chapter 6) to clone the properties first from <code>defaults</code> and then overwritten with the cloned properties from <code>config</code>, as so:</p>

<div class="highlight highlight-source-js"><pre>config <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign( {}, defaults, config );</pre></div>

<p>That looks way nicer, huh? But there's a major problem! <code>Object.assign(..)</code> is shallow, which means when it copies <code>defaults.options</code>, it just copies that object reference, not deep cloning that object's properties to a <code>config.options</code> object. <code>Object.assign(..)</code> would need to be applied (sort of "recursively") at all levels of your object's tree to get the deep cloning you're expecting.</p>

<p><strong>Note:</strong> Many JS utility libraries/frameworks provide their own option for deep cloning of an object, but those approaches and their gotchas are beyond our scope to discuss here.</p>

<p>So let's examine if ES6 object destructuring with defaults can help at all:</p>

<div class="highlight highlight-source-js"><pre>config.<span class="pl-c1">options</span> <span class="pl-k">=</span> config.<span class="pl-c1">options</span> <span class="pl-k">||</span> {};
config<span class="pl-c1">.log</span> <span class="pl-k">=</span> config<span class="pl-c1">.log</span> <span class="pl-k">||</span> {};
{
    options<span class="pl-k">:</span> {
        remove<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.remove <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.remove,
        enable<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.enable <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.enable,
        instance<span class="pl-k">:</span> config.<span class="pl-c1">options</span>.instance <span class="pl-k">=</span> <span class="pl-k">default</span>.<span class="pl-c1">options</span>.instance
    } <span class="pl-k">=</span> {},
    log<span class="pl-k">:</span> {
        warn<span class="pl-k">:</span> config<span class="pl-c1">.log.warn</span> <span class="pl-k">=</span> <span class="pl-k">default</span><span class="pl-c1">.log.warn</span>,
        error<span class="pl-k">:</span> config<span class="pl-c1">.log.error</span> <span class="pl-k">=</span> <span class="pl-k">default</span><span class="pl-c1">.log.error</span>
    } <span class="pl-k">=</span> {}
} <span class="pl-k">=</span> config;</pre></div>

<p>Not as nice as the false promise of <code>Object.assign(..)</code> (being that it's shallow only), but it's better than the manual approach by a fair bit, I think. It is still unfortunately verbose and repetitive, though.</p>

<p>The previous snippet's approach works because I'm hacking the destructuring and defaults mechansim to do the property <code>=== undefined</code> checks and assignment decisions for me. It's a trick in that I'm destructuring <code>config</code> (see the <code>= config</code> at the end of the snippet), but I'm reassigning all the destructured values right back into <code>config</code>, with the <code>config.options.enable</code> assignment references.</p>

<p>Still too much, though. Let's see if we can make anything better.</p>

<p>The following trick works best if you know that all the various properties you're destructuring are uniquely named. You can still do it even if that's not the case, but it's not as nice -- you'll have to do the destructuring in stages, or create unique local variables as temporary aliases.</p>

<p>If we fully destructure all the properties into top-level variables, we can then immediately restructure to reconstitute the original nested object structure.</p>

<p>But all those temporary variables hanging around would pollute scope. So, let's use block scoping (see "Block-Scoped Declarations" earlier in this chapter) with a general <code>{ }</code> enclosing block:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// merge `defaults` into `config`</span>
{
    <span class="pl-c">// destructure (with default value assignments)</span>
    <span class="pl-k">let</span> {
        options<span class="pl-k">:</span> {
            remove <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.remove,
            enable <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.enable,
            instance <span class="pl-k">=</span> defaults.<span class="pl-c1">options</span>.instance
        } <span class="pl-k">=</span> {},
        log<span class="pl-k">:</span> {
            warn <span class="pl-k">=</span> defaults<span class="pl-c1">.log.warn</span>,
            error <span class="pl-k">=</span> defaults<span class="pl-c1">.log.error</span>
        } <span class="pl-k">=</span> {}
    } <span class="pl-k">=</span> config;

    <span class="pl-c">// restructure</span>
    config <span class="pl-k">=</span> {
        options<span class="pl-k">:</span> { remove, enable, instance },
        log<span class="pl-k">:</span> { warn, error }
    };
}</pre></div>

<p>That seems a fair bit nicer, huh?</p>

<p><strong>Note:</strong> You could also accomplish the scope enclosure with an arrow IIFE instead of the general <code>{ }</code> block and <code>let</code> declarations. Your destructuring assignments/defaults would be in the parameter list and your restructuring would be the <code>return</code> statement in the function body.</p>

<p>The <code>{ warn, error }</code> syntax in the restructuring part may look new to you; that's called "concise properties" and we cover it in the next section!</p>

<h2><a id="user-content-object-literal-extensions" class="anchor" href="#object-literal-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Literal Extensions</h2>

<p>ES6 adds a number of important convenience extensions to the humble <code>{ .. }</code> object literal.</p>

<h3><a id="user-content-concise-properties" class="anchor" href="#concise-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concise Properties</h3>

<p>You're certainly familiar with declaring object literals in this form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">2</span>, y <span class="pl-k">=</span> <span class="pl-c1">3</span>,
    o <span class="pl-k">=</span> {
        x<span class="pl-k">:</span> x,
        y<span class="pl-k">:</span> y
    };</pre></div>

<p>If it's always felt redundant to say <code>x: x</code> all over, there's good news. If you need to define a property that is the same name as a lexical identifier, you can shorten it from <code>x: x</code> to <code>x</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">2</span>, y <span class="pl-k">=</span> <span class="pl-c1">3</span>,
    o <span class="pl-k">=</span> {
        x,
        y
    };</pre></div>

<h3><a id="user-content-concise-methods" class="anchor" href="#concise-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concise Methods</h3>

<p>In a similar spirit to concise properties we just examined, functions attached to properties in object literals also have a concise form, for convenience.</p>

<p>The old way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">x</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">y</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
        <span class="pl-c">// ..</span>
    }
}</pre></div>

<p>And as of ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">x</span>() {
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">y</span>() {
        <span class="pl-c">// ..</span>
    }
}</pre></div>

<p><strong>Warning:</strong> While <code>x() { .. }</code> seems to just be shorthand for <code>x: function(){ .. }</code>, concise methods have special behaviors that their older counterparts don't; specifically, the allowance for <code>super</code> (see "Object <code>super</code>" later in this chapter).</p>

<p>Generators (see Chapter 4) also have a concise method form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-k">*</span><span class="pl-en">foo</span>() { .. }
};</pre></div>

<h4><a id="user-content-concisely-unnamed" class="anchor" href="#concisely-unnamed" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concisely Unnamed</h4>

<p>While that convenience shorthand is quite attractive, there's a subtle gotcha to be aware of. To illustrate, let's examine pre-ES6 code like the following, which you might try to refactor to use concise methods:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">runSomething</span>(<span class="pl-smi">o</span>) {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>(),
        y <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();

    <span class="pl-k">return</span> o.something( x, y );
}

runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-c">// recursively call with `x`</span>
            <span class="pl-c">// and `y` swapped</span>
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>This obviously silly code just generates two random numbers and subtracts the smaller from the bigger. But what's important here isn't what it does, but rather how it's defined. Let's focus on the object literal and function definition, as we see here:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-c">// ..</span>
    }
} );</pre></div>

<p>Why do we say both <code>something:</code> and <code>function something</code>? Isn't that redundant? Actually, no, both are needed for different purposes. The property <code>something</code> is how we can call <code>o.something(..)</code>, sort of like its public name. But the second <code>something</code> is a lexical name to refer to the function from inside itself, for recursion purposes.</p>

<p>Can you see why the line <code>return something(y,x)</code> needs the name <code>something</code> to refer to the function? There's no lexical name for the object, such that it could have said <code>return o.something(y,x)</code> or something of that sort.</p>

<p>That's actually a pretty common practice when the object literal does have an identifying name, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-c">// ..</span>
        controller.makeRequest(..);
    }
};</pre></div>

<p>Is this a good idea? Perhaps, perhaps not. You're assuming that the name <code>controller</code> will always point to the object in question. But it very well may not -- the <code>makeRequest(..)</code> function doesn't control the outer code and so can't force that to be the case. This could come back to bite you.</p>

<p>Others prefer to use <code>this</code> to define such things:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-c">// ..</span>
        <span class="pl-v">this</span>.makeRequest(..);
    }
};</pre></div>

<p>That looks fine, and should work if you always invoke the method as <code>controller.makeRequest(..)</code>. But you now have a <code>this</code> binding gotcha if you do something like:</p>

<div class="highlight highlight-source-js"><pre>btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, controller.makeRequest, <span class="pl-c1">false</span> );</pre></div>

<p>Of course, you can solve that by passing <code>controller.makeRequest.bind(controller)</code> as the handler reference to bind the event to. But yuck -- it isn't very appealing.</p>

<p>Or what if your inner <code>this.makeRequest(..)</code> call needs to be made from a nested function? You'll have another <code>this</code> binding hazard, which people will often solve with the hacky <code>var self = this</code>, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;

        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
            <span class="pl-c">// ..</span>
            self.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>More yuck.</p>

<p><strong>Note:</strong> For more information on <code>this</code> binding rules and gotchas, see Chapters 1-2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>OK, what does all this have to do with concise methods? Recall our <code>something(..)</code> method definition:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-c">// ..</span>
    }
} );</pre></div>

<p>The second <code>something</code> here provides a super convenient lexical identifier that will always point to the function itself, giving us the perfect reference for recursion, event binding/unbinding, and so on -- no messing around with <code>this</code> or trying to use an untrustable object reference.</p>

<p>Great!</p>

<p>So, now we try to refactor that function reference to this ES6 concise method form:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>Seems fine at first glance, except this code will break. The <code>return something(..)</code> call will not find a <code>something</code> identifier, so you'll get a <code>ReferenceError</code>. Oops. But why?</p>

<p>The above ES6 snippet is interpreted as meaning:</p>

<div class="highlight highlight-source-js"><pre>runSomething( {
    <span class="pl-en">something</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> y) {
            <span class="pl-k">return</span> something( y, x );
        }

        <span class="pl-k">return</span> y <span class="pl-k">-</span> x;
    }
} );</pre></div>

<p>Look closely. Do you see the problem? The concise method definition implies <code>something: function(x,y)</code>. See how the second <code>something</code> we were relying on has been omitted? In other words, concise methods imply anonymous function expressions.</p>

<p>Yeah, yuck.</p>

<p><strong>Note:</strong> You may be tempted to think that <code>=&gt;</code> arrow functions are a good solution here, but they're equally insufficient, as they're also anonymous function expressions. We'll cover them in "Arrow Functions" later in this chapter.</p>

<p>The partially redeeming news is that our <code>something(x,y)</code> concise method won't be totally anonymous. See "Function Names" in Chapter 7 for information about ES6 function name inference rules. That won't help us for our recursion, but it helps with debugging at least.</p>

<p>So what are we left to conclude about concise methods? They're short and sweet, and a nice convenience. But you should only use them if you're never going to need them to do recursion or event binding/unbinding. Otherwise, stick to your old-school <code>something: function something(..)</code> method definitions.</p>

<p>A lot of your methods are probably going to benefit from concise method definitions, so that's great news! Just be careful of the few where there's an un-naming hazard.</p>

<h4><a id="user-content-es5-gettersetter" class="anchor" href="#es5-gettersetter" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES5 Getter/Setter</h4>

<p>Technically, ES5 defined getter/setter literals forms, but they didn't seem to get used much, mostly due to the lack of transpilers to handle that new syntax (the only major new syntax added in ES5, really). So while it's not a new ES6 feature, we'll briefly refresh on that form, as it's probably going to be much more useful with ES6 going forward.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    __id<span class="pl-k">:</span> <span class="pl-c1">10</span>,
    get <span class="pl-en">id</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>.__id<span class="pl-k">++</span>; },
    set <span class="pl-en">id</span>(<span class="pl-smi">v</span>) { <span class="pl-v">this</span>.__id <span class="pl-k">=</span> v; }
}

o.<span class="pl-c1">id</span>;           <span class="pl-c">// 10</span>
o.<span class="pl-c1">id</span>;           <span class="pl-c">// 11</span>
o.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-c1">20</span>;
o.<span class="pl-c1">id</span>;           <span class="pl-c">// 20</span>

<span class="pl-c">// and:</span>
o.__id;         <span class="pl-c">// 21</span>
o.__id;         <span class="pl-c">// 21 -- still!</span></pre></div>

<p>These getter and setter literal forms are also present in classes; see Chapter 3.</p>

<p><strong>Warning:</strong> It may not be obvious, but the setter literal must have exactly one declared parameter; omitting it or listing others is illegal syntax. The single required parameter <em>can</em> use destructuring and defaults (e.g., <code>set id({ id: v = 0 }) { .. }</code>), but the gather/rest <code>...</code> is not allowed (<code>set id(...v) { .. }</code>).</p>

<h3><a id="user-content-computed-property-names" class="anchor" href="#computed-property-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Computed Property Names</h3>

<p>You've probably been in a situation like the following snippet, where you have one or more property names that come from some sort of expression and thus can't be put into the object literal:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> prefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>user_<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. }
};

o[ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ] <span class="pl-k">=</span> <span class="pl-k">function</span>(..){ .. };
o[ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ] <span class="pl-k">=</span> <span class="pl-k">function</span>(..){ .. };
..</pre></div>

<p>ES6 adds a syntax to the object literal definition which allows you to specify an expression that should be computed, whose result is the property name assigned. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> prefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>user_<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">baz</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. },
    [ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ]<span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. },
    [ prefix <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ]<span class="pl-k">:</span> <span class="pl-k">function</span>(..){ .. }
    ..
};</pre></div>

<p>Any valid expression can appear inside the <code>[ .. ]</code> that sits in the property name position of the object literal definition.</p>

<p>Probably the most common use of computed property names will be with <code>Symbol</code>s (which we cover in "Symbols" later in this chapter), such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    [Symbol.toStringTag]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>really cool thing<span class="pl-pds">"</span></span>,
    ..
};</pre></div>

<p><code>Symbol.toStringTag</code> is a special built-in value, which we evaluate with the <code>[ .. ]</code> syntax, so we can assign the <code>"really cool thing"</code> value to the special property name.</p>

<p>Computed property names can also appear as the name of a concise method or a concise generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    [<span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>oo<span class="pl-pds">"</span></span>]() { .. }   <span class="pl-c">// computed concise method</span>
    <span class="pl-k">*</span>[<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>ar<span class="pl-pds">"</span></span>]() { .. }  <span class="pl-c">// computed concise generator</span>
};</pre></div>

<h3><a id="user-content-setting-prototype" class="anchor" href="#setting-prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setting <code>[[Prototype]]</code></h3>

<p>We won't cover prototypes in detail here, so for more information, see the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>Sometimes it will be helpful to assign the <code>[[Prototype]]</code> of an object at the same time you're declaring its object literal. The following has been a nonstandard extension in many JS engines for a while, but is standardized as of ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    __proto__<span class="pl-k">:</span> o1,
    <span class="pl-c">// ..</span>
};</pre></div>

<p><code>o2</code> is declared with a normal object literal, but it's also <code>[[Prototype]]</code>-linked to <code>o1</code>. The <code>__proto__</code> property name here can also be a string <code>"__proto__"</code>, but note that it <em>cannot</em> be the result of a computed property name (see the previous section).</p>

<p><code>__proto__</code> is controversial, to say the least. It's a decades-old proprietary extension to JS that is finally standardized, somewhat begrudgingly it seems, in ES6. Many developers feel it shouldn't ever be used. In fact, it's in "Annex B" of ES6, which is the section that lists things JS feels it has to standardize for compatibility reasons only.</p>

<p><strong>Warning:</strong> Though I'm narrowly endorsing <code>__proto__</code> as a key in an object literal definition, I definitely do not endorse using it in its object property form, like <code>o.__proto__</code>. That form is both a getter and setter (again for compatibility reasons), but there are definitely better options. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<p>For setting the <code>[[Prototype]]</code> of an existing object, you can use the ES6 utility <code>Object.setPrototypeOf(..)</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-c">// ..</span>
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );</pre></div>

<p><strong>Note:</strong> We'll discuss <code>Object</code> again in Chapter 6. "<code>Object.setPrototypeOf(..)</code> Static Function" provides additional details on <code>Object.setPrototypeOf(..)</code>. Also see "<code>Object.assign(..)</code> Static Function" for another form that relates <code>o2</code> prototypically to <code>o1</code>.</p>

<h3><a id="user-content-object-super" class="anchor" href="#object-super" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object <code>super</code></h3>

<p><code>super</code> is typically thought of as being only related to classes. However, due to JS's classless-objects-with-prototypes nature, <code>super</code> is equally effective, and nearly the same in behavior, with plain objects' concise methods.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>o1:foo<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>o2:foo<span class="pl-pds">"</span></span> );
    }
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );

o2.foo();       <span class="pl-c">// o1:foo</span>
                <span class="pl-c">// o2:foo</span></pre></div>

<p><strong>Warning:</strong> <code>super</code> is only allowed in concise methods, not regular function expression properties. It also is only allowed in <code>super.XXX</code> form (for property/method access), not in <code>super()</code> form.</p>

<p>The <code>super</code> reference in the <code>o2.foo()</code> method is locked statically to <code>o2</code>, and specifically to the <code>[[Prototype]]</code> of <code>o2</code>. <code>super</code> here would basically be <code>Object.getPrototypeOf(o2)</code> -- resolves to <code>o1</code> of course -- which is how it finds and calls <code>o1.foo()</code>.</p>

<p>For complete details on <code>super</code>, see "Classes" in Chapter 3.</p>

<h2><a id="user-content-template-literals" class="anchor" href="#template-literals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Template Literals</h2>

<p>At the very outset of this section, I'm going to have to call out the name of this ES6 feature as being awfully... misleading, depending on your experiences with what the word <em>template</em> means.</p>

<p>Many developers think of templates as being reusable renderable pieces of text, such as the capability provided by most template engines (Mustache, Handlebars, etc.). ES6's use of the word <em>template</em> would imply something similar, like a way to declare inline template literals that can be re-rendered. However, that's not at all the right way to think about this feature.</p>

<p>So, before we go on, I'm renaming to what it should have been called: <em>interpolated string literals</em> (or <em>interpoliterals</em> for short).</p>

<p>You're already well aware of declaring string literals with <code>"</code> or <code>'</code> delimiters, and you also know that these are not <em>smart strings</em> (as some languages have), where the contents would be parsed for interpolation expressions.</p>

<p>However, ES6 introduces a new type of string literal, using the <code>`</code> backtick as the delimiter. These string literals allow basic string interpolation expressions to be embedded, which are then automatically parsed and evaluated.</p>

<p>Here's the old pre-ES6 way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );            <span class="pl-c">// "Hello Kyle!"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-k">typeof</span> greeting );     <span class="pl-c">// "string"</span></pre></div>

<p>Now, consider the new ES6 way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">`</span>Hello <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( greeting );            <span class="pl-c">// "Hello Kyle!"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-k">typeof</span> greeting );     <span class="pl-c">// "string"</span></pre></div>

<p>As you can see, we used the <code>`..`</code> around a series of characters, which are interpreted as a string literal, but any expressions of the form <code>${..}</code> are parsed and evaluated inline immediately. The fancy term for such parsing and evaluating is <em>interpolation</em> (much more accurate than templating).</p>

<p>The result of the interpolated string literal expression is just a plain old normal string, assigned to the <code>greeting</code> variable.</p>

<p><strong>Warning:</strong> <code>typeof greeting == "string"</code> illustrates why it's important not to think of these entities as special template values, as you cannot assign the unevaluated form of the literal to something and reuse it. The <code>`..`</code> string literal is more like an IIFE in the sense that it's automatically evaluated inline. The result of a <code>`..`</code> string literal is, simply, just a string.</p>

<p>One really nice benefit of interpolated string literals is they are allowed to split across multiple lines:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> text <span class="pl-k">=</span>
<span class="pl-s"><span class="pl-pds">`</span>Now is the time for all good men</span>
<span class="pl-s">to come to the aid of their</span>
<span class="pl-s">country!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// Now is the time for all good men</span>
<span class="pl-c">// to come to the aid of their</span>
<span class="pl-c">// country!</span></pre></div>

<p>The line breaks (newlines) in the interpolated string literal were preserved in the string value.</p>

<p>Unless appearing as explicit escape sequences in the literal value, the value of the <code>\r</code> carriage return character (code point <code>U+000D</code>) or the value of the <code>\r\n</code> carriage return + line feed sequence (code points <code>U+000D</code> and <code>U+000A</code>) are both normalized to a <code>\n</code> line feed character (code point <code>U+000A</code>). Don't worry though; this normalization is rare and would likely only happen if copy-pasting text into your JS file.</p>

<h3><a id="user-content-interpolated-expressions" class="anchor" href="#interpolated-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interpolated Expressions</h3>

<p>Any valid expression is allowed to appear inside <code>${..}</code> in an interpolated string literal, including function calls, inline function expression calls, and even other interpolated string literals!</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">upper</span>(<span class="pl-smi">s</span>) {
    <span class="pl-k">return</span> s.<span class="pl-c1">toUpperCase</span>();
}

<span class="pl-k">var</span> who <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>reader<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span>
<span class="pl-s"><span class="pl-pds">`</span>A very <span class="pl-s1"><span class="pl-pse">${</span>upper( <span class="pl-s"><span class="pl-pds">"</span>warm<span class="pl-pds">"</span></span> )<span class="pl-pse">}</span></span> welcome</span>
<span class="pl-s">to all of you <span class="pl-s1"><span class="pl-pse">${</span>upper( <span class="pl-s"><span class="pl-pds">`</span><span class="pl-s1"><span class="pl-pse">${</span>who<span class="pl-pse">}</span></span>s<span class="pl-pds">`</span></span> )<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// A very WARM welcome</span>
<span class="pl-c">// to all of you READERS!</span></pre></div>

<p>Here, the inner <code>`${who}s`</code> interpolated string literal was a little bit nicer convenience for us when combining the <code>who</code> variable with the <code>"s"</code> string, as opposed to <code>who + "s"</code>. There will be cases that nesting interpolated string literals is helpful, but be wary if you find yourself doing that kind of thing often, or if you find yourself nesting several levels deep.</p>

<p>If that's the case, the odds are good that your string value production could benefit from some abstractions.</p>

<p><strong>Warning:</strong> As a word of caution, be very careful about the readability of your code with such new found power. Just like with default value expressions and destructuring assignment expressions, just because you <em>can</em> do something doesn't mean you <em>should</em> do it. Never go so overboard with new ES6 tricks that your code becomes more clever than you or your other team members.</p>

<h4><a id="user-content-expression-scope" class="anchor" href="#expression-scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expression Scope</h4>

<p>One quick note about the scope that is used to resolve variables in expressions. I mentioned earlier that an interpolated string literal is kind of like an IIFE, and it turns out thinking about it like that explains the scoping behavior as well.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">str</span>) {
    <span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( str );
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;
    foo( <span class="pl-s"><span class="pl-pds">`</span>Hello from <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span> );
}

<span class="pl-k">var</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>global<span class="pl-pds">"</span></span>;

bar();                  <span class="pl-c">// "Hello from bar!"</span></pre></div>

<p>At the moment the <code>`..`</code> string literal is expressed, inside the <code>bar()</code> function, the scope available to it finds <code>bar()</code>'s <code>name</code> variable with value <code>"bar"</code>. Neither the global <code>name</code> nor <code>foo(..)</code>'s <code>name</code> matter. In other words, an interpolated string literal is just lexically scoped where it appears, not dynamically scoped in any way.</p>

<h3><a id="user-content-tagged-template-literals" class="anchor" href="#tagged-template-literals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tagged Template Literals</h3>

<p>Again, renaming the feature for sanity sake: <em>tagged string literals</em>.</p>

<p>To be honest, this is one of the cooler tricks that ES6 offers. It may seem a little strange, and perhaps not all that generally practical at first. But once you've spent some time with it, tagged string literals may just surprise you in their usefulness.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( values );
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

foo<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Everything is ", "!"]</span>
<span class="pl-c">// [ "awesome" ]</span></pre></div>

<p>Let's take a moment to consider what's happening in the previous snippet. First, the most jarring thing that jumps out is <code>foo`Everything...`;</code>. That doesn't look like anything we've seen before. What is it?</p>

<p>It's essentially a special kind of function call that doesn't need the <code>( .. )</code>. The <em>tag</em> -- the <code>foo</code> part before the <code>`..`</code> string literal -- is a function value that should be called. Actually, it can be any expression that results in a function, even a function call that returns another function, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( values );
    }
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

bar()<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Everything is ", "!"]</span>
<span class="pl-c">// [ "awesome" ]</span></pre></div>

<p>But what gets passed to the <code>foo(..)</code> function when invoked as a tag for a string literal?</p>

<p>The first argument -- we called it <code>strings</code> -- is an array of all the plain strings (the stuff between any interpolated expressions). We get two values in the <code>strings</code> array: <code>"Everything is "</code> and <code>"!"</code>.</p>

<p>For convenience sake in our example, we then gather up all subsequent arguments into an array called <code>values</code> using the <code>...</code> gather/rest operator (see the "Spread/Rest" section earlier in this chapter), though you could of course have left them as individual named parameters following the <code>strings</code> parameter.</p>

<p>The argument(s) gathered into our <code>values</code> array are the results of the already-evaluated interpolation expressions found in the string literal. So obviously the only element in <code>values</code> in our example is <code>"awesome"</code>.</p>

<p>You can think of these two arrays as: the values in <code>values</code> are the separators if you were to splice them in between the values in <code>strings</code>, and then if you joined everything together, you'd get the complete interpolated string value.</p>

<p>A tagged string literal is like a processing step after the interpolation expressions are evaluated but before the final string value is compiled, allowing you more control over generating the string from the literal.</p>

<p>Typically, the string literal tag function (<code>foo(..)</code> in the previous snippets) should compute an appropriate string value and return it, so that you can use the tagged string literal as a value just like untagged string literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">tag</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-k">return</span> strings.reduce( <span class="pl-k">function</span>(<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>){
        <span class="pl-k">return</span> s <span class="pl-k">+</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>) <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> desc <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span> tag<span class="pl-s"><span class="pl-pds">`</span>Everything is <span class="pl-s1"><span class="pl-pse">${</span>desc<span class="pl-pse">}</span></span>!<span class="pl-pds">`</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );            <span class="pl-c">// Everything is awesome!</span></pre></div>

<p>In this snippet, <code>tag(..)</code> is a pass-through operation, in that it doesn't perform any special modifications, but just uses <code>reduce(..)</code> to loop over and splice/interleave <code>strings</code> and <code>values</code> together the same way an untagged string literal would have done.</p>

<p>So what are some practical uses? There are many advanced ones that are beyond our scope to discuss here. But here's a simple idea that formats numbers as U.S. dollars (sort of like basic localization):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">dollabillsyall</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-k">return</span> strings.reduce( <span class="pl-k">function</span>(<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>){
        <span class="pl-k">if</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// look, also using interpolated</span>
                <span class="pl-c">// string literals!</span>
                s <span class="pl-k">+=</span> <span class="pl-s"><span class="pl-pds">`</span>$<span class="pl-s1"><span class="pl-pse">${</span>values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>].toFixed( <span class="pl-c1">2</span> )<span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>;
            }
            <span class="pl-k">else</span> {
                s <span class="pl-k">+=</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> s <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
}

<span class="pl-k">var</span> amt1 <span class="pl-k">=</span> <span class="pl-c1">11.99</span>,
    amt2 <span class="pl-k">=</span> amt1 <span class="pl-k">*</span> <span class="pl-c1">1.08</span>,
    name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> text <span class="pl-k">=</span> dollabillsyall
<span class="pl-s"><span class="pl-pds">`</span>Thanks for your purchase, <span class="pl-s1"><span class="pl-pse">${</span>name<span class="pl-pse">}</span></span>! Your</span>
<span class="pl-s">product cost was <span class="pl-s1"><span class="pl-pse">${</span>amt1<span class="pl-pse">}</span></span>, which with tax</span>
<span class="pl-s">comes out to <span class="pl-s1"><span class="pl-pse">${</span>amt2<span class="pl-pse">}</span></span>.<span class="pl-pds">`</span></span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( text );
<span class="pl-c">// Thanks for your purchase, Kyle! Your</span>
<span class="pl-c">// product cost was $11.99, which with tax</span>
<span class="pl-c">// comes out to $12.95.</span></pre></div>

<p>If a <code>number</code> value is encountered in the <code>values</code> array, we put <code>"$"</code> in front of it and format it to two decimal places with <code>toFixed(2)</code>. Otherwise, we let the value pass-through untouched.</p>

<h4><a id="user-content-raw-strings" class="anchor" href="#raw-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Raw Strings</h4>

<p>In the previous snippets, our tag functions receive the first argument we called <code>strings</code>, which is an array. But there's an additional bit of data included: the raw unprocessed versions of all the strings. You can access those raw string values using the <code>.raw</code> property, like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">showraw</span>(<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings );
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( strings.raw );
}

showraw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span>;
<span class="pl-c">// [ "Hello</span>
<span class="pl-c">// World" ]</span>
<span class="pl-c">// [ "Hello\nWorld" ]</span></pre></div>

<p>The raw version of the value preserves the raw escaped <code>\n</code> sequence (the <code>\</code> and the <code>n</code> are separate characters), while the processed version considers it a single newline character. However, the earlier mentioned line-ending normalization is applied to both values.</p>

<p>ES6 comes with a built-in function that can be used as a string literal tag: <code>String.raw(..)</code>. It simply passes through the raw versions of the <code>strings</code> values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span> );
<span class="pl-c">// Hello</span>
<span class="pl-c">// World</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span> );
<span class="pl-c">// Hello\nWorld</span>

<span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span>Hello<span class="pl-cce">\n</span>World<span class="pl-pds">`</span></span>.<span class="pl-c1">length</span>;
<span class="pl-c">// 12</span></pre></div>

<p>Other uses for string literal tags included special processing for internationalization, localization, and more!</p>

<h2><a id="user-content-arrow-functions" class="anchor" href="#arrow-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arrow Functions</h2>

<p>We've touched on <code>this</code> binding complications with functions earlier in this chapter, and they're covered at length in the <em>this &amp; Object Prototypes</em> title of this series. It's important to understand the frustrations that <code>this</code>-based programming with normal functions brings, because that is the primary motivation for the new ES6 <code>=&gt;</code> arrow function feature.</p>

<p>Let's first illustrate what an arrow function looks like, as compared to normal functions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">+</span> y;
}

<span class="pl-c">// versus</span>

<span class="pl-k">var</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> (<span class="pl-smi">x</span>,<span class="pl-smi">y</span>)<span class="pl-k"> =&gt;</span> x <span class="pl-k">+</span> y;</pre></div>

<p>The arrow function definition consists of a parameter list (of zero or more parameters, and surrounding <code>( .. )</code> if there's not exactly one parameter), followed by the <code>=&gt;</code> marker, followed by a function body.</p>

<p>So, in the previous snippet, the arrow function is just the <code>(x,y) =&gt; x + y</code> part, and that function reference happens to be assigned to the variable <code>foo</code>.</p>

<p>The body only needs to be enclosed by <code>{ .. }</code> if there's more than one expression, or if the body consists of a non-expression statement. If there's only one expression, and you omit the surrounding <code>{ .. }</code>, there's an implied <code>return</code> in front of the expression, as illustrated in the previous snippet.</p>

<p>Here's some other arrow function variations to consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">f1</span> <span class="pl-k">=</span> ()<span class="pl-k"> =&gt;</span> <span class="pl-c1">12</span>;
<span class="pl-k">var</span> f2 <span class="pl-k">=</span> x <span class="pl-k">=&gt;</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
<span class="pl-k">var</span> <span class="pl-en">f3</span> <span class="pl-k">=</span> (<span class="pl-smi">x</span>,<span class="pl-smi">y</span>)<span class="pl-k"> =&gt;</span> {
    <span class="pl-k">var</span> z <span class="pl-k">=</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> y;
    y<span class="pl-k">++</span>;
    x <span class="pl-k">*=</span> <span class="pl-c1">3</span>;
    <span class="pl-k">return</span> (x <span class="pl-k">+</span> y <span class="pl-k">+</span> z) <span class="pl-k">/</span> <span class="pl-c1">2</span>;
};</pre></div>

<p>Arrow functions are <em>always</em> function expressions; there is no arrow function declaration. It also should be clear that they are anonymous function expressions -- they have no named reference for the purposes of recursion or event binding/unbinding -- though "Function Names" in Chapter 7 will describe ES6's function name inference rules for debugging purposes.</p>

<p><strong>Note:</strong> All the capabilities of normal function parameters are available to arrow functions, including default values, destructuring, rest parameters, and so on.</p>

<p>Arrow functions have a nice, shorter syntax, which makes them on the surface very attractive for writing terser code. Indeed, nearly all literature on ES6 (other than the titles in this series) seems to immediately and exclusively adopt the arrow function as "the new function."</p>

<p>It is telling that nearly all examples in discussion of arrow functions are short single statement utilities, such as those passed as callbacks to various utilities. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a <span class="pl-k">=</span> a.map( v <span class="pl-k">=&gt;</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( a );               <span class="pl-c">// [2,4,6,8,10]</span></pre></div>

<p>In those cases, where you have such inline function expressions, and they fit the pattern of computing a quick calculation in a single statement and returning that result, arrow functions indeed look to be an attractive and lightweight alternative to the more verbose <code>function</code> keyword and syntax.</p>

<p>Most people tend to <em>ooh and aah</em> at nice terse examples like that, as I imagine you just did!</p>

<p>However, I would caution you that it would seem to me somewhat a misapplication of this feature to use arrow function syntax with otherwise normal, multistatement functions, especially those that would otherwise be naturally expressed as function declarations.</p>

<p>Recall the <code>dollabillsyall(..)</code> string literal tag function from earlier in this chapter -- let's change it to use <code>=&gt;</code> syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">dollabillsyall</span> <span class="pl-k">=</span> (<span class="pl-smi">strings</span>, ...<span class="pl-smi">values</span>)<span class="pl-k"> =&gt;</span>
    strings.reduce( (<span class="pl-smi">s</span>,<span class="pl-smi">v</span>,<span class="pl-smi">idx</span>)<span class="pl-k"> =&gt;</span> {
        <span class="pl-k">if</span> (idx <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// look, also using interpolated</span>
                <span class="pl-c">// string literals!</span>
                s <span class="pl-k">+=</span> <span class="pl-s"><span class="pl-pds">`</span>$<span class="pl-s1"><span class="pl-pse">${</span>values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>].toFixed( <span class="pl-c1">2</span> )<span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>;
            }
            <span class="pl-k">else</span> {
                s <span class="pl-k">+=</span> values[idx<span class="pl-k">-</span><span class="pl-c1">1</span>];
            }
        }

        <span class="pl-k">return</span> s <span class="pl-k">+</span> v;
    }, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );</pre></div>

<p>In this example,  the only modifications I made were the removal of <code>function</code>, <code>return</code>, and some <code>{ .. }</code>, and then the insertion of <code>=&gt;</code> and a <code>var</code>. Is this a significant improvement in the readability of the code? Meh.</p>

<p>I'd actually argue that the lack of <code>return</code> and outer <code>{ .. }</code> partially obscures the fact that the <code>reduce(..)</code> call is the only statement in the <code>dollabillsyall(..)</code> function and that its result is the intended result of the call. Also, the trained eye that is so used to hunting for the word <code>function</code> in code to find scope boundaries now needs to look for the <code>=&gt;</code> marker, which can definitely be harder to find in the thick of the code.</p>

<p>While not a hard-and-fast rule, I'd say that the readability gains from <code>=&gt;</code> arrow function conversion are inversely proportional to the length of the function being converted. The longer the function, the less <code>=&gt;</code> helps; the shorter the function, the more <code>=&gt;</code> can shine.</p>

<p>I think it's probably more sensible and reasonable to adopt <code>=&gt;</code> for the places in code where you do need short inline function expressions, but leave your normal-length main functions as is.</p>

<h3><a id="user-content-not-just-shorter-syntax-but-this" class="anchor" href="#not-just-shorter-syntax-but-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Not Just Shorter Syntax, But <code>this</code></h3>

<p>Most of the popular attention toward <code>=&gt;</code> has been on saving those precious keystrokes by dropping <code>function</code>, <code>return</code>, and <code>{ .. }</code> from your code.</p>

<p>But there's a big detail we've skipped over so far. I said at the beginning of the section that <code>=&gt;</code> functions are closely related to <code>this</code> binding behavior. In fact, <code>=&gt;</code> arrow functions are <em>primarily designed</em> to alter <code>this</code> behavior in a specific way, solving a particular and common pain point with <code>this</code>-aware coding.</p>

<p>The saving of keystrokes is a red herring, a misleading sideshow at best.</p>

<p>Let's revisit another example from earlier in this chapter:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;

        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
            <span class="pl-c">// ..</span>
            self.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>We used the <code>var self = this</code> hack, and then referenced <code>self.makeRequest(..)</code>, because inside the callback function we're passing to <code>addEventListener(..)</code>, the <code>this</code> binding will not be the same as it is in <code>makeRequest(..)</code> itself. In other words, because <code>this</code> bindings are dynamic, we fall back to the predictability of lexical scope via the <code>self</code> variable.</p>

<p>Herein we finally can see the primary design characteristic of <code>=&gt;</code> arrow functions. Inside arrow functions, the <code>this</code> binding is not dynamic, but is instead lexical. In the previous snippet, if we used an arrow function for the callback, <code>this</code> will be predictably what we wanted it to be.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    <span class="pl-en">makeRequest</span><span class="pl-k">:</span> <span class="pl-k">function</span>(..){
        btn.addEventListener( <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, ()<span class="pl-k"> =&gt;</span> {
            <span class="pl-c">// ..</span>
            <span class="pl-v">this</span>.makeRequest(..);
        }, <span class="pl-c1">false</span> );
    }
};</pre></div>

<p>Lexical <code>this</code> in the arrow function callback in the previous snippet now points to the same value as in the enclosing <code>makeRequest(..)</code> function. In other words, <code>=&gt;</code> is a syntactic stand-in for <code>var self = this</code>.</p>

<p>In cases where <code>var self = this</code> (or, alternatively, a function <code>.bind(this)</code> call) would normally be helpful, <code>=&gt;</code> arrow functions are a nicer alternative operating on the same prinicple. Sounds great, right?</p>

<p>Not quite so simple.</p>

<p>If <code>=&gt;</code> replaces <code>var self = this</code> or <code>.bind(this)</code> and it helps, guess what happens if you use <code>=&gt;</code> with a <code>this</code>-aware function that <em>doesn't</em> need <code>var self = this</code> to work? You might be able to guess that it's going to mess things up. Yeah.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> controller <span class="pl-k">=</span> {
    makeRequest<span class="pl-k">:</span> (..)<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// ..</span>
        <span class="pl-v">this</span>.helper(..);
    },
    helper<span class="pl-k">:</span> (..)<span class="pl-k"> =&gt;</span> {
        <span class="pl-c">// ..</span>
    }
};

controller.makeRequest(..);</pre></div>

<p>Although we invoke as <code>controller.makeRequest(..)</code>, the <code>this.helper</code> reference fails, because <code>this</code> here doesn't point to <code>controller</code> as it normally would. Where does it point? It lexically inherits <code>this</code> from the surrounding scope. In this previous snippet, that's the global scope, where <code>this</code> points to the global object. Ugh.</p>

<p>In addition to lexical <code>this</code>, arrow functions also have lexical <code>arguments</code> -- they don't have their own <code>arguments</code> array but instead inherit from their parent -- as well as lexical <code>super</code> and <code>new.target</code> (see "Classes" in Chapter 3).</p>

<p>So now we can conclude a more nuanced set of rules for when <code>=&gt;</code> is appropriate and not:</p>

<ul>
<li>If you have a short, single-statement inline function expression, where the only statement is a <code>return</code> of some computed value, <em>and</em> that function doesn't already make a <code>this</code> reference inside it, <em>and</em> there's no self-reference (recursion, event binding/unbinding), <em>and</em> you don't reasonably expect the function to ever be that way, you can probably safely refactor it to be an <code>=&gt;</code> arrow function.</li>
<li>If you have an inner function expression that's relying on a <code>var self = this</code> hack or a <code>.bind(this)</code> call on it in the enclosing function to ensure proper <code>this</code> binding, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>
<li>If you have an inner function expression that's relying on something like <code>var args = Array.prototype.slice.call(arguments)</code> in the enclosing function to make a lexical copy of <code>arguments</code>, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>
<li>For everything else -- normal function declarations, longer multistatment function expressions, functions that need a lexical name identifier self-reference (recursion, etc.), and any other function that doesn't fit the previous characteristics -- you should probably avoid <code>=&gt;</code> function syntax.</li>
</ul>

<p>Bottom line: <code>=&gt;</code> is about lexical binding of <code>this</code>, <code>arguments</code>, and <code>super</code>. These are intentional features designed to fix some common problems, not bugs, quirks, or mistakes in ES6.</p>

<p>Don't believe any hype that <code>=&gt;</code> is primarily, or even mostly, about fewer keystrokes. Whether you save keystrokes or waste them, you should know exactly what you are intentionally doing with every character typed.</p>

<p><strong>Tip:</strong> If you have a function that for any of these articulated reasons is not a good match for an <code>=&gt;</code> arrow function, but it's being declared as part of an object literal, recall from "Concise Methods" earlier in this chapter that there's another option for shorter function syntax.</p>

<p>If you prefer a visual decision chart for how/why to pick an arrow function:</p>

<p><a href="/getify/You-Dont-Know-JS/blob/master/es6 &amp; beyond/fig1.png" target="_blank"><img src="/getify/You-Dont-Know-JS/raw/master/es6 &amp; beyond/fig1.png" style="max-width:100%;"></a></p>

<h2><a id="user-content-forof-loops" class="anchor" href="#forof-loops" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>for..of</code> Loops</h2>

<p>Joining the <code>for</code> and <code>for..in</code> loops from the JavaScript we're all familiar with, ES6 adds a <code>for..of</code> loop, which loops over the set of values produced by an <em>iterator</em>.</p>

<p>The value you loop over with <code>for..of</code> must be an <em>iterable</em>, or it must be a value which can be coerced/boxed to an object (see the <em>Types &amp; Grammar</em> title of this series) that is an iterable. An iterable is simply an object that is able to produce an iterator, which the loop then uses.</p>

<p>Let's compare <code>for..of</code> to <code>for..in</code> to illustrate the difference:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> idx <span class="pl-k">in</span> a) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( idx );
}
<span class="pl-c">// 0 1 2 3 4</span>

<span class="pl-k">for</span> (<span class="pl-k">var</span> val <span class="pl-k">of</span> a) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>As you can see, <code>for..in</code> loops over the keys/indexes in the <code>a</code> array, while <code>for..of</code> loops over the values in <code>a</code>.</p>

<p>Here's the pre-ES6 version of the <code>for..of</code> from that previous snippet:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>],
    k <span class="pl-k">=</span> <span class="pl-c1">Object</span>.keys( a );

<span class="pl-k">for</span> (<span class="pl-k">var</span> val, i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> k.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
    val <span class="pl-k">=</span> a[ k[i] ];
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>And here's the ES6 but non-<code>for..of</code> equivalent, which also gives a glimpse at manually iterating an iterator (see "Iterators" in Chapter 3):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> val, ret, it <span class="pl-k">=</span> a[Symbol.iterator]();
    (ret <span class="pl-k">=</span> it.<span class="pl-c1">next</span>()) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>ret.done;
) {
    val <span class="pl-k">=</span> ret.<span class="pl-c1">value</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );
}
<span class="pl-c">// "a" "b" "c" "d" "e"</span></pre></div>

<p>Under the covers, the <code>for..of</code> loop asks the iterable for an iterator (using the built-in <code>Symbol.iterator</code>; see "Well-Known Symbols" in Chapter 7), then it repeatedly calls the iterator and assigns its produced value to the loop iteration variable.</p>

<p>Standard built-in values in JavaScript that are by default iterables (or provide them) include:</p>

<ul>
<li>Arrays</li>
<li>Strings</li>
<li>Generators (see Chapter 3)</li>
<li>Collections / TypedArrays (see Chapter 5)</li>
</ul>

<p><strong>Warning:</strong> Plain objects are not by default suitable for <code>for..of</code> looping. That's because they don't have a default iterator, which is intentional, not a mistake. However, we won't go any further into those nuanced reasonings here. In "Iterators" in Chapter 3, we'll see how to define iterators for our own objects, which lets <code>for..of</code> loop over any object to get a set of values we define.</p>

<p>Here's how to loop over the characters in a primitive string:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> c <span class="pl-k">of</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( c );
}
<span class="pl-c">// "h" "e" "l" "l" "o"</span></pre></div>

<p>The <code>"hello"</code> primitive string value is coerced/boxed to the <code>String</code> object wrapper equivalent, which is an iterable by default.</p>

<p>In <code>for (XYZ of ABC)..</code>, the <code>XYZ</code> clause can either be an assignment expression or a declaration, identical to that same clause in <code>for</code> and <code>for..in</code> loops. So you can do stuff like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

<span class="pl-k">for</span> (o.a <span class="pl-k">of</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>]) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a );
}
<span class="pl-c">// 1 2 3</span>

<span class="pl-k">for</span> ({x<span class="pl-k">:</span> o.a} <span class="pl-k">of</span> [ {x<span class="pl-k">:</span> <span class="pl-c1">1</span>}, {x<span class="pl-k">:</span> <span class="pl-c1">2</span>}, {x<span class="pl-k">:</span> <span class="pl-c1">3</span>} ]) {
  <span class="pl-en">console</span><span class="pl-c1">.log</span>( o.a );
}
<span class="pl-c">// 1 2 3</span></pre></div>

<p><code>for..of</code> loops can be prematurely stopped, just like other loops, with <code>break</code>, <code>continue</code>, <code>return</code> (if in a function), and thrown exceptions. In any of these cases, the iterator's <code>return(..)</code> function is automatically called (if one exists) to let the iterator perform cleanup tasks, if necessary.</p>

<p><strong>Note:</strong> See "Iterators" in Chapter 3 for more complete coverage on iterables and iterators.</p>

<h2><a id="user-content-regular-expressions" class="anchor" href="#regular-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expressions</h2>

<p>Let's face it: regular expressions haven't changed much in JS in a long time. So it's a great thing that they've finally learned a couple of new tricks in ES6. We'll briefly cover the additions here, but the overall topic of regular expressions is so dense that you'll need to turn to chapters/books dedicated to it (of which there are many!) if you need a refresher.</p>

<h3><a id="user-content-unicode-flag" class="anchor" href="#unicode-flag" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Flag</h3>

<p>We'll cover the topic of Unicode in more detail in "Unicode" later in this chapter. Here, we'll just look briefly at the new <code>u</code> flag for ES6+ regular expressions, which turns on Unicode matching for that expression.</p>

<p>JavaScript strings are typically interpreted as sequences of 16-bit characters, which correspond to the characters in the <em>Basic Multilingual Plane (BMP)</em> (<a href="http://en.wikipedia.org/wiki/Plane_%28Unicode%29">http://en.wikipedia.org/wiki/Plane_%28Unicode%29</a>). But there are many UTF-16 characters that fall outside this range, and so strings may have these multibyte characters in them.</p>

<p>Prior to ES6, regular expressions could only match based on BMP characters, which means that those extended characters were treated as two separate characters for matching purposes. This is often not ideal.</p>

<p>So, as of ES6, the <code>u</code> flag tells a regular expression to process a string with the intepretation of Unicode (UTF-16) characters, such that such an extended character will be matched as a single entity.</p>

<p><strong>Warning:</strong> Despite the name implication, "UTF-16" doesn't strictly mean 16 bits. Modern Unicode uses 21 bits, and standards like UTF-8 and UTF-16 refer roughly to how many bits are used in the representation of a character.</p>

<p>An example (straight from the ES6 specification): 𝄞 (the musical symbol G-clef) is Unicode point U+1D11E (0x1D11E).</p>

<p>If this character appears in a regular expression pattern (like <code>/𝄞/</code>), the standard BMP interpretation would be that it's two separate characters (0xD834 and 0xDD1E) to match with. But the new ES6 Unicode-aware mode means that <code>/𝄞/u</code> (or the escaped Unicode form <code>/\u{1D11E}/u</code>) will match <code>"𝄞"</code> in a string as a single matched character.</p>

<p>You might be wondering why this matters? In non-Unicode BMP mode, the pattern is treated as two separate characters, but would still find the match in a string with the <code>"𝄞"</code> character in it, as you can see if you try:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-sr"><span class="pl-pds">/</span>𝄞<span class="pl-pds">/</span></span>.<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>𝄞-clef<span class="pl-pds">"</span></span> );         <span class="pl-c">// true</span></pre></div>

<p>The length of the match is what matters. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span><span class="pl-c1">.</span>-clef<span class="pl-pds">/</span></span> .<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>𝄞-clef<span class="pl-pds">"</span></span> );     <span class="pl-c">// false</span>
<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-k">^</span><span class="pl-c1">.</span>-clef<span class="pl-pds">/</span>u</span>.<span class="pl-c1">test</span>( <span class="pl-s"><span class="pl-pds">"</span>𝄞-clef<span class="pl-pds">"</span></span> );     <span class="pl-c">// true</span></pre></div>

<p>The <code>^.-clef</code> in the pattern says to match only a single character at the beginning before the normal <code>"-clef"</code> text. In standard BMP mode, the match fails (two characters), but with <code>u</code> Unicode mode flagged on, the match succeeds (one character).</p>

<p>It's also important to note that <code>u</code> makes quantifiers like <code>+</code> and <code>*</code> apply to the entire Unicode code point as a single character, not just the <em>lower surrogate</em> (aka rightmost half of the symbol) of the character. The same goes for Unicode characters appearing in character classes, like <code>/[💩-💫]/u</code>.</p>

<p><strong>Note:</strong> There's plenty more nitty-gritty details about <code>u</code> behavior in regular expressions, which Mathias Bynens (<a href="https://twitter.com/mathias">https://twitter.com/mathias</a>) has written extensively about (<a href="https://mathiasbynens.be/notes/es6-unicode-regex">https://mathiasbynens.be/notes/es6-unicode-regex</a>).</p>

<h3><a id="user-content-sticky-flag" class="anchor" href="#sticky-flag" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Flag</h3>

<p>Another flag mode added to ES6 regular expressions is <code>y</code>, which is often called "sticky mode." <em>Sticky</em> essentially means the regular expression has a virtual anchor at its beginning that keeps it rooted to matching at only the position indicated by the regular expression's <code>lastIndex</code> property.</p>

<p>To illustrate, let's consider two regular expressions, the first without sticky mode and the second with:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re1 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span></span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>++foo++<span class="pl-pds">"</span></span>;

re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>
re1.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true</span>
re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0 -- not updated</span>

re1.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>;
re1.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true -- ignored `lastIndex`</span>
re1.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 4 -- not updated</span></pre></div>

<p>Three things to observe about this snippet:</p>

<ul>
<li><code>test(..)</code> doesn't pay any attention to <code>lastIndex</code>'s value, and always just performs its match from the beginning of the input string.</li>
<li>Because our pattern does not have a <code>^</code> start-of-input anchor, the search for <code>"foo"</code> is free to move ahead through the whole string looking for a match.</li>
<li><code>lastIndex</code> is not updated by <code>test(..)</code>.</li>
</ul>

<p>Now, let's try a sticky mode regular expression:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re2 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>y</span>,       <span class="pl-c">// &lt;-- notice the `y` sticky flag</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>++foo++<span class="pl-pds">"</span></span>;

re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>
re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// false -- "foo" not found at `0`</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0</span>

re2.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;
re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// true</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 5 -- updated to after previous match</span>

re2.<span class="pl-c1">test</span>( str );        <span class="pl-c">// false</span>
re2.<span class="pl-c1">lastIndex</span>;          <span class="pl-c">// 0 -- reset after previous match failure</span></pre></div>

<p>And so our new observations about sticky mode:</p>

<ul>
<li><code>test(..)</code> uses <code>lastIndex</code> as the exact and only position in <code>str</code> to look to make a match. There is no moving ahead to look for the match -- it's either there at the <code>lastIndex</code> position or not.</li>
<li>If a match is made, <code>test(..)</code> updates <code>lastIndex</code> to point to the character immediately following the match. If a match fails, <code>test(..)</code> resets <code>lastIndex</code> back to <code>0</code>.</li>
</ul>

<p>Normal non-sticky patterns that aren't otherwise <code>^</code>-rooted to the start-of-input are free to move ahead in the input string looking for a match. But sticky mode restricts the pattern to matching just at the position of <code>lastIndex</code>.</p>

<p>As I suggested at the beginning of this section, another way of looking at this is that <code>y</code> implies a virtual anchor at the beginning of the pattern that is relative (aka constrains the start of the match) to exactly the <code>lastIndex</code> position.</p>

<p><strong>Warning:</strong> In previous literature on the topic, it has alternatively been asserted that this behavior is like <code>y</code> implying a <code>^</code> (start-of-input) anchor in the pattern. This is inaccurate. We'll explain in further detail in "Anchored Sticky" later.</p>

<h4><a id="user-content-sticky-positioning" class="anchor" href="#sticky-positioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Positioning</h4>

<p>It may seem strangely limiting that to use <code>y</code> for repeated matches, you have to manually ensure <code>lastIndex</code> is in the exact right position, as it has no move-ahead capability for matching.</p>

<p>Here's one possible scenario: if you know that the match you care about is always going to be at a position that's a multiple of a number (e.g., <code>0</code>, <code>10</code>, <code>20</code>, etc.), you can just construct a limited pattern matching what you care about, but then manually set <code>lastIndex</code> each time before match to those fixed positions.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>f<span class="pl-c1">..</span><span class="pl-pds">/</span>y</span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo       far       fad<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["foo"]</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>;
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["far"]</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">20</span>;
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["fad"]</span></pre></div>

<p>However, if you're parsing a string that isn't formatted in fixed positions like that, figuring out what to set <code>lastIndex</code> to before each match is likely going to be untenable.</p>

<p>There's a saving nuance to consider here. <code>y</code> requires that <code>lastIndex</code> be in the exact position for a match to occur. But it doesn't strictly require that <em>you</em> manually set <code>lastIndex</code>.</p>

<p>Instead, you can construct your expressions in such a way that they capture in each main match everything before and after the thing you care about, up to right before the next thing you'll care to match.</p>

<p>Because <code>lastIndex</code> will set to the next character beyond the end of a match, if you've matched everything up to that point, <code>lastIndex</code> will always be in the correct position for the <code>y</code> pattern to start from the next time.</p>

<p><strong>Warning:</strong> If you can't predict the structure of the input string in a sufficiently patterned way like that, this technique may not be suitable and you may not be able to use <code>y</code>.</p>

<p>Having structured string input is likely the most practical scenario where <code>y</code> will be capable of performing repeated matching throughout a string. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-c1">\d</span><span class="pl-k">+</span><span class="pl-cce">\.</span><span class="pl-c1">\s</span>(<span class="pl-c1">.</span><span class="pl-k">*?</span>)(?:<span class="pl-c1">\s</span><span class="pl-k">|</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>y</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1. foo 2. bar 3. baz<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// [ "1. foo ", "foo" ]</span>

re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 7 -- correct position!</span>
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// [ "2. bar ", "bar" ]</span>

re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 14 -- correct position!</span>
str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["3. baz", "baz"]</span></pre></div>

<p>This works because I knew something ahead of time about the structure of the input string: there is always a numeral prefix like <code>"1. "</code> before the desired match (<code>"foo"</code>, etc.), and either a space after it, or the end of the string (<code>$</code> anchor). So the regular expression I constructed captures all of that in each main match, and then I use a matching group <code>( )</code> so that the stuff I really care about is separated out for convenience.</p>

<p>After the first match (<code>"1. foo "</code>), the <code>lastIndex</code> is <code>7</code>, which is already the position needed to start the next match, for <code>"2. bar "</code>, and so on.</p>

<p>If you're going to use <code>y</code> sticky mode for repeated matches, you'll probably want to look for opportunities to have <code>lastIndex</code> automatically positioned as we've just demonstrated.</p>

<h4><a id="user-content-sticky-versus-global" class="anchor" href="#sticky-versus-global" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sticky Versus Global</h4>

<p>Some readers may be aware that you can emulate something like this <code>lastIndex</code>-relative matching with the <code>g</code> global match flag and the <code>exec(..)</code> method, as so:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>o<span class="pl-k">+</span><span class="pl-c1">.</span><span class="pl-pds">/</span>g</span>,        <span class="pl-c">// &lt;-- look, `g`!</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foot book more<span class="pl-pds">"</span></span>;

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["oot"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 4</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["ook"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 9</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// ["or"]</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 13</span>

re.<span class="pl-c1">exec</span>( str );         <span class="pl-c">// null -- no more matches!</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- starts over now!</span></pre></div>

<p>While it's true that <code>g</code> pattern matches with <code>exec(..)</code> start their matching from <code>lastIndex</code>'s current value, and also update <code>lastIndex</code> after each match (or failure), this is not the same thing as <code>y</code>'s behavior.</p>

<p>Notice in the previous snippet that <code>"ook"</code>, located at position <code>6</code>, was matched and found by the second <code>exec(..)</code> call, even though at the time, <code>lastIndex</code> was <code>4</code> (from the end of the previous match). Why? Because as we said earlier, non-sticky matches are free to move ahead in their matching. A sticky mode expression would have failed here, because it would not be allowed to move ahead.</p>

<p>In addition to perhaps undesired move-ahead matching behavior, another downside to just using <code>g</code> instead of <code>y</code> is that <code>g</code> changes the behavior of some matching methods, like <code>str.match(re)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>o<span class="pl-k">+</span><span class="pl-c1">.</span><span class="pl-pds">/</span>g</span>,        <span class="pl-c">// &lt;-- look, `g`!</span>
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foot book more<span class="pl-pds">"</span></span>;

str.<span class="pl-c1">match</span>( re );        <span class="pl-c">// ["oot","ook","or"]</span></pre></div>

<p>See how all the matches were returned at once? Sometimes that's OK, but sometimes that's not what you want.</p>

<p>The <code>y</code> sticky flag will give you one-at-a-time progressive matching with utilities like <code>test(..)</code> and <code>match(..)</code>. Just make sure the <code>lastIndex</code> is always in the right position for each match!</p>

<h4><a id="user-content-anchored-sticky" class="anchor" href="#anchored-sticky" aria-hidden="true"><span class="octicon octicon-link"></span></a>Anchored Sticky</h4>

<p>As we warned earlier, it's inaccurate to think of sticky mode as implying a pattern starts with <code>^</code>. The <code>^</code> anchor has a distinct meaning in regular expressions, which is <em>not altered</em> by sticky mode. <code>^</code> is an anchor that <em>always</em> refers to the beginning of the input, and <em>is not</em> in any way relative to <code>lastIndex</code>.</p>

<p>Besides poor/inaccurate documentation on this topic, the confusion is unfortunately strengthened further because an older pre-ES6 experiment with sticky mode in Firefox <em>did</em> make <code>^</code> relative to <code>lastIndex</code>, so that behavior has been around for years.</p>

<p>ES6 elected not to do it that way. <code>^</code> in a pattern means start-of-input absolutely and only.</p>

<p>As a consequence, a pattern like <code>/^foo/y</code> will always and only find a <code>"foo"</code> match at the beginning of a string, <em>if it's allowed to match there</em>. If <code>lastIndex</code> is not <code>0</code>, the match will fail. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-k">^</span>foo<span class="pl-pds">/</span>y</span>,
    str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// true</span>
re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// false</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- reset after failure</span>

re.<span class="pl-c1">lastIndex</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>;
re.<span class="pl-c1">test</span>( str );         <span class="pl-c">// false -- failed for positioning</span>
re.<span class="pl-c1">lastIndex</span>;           <span class="pl-c">// 0 -- reset after failure</span></pre></div>

<p>Bottom line: <code>y</code> plus <code>^</code> plus <code>lastIndex &gt; 0</code> is an incompatible combination that will always cause a failed match.</p>

<p><strong>Note:</strong> While <code>y</code> does not alter the meaning of <code>^</code> in any way, the <code>m</code> multiline mode <em>does</em>, such that <code>^</code> means start-of-input <em>or</em> start of text after a newline. So, if you combine <code>y</code> and <code>m</code> flags together for a pattern, you can find multiple <code>^</code>-rooted matches in a string. But remember: because it's <code>y</code> sticky, you'll have to make sure <code>lastIndex</code> is pointing at the correct new line position (likely by matching to the end of the line) each subsequent time, or no subsequent matches will be made.</p>

<h3><a id="user-content-regular-expression-flags" class="anchor" href="#regular-expression-flags" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expression <code>flags</code></h3>

<p>Prior to ES6, if you wanted to examine a regular expression object to see what flags it had applied, you needed to parse them out -- ironically, probably with another regular expression -- from the content of the <code>source</code> property, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>ig</span>;

re.<span class="pl-c1">toString</span>();          <span class="pl-c">// "/foo/ig"</span>

<span class="pl-k">var</span> flags <span class="pl-k">=</span> re.<span class="pl-c1">toString</span>().<span class="pl-c1">match</span>(<span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-cce">\/</span>(<span class="pl-c1">[gim]</span><span class="pl-k">*</span>)<span class="pl-k">$</span><span class="pl-pds">/</span></span> )[<span class="pl-c1">1</span>];

flags;                  <span class="pl-c">// "ig"</span></pre></div>

<p>As of ES6, you can now get these values directly, with the new <code>flags</code> property:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-pds">/</span>ig</span>;

re.flags;               <span class="pl-c">// "gi"</span></pre></div>

<p>It's a small nuance, but the ES6 specification calls for the expression's flags to be listed in this order: <code>"gimuy"</code>, regardless of what order the original pattern was specified with. That's the reason for the difference between <code>/ig</code> and <code>"gi"</code>.</p>

<p>No, the order of flags specified or listed doesn't matter.</p>

<p>Another tweak from ES6 is that the <code>RegExp(..)</code> constructor is now <code>flags</code>-aware if you pass it an existing regular expression:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> re1 <span class="pl-k">=</span><span class="pl-sr"> <span class="pl-pds">/</span>foo<span class="pl-k">*</span><span class="pl-pds">/</span>y</span>;
re1.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re1.flags;                          <span class="pl-c">// "y"</span>

<span class="pl-k">var</span> re2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RegExp</span>( re1 );
re2.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re2.flags;                          <span class="pl-c">// "y"</span>

<span class="pl-k">var</span> re3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RegExp</span>( re1, <span class="pl-s"><span class="pl-pds">"</span>ig<span class="pl-pds">"</span></span> );
re3.<span class="pl-c1">source</span>;                         <span class="pl-c">// "foo*"</span>
re3.flags;                          <span class="pl-c">// "gi"</span></pre></div>

<p>Prior to ES6, the <code>re3</code> construction would throw an error, but as of ES6 you can override the flags when duplicating.</p>

<h2><a id="user-content-number-literal-extensions" class="anchor" href="#number-literal-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Number Literal Extensions</h2>

<p>Prior to ES5, number literals looked like the following -- the octal form was not officially specified, only allowed as an extension that browsers had come to de facto agreement on:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> dec <span class="pl-k">=</span> <span class="pl-c1">42</span>,
    oct <span class="pl-k">=</span> <span class="pl-c1">052</span>,
    hex <span class="pl-k">=</span> <span class="pl-c1">0x2a</span>;</pre></div>

<p><strong>Note:</strong> Though you are specifying a number in different bases, the number's mathematic value is what is stored, and the default output interpretation is always base-10. The three variables in the previous snippet all have the <code>42</code> value stored in them.</p>

<p>To further illustrate that <code>052</code> was a nonstandard form extension, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span> );             <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>052<span class="pl-pds">"</span></span> );            <span class="pl-c">// 52</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0x2a<span class="pl-pds">"</span></span> );           <span class="pl-c">// 42</span></pre></div>

<p>ES5 continued to permit the browser-extended octal form (including such inconsistencies), except that in strict mode, the octal literal (<code>052</code>) form is disallowed. This restriction was done mainly because many developers had the habit (from other languages) of seemingly innocuously prefixing otherwise base-10 numbers with <code>0</code>'s for code alignment purposes, and then running into the accidental fact that they'd changed the number value entirely!</p>

<p>ES6 continues the legacy of changes/variations to how number literals outside base-10 numbers can be represented. There's now an official octal form, an amended hexadecimal form, and a brand-new binary form. For web compatibility reasons, the old octal <code>052</code> form will continue to be legal (though unspecified) in non-strict mode, but should really never be used anymore.</p>

<p>Here are the new ES6 number literal forms:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> dec <span class="pl-k">=</span> <span class="pl-c1">42</span>,
    oct <span class="pl-k">=</span> <span class="pl-c1">0o52</span>,         <span class="pl-c">// or `0O52` :(</span>
    hex <span class="pl-k">=</span> <span class="pl-c1">0x2a</span>,         <span class="pl-c">// or `0X2a` :/</span>
    bin <span class="pl-k">=</span> <span class="pl-c1">0b101010</span>;     <span class="pl-c">// or `0B101010` :/</span></pre></div>

<p>The only decimal form allowed is base-10. Octal, hexadecimal, and binary are all integer forms.</p>

<p>And the string representations of these forms are all able to be coerced/converted to their number equivalent:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span> );         <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0o52<span class="pl-pds">"</span></span> );       <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0x2a<span class="pl-pds">"</span></span> );       <span class="pl-c">// 42</span>
<span class="pl-c1">Number</span>( <span class="pl-s"><span class="pl-pds">"</span>0b101010<span class="pl-pds">"</span></span> );   <span class="pl-c">// 42</span></pre></div>

<p>Though not strictly new to ES6, it's a little-known fact that you can actually go the opposite direction of conversion (well, sort of):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">42</span>;

a.<span class="pl-c1">toString</span>();           <span class="pl-c">// "42" -- also `a.toString( 10 )`</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">8</span> );        <span class="pl-c">// "52"</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );       <span class="pl-c">// "2a"</span>
a.<span class="pl-c1">toString</span>( <span class="pl-c1">2</span> );        <span class="pl-c">// "101010"</span></pre></div>

<p>In fact, you can represent a number this way in any base from <code>2</code> to <code>36</code>, though it'd be rare that you'd go outside the standard bases: 2, 8, 10, and 16.</p>

<h2><a id="user-content-unicode" class="anchor" href="#unicode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode</h2>

<p>Let me just say that this section is not an exhaustive everything-you-ever-wanted-to-know-about-Unicode resource. I want to cover what you need to know that's <em>changing</em> for Unicode in ES6, but we won't go much deeper than that. Mathias Bynens (<a href="http://twitter.com/mathias">http://twitter.com/mathias</a>) has written/spoken extensively and brilliantly about JS and Unicode (see <a href="https://mathiasbynens.be/notes/javascript-unicode">https://mathiasbynens.be/notes/javascript-unicode</a> and <a href="http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode">http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode</a>).</p>

<p>The Unicode characters that range from <code>0x0000</code> to <code>0xFFFF</code> contain all the standard printed characters (in various languages) that you're likely to have seen or interacted with. This group of characters is called the <em>Basic Multilingual Plane (BMP)</em>. The BMP even contains fun symbols like this cool snowman: ☃ (U+2603).</p>

<p>There are lots of other extended Unicode characters beyond this BMP set, which range up to <code>0x10FFFF</code>. These symbols are often referred to as <em>astral</em> symbols, as that's the name given to the set of 16 <em>planes</em> (e.g., layers/groupings) of characters beyond the BMP. Examples of astral symbols include 𝄞 (U+1D11E) and <g-emoji alias="hankey" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png"><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a9.png" class="emoji" title=":hankey:" alt=":hankey:" height="20" width="20" align="absmiddle"></g-emoji> (U+1F4A9).</p>

<p>Prior to ES6, JavaScript strings could specify Unicode characters using Unicode escaping, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> snowman <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>2603<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( snowman );         <span class="pl-c">// "☃"</span></pre></div>

<p>However, the <code>\uXXXX</code> Unicode escaping only supports four hexadecimal characters, so you can only represent the BMP set of characters in this way. To represent an astral character using Unicode escaping prior to ES6, you need to use a <em>surrogate pair</em> -- basically two specially calculated Unicode-escaped characters side by side, which JS interprets together as a single astral character:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>D834<span class="pl-cce">\u</span>DD1E<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( gclef );           <span class="pl-c">// "𝄞"</span></pre></div>

<p>As of ES6, we now have a new form for Unicode escaping (in strings and regular expressions), called Unicode <em>code point escaping</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\u</span>{1D11E}<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-c1">.log</span>( gclef );           <span class="pl-c">// "𝄞"</span></pre></div>

<p>As you can see, the difference is the presence of the <code>{ }</code> in the escape sequence, which allows it to contain any number of hexadecimal characters. Because you only need six to represent the highest possible code point value in Unicode (i.e., 0x10FFFF), this is sufficient.</p>

<h3><a id="user-content-unicode-aware-string-operations" class="anchor" href="#unicode-aware-string-operations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode-Aware String Operations</h3>

<p>By default, JavaScript string operations and methods are not sensitive to astral symbols in string values. So, they treat each BMP character individually, even the two surrogate halves that make up an otherwise single astral character. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> snowman <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>☃<span class="pl-pds">"</span></span>;
snowman.<span class="pl-c1">length</span>;                 <span class="pl-c">// 1</span>

<span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>𝄞<span class="pl-pds">"</span></span>;
gclef.<span class="pl-c1">length</span>;                   <span class="pl-c">// 2</span></pre></div>

<p>So, how do we accurately calculate the length of such a string? In this scenario, the following trick will work:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> gclef <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>𝄞<span class="pl-pds">"</span></span>;

[...gclef].<span class="pl-c1">length</span>;              <span class="pl-c">// 1</span>
<span class="pl-c1">Array</span>.from( gclef ).<span class="pl-c1">length</span>;     <span class="pl-c">// 1</span></pre></div>

<p>Recall from the "<code>for..of</code> Loops" section earlier in this chapter that ES6 strings have built-in iterators. This iterator happens to be Unicode-aware, meaning it will automatically output an astral symbol as a single value. We take advantage of that using the <code>...</code> spread operator in an array literal, which creates an array of the string's symbols. Then we just inspect the length of that resultant array. ES6's <code>Array.from(..)</code> does basically the same thing as <code>[...XYZ]</code>, but we'll cover that utility in detail in Chapter 6.</p>

<p><strong>Warning:</strong> It should be noted that constructing and exhausting an iterator just to get the length of a string is quite expensive on performance, relatively speaking, compared to what a theoretically optimized native utility/property would do.</p>

<p>Unfortunately, the full answer is not as simple or straightforward. In addition to the surrogate pairs (which the string iterator takes care of), there are special Unicode code points that behave in other special ways, which is much harder to account for. For example, there's a set of code points that modify the previous adjacent character, known as <em>Combining Diacritical Marks</em>.</p>

<p>Consider these two string outputs:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// "é"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s2 );              <span class="pl-c">// "é"</span></pre></div>

<p>They look the same, but they're not! Here's how we created <code>s1</code> and <code>s2</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;</pre></div>

<p>As you can probably guess, our previous <code>length</code> trick doesn't work with <code>s2</code>:</p>

<div class="highlight highlight-source-js"><pre>[...s1].<span class="pl-c1">length</span>;                 <span class="pl-c">// 1</span>
[...s2].<span class="pl-c1">length</span>;                 <span class="pl-c">// 2</span></pre></div>

<p>So what can we do? In this case, we can perform a <em>Unicode normalization</em> on the value before inquiring about its length, using the ES6 <code>String#normalize(..)</code> utility (which we'll cover more in Chapter 6):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;

s1.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 1</span>
s2.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 1</span>

s1 <span class="pl-k">===</span> s2;                      <span class="pl-c">// false</span>
s1 <span class="pl-k">===</span> s2.normalize();          <span class="pl-c">// true</span></pre></div>

<p>Essentially, <code>normalize(..)</code> takes a sequence like <code>"e\u0301"</code> and normalizes it to <code>"\xE9"</code>. Normalization can even combine multiple adjacent combining marks if there's a suitable Unicode character they combine to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>o<span class="pl-cce">\u</span>0302<span class="pl-cce">\u</span>0300<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> s1.normalize(),
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ồ<span class="pl-pds">"</span></span>;

s1.<span class="pl-c1">length</span>;                      <span class="pl-c">// 3</span>
s2.<span class="pl-c1">length</span>;                      <span class="pl-c">// 1</span>
s3.<span class="pl-c1">length</span>;                      <span class="pl-c">// 1</span>

s2 <span class="pl-k">===</span> s3;                      <span class="pl-c">// true</span></pre></div>

<p>Unfortunately, normalization isn't fully perfect here, either. If you have multiple combining marks modifying a single character, you may not get the length count you'd expect, because there may not be a single defined normalized character that represents the combination of all the marks. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-cce">\u</span>0330<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// "ḛ́"</span>

s1.normalize().<span class="pl-c1">length</span>;          <span class="pl-c">// 2</span></pre></div>

<p>The further you go down this rabbit hole, the more you realize that it's difficult to get one precise definition for "length." What we see visually rendered as a single character -- more precisely called a <em>grapheme</em> -- doesn't always strictly relate to a single "character" in the program processing sense.</p>

<p><strong>Tip:</strong> If you want to see just how deep this rabbit hole goes, check out the "Grapheme Cluster Boundaries" algorithm (<a href="http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries</a>).</p>

<h3><a id="user-content-character-positioning" class="anchor" href="#character-positioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Character Positioning</h3>

<p>Similar to length complications, what does it actually mean to ask, "what is the character at position 2?" The naive pre-ES6 answer comes from <code>charAt(..)</code>, which will not respect the atomicity of an astral character, nor will it take into account combining marks.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( s1 );              <span class="pl-c">// "abćd"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s2 );              <span class="pl-c">// "abćd"</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>( s3 );              <span class="pl-c">// "ab𝒞d"</span>

s1.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// "c"</span>
s2.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// "ć"</span>
s3.<span class="pl-c1">charAt</span>( <span class="pl-c1">2</span> );                 <span class="pl-c">// "" &lt;-- unprintable surrogate</span>
s3.<span class="pl-c1">charAt</span>( <span class="pl-c1">3</span> );                 <span class="pl-c">// "" &lt;-- unprintable surrogate</span></pre></div>

<p>So, is ES6 giving us a Unicode-aware verison of <code>charAt(..)</code>? Unfortunately, no. At the time of this writing, there's a proposal for such a utility that's under consideration for post-ES6.</p>

<p>But with what we explored in the previous section (and of course with the limitations noted thereof!), we can hack an ES6 answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

[...s1.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// "ć"</span>
[...s2.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// "ć"</span>
[...s3.normalize()][<span class="pl-c1">2</span>];         <span class="pl-c">// "𝒞"</span></pre></div>

<p><strong>Warning:</strong> Reminder of an earlier warning: constructing and exhausting an iterator each time you want to get at a single character is... very not ideal, performance wise. Let's hope we get a built-in and optimized utility for this soon, post-ES6.</p>

<p>What about a Unicode-aware version of the <code>charCodeAt(..)</code> utility? ES6 gives us <code>codePointAt(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

s1.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "107"</span>

s2.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "107"</span>

s3.normalize().codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );
<span class="pl-c">// "1d49e"</span></pre></div>

<p>What about the other direction? A Unicode-aware version of <code>String.fromCharCode(..)</code> is ES6's <code>String.fromCodePoint(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x107</span> );      <span class="pl-c">// "ć"</span>

<span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x1d49e</span> );    <span class="pl-c">// "𝒞"</span></pre></div>

<p>So wait, can we just combine <code>String.fromCodePoint(..)</code> and <code>codePointAt(..)</code> to get a better version of a Unicode-aware <code>charAt(..)</code> from earlier? Yep!</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-cce">\u</span>0301d<span class="pl-pds">"</span></span>,
    s2 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>0107d<span class="pl-pds">"</span></span>,
    s3 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-cce">\u</span>{1d49e}d<span class="pl-pds">"</span></span>;

<span class="pl-c1">String</span>.fromCodePoint( s1.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// "ć"</span>

<span class="pl-c1">String</span>.fromCodePoint( s2.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// "ć"</span>

<span class="pl-c1">String</span>.fromCodePoint( s3.normalize().codePointAt( <span class="pl-c1">2</span> ) );
<span class="pl-c">// "𝒞"</span></pre></div>

<p>There's quite a few other string methods we haven't addressed here, including <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring(..)</code>, <code>indexOf(..)</code>, <code>slice(..)</code>, and a dozen others. None of these have been changed or augmented for full Unicode awareness, so you should be very careful -- probably just avoid them! -- when working with strings containing astral symbols.</p>

<p>There are also several string methods that use regular expressions for their behavior, like <code>replace(..)</code> and <code>match(..)</code>. Thankfully, ES6 brings Unicode awareness to regular expressions, as we covered in "Unicode Flag" earlier in this chapter.</p>

<p>OK, there we have it! JavaScript's Unicode string support is significantly better over pre-ES6 (though still not perfect) with the various additions we've just covered.</p>

<h3><a id="user-content-unicode-identifier-names" class="anchor" href="#unicode-identifier-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Identifier Names</h3>

<p>Unicode can also be used in identifier names (variables, properties, etc.). Prior to ES6, you could do this with Unicode-escapes, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> \u03A9 <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// same as: var Ω = 42;</span></pre></div>

<p>As of ES6, you can also use the earlier explained code point escape syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> \u{2B400} <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c">// same as: var 𫐀 = 42;</span></pre></div>

<p>There's a complex set of rules around exactly which Unicode characters are allowed. Furthermore, some are allowed only if they're not the first character of the identifier name.</p>

<p><strong>Note:</strong> Mathias Bynens has a great post (<a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">https://mathiasbynens.be/notes/javascript-identifiers-es6</a>) on all the nitty-gritty details.</p>

<p>The reasons for using such unusual characters in identifier names are rather rare and academic. You typically won't be best served by writing code that relies on these esoteric capabilities.</p>

<h2><a id="user-content-symbols" class="anchor" href="#symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols</h2>

<p>With ES6, for the first time in quite a while, a new primitive type has been added to JavaScript: the <code>symbol</code>. Unlike the other primitive types, however, symbols don't have a literal form.</p>

<p>Here's how you create a symbol:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> sym <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>some optional description<span class="pl-pds">"</span></span> );

<span class="pl-k">typeof</span> sym;     <span class="pl-c">// "symbol"</span></pre></div>

<p>Some things to note:</p>

<ul>
<li>You cannot and should not use <code>new</code> with <code>Symbol(..)</code>. It's not a constructor, nor are you producing an object.</li>
<li>The parameter passed to <code>Symbol(..)</code> is optional. If passed, it should be a string that gives a friendly description for the symbol's purpose.</li>
<li>The <code>typeof</code> output is a new value (<code>"symbol"</code>) that is the primary way to identify a symbol.</li>
</ul>

<p>The description, if provided, is solely used for the stringification representation of the symbol:</p>

<div class="highlight highlight-source-js"><pre>sym.<span class="pl-c1">toString</span>();     <span class="pl-c">// "Symbol(some optional description)"</span></pre></div>

<p>Similar to how primitive string values are not instances of <code>String</code>, symbols are also not instances of <code>Symbol</code>. If, for some reason, you want to construct a boxed wrapper object form of a symbol value, you can do the following:</p>

<div class="highlight highlight-source-js"><pre>sym <span class="pl-k">instanceof</span> Symbol;      <span class="pl-c">// false</span>

<span class="pl-k">var</span> symObj <span class="pl-k">=</span> <span class="pl-c1">Object</span>( sym );
symObj <span class="pl-k">instanceof</span> Symbol;   <span class="pl-c">// true</span>

symObj.<span class="pl-c1">valueOf</span>() <span class="pl-k">===</span> sym;   <span class="pl-c">// true</span></pre></div>

<p><strong>Note:</strong> <code>symObj</code> in this snippet is interchangeable with <code>sym</code>; either form can be used in all places symbols are utilized. There's not much reason to use the boxed wrapper object form (<code>symObj</code>) instead of the primitive form (<code>sym</code>). Keeping with similar advice for other primitives, it's probably best to prefer <code>sym</code> over <code>symObj</code>.</p>

<p>The internal value of a symbol itself -- referred to as its <code>name</code> -- is hidden from the code and cannot be obtained. You can think of this symbol value as an automatically generated, unique (within your application) string value.</p>

<p>But if the value is hidden and unobtainable, what's the point of having a symbol at all?</p>

<p>The main point of a symbol is to create a string-like value that can't collide with any other value. So, for example, consider using a symbol as a constant representing an event name:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">EVT_LOGIN</span> <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>event.login<span class="pl-pds">"</span></span> );</pre></div>

<p>You'd then use <code>EVT_LOGIN</code> in place of a generic string literal like <code>"event.login"</code>:</p>

<div class="highlight highlight-source-js"><pre>evthub.listen( <span class="pl-c1">EVT_LOGIN</span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>The benefit here is that <code>EVT_LOGIN</code> holds a value that cannot be duplicated (accidentally or otherwise) by any other value, so it is impossible for there to be any confusion of which event is being dispatched or handled.</p>

<p><strong>Note:</strong> Under the covers, the <code>evthub</code> utility assumed in the previous snippet would almost certainly be using the symbol value from the <code>EVT_LOGIN</code> argument directly as the property/key in some internal object (hash) that tracks event handlers. If <code>evthub</code> instead needed to use the symbol value as a real string, it would need to explicitly coerce with <code>String(..)</code> or <code>toString()</code>, as implicit string coercion of symbols is not allowed.</p>

<p>You may use a symbol directly as a property name/key in an object, such as a special property that you want to treat as hidden or meta in usage. It's important to know that although you intend to treat it as such, it is not <em>actually</em> a hidden or untouchable property.</p>

<p>Consider this module that implements the <em>singleton</em> pattern behavior -- that is, it only allows itself to be created once:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">INSTANCE</span> <span class="pl-k">=</span> Symbol( <span class="pl-s"><span class="pl-pds">"</span>instance<span class="pl-pds">"</span></span> );

<span class="pl-k">function</span> <span class="pl-en">HappyFace</span>() {
    <span class="pl-k">if</span> (HappyFace[<span class="pl-c1">INSTANCE</span>]) <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>];

    <span class="pl-k">function</span> <span class="pl-en">smile</span>() { .. }

    <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>] <span class="pl-k">=</span> {
        smile<span class="pl-k">:</span> smile
    };
}

<span class="pl-k">var</span> me <span class="pl-k">=</span> HappyFace(),
    you <span class="pl-k">=</span> HappyFace();

me <span class="pl-k">===</span> you;         <span class="pl-c">// true</span></pre></div>

<p>The <code>INSTANCE</code> symbol value here is a special, almost hidden, meta-like property stored statically on the <code>HappyFace()</code> function object.</p>

<p>It could alternatively have been a plain old property like <code>__instance</code>, and the behavior would have been identical. The usage of a symbol simply improves the metaprogramming style, keeping this <code>INSTANCE</code> property set apart from any other normal properties.</p>

<h3><a id="user-content-symbol-registry" class="anchor" href="#symbol-registry" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbol Registry</h3>

<p>One mild downside to using symbols as in the last few examples is that the <code>EVT_LOGIN</code> and <code>INSTANCE</code> variables had to be stored in an outer scope (perhaps even the global scope), or otherwise somehow stored in a publicly available location, so that all parts of the code that need to use the symbols can access them.</p>

<p>To aid in organizing code with access to these symbols, you can create symbol values with the <em>global symbol registry</em>. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">EVT_LOGIN</span> <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>event.login<span class="pl-pds">"</span></span> );

<span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-c1">EVT_LOGIN</span> );       <span class="pl-c">// Symbol(event.login)</span></pre></div>

<p>And:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">HappyFace</span>() {
    <span class="pl-k">const</span> <span class="pl-c1">INSTANCE</span> <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>instance<span class="pl-pds">"</span></span> );

    <span class="pl-k">if</span> (HappyFace[<span class="pl-c1">INSTANCE</span>]) <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>];

    <span class="pl-c">// ..</span>

    <span class="pl-k">return</span> HappyFace[<span class="pl-c1">INSTANCE</span>] <span class="pl-k">=</span> { .. };
}</pre></div>

<p><code>Symbol.for(..)</code> looks in the global symbol registry to see if a symbol is already stored with the provided description text, and returns it if so. If not, it creates one to return. In other words, the global symbol registry treats symbol values, by description text, as singletons themselves.</p>

<p>But that also means that any part of your application can retrieve the symbol from the registry using <code>Symbol.for(..)</code>, as long as the matching description name is used.</p>

<p>Ironically, symbols are basically intended to replace the use of <em>magic strings</em> (arbitrary string values given special meaning) in your application. But you precisely use <em>magic</em> description string values to uniquely identify/locate them in the global symbol registry!</p>

<p>To avoid accidental collisions, you'll probably want to make your symbol descriptions quite unique. One easy way of doing that is to include prefix/context/namespacing information in them.</p>

<p>For example, consider a utility such as the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">extractValues</span>(<span class="pl-smi">str</span>) {
    <span class="pl-k">var</span> key <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>extractValues.parse<span class="pl-pds">"</span></span> ),
        re <span class="pl-k">=</span> extractValues[key] <span class="pl-k">||</span>
<span class="pl-sr">            <span class="pl-pds">/</span><span class="pl-c1">[<span class="pl-k">^</span>=&amp;]</span><span class="pl-k">+?</span>=(<span class="pl-c1">[<span class="pl-k">^</span>&amp;]</span><span class="pl-k">+?</span>)(?=&amp;<span class="pl-k">|</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>g</span>,
        values <span class="pl-k">=</span> [], match;

    <span class="pl-k">while</span> (match <span class="pl-k">=</span> re.<span class="pl-c1">exec</span>( str )) {
        values.<span class="pl-c1">push</span>( match[<span class="pl-c1">1</span>] );
    }

    <span class="pl-k">return</span> values;
}</pre></div>

<p>We use the magic string value <code>"extractValues.parse"</code> because it's quite unlikely that any other symbol in the registry would ever collide with that description.</p>

<p>If a user of this utility wants to override the parsing regular expression, they can also use the symbol registry:</p>

<div class="highlight highlight-source-js"><pre>extractValues[Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>extractValues.parse<span class="pl-pds">"</span></span> )] <span class="pl-k">=</span>
<span class="pl-sr">    <span class="pl-pds">/</span><span class="pl-c1">..</span>some pattern<span class="pl-c1">..</span><span class="pl-pds">/</span>g</span>;

extractValues( <span class="pl-s"><span class="pl-pds">"</span>..some string..<span class="pl-pds">"</span></span> );</pre></div>

<p>Aside from the assistance the symbol registry provides in globally storing these values, everything we're seeing here could have been done by just actually using the magic string <code>"extractValues.parse"</code> as the key, rather than the symbol. The improvements exist at the metaprogramming level more than the functional level.</p>

<p>You may have occasion to use a symbol value that has been stored in the registry to look up what description text (key) it's stored under. For example, you may need to signal to another part of your application how to locate a symbol in the registry because you cannot pass the symbol value itself.</p>

<p>You can retrieve a registered symbol's description text (key) using <code>Symbol.keyFor(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>something cool<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> desc <span class="pl-k">=</span> Symbol.keyFor( s );
<span class="pl-en">console</span><span class="pl-c1">.log</span>( desc );            <span class="pl-c">// "something cool"</span>

<span class="pl-c">// get the symbol from the registry again</span>
<span class="pl-k">var</span> s2 <span class="pl-k">=</span> Symbol.for( desc );

s2 <span class="pl-k">===</span> s;                       <span class="pl-c">// true</span></pre></div>

<h3><a id="user-content-symbols-as-object-properties" class="anchor" href="#symbols-as-object-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols as Object Properties</h3>

<p>If a symbol is used as a property/key of an object, it's stored in a special way so that the property will not show up in a normal enumeration of the object's properties:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    [ Symbol( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ) ]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    baz<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

<span class="pl-c1">Object</span>.getOwnPropertyNames( o );    <span class="pl-c">// [ "foo","baz" ]</span></pre></div>

<p>To retrieve an object's symbol properties:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [ Symbol(bar) ]</span></pre></div>

<p>This makes it clear that a property symbol is not actually hidden or inaccessible, as you can always see it in the <code>Object.getOwnPropertySymbols(..)</code> list.</p>

<h4><a id="user-content-built-in-symbols" class="anchor" href="#built-in-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Built-In Symbols</h4>

<p>ES6 comes with a number of predefined built-in symbols that expose various meta behaviors on JavaScript object values. However, these symbols are <em>not</em> registered in the global symbol registry, as one might expect.</p>

<p>Instead, they're stored as properties on the <code>Symbol</code> function object. For example, in the "<code>for..of</code>" section earlier in this chapter, we introduced the <code>Symbol.iterator</code> value:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

a[Symbol.iterator];         <span class="pl-c">// native function</span></pre></div>

<p>The specification uses the <code>@@</code> prefix notation to refer to the built-in symbols, the most common ones being: <code>@@iterator</code>, <code>@@toStringTag</code>, <code>@@toPrimitive</code>. Several others are defined as well, though they probably won't be used as often.</p>

<p><strong>Note:</strong> See "Well Known Symbols" in Chapter 7 for detailed information about how these built-in symbols are used for meta programming purposes.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 adds a heap of new syntax forms to JavaScript, so there's plenty to learn!</p>

<p>Most of these are designed to ease the pain points of common programming idioms, such as setting default values to function parameters and gathering the "rest" of the parameters into an array. Destructuring is a powerful tool for more concisely expressing assignments of values from arrays and nested objects.</p>

<p>While features like <code>=&gt;</code> arrow functions appear to also be all about shorter and nicer-looking syntax, they actually have very specific behaviors that you should intentionally use only in appropriate situations.</p>

<p>Expanded Unicode support, new tricks for regular expressions, and even a new primitive <code>symbol</code> type round out the syntactic evolution of ES6.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-3-organization" class="anchor" href="#chapter-3-organization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3: Organization</h1>

<p>It's one thing to write JS code, but it's another to properly organize it. Utilizing common patterns for organization and reuse goes a long way to improving the readability and understandability of your code. Remember: code is at least as much about communicating to other developers as it is about feeding the computer instructions.</p>

<p>ES6 has several important features that help signficantly improve these patterns, including: iterators, generators, modules, and classes.</p>

<h2><a id="user-content-iterators" class="anchor" href="#iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterators</h2>

<p>An <em>iterator</em> is a structured pattern for pulling information from a source in one-at-a-time fashion. This pattern has been around programming for a long time. And to be sure, JS developers have been ad hoc designing and implementing iterators in JS programs since before anyone can remember, so it's not at all a new topic.</p>

<p>What ES6 has done is introduce an implicit standardized interface for iterators. Many of the built-in data structures in JavaScript will now expose an iterator implementing this standard. And you can also construct your own iterators adhering to the same standard, for maximal interoperability.</p>

<p>Iterators are a way of organizing ordered, sequential, pull-based consumption of data.</p>

<p>For example, you may implement a utility that produces a new unique identifier each time it's requested. Or you may produce an infinite series of values that rotate through a fixed list, in round-robin fashion. Or you could attach an iterator to a database query result to pull out new rows one at a time.</p>

<p>Although they have not commonly been used in JS in such a manner, iterators can also be thought of as controlling behavior one step at a time. This can be illustrated quite clearly when considering generators (see "Generators" later in this chapter), though you can certainly do the same without generators.</p>

<h3><a id="user-content-interfaces" class="anchor" href="#interfaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interfaces</h3>

<p>At the time of this writing, ES6 section 25.1.1.2 (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-iterator-interface">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface</a>) details the <code>Iterator</code> interface as having the following requirement:</p>

<pre><code>Iterator [required]
    next() {method}: retrieves next IteratorResult
</code></pre>

<p>There are two optional members that some iterators are extended with:</p>

<pre><code>Iterator [optional]
    return() {method}: stops iterator and returns IteratorResult
    throw() {method}: signals error and returns IteratorResult
</code></pre>

<p>The <code>IteratorResult</code> interface is specified as:</p>

<pre><code>IteratorResult
    value {property}: current iteration value or final return value
        (optional if `undefined`)
    done {property}: boolean, indicates completion status
</code></pre>

<p><strong>Note:</strong> I call these interfaces implicit not because they're not explicitly called out in the specification -- they are! -- but because they're not exposed as direct objects accessible to code. JavaScript does not, in ES6, support any notion of "interfaces," so adherence for your own code is purely conventional. However, wherever JS expects an iterator -- a <code>for..of</code> loop, for instance -- what you provide must adhere to these interfaces or the code will fail.</p>

<p>There's also an <code>Iterable</code> interface, which describes objects that must be able to produce iterators:</p>

<pre><code>Iterable
    @@iterator() {method}: produces an Iterator
</code></pre>

<p>If you recall from "Built-In Symbols" in Chapter 2, <code>@@iterator</code> is the special built-in symbol representing the method that can produce iterator(s) for the object.</p>

<h4><a id="user-content-iteratorresult" class="anchor" href="#iteratorresult" aria-hidden="true"><span class="octicon octicon-link"></span></a>IteratorResult</h4>

<p>The <code>IteratorResult</code> interface specifies that the return value from any iterator operation will be an object of the form:</p>

<div class="highlight highlight-source-js"><pre>{ value<span class="pl-k">:</span> .. , done<span class="pl-k">:</span> <span class="pl-c1">true</span> <span class="pl-k">/</span> <span class="pl-c1">false</span> }</pre></div>

<p>Built-in iterators will always return values of this form, but more properties are, of course, allowed to be present on the return value, as necessary.</p>

<p>For example, a custom iterator may add additional metadata to the result object (e.g., where the data came from, how long it took to retrieve, cache expiration length, frequency for the appropriate next request, etc.).</p>

<p><strong>Note:</strong> Technically, <code>value</code> is optional if it would otherwise be considered absent or unset, such as in the case of the value <code>undefined</code>. Because accessing <code>res.value</code> will produce <code>undefined</code> whether it's present with that value or absent entirely, the presence/absence of the property is more an implementation detail or an optimization (or both), rather than a functional issue.</p>

<h3><a id="user-content-next-iteration" class="anchor" href="#next-iteration" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>next()</code> Iteration</h3>

<p>Let's look at an array, which is an iterable, and the iterator it can produce to consume its values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">var</span> it <span class="pl-k">=</span> arr[Symbol.iterator]();

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 1, done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 2, done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: 3, done: false }</span>

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Each time the method located at <code>Symbol.iterator</code> (see Chapters 2 and 7) is invoked on this <code>arr</code> value, it will produce a new fresh iterator. Most structures will do the same, including all the built-in data structures in JS.</p>

<p>However, a structure like an event queue consumer might only ever produce a single iterator (singleton pattern). Or a structure might only allow one unique iterator at a time, requiring the current one to be completed before a new one can be created.</p>

<p>The <code>it</code> iterator in the previous snippet doesn't report <code>done: true</code> when you receive the <code>3</code> value. You have to call <code>next()</code> again, in essence going beyond the end of the array's values, to get the complete signal <code>done: true</code>. It may not be clear why until later in this section, but that design decision will typically be considered a best practice.</p>

<p>Primitive string values are also iterables by default:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> greeting <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> it <span class="pl-k">=</span> greeting[Symbol.iterator]();

it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: "h", done: false }</span>
it.<span class="pl-c1">next</span>();      <span class="pl-c">// { value: "e", done: false }</span>
..</pre></div>

<p><strong>Note:</strong> Technically, the primitive value itself isn't iterable, but thanks to "boxing", <code>"hello world"</code> is coerced/converted to its <code>String</code> object wrapper form, which <em>is</em> an iterable. See the <em>Types &amp; Grammar</em> title of this series for more information.</p>

<p>ES6 also includes several new data structures, called collections (see Chapter 5). These collections are not only iterables themselves, but they also provide API method(s) to generate an iterator, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();
m.set( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span> );
m.set( { cool<span class="pl-k">:</span> <span class="pl-c1">true</span> }, <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> m[Symbol.iterator]();
<span class="pl-k">var</span> it2 <span class="pl-k">=</span> m.entries();

it1.<span class="pl-c1">next</span>();     <span class="pl-c">// { value: [ "foo", 42 ], done: false }</span>
it2.<span class="pl-c1">next</span>();     <span class="pl-c">// { value: [ "foo", 42 ], done: false }</span>
..</pre></div>

<p>The <code>next(..)</code> method of an iterator can optionally take one or more arguments. The built-in iterators mostly do not exercise this capability, though a generator's iterator definitely does (see "Generators" later in this chapter).</p>

<p>By general convention, including all the built-in iterators, calling <code>next(..)</code> on an iterator that's already been exhausted is not an error, but will simply continue to return the result <code>{ value: undefined, done: true }</code>.</p>

<h3><a id="user-content-optional-return-and-throw" class="anchor" href="#optional-return-and-throw" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optional: <code>return(..)</code> and <code>throw(..)</code></h3>

<p>The optional methods on the iterator interface -- <code>return(..)</code> and <code>throw(..)</code> -- are not implemented on most of the built-in iterators. However, they definitely do mean something in the context of generators, so see "Generators" for more specific information.</p>

<p><code>return(..)</code> is defined as sending a signal to an iterator that the consuming code is complete and will not be pulling any more values from it. This signal can be used to notify the producer (the iterator responding to <code>next(..)</code> calls) to perform any cleanup it may need to do, such as releasing/closing network, database, or file handle resources.</p>

<p>If an iterator has a <code>return(..)</code> present and any condition occurs that can automatically be interpreted as abnormal or early termination of consuming the iterator, <code>return(..)</code> will automatically be called. You can call <code>return(..)</code> manually as well.</p>

<p><code>return(..)</code> will return an <code>IteratorResult</code> object just like <code>next(..)</code> does. In general, the optional value you send to <code>return(..)</code> would be sent back as <code>value</code> in this <code>IteratorResult</code>, though there are nuanced cases where that might not be true.</p>

<p><code>throw(..)</code> is used to signal an exception/error to an iterator, which possibly may be used differently by the iterator than the completion signal implied by <code>return(..)</code>. It does not necessarily imply a complete stop of the iterator as <code>return(..)</code> generally does.</p>

<p>For example, with generator iterators, <code>throw(..)</code> actually injects a thrown exception into the generator's paused execution context, which can be caught with a <code>try..catch</code>. An uncaught <code>throw(..)</code> exception would end up abnormally aborting the generator's iterator.</p>

<p><strong>Note:</strong> By general convention, an iterator should not produce any more results after having called <code>return(..)</code> or <code>throw(..)</code>.</p>

<h3><a id="user-content-iterator-loop" class="anchor" href="#iterator-loop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Loop</h3>

<p>As we covered in the "<code>for..of</code>" section in Chapter 2, the ES6 <code>for..of</code> loop directly consumes a conforming iterable.</p>

<p>If an iterator is also an iterable, it can be used directly with the <code>for..of</code> loop. You make an iterator an iterable by giving it a <code>Symbol.iterator</code> method that simply returns the iterator itself:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> {
    <span class="pl-c">// make the `it` iterator an iterable</span>
    [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

    <span class="pl-en">next</span>() { .. },
    ..
};

it[Symbol.iterator]() <span class="pl-k">===</span> it;       <span class="pl-c">// true</span></pre></div>

<p>Now we can consume the <code>it</code> iterator with a <code>for..of</code> loop:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> it) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}</pre></div>

<p>To fully understand how such a loop works, recall the <code>for</code> equivalent of a <code>for..of</code> loop from Chapter 2:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v, res; (res <span class="pl-k">=</span> it.<span class="pl-c1">next</span>()) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>res.done; ) {
    v <span class="pl-k">=</span> res.<span class="pl-c1">value</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}</pre></div>

<p>If you look closely, you'll see that <code>it.next()</code> is called before each iteration, and then <code>res.done</code> is consulted. If <code>res.done</code> is <code>true</code>, the expression evaluates to <code>false</code> and the iteration doesn't occur.</p>

<p>Recall earlier that we suggested iterators should in general not return <code>done: true</code> along with the final intended value from the iterator. Now you can see why.</p>

<p>If an iterator returned <code>{ done: true, value: 42 }</code>, the <code>for..of</code> loop would completely discard the <code>42</code> value and it'd be lost. For this reason, assuming that your iterator may be consumed by patterns like the <code>for..of</code> loop or its manual <code>for</code> equivalent, you should probably wait to return <code>done: true</code> for signaling completion until after you've already returned all relevant iteration values.</p>

<p><strong>Warning:</strong> You can, of course, intentionally design your iterator to return some relevant <code>value</code> at the same time as returning <code>done: true</code>. But don't do this unless you've documented that as the case, and thus implicitly forced consumers of your iterator to use a different pattern for iteration than is implied by <code>for..of</code> or its manual equivalent we depicted.</p>

<h3><a id="user-content-custom-iterators" class="anchor" href="#custom-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom Iterators</h3>

<p>In addition to the standard built-in iterators, you can make your own! All it takes to make them interoperate with ES6's consumption facilities (e.g., the <code>for..of</code> loop and the <code>...</code> operator) is to adhere to the proper interface(s).</p>

<p>Let's try constructing an iterator that produces the infinite series of numbers in the Fibonacci sequence:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> Fib <span class="pl-k">=</span> {
    [Symbol.iterator]() {
        <span class="pl-k">var</span> n1 <span class="pl-k">=</span> <span class="pl-c1">1</span>, n2 <span class="pl-k">=</span> <span class="pl-c1">1</span>;

        <span class="pl-k">return</span> {
            <span class="pl-c">// make the iterator an iterable</span>
            [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

            <span class="pl-en">next</span>() {
                <span class="pl-k">var</span> current <span class="pl-k">=</span> n2;
                n2 <span class="pl-k">=</span> n1;
                n1 <span class="pl-k">=</span> n1 <span class="pl-k">+</span> current;
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> current, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
            },

            <span class="pl-k">return</span>(v) {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>(
                    <span class="pl-s"><span class="pl-pds">"</span>Fibonacci sequence abandoned.<span class="pl-pds">"</span></span>
                );
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> v, done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
            }
        };
    }
};

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> Fib) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );

    <span class="pl-k">if</span> (v <span class="pl-k">&gt;</span> <span class="pl-c1">50</span>) <span class="pl-k">break</span>;
}
<span class="pl-c">// 1 1 2 3 5 8 13 21 34 55</span>
<span class="pl-c">// Fibonacci sequence abandoned.</span></pre></div>

<p><strong>Warning:</strong> If we hadn't inserted the <code>break</code> condition, this <code>for..of</code> loop would have run forever, which is probably not the desired result in terms of breaking your program!</p>

<p>The <code>Fib[Symbol.iterator]()</code> method when called returns the iterator object with <code>next()</code> and <code>return(..)</code> methods on it. State is maintained via <code>n1</code> and <code>n2</code> variables, which are kept by the closure.</p>

<p>Let's <em>next</em> consider an iterator that is designed to run through a series (aka a queue) of actions, one item at a time:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> tasks <span class="pl-k">=</span> {
    [Symbol.iterator]() {
        <span class="pl-k">var</span> steps <span class="pl-k">=</span> <span class="pl-v">this</span>.actions.<span class="pl-c1">slice</span>();

        <span class="pl-k">return</span> {
            <span class="pl-c">// make the iterator an iterable</span>
            [Symbol.iterator]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; },

            <span class="pl-en">next</span>(...<span class="pl-smi">args</span>) {
                <span class="pl-k">if</span> (steps.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) {
                    <span class="pl-k">let</span> res <span class="pl-k">=</span> steps.<span class="pl-c1">shift</span>()( ...args );
                    <span class="pl-k">return</span> { value<span class="pl-k">:</span> res, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
                }
                <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> { done<span class="pl-k">:</span> <span class="pl-c1">true</span> }
                }
            },

            <span class="pl-k">return</span>(v) {
                steps.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                <span class="pl-k">return</span> { value<span class="pl-k">:</span> v, done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
            }
        };
    },
    actions<span class="pl-k">:</span> []
};</pre></div>

<p>The iterator on <code>tasks</code> steps through functions found in the <code>actions</code> array property, if any, and executes them one at a time, passing in whatever arguments you pass to <code>next(..)</code>, and returning any return value to you in the standard <code>IteratorResult</code> object.</p>

<p>Here's how we could could use this <code>tasks</code> queue:</p>

<div class="highlight highlight-source-js"><pre>tasks.actions.<span class="pl-c1">push</span>(
    <span class="pl-k">function</span> <span class="pl-en">step1</span>(<span class="pl-smi">x</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 1:<span class="pl-pds">"</span></span>, x );
        <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    },
    <span class="pl-k">function</span> <span class="pl-en">step2</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 2:<span class="pl-pds">"</span></span>, x, y );
        <span class="pl-k">return</span> x <span class="pl-k">+</span> (y <span class="pl-k">*</span> <span class="pl-c1">2</span>);
    },
    <span class="pl-k">function</span> <span class="pl-en">step3</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>step 3:<span class="pl-pds">"</span></span>, x, y, z );
        <span class="pl-k">return</span> (x <span class="pl-k">*</span> y) <span class="pl-k">+</span> z;
    }
);

<span class="pl-k">var</span> it <span class="pl-k">=</span> tasks[Symbol.iterator]();

it.<span class="pl-c1">next</span>( <span class="pl-c1">10</span> );          <span class="pl-c">// step 1: 10</span>
                        <span class="pl-c">// { value:   20, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">20</span>, <span class="pl-c1">50</span> );      <span class="pl-c">// step 2: 20 50</span>
                        <span class="pl-c">// { value:  120, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">20</span>, <span class="pl-c1">50</span>, <span class="pl-c1">120</span> ); <span class="pl-c">// step 3: 20 50 120</span>
                        <span class="pl-c">// { value: 1120, done: false }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { done: true }</span></pre></div>

<p>This particular usage reinforces that iterators can be a pattern for organizing functionality, not just data. It's also reminiscent of what we'll see with generators in the next section.</p>

<p>You could even get creative and define an iterator that represents meta operations on a single piece of data. For example, we could define an iterator for numbers that by default ranges from <code>0</code> up to (or down to, for negative numbers) the number in question.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Number</span>.<span class="pl-c1">prototype</span>[Symbol.iterator]) {
    <span class="pl-c1">Object</span>.defineProperty(
        <span class="pl-c1">Number</span>.<span class="pl-c1">prototype</span>,
        Symbol.iterator,
        {
            writable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
            configurable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
            enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
            <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">iterator</span>(){
                <span class="pl-k">var</span> i, inc, done <span class="pl-k">=</span> <span class="pl-c1">false</span>, top <span class="pl-k">=</span> <span class="pl-k">+</span><span class="pl-v">this</span>;

                <span class="pl-c">// iterate positively or negatively?</span>
                inc <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">*</span> (top <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">?</span> <span class="pl-k">-</span><span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>);

                <span class="pl-k">return</span> {
                    <span class="pl-c">// make the iterator itself an iterable!</span>
                    [Symbol.iterator](){ <span class="pl-k">return</span> <span class="pl-v">this</span>; },

                    <span class="pl-en">next</span>() {
                        <span class="pl-k">if</span> (<span class="pl-k">!</span>done) {
                            <span class="pl-c">// initial iteration always 0</span>
                            <span class="pl-k">if</span> (i <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
                                i <span class="pl-k">=</span> <span class="pl-c1">0</span>;
                            }
                            <span class="pl-c">// iterating positively</span>
                            <span class="pl-k">else</span> <span class="pl-k">if</span> (top <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
                                i <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">min</span>(top,i <span class="pl-k">+</span> inc);
                            }
                            <span class="pl-c">// iterating negatively</span>
                            <span class="pl-k">else</span> {
                                i <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">max</span>(top,i <span class="pl-k">+</span> inc);
                            }

                            <span class="pl-c">// done after this iteration?</span>
                            <span class="pl-k">if</span> (i <span class="pl-k">==</span> top) done <span class="pl-k">=</span> <span class="pl-c1">true</span>;

                            <span class="pl-k">return</span> { value<span class="pl-k">:</span> i, done<span class="pl-k">:</span> <span class="pl-c1">false</span> };
                        }
                        <span class="pl-k">else</span> {
                            <span class="pl-k">return</span> { done<span class="pl-k">:</span> <span class="pl-c1">true</span> };
                        }
                    }
                };
            }
        }
    );
}</pre></div>

<p>Now, what tricks does this creativity afford us?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">of</span> <span class="pl-c1">3</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( i );
}
<span class="pl-c">// 0 1 2 3</span>

[...<span class="pl-k">-</span><span class="pl-c1">3</span>];                <span class="pl-c">// [0,-1,-2,-3]</span></pre></div>

<p>Those are some fun tricks, though the practical utility is somewhat debatable. But then again, one might wonder why ES6 didn't just ship with such a minor but delightful feature easter egg!?</p>

<p>I'd be remiss if I didn't at least remind you that extending native prototypes as I'm doing in the previous snippet is something you should only do with caution and awareness of potential hazards.</p>

<p>In this case, the chances that you'll have a collision with other code or even a future JS feature is probably exceedingly low. But just beware of the slight possibility. And document what you're doing verbosely for posterity's sake.</p>

<p><strong>Note:</strong> I've expounded on this particular technique in this blog post (<a href="http://blog.getify.com/iterating-es6-numbers/">http://blog.getify.com/iterating-es6-numbers/</a>) if you want more details. And this comment (<a href="http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294">http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294</a>) even suggests a similar trick but for making string character ranges.</p>

<h3><a id="user-content-iterator-consumption" class="anchor" href="#iterator-consumption" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Consumption</h3>

<p>We've already shown consuming an iterator item by item with the <code>for..of</code> loop. But there are other ES6 structures that can consume iterators.</p>

<p>Let's consider the iterator attached to this array (though any iterator we choose would have the following behaviors):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];</pre></div>

<p>The <code>...</code> spread operator fully exhausts an iterator. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>,<span class="pl-smi">z</span>,<span class="pl-smi">w</span>,<span class="pl-smi">p</span>) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x <span class="pl-k">+</span> y <span class="pl-k">+</span> z <span class="pl-k">+</span> w <span class="pl-k">+</span> p );
}

foo( ...a );            <span class="pl-c">// 15</span></pre></div>

<p><code>...</code> can also spread an iterator inside an array:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> b <span class="pl-k">=</span> [ <span class="pl-c1">0</span>, ...a, <span class="pl-c1">6</span> ];
b;                      <span class="pl-c">// [0,1,2,3,4,5,6]</span></pre></div>

<p>Array destructuring (see "Destructuring" in Chapter 2) can partially or completely (if paired with a <code>...</code> rest/gather operator) consume an iterator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> a[Symbol.iterator]();

<span class="pl-k">var</span> [x,y] <span class="pl-k">=</span> it;         <span class="pl-c">// take just the first two elements from `it`</span>
<span class="pl-k">var</span> [z, ...w] <span class="pl-k">=</span> it;     <span class="pl-c">// take the third, then the rest all at once</span>

<span class="pl-c">// is `it` fully exhausted? Yep.</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span>

x;                      <span class="pl-c">// 1</span>
y;                      <span class="pl-c">// 2</span>
z;                      <span class="pl-c">// 3</span>
w;                      <span class="pl-c">// [4,5]</span></pre></div>

<h2><a id="user-content-generators" class="anchor" href="#generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators</h2>

<p>All functions run to completion, right? In other words, once a function starts running, it finishes before anything else can interrupt.</p>

<p>At least that's how it's been for the whole history of JavaScript up to this point. As of ES6, a new somewhat exotic form of function is being introduced, called a generator. A generator can pause itself in mid-execution, and can be resumed either right away or at a later time. So it clearly does not hold the run-to-completion guarantee that normal functions do.</p>

<p>Moreover, each pause/resume cycle in mid-execution is an opportunity for two-way message passing, where the generator can return a value, and the controlling code that resumes it can send a value back in.</p>

<p>As with iterators in the previous section, there are multiple ways to think about what a generator is, or rather what it's most useful for. There's no one right answer, but we'll try to consider several angles.</p>

<p><strong>Note:</strong> See the <em>Async &amp; Performance</em> title of this series for more information about generators, and also see Chapter 4 of this current title.</p>

<h3><a id="user-content-syntax" class="anchor" href="#syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax</h3>

<p>The generator function is declared with this new syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// ..</span>
}</pre></div>

<p>The position of the <code>*</code> is not functionally relevant. The same declaration could be written as any of the following:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>()  { .. }
<span class="pl-k">function*</span> <span class="pl-en">foo</span>()  { .. }
<span class="pl-k">function</span> <span class="pl-k">*</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">function</span><span class="pl-k">*</span><span class="pl-en">foo</span>()   { .. }
..</pre></div>

<p>The <em>only</em> difference here is stylistic preference. Most other literature seems to prefer <code>function* foo(..) { .. }</code>. I prefer <code>function *foo(..) { .. }</code>, so that's how I'll present them for the rest of this title.</p>

<p>My reason is purely didactic in nature. In this text, when referring to a generator function, I will use <code>*foo(..)</code>, as opposed to <code>foo(..)</code> for a normal function. I observe that <code>*foo(..)</code> more closely matches the <code>*</code> positioning of <code>function *foo(..) { .. }</code>.</p>

<p>Moreover, as we saw in Chapter 2 with concise methods, there's a concise generator form in object literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> {
    <span class="pl-k">*</span><span class="pl-en">foo</span>() { .. }
};</pre></div>

<p>I would say that with concise generators, <code>*foo() { .. }</code> is rather more natural than <code>* foo() { .. }</code>. So that further argues for matching the consistency with <code>*foo()</code>.</p>

<p>Consistency eases understanding and learning.</p>

<h4><a id="user-content-executing-a-generator" class="anchor" href="#executing-a-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Executing a Generator</h4>

<p>Though a generator is declared with <code>*</code>, you still execute it like a normal function:</p>

<div class="highlight highlight-source-js"><pre>foo();</pre></div>

<p>You can still pass it arguments, as in:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>,<span class="pl-smi">y</span>) {
    <span class="pl-c">// ..</span>
}

foo( <span class="pl-c1">5</span>, <span class="pl-c1">10</span> );</pre></div>

<p>The major difference is that executing a generator, like <code>foo(5,10)</code> doesn't actually run the code in the generator. Instead, it produces an iterator that will control the generator to execute its code.</p>

<p>We'll come back to this later in "Iterator Control," but briefly:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

<span class="pl-c">// to start/advanced `*foo()`, call</span>
<span class="pl-c">// `it.next(..)`</span></pre></div>

<h4><a id="user-content-yield" class="anchor" href="#yield" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>yield</code></h4>

<p>Generators also have a new keyword you can use inside them, to signal the pause point: <code>yield</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">10</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-c1">20</span>;

    <span class="pl-k">yield</span>;

    <span class="pl-k">var</span> z <span class="pl-k">=</span> x <span class="pl-k">+</span> y;
}</pre></div>

<p>In this <code>*foo()</code> generator, the operations on the first two lines would run at the beginning, then <code>yield</code> would pause the generator. If and when resumed, the last line of <code>*foo()</code> would run. <code>yield</code> can appear any number of times (or not at all, technically!) in a generator.</p>

<p>You can even put <code>yield</code> inside a loop, and it can represent a repeated pause point. In fact, a loop that never completes just means a generator that never completes, which is completely valid, and sometimes entirely what you need.</p>

<p><code>yield</code> is not just a pause point. It's an expression that sends out a value when pausing the generator. Here's a <code>while..true</code> loop in a generator that for each iteration <code>yield</code>s a new random number:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
        <span class="pl-k">yield</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();
    }
}</pre></div>

<p>The <code>yield ..</code> expression not only sends a value -- <code>yield</code> without a value is the same as <code>yield undefined</code> -- but also receives (e.g., is replaced by) the eventual resumption value. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">10</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}</pre></div>

<p>This generator will first <code>yield</code> out the value <code>10</code> when pausing itself. When you resume the generator -- using the <code>it.next(..)</code> we referred to earlier -- whatever value (if any) you resume with will replace/complete the whole <code>yield 10</code> expression, meaning that value will be assigned to the <code>x</code> variable.</p>

<p>A <code>yield ..</code> expression can appear anywhere a normal expression can. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> arr <span class="pl-k">=</span> [ <span class="pl-k">yield</span> <span class="pl-c1">1</span>, <span class="pl-k">yield</span> <span class="pl-c1">2</span>, <span class="pl-k">yield</span> <span class="pl-c1">3</span> ];
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( arr, <span class="pl-k">yield</span> <span class="pl-c1">4</span> );
}</pre></div>

<p><code>*foo()</code> here has four <code>yield ..</code> expressions. Each <code>yield</code> results in the generator pausing to wait for a resumption value that's then used in the various expression contexts.</p>

<p><code>yield</code> is not technically an operator, though when used like <code>yield 1</code> it sure looks like it. Because <code>yield</code> can be used all by itself as in <code>var x = yield;</code>, thinking of it as an operator can sometimes be confusing.</p>

<p>Technically, <code>yield ..</code> is of the same "expression precedence" -- similar conceptually to operator precedence -- as an assignment expression like <code>a = 3</code>. That means <code>yield ..</code> can basically appear anywhere <code>a = 3</code> can validly appear.</p>

<p>Let's illustrate the symmetry:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a, b;

a <span class="pl-k">=</span> <span class="pl-c1">3</span>;                  <span class="pl-c">// valid</span>
b <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> a <span class="pl-k">=</span> <span class="pl-c1">3</span>;          <span class="pl-c">// invalid</span>
b <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> (a <span class="pl-k">=</span> <span class="pl-c1">3</span>);        <span class="pl-c">// valid</span>

<span class="pl-k">yield</span> <span class="pl-c1">3</span>;                <span class="pl-c">// valid</span>
a <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-k">yield</span> <span class="pl-c1">3</span>;        <span class="pl-c">// invalid</span>
a <span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> (<span class="pl-k">yield</span> <span class="pl-c1">3</span>);      <span class="pl-c">// valid</span></pre></div>

<p><strong>Note:</strong> If you think about it, it makes a sort of conceptual sense that a <code>yield ..</code> expression would behave similar to an assignment expression. When a paused <code>yield</code> expression is resumed, it's completed/replaced by the resumption value in a way that's not terribly dissimilar from being "assigned" that value.</p>

<p>The takeaway: if you need <code>yield ..</code> to appear in a position where an assignment like <code>a = 3</code> would not itself be allowed, it needs to be wrapped in a <code>( )</code>.</p>

<p>Because of the low precedence of the <code>yield</code> keyword, almost any expression after a <code>yield ..</code> will be computed first before being sent with <code>yield</code>. Only the <code>...</code> spread operator and the <code>,</code> comma operator have lower precedence, meaning they'd bind after the <code>yield</code> has been evaluated.</p>

<p>So just like with multiple operators in normal statements, another case where <code>( )</code> might be needed is to override (elevate) the low precedence of <code>yield</code>, such as the difference between these expressions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">yield</span> <span class="pl-c1">2</span> <span class="pl-k">+</span> <span class="pl-c1">3</span>;            <span class="pl-c">// same as `yield (2 + 3)`</span>

(<span class="pl-k">yield</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> <span class="pl-c1">3</span>;          <span class="pl-c">// `yield 2` first, then `+ 3`</span></pre></div>

<p>Just like <code>=</code> assignment, <code>yield</code> is also "right-associative," which means that multiple <code>yield</code> expressions in succession are treated as having been <code>( .. )</code> grouped from right to left. So, <code>yield yield yield 3</code> is treated as <code>yield (yield (yield 3))</code>. A "left-associative" interpretation like <code>((yield) yield) yield 3</code> would make no sense.</p>

<p>Just like with operators, it's a good idea to use <code>( .. )</code> grouping, even if not strictly required, to disambiguate your intent if <code>yield</code> is combined with other operators or <code>yield</code>s.</p>

<p><strong>Note:</strong> See the <em>Types &amp; Grammar</em> title of this series for more information about operator precedence and associativity.</p>

<h4><a id="user-content-yield-" class="anchor" href="#yield-" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>yield *</code></h4>

<p>In the same way that the <code>*</code> makes a <code>function</code> declaration into <code>function *</code> generator declaration, a <code>*</code> makes <code>yield</code> into <code>yield *</code>, which is a very different mechanism, called <em>yield delegation</em>. Grammatically, <code>yield *..</code> will behave the same as a <code>yield ..</code>, as discussed in the previous section.</p>

<p><code>yield * ..</code> requires an iterable; it then invokes that iterable's iterator, and delegates its own host generator's control to that iterator until it's exhausted. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-k">*</span>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
}</pre></div>

<p><strong>Note:</strong> As with the <code>*</code> position in a generator's declaration (discussed earlier), the <code>*</code> positioning in <code>yield *</code> expressions is stylistically up to you. Most other literature prefers <code>yield* ..</code>, but I prefer <code>yield *..</code>, for very symmetrical reasons as already discussed.</p>

<p>The <code>[1,2,3]</code> value produces an iterator that will step through its values, so the <code>*foo()</code> generator will yield those values out as it's consumed. Another way to illustrate the behavior is in yield delegating to another generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();
}</pre></div>

<p>The iterator produced when <code>*bar()</code> calls <code>*foo()</code> is delegated to via <code>yield *</code>, meaning whatever value(s) <code>*foo()</code> produces will be produced by <code>*bar()</code>.</p>

<p>Whereas with <code>yield ..</code> the completion value of the expression comes from resuming the generator with <code>it.next(..)</code>, the completion value of the <code>yield *..</code> expression comes from the return value (if any) from the delegated-to iterator.</p>

<p>Built-in iterators generally don't have return values, as we covered at the end of the "Iterator Loop" section earlier in this chapter. But if you define your own custom iterator (or generator), you can design it to <code>return</code> a value, which <code>yield *..</code> would capture:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    <span class="pl-k">return</span> <span class="pl-c1">4</span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>x:<span class="pl-pds">"</span></span>, x );
}

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> bar()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span>
<span class="pl-c">// x: 4</span></pre></div>

<p>While the <code>1</code>, <code>2</code>, and <code>3</code> values are <code>yield</code>ed out of <code>*foo()</code> and then out of <code>*bar()</code>, the <code>4</code> value returned from <code>*foo()</code> is the completion value of the <code>yield *foo()</code> expression, which then gets assigned to <code>x</code>.</p>

<p>Because <code>yield *</code> can call another generator (by way of delegating to its iterator), it can also perform a sort of generator recursion by calling itself:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) {
        x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

foo( <span class="pl-c1">1</span> );</pre></div>

<p>The result from <code>foo(1)</code> and then calling the iterator's <code>next()</code> to run it through its recursive steps will be <code>24</code>. The first <code>*foo(..)</code> run has <code>x</code> at value <code>1</code>, which is <code>x &lt; 3</code>. <code>x + 1</code> is passed recursively to <code>*foo(..)</code>, so <code>x</code> is then <code>2</code>. One more recursive call results in <code>x</code> of <code>3</code>.</p>

<p>Now, because <code>x &lt; 3</code> fails, the recursion stops, and <code>return 3 * 2</code> gives <code>6</code> back to the previous call's <code>yield *..</code> expression, which is then assigned to <code>x</code>. Another <code>return 6 * 2</code> returns <code>12</code> back to the previous call's <code>x</code>. Finally <code>12 * 2</code>, or <code>24</code>, is returned from the completed run of the <code>*foo(..)</code> generator.</p>

<h3><a id="user-content-iterator-control" class="anchor" href="#iterator-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Iterator Control</h3>

<p>Earlier, we briefly introduced the concept that generators are controlled by iterators. Let's fully dig into that now.</p>

<p>Recall the recursive <code>*foo(..)</code> from the previous section. Here's how we'd run it:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">3</span>) {
        x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-k">*</span>foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo( <span class="pl-c1">1</span> );
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 24, done: true }</span></pre></div>

<p>In this case, the generator doesn't really ever pause, as there's no <code>yield ..</code> expression. Instead, <code>yield *</code> just keeps the current iteration step going via the recursive call. So, just one call to the iterator's <code>next()</code> function fully runs the generator.</p>

<p>Now let's consider a generator that will have multiple steps and thus multiple produced values:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}</pre></div>

<p>We already know we can consume an iterator, even one attached to a generator like <code>*foo()</code>, with a <code>for..of</code> loop:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> foo()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span></pre></div>

<p><strong>Note:</strong> The <code>for..of</code> loop requires an iterable. A generator function reference (like <code>foo</code>) by itself is not an iterable; you must execute it with <code>foo()</code> to get the iterator (which is also an iterable, as we explained earlier in this chapter). You could theoretically extend the <code>GeneratorPrototype</code> (the prototype of all generator functions) with a <code>Symbol.iterator</code> function that essentially just does <code>return this()</code>. That would make the <code>foo</code> reference itself an iterable, which means <code>for (var v of foo) { .. }</code> (notice no <code>()</code> on <code>foo</code>) will work.</p>

<p>Let's instead iterate the generator manually:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 2, done: false }</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 3, done: false }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>If you look closely, there are three <code>yield</code> statements and four <code>next()</code> calls. That may seem like a strange mismatch. In fact, there will always be one more <code>next()</code> call than <code>yield</code> expression, assuming all are evaluated and the generator is fully run to completion.</p>

<p>But if you look at it from the opposite perspective (inside-out instead of outside-in), the matching between <code>yield</code> and <code>next()</code> makes more sense.</p>

<p>Recall that the <code>yield ..</code> expression will be completed by the value you resume the generator with. That means the argument you pass to <code>next(..)</code> completes whatever <code>yield ..</code> expression is currently paused waiting for a completion.</p>

<p>Let's illustrate this perspective this way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">var</span> z <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x, y, z );
}</pre></div>

<p>In this snippet, each <code>yield ..</code> is sending a value out (<code>1</code>, <code>2</code>, <code>3</code>), but more directly, it's pausing the generator to wait for a value. In other words, it's almost like asking the question, "What value should I use here? I'll wait to hear back."</p>

<p>Now, here's how we control <code>*foo()</code> to start it up:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span></pre></div>

<p>That first <code>next()</code> call is starting up the generator from its initial paused state, and running it to the first <code>yield</code>. At the moment you call that first <code>next()</code>, there's no <code>yield ..</code> expression waiting for a completion. If you passed a value to that first <code>next()</code> call, it would currently just be thrown away, because no <code>yield</code> is waiting to receive such a value.</p>

<p><strong>Note:</strong> An early proposal for the "beyond ES6" timeframe <em>would</em> let you access a value passed to an initial <code>next(..)</code> call via a separate meta property (see Chapter 7) inside the generator.</p>

<p>Now, let's answer the currently pending question, "What value should I assign to <code>x</code>?" We'll answer it by sending a value to the <em>next</em> <code>next(..)</code> call:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 2, done: false }</span></pre></div>

<p>Now, the <code>x</code> will have the value <code>"foo"</code>, but we've also asked a new question, "What value should I assign to <code>y</code>?" And we answer:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 3, done: false }</span></pre></div>

<p>Answer given, another question asked. Final answer:</p>

<div class="highlight highlight-source-js"><pre>it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> );       <span class="pl-c">// "foo" "bar" "baz"</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Now it should be clearer how each <code>yield ..</code> "question" is answered by the <em>next</em> <code>next(..)</code> call, and so the "extra" <code>next()</code> call we observed is always just the initial one that starts everything going.</p>

<p>Let's put all those steps together:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

<span class="pl-c">// start up the generator</span>
it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-c">// answer first question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 2, done: false }</span>

<span class="pl-c">// answer second question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );       <span class="pl-c">// { value: 3, done: false }</span>

<span class="pl-c">// answer third question</span>
it.<span class="pl-c1">next</span>( <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> );       <span class="pl-c">// "foo" "bar" "baz"</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>You can think of a generator as a producer of values, in which case each iteration is simply producing a value to be consumed.</p>

<p>But in a more general sense, perhaps it's appropriate to think of generators as controlled, progressive code execution, much like the <code>tasks</code> queue example from the earlier "Custom Iterators" section.</p>

<p><strong>Note:</strong> That perspective is exactly the motivation for how we'll revisit generators in Chapter 4. Specifically, there's no reason that <code>next(..)</code> has to be called right away after the previous <code>next(..)</code> finishes. While the generator's inner execution context is paused, the rest of the program continues unblocked, including the ability for asynchronous actions to control when the generator is resumed.</p>

<h3><a id="user-content-early-completion" class="anchor" href="#early-completion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Early Completion</h3>

<p>As we covered earlier in this chapter, the iterator attached to a generator supports the optional <code>return(..)</code> and <code>throw(..)</code> methods. Both of them have the effect of aborting a paused generator immediately.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

it.return( <span class="pl-c1">42</span> );        <span class="pl-c">// { value: 42, done: true }</span>

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p><code>return(x)</code> is kind of like forcing a <code>return x</code> to be processed at exactly that moment, such that you get the specified value right back. Once a generator is completed, either normally or early as shown, it no longer processes any code or returns any values.</p>

<p>In addition to <code>return(..)</code> being callable manually, it's also called automatically at the end of iteration by any of the ES6 constructs that consume iterators, such as the <code>for..of</code> loop and the <code>...</code> spread operator.</p>

<p>The purpose for this capability is so the generator can be notified if the controlling code is no longer going to iterate over it anymore, so that it can perhaps do any cleanup tasks (freeing up resources, resetting status, etc.). Identical to a normal function cleanup pattern, the main way to accomplish this is to use a <code>finally</code> clause:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
        <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
        <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
    }
    <span class="pl-k">finally</span> {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cleanup!<span class="pl-pds">"</span></span> );
    }
}

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> foo()) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 1 2 3</span>
<span class="pl-c">// cleanup!</span>

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>
it.return( <span class="pl-c1">42</span> );        <span class="pl-c">// cleanup!</span>
                        <span class="pl-c">// { value: 42, done: true }</span></pre></div>

<p><strong>Warning:</strong> Do not put a <code>yield</code> statement inside the <code>finally</code> clause! It's valid and legal, but it's a really terrible idea. It acts in a sense as deferring the completion of the <code>return(..)</code> call you made, as any <code>yield ..</code> expressions in the <code>finally</code> clause are respected to pause and send messages; you don't immediately get a completed generator as expected. There's basically no good reason to opt in to that crazy <em>bad part</em>, so avoid doing so!</p>

<p>In addition to the previous snippet showing how <code>return(..)</code> aborts the generator while still triggering the <code>finally</code> clause, it also demonstrates that a generator produces a whole new iterator each time it's called. In fact, you can use multiple iterators attached to the same generator concurrently:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it1 <span class="pl-k">=</span> foo();
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 1, done: false }</span>
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 2, done: false }</span>

<span class="pl-k">var</span> it2 <span class="pl-k">=</span> foo();
it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 1, done: false }</span>

it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 3, done: false }</span>

it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 2, done: false }</span>
it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: 3, done: false }</span>

it2.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: undefined, done: true }</span>
it1.<span class="pl-c1">next</span>();             <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<h4><a id="user-content-early-abort" class="anchor" href="#early-abort" aria-hidden="true"><span class="octicon octicon-link"></span></a>Early Abort</h4>

<p>Instead of calling <code>return(..)</code>, you can call <code>throw(..)</code>. Just like <code>return(x)</code> is essentially injecting a <code>return x</code> into the generator at its current pause point, calling <code>throw(x)</code> is essentially like injecting a <code>throw x</code> at the pause point.</p>

<p>Other than the exception behavior (we cover what that means to <code>try</code> clauses in the next section), <code>throw(..)</code> produces the same sort of early completion that aborts the generator's run at its current pause point. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;
    <span class="pl-k">yield</span> <span class="pl-c1">3</span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-k">try</span> {
    it.throw( <span class="pl-s"><span class="pl-pds">"</span>Oops!<span class="pl-pds">"</span></span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// Exception: Oops!</span>
}

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Because <code>throw(..)</code> basically injects a <code>throw ..</code> in replacement of the <code>yield 1</code> line of the generator, and nothing handles this exception, it immediately propagates back out to the calling code, which handles it with a <code>try..catch</code>.</p>

<p>Unlike <code>return(..)</code>, the iterator's <code>throw(..)</code> method is never called automatically.</p>

<p>Of course, though not shown in the previous snippet, if a <code>try..finally</code> clause was waiting inside the generator when you call <code>throw(..)</code>, the <code>finally</code> clause would be given a chance to complete before the exception is propagated back to the calling code.</p>

<h3><a id="user-content-error-handling" class="anchor" href="#error-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Handling</h3>

<p>As we've already hinted, error handling with generators can be expressed with <code>try..catch</code>, which works in both inbound and outbound directions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }

    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;

    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span>;
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 1, done: false }</span>

<span class="pl-k">try</span> {
    it.throw( <span class="pl-s"><span class="pl-pds">"</span>Hi!<span class="pl-pds">"</span></span> );  <span class="pl-c">// Hi!</span>
                        <span class="pl-c">// { value: 2, done: false }</span>
    it.<span class="pl-c1">next</span>();

    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( err ); <span class="pl-c">// Hello!</span>
}</pre></div>

<p>Errors can also propagate in both directions through <code>yield *</code> delegation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }

    <span class="pl-k">yield</span> <span class="pl-c1">2</span>;

    <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>foo: e2<span class="pl-pds">"</span></span>;
}

<span class="pl-k">function</span> <span class="pl-en">*bar</span>() {
    <span class="pl-k">try</span> {
        <span class="pl-k">yield</span> <span class="pl-k">*</span>foo();

        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
    }
    <span class="pl-k">catch</span> (err) {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( err );
    }
}

<span class="pl-k">var</span> it <span class="pl-k">=</span> bar();

<span class="pl-k">try</span> {
    it.<span class="pl-c1">next</span>();          <span class="pl-c">// { value: 1, done: false }</span>

    it.throw( <span class="pl-s"><span class="pl-pds">"</span>e1<span class="pl-pds">"</span></span> );   <span class="pl-c">// e1</span>
                        <span class="pl-c">// { value: 2, done: false }</span>

    it.<span class="pl-c1">next</span>();          <span class="pl-c">// foo: e2</span>
                        <span class="pl-c">// { value: undefined, done: true }</span>
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>never gets here<span class="pl-pds">"</span></span> );
}

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>When <code>*foo()</code> calls <code>yield 1</code>, the <code>1</code> value passes through <code>*bar()</code> untouched, as we've already seen.</p>

<p>But what's most interesting about this snippet is that when <code>*foo()</code> calls <code>throw "foo: e2"</code>, this error propagates to <code>*bar()</code> and is immediately caught by <code>*bar()</code>'s <code>try..catch</code> block. The error doesn't pass through <code>*bar()</code> like the <code>1</code> value did.</p>

<p><code>*bar()</code>'s <code>catch</code> then does a normal output of <code>err</code> (<code>"foo: e2"</code>) and then <code>*bar()</code> finishes normally, which is why the <code>{ value: undefined, done: true }</code> iterator result comes back from <code>it.next()</code>.</p>

<p>If <code>*bar()</code> didn't have a <code>try..catch</code> around the <code>yield *..</code> expression, the error would of course propagate all the way out, and on the way through it still would complete (abort) <code>*bar()</code>.</p>

<h3><a id="user-content-transpiling-a-generator" class="anchor" href="#transpiling-a-generator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transpiling a Generator</h3>

<p>Is it possible to represent a generator's capabilities prior to ES6? It turns out it is, and there are several great tools that do so, including most notably Facebook's Regenerator tool (<a href="https://facebook.github.io/regenerator/">https://facebook.github.io/regenerator/</a>).</p>

<p>But just to better understand generators, let's try our hand at manually converting. Basically, we're going to create a simple closure-based state machine.</p>

<p>We'll keep our source generator really simple:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*foo</span>() {
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">yield</span> <span class="pl-c1">42</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );
}</pre></div>

<p>To start, we'll need a function called <code>foo()</code> that we can execute, which needs to return an iterator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>

    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-c">// ..</span>
        }

        <span class="pl-c">// we'll skip `return(..)` and `throw(..)`</span>
    };
}</pre></div>

<p>Now, we need some inner variable to keep track of where we are in the steps of our "generator"'s logic. We'll call it <code>state</code>. There will be three states: <code>0</code> initially, <code>1</code> while waiting to fulfill the <code>yield</code> expression, and <code>2</code> once the generator is complete.</p>

<p>Each time <code>next(..)</code> is called, we need to process the next step, and then increment <code>state</code>. For convenience, we'll put each step into a <code>case</code> clause of a <code>switch</code> statement, and we'll hold that in an inner function called <code>nextState(..)</code> that <code>next(..)</code> can call. Also, because <code>x</code> is a variable across the overall scope of the "generator," it needs to live outside the <code>nextState(..)</code> function.</p>

<p>Here it is all together (obviously somewhat simplified, to keep the conceptual illustration clearer):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">function</span> <span class="pl-en">nextState</span>(<span class="pl-smi">v</span>) {
        <span class="pl-k">switch</span> (state) {
            <span class="pl-k">case</span> <span class="pl-c1">0</span><span class="pl-k">:</span>
                state<span class="pl-k">++</span>;

                <span class="pl-c">// the `yield` expression</span>
                <span class="pl-k">return</span> <span class="pl-c1">42</span>;
            <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
                state<span class="pl-k">++</span>;

                <span class="pl-c">// `yield` expression fulfilled</span>
                x <span class="pl-k">=</span> v;
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( x );

                <span class="pl-c">// the implicit `return`</span>
                <span class="pl-k">return</span> <span class="pl-c1">undefined</span>;

            <span class="pl-c">// no need to handle state `2`</span>
        }
    }

    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-c1">0</span>, x;

    <span class="pl-k">return</span> {
        <span class="pl-en">next</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">v</span>) {
            <span class="pl-k">var</span> ret <span class="pl-k">=</span> nextState( v );

            <span class="pl-k">return</span> { value<span class="pl-k">:</span> ret, done<span class="pl-k">:</span> (state <span class="pl-k">==</span> <span class="pl-c1">2</span>) };
        }

        <span class="pl-c">// we'll skip `return(..)` and `throw(..)`</span>
    };
}</pre></div>

<p>And finally, let's test our pre-ES6 "generator":</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> it <span class="pl-k">=</span> foo();

it.<span class="pl-c1">next</span>();              <span class="pl-c">// { value: 42, done: false }</span>

it.<span class="pl-c1">next</span>( <span class="pl-c1">10</span> );          <span class="pl-c">// 10</span>
                        <span class="pl-c">// { value: undefined, done: true }</span></pre></div>

<p>Not bad, huh? Hopefully this exercise solidifies in your mind that generators are actually just simple syntax for state machine logic. That makes them widely applicable.</p>

<h3><a id="user-content-generator-uses" class="anchor" href="#generator-uses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Uses</h3>

<p>So, now that we much more deeply understand how generators work, what are they useful for?</p>

<p>We've seen two major patterns:</p>

<ul>
<li><p><em>Producing a series of values:</em> This usage can be simple (e.g., random strings or incremented numbers), or it can represent more structured data access (e.g., iterating over rows returned from a database query).</p>

<p>Either way, we use the iterator to control a generator so that some logic can be invoked for each call to <code>next(..)</code>. Normal iterators on data structures merely pull values without any controlling logic.</p></li>
<li><p><em>Queue of tasks to perform serially:</em> This usage often represents flow control for the steps in an algorithm, where each step requires retrieval of data from some external source. The fulfillment of each piece of data may be immediate, or may be asynchronously delayed.</p>

<p>From the perspective of the code inside the generator, the details of sync or async at a <code>yield</code> point are entirely opaque. Moreover, these details are intentionally abstracted away, such as not to obscure the natural sequential expression of steps with such implementation complications. Abstraction also means the implementations can be swapped/refactored often without touching the code in the generator at all.</p></li>
</ul>

<p>When generators are viewed in light of these uses, they become a lot more than just a different or nicer syntax for a manual state machine. They are a powerful abstraction tool for organizing and controlling orderly production and consumption of data.</p>

<h2><a id="user-content-modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h2>

<p>I don't think it's an exaggeration to suggest that the single most important code organization pattern in all of JavaScript is, and always has been, the module. For myself, and I think for a large cross-section of the community, the module pattern drives the vast majority of code.</p>

<h3><a id="user-content-the-old-way" class="anchor" href="#the-old-way" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Old Way</h3>

<p>The traditional module pattern is based on an outer function with inner variables and functions, and a returned "public API" with methods that have closure over the inner data and capabilities. It's often expressed like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Hello</span>(<span class="pl-smi">name</span>) {
    <span class="pl-k">function</span> <span class="pl-en">greeting</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// public API</span>
    <span class="pl-k">return</span> {
        greeting<span class="pl-k">:</span> greeting
    };
}

<span class="pl-k">var</span> me <span class="pl-k">=</span> Hello( <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span> );
me.greeting();          <span class="pl-c">// Hello Kyle!</span></pre></div>

<p>This <code>Hello(..)</code> module can produce multiple instances by being called subsequent times. Sometimes, a module is only called for as a singleton (i.e., it just needs one instance), in which case a slight variation on the previous snippet, using an IIFE, is common:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> me <span class="pl-k">=</span> (<span class="pl-k">function</span> <span class="pl-en">Hello</span>(<span class="pl-smi">name</span>){
    <span class="pl-k">function</span> <span class="pl-en">greeting</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span> );
    }

    <span class="pl-c">// public API</span>
    <span class="pl-k">return</span> {
        greeting<span class="pl-k">:</span> greeting
    };
})( <span class="pl-s"><span class="pl-pds">"</span>Kyle<span class="pl-pds">"</span></span> );

me.greeting();          <span class="pl-c">// Hello Kyle!</span></pre></div>

<p>This pattern is tried and tested. It's also flexible enough to have a wide assortment of variations for a number of different scenarios.</p>

<p>One of the most common is the Asynchronous Module Definition (AMD), and another is the Universal Module Definition (UMD). We won't cover the particulars of these patterns and techniques here, but they're explained extensively in many places online.</p>

<h3><a id="user-content-moving-forward" class="anchor" href="#moving-forward" aria-hidden="true"><span class="octicon octicon-link"></span></a>Moving Forward</h3>

<p>As of ES6, we no longer need to rely on the enclosing function and closure to provide us with module support. ES6 modules have first class syntactic and functional support.</p>

<p>Before we get into the specific syntax, it's important to understand some fairly significant conceptual differences with ES6 modules compared to how you may have dealt with modules in the past:</p>

<ul>
<li><p>ES6 uses file-based modules, meaning one module per file. At this time, there is no standardized way of combining multiple modules into a single file.</p>

<p>That means that if you are going to load ES6 modules directly into a browser web application, you will be loading them individually, not as a large bundle in a single file as has been common in performance optimization efforts.</p>

<p>It's expected that the contemporaneous advent of HTTP/2 will significantly mitigate any such performance concerns, as it operates on a persistent socket connection and thus can very efficiently load many smaller files in parallel and interleaved with one another.</p></li>
<li><p>The API of an ES6 module is static. That is, you define statically what all the top-level exports are on your module's public API, and those cannot be amended later.</p>

<p>Some uses are accustomed to being able to provide dynamic API definitions, where methods can be added/removed/replaced in response to runtime conditions. Either these uses will have to change to fit with ES6 static APIs, or they will have to restrain the dynamic changes to properties/methods of a second-level object.</p></li>
<li>ES6 modules are singletons. That is, there's only one instance of the module, which maintains its state. Every time you import that module into another module, you get a reference to the one centralized instance. If you want to be able to produce multiple module instances, your module will need to provide some sort of factory to do it.</li>
<li><p>The properties and methods you expose on a module's public API are not just normal assignments of values or references. They are actual bindings (almost like pointers) to the identifiers in your inner module definition.</p>

<p>In pre-ES6 modules, if you put a property on your public API that holds a primitive value like a number or string, that property assignment was by value-copy, and any internal update of a corresponding variable would be separate and not affect the public copy on the API object.</p>

<p>With ES6, exporting a local private variable, even if it currently holds a primitive string/number/etc, exports a binding to the variable. If the module changes the  variable's value, the external import binding now resolves to that new value.</p></li>
<li><p>Importing a module is the same thing as statically requesting it to load (if it hasn't already). If you're in a browser, that implies a blocking load over the network. If you're on a server (i.e., Node.js), it's a blocking load from the filesystem.</p>

<p>However, don't panic about the performance implications. Because ES6 modules have static definitions, the import requirements can be statically scanned, and loads will happen preemptively, even before you've used the module.</p>

<p>ES6 doesn't actually specify or handle the mechanics of how these load requests work. There's a separate notion of a Module Loader, where each hosting environment (browser, Node.js, etc.) provides a default Loader appropriate to the environment. The importing of a module uses a string value to represent where to get the module (URL, file path, etc.), but this value is opaque in your program and only meaningful to the Loader itself.</p>

<p>You can define your own custom Loader if you want more fine-grained control than the default Loader affords -- which is basically none, as it's totally hidden from your program's code.</p></li>
</ul>

<p>As you can see, ES6 modules will serve the overall use case of organizing code with encapsulation, controlling public APIs, and referencing dependency imports. But they have a very particular way of doing so, and that may or may not fit very closely with how you've already been doing modules for years.</p>

<h4><a id="user-content-commonjs" class="anchor" href="#commonjs" aria-hidden="true"><span class="octicon octicon-link"></span></a>CommonJS</h4>

<p>There's a similar, but not fully compatible, module syntax called CommonJS, which is familiar to those in the Node.js ecosystem.</p>

<p>For lack of a more tactful way to say this, in the long run, ES6 modules essentially are bound to supercede all previous formats and standards for modules, even CommonJS, as they are built on syntactic support in the language. This will, in time, inevitably win out as the superior approach, if for no other reason than ubiquity.</p>

<p>We face a fairly long road to get to that point, though. There are literally hundreds of thousands of CommonJS style modules in the server-side JavaScript world, and 10 times that many modules of varying format standards (UMD, AMD, ad hoc) in the browser world. It will take many years for the transitions to make any significant progress.</p>

<p>In the interim, module transpilers/converters will be an absolute necessity. You might as well just get used to that new reality. Whether you author in regular modules, AMD, UMD, CommonJS, or ES6, these tools will have to parse and convert to a format that is suitable for whatever environment your code will run in.</p>

<p>For Node.js, that probably means (for now) that the target is CommonJS. For the browser, it's probably UMD or AMD. Expect lots of flux on this over the next few years as these tools mature and best practices emerge.</p>

<p>From here on out, my best advice on modules is this: whatever format you've been religiously attached to with strong affinity, also develop an appreciation for and understanding of ES6 modules, such as they are, and let your other module tendencies fade. They <em>are</em> the future of modules in JS, even if that reality is a bit of a ways off.</p>

<h3><a id="user-content-the-new-way" class="anchor" href="#the-new-way" aria-hidden="true"><span class="octicon octicon-link"></span></a>The New Way</h3>

<p>The two main new keywords that enable ES6 classes are <code>import</code> and <code>export</code>. There's lots of nuance to the syntax, so let's take a deeper look.</p>

<p><strong>Warning:</strong> An important detail that's easy to overlook: both <code>import</code> and <code>export</code> must always appear in the top-level scope of their respective usage. For example, you cannot put either an <code>import</code> or <code>export</code> inside an <code>if</code> conditional; they must appear outside of all blocks and functions.</p>

<h4><a id="user-content-exporting-api-members" class="anchor" href="#exporting-api-members" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>export</code>ing API Members</h4>

<p>The <code>export</code> keyword is either put in front of a declaration, or used as an operator (of sorts) with a special list of bindings to export. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> <span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-k">var</span> bar <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];
<span class="pl-k">export</span> { bar };</pre></div>

<p>Another way of expressing the same exports:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">var</span> bar <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

<span class="pl-k">export</span> { foo, awesome, bar };</pre></div>

<p>These are all called <em>named exports</em>, as you are in effect exporting the name bindings of the variables/functions/etc.</p>

<p>Anything you don't <em>label</em> with <code>export</code> stays private inside the scope of the module. That is, although something like <code>var bar = ..</code> looks like it's declaring at the top-level global scope, the top-level scope is actually the module itself; there is no global scope in modules.</p>

<p><strong>Note:</strong> Modules <em>do</em> still have access to <code>window</code> and all the "globals" that hang off it, just not as lexical top-level scope. However, you really should stay away from the globals in your modules if at all possible.</p>

<p>You can also "rename" (aka alias) a module member during named export:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> { foo as bar };</pre></div>

<p>When this module is imported, only the <code>bar</code> member name is available to import; <code>foo</code> stays hidden inside the module.</p>

<p>Module exports are not just normal assignments of values or references, as you're accustomed to with the <code>=</code> assignment operator. Actually, when you export something, you're exporting a binding (kinda like a pointer) to that thing (variable, etc.).</p>

<p>Within your module, if you change the value of a variable you already exported a binding to, even if it's already been imported (see the next section), the imported binding will resolve to the current (updated) value.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> awesome <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> { awesome };

<span class="pl-c">// later</span>
awesome <span class="pl-k">=</span> <span class="pl-c1">100</span>;</pre></div>

<p>When this module is imported, regardless of whether that's before or after the <code>awesome = 100</code> setting, once that assignment has happened, the imported binding resolves to the <code>100</code> value, not <code>42</code>.</p>

<p>That's because the binding is, in essence, a reference to, or a pointer to, the <code>awesome</code> variable itself, rather than a copy of its value. This is a mostly unprecedented concept for JS introduced with ES6 module bindings.</p>

<p>Though you can clearly use <code>export</code> multiple times inside a module's definition, ES6 definitely prefers the approach that a module has a single export, which is known as a <em>default export</em>. In the words of some members of the TC39 committee, you're "rewarded with simpler <code>import</code> syntax" if you follow that pattern, and conversely "penalized" with more verbose syntax if you don't.</p>

<p>A default export sets a particular exported binding to be the default when importing the module. The name of the binding is literally <code>default</code>. As you'll see later, when importing module bindings you can also rename them, as you commonly will with a default export.</p>

<p>There can only be one <code>default</code> per module definition. We'll cover <code>import</code> in the next section, and you'll see how the <code>import</code> syntax is more concise if the module has a default export.</p>

<p>There's a subtle nuance to default export syntax that you should pay close attention to. Compare these two snippets:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> <span class="pl-k">default</span> foo;</pre></div>

<p>And this one:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };</pre></div>

<p>In the first snippet, you are exporting a binding to the function expression value at that moment, <em>not</em> to the identifier <code>foo</code>. In other words, <code>export default ..</code> takes an expression. If you later assign <code>foo</code> to a different value inside your module, the module import still reveals the function originally exported, not the new value.</p>

<p>By the way, the first snippet could also have been written as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}</pre></div>

<p><strong>Warning:</strong> Although the <code>function foo..</code> part here is technically a function expression, for the purposes of the internal scope of the module, it's treated like a function declaration, in that the <code>foo</code> name is bound in the module's top-level scope (often called "hoisting"). The same is true for <code>export default class Foo..</code>. However, while you <em>can</em> do <code>export var foo = ..</code>, you currently cannot do <code>export default var foo = ..</code> (or <code>let</code> or <code>const</code>), in a frustrating case of inconsistency. At the time of this writing, there's already discussion of adding that capability in soon, post-ES6, for consistency sake.</p>

<p>Recall the second snippet again:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(..) {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };</pre></div>

<p>In this version of the module export, the default export binding is actually to the <code>foo</code> identifier rather than its value, so you get the previously described binding behavior (i.e., if you later change <code>foo</code>'s value, the value seen on the import side will also be updated).</p>

<p>Be very careful of this subtle gotcha in default export syntax, especially if your logic calls for export values to be updated. If you never plan to update a default export's value, <code>export default ..</code> is fine. If you do plan to update the value, you must use <code>export { .. as default }</code>. Either way, make sure to comment your code to explain your intent!</p>

<p>Because there can only be one <code>default</code> per module, you may be tempted to design your module with one default export of an object with all your API methods on it, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> {
    <span class="pl-en">foo</span>() { .. },
    <span class="pl-en">bar</span>() { .. },
    ..
};</pre></div>

<p>That pattern seems to map closely to how a lot of developers have already structured their pre-ES6 modules, so it seems like a natural approach. Unfortunately, it has some downsides and is officially discouraged.</p>

<p>In particular, the JS engine cannot statically analyze the contents of a plain object, which means it cannot do some optimizations for static <code>import</code> performance. The advantage of having each member individually and explicitly exported is that the engine <em>can</em> do the static analysis and optimization.</p>

<p>If your API has more than one member already, it seems like these principles -- one default export per module, and all API members as named exports -- are in conflict, doesn't it? But you <em>can</em> have a single default export as well as other named exports; they are not mutually exclusive.</p>

<p>So, instead of this (discouraged) pattern:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-c1">foo</span>.<span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() { .. };
<span class="pl-c1">foo</span>.<span class="pl-en">baz</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() { .. };</pre></div>

<p>You can do:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p><strong>Note:</strong> In this previous snippet, I used the name <code>foo</code> for the function that <code>default</code> labels. That <code>foo</code> name, however, is ignored for the purposes of export -- <code>default</code> is actually the exported name. When you import this default binding, you can give it whatever name you want, as you'll see in the next section.</p>

<p>Alternatively, some will prefer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }

<span class="pl-k">export</span> { foo as <span class="pl-k">default</span>, bar, baz, .. };</pre></div>

<p>The effects of mixing default and named exports will be more clear when we cover <code>import</code> shortly. But essentially it means that the most concise default import form would only retrieve the <code>foo()</code> function. The user could additionally manually list <code>bar</code> and <code>baz</code> as named imports, if they want them.</p>

<p>You can probably imagine how tedious that's going to be for consumers of your module if you have lots of named export bindings. There is a wildcard import form where you import all of a module's exports within a single namespace object, but there's no way to wildcard import to top-level bindings.</p>

<p>Again, the ES6 module mechanism is intentionally designed to discourage modules with lots of exports; relatively speaking, it's desired that such approaches be a little more difficult, as a sort of social engineering to encourage simple module design in favor of large/complex module design.</p>

<p>I would probably recommend you not mix default export with named exports, especially if you have a large API and refactoring to separate modules isn't practical or desired. In that case, just use all named exports, and document that consumers of your module should probably use the <code>import * as ..</code> (namespace import, discussed in the next section) approach to bring the whole API in at once on a single namespace.</p>

<p>We mentioned this earlier, but let's come back to it in more detail. Other than the <code>export default ...</code> form that exports an expression value binding, all other export forms are exporting bindings to local identifiers. For those bindings, if you change the value of a variable inside a module after exporting, the external imported binding will access the updated value:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> { foo as <span class="pl-k">default</span> };

<span class="pl-k">export</span> <span class="pl-k">var</span> bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;

foo <span class="pl-k">=</span> <span class="pl-c1">10</span>;
bar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;</pre></div>

<p>When you import this module, the <code>default</code> and <code>bar</code> exports will be bound to the local variables <code>foo</code> and <code>bar</code>, meaning they will reveal the updated <code>10</code> and <code>"cool"</code> values. The values at time of export are irrelevant. The values at time of import are irrelevant. The bindings are live links, so all that matters is what the current value is when you access the binding.</p>

<p><strong>Warning:</strong> Two-way bindings are not allowed. If you import a <code>foo</code> from a module, and try to change the value of your imported <code>foo</code> variable, an error will be thrown! We'll revisit that in the next section.</p>

<p>You can also re-export another module's exports, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> { foo, bar } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;
<span class="pl-k">export</span> { foo as <span class="pl-c1">FOO</span>, bar as <span class="pl-c1">BAR</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;
<span class="pl-k">export</span> <span class="pl-k">*</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>;</pre></div>

<p>Those forms are similar to just first importing from the <code>"baz"</code> module then listing its members explicitly for export from your module. However, in these forms, the members of the <code>"baz"</code> module are never imported to your module's local scope; they sort of pass through untouched.</p>

<h4><a id="user-content-importing-api-members" class="anchor" href="#importing-api-members" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>import</code>ing API Members</h4>

<p>To import a module, unsurprisingly you use the <code>import</code> statement. Just as <code>export</code> has several nuanced variations, so does <code>import</code>, so spend plenty of time considering the following issues and experimenting with your options.</p>

<p>If you want to import certain specific named members of a module's API into your top-level scope, you use this syntax:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo, bar, baz } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><strong>Warning:</strong> The <code>{ .. }</code> syntax here may look like an object literal, or even an object destructuring syntax. However, its form is special just for modules, so be careful not to confuse it with other <code>{ .. }</code> patterns elsewhere.</p>

<p>The <code>"foo"</code> string is called a <em>module specifier</em>. Because the whole goal is statically analyzable syntax, the module specifier must be a string literal; it cannot be a variable holding the string value.</p>

<p>From the perspective of your ES6 code and the JS engine itself, the contents of this string literal are completely opaque and meaningless. The module loader will interpret this string as an instruction of where to find the desired module, either as a URL path or a local filesystem path.</p>

<p>The <code>foo</code>, <code>bar</code>, and <code>baz</code> identifiers listed must match named exports on the module's API (static analysis and error assertion apply). They are bound as top-level identifiers in your current scope:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

foo();</pre></div>

<p>You can rename the bound identifiers imported, as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> { foo <span class="pl-k">as</span> theFooFunc } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

theFooFunc();</pre></div>

<p>If the module has just a default export that you want to import and bind to an identifier, you can opt to skip the <code>{ .. }</code> surrounding syntax for that binding. The <code>import</code> in this preferred case gets the nicest and most concise of the <code>import</code> syntax forms:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c">// or:</span>
<span class="pl-k">import</span> { default <span class="pl-k">as</span> foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><strong>Note:</strong> As explained in the previous section, the <code>default</code> keyword in a module's <code>export</code> specifies a named export where the name is actually <code>default</code>, as is illustrated by the second more verbose syntax option. The renaming from <code>default</code> to, in this case, <code>foo</code>, is explicit in the latter syntax and is identical yet implicit in the former syntax.</p>

<p>You can also import a default export along with other named exports, if the module has such a definition. Recall this module definition from earlier:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }

<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>To import that module's default export and its two named exports:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> FOOFN, { bar, baz <span class="pl-k">as</span> BAZ } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">FOOFN</span>();
bar();
<span class="pl-c1">BAZ</span>();</pre></div>

<p>The strongly suggested approach from ES6's module philosophy is that you only import the specific bindings from a module that you need. If a module provides 10 API methods, but you only need two of them, some believe it wasteful to bring in the entire set of API bindings.</p>

<p>One benefit, besides code being more explicit, is that narrow imports make static analysis and error detection (accidentally using the wrong binding name, for instance) more robust.</p>

<p>Of course, that's just the standard position influenced by ES6 design philosophy; there's nothing that requires adherence to that approach.</p>

<p>Many developers would be quick to point out that such approaches can be more tedious, requiring you to regularly revisit and update your <code>import</code> statement(s) each time you realize you need something else from a module. The trade-off is in exchange for convenience.</p>

<p>In that light, the preference might be to import everything from the module into a single namespace, rather than importing individual members, each directly into the scope. Fortunately, the <code>import</code> statement has a syntax variation that can support this style of module consumption, called <em>namespace import</em>.</p>

<p>Consider a <code>"foo"</code> module exported as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>You can import that entire API to a single module namespace binding:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> * <span class="pl-k">as</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

foo.bar();
foo.<span class="pl-c1">x</span>;          <span class="pl-c">// 42</span>
foo.baz();</pre></div>

<p><strong>Note:</strong> The <code>* as ..</code> clause requires the <code>*</code> wildcard. In other words, you cannot do something like <code>import { bar, x } as foo from "foo"</code> to bring in only part of the API but still bind to the <code>foo</code> namespace. I would have liked something like that, but for ES6 it's all or nothing with the namespace import.</p>

<p>If the module you're importing with <code>* as ..</code> has a default export, it is named <code>default</code> in the namespace specified. You can additionaly name the default import outside of the namespace binding, as a top-level identifier. Consider a <code>"world"</code> module exported as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>() { .. }
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() { .. }</pre></div>

<p>And this <code>import</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foofn, * <span class="pl-k">as</span> hello <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>;

foofn();
hello.default();
hello.bar();
hello.baz();</pre></div>

<p>While this syntax is valid, it can be rather confusing that one method of the module (the default export) is bound at the top-level of your scope, whereas the rest of the named exports (and one called <code>default</code>) are bound as properties on a differently named (<code>hello</code>) identifier namespace.</p>

<p>As I mentioned earlier, my suggestion would be to avoid designing your module exports in this way, to reduce the chances that your module's users will suffer these strange quirks.</p>

<p>All imported bindings are immutable and/or read-only. Consider the previous import; all of these subsequent assignment attempts will throw <code>TypeError</code>s:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foofn, * <span class="pl-k">as</span> hello <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>;

foofn <span class="pl-k">=</span> <span class="pl-c1">42</span>;         <span class="pl-c">// (runtime) TypeError!</span>
hello.default <span class="pl-k">=</span> <span class="pl-c1">42</span>; <span class="pl-c">// (runtime) TypeError!</span>
hello.bar <span class="pl-k">=</span> <span class="pl-c1">42</span>;     <span class="pl-c">// (runtime) TypeError!</span>
hello.baz <span class="pl-k">=</span> <span class="pl-c1">42</span>;     <span class="pl-c">// (runtime) TypeError!</span></pre></div>

<p>Recall earlier in the "<code>export</code>ing API Members" section that we talked about how the <code>bar</code> and <code>baz</code> bindings are bound to the actual identifiers inside the <code>"world"</code> module. That means if the module changes those values, <code>hello.bar</code> and <code>hello.baz</code> now reference the updated values.</p>

<p>But the immutable/read-only nature of your local imported bindings enforces that you cannot change them from the imported bindings, hence the <code>TypeError</code>s. That's pretty important, because without those protections, your changes would end up affecting all other consumers of the module (remember: singleton), which could create some very surprising side effects!</p>

<p>Moreover, though a module <em>can</em> change its API members from the inside, you should be very cautious of intentionally designing your modules in that fashion. ES6 modules are <em>intended</em> to be static, so deviations from that principle should be rare and should be carefully and verbosely documented.</p>

<p><strong>Warning:</strong> There are module design philosophies where you actually intend to let a consumer change the value of a property on your API, or module APIs are designed to be "extended" by having other "plug-ins" add to the API namespace. As we just asserted, ES6 module APIs should be thought of and designed as static and unchangeable, which strongly restricts and discourages these alternative module design patterns. You can get around these limitations by exporting a plain object, which of course can then be changed at will. But be careful and think twice before going down that road.</p>

<p>Declarations that occur as a result of an <code>import</code> are "hoisted" (see the <em>Scope &amp; Closures</em> title of this series). Consider:</p>

<div class="highlight highlight-source-js"><pre>foo();

<span class="pl-k">import</span> { foo } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p><code>foo()</code> can run because not only did the static resolution of the <code>import ..</code> statement figure out what <code>foo</code> is during compilation, but it also "hoisted" the declaration to the top of the module's scope, thus making it available throughout the module.</p>

<p>Finally, the most basic form of the <code>import</code> looks like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;</pre></div>

<p>This form does not actually import any of the module's bindings into your scope. It loads (if not already loaded), compiles (if not already compiled), and evaluates (if not already run) the <code>"foo"</code> module.</p>

<p>In general, that sort of import is probably not going to be terribly useful. There may be niche cases where a module's definition has side effects (such as assigning things to the <code>window</code>/global object). You could also envision using <code>import "foo"</code> as a sort of preload for a module that may be needed later.</p>

<h3><a id="user-content-circular-module-dependency" class="anchor" href="#circular-module-dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Circular Module Dependency</h3>

<p>A imports B. B imports A. How does this actually work?</p>

<p>I'll state off the bat that designing systems with intentional circular dependency is generally something I try to avoid. That having been said, I recognize there are reasons people do this and it can solve some sticky design situations.</p>

<p>Let's consider how ES6 handles this. First, module <code>"A"</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>;

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>) <span class="pl-k">return</span> bar( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}</pre></div>

<p>Now, module <code>"B"</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>;

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">y</span>) {
    <span class="pl-k">if</span> (y <span class="pl-k">&gt;</span> <span class="pl-c1">5</span>) <span class="pl-k">return</span> foo( y <span class="pl-k">/</span> <span class="pl-c1">2</span> );
    <span class="pl-k">return</span> y <span class="pl-k">*</span> <span class="pl-c1">3</span>;
}</pre></div>

<p>These two functions, <code>foo(..)</code> and <code>bar(..)</code>, would work as standard function declarations if they were in the same scope, because the declarations are "hoisted" to the whole scope and thus available to each other regardless of authoring order.</p>

<p>With modules, you have declarations in entirely different scopes, so ES6 has to do extra work to help make these circular references work.</p>

<p>In a rough conceptual sense, this is how circular <code>import</code> dependencies are validated and resolved:</p>

<ul>
<li>If the <code>"A"</code> module is loaded first, the first step is to scan the file and analyze all the exports, so it can register all those bindings available for import. Then it processes the <code>import .. from "B"</code>, which signals that it needs to go fetch <code>"B"</code>.</li>
<li>Once the engine loads <code>"B"</code>, it does the same analysis of its export bindings. When it sees the <code>import .. from "A"</code>, it knows the API of <code>"A"</code> already, so it can verify the <code>import</code> is valid. Now that it knows the <code>"B"</code> API, it can also validate the <code>import .. from "B"</code> in the waiting <code>"A"</code> module.</li>
</ul>

<p>In essence, the mutual imports, along with the static verification that's done to validate both <code>import</code> statements, virtually composes the two separate module scopes (via the bindings), such that <code>foo(..)</code> can call <code>bar(..)</code> and vice versa. This is symmetric to if they had originally been declared in the same scope.</p>

<p>Now let's try using the two modules together. First, we'll try <code>foo(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
foo( <span class="pl-c1">25</span> );              <span class="pl-c">// 11</span></pre></div>

<p>Or we can try <code>bar(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;
bar( <span class="pl-c1">25</span> );              <span class="pl-c">// 11.5</span></pre></div>

<p>By the time either the <code>foo(25)</code> or <code>bar(25)</code> calls are executed, all the analysis/compilation of all modules has completed. That means <code>foo(..)</code> internally knows directly about <code>bar(..)</code> and <code>bar(..)</code> internally knows directly about <code>foo(..)</code>.</p>

<p>If all we need is to interact with <code>foo(..)</code>, then we only need to import the <code>"foo"</code> module. Likewise with <code>bar(..)</code> and the <code>"bar"</code> module.</p>

<p>Of course, we <em>can</em> import and use both of them if we want to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
<span class="pl-k">import</span> bar <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

foo( <span class="pl-c1">25</span> );              <span class="pl-c">// 11</span>
bar( <span class="pl-c1">25</span> );              <span class="pl-c">// 11.5</span></pre></div>

<p>The static loading semantics of the <code>import</code> statement mean that a <code>"foo"</code> and <code>"bar"</code> that mutually depend on each other via <code>import</code> will ensure that both are loaded, parsed, and compiled before either of them runs. So their circular dependency is statically resolved and this works as you'd expect.</p>

<h3><a id="user-content-module-loading" class="anchor" href="#module-loading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Module Loading</h3>

<p>We asserted at the beginning of this "Modules" section that the <code>import</code> statement uses a separate mechanism, provided by the hosting environment (browser, Node.js, etc.), to actually resolve the module specifier string into some useful instruction for finding and loading the desired module. That mechanism is the system <em>Module Loader</em>.</p>

<p>The default module loader provided by the environment will interpret a module specifier as a URL if in the browser, and (generally) as a local filesystem path if on a server such as Node.js. The default behavior is to assume the loaded file is authored in the ES6 standard module format.</p>

<p>Moreover, you will be able to load a module into the browser via an HTML tag, similar to how current script programs are loaded. At the time of this writing, it's not fully clear if this tag will be <code>&lt;script type="module"&gt;</code> or <code>&lt;module&gt;</code>. ES6 doesn't control that decision, but discussions in the appropriate standards bodies are already well along in parallel of ES6.</p>

<p>Whatever the tag looks like, you can be sure that under the covers it will use the default loader (or a customized one you've pre-specified, as we'll discuss in the next section).</p>

<p>Just like the tag you'll use in markup, the module loader itself is not specified by ES6. It is a separate, parallel standard (<a href="http://whatwg.github.io/loader/">http://whatwg.github.io/loader/</a>) controlled currently by the WHATWG browser standards group.</p>

<p>At the time of this writing, the following discussions reflect an early pass at the API design, and things are likely to change.</p>

<h4><a id="user-content-loading-modules-outside-of-modules" class="anchor" href="#loading-modules-outside-of-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loading Modules Outside of Modules</h4>

<p>One use for interacting directly with the module loader is if a non-module needs to load a module. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// normal script loaded in browser via `&lt;script&gt;`,</span>
<span class="pl-c">// `import` is illegal here</span>

Reflect.Loader.import( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ) <span class="pl-c">// returns a promise for `"foo"`</span>
.then( <span class="pl-k">function</span>(<span class="pl-smi">foo</span>){
    foo.bar();
} );</pre></div>

<p>The <code>Reflect.Loader.import(..)</code> utility imports the entire module onto the named parameter (as a namespace), just like the <code>import * as foo ..</code> namespace import we discussed earlier.</p>

<p><strong>Note:</strong> The <code>Reflect.Loader.import(..)</code> utility returns a promise that is fulfilled once the module is ready. To import multiple modules, you can compose promises from multiple <code>Reflect.Loader.import(..)</code> calls using <code>Promise.all([ .. ])</code>. For more information about Promises, see "Promises" in Chapter 4.</p>

<p>You can also use <code>Reflect.Loader.import(..)</code> in a real module to dynamically/conditionally load a module, where <code>import</code> itself would not work. You might, for instance, choose to load a module containing a polyfill for some ES7+ feature if a feature test reveals it's not defined by the current engine.</p>

<p>For performance reasons, you'll want to avoid dynamic loading whenever possible, as it hampers the ability of the JS engine to fire off early fetches from its static analysis.</p>

<h4><a id="user-content-customized-loading" class="anchor" href="#customized-loading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Customized Loading</h4>

<p>Another use for directly interacting with the module loader is if you want to customize its behavior through configuration or even redefinition.</p>

<p>At the time of this writing, there's a polyfill for the module loader API being developed (<a href="https://github.com/ModuleLoader/es6-module-loader">https://github.com/ModuleLoader/es6-module-loader</a>). While details are scarce and highly subject to change, we can explore what possibilities may eventually land.</p>

<p>The <code>Reflect.Loader.import(..)</code> call may support a second argument for specifying various options to customize the import/load task. For example:</p>

<div class="highlight highlight-source-js"><pre>Reflect.Loader.import( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, { address<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>/path/to/foo.js<span class="pl-pds">"</span></span> } )
.then( <span class="pl-k">function</span>(<span class="pl-smi">foo</span>){
    <span class="pl-c">// ..</span>
} )</pre></div>

<p>It's also expected that a customization will be provided (through some means) for hooking into the process of loading a module, where a translation/transpilation could occur after load but before the engine compiles the module.</p>

<p>For example, you could load something that's not already an ES6-compliant module format (e.g., CoffeeScript, TypeScript, CommonJS, AMD). Your translation step could then convert it to an ES6-compliant module for the engine to then process.</p>

<h2><a id="user-content-classes" class="anchor" href="#classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Classes</h2>

<p>From nearly the beginning of JavaScript, syntax and development patterns have all strived (read: struggled) to put on a facade of supporting class-oriented development. With things like <code>new</code> and <code>instanceof</code> and a <code>.constructor</code> property, who couldn't help but be teased that JS had classes hidden somewhere inside its prototype system?</p>

<p>Of course, JS "classes" aren't nearly the same as classical classes. The differences are well documented, so I won't belabor that point any further here.</p>

<p><strong>Note:</strong> To learn more about the patterns used in JS to fake "classes," and an alternative view of prototypes called "delegation," see the second half of the <em>this &amp; Object Prototypes</em> title of this series.</p>

<h3><a id="user-content-class" class="anchor" href="#class" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>class</code></h3>

<p>Although JS's prototype mechanism doesn't work like traditional classes, that doesn't stop the strong tide of demand on the language to extend the syntactic sugar so that expressing "classes" looks more like real classes. Enter the ES6 <code>class</code> keyword and its associated mechanism.</p>

<p>This feature is the result of a highly contentious and drawn-out debate, and represents a smaller subset compromise from several strongly opposed views on how to approach JS classes. Most developers who want full classes in JS will find parts of the new syntax quite inviting, but will find important bits still missing. Don't worry, though. TC39 is already working on additional features to augment classes in the post-ES6 timeframe.</p>

<p>At the heart of the new ES6 class mechanism is the <code>class</code> keyword, which identifies a <em>block</em> where the contents define the members of a function's prototype. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
        <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">=</span> a;
        <span class="pl-v">this</span>.<span class="pl-c1">y</span> <span class="pl-k">=</span> b;
    }

    <span class="pl-en">gimmeXY</span>() {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">y</span>;
    }
}</pre></div>

<p>Some things to note:</p>

<ul>
<li><code>class Foo</code> implies creating a (special) function of the name <code>Foo</code>, much like you did pre-ES6.</li>
<li><code>constructor(..)</code> identifies the signature of that <code>Foo(..)</code> function, as well as its body contents.</li>
<li>Class methods use the same "concise method" syntax available to object literals, as discussed in Chapter 2. This also includes the concise generator form as discussed earlier in this chapter, as well as the ES5 getter/setter syntax. However, class methods are non-enumerable whereas object methods are by default enumerable.</li>
<li>Unlike object literals, there are no commas separating members in a <code>class</code> body! In fact, they're not even allowed.</li>
</ul>

<p>The <code>class</code> syntax definition in the previous snippet can be roughly thought of as this pre-ES6 equivalent, which probably will look fairly familiar to those who've done prototype-style coding before:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">=</span> a;
    <span class="pl-v">this</span>.<span class="pl-c1">y</span> <span class="pl-k">=</span> b;
}

<span class="pl-c1">Foo</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">gimmeXY</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">x</span> <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">y</span>;
}</pre></div>

<p>In either the pre-ES6 form or the new ES6 <code>class</code> form, this "class" can now be instantiated and used just as you'd expect:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> f <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-c1">5</span>, <span class="pl-c1">15</span> );

f.<span class="pl-c1">x</span>;                        <span class="pl-c">// 5</span>
f.<span class="pl-c1">y</span>;                        <span class="pl-c">// 15</span>
f.gimmeXY();                <span class="pl-c">// 75</span></pre></div>

<p>Caution! Though <code>class Foo</code> seems much like <code>function Foo()</code>, there are important differences:</p>

<ul>
<li>A <code>Foo(..)</code> call of <code>class Foo</code> <em>must</em> be made with <code>new</code>, as the pre-ES6 option of <code>Foo.call( obj )</code> will <em>not</em> work.</li>
<li>While <code>function Foo</code> is "hoisted" (see the <em>Scope &amp; Closures</em> title of this series), <code>class Foo</code> is not; the <code>extends ..</code> clause specifies an expression that cannot be "hoisted." So, you must declare a <code>class</code> before you can instantiate it.</li>
<li><code>class Foo</code> in the top global scope creates a lexical <code>Foo</code> identifier in that scope, but unlike <code>function Foo</code> does not create a global object property of that name.</li>
</ul>

<p>The established <code>instanceof</code> operator still works with ES6 classes, because <code>class</code> just creates a constructor function of the same name. However, ES6 introduces a way to customize how <code>instanceof</code> works, using <code>Symbol.hasInstance</code> (see "Well-Known Symbols" in Chapter 7).</p>

<p>Another way of thinking about <code>class</code>, which I find more convenient, is as a <em>macro</em> that is used to automatically populate a <code>prototype</code> object. Optionally, it also wires up the <code>[[Prototype]]</code> relationship if using <code>extends</code> (see the next section).</p>

<p>An ES6 <code>class</code> isn't really an entity itself, but a meta concept that wraps around other concrete entities, such as functions and properties, and ties them together.</p>

<p><strong>Tip:</strong> In addition to the declaration form, a <code>class</code> can also be an expression, as in: <code>var x = class Y { .. }</code>. This is primarily useful for passing a class definition (technically, the constructor itself) as a function argument or assigning it to an object property.</p>

<h3><a id="user-content-extends-and-super" class="anchor" href="#extends-and-super" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>extends</code> and <code>super</code></h3>

<p>ES6 classes also have syntactic sugar for establishing the <code>[[Prototype]]</code> delegation link between two function prototypes -- commonly mislabeled "inheritance" or confusingly labeled "prototype inheritance" -- using the class-oriented familiar terminology <code>extends</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>,<span class="pl-smi">c</span>) {
        <span class="pl-v">super</span>( a, b );
        <span class="pl-v">this</span>.<span class="pl-c1">z</span> <span class="pl-k">=</span> c;
    }

    <span class="pl-en">gimmeXYZ</span>() {
        <span class="pl-k">return</span> <span class="pl-v">super</span>.gimmeXY() <span class="pl-k">*</span> <span class="pl-v">this</span>.<span class="pl-c1">z</span>;
    }
}

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>( <span class="pl-c1">5</span>, <span class="pl-c1">15</span>, <span class="pl-c1">25</span> );

b.<span class="pl-c1">x</span>;                        <span class="pl-c">// 5</span>
b.<span class="pl-c1">y</span>;                        <span class="pl-c">// 15</span>
b.<span class="pl-c1">z</span>;                        <span class="pl-c">// 25</span>
b.gimmeXYZ();               <span class="pl-c">// 1875</span></pre></div>

<p>A significant new addition is <code>super</code>, which is actually something not directly possible pre-ES6 (without some unfortunate hack trade-offs). In the constructor, <code>super</code> automatically refers to the "parent constructor," which in the previous example is <code>Foo(..)</code>. In a method, it refers to the "parent object," such that you can then make a property/method access off it, such as <code>super.gimmeXY()</code>.</p>

<p><code>Bar extends Foo</code> of course means to link the <code>[[Prototype]]</code> of <code>Bar.prototype</code> to <code>Foo.prototype</code>. So, <code>super</code> in a method like <code>gimmeXYZ()</code> specifically means <code>Foo.prototype</code>, whereas <code>super</code> means <code>Foo</code> when used in the <code>Bar</code> constructor.</p>

<p><strong>Note:</strong> <code>super</code> is not limited to <code>class</code> declarations. It also works in object literals, in much the same way we're discussing here. See "Object <code>super</code>" in Chapter 2 for more information.</p>

<h4><a id="user-content-there-be-super-dragons" class="anchor" href="#there-be-super-dragons" aria-hidden="true"><span class="octicon octicon-link"></span></a>There Be <code>super</code> Dragons</h4>

<p>It is not insignificant to note that <code>super</code> behaves differently depending on where it appears. In fairness, most of the time, that won't be a problem. But surprises await if you deviate from a narrow norm.</p>

<p>There may be cases where in the constructor you would want to reference the <code>Foo.prototype</code>, such as to directly access one of its properties/methods. However, <code>super</code> in the constructor cannot be used in that way; <code>super.prototype</code> will not work. <code>super(..)</code> means roughly to call <code>new Foo(..)</code>, but isn't actually a usable reference to <code>Foo</code> itself.</p>

<p>Symmetrically, you may want to reference the <code>Foo(..)</code> function from inside a non-constructor method. <code>super.constructor</code> will point at <code>Foo(..)</code> the function, but beware that this function can <em>only</em> be invoked with <code>new</code>. <code>new super.constructor(..)</code> would be valid, but it wouldn't be terribly useful in most cases, because you can't make that call use or reference the current <code>this</code> object context, which is likely what you'd want.</p>

<p>Also, <code>super</code> looks like it might be driven by a function's context just like <code>this</code> -- that is, that they'd both be dynamically bound. However, <code>super</code> is not dynamic like <code>this</code> is. When a constructor or method makes a <code>super</code> reference inside it at declaration time (in the <code>class</code> body), that <code>super</code> is statically bound to that specific class hierarchy, and cannot be overridden (at least in ES6).</p>

<p>What does that mean? It means that if you're in the habit of taking a method from one "class" and "borrowing" it for another class by overriding its <code>this</code>, say with <code>call(..)</code> or <code>apply(..)</code>, that may very well create surprises if the method you're borrowing has a <code>super</code> in it. Consider this class hierarchy:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">ParentA</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>; }
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ParentA:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">ParentB</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.<span class="pl-c1">id</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>; }
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ParentB:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">ChildA</span> <span class="pl-k">extends</span> <span class="pl-en">ParentA</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ChildA:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
    }
}

<span class="pl-k">class</span> <span class="pl-en">ChildB</span> <span class="pl-k">extends</span> <span class="pl-en">ParentB</span> {
    <span class="pl-en">foo</span>() {
        <span class="pl-v">super</span>.foo();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>ChildB:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">id</span> );
    }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ChildA</span>();
a.foo();                    <span class="pl-c">// ParentA: a</span>
                            <span class="pl-c">// ChildA: a</span>
<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ChildB</span>();       <span class="pl-c">// ParentB: b</span>
b.foo();                    <span class="pl-c">// ChildB: b</span></pre></div>

<p>All seems fairly natural and expected in this previous snippet. However, if you try to borrow <code>b.foo()</code> and use it in the context of <code>a</code> -- by virtue of dynamic <code>this</code> binding, such borrowing is quite common and used in many different ways, including mixins most notably -- you may find this result an ugly surprise:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// borrow `b.foo()` to use in `a` context</span>
b.foo.<span class="pl-c1">call</span>( a );            <span class="pl-c">// ParentB: a</span>
                            <span class="pl-c">// ChildB: a</span></pre></div>

<p>As you can see, the <code>this.id</code> reference was dynamically rebound so that <code>: a</code> is reported in both cases instead of <code>: b</code>. But <code>b.foo()</code>'s <code>super.foo()</code> reference wasn't dynamically rebound, so it still reported <code>ParentB</code> instead of the expected <code>ParentA</code>.</p>

<p>Because <code>b.foo()</code> references <code>super</code>, it is statically bound to the <code>ChildB</code>/<code>ParentB</code> hierarchy and cannot be used against the <code>ChildA</code>/<code>ParentA</code> hierarchy. There is no ES6 solution to this limitation.</p>

<p><code>super</code> seems to work intuitively if you have a static class hierarchy with no cross-pollination. But in all fairness, one of the main benefits of doing <code>this</code>-aware coding is exactly that sort of flexibility. Simply, <code>class</code> + <code>super</code> requires you to avoid such techniques.</p>

<p>The choice boils down to narrowing your object design to these static hierarchies -- <code>class</code>, <code>extends</code>, and <code>super</code> will be quite nice -- or dropping all attempts to "fake" classes and instead embrace dynamic and flexible, classless objects and <code>[[Prototype]]</code> delegation (see the <em>this &amp; Object Prototypes</em> title of this series).</p>

<h4><a id="user-content-subclass-constructor" class="anchor" href="#subclass-constructor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subclass Constructor</h4>

<p>Constructors are not required for classes or subclasses; a default constructor is substituted in both cases if omitted. However, the default substituted constructor is different for a direct class versus an extended class.</p>

<p>Specifically, the default subclass constructor automatically calls the parent constructor, and passes along any arguments. In other words, you could think of the default subclass constructor sort of like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-en">constructor</span>(...<span class="pl-smi">args</span>) {
    <span class="pl-v">super</span>(...args);
}</pre></div>

<p>This is an important detail to note. Not all class languages have the subclass constructor automatically call the parent constructor. C++ does, but Java does not. But more importantly, in pre-ES6 classes, such automatic "parent constructor" calling does not happen. Be careful when converting to ES6 <code>class</code> if you've been relying on such calls <em>not</em> happening.</p>

<p>Another perhaps surprising deviation/limitation of ES6 subclass constructors: in a constructor of a subclass, you cannot access <code>this</code> until <code>super(..)</code> has been called. The reason is nuanced and complicated, but it boils down to the fact that the parent constructor is actually the one creating/initializing your instance's <code>this</code>. Pre-ES6, it works oppositely; the <code>this</code> object is created by the "subclass constructor," and then you  call a "parent constructor" with the context of the "subclass" <code>this</code>.</p>

<p>Let's illustrate. This works pre-ES6:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {
    <span class="pl-v">this</span>.a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">function</span> <span class="pl-en">Bar</span>() {
    <span class="pl-v">this</span>.b <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    Foo.<span class="pl-c1">call</span>( <span class="pl-v">this</span> );
}

<span class="pl-c">// `Bar` "extends" `Foo`</span>
<span class="pl-c1">Bar</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( Foo.<span class="pl-c1">prototype</span> );</pre></div>

<p>But this ES6 equivalent is not allowed:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() { <span class="pl-v">this</span>.a <span class="pl-k">=</span> <span class="pl-c1">1</span>; }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-v">this</span>.b <span class="pl-k">=</span> <span class="pl-c1">2</span>;         <span class="pl-c">// not allowed before `super()`</span>
        <span class="pl-v">super</span>();            <span class="pl-c">// to fix swap these two statements</span>
    }
}</pre></div>

<p>In this case, the fix is simple. Just swap the two statements in the subclass <code>Bar</code> constructor. However, if you've been relying pre-ES6 on being able to skip calling the "parent constructor," beware because that won't be allowed anymore.</p>

<h4><a id="user-content-extending-natives" class="anchor" href="#extending-natives" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>extend</code>ing Natives</h4>

<p>One of the most heralded benefits to the new <code>class</code> and <code>extend</code> design is the ability to (finally!) subclass the built-in natives, like <code>Array</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-en">first</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>[<span class="pl-c1">0</span>]; }
    <span class="pl-en">last</span>() { <span class="pl-k">return</span> <span class="pl-v">this</span>[<span class="pl-v">this</span>.<span class="pl-c1">length</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>]; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

a.<span class="pl-c1">length</span>;                   <span class="pl-c">// 3</span>
a;                          <span class="pl-c">// [1,2,3]</span>

a.first();                  <span class="pl-c">// 1</span>
a.last();                   <span class="pl-c">// 3</span></pre></div>

<p>Prior to ES6, a fake "subclass" of <code>Array</code> using manual object creation and linking to <code>Array.prototype</code> only partially worked. It missed out on the special behaviors of a real array, such as the automatically updating <code>length</code> property. ES6 subclasses should fully work with "inherited" and augmented behaviors as expected!</p>

<p>Another common pre-ES6 "subclass" limitation is with the <code>Error</code> object, in creating custom error "subclasses." When genuine <code>Error</code> objects are created, they automatically capture special <code>stack</code> information, including the line number and file where the error is created. Pre-ES6 custom error "subclasses" have no such special behavior, which severely limits their usefulness.</p>

<p>ES6 to the rescue:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Oops</span> <span class="pl-k">extends</span> <span class="pl-en">Error</span> {
    <span class="pl-en">constructor</span>(<span class="pl-smi">reason</span>) {
        <span class="pl-v">this</span>.oops <span class="pl-k">=</span> reason;
    }
}

<span class="pl-c">// later:</span>
<span class="pl-k">var</span> ouch <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Oops</span>( <span class="pl-s"><span class="pl-pds">"</span>I messed up!<span class="pl-pds">"</span></span> );
<span class="pl-k">throw</span> ouch;</pre></div>

<p>The <code>ouch</code> custom error object in this previous snippet will behave like any other genuine error object, including capturing <code>stack</code>. That's a big improvement!</p>

<h3><a id="user-content-newtarget" class="anchor" href="#newtarget" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>new.target</code></h3>

<p>ES6 introduces a new concept called a <em>meta property</em> (see Chapter 7), in the form of <code>new.target</code>.</p>

<p>If that looks strange, it is; pairing a keyword with a <code>.</code> and a property name is definitely an out-of-the-ordinary pattern for JS.</p>

<p><code>new.target</code> is a new "magical" value available in all functions, though in normal functions it will always be <code>undefined</code>. In any constructor, <code>new.target</code> always points at the constructor that <code>new</code> actually directly invoked, even if the constructor is in a parent class and was delegated to by a <code>super(..)</code> call from a child constructor. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Foo: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span>.<span class="pl-c1">name</span> );
    }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-v">super</span>();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Bar: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span>.<span class="pl-c1">name</span> );
    }
    <span class="pl-en">baz</span>() {
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>baz: <span class="pl-pds">"</span></span>, <span class="pl-k">new</span>.<span class="pl-c1">target</span> );
    }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
<span class="pl-c">// Foo: Foo</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
<span class="pl-c">// Foo: Bar   &lt;-- respects the `new` call-site</span>
<span class="pl-c">// Bar: Bar</span>

b.baz();
<span class="pl-c">// baz: undefined</span></pre></div>

<p>The <code>new.target</code> meta property doesn't have much purpose in class constructors, except accessing a static property/method (see the next section).</p>

<p>If <code>new.target</code> is <code>undefined</code>, you know the function was not called with <code>new</code>. You can then force a <code>new</code> invocation if that's necessary.</p>

<h3><a id="user-content-static" class="anchor" href="#static" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>static</code></h3>

<p>When a subclass <code>Bar</code> extends a parent class <code>Foo</code>, we already observed that <code>Bar.prototype</code> is <code>[[Prototype]]</code>-linked to <code>Foo.prototype</code>. But additionally, <code>Bar()</code> is <code>[[Prototype]]</code>-linked to <code>Foo()</code>. That part may not have such an obvious reasoning.</p>

<p>However, it's quite useful in the case where you declare <code>static</code> methods (not just properties) for a class, as these are added directly to that class's function object, not to the function object's <code>prototype</code> object. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-k">static</span> <span class="pl-en">cool</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span> ); }
    <span class="pl-en">wow</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>wow<span class="pl-pds">"</span></span> ); }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-k">static</span> <span class="pl-en">awesome</span>() {
        <span class="pl-v">super</span>.cool();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span> );
    }
    <span class="pl-en">neat</span>() {
        <span class="pl-v">super</span>.wow();
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>neat<span class="pl-pds">"</span></span> );
    }
}

Foo.cool();                 <span class="pl-c">// "cool"</span>
Bar.cool();                 <span class="pl-c">// "cool"</span>
Bar.awesome();              <span class="pl-c">// "cool"</span>
                            <span class="pl-c">// "awesome"</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
b.neat();                   <span class="pl-c">// "wow"</span>
                            <span class="pl-c">// "neat"</span>

b.awesome;                  <span class="pl-c">// undefined</span>
b.cool;                     <span class="pl-c">// undefined</span></pre></div>

<p>Be careful not to get confused that <code>static</code> members are on the class's prototype chain. They're actually on the dual/parallel chain between the function constructors.</p>

<h4><a id="user-content-symbolspecies-constructor-getter" class="anchor" href="#symbolspecies-constructor-getter" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.species</code> Constructor Getter</h4>

<p>One place where <code>static</code> can be useful is in setting the <code>Symbol.species</code> getter (known internally in the specification as <code>@@species</code>) for a derived (child) class. This capability allows a child class to signal to a parent class what constructor should be used -- when not intending the child class's constructor itself -- if any parent class method needs to vend a new instance.</p>

<p>For example, many methods on <code>Array</code> create and return a new <code>Array</code> instance. If you define a derived class from <code>Array</code>, but you want those methods to continue to vend actual <code>Array</code> instances instead of from your derived class, this works:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> ),
    b <span class="pl-k">=</span> a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){ <span class="pl-k">return</span> v <span class="pl-k">*</span> <span class="pl-c1">2</span>; } );

b <span class="pl-k">instanceof</span> MyCoolArray;   <span class="pl-c">// false</span>
b <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;         <span class="pl-c">// true</span></pre></div>

<p>To illustrate how a parent class method can use a child's species declaration somewhat like <code>Array#map(..)</code> is doing, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Foo</span> {
    <span class="pl-c">// defer `species` to derived constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; }
    <span class="pl-en">spawn</span>() {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">this.constructor</span>[Symbol.species]();
    }
}

<span class="pl-k">class</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-en">Foo</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> Foo; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();
<span class="pl-k">var</span> b <span class="pl-k">=</span> a.spawn();
b <span class="pl-k">instanceof</span> Foo;                   <span class="pl-c">// true</span>

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>();
<span class="pl-k">var</span> y <span class="pl-k">=</span> x.spawn();
y <span class="pl-k">instanceof</span> Bar;                   <span class="pl-c">// false</span>
y <span class="pl-k">instanceof</span> Foo;                   <span class="pl-c">// true</span></pre></div>

<p>The parent class <code>Symbol.species</code> does <code>return this</code> to defer to any derived class, as you'd normally expect. <code>Bar</code> then overrides to manually declare <code>Foo</code> to be used for such instance creation. Of course, a derived class can still vend instances of itself using <code>new this.constructor(..)</code>.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 introduces several new features that aid in code organization:</p>

<ul>
<li>Iterators provide sequential access to data or operations. They can be consumed by new language features like <code>for..of</code> and <code>...</code>.</li>
<li>Generators are locally pause/resume capable functions controlled by an iterator. They can be used to programmatically (and interactively, through <code>yield</code>/<code>next(..)</code> message passing) <em>generate</em> values to be consumed via iteration.</li>
<li>Modules allow private encapsulation of implementation details with a publicly exported API. Module definitions are file-based, singleton instances, and statically resolved at compile time.</li>
<li>Classes provide cleaner syntax around prototype-based coding. The addition of <code>super</code> also solves tricky issues with relative references in the <code>[[Prototype]]</code> chain.</li>
</ul>

<p>These new tools should be your first stop when trying to improve the architecture of your JS projects by embracing ES6.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-4-async-flow-control" class="anchor" href="#chapter-4-async-flow-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4: Async Flow Control</h1>

<p>It's no secret if you've written any significant amount of JavaScript that asynchronous programming is a required skill. The primary mechanism for managing asynchrony has been the function callback.</p>

<p>However, ES6 adds a new feature that helps address significant shortcomings in the callbacks-only approach to async: <em>Promises</em>. In addition, we can revisit generators (from the previous chapter) and see a pattern for combining the two that's a major step forward in async flow control programming in JavaScript.</p>

<h2><a id="user-content-promises" class="anchor" href="#promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Promises</h2>

<p>Let's clear up some misconceptions: Promises are not about replacing callbacks. Promises provide a trustable intermediary -- that is, between your calling code and the async code that will perform the task -- to manage callbacks.</p>

<p>Another way of thinking about a Promise is as an event listener, on which you can register to listen for an event that lets you know when a task has completed. It's an event that will only ever fire once, but it can be thought of as an event nonetheless.</p>

<p>Promises can be chained together, which can sequence a series of asychronously completing steps. Together with higher-level abstractions like the <code>all(..)</code> method (in classic terms, a "gate") and the <code>race(..)</code> method (in classic terms, a "latch"), promise chains provide a mechanism for async flow control.</p>

<p>Yet another way of conceptualizing a Promise is that it's a <em>future value</em>, a time-independent container wrapped around a value. This container can be reasoned about identically whether the underlying value is final or not. Observing the resolution of a Promise extracts this value once available. In other words, a Promise is said to be the async version of a sync function's return value.</p>

<p>A Promise can only have one of two possible resolution outcomes: fulfilled or rejected, with an optional single value. If a Promise is fulfilled, the final value is called a fulfillment. If it's rejected, the final value is called a reason (as in, a "reason for rejection"). Promises can only be resolved (fulfillment or rejection) <em>once</em>. Any further attempts to fulfill or reject are simply ignored. Thus, once a Promise is resolved, it's an immutable value that cannot be changed.</p>

<p>Clearly, there are several different ways to think about what a Promise is. No single perspective is fully sufficient, but each provides a separate aspect of the whole. The big takeaway is that they offer a significant improvement over callbacks-only async, namely that they provide order, predictability, and trustability.</p>

<h3><a id="user-content-making-and-using-promises" class="anchor" href="#making-and-using-promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Making and Using Promises</h3>

<p>To construct a promise instance, use the <code>Promise(..)</code> constructor:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c">// ..</span>
} );</pre></div>

<p>The <code>Promise(..)</code> constructor takes a single function (<code>pr(..)</code>), which is called immediately and receives two control functions as arguments, usually named <code>resolve(..)</code> and <code>reject(..)</code>. They are used as:</p>

<ul>
<li>If you call <code>reject(..)</code>, the promise is rejected, and if any value is passed to <code>reject(..)</code>, it is set as the reason for rejection.</li>
<li>If you call <code>resolve(..)</code> with no value, or any non-promise value, the promise is fulfilled.</li>
<li>If you call <code>resolve(..)</code> and pass another promise, this promise simply adopts the state -- whether immediate or eventual -- of the passed promise (either fulfillment or rejection).</li>
</ul>

<p>Here's how you'd typically use a promise to refactor a callback-reliant function call. If you start out with an <code>ajax(..)</code> utility that expects to be able to call an error-first style callback:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>,<span class="pl-smi">cb</span>) {
    <span class="pl-c">// make request, eventually call `cb(..)`</span>
}

<span class="pl-c">// ..</span>

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span>, <span class="pl-k">function</span> <span class="pl-en">handler</span>(<span class="pl-smi">err</span>,<span class="pl-smi">contents</span>){
    <span class="pl-k">if</span> (err) {
        <span class="pl-c">// handle ajax error</span>
    }
    <span class="pl-k">else</span> {
        <span class="pl-c">// handle `contents` success</span>
    }
} );</pre></div>

<p>You can convert it to:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">ajax</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
        <span class="pl-c">// make request, eventually call</span>
        <span class="pl-c">// either `resolve(..)` or `reject(..)`</span>
    } );
}

<span class="pl-c">// ..</span>

ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-c">// handle `contents` success</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// handle ajax error reason</span>
    }
);</pre></div>

<p>Promises have a <code>then(..)</code> method that accepts one or two callback functions. The first function (if present) is treated as the handler to call if the promise is fulfilled successfully. The second function (if present) is treated as the handler to call if the promise is rejected explicitly, or if any error/exception is caught during resolution.</p>

<p>If one of the arguments is omitted or otherwise not a valid function -- typically you'll use <code>null</code> instead -- a default placeholder equivalent is used. The default success callback passes its fulfillment value along and the default error callback propagates its rejection reason along.</p>

<p>The shorthand for calling <code>then(null,handleRejection)</code> is <code>catch(handleRejection)</code>.</p>

<p>Both <code>then(..)</code> and <code>catch(..)</code> automatically construct and return another promise instance, which is wired to receive the resolution from whatever the return value is from the original promise's fulfillment or rejection handler (whichever is actually called). Consider:</p>

<div class="highlight highlight-source-js"><pre>ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-k">return</span> contents.<span class="pl-c1">toUpperCase</span>();
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>DEFAULT VALUE<span class="pl-pds">"</span></span>;
    }
)
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">data</span>){
    <span class="pl-c">// handle data from original promise's</span>
    <span class="pl-c">// handlers</span>
} );</pre></div>

<p>In this snippet, we're returning an immediate value from either <code>fulfilled(..)</code> or <code>rejected(..)</code>, which then is received on the next event turn in the second <code>then(..)</code>'s <code>fulfilled(..)</code>. If we instead return a new promise, that new promise is subsumed and adopted as the resolution:</p>

<div class="highlight highlight-source-js"><pre>ajax( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
        <span class="pl-k">return</span> ajax(
            <span class="pl-s"><span class="pl-pds">"</span>http://some.url.2?v=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> contents
        );
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-k">return</span> ajax(
            <span class="pl-s"><span class="pl-pds">"</span>http://backup.url.3?err=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> reason
        );
    }
)
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">contents</span>){
    <span class="pl-c">// `contents` comes from the subsequent</span>
    <span class="pl-c">// `ajax(..)` call, whichever it was</span>
} );</pre></div>

<p>It's important to note that an exception (or rejected promise) in the first <code>fulfilled(..)</code> will <em>not</em> result in the first <code>rejected(..)</code> being called, as that handler only responds to the resolution of the first original promise. Instead, the second promise, which the second <code>then(..)</code> is called against, receives that rejection.</p>

<p>In this previous snippet, we are not listening for that rejection, which means it will be silently held onto for future observation. If you never observe it by calling a <code>then(..)</code> or <code>catch(..)</code>, then it will go unhandled. Some browser developer consoles may detect these unhandled rejections and report them, but this is not reliably guaranteed; you should always observe promise rejections.</p>

<p><strong>Note:</strong> This was just a brief overview of Promise theory and behavior. For a much more in-depth exploration, see Chapter 3 of the <em>Async &amp; Performance</em> title of this series.</p>

<h3><a id="user-content-thenables" class="anchor" href="#thenables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thenables</h3>

<p>Promises are genuine instances of the <code>Promise(..)</code> constructor. However, there are promise-like objects called <em>thenables</em> that generally can interoperate with the Promise mechanisms.</p>

<p>Any object (or function) with a <code>then(..)</code> function on it is assumed to be a thenable. Any place where the Promise mechanisms can accept and adopt the state of a genuine promise, they can also handle a thenable.</p>

<p>Thenables are basically a general label for any promise-like value that may have been created by some other system than the actual <code>Promise(..)</code> constructor. In that perspective, a thenable is generally less trustable than a genuine Promise. Consider this misbehaving thenable, for example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> th <span class="pl-k">=</span> {
    <span class="pl-en">then</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">thener</span>( <span class="pl-smi">fulfilled</span> ) {
        <span class="pl-c">// call `fulfilled(..)` once every 100ms forever</span>
        <span class="pl-c1">setInterval</span>( fulfilled, <span class="pl-c1">100</span> );
    }
};</pre></div>

<p>If you received that thenable and chained it with <code>th.then(..)</code>, you'd likely be surprised that your fulfillment handler is called repeatedly, when normal Promises are supposed to only ever be resolved once.</p>

<p>Generally, if you're receiving what purports to be a promise or thenable back from some other system, you shouldn't just trust it blindly. In the next section, we'll see a utility included with ES6 Promises that helps address this trust concern.</p>

<p>But to further understand the perils of this issue, consider that <em>any</em> object in <em>any</em> piece of code that's ever been defined to have a method on it called <code>then(..)</code> can be potentially confused as a thenable -- if used with Promises, of course -- regardless of if that thing was ever intended to even remotely be related to Promise-style async coding.</p>

<p>Prior to ES6, there was never any special reservation made on methods called <code>then(..)</code>, and as you can imagine there's been at least a few cases where that method name has been chosen prior to Promises ever showing up on the radar screen. The most likely case of mistaken thenable will be async libraries that use <code>then(..)</code> but which are not strictly Promises-compliant -- there are several out in the wild.</p>

<p>The onus will be on you to guard against directly using values with the Promise mechanism that would be incorrectly assumed to be a thenable.</p>

<h3><a id="user-content-promise-api" class="anchor" href="#promise-api" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Promise</code> API</h3>

<p>The <code>Promise</code> API also provides some static methods for working with Promises.</p>

<p><code>Promise.resolve(..)</code> creates a promise resolved to the value passed in. Let's compare how it works to the more manual approach:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    resolve( <span class="pl-c1">42</span> );
} );</pre></div>

<p><code>p1</code> and <code>p2</code> will have essentially identical behavior. The same goes for resolving with a promise:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> theP <span class="pl-k">=</span> ajax( .. );

<span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( theP );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    resolve( theP );
} );</pre></div>

<p><strong>Tip:</strong> <code>Promise.resolve(..)</code> is the solution to the thenable trust issue raised in the previous section. Any value that you are not already certain is a trustable promise -- even if it could be an immediate value -- can be normalized by passing it to <code>Promise.resolve(..)</code>. If the value is already a recognizable promise or thenable, its state/resolution will simply be adopted, insulating you from misbehavior. If it's instead an immediate value, it will be "wrapped" in a genuine promise, thereby normalizing its behavior to be async.</p>

<p><code>Promise.reject(..)</code> creates an immediately rejected promise, the same as its <code>Promise(..)</code> constructor counterpart:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
} );</pre></div>

<p>While <code>resolve(..)</code> and <code>Promise.resolve(..)</code> can accept a promise and adopt its state/resolution, <code>reject(..)</code> and <code>Promise.reject(..)</code> do not differentiate what value they receive. So, if you reject with a promise or thenable, the promise/thenable itself will be set as the rejection reason, not its underlying value.</p>

<p><code>Promise.all([ .. ])</code> accepts an array of one or more values (e.g., immediate values, promises, thenables). It returns a promise back that will be fulfilled if all the values fulfill, or reject immediately once the first of any of them rejects.</p>

<p>Starting with these values/promises:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> p1 <span class="pl-k">=</span> Promise.resolve( <span class="pl-c1">42</span> );
<span class="pl-k">var</span> p2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>){
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        resolve( <span class="pl-c1">43</span> );
    }, <span class="pl-c1">100</span> );
} );
<span class="pl-k">var</span> v3 <span class="pl-k">=</span> <span class="pl-c1">44</span>;
<span class="pl-k">var</span> p4 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span> <span class="pl-en">pr</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
    <span class="pl-c1">setTimeout</span>( <span class="pl-k">function</span>(){
        reject( <span class="pl-s"><span class="pl-pds">"</span>Oops<span class="pl-pds">"</span></span> );
    }, <span class="pl-c1">10</span> );
} );</pre></div>

<p>Let's consider how <code>Promise.all([ .. ])</code> works with combinations of those values:</p>

<div class="highlight highlight-source-js"><pre>Promise.<span class="pl-c1">all</span>( [p1,p2,v3] )
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">vals</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( vals );            <span class="pl-c">// [42,43,44]</span>
} );

Promise.<span class="pl-c1">all</span>( [p1,p2,v3,p4] )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">vals</span>){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( reason );      <span class="pl-c">// Oops</span>
    }
);</pre></div>

<p>While <code>Promise.all([ .. ])</code> waits for all fulfillments (or the first rejection), <code>Promise.race([ .. ])</code> waits only for either the first fulfillment or rejection. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// NOTE: re-setup all test values to</span>
<span class="pl-c">// avoid timing issues misleading you!</span>

Promise.race( [p2,p1,v3] )
.then( <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( val );             <span class="pl-c">// 42</span>
} );

Promise.race( [p2,p1,v3,p4] )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">val</span>){
        <span class="pl-c">// never gets here</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-en">console</span><span class="pl-c1">.log</span>( reason );      <span class="pl-c">// Oops</span>
    }
);</pre></div>

<p><strong>Warning:</strong> While <code>Promise.all([])</code> will fulfill right away (with no values), <code>Promise.race([])</code> will hang forever. This is a strange inconsistency, and speaks to the suggestion that you should never use these methods with empty arrays.</p>

<h2><a id="user-content-generators--promises" class="anchor" href="#generators--promises" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators + Promises</h2>

<p>It <em>is</em> possible to express a series of promises in a chain to represent the async flow control of your program. Consider:</p>

<div class="highlight highlight-source-js"><pre>step1()
.then(
    step2,
    step2Failed
)
.then(
    <span class="pl-k">function</span> <span class="pl-en">step3</span>(<span class="pl-smi">msg</span>) {
        <span class="pl-k">return</span> Promise.<span class="pl-c1">all</span>( [
            step3a( msg ),
            step3b( msg ),
            step3c( msg )
        ] )
    }
)
.then(step4);</pre></div>

<p>However, there's a much better option for expressing async flow control, and it will probably be much more preferable in terms of coding style than long promise chains. We can use what we learned in Chapter 3 about generators to express our async flow control.</p>

<p>The important pattern to recognize: a generator can yield a promise, and that promise can then be wired to resume the generator with its fulfillment value.</p>

<p>Consider the previous snippet's async flow control expressed with a generator:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2Failed( err );
    }

    <span class="pl-c">// step 3</span>
    ret <span class="pl-k">=</span> <span class="pl-k">yield</span> Promise.<span class="pl-c1">all</span>( [
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ] );

    <span class="pl-k">yield</span> step4( ret );
}</pre></div>

<p>On the surface, this snippet may seem more verbose than the promise chain equivalent in the earlier snippet. However, it offers a much more attractive -- and more importantly, a more understandable and reason-able -- synchronous-looking coding style (with <code>=</code> assignment of "return" values, etc.) That's especially true in that <code>try..catch</code> error handling can be used across those hidden async boundaries.</p>

<p>Why are we using Promises with the generator? It's certainly possible to do async generator coding without Promises.</p>

<p>Promises are a trustable system that uninverts the inversion of control of normal callbacks or thunks (see the <em>Async &amp; Performance</em> title of this series). So, combining the trustability of Promises and the synchronicity of code in generators effectively addresses all the major deficiencies of callbacks. Also, utilities like <code>Promise.all([ .. ])</code> are a nice, clean way to express concurrency at a generator's single <code>yield</code> step.</p>

<p>So how does this magic work? We're going to need a <em>runner</em> that can run our generator, receive a <code>yield</code>ed promise, and wire it up to resume the generator with either the fulfillment success value, or throw an error into the generator with the rejection reason.</p>

<p>Many async-capable utilities/libraries have such a "runner"; for example, <code>Q.spawn(..)</code> and my asynquence's <code>runner(..)</code> plug-in. But here's a stand-alone runner to illustrate how the process works:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">run</span>(<span class="pl-smi">gen</span>) {
    <span class="pl-k">var</span> args <span class="pl-k">=</span> [].slice.<span class="pl-c1">call</span>( arguments, <span class="pl-c1">1</span>), it;

    it <span class="pl-k">=</span> gen.<span class="pl-c1">apply</span>( <span class="pl-v">this</span>, args );

    <span class="pl-k">return</span> Promise.resolve()
        .then( <span class="pl-k">function</span> <span class="pl-en">handleNext</span>(<span class="pl-smi">value</span>){
            <span class="pl-k">var</span> next <span class="pl-k">=</span> it.<span class="pl-c1">next</span>( value );

            <span class="pl-k">return</span> (<span class="pl-k">function</span> <span class="pl-en">handleResult</span>(<span class="pl-smi">next</span>){
                <span class="pl-k">if</span> (next.done) {
                    <span class="pl-k">return</span> next.<span class="pl-c1">value</span>;
                }
                <span class="pl-k">else</span> {
                    <span class="pl-k">return</span> Promise.resolve( next.<span class="pl-c1">value</span> )
                        .then(
                            handleNext,
                            <span class="pl-k">function</span> <span class="pl-en">handleErr</span>(<span class="pl-smi">err</span>) {
                                <span class="pl-k">return</span> Promise.resolve(
                                    it.throw( err )
                                )
                                .then( handleResult );
                            }
                        );
                }
            })( next );
        } );
}</pre></div>

<p><strong>Note:</strong> For a more prolifically commented version of this utility, see the <em>Async &amp; Performance</em> title of this series. Also, the run utilities provided with various async libraries are often more powerful/capable than what we've shown here. For example, asynquence's <code>runner(..)</code> can handle <code>yield</code>ed promises, sequences, thunks, and immediate (non-promise) values, giving you ultimate flexibility.</p>

<p>So now running <code>*main()</code> as listed in the earlier snippet is as easy as:</p>

<div class="highlight highlight-source-js"><pre>run( main )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `*main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>Essentially, anywhere that you have more than two asynchronous steps of flow control logic in your program, you can <em>and should</em> use a promise-yielding generator driven by a run utility to express the flow control in a synchronous fashion. This will make for much easier to understand and maintain code.</p>

<p>This yield-a-promise-resume-the-generator pattern is going to be so common and so powerful, the next version of JavaScript after ES6 is almost certainly going to introduce a new function type that will do it automatically without needing the run utility. We'll cover <code>async function</code>s (as they're expected to be called) in Chapter 8.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>As JavaScript continues to mature and grow in its widespread adoption, asynchronous programming is more and more of a central concern. Callbacks are not fully sufficient for these tasks, and totally fall down the more sophisticated the need.</p>

<p>Thankfully, ES6 adds Promises to address one of the major shortcomings of callbacks: lack of trust in predictable behavior. Promises represent the future completion value from a potentially async task, normalizing behavior across sync and async boundaries.</p>

<p>But it's the combination of Promises with generators that fully realizes the benefits of rearranging our async flow control code to de-emphasize and abstract away that ugly callback soup (aka "hell").</p>

<p>Right now, we can manage these interactions with the aide of various async libraries' runners, but JavaScript is eventually going to support this interaction pattern with dedicated syntax alone!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-5-collections" class="anchor" href="#chapter-5-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 5: Collections</h1>

<p>Structured collection and access to data is a critical component of just about any JS program. From the beginning of the language up to this point, the array and the object have been our primary mechanism for creating data structures. Of course, many higher-level data structures have been built on top of these, as user-land libraries.</p>

<p>As of ES6, some of the most useful (and performance-optimizing!) data structure abstractions have been added as native components of the language.</p>

<p>We'll start this chapter first by looking at <em>TypedArrays</em>, technically contemporary to ES5 efforts several years ago, but only standardized as companions to WebGL and not JavaScript itself. As of ES6, these have been adopted directly by the language specification, which gives them first-class status.</p>

<p>Maps are like objects (key/value pairs), but instead of just a string for the key, you can use any value -- even another object or map! Sets are similar to arrays (lists of values), but the values are unique; if you add a duplicate, it's ignored. There are also weak (in relation to memory/garbage collection) counterparts: WeakMap and WeakSet.</p>

<h2><a id="user-content-typedarrays" class="anchor" href="#typedarrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypedArrays</h2>

<p>As we cover in the <em>Types &amp; Grammar</em> title of this series, JS does have a set of built-in types, like <code>number</code> and <code>string</code>. It'd be tempting to look at a feature named "typed array" and assume it means an array of a specific type of values, like an array of only strings.</p>

<p>However, typed arrays are really more about providing structured access to binary data using array-like semantics (indexed access, etc.). The "type" in the name refers to a "view" layered on type of the bucket of bits, which is essentially a mapping of whether the bits should be viewed as an array of 8-bit signed integers, 16-bit signed integers, and so on.</p>

<p>How do you construct such a bit-bucket? It's called a "buffer," and you construct it most directly with the <code>ArrayBuffer(..)</code> constructor:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> buf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">32</span> );
buf.byteLength;                         <span class="pl-c">// 32</span></pre></div>

<p><code>buf</code> is now a binary buffer that is 32-bytes long (256-bits), that's pre-initialized to all <code>0</code>s. A buffer by itself doesn't really allow you any interaction exception for checking its <code>byteLength</code> property.</p>

<p><strong>Tip:</strong> Several web platform features use or return array buffers, such as <code>FileReader#readAsArrayBuffer(..)</code>, <code>XMLHttpRequest#send(..)</code>, and <code>ImageData</code> (canvas data).</p>

<p>But on top of this array buffer, you can then layer a "view," which comes in the form of a typed array. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf );
arr.<span class="pl-c1">length</span>;                         <span class="pl-c">// 16</span></pre></div>

<p><code>arr</code> is a typed array of 16-bit unsigned integers mapped over the 256-bit <code>buf</code> buffer, meaning you get 16 elements.</p>

<h3><a id="user-content-endianness" class="anchor" href="#endianness" aria-hidden="true"><span class="octicon octicon-link"></span></a>Endianness</h3>

<p>It's very important to understand that the <code>arr</code> is mapped using the endian-setting (big-endian or little-endian) of the platform the JS is running on. This can be an issue if the binary data is created with one endianness but interpreted on a platform with the opposite endianness.</p>

<p>Endian means if the low-order byte (collection of 8-bits) of a multi-byte number -- such as the 16-bit unsigned ints we created in the earlier snippet -- is on the right or the left of the number's bytes.</p>

<p>For example, let's imagine the base-10 number <code>3085</code>, which takes 16-bits to represent. If you have just one 16-bit number container, it'd be represented in binary as <code>0000110000001101</code> (hexadecimal <code>0c0d</code>) regardless of endianness.</p>

<p>But if <code>3085</code> was represented with two 8-bit numbers, the endianness would significantly affect its storage in memory:</p>

<ul>
<li><code>0000110000001101</code> / <code>0c0d</code> (big endian)</li>
<li><code>0000110100001100</code> / <code>0d0c</code> (little endian)</li>
</ul>

<p>If you received the bits of <code>3085</code> as <code>0000110100001100</code> from a little-endian system, but you layered a view on top of it in a big-endian system, you'd instead see value <code>3340</code> (base-10) and <code>0d0c</code> (base-16).</p>

<p>Little endian is the most common representation on the web these days, but there are definitely browsers where that's not true. It's important that you understand the endianness of both the producer and consumer of a chunk of binary data.</p>

<p>From MDN, here's a quick way to test the endianness of your JavaScript:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> littleEndian <span class="pl-k">=</span> (<span class="pl-k">function</span>() {
    <span class="pl-k">var</span> buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">2</span> );
    <span class="pl-k">new</span> <span class="pl-en">DataView</span>( buffer ).setInt16( <span class="pl-c1">0</span>, <span class="pl-c1">256</span>, <span class="pl-c1">true</span> );
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Int16Array</span>( buffer )[<span class="pl-c1">0</span>] <span class="pl-k">===</span> <span class="pl-c1">256</span>;
})();</pre></div>

<p><code>littleEndian</code> will be <code>true</code> or <code>false</code>; for most browsers, it should return <code>true</code>. This test uses <code>DataView(..)</code>, which allows more low-level, fine-grained control over accessing (setting/getting) the bits from the view you layer over the buffer. The third parameter of the <code>setInt16(..)</code> method in the previous snippet is for telling the <code>DataView</code> what endianness you're wanting it to use for that operation.</p>

<p><strong>Warning:</strong> Do not confuse endianness of underlying binary storage in array buffers with how a given number is represented when exposed in a JS program. For example, <code>(3085).toString(2)</code> returns <code>"110000001101"</code>, which with an assumed leading four <code>"0"</code>s appears to be the big-endian representation. In fact, this representation is based on a single 16-bit view, not a view of two 8-bit bytes. The <code>DataView</code> test above is the best way to determine endianness for your JS environment.</p>

<h3><a id="user-content-multiple-views" class="anchor" href="#multiple-views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Views</h3>

<p>A single buffer can have multiple views attached to it, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> buf <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ArrayBuffer</span>( <span class="pl-c1">2</span> );

<span class="pl-k">var</span> view8 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf );
<span class="pl-k">var</span> view16 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf );

view16[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">3085</span>;
view8[<span class="pl-c1">0</span>];                       <span class="pl-c">// 13</span>
view8[<span class="pl-c1">1</span>];                       <span class="pl-c">// 12</span>

view8[<span class="pl-c1">0</span>].<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );        <span class="pl-c">// "d"</span>
view8[<span class="pl-c1">1</span>].<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );        <span class="pl-c">// "c"</span>

<span class="pl-c">// swap (as if endian!)</span>
<span class="pl-k">var</span> tmp <span class="pl-k">=</span> view8[<span class="pl-c1">0</span>];
view8[<span class="pl-c1">0</span>] <span class="pl-k">=</span> view8[<span class="pl-c1">1</span>];
view8[<span class="pl-c1">1</span>] <span class="pl-k">=</span> tmp;

view16[<span class="pl-c1">0</span>];                      <span class="pl-c">// 3340</span></pre></div>

<p>The typed array constructors have multiple signature variations. We've shown so far only passing them an existing buffer. However, that form also takes two extra parameters: <code>byteOffset</code> and <code>length</code>. In other words, you can start the typed array view at a location other than <code>0</code> and you can make it span less than the full length of the buffer.</p>

<p>If the buffer of binary data includes data in non-uniform size/location, this technique can be quite useful.</p>

<p>For example, consider a binary buffer that has a 2-byte number (aka "word") at the beginning, followed by two 1-byte numbers, followed by a 32-bit floating point number. Here's how you can access that data with multiple views on the same buffer, offsets, and lengths:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> first <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint16Array</span>( buf, <span class="pl-c1">0</span>, <span class="pl-c1">2</span> )[<span class="pl-c1">0</span>],
    second <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf, <span class="pl-c1">2</span>, <span class="pl-c1">1</span> )[<span class="pl-c1">0</span>],
    third <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( buf, <span class="pl-c1">3</span>, <span class="pl-c1">1</span> )[<span class="pl-c1">0</span>],
    fourth <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Float32Array</span>( buf, <span class="pl-c1">4</span>, <span class="pl-c1">4</span> )[<span class="pl-c1">0</span>];</pre></div>

<h3><a id="user-content-typedarray-constructors" class="anchor" href="#typedarray-constructors" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypedArray Constructors</h3>

<p>In addition to the <code>(buffer,[offset, [length]])</code> form examined in the previous section, typed array constructors also support these forms:</p>

<ul>
<li>[constructor]<code>(length)</code>: Creates a new view over a new buffer of <code>length</code> bytes</li>
<li>[constructor]<code>(typedArr)</code>: Creates a new view and buffer, and copies the contents from the <code>typedArr</code> view</li>
<li>[constructor]<code>(obj)</code>: Creates a new view and buffer, and iterates over the array-like or object <code>obj</code> to copy its contents</li>
</ul>

<p>The following typed array constructors are available as of ES6:</p>

<ul>
<li><code>Int8Array</code> (8-bit signed integers), <code>Uint8Array</code> (8-bit unsigned integers)

<ul>
<li><code>Uint8ClampedArray</code> (8-bit unsigned integers, each value clamped on setting to the <code>0</code>-<code>255</code> range)</li>
</ul></li>
<li><code>Int16Array</code> (16-bit signed integers), <code>Uint16Array</code> (16-bit unsigned integers)</li>
<li><code>Int32Array</code> (32-bit signed integers), <code>Uint32Array</code> (32-bit unsigned integers)</li>
<li><code>Float32Array</code> (32-bit floating point, IEEE-754)</li>
<li><code>Float64Array</code> (64-bit floating point, IEEE-754)</li>
</ul>

<p>Instances of typed array constructors are almost the same as regular native arrays. Some differences include having a fixed length and the values all being of the same "type."</p>

<p>However, they share most of the same <code>prototype</code> methods. As such, you likely will be able to use them as regular arrays without needing to convert.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Int32Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
} );
<span class="pl-c">// 10 20 30</span>

a.<span class="pl-c1">join</span>( <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> );
<span class="pl-c">// "10-20-30"</span></pre></div>

<p><strong>Warning:</strong> You can't use certain <code>Array.prototype</code> methods with TypedArrays that don't make sense, such as the mutators (<code>splice(..)</code>, <code>push(..)</code>, etc.) and <code>concat(..)</code>.</p>

<p>Be aware that the elements in TypedArrays really are constrained to the declared bit sizes. If you have a <code>Uint8Array</code> and try to assign something larger than an 8-bit value into one of its elements, the value wraps around so as to stay within the bit length.</p>

<p>This could cause problems if you were trying to, for instance, square all the values in a TypedArray. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> a.map( <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">*</span> v;
} );

b;              <span class="pl-c">// [100, 144, 132]</span></pre></div>

<p>The <code>20</code> and <code>30</code> values, when squared, resulted in bit overflow. To get around such a limitation, you can use the <code>TypedArray#from(..)</code> function:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( <span class="pl-c1">3</span> );
a[<span class="pl-c1">0</span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">20</span>;
a[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">30</span>;

<span class="pl-k">var</span> b <span class="pl-k">=</span> Uint16Array.from( a, <span class="pl-k">function</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">*</span> v;
} );

b;              <span class="pl-c">// [100, 400, 900]</span></pre></div>

<p>See the "<code>Array.from(..)</code> Static Function" section in Chapter 6 for more information about the <code>Array.from(..)</code> that is shared with TypedArrays. Specifically, the "Mapping" section explains the mapping function accepted as its second argument.</p>

<p>One interesting behavior to consider is that TypedArrays have a <code>sort(..)</code> method much like regular arrays, but this one defaults to numeric sort comparisons instead of coercing values to strings for lexicographic comparison. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [ <span class="pl-c1">10</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, ];
a.<span class="pl-c1">sort</span>();                               <span class="pl-c">// [1,10,2]</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Uint8Array</span>( [ <span class="pl-c1">10</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ] );
b.<span class="pl-c1">sort</span>();                               <span class="pl-c">// [1,2,10]</span></pre></div>

<p>The <code>TypedArray#sort(..)</code> takes an optional compare function argument just like <code>Array#sort(..)</code>, which works in exactly the same way.</p>

<h2><a id="user-content-maps" class="anchor" href="#maps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maps</h2>

<p>If you have a lot of JS experience, you know that objects are the primary mechanism for creating unordered key/value-pair data structures, otherwise known as maps. However, the major drawback with objects-as-maps is the inability to use a non-string value as the key.</p>

<p>For example, consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> {};

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m[x] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;
m[y] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>;

m[x];                           <span class="pl-c">// "bar"</span>
m[y];                           <span class="pl-c">// "bar"</span></pre></div>

<p>What's going on here? The two objects <code>x</code> and <code>y</code> both stringify to <code>"[object Object]"</code>, so only that one key is being set in <code>m</code>.</p>

<p>Some have implemented fake maps by maintaining a parallel array of non-string keys alongside an array of the values, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> keys <span class="pl-k">=</span> [], vals <span class="pl-k">=</span> [];

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

keys.<span class="pl-c1">push</span>( x );
vals.<span class="pl-c1">push</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

keys.<span class="pl-c1">push</span>( y );
vals.<span class="pl-c1">push</span>( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;                  <span class="pl-c">// true</span>
vals[<span class="pl-c1">0</span>];                        <span class="pl-c">// "foo"</span>

keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;                  <span class="pl-c">// true</span>
vals[<span class="pl-c1">1</span>];                        <span class="pl-c">// "bar"</span></pre></div>

<p>Of course, you wouldn't want to manage those parallel arrays yourself, so you could define a data structure with methods that automatically do the management under the covers. Besides having to do that work yourself, the main drawback is that access is no longer O(1) time-complexity, but instead is O(n).</p>

<p>But as of ES6, there's no longer any need to do this! Just use <code>Map(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

m.get( x );                     <span class="pl-c">// "foo"</span>
m.get( y );                     <span class="pl-c">// "bar"</span></pre></div>

<p>The only drawback is that you can't use the <code>[ ]</code> bracket access syntax for setting and retrieving values. But <code>get(..)</code> and <code>set(..)</code> work perfectly suitably instead.</p>

<p>To delete an element from a map, don't use the <code>delete</code> operator, but instead use the <code>delete(..)</code> method:</p>

<div class="highlight highlight-source-js"><pre>m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

m.delete( y );</pre></div>

<p>You can clear the entire map's contents with <code>clear()</code>. To get the length of a map (i.e., the number of keys), use the <code>size</code> property (not <code>length</code>):</p>

<div class="highlight highlight-source-js"><pre>m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );
m.<span class="pl-c1">size</span>;                         <span class="pl-c">// 2</span>

m.<span class="pl-c1">clear</span>();
m.<span class="pl-c1">size</span>;                         <span class="pl-c">// 0</span></pre></div>

<p>The <code>Map(..)</code> constructor can also receive an iterable (see "Iterators" in Chapter 3), which must produce a list of arrays, where the first item in each array is the key and the second item is the value. This format for iteration is identical to that produced by the <code>entries()</code> method, explained in the next section. That makes it easy to make a copy of a map:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( m.entries() );

<span class="pl-c">// same as:</span>
<span class="pl-k">var</span> m2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( m );</pre></div>

<p>Because a map instance is an iterable, and its default iterator is the same as <code>entries()</code>, the second shorter form is more preferable.</p>

<p>Of course, you can just manually specify an <em>entries</em> list (array of key/value arrays) in the <code>Map(..)</code> constructor form:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>( [
    [ x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ],
    [ y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ]
] );

m.get( x );                     <span class="pl-c">// "foo"</span>
m.get( y );                     <span class="pl-c">// "bar"</span></pre></div>

<h3><a id="user-content-map-values" class="anchor" href="#map-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map Values</h3>

<p>To get the list of values from a map, use <code>values(..)</code>, which returns an iterator. In Chapters 2 and 3, we covered various ways to process an iterator sequentially (like an array), such as the <code>...</code> spread operator and the <code>for..of</code> loop. Also, "Arrays" in Chapter 6 covers the <code>Array.from(..)</code> method in detail. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> vals <span class="pl-k">=</span> [ ...m.values() ];

vals;                           <span class="pl-c">// ["foo","bar"]</span>
<span class="pl-c1">Array</span>.from( m.values() );       <span class="pl-c">// ["foo","bar"]</span></pre></div>

<p>As discussed in the previous section, you can iterate over a map's entries using <code>entries()</code> (or the default map iterator). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> vals <span class="pl-k">=</span> [ ...m.entries() ];

vals[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;               <span class="pl-c">// true</span>
vals[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>];                     <span class="pl-c">// "foo"</span>

vals[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> y;               <span class="pl-c">// true</span>
vals[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>];                     <span class="pl-c">// "bar"</span></pre></div>

<h3><a id="user-content-map-keys" class="anchor" href="#map-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Map Keys</h3>

<p>To get the list of keys, use <code>keys()</code>, which returns an iterator over the keys in the map:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );
m.set( y, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> );

<span class="pl-k">var</span> keys <span class="pl-k">=</span> [ ...m.keys() ];

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;                  <span class="pl-c">// true</span>
keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;                  <span class="pl-c">// true</span></pre></div>

<p>To determine if a map has a given key, use <code>has(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Map</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

m.has( x );                     <span class="pl-c">// true</span>
m.has( y );                     <span class="pl-c">// false</span></pre></div>

<p>Maps essentially let you associate some extra piece of information (the value) with an object (the key) without actually putting that information on the object itself.</p>

<p>While you can use any kind of value as a key for a map, you typically will use objects, as strings and other primitives are already eligible as keys of normal objects. In other words, you'll probably want to continue to use normal objects for maps unless some or all of the keys need to be objects, in which case map is more appropriate.</p>

<p><strong>Warning:</strong> If you use an object as a map key and that object is later discarded (all references unset) in attempt to have garbage collection (GC) reclaim its memory, the map itself will still retain its entry. You will need to remove the entry from the map for it to be GC-eligible. In the next section, we'll see WeakMaps as a better option for object keys and GC.</p>

<h2><a id="user-content-weakmaps" class="anchor" href="#weakmaps" aria-hidden="true"><span class="octicon octicon-link"></span></a>WeakMaps</h2>

<p>WeakMaps are a variation on maps, which has most of the same external behavior but differs underneath in how the memory allocation (specifically its GC) works.</p>

<p>WeakMaps take (only) objects as keys. Those objects are held <em>weakly</em>, which means if the object itself is GC'd, the entry in the WeakMap is also removed. This isn't observable behavior, though, as the only way an object can be GC'd is if there's no more references to it -- once there are no more references to it, you have no object reference to check if it exists in the WeakMap.</p>

<p>Otherwise, the API for WeakMap is similar, though more limited:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakMap</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

m.set( x, <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> );

m.has( x );                     <span class="pl-c">// true</span>
m.has( y );                     <span class="pl-c">// false</span></pre></div>

<p>WeakMaps do not have a <code>size</code> property or <code>clear()</code> method, nor do they expose any iterators over their keys, values, or entries. So even if you unset the <code>x</code> reference, which will remove its entry from <code>m</code> upon GC, there is no way to tell. You'll just have to take JavaScript's word for it!</p>

<p>Just like Maps, WeakMaps let you soft-associate information with an object. But they are particularly useful if the object is not one you completely control, such as a DOM element. If the object you're using as a map key can be deleted and should be GC-eligible when it is, then a WeakMap is a more appropriate option.</p>

<p>It's important to note that a WeakMap only holds its <em>keys</em> weakly, not its values. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakMap</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    z <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    w <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">4</span> };

m.set( x, y );

x <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 1 } is GC-eligible</span>
y <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 2 } is GC-eligible</span>
                                <span class="pl-c">// only because { id: 1 } is</span>

m.set( z, w );

w <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// { id: 4 } is not GC-eligible</span></pre></div>

<p>For this reason, WeakMaps are in my opinion better named "WeakKeyMaps."</p>

<h2><a id="user-content-sets" class="anchor" href="#sets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sets</h2>

<p>A set is a collection of unique values (duplicates are ignored).</p>

<p>The API for a set is similar to map. The <code>add(..)</code> method takes the place of the <code>set(..)</code> method (somewhat ironically), and there is no <code>get(..)</code> method.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );
s.<span class="pl-c1">add</span>( y );
s.<span class="pl-c1">add</span>( x );

s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 2</span>

s.delete( y );
s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 1</span>

s.<span class="pl-c1">clear</span>();
s.<span class="pl-c1">size</span>;                         <span class="pl-c">// 0</span></pre></div>

<p>The <code>Set(..)</code> constructor form is similar to <code>Map(..)</code>, in that it can receive an iterable, like another set or simply an array of values. However, unlike how <code>Map(..)</code> expects <em>entries</em> list (array of key/value arrays), <code>Set(..)</code> expects a <em>values</em> list (array of values):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>( [x,y] );</pre></div>

<p>A set doesn't need a <code>get(..)</code> because you don't retrieve a value from a set, but rather test if it is present or not, using <code>has(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );

s.has( x );                     <span class="pl-c">// true</span>
s.has( y );                     <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> The comparison algorithm in <code>has(..)</code> is almost identical to <code>Object.is(..)</code> (see Chapter 6), except that <code>-0</code> and <code>0</code> are treated as the same rather than distinct.</p>

<h3><a id="user-content-set-iterators" class="anchor" href="#set-iterators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Set Iterators</h3>

<p>Sets have the same iterator methods as maps. Their behavior is different for sets, but symmetric with the behavior of map iterators. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x ).<span class="pl-c1">add</span>( y );

<span class="pl-k">var</span> keys <span class="pl-k">=</span> [ ...s.keys() ],
    vals <span class="pl-k">=</span> [ ...s.values() ],
    entries <span class="pl-k">=</span> [ ...s.entries() ];

keys[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
keys[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;

vals[<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
vals[<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;

entries[<span class="pl-c1">0</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> x;
entries[<span class="pl-c1">0</span>][<span class="pl-c1">1</span>] <span class="pl-k">===</span> x;
entries[<span class="pl-c1">1</span>][<span class="pl-c1">0</span>] <span class="pl-k">===</span> y;
entries[<span class="pl-c1">1</span>][<span class="pl-c1">1</span>] <span class="pl-k">===</span> y;</pre></div>

<p>The <code>keys()</code> and <code>values()</code> iterators both yield a list of the unique values in the set. The <code>entries()</code> iterator yields a list of entry arrays, where both items of the array are the unique set value. The default iterator for a set is its <code>values()</code> iterator.</p>

<p>The inherent uniqueness of a set is its most useful trait. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Set</span>( [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>,<span class="pl-c1">2</span>,<span class="pl-c1">4</span>,<span class="pl-s"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>] ),
    uniques <span class="pl-k">=</span> [ ...s ];

uniques;                        <span class="pl-c">// [1,2,3,4,"1","5"]</span></pre></div>

<p>Set uniqueness does not allow coercion, so <code>1</code> and <code>"1"</code> are considered distinct values.</p>

<h2><a id="user-content-weaksets" class="anchor" href="#weaksets" aria-hidden="true"><span class="octicon octicon-link"></span></a>WeakSets</h2>

<p>Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet holds its values weakly (there aren't really keys).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">WeakSet</span>();

<span class="pl-k">var</span> x <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    y <span class="pl-k">=</span> { id<span class="pl-k">:</span> <span class="pl-c1">2</span> };

s.<span class="pl-c1">add</span>( x );
s.<span class="pl-c1">add</span>( y );

x <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// `x` is GC-eligible</span>
y <span class="pl-k">=</span> <span class="pl-c1">null</span>;                       <span class="pl-c">// `y` is GC-eligible</span></pre></div>

<p><strong>Warning:</strong> WeakSet values must be objects, not primitive values as is allowed with sets.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 defines a number of useful collections that make working with data in structured ways more efficient and effective.</p>

<p>TypedArrays provide "view"s of binary data buffers that align with various integer types, like 8-bit unsigned integers and 32-bit floats. The array access to binary data makes operations much easier to express and maintain, which enables you to more easily work with complex data like video, audio, canvas data, and so on.</p>

<p>Maps are key-value pairs where the key can be an object instead of just a string/primitive. Sets are unique lists of values (of any type).</p>

<p>WeakMaps are maps where the key (object) is weakly held, so that GC is free to collect the entry if it's the last reference to an object. WeakSets are sets where the value is weakly held, again so that GC can remove the entry if it's the last reference to that object.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-6-api-additions" class="anchor" href="#chapter-6-api-additions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 6: API Additions</h1>

<p>From conversions of values to mathematic calculations, ES6 adds many static properties and methods to various built-in natives and objects to help with common tasks. In addition, instances of some of the natives have new capabilities via various new prototype methods.</p>

<p><strong>Note:</strong> Most of these features can be faithfully polyfilled. We will not dive into such details here, but check out "ES6 Shim" (<a href="https://github.com/paulmillr/es6-shim/">https://github.com/paulmillr/es6-shim/</a>) for standards-compliant shims/polyfills.</p>

<h2><a id="user-content-array" class="anchor" href="#array" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array</code></h2>

<p>One of the most commonly extended features in JS by various user libraries is the Array type. It should be no surprise that ES6 adds a number of helpers to Array, both static and prototype (instance).</p>

<h3><a id="user-content-arrayof-static-function" class="anchor" href="#arrayof-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array.of(..)</code> Static Function</h3>

<p>There's a well known gotcha with the <code>Array(..)</code> constructor, which is that if there's only one argument passed, and that argument is a number, instead of making an array of one element with that number value in it, it constructs an empty array with a <code>length</code> property equal to the number. This action produces the unfortunate and quirky "empty slots" behavior that's reviled about JS arrays.</p>

<p><code>Array.of(..)</code> replaces <code>Array(..)</code> as the preferred function-form constructor for arrays, because <code>Array.of(..)</code> does not have that special single-number-argument case. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">3</span> );
a.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3</span>
a[<span class="pl-c1">0</span>];                           <span class="pl-c">// undefined</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Array</span>.of( <span class="pl-c1">3</span> );
b.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
b[<span class="pl-c1">0</span>];                           <span class="pl-c">// 3</span>

<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">Array</span>.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );
c.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3</span>
c;                              <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Under what circumstances would you want to use <code>Array.of(..)</code> instead of just creating an array with literal syntax, like <code>c = [1,2,3]</code>? There's two possible cases.</p>

<p>If you have a callback that's supposed to wrap argument(s) passed to it in an array, <code>Array.of(..)</code> fits the bill perfectly. That's probably not terribly common, but it may scratch an itch for you.</p>

<p>The other scenario is if you subclass <code>Array</code> (see "Classes" in Chapter 3) and want to be able to create and initialize elements in an instance of your subclass, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-en">sum</span>() {
        <span class="pl-k">return</span> <span class="pl-v">this</span>.reduce( <span class="pl-k">function</span> <span class="pl-en">reducer</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">curr</span>){
            <span class="pl-k">return</span> acc <span class="pl-k">+</span> curr;
        }, <span class="pl-c1">0</span> );
    }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">3</span> );
x.<span class="pl-c1">length</span>;                       <span class="pl-c">// 3 -- oops!</span>
x.sum();                        <span class="pl-c">// 0 -- oops!</span>

<span class="pl-k">var</span> y <span class="pl-k">=</span> [<span class="pl-c1">3</span>];                    <span class="pl-c">// Array, not MyCoolArray</span>
y.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
y.sum();                        <span class="pl-c">// `sum` is not a function</span>

<span class="pl-k">var</span> z <span class="pl-k">=</span> MyCoolArray.of( <span class="pl-c1">3</span> );
z.<span class="pl-c1">length</span>;                       <span class="pl-c">// 1</span>
z.sum();                        <span class="pl-c">// 3</span></pre></div>

<p>You can't just (easily) create a constructor for <code>MyCoolArray</code> that overrides the behavior of the <code>Array</code> parent constructor, because that constructor is necessary to actually create a well-behaving array value (initializing the <code>this</code>). The "inherited" static <code>of(..)</code> method on the <code>MyCoolArray</code> subclass provides a nice solution.</p>

<h3><a id="user-content-arrayfrom-static-function" class="anchor" href="#arrayfrom-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array.from(..)</code> Static Function</h3>

<p>An "array-like object" in JavaScript is an object that has a <code>length</code> property on it, specifically with an integer value of zero or higher.</p>

<p>These values have been notoriously frustrating to work with in JS; it's been quite common to need to transform them into an actual array, so that the various <code>Array.prototype</code> methods (<code>map(..)</code>, <code>indexOf(..)</code> etc.) are available to use with it. That process usually looks like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// array-like object</span>
<span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">3</span>,
    <span class="pl-c1">0</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>,
    <span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
};

<span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.slice.<span class="pl-c1">call</span>( arrLike );</pre></div>

<p>Another common task where <code>slice(..)</code> is often used is in duplicating a real array:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr2 <span class="pl-k">=</span> arr.<span class="pl-c1">slice</span>();</pre></div>

<p>In both cases, the new ES6 <code>Array.from(..)</code> method can be a more understandable and graceful -- if also less verbose -- approach:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( arrLike );

<span class="pl-k">var</span> arrCopy <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( arr );</pre></div>

<p><code>Array.from(..)</code> looks to see if the first argument is an iterable (see "Iterators" in Chapter 3), and if so, it uses the iterator to produce values to "copy" into the returned array. Because real arrays have an iterator for those values, that iterator is automatically used.</p>

<p>But if you pass an array-like object as the first argument to <code>Array.from(..)</code>, it behaves basically the same as <code>slice()</code> (no arguments!) or <code>apply(..)</code> does, which is that it simply loops over the value, accessing numerically named properties from <code>0</code> up to whatever the value of <code>length</code> is.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">4</span>,
    <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>
};

<span class="pl-c1">Array</span>.from( arrLike );
<span class="pl-c">// [ undefined, undefined, "foo", undefined ]</span></pre></div>

<p>Because positions <code>0</code>, <code>1</code>, and <code>3</code> didn't exist on <code>arrLike</code>, the result was the <code>undefined</code> value for each of those slots.</p>

<p>You could produce a similar outcome like this:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> emptySlotsArr <span class="pl-k">=</span> [];
emptySlotsArr.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>;
emptySlotsArr[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">Array</span>.from( emptySlotsArr );
<span class="pl-c">// [ undefined, undefined, "foo", undefined ]</span></pre></div>

<h4><a id="user-content-avoiding-empty-slots" class="anchor" href="#avoiding-empty-slots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Avoiding Empty Slots</h4>

<p>There's a subtle but important difference in the previous snippet between the <code>emptySlotsArr</code> and the result of the <code>Array.from(..)</code> call. <code>Array.from(..)</code> never produces empty slots.</p>

<p>Prior to ES6, if you wanted to produce an array initialized to a certain length with actual <code>undefined</code> values in each slot (no empty slots!), you had to do extra work:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">4</span> );                             <span class="pl-c">// four empty slots!</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">apply</span>( <span class="pl-c1">null</span>, { length<span class="pl-k">:</span> <span class="pl-c1">4</span> } );     <span class="pl-c">// four `undefined` values</span></pre></div>

<p>But <code>Array.from(..)</code> now makes this easier:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-c1">Array</span>.from( { length<span class="pl-k">:</span> <span class="pl-c1">4</span> } );            <span class="pl-c">// four `undefined` values</span></pre></div>

<p><strong>Warning:</strong> Using an empty slot array like <code>a</code> in the previous snippets would work with some array functions, but others ignore empty slots (like <code>map(..)</code>, etc.). You should never intentionally work with empty slots, as it will almost certainly lead to strange/unpredictable behavior in your programs.</p>

<h4><a id="user-content-mapping" class="anchor" href="#mapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mapping</h4>

<p>The <code>Array.from(..)</code> utility has another helpful trick up its sleeve. The second argument, if provided, is a mapping callback (almost the same as the regular <code>Array#map(..)</code> expects) which is called to map/transform each value from the source to the returned target. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arrLike <span class="pl-k">=</span> {
    length<span class="pl-k">:</span> <span class="pl-c1">4</span>,
    <span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>
};

<span class="pl-c1">Array</span>.from( arrLike, <span class="pl-k">function</span> <span class="pl-en">mapper</span>(<span class="pl-smi">val</span>,<span class="pl-smi">idx</span>){
    <span class="pl-k">if</span> (<span class="pl-k">typeof</span> val <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
        <span class="pl-k">return</span> val.<span class="pl-c1">toUpperCase</span>();
    }
    <span class="pl-k">else</span> {
        <span class="pl-k">return</span> idx;
    }
} );
<span class="pl-c">// [ 0, 1, "FOO", 3 ]</span></pre></div>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>Array.from(..)</code> takes an optional third argument that if set will specify the <code>this</code> binding for the callback passed as the second argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<p>See "TypedArrays" in Chapter 5 for an example of using <code>Array.from(..)</code> in translating values from an array of 8-bit values to an array of 16-bit values.</p>

<h3><a id="user-content-creating-arrays-and-subtypes" class="anchor" href="#creating-arrays-and-subtypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating Arrays and Subtypes</h3>

<p>In the last couple of sections, we've discussed <code>Array.of(..)</code> and <code>Array.from(..)</code>, both of which create a new array in a similar way to a constructor. But what do they do in subclasses? Do they create instances of the base <code>Array</code> or the derived subclass?</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    ..
}

<span class="pl-c1">Array</span>.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                  <span class="pl-c">// true</span>
<span class="pl-c1">Array</span>.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;              <span class="pl-c">// true</span>

MyCoolArray.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;            <span class="pl-c">// false</span>
MyCoolArray.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;        <span class="pl-c">// false</span>

MyCoolArray.of( <span class="pl-c1">1</span>, <span class="pl-c1">2</span> ) <span class="pl-k">instanceof</span> MyCoolArray;      <span class="pl-c">// true</span>
MyCoolArray.from( [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>] ) <span class="pl-k">instanceof</span> MyCoolArray;  <span class="pl-c">// true</span></pre></div>

<p>Both <code>of(..)</code> and <code>from(..)</code> use the constructor that they're accessed from to construct the array. So if you use the base <code>Array.of(..)</code> you'll get an <code>Array</code> instance, but if you use <code>MyCoolArray.of(..)</code>, you'll get a <code>MyCoolArray</code> instance.</p>

<p>In "Classes" in Chapter 3, we covered the <code>@@species</code> setting which all the built-in classes (like <code>Array</code>) have defined, which is used by any prototype methods if they create a new instance. <code>slice(..)</code> is a great example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> MyCoolArray;                <span class="pl-c">// true</span></pre></div>

<p>Generally, that default behavior will probably be desired, but as we discussed in Chapter 3, you <em>can</em> override if you want:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> MyCoolArray;                <span class="pl-c">// false</span>
x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                      <span class="pl-c">// true</span></pre></div>

<p>It's important to note that the <code>@@species</code> setting is only used for the prototype methods, like <code>slice(..)</code>. It's not used by <code>of(..)</code> and <code>from(..)</code>; they both just use the <code>this</code> binding (whatever constructor is used to make the reference). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">MyCoolArray</span> <span class="pl-k">extends</span> <span class="pl-en">Array</span> {
    <span class="pl-c">// force `species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-c1">Array</span>; }
}

<span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyCoolArray</span>( <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span> );

x.<span class="pl-c1">slice</span>( <span class="pl-c1">1</span> ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;                      <span class="pl-c">// true</span>

MyCoolArray.from( x ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;             <span class="pl-c">// false</span>
MyCoolArray.of( [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ) <span class="pl-k">instanceof</span> <span class="pl-c1">Array</span>;          <span class="pl-c">// false</span>

MyCoolArray.from( x ) <span class="pl-k">instanceof</span> MyCoolArray;       <span class="pl-c">// true</span>
MyCoolArray.of( [<span class="pl-c1">2</span>, <span class="pl-c1">3</span>] ) <span class="pl-k">instanceof</span> MyCoolArray;    <span class="pl-c">// true</span></pre></div>

<h3><a id="user-content-copywithin-prototype-method" class="anchor" href="#copywithin-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>copyWithin(..)</code> Prototype Method</h3>

<p><code>Array#copyWithin(..)</code> is a new mutator method available to all arrays (including Typed Arrays; see Chapter 5). <code>copyWithin(..)</code> copies a portion of an array to another location in the same array, overwriting whatever was there before.</p>

<p>The arguments are <em>target</em> (the index to copy to), <em>start</em> (the inclusive index to start the copying from), and optionally <em>end</em> (the exclusive index to stop copying). If any of the arguments are negative, they're taken to be relative from the end of the array.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">3</span>, <span class="pl-c1">0</span> );         <span class="pl-c">// [1,2,3,1,2]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span> );      <span class="pl-c">// [1,2,3,1,5]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">2</span> );        <span class="pl-c">// [4,5,3,4,5]</span>

[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-k">-</span><span class="pl-c1">1</span> );    <span class="pl-c">// [4,2,3,4,5]</span></pre></div>

<p>The <code>copyWithin(..)</code> method does not extend the array's length, as the first example in the previous snippet shows. Copying simply stops when the end of the array is reached.</p>

<p>Contrary to what you might think, the copying doesn't always go in left-to-right (ascending index) order. It's possible this would result in repeatedly copying an already copied value if the from and target ranges overlap, which is presumably not desired behavior.</p>

<p>So internally, the algorithm avoids this case by copying in reverse order to avoid that gotcha. Consider:</p>

<div class="highlight highlight-source-js"><pre>[<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>].copyWithin( <span class="pl-c1">2</span>, <span class="pl-c1">1</span> );     <span class="pl-c">// ???</span></pre></div>

<p>If the algorithm was strictly moving left to right, then the <code>2</code> should be copied to overwrite the <code>3</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>4</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>5</code>, and you'd end up with <code>[1,2,2,2,2]</code>.</p>

<p>Instead, the copying algorithm reverses direction and copies <code>4</code> to overwrite <code>5</code>, then copies <code>3</code> to overwrite <code>4</code>, then copies <code>2</code> to overwrite <code>3</code>, and the final result is <code>[1,2,2,3,4]</code>. That's probably more "correct" in terms of expectation, but it can be confusing if you're only thinking about the copying algorithm in a naive left-to-right fashion.</p>

<h3><a id="user-content-fill-prototype-method" class="anchor" href="#fill-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>fill(..)</code> Prototype Method</h3>

<p>Filling an existing array entirely (or partially) with a specified value is natively supported as of ES6 with the <code>Array#fill(..)</code> method:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">Array</span>( <span class="pl-c1">4</span> ).fill( <span class="pl-c1">undefined</span> );
a;
<span class="pl-c">// [undefined,undefined,undefined,undefined]</span></pre></div>

<p><code>fill(..)</code> optionally takes <em>start</em> and <em>end</em> parameters, which indicate a subset portion of the array to fill, such as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [ <span class="pl-c1">null</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span> ].fill( <span class="pl-c1">42</span>, <span class="pl-c1">1</span>, <span class="pl-c1">3</span> );

a;                                  <span class="pl-c">// [null,42,42,null]</span></pre></div>

<h3><a id="user-content-find-prototype-method" class="anchor" href="#find-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>find(..)</code> Prototype Method</h3>

<p>The most common way to search for a value in an array has generally been the <code>indexOf(..)</code> method, which returns the index the value is found at or <code>-1</code> if not found:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

(a.<span class="pl-c1">indexOf</span>( <span class="pl-c1">3</span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);             <span class="pl-c">// true</span>
(a.<span class="pl-c1">indexOf</span>( <span class="pl-c1">7</span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);             <span class="pl-c">// false</span>

(a.<span class="pl-c1">indexOf</span>( <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span> ) <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>);           <span class="pl-c">// false</span></pre></div>

<p>The <code>indexOf(..)</code> comparison requires a strict <code>===</code> match, so a search for <code>"2"</code> fails to find a value of <code>2</code>, and vice versa. There's no way to override the matching algorithm for <code>indexOf(..)</code>. It's also unfortunate/ungraceful to have to make the manual comparison to the <code>-1</code> value.</p>

<p><strong>Tip:</strong> See the <em>Types &amp; Grammar</em> title of this series for an interesting (and controversially confusing) technique to work around the <code>-1</code> ugliness with the <code>~</code> operator.</p>

<p>Since ES5, the most common workaround to have control over the matching logic has been the <code>some(..)</code> method. It works by calling a function callback for each element, until one of those calls returns a <code>true</code>/truthy value, and then it stops. Because you get to define the callback function, you have full control over how a match is made:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a.some( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>;
} );                                <span class="pl-c">// true</span>

a.some( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-c1">7</span>;
} );                                <span class="pl-c">// false</span></pre></div>

<p>But the downside to this approach is that you only get the <code>true</code>/<code>false</code> indicating if a suitably matched value was found, but not what the actual matched value was.</p>

<p>ES6's <code>find(..)</code> addresses this. It works basically the same as <code>some(..)</code>, except that once the callback returns a <code>true</code>/truthy value, the actual array value is returned:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

a.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>;
} );                                <span class="pl-c">// 2</span>

a.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">v</span>){
    <span class="pl-k">return</span> v <span class="pl-k">==</span> <span class="pl-c1">7</span>;                  <span class="pl-c">// undefined</span>
});</pre></div>

<p>Using a custom <code>matcher(..)</code> function also lets you match against complex values like objects:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> points <span class="pl-k">=</span> [
    { x<span class="pl-k">:</span> <span class="pl-c1">10</span>, y<span class="pl-k">:</span> <span class="pl-c1">20</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">20</span>, y<span class="pl-k">:</span> <span class="pl-c1">30</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">30</span>, y<span class="pl-k">:</span> <span class="pl-c1">40</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">40</span>, y<span class="pl-k">:</span> <span class="pl-c1">50</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">50</span>, y<span class="pl-k">:</span> <span class="pl-c1">60</span> }
];

points.<span class="pl-c1">find</span>( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// { x: 30, y: 40 }</span></pre></div>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<h3><a id="user-content-findindex-prototype-method" class="anchor" href="#findindex-prototype-method" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>findIndex(..)</code> Prototype Method</h3>

<p>While the previous section illustrates how <code>some(..)</code> yields a boolean result for a search of an array, and <code>find(..)</code> yields the matched value itself from the array search, there's also a need for finding the positional index of the matched value.</p>

<p><code>indexOf(..)</code> does that, but there's no control over its matching logic; it always uses <code>===</code> strict equality. So ES6's <code>findIndex(..)</code> is the answer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> points <span class="pl-k">=</span> [
    { x<span class="pl-k">:</span> <span class="pl-c1">10</span>, y<span class="pl-k">:</span> <span class="pl-c1">20</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">20</span>, y<span class="pl-k">:</span> <span class="pl-c1">30</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">30</span>, y<span class="pl-k">:</span> <span class="pl-c1">40</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">40</span>, y<span class="pl-k">:</span> <span class="pl-c1">50</span> },
    { x<span class="pl-k">:</span> <span class="pl-c1">50</span>, y<span class="pl-k">:</span> <span class="pl-c1">60</span> }
];

points.findIndex( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">4</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// 2</span>

points.findIndex( <span class="pl-k">function</span> <span class="pl-en">matcher</span>(<span class="pl-smi">point</span>) {
    <span class="pl-k">return</span> (
        point.<span class="pl-c1">x</span> <span class="pl-k">%</span> <span class="pl-c1">6</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span>
        point.<span class="pl-c1">y</span> <span class="pl-k">%</span> <span class="pl-c1">7</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
    );
} );                                <span class="pl-c">// -1</span></pre></div>

<p>Don't use <code>findIndex(..) != -1</code> (the way it's always been done with <code>indexOf(..)</code>) to get a boolean from the search, because <code>some(..)</code> already yields the <code>true</code>/<code>false</code> you want. And don't do <code>a[ a.findIndex(..) ]</code> to get the matched value, because that's what <code>find(..)</code> accomplishes. And finally, use <code>indexOf(..)</code> if you need the index of a strict match, or <code>findIndex(..)</code> if you need the index of a more customized match.</p>

<p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>

<h3><a id="user-content-entries-values-keys-prototype-methods" class="anchor" href="#entries-values-keys-prototype-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>entries()</code>, <code>values()</code>, <code>keys()</code> Prototype Methods</h3>

<p>In Chapter 3, we illustrated how data structures can provide a patterned item-by-item enumeration of their values, via an iterator. We then expounded on this approach in Chapter 5, as we explored how the new ES6 collections (Map, Set, etc.) provide several methods for producing different kinds of iterations.</p>

<p>Because it's not new to ES6, <code>Array</code> might not be thought of traditionally as a "collection," but it is one in the sense that it provides these same iterator methods: <code>entries()</code>, <code>values()</code>, and <code>keys()</code>. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>];

[...a.values()];                    <span class="pl-c">// [1,2,3]</span>
[...a.keys()];                      <span class="pl-c">// [0,1,2]</span>
[...a.entries()];                   <span class="pl-c">// [ [0,1], [1,2], [2,3] ]</span>

[...a[Symbol.iterator]()];          <span class="pl-c">// [1,2,3]</span></pre></div>

<p>Just like with <code>Set</code>, the default <code>Array</code> iterator is the same as what <code>values()</code> returns.</p>

<p>In "Avoiding Empty Slots" earlier in this chapter, we illustrated how <code>Array.from(..)</code> treats empty slots in an array as just being present slots with <code>undefined</code> in them. That's actually because under the covers, the array iterators behave that way:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [];
a.<span class="pl-c1">length</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>;
a[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">2</span>;

[...a.values()];        <span class="pl-c">// [undefined,2,undefined]</span>
[...a.keys()];          <span class="pl-c">// [0,1,2]</span>
[...a.entries()];       <span class="pl-c">// [ [0,undefined], [1,2], [2,undefined] ]</span></pre></div>

<h2><a id="user-content-object" class="anchor" href="#object" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object</code></h2>

<p>A few additional static helpers have been added to <code>Object</code>. Traditionally, functions of this sort have been seen as focused on the behaviors/capabilities of object values.</p>

<p>However, starting with ES6, <code>Object</code> static functions will also be for general-purpose global APIs of any sort that don't already belong more naturally in some other location (i.e., <code>Array.from(..)</code>).</p>

<h3><a id="user-content-objectis-static-function" class="anchor" href="#objectis-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.is(..)</code> Static Function</h3>

<p>The <code>Object.is(..)</code> static function makes value comparisons in an even more strict fashion than the <code>===</code> comparison.</p>

<p><code>Object.is(..)</code> invokes the underlying <code>SameValue</code> algorithm (ES6 spec, section 7.2.9). The <code>SameValue</code> algorithm is basically the same as the <code>===</code> Strict Equality Comparison Algorithm (ES6 spec, section 7.2.13), with two important exceptions.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, y <span class="pl-k">=</span> <span class="pl-c1">0</span>, z <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">0</span>;

x <span class="pl-k">===</span> x;                            <span class="pl-c">// false</span>
y <span class="pl-k">===</span> z;                            <span class="pl-c">// true</span>

<span class="pl-c1">Object</span>.is( x, x );                  <span class="pl-c">// true</span>
<span class="pl-c1">Object</span>.is( y, z );                  <span class="pl-c">// false</span></pre></div>

<p>You should continue to use <code>===</code> for strict equality comparisons; <code>Object.is(..)</code> shouldn't be thought of as a replacement for the operator. However, in cases where you're trying to strictly identify a <code>NaN</code> or <code>-0</code> value, <code>Object.is(..)</code> is now the preferred option.</p>

<p><strong>Note:</strong> ES6 also adds a <code>Number.isNaN(..)</code> utility (discussed later in this chapter) which may be a slightly more convenient test; you may prefer <code>Number.isNaN(x)</code> over <code>Object.is(x,NaN)</code>. You <em>can</em> accurately test for <code>-0</code> with a clumsy <code>x == 0 &amp;&amp; 1 / x === -Infinity</code>, but in this case <code>Object.is(x,-0)</code> is much better.</p>

<h3><a id="user-content-objectgetownpropertysymbols-static-function" class="anchor" href="#objectgetownpropertysymbols-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.getOwnPropertySymbols(..)</code> Static Function</h3>

<p>The "Symbols" section in Chapter 2 discusses the new Symbol primitive value type in ES6.</p>

<p>Symbols are likely going to be mostly used as special (meta) properties on objects. So the <code>Object.getOwnPropertySymbols(..)</code> utility was introduced, which retrieves only the symbol properties directly on an object:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-c1">42</span>,
    [ Symbol( <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> ) ]<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>,
    baz<span class="pl-k">:</span> <span class="pl-c1">true</span>
};

<span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [ Symbol(bar) ]</span></pre></div>

<h3><a id="user-content-objectsetprototypeof-static-function" class="anchor" href="#objectsetprototypeof-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.setPrototypeOf(..)</code> Static Function</h3>

<p>Also in Chapter 2, we mentioned the <code>Object.setPrototypeOf(..)</code> utility, which (unsurprisingly) sets the <code>[[Prototype]]</code> of an object for the purposes of <em>behavior delegation</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};
<span class="pl-k">var</span> o2 <span class="pl-k">=</span> {
    <span class="pl-c">// .. o2's definition ..</span>
};

<span class="pl-c1">Object</span>.setPrototypeOf( o2, o1 );

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p>Alternatively:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.setPrototypeOf( {
    <span class="pl-c">// .. o2's definition ..</span>
}, o1 );

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p>In both previous snippets, the relationship between <code>o2</code> and <code>o1</code> appears at the end of the <code>o2</code> definition. More commonly, the relationship between an <code>o2</code> and <code>o1</code> is specified at the top of the <code>o2</code> definition, as it is with classes, and also with <code>__proto__</code> in object literals (see "Setting <code>[[Prototype]]</code>" in Chapter 2).</p>

<p><strong>Warning:</strong> Setting a <code>[[Prototype]]</code> right after object creation is reasonable, as shown. But changing it much later is generally not a good idea and will usually lead to more confusion than clarity.</p>

<h3><a id="user-content-objectassign-static-function" class="anchor" href="#objectassign-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.assign(..)</code> Static Function</h3>

<p>Many JavaScript libraries/frameworks provide utilities for copying/mixing one object's properties into another (e.g., jQuery's <code>extend(..)</code>). There are various nuanced differences between these different utilities, such as whether a property with value <code>undefined</code> is ignored or not.</p>

<p>ES6 adds <code>Object.assign(..)</code>, which is a simplified version of these algorithms. The first argument is the <em>target</em>, and any other arguments passed are the <em>sources</em>, which will be processed in listed order. For each source, its enumerable and own (e.g., not "inherited") keys, including symbols, are copied as if by plain <code>=</code> assignment. <code>Object.assign(..)</code> returns the target object.</p>

<p>Consider this object setup:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> target <span class="pl-k">=</span> {},
    o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> }, o2 <span class="pl-k">=</span> { b<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    o3 <span class="pl-k">=</span> { c<span class="pl-k">:</span> <span class="pl-c1">3</span> }, o4 <span class="pl-k">=</span> { d<span class="pl-k">:</span> <span class="pl-c1">4</span> };

<span class="pl-c">// setup read-only property</span>
<span class="pl-c1">Object</span>.defineProperty( o3, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">5</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    writable<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    configurable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

<span class="pl-c">// setup non-enumerable property</span>
<span class="pl-c1">Object</span>.defineProperty( o3, <span class="pl-s"><span class="pl-pds">"</span>f<span class="pl-pds">"</span></span>, {
    value<span class="pl-k">:</span> <span class="pl-c1">6</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

o3[ Symbol( <span class="pl-s"><span class="pl-pds">"</span>g<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> <span class="pl-c1">7</span>;

<span class="pl-c">// setup non-enumerable symbol</span>
<span class="pl-c1">Object</span>.defineProperty( o3, Symbol( <span class="pl-s"><span class="pl-pds">"</span>h<span class="pl-pds">"</span></span> ), {
    value<span class="pl-k">:</span> <span class="pl-c1">8</span>,
    enumerable<span class="pl-k">:</span> <span class="pl-c1">false</span>
} );

<span class="pl-c1">Object</span>.setPrototypeOf( o3, o4 );</pre></div>

<p>Only the properties <code>a</code>, <code>b</code>, <code>c</code>, <code>e</code>, and <code>Symbol("g")</code> will be copied to <code>target</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Object</span>.assign( target, o1, o2, o3 );

target.a;                           <span class="pl-c">// 1</span>
target.b;                           <span class="pl-c">// 2</span>
target.c;                           <span class="pl-c">// 3</span>

<span class="pl-c1">Object</span>.getOwnPropertyDescriptor( target, <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-pds">"</span></span> );
<span class="pl-c">// { value: 5, writable: true, enumerable: true,</span>
<span class="pl-c">//   configurable: true }</span>

<span class="pl-c1">Object</span>.getOwnPropertySymbols( target );
<span class="pl-c">// [Symbol("g")]</span></pre></div>

<p>The <code>d</code>, <code>f</code>, and <code>Symbol("h")</code> properties are omitted from copying; non-enumerable properties and non-owned properties are all excluded from the assignment. Also, <code>e</code> is copied as a normal property assignment, not duplicated as a read-only property.</p>

<p>In an earlier section, we showed using <code>setPrototypeOf(..)</code> to set up a <code>[[Prototype]]</code> relationship between an <code>o2</code> and <code>o1</code> object. There's another form that leverages <code>Object.assign(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ); }
};

<span class="pl-k">var</span> o2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign(
    <span class="pl-c1">Object</span>.create( o1 ),
    {
        <span class="pl-c">// .. o2's definition ..</span>
    }
);

<span class="pl-c">// delegates to `o1.foo()`</span>
o2.foo();                           <span class="pl-c">// foo</span></pre></div>

<p><strong>Note:</strong> <code>Object.create(..)</code> is the ES5 standard utility that creates an empty object that is <code>[[Prototype]]</code>-linked. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<h2><a id="user-content-math" class="anchor" href="#math" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Math</code></h2>

<p>ES6 adds several new mathematic utilities that fill in holes or aid with common operations. All of these can be manually calculated, but most of them are now defined natively so that in some cases the JS engine can either more optimally perform the calculations, or perform them with better decimal precision than their manual counterparts.</p>

<p>It's likely that asm.js/transpiled JS code (see the <em>Async &amp; Performance</em> title of this series) is the more likely consumer of many of these utilities rather than direct developers.</p>

<p>Trigonometry:</p>

<ul>
<li><code>cosh(..)</code> - Hyperbolic cosine</li>
<li><code>acosh(..)</code> - Hyperbolic arccosine</li>
<li><code>sinh(..)</code> - Hyperbolic sine</li>
<li><code>asinh(..)</code> - Hyperbolic arcsine</li>
<li><code>tanh(..)</code> - Hyperbolic tangent</li>
<li><code>atanh(..)</code> - Hyperbolic arctangent</li>
<li><code>hypot(..)</code> - The squareroot of the sum of the squares (i.e., the generalized Pythagorean theorem)</li>
</ul>

<p>Arithmetic:</p>

<ul>
<li><code>cbrt(..)</code> - Cube root</li>
<li><code>clz32(..)</code> - Count leading zeros in 32-bit binary representation</li>
<li><code>expm1(..)</code> - The same as <code>exp(x) - 1</code></li>
<li><code>log2(..)</code> - Binary logarithm (log base 2)</li>
<li><code>log10(..)</code> - Log base 10</li>
<li><code>log1p(..)</code> - The same as <code>log(x + 1)</code></li>
<li><code>imul(..)</code> - 32-bit integer multiplication of two numbers</li>
</ul>

<p>Meta:</p>

<ul>
<li><code>sign(..)</code> - Returns the sign of the number</li>
<li><code>trunc(..)</code> - Returns only the integer part of a number</li>
<li><code>fround(..)</code> - Rounds to nearest 32-bit (single precision) floating-point value</li>
</ul>

<h2><a id="user-content-number" class="anchor" href="#number" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number</code></h2>

<p>Importantly, for your program to properly work, it must accurately handle numbers. ES6 adds some additional properties and functions to assist with common numeric operations.</p>

<p>Two additions to <code>Number</code> are just references to the preexisting globals: <code>Number.parseInt(..)</code> and <code>Number.parseFloat(..)</code>.</p>

<h3><a id="user-content-static-properties" class="anchor" href="#static-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Static Properties</h3>

<p>ES6 adds some helpful numeric constants as static properties:</p>

<ul>
<li><code>Number.EPSILON</code> - The minimum value between any two numbers: <code>2^-52</code> (see Chapter 2 of the <em>Types &amp; Grammar</em> title of this series regarding using this value as a tolerance for imprecision in floating-point arithmetic)</li>
<li><code>Number.MAX_SAFE_INTEGER</code> - The highest integer that can "safely" be represented unambiguously in a JS number value: <code>2^53 - 1</code></li>
<li><code>Number.MIN_SAFE_INTEGER</code> - The lowest integer that can "safely" be represented unambiguously in a JS number value: <code>-(2^53 - 1)</code> or <code>(-2)^53 + 1</code>.</li>
</ul>

<p><strong>Note:</strong> See Chapter 2 of the <em>Types &amp; Grammar</em> title of this series for more information about "safe" integers.</p>

<h3><a id="user-content-numberisnan-static-function" class="anchor" href="#numberisnan-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number.isNaN(..)</code> Static Function</h3>

<p>The standard global <code>isNaN(..)</code> utility has been broken since its inception, in that it returns <code>true</code> for things that are not numbers, not just for the actual <code>NaN</code> value, because it coerces the argument to a number type (which can falsely result in a NaN). ES6 adds a fixed utility <code>Number.isNaN(..)</code> that works as it should:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>NaN<span class="pl-pds">"</span></span>, c <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c1">isNaN</span>( a );                         <span class="pl-c">// true</span>
<span class="pl-c1">isNaN</span>( b );                         <span class="pl-c">// true -- oops!</span>
<span class="pl-c1">isNaN</span>( c );                         <span class="pl-c">// false</span>

<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( a );                  <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( b );                  <span class="pl-c">// false -- fixed!</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isNaN</span>( c );                  <span class="pl-c">// false</span></pre></div>

<h3><a id="user-content-numberisfinite-static-function" class="anchor" href="#numberisfinite-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Number.isFinite(..)</code> Static Function</h3>

<p>There's a temptation to look at a function name like <code>isFinite(..)</code> and assume it's simply "not infinite". That's not quite correct, though. There's more nuance to this new ES6 utility. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">NaN</span>, b <span class="pl-k">=</span> <span class="pl-c1">Infinity</span>, c <span class="pl-k">=</span> <span class="pl-c1">42</span>;

<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( a );               <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( b );               <span class="pl-c">// false</span>

<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( c );               <span class="pl-c">// true</span></pre></div>

<p>The standard global <code>isFinite(..)</code> coerces its argument, but <code>Number.isFinite(..)</code> omits the coercive behavior:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>;

<span class="pl-c1">isFinite</span>( a );                      <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( a );               <span class="pl-c">// false</span></pre></div>

<p>You may still prefer the coercion, in which case using the global <code>isFinite(..)</code> is a valid choice. Alternatively, and perhaps more sensibly, you can use <code>Number.isFinite(+x)</code>, which explicitly coerces <code>x</code> to a number before passing it in (see Chapter 4 of the <em>Types &amp; Grammar</em> title of this series).</p>

<h3><a id="user-content-integer-related-static-functions" class="anchor" href="#integer-related-static-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Integer-Related Static Functions</h3>

<p>JavaScript number valuess are always floating point (IEE-754). So the notion of determining if a number is an "integer" is not about checking its type, because JS makes no such distinction.</p>

<p>Instead, you need to check if there's any non-zero decimal portion of the value. The easiest way to do that has commonly been:</p>

<div class="highlight highlight-source-js"><pre>x <span class="pl-k">===</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>( x );</pre></div>

<p>ES6 adds a <code>Number.isInteger(..)</code> helper utility that potentially can determine this quality slightly more efficiently:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">4</span> );              <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">4.2</span> );            <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> In JavaScript, there's no difference between <code>4</code>, <code>4.</code>, <code>4.0</code>, or <code>4.0000</code>. All of these would be considered an "integer", and would thus yield <code>true</code> from <code>Number.isInteger(..)</code>.</p>

<p>In addition, <code>Number.isInteger(..)</code> filters out some clearly not-integer values that <code>x === Math.floor(x)</code> could potentially mix up:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">NaN</span> );            <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.isInteger( <span class="pl-c1">Infinity</span> );       <span class="pl-c">// false</span></pre></div>

<p>Working with "integers" is sometimes an important bit of information, as it can simplify certain kinds of algorithms. JS code by itself will not run faster just from filtering for only integers, but there are optimization techniques the engine can take (e.g., asm.js) when only integers are being used.</p>

<p>Because of <code>Number.isInteger(..)</code>'s handling of <code>NaN</code> and <code>Infinity</code> values, defining a <code>isFloat(..)</code> utility would not be just as simple as <code>!Number.isInteger(..)</code>. You'd need to do something like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">isFloat</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> <span class="pl-c1">Number</span>.<span class="pl-c1">isFinite</span>( x ) <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span><span class="pl-c1">Number</span>.isInteger( x );
}

isFloat( <span class="pl-c1">4.2</span> );                     <span class="pl-c">// true</span>
isFloat( <span class="pl-c1">4</span> );                       <span class="pl-c">// false</span>

isFloat( <span class="pl-c1">NaN</span> );                     <span class="pl-c">// false</span>
isFloat( <span class="pl-c1">Infinity</span> );                <span class="pl-c">// false</span></pre></div>

<p><strong>Note:</strong> It may seem strange, but Infinity should neither be considered an integer nor a float.</p>

<p>ES6 also defines a <code>Number.isSafeInteger(..)</code> utility, which checks to make sure the value is both an integer and within the range of <code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code> (inclusive).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">pow</span>( <span class="pl-c1">2</span>, <span class="pl-c1">53</span> ),
    y <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">pow</span>( <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">53</span> );

<span class="pl-c1">Number</span>.isSafeInteger( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );      <span class="pl-c">// true</span>
<span class="pl-c1">Number</span>.isSafeInteger( y <span class="pl-k">+</span> <span class="pl-c1">1</span> );      <span class="pl-c">// true</span>

<span class="pl-c1">Number</span>.isSafeInteger( x );          <span class="pl-c">// false</span>
<span class="pl-c1">Number</span>.isSafeInteger( y );          <span class="pl-c">// false</span></pre></div>

<h2><a id="user-content-string" class="anchor" href="#string" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>String</code></h2>

<p>Strings already have quite a few helpers prior to ES6, but even more have been added to the mix.</p>

<h3><a id="user-content-unicode-functions" class="anchor" href="#unicode-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unicode Functions</h3>

<p>"Unicode-Aware String Operations" in Chapter 2 discusses <code>String.fromCodePoint(..)</code>, <code>String#codePointAt(..)</code>, and <code>String#normalize(..)</code> in detail. They have been added to improve Unicode support in JS string values.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">String</span>.fromCodePoint( <span class="pl-c1">0x1d49e</span> );            <span class="pl-c">// "𝒞"</span>

<span class="pl-s"><span class="pl-pds">"</span>ab𝒞d<span class="pl-pds">"</span></span>.codePointAt( <span class="pl-c1">2</span> ).<span class="pl-c1">toString</span>( <span class="pl-c1">16</span> );      <span class="pl-c">// "1d49e"</span></pre></div>

<p>The <code>normalize(..)</code> string prototype method is used to perform Unicode normalizations that either combine characters with adjacent "combining marks" or decompose combined characters.</p>

<p>Generally, the normalization won't create a visible effect on the contents of the string, but will change the contents of the string, which can affect how things like the <code>length</code> property are reported, as well as how character access by position behave:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> s1 <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>e<span class="pl-cce">\u</span>0301<span class="pl-pds">"</span></span>;
s1.<span class="pl-c1">length</span>;                          <span class="pl-c">// 2</span>

<span class="pl-k">var</span> s2 <span class="pl-k">=</span> s1.normalize();
s2.<span class="pl-c1">length</span>;                          <span class="pl-c">// 1</span>
s2 <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\x</span>E9<span class="pl-pds">"</span></span>;                      <span class="pl-c">// true</span></pre></div>

<p><code>normalize(..)</code> takes an optional argument that specifies the normalization form to use. This argument must be one of the following four values: <code>"NFC"</code> (default), <code>"NFD"</code>, <code>"NFKC"</code>, or <code>"NFKD"</code>.</p>

<p><strong>Note:</strong> Normalization forms and their effects on strings is well beyond the scope of what we'll discuss here. See "Unicode Normalization Forms" (<a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a>) for more information.</p>

<h3><a id="user-content-stringraw-static-function" class="anchor" href="#stringraw-static-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>String.raw(..)</code> Static Function</h3>

<p>The <code>String.raw(..)</code> utility is provided as a built-in tag function to use with template string literals (see Chapter 2) for obtaining the raw string value without any processing of escape sequences.</p>

<p>This function will almost never be called manually, but will be used with tagged template literals:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bc<span class="pl-pds">"</span></span>;

<span class="pl-c1">String</span>.raw<span class="pl-s"><span class="pl-pds">`</span><span class="pl-cce">\t</span>a<span class="pl-s1"><span class="pl-pse">${</span>str<span class="pl-pse">}</span></span>d<span class="pl-cce">\x</span>E9<span class="pl-pds">`</span></span>;
<span class="pl-c">// "\tabcd\xE9", not "  abcdé"</span></pre></div>

<p>In the resultant string, <code>\</code> and <code>t</code> are separate raw characters, not the one escape sequence character <code>\t</code>. The same is true with the Unicode escape sequence.</p>

<h3><a id="user-content-repeat-prototype-function" class="anchor" href="#repeat-prototype-function" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>repeat(..)</code> Prototype Function</h3>

<p>In languages like Python and Ruby, you can repeat a string as:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">*</span> <span class="pl-c1">3</span>;                          <span class="pl-c">// "foofoofoo"</span></pre></div>

<p>That doesn't work in JS, because <code>*</code> multiplication is only defined for numbers, and thus <code>"foo"</code> coerces to the <code>NaN</code> number.</p>

<p>However, ES6 defines a string prototype method <code>repeat(..)</code> to accomplish the task:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>.repeat( <span class="pl-c1">3</span> );                  <span class="pl-c">// "foofoofoo"</span></pre></div>

<h3><a id="user-content-string-inspection-functions" class="anchor" href="#string-inspection-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>String Inspection Functions</h3>

<p>In addition to <code>String#indexOf(..)</code> and <code>String#lastIndexOf(..)</code> from prior to ES6, three new methods for searching/inspection have been added: <code>startsWith(..)</code>, <code>endsWidth(..)</code>, and <code>includes(..)</code>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> palindrome <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>step on no pets<span class="pl-pds">"</span></span>;

palindrome.startsWith( <span class="pl-s"><span class="pl-pds">"</span>step on<span class="pl-pds">"</span></span> ); <span class="pl-c">// true</span>
palindrome.startsWith( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span>, <span class="pl-c1">5</span> );   <span class="pl-c">// true</span>

palindrome.endsWith( <span class="pl-s"><span class="pl-pds">"</span>no pets<span class="pl-pds">"</span></span> );   <span class="pl-c">// true</span>
palindrome.endsWith( <span class="pl-s"><span class="pl-pds">"</span>no<span class="pl-pds">"</span></span>, <span class="pl-c1">10</span> );    <span class="pl-c">// true</span>

palindrome.includes( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span> );        <span class="pl-c">// true</span>
palindrome.includes( <span class="pl-s"><span class="pl-pds">"</span>on<span class="pl-pds">"</span></span>, <span class="pl-c1">6</span> );     <span class="pl-c">// false</span></pre></div>

<p>For all the string search/inspection methods, if you look for an empty string <code>""</code>, it will either be found at the beginning or the end of the string.</p>

<p><strong>Warning:</strong> These methods will not by default accept a regular expression for the search string. See "Regular Expression Symbols" in Chapter 7 for information about disabling the <code>isRegExp</code> check that is performed on this first argument.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>ES6 adds many extra API helpers on the various built-in native objects:</p>

<ul>
<li><code>Array</code> adds <code>of(..)</code> and <code>from(..)</code> static functions, as well as prototype functions like <code>copyWithin(..)</code> and <code>fill(..)</code>.</li>
<li><code>Object</code> adds static functions like <code>is(..)</code> and <code>assign(..)</code>.</li>
<li><code>Math</code> adds static functions like <code>acosh(..)</code> and <code>clz32(..)</code>.</li>
<li><code>Number</code> adds static properties like <code>Number.EPSILON</code>, as well as static functions like <code>Number.isFinite(..)</code>.</li>
<li><code>String</code> adds static functions like <code>String.fromCodePoint(..)</code> and <code>String.raw(..)</code>, as well as prototype functions like <code>repeat(..)</code> and <code>includes(..)</code>.</li>
</ul>

<p>Most of these additions can be polyfilled (see ES6 Shim), and were inspired by utilities in common JS libraries/frameworks.</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-7-meta-programming" class="anchor" href="#chapter-7-meta-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 7: Meta Programming</h1>

<p>Meta programming is programming where the operation targets the behavior of the program itself. In other words, it's programming the programming of your program. Yeah, a mouthful, huh?</p>

<p>For example, if you probe the relationship between one object <code>a</code> and another <code>b</code> -- are they <code>[[Prototype]]</code> linked? -- using <code>a.isPrototype(b)</code>, this is commonly referred to as introspection, a form of meta programming. Macros (which don't exist in JS, yet) --  where the code modifies itself at compile time -- are another obvious example of meta programming. Enumerating the keys of an object with a <code>for..in</code> loop, or checking if an object is an <em>instance of</em> a "class constructor", are other common meta programming tasks.</p>

<p>Meta programming focuses on one or more of the following: code inspecting itself, code modifying itself, or code modifying default language behavior so other code is affected.</p>

<p>The goal of meta programming is to leverage the language's own intrinsic capabilities to make the rest of your code more descriptive, expressive, and/or flexible. Because of the <em>meta</em> nature of meta programming, it's somewhat difficult to put a more precise definition on it than that. The best way to understand meta programming is to see it through examples.</p>

<p>ES6 adds several new forms/features for meta programming on top of what JS already had.</p>

<h2><a id="user-content-function-names" class="anchor" href="#function-names" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Names</h2>

<p>There are cases where your code may want to introspect on itself and ask what the name of some function is. If you ask what a function's name is, the answer is surprisingly somewhat ambiguous. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">daz</span>() {
    <span class="pl-c">// ..</span>
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> {
    <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">function</span>() {
        <span class="pl-c">// ..</span>
    },
    <span class="pl-en">bar</span><span class="pl-k">:</span> <span class="pl-k">function</span> <span class="pl-en">baz</span>() {
        <span class="pl-c">// ..</span>
    },
    bam<span class="pl-k">:</span> daz,
    <span class="pl-en">zim</span>() {
        <span class="pl-c">// ..</span>
    }
};</pre></div>

<p>In this previous snippet, "what is the name of <code>obj.foo()</code>" is slightly nuanced. Is it <code>"foo"</code>, <code>""</code>, or <code>undefined</code>? And what about <code>obj.bar()</code> -- is it named <code>"bar"</code> or <code>"baz"</code>? Is <code>obj.bam()</code> named <code>"bam"</code> or <code>"daz"</code>? What about <code>obj.zim()</code>?</p>

<p>Moreover, what about functions which are passed as callbacks, like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">cb</span>) {
    <span class="pl-c">// what is the name of `cb()` here?</span>
}

foo( <span class="pl-k">function</span>(){
    <span class="pl-c">// I'm anonymous!</span>
} );</pre></div>

<p>There are quite a few ways that functions can be expressed in programs, and it's not always clear and unambiguous what the "name" of that function should be.</p>

<p>More importantly, we need to distinguish whether the "name" of a function refers to its <code>name</code> property -- yes, functions have a property called <code>name</code> -- or whether it refers to the lexical binding name, such as <code>bar</code> in <code>function bar() { .. }</code>.</p>

<p>The lexical binding name is what you use for things like recursion:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">i</span>) {
    <span class="pl-k">if</span> (i <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>) <span class="pl-k">return</span> foo( i <span class="pl-k">*</span> <span class="pl-c1">2</span> );
    <span class="pl-k">return</span> i;
}</pre></div>

<p>The <code>name</code> property is what you'd use for meta programming purposes, so that's what we'll focus on in this discussion.</p>

<p>The confusion comes because by default, the lexical name a function has (if any) is also set as its <code>name</code> property. Actually there was no official requirement for that behavior by the ES5 (and prior) specifications. The setting of the <code>name</code> property was nonstandard but still fairly reliable. As of ES6, it has been standardized.</p>

<p><strong>Tip:</strong> If a function has a <code>name</code> value assigned, that's typically the name used in stack traces in developer tools.</p>

<h3><a id="user-content-inferences" class="anchor" href="#inferences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inferences</h3>

<p>But what happens to the <code>name</code> property if a function has no lexical name?</p>

<p>As of ES6, there are now inference rules which can determine a sensible <code>name</code> property value to assign a function even if that function doesn't have a lexical name to use.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">abc</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-c">// ..</span>
};

abc.<span class="pl-c1">name</span>;               <span class="pl-c">// "abc"</span></pre></div>

<p>Had we given the function a lexical name like <code>abc = function def() { .. }</code>, the <code>name</code> property would of course be <code>"def"</code>. But in the absence of the lexical name, intuitively the <code>"abc"</code> name seems appropriate.</p>

<p>Here are other forms that will infer a name (or not) in ES6:</p>

<div class="highlight highlight-source-js"><pre>(<span class="pl-k">function</span>(){ .. });                 <span class="pl-c">// name:</span>
(<span class="pl-k">function*</span>(){ .. });                <span class="pl-c">// name:</span>
<span class="pl-c1">window</span>.<span class="pl-en">foo</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){ .. };      <span class="pl-c">// name:</span>

<span class="pl-k">class</span> <span class="pl-en">Awesome</span> {
    <span class="pl-en">constructor</span>() { .. }            <span class="pl-c">// name: Awesome</span>
    <span class="pl-en">funny</span>() { .. }                  <span class="pl-c">// name: funny</span>
}

<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-k">class</span> <span class="pl-en">Awesome</span> { .. };       <span class="pl-c">// name: Awesome</span>

<span class="pl-k">var</span> o <span class="pl-k">=</span> {
    <span class="pl-en">foo</span>() { .. },                   <span class="pl-c">// name: foo</span>
    <span class="pl-k">*</span><span class="pl-en">bar</span>() { .. },                  <span class="pl-c">// name: bar</span>
    baz<span class="pl-k">:</span> ()<span class="pl-k"> =&gt;</span> { .. },              <span class="pl-c">// name: baz</span>
    <span class="pl-en">bam</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){ .. },          <span class="pl-c">// name: bam</span>
    get <span class="pl-en">qux</span>() { .. },               <span class="pl-c">// name: get qux</span>
    set <span class="pl-en">fuz</span>() { .. },               <span class="pl-c">// name: set fuz</span>
    [<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>iz<span class="pl-pds">"</span></span>]<span class="pl-k">:</span>
        <span class="pl-k">function</span>(){ .. },           <span class="pl-c">// name: biz</span>
    [Symbol( <span class="pl-s"><span class="pl-pds">"</span>buz<span class="pl-pds">"</span></span> )]<span class="pl-k">:</span>
        <span class="pl-k">function</span>(){ .. }            <span class="pl-c">// name: [buz]</span>
};

<span class="pl-k">var</span> x <span class="pl-k">=</span> o.foo.bind( o );            <span class="pl-c">// name: bound foo</span>
(<span class="pl-k">function</span>(){ .. }).bind( o );       <span class="pl-c">// name: bound</span>

<span class="pl-k">export</span> <span class="pl-k">default</span> <span class="pl-k">function</span>() { .. }    <span class="pl-c">// name: default</span>

<span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Function</span>();             <span class="pl-c">// name: anonymous</span>
<span class="pl-k">var</span> GeneratorFunction <span class="pl-k">=</span>
    <span class="pl-k">function*</span>(){}.__proto__.<span class="pl-c1">constructor</span>;
<span class="pl-k">var</span> z <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GeneratorFunction</span>();    <span class="pl-c">// name: anonymous</span></pre></div>

<p>The <code>name</code> property is not writable by default, but it is configurable, meaning you can use <code>Object.defineProperty(..)</code> to manually change it if so desired.</p>

<h2><a id="user-content-meta-properties" class="anchor" href="#meta-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meta Properties</h2>

<p>In the "<code>new.target</code>" section of Chapter 3, we introduced a concept new to JS in ES6: the meta property. As the name suggests, meta properties are intended to provide special meta information in the form of a property access that would otherwise not have been possible.</p>

<p>In the case of <code>new.target</code>, the keyword <code>new</code> serves as the context for a property access. Clearly <code>new</code> is itself not an object, which makes this capability special. However, when <code>new.target</code> is used inside a constructor call (a function/method invoked with <code>new</code>), <code>new</code> becomes a virtual context, so that <code>new.target</code> can refer to the target constructor that <code>new</code> invoked.</p>

<p>This is a clear example of a meta programming operation, as the intent is to determine from inside a constructor call what the original <code>new</code> target was, generally for the purposes of introspection (examining typing/structure) or static property access.</p>

<p>For example, you may want to have different behavior in a constructor depending on if it's directly invoked or invoked via a child class:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Parent</span> {
    <span class="pl-en">constructor</span>() {
        <span class="pl-k">if</span> (<span class="pl-k">new</span>.<span class="pl-c1">target</span> <span class="pl-k">===</span> Parent) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>Parent instantiated<span class="pl-pds">"</span></span> );
        }
        <span class="pl-k">else</span> {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>A child instantiated<span class="pl-pds">"</span></span> );
        }
    }
}

<span class="pl-k">class</span> <span class="pl-en">Child</span> <span class="pl-k">extends</span> <span class="pl-en">Parent</span> {}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Parent</span>();
<span class="pl-c">// Parent instantiated</span>

<span class="pl-k">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Child</span>();
<span class="pl-c">// A child instantiated</span></pre></div>

<p>There's a slight nuance here, which is that the <code>constructor()</code> inside the <code>Parent</code> class definition is actually given the lexical name of the class (<code>Parent</code>), even though the syntax implies that the class is a separate entity from the constructor.</p>

<p><strong>Warning:</strong> As with all meta programming techniques, be careful of creating code that's too clever for your future self or others maintaining your code to understand. Use these tricks with caution.</p>

<h2><a id="user-content-well-known-symbols" class="anchor" href="#well-known-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Well Known Symbols</h2>

<p>In the "Symbols" section of Chapter 2, we covered the new ES6 primitive type <code>symbol</code>. In addition to symbols you can define in your own program, JS predefines a number of built-in symbols, referred to as <em>Well Known Symbols</em> (WKS).</p>

<p>These symbol values are defined primarily to expose special meta properties that are being exposed to your JS programs to give you more control over JS's behavior.</p>

<p>We'll briefly introduce each and discuss their purpose.</p>

<h3><a id="user-content-symboliterator" class="anchor" href="#symboliterator" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.iterator</code></h3>

<p>In Chapters 2 and 3, we introduced and used the <code>@@iterator</code> symbol, automatically used by <code>...</code> spreads and <code>for..of</code> loops. We also saw <code>@@iterator</code> as defined on the new ES6 collections as defined in Chapter 5.</p>

<p><code>Symbol.iterator</code> represents the special location (property) on any object where the language mechanisms automatically look to find a method that will construct an iterator instance for consuming that object's values. Many objects come with a default one defined.</p>

<p>However, we can define our own iterator logic for any object value by setting the <code>Symbol.iterator</code> property, even if that's overriding the default iterator. The meta programming aspect is that we are defining behavior which other parts of JS (namely, operators and looping constructs) use when processing an object value we define.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>,<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>];

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> arr) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 4 5 6 7 8 9</span>

<span class="pl-c">// define iterator that only produces values</span>
<span class="pl-c">// from odd indexes</span>
arr[Symbol.iterator] <span class="pl-k">=</span> <span class="pl-k">function*</span>() {
    <span class="pl-k">var</span> idx <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">do</span> {
        <span class="pl-k">yield</span> <span class="pl-v">this</span>[idx];
    } <span class="pl-k">while</span> ((idx <span class="pl-k">+=</span> <span class="pl-c1">2</span>) <span class="pl-k">&lt;</span> <span class="pl-v">this</span>.<span class="pl-c1">length</span>);
};

<span class="pl-k">for</span> (<span class="pl-k">var</span> v <span class="pl-k">of</span> arr) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( v );
}
<span class="pl-c">// 5 7 9</span></pre></div>

<h3><a id="user-content-symboltostringtag-and-symbolhasinstance" class="anchor" href="#symboltostringtag-and-symbolhasinstance" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.toStringTag</code> and <code>Symbol.hasInstance</code></h3>

<p>One of the most common meta programming tasks is to introspect on a value to find out what <em>kind</em> it is, usually to decide what operations are appropriate to perform on it. With objects, the two most common inspection techniques are <code>toString()</code> and <code>instanceof</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>() {}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>();

a.<span class="pl-c1">toString</span>();               <span class="pl-c">// [object Object]</span>
a <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// true</span></pre></div>

<p>As of ES6, you can control the behavior of these operations:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Foo</span>(<span class="pl-smi">greeting</span>) {
    <span class="pl-v">this</span>.greeting <span class="pl-k">=</span> greeting;
}

Foo.<span class="pl-c1">prototype</span>[Symbol.toStringTag] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>;

<span class="pl-c1">Object</span>.defineProperty( Foo, Symbol.hasInstance, {
    <span class="pl-en">value</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">inst</span>) {
        <span class="pl-k">return</span> inst.greeting <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
    }
} );

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span> ),
    b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>( <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span> );

b[Symbol.toStringTag] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;

a.<span class="pl-c1">toString</span>();               <span class="pl-c">// [object Foo]</span>
<span class="pl-c1">String</span>( b );                <span class="pl-c">// [object cool]</span>

a <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// true</span>
b <span class="pl-k">instanceof</span> Foo;           <span class="pl-c">// false</span></pre></div>

<p>The <code>@@toStringTag</code> symbol on the prototype (or instance itself) specifies a string value to use in the <code>[object ___]</code> stringification.</p>

<p>The <code>@@hasInstance</code> symbol is a method on the constructor function which receives the instance object value and lets you decide by returning <code>true</code> or <code>false</code> if the value should be considered an instance or not.</p>

<p><strong>Note:</strong> To set <code>@@hasInstance</code> on a function, you must use <code>Object.defineProperty(..)</code>, as the default one on <code>Function.prototype</code> is <code>writable: false</code>. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>

<h3><a id="user-content-symbolspecies" class="anchor" href="#symbolspecies" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.species</code></h3>

<p>In "Classes" in Chapter 3, we introduced the <code>@@species</code> symbol, which controls which constructor is used by built-in methods of a class that needs to spawn new instances.</p>

<p>The most common example is when subclassing <code>Array</code> and wanting to define which constructor (<code>Array(..)</code> or your subclass) inherited methods like <code>slice(..)</code> should use. By default, <code>slice(..)</code> called on an instance of a subclass of <code>Array</code> would produce a new instance of that subclass, which is frankly what you'll likely often want.</p>

<p>However, you can meta program by overriding a class's default <code>@@species</code> definition:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">class</span> <span class="pl-en">Cool</span> {
    <span class="pl-c">// defer `@@species` to derived constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> <span class="pl-v">this</span>; }

    <span class="pl-en">again</span>() {
        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">this.constructor</span>[Symbol.species]();
    }
}

<span class="pl-k">class</span> <span class="pl-en">Fun</span> <span class="pl-k">extends</span> <span class="pl-en">Cool</span> {}

<span class="pl-k">class</span> <span class="pl-en">Awesome</span> <span class="pl-k">extends</span> <span class="pl-en">Cool</span> {
    <span class="pl-c">// force `@@species` to be parent constructor</span>
    <span class="pl-k">static</span> get [Symbol.species]() { <span class="pl-k">return</span> Cool; }
}

<span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fun</span>(),
    b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Awesome</span>(),
    c <span class="pl-k">=</span> a.again(),
    d <span class="pl-k">=</span> b.again();

c <span class="pl-k">instanceof</span> Fun;           <span class="pl-c">// true</span>
d <span class="pl-k">instanceof</span> Awesome;       <span class="pl-c">// false</span>
d <span class="pl-k">instanceof</span> Cool;          <span class="pl-c">// true</span></pre></div>

<p>The <code>Symbol.species</code> setting defaults on the built-in native constructors to the <code>return this</code> behavior as illustrated in the previous snippet in the <code>Cool</code> definition. It has no default on user classes, but as shown that behaivor is easy to emulate.</p>

<p>If you need to define methods that generate new instances, use the meta programming of the <code>new this.constructor[Symbol.species](..)</code> pattern instead of the hard-wiring of <code>new this.constructor(..)</code> or <code>new XYZ(..)</code>. Derived classes will then be able to customize <code>Symbol.species</code> to control which constructor vends those instances.</p>

<h3><a id="user-content-symboltoprimitive" class="anchor" href="#symboltoprimitive" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.toPrimitive</code></h3>

<p>In the <em>Types &amp; Grammar</em> title of this series, we discussed the <code>ToPrimitive</code> abstract coercion operation, which is used when an object must be coerced to a primitive value for some operation (such as <code>==</code> comparison or <code>+</code> addition). Prior to ES6, there was no way to control this behavior.</p>

<p>As of ES6, the <code>@@toPrimitive</code> symbol as a property on any object value can customize that <code>ToPrimitive</code> coercion by specifying a method.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> arr <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>];

arr <span class="pl-k">+</span> <span class="pl-c1">10</span>;               <span class="pl-c">// 1,2,3,4,510</span>

arr[Symbol.toPrimitive] <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">hint</span>) {
    <span class="pl-k">if</span> (hint <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>default<span class="pl-pds">"</span></span> <span class="pl-k">||</span> hint <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>number<span class="pl-pds">"</span></span>) {
        <span class="pl-c">// sum all numbers</span>
        <span class="pl-k">return</span> <span class="pl-v">this</span>.reduce( <span class="pl-k">function</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">curr</span>){
            <span class="pl-k">return</span> acc <span class="pl-k">+</span> curr;
        }, <span class="pl-c1">0</span> );
    }
};

arr <span class="pl-k">+</span> <span class="pl-c1">10</span>;               <span class="pl-c">// 25</span></pre></div>

<p>The <code>Symbol.toPrimitive</code> method will be provided with a <em>hint</em> of <code>"string"</code>, <code>"number"</code>, or <code>"default"</code> (which should be interpreted as <code>"number"</code>), depending on what type the operation invoking <code>ToPrimitive</code> is expecting. In the previous snippet, the additive <code>+</code> operation has no hint (<code>"default"</code> is passed). A multiplicative <code>*</code> operation would hint <code>"number"</code> and a <code>String(arr)</code> would hint <code>"string"</code>.</p>

<p><strong>Warning:</strong> The <code>==</code> operator will invoke the <code>ToPrimitive</code> operation with no hint -- the <code>@@toPrimitive</code> method, if any is called with hint <code>"default"</code> -- on an object if the other value being compared is not an object. However, if both comparison values are objects, the behavior of <code>==</code> is identical to <code>===</code>, which is that the references themselves are directly compared. In this case, <code>@@toPrimitive</code> is not invoked at all. See the <em>Types &amp; Grammar</em> title of this series for more information about coercion and the abstract operations.</p>

<h3><a id="user-content-regular-expression-symbols" class="anchor" href="#regular-expression-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular Expression Symbols</h3>

<p>There are four well known symbols that can be overridden for regular expression objects, which control how those regular expressions are used by the four corresponding <code>String.prototype</code> functions of the same name:</p>

<ul>
<li><p><code>@@match</code>: The <code>Symbol.match</code> value of a regular expression is the method used to match all or part of a string value with the given regular expression. It's used by <code>String.prototype.match(..)</code> if you pass it a regular expression for the pattern matching.</p>

<p>The default algorithm for matching is laid out in section 21.2.5.6 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@match">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@match</a>). You could override this default algorithm and provide extra regex features, such as look-behind assertions.</p>

<p><code>Symbol.match</code> is also used by the <code>isRegExp</code> abstract operation (see the note in "String Inspection Functions" in Chapter 6) to determine if an object is intended to be used as a regular expression. To force this check to fail for an object so it's not treated as a regular expression, set the <code>Symbol.match</code> value to <code>false</code> (or something falsy).</p></li>
<li><p><code>@@replace</code>: The <code>Symbol.replace</code> value of a regular expression is the method used by <code>String.prototype.replace(..)</code> to replace within a string one or all occurrences of character sequences that match the given regular expression pattern.</p>

<p>The default algorithm for replacing is laid out in section 21.2.5.8 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@replace">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@replace</a>).</p>

<p>One cool use for overriding the default algorithm is to provide additional <code>replacer</code> argument options, such as supporting <code>"abaca".replace(/a/g,[1,2,3])</code> producing <code>"1b2c3"</code> by consuming the iterable for successive replacement values.</p></li>
<li><p><code>@@search</code>: The <code>Symbol.search</code> value of a regular expression is the method used by <code>String.prototype.search(..)</code> to search for a sub-string within another string as matched by the given regular expression.</p>

<p>The default algorithm for searching is laid out in section 21.2.5.9 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@search">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@search</a>).</p></li>
<li><p><code>@@split</code>: The <code>Symbol.split</code> value of a regular expression is the method used by <code>String.prototype.split(..)</code> to split a string into sub-strings at the location(s) of the delimiter as matched by the given regular expression.</p>

<p>The default algorithm for splitting is laid out in section 21.2.5.11 of the ES6 specification (<a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-regexp.prototype-@@split">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@split</a>).</p></li>
</ul>

<p>Overriding the built-in regular expression algorithms is not for the faint of heart! JS ships with a highly optimized regular expression engine, so your own user code will likely be a lot slower. This kind of meta programming is neat and powerful, but it should only be used in cases where it's really necessary or beneficial.</p>

<h3><a id="user-content-symbolisconcatspreadable" class="anchor" href="#symbolisconcatspreadable" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.isConcatSpreadable</code></h3>

<p>The <code>@@isConcatSpreadable</code> symbol can be defined as a boolean property (<code>Symbol.isConcatSpreadable</code>) on any object (like an array or other iterable) to indicate if it should be <em>spread out</em> if passed to an array <code>concat(..)</code>.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>],
    b <span class="pl-k">=</span> [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>];

b[Symbol.isConcatSpreadable] <span class="pl-k">=</span> <span class="pl-c1">false</span>;

[].<span class="pl-c1">concat</span>( a, b );      <span class="pl-c">// [1,2,3,[4,5,6]]</span></pre></div>

<h3><a id="user-content-symbolunscopables" class="anchor" href="#symbolunscopables" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Symbol.unscopables</code></h3>

<p>The <code>@@unscopables</code> symbol can be defined as an object property (<code>Symbol.unscopables</code>) on any object to indicate which properties can and cannot be exposed as lexical variables in a <code>with</code> statement.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span>, c<span class="pl-k">:</span><span class="pl-c1">3</span> },
    a <span class="pl-k">=</span> <span class="pl-c1">10</span>, b <span class="pl-k">=</span> <span class="pl-c1">20</span>, c <span class="pl-k">=</span> <span class="pl-c1">30</span>;

o[Symbol.unscopables] <span class="pl-k">=</span> {
    a<span class="pl-k">:</span> <span class="pl-c1">false</span>,
    b<span class="pl-k">:</span> <span class="pl-c1">true</span>,
    c<span class="pl-k">:</span> <span class="pl-c1">false</span>
};

<span class="pl-k">with</span> (o) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( a, b, c );     <span class="pl-c">// 1 20 3</span>
}</pre></div>

<p>A <code>true</code> in the <code>@@unscopables</code> object indicates the property should be <em>unscopable</em>, and thus filtered out from the lexical scope variables. <code>false</code> means it's OK to be included in the lexical scope variables.</p>

<p><strong>Warning:</strong> The <code>with</code> statement is disallowed entirely in <code>strict</code> mode, and as such should be considered deprecated from the language. Don't use it. See the <em>Scope &amp; Closures</em> title of this series for more information. Because <code>with</code> should be avoided, the <code>@@unscopables</code> symbol is also moot.</p>

<h2><a id="user-content-proxies" class="anchor" href="#proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxies</h2>

<p>One of the most obviously meta programming features added to ES6 is the <code>Proxy</code> feature.</p>

<p>A proxy is a special kind of object you create that "wraps" -- or sits in front of -- another normal object. You can register special handlers (aka <em>traps</em>) on the proxy object which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to <em>forwarding</em> the operations on to the original target/wrapped object.</p>

<p>One example of the kind of <em>trap</em> handler you can define on a proxy is <code>get</code> that intercepts the <code>[[Get]]</code> operation -- performed when you try to access a property on an object. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-c">// note: target === obj,</span>
            <span class="pl-c">// context === pobj</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>accessing: <span class="pl-pds">"</span></span>, key );
            <span class="pl-k">return</span> Reflect.get(
                target, key, context
            );
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

obj.a;
<span class="pl-c">// 1</span>

pobj.a;
<span class="pl-c">// accessing: a</span>
<span class="pl-c">// 1</span></pre></div>

<p>We declare a <code>get(..)</code> handler as a named method on the <em>handler</em> object (second argument to <code>Proxy(..)</code>), which receives a reference to the <em>target</em> object (<code>obj</code>), the <em>key</em> property name (<code>"a"</code>), and the <code>self</code>/receiver/proxy (<code>pobj</code>).</p>

<p>After the <code>console.log(..)</code> tracing statement, we "forward" the operation onto <code>obj</code> via <code>Reflect.get(..)</code>. We will cover the <code>Reflect</code> API in the next section, but note that each available proxy trap has a corresponding <code>Reflect</code> function of the same name.</p>

<p>These mappings are symmetric on purpose. The proxy handlers each intercept when a respective meta programming task is performed, and the <code>Reflect</code> utilities each perform the respective meta programming task on an object. Each proxy handler has a default definition that automatically calls the corresponding <code>Reflect</code> utility. You will almost certainly use both <code>Proxy</code> and <code>Reflect</code> in tandem.</p>

<p>Here's a list of handlers you can define on a proxy for a <em>target</em> object/function, and how/when they are triggered:</p>

<ul>
<li><code>get(..)</code>: via <code>[[Get]]</code>, a property is accessed on the proxy (<code>Reflect.get(..)</code>, <code>.</code> property operator, or <code>[ .. ]</code> property operator)</li>
<li><code>set(..)</code>: via <code>[[Set]]</code>, a property value is set on the proxy (<code>Reflect.set(..)</code>, the <code>=</code> assignment operator, or destructuring assignment if it targets an object property)</li>
<li><code>deleteProperty(..)</code>: via <code>[[Delete]]</code>, a property is deleted from the proxy (<code>Reflect.deleteProperty(..)</code> or <code>delete</code>)</li>
<li><code>apply(..)</code> (if <em>target</em> is a function): via <code>[[Call]]</code>, the proxy is invoked as a normal function/method (<code>Reflect.apply(..)</code>, <code>call(..)</code>, <code>apply(..)</code>, or the <code>(..)</code> call operator)</li>
<li><code>construct(..)</code> (if <em>target</em> is a constructor function): via <code>[[Construct]]</code>, the proxy is invoked as a constructor function (<code>Reflect.construct(..)</code> or <code>new</code>)</li>
<li><code>getOwnPropertyDescriptor(..)</code>: via <code>[[GetOwnProperty]]</code>, a property descriptor is retrieved from the proxy (<code>Object.getOwnPropertyDescriptor(..)</code> or <code>Reflect.getOwnPropertyDescriptor(..)</code>)</li>
<li><code>defineProperty(..)</code>: via <code>[[DefineOwnProperty]]</code>, a property descriptor is set on the proxy (<code>Object.defineProperty(..)</code> or <code>Reflect.defineProperty(..)</code>)</li>
<li><code>getPrototypeOf(..)</code>: via <code>[[GetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is retrieved (<code>Object.getPrototypeOf(..)</code>, <code>Reflect.getPrototypeOf(..)</code>, <code>__proto__</code>, <code>Object#isPrototypeOf(..)</code>, or <code>instanceof</code>)</li>
<li><code>setPrototypeOf(..)</code>: via <code>[[SetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is set (<code>Object.setPrototypeOf(..)</code>, <code>Reflect.setPrototypeOf(..)</code>, or <code>__proto__</code>)</li>
<li><code>preventExtensions(..)</code>: via <code>[[PreventExtensions]]</code>, the proxy is made non-extensible (<code>Object.preventExtensions(..)</code> or <code>Reflect.preventExtensions(..)</code>)</li>
<li><code>isExtensible(..)</code>: via <code>[[IsExtensible]]</code>, the extensibility of the proxy is probed (<code>Object.isExtensible(..)</code> or <code>Reflect.isExtensible(..)</code>)</li>
<li><code>ownKeys(..)</code>: via <code>[[OwnPropertyKeys]]</code>, the set of owned properties and/or owned symbol properties of the proxy is retrieved (<code>Object.keys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, <code>Object.getOwnSymbolProperties(..)</code>, <code>Reflect.ownKeys(..)</code>, or <code>JSON.stringify(..)</code>)</li>
<li><code>enumerate(..)</code>: via <code>[[Enumerate]]</code>, an iterator is requested for the proxy's enumerable owned and "inherited" properties (<code>Reflect.enumerate(..)</code> or <code>for..in</code>)</li>
<li><code>has(..)</code>: via <code>[[HasProperty]]</code>, the proxy is probed to see if it has an owned or "inherited" property (<code>Reflect.has(..)</code>, <code>Object#hasOwnProperty(..)</code>, or <code>"prop" in obj</code>)</li>
</ul>

<p><strong>Tip:</strong> For more information about each of these meta programming tasks, see the "<code>Reflect</code> API" section later in this chapter.</p>

<p>In addition to the notations in the preceding list about actions that will trigger the various traps, some traps are triggered indirectly by the default actions of another trap. For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">getOwnPropertyDescriptor</span>(<span class="pl-smi">target</span>,<span class="pl-smi">prop</span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>(
                <span class="pl-s"><span class="pl-pds">"</span>getOwnPropertyDescriptor<span class="pl-pds">"</span></span>
            );
            <span class="pl-k">return</span> <span class="pl-c1">Object</span>.getOwnPropertyDescriptor(
                target, prop
            );
        },
        <span class="pl-en">defineProperty</span>(<span class="pl-smi">target</span>,<span class="pl-smi">prop</span>,<span class="pl-smi">desc</span>){
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>defineProperty<span class="pl-pds">"</span></span> );
            <span class="pl-k">return</span> <span class="pl-c1">Object</span>.defineProperty(
                target, prop, desc
            );
        }
    },
    proxy <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers );

proxy.a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
<span class="pl-c">// getOwnPropertyDescriptor</span>
<span class="pl-c">// defineProperty</span></pre></div>

<p>The <code>getOwnPropertyDescriptor(..)</code> and <code>defineProperty(..)</code> handlers are triggered by the default <code>set(..)</code> handler's steps when setting a property value (whether newly adding or updating). If you also define your own <code>set(..)</code> handler, you may or may not make the corresponding calls against <code>context</code> (not <code>target</code>!) which would trigger these proxy traps.</p>

<h3><a id="user-content-proxy-limitations" class="anchor" href="#proxy-limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy Limitations</h3>

<p>These meta programming handlers trap a wide array of fundamental operations you can perform against an object. However, there are some operations which are not (yet, at least) available to intercept.</p>

<p>For example, none of these operations are trapped and forwarded from <code>pobj</code> proxy to <code>obj</code> target:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span><span class="pl-c1">1</span>, b<span class="pl-k">:</span><span class="pl-c1">2</span> },
    handlers <span class="pl-k">=</span> { .. },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

<span class="pl-k">typeof</span> obj;
<span class="pl-c1">String</span>( obj );
obj <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
obj <span class="pl-k">==</span> pobj;
obj <span class="pl-k">===</span> pobj</pre></div>

<p>Perhaps in the future, more of these underlying fundamental operations in the language will be interceptable, giving us even more power to extend JavaScript from within itself.</p>

<p><strong>Warning:</strong> There are certain <em>invariants</em> -- behaviors which cannot be overridden -- that apply to the use of proxy handlers. For example, the result from the <code>isExtensible(..)</code> handler is always coerced to a <code>boolean</code>. These invariants restrict some of your ability to customize behaviors with proxies, but they do so only to prevent you from creating strange and unusual (or inconsistent) behavior. The conditions for these invariants are complicated so we won't fully go into them here, but this post (<a href="http://www.2ality.com/2014/12/es6-proxies.html#invariants">http://www.2ality.com/2014/12/es6-proxies.html#invariants</a>) does a great job of covering them.</p>

<h3><a id="user-content-revocable-proxies" class="anchor" href="#revocable-proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Revocable Proxies</h3>

<p>A regular proxy always traps for the target object, and cannot be modified after creation -- as long as a reference is kept to the proxy, proxying remains possible. However, there may be cases where you want to create a proxy that can be disabled when you want to stop allowing it to proxy. The solution is to create a <em>revocable proxy</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span> },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-c">// note: target === obj,</span>
            <span class="pl-c">// context === pobj</span>
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>accessing: <span class="pl-pds">"</span></span>, key );
            <span class="pl-k">return</span> target[key];
        }
    },
    { proxy<span class="pl-k">:</span> pobj, revoke<span class="pl-k">:</span> prevoke } <span class="pl-k">=</span>
        Proxy.revocable( obj, handlers );

pobj.a;
<span class="pl-c">// accessing: a</span>
<span class="pl-c">// 1</span>

<span class="pl-c">// later:</span>
prevoke();

pobj.a;
<span class="pl-c">// TypeError</span></pre></div>

<p>A revocable proxy is created with <code>Proxy.revocable(..)</code>, which is a regular function, not a constructor like <code>Proxy(..)</code>. Otherwise, it takes the same two arguments: <em>target</em> and <em>handlers</em>.</p>

<p>The return value of <code>Proxy.revocable(..)</code> is not the proxy itself as with <code>new Proxy(..)</code>. Instead, it's an object with two properties: <em>proxy</em> and <em>revoke</em> -- we used object destructuring (see "Destructuring" in Chapter 2) to assign these properties to <code>pobj</code> and <code>prevoke()</code> variables, respectively.</p>

<p>Once a revocable proxy is revoked, any attempts to access it (trigger any of its traps) will throw a <code>TypeError</code>.</p>

<p>An example of using a revocable proxy might be handing out a proxy to another party in your application that manages data in your model, instead of giving them a reference to the real model object itself. If your model object changes or is replaced, you want to invalidate the proxy you handed out so the other party knows (via the errors!) to request an updated reference to the model.</p>

<h3><a id="user-content-using-proxies" class="anchor" href="#using-proxies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Proxies</h3>

<p>The meta programming benefits of these Proxy handlers should be obvious. We can almost fully intercept (and thus override) the behavior of objects, meaning we can extend object behavior beyond core JS in some very powerful ways. We'll look at a few example patterns to explore the possibilities.</p>

<h4><a id="user-content-proxy-first-proxy-last" class="anchor" href="#proxy-first-proxy-last" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy First, Proxy Last</h4>

<p>As we mentioned earlier, you typically think of a proxy as "wrapping" the target object. In that sense, the proxy becomes the primary object that the code interfaces with, and the actual target object remains hidden/protected.</p>

<p>You might do this because you want to pass the object somewhere that can't be fully "trusted," and so you need to enforce special rules around its access rather than passing the object itself.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> messages <span class="pl-k">=</span> [],
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>) {
            <span class="pl-c">// string value?</span>
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> target[key] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
                <span class="pl-c">// filter out punctuation</span>
                <span class="pl-k">return</span> target[key]
                    .<span class="pl-c1">replace</span>(<span class="pl-sr"> <span class="pl-pds">/</span><span class="pl-c1">[<span class="pl-k">^</span><span class="pl-c1">\w</span>]</span><span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> );
            }

            <span class="pl-c">// pass everything else through</span>
            <span class="pl-k">return</span> target[key];
        },
        <span class="pl-en">set</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">val</span>) {
            <span class="pl-c">// only set unique strings, lowercased</span>
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> val <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) {
                val <span class="pl-k">=</span> val.<span class="pl-c1">toLowerCase</span>();
                <span class="pl-k">if</span> (target.<span class="pl-c1">indexOf</span>( val ) <span class="pl-k">==</span> <span class="pl-k">-</span><span class="pl-c1">1</span>) {
                    target.<span class="pl-c1">push</span>(
                        val.<span class="pl-c1">toLowerCase</span>()
                    );
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">true</span>;
        }
    },
    messages_proxy <span class="pl-k">=</span>
        <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( messages, handlers );

<span class="pl-c">// elsewhere:</span>
messages_proxy.<span class="pl-c1">push</span>(
    <span class="pl-s"><span class="pl-pds">"</span>heLLo...<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>wOrlD!!<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>WoRld!!<span class="pl-pds">"</span></span>
);

messages_proxy.forEach( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(val);
} );
<span class="pl-c">// hello world</span>

messages.forEach( <span class="pl-k">function</span>(<span class="pl-smi">val</span>){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(val);
} );
<span class="pl-c">// hello... world!!</span></pre></div>

<p>I call this <em>proxy first</em> design, as we interact first (primarily, entirely) with the proxy.</p>

<p>We enforce some special rules on interacting with <code>messages_proxy</code> that aren't enforced for <code>messages</code> itself. We only add elements if the value is a string and is also unique; we also lowercase the value. When retrieving values from <code>messages_proxy</code>, we filter out any punctuation in the strings.</p>

<p>Alternatively, we can completely invert this pattern, where the target interacts with the proxy instead of the proxy interacting with the target. Thus, code really only interacts with the main object. The easiest way to accomplish this fallback is to have the proxy object in the <code>[[Prototype]]</code> chain of the main object.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">return</span> <span class="pl-k">function</span>() {
                context.speak(key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>);
            };
        }
    },
    catchall <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers ),
    greeter <span class="pl-k">=</span> {
        <span class="pl-en">speak</span>(<span class="pl-smi">who</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>someone<span class="pl-pds">"</span></span>) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>, who );
        }
    };

<span class="pl-c">// setup `greeter` to fall back to `catchall`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( greeter, catchall );

greeter.speak();                <span class="pl-c">// hello someone</span>
greeter.speak( <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span> );       <span class="pl-c">// hello world</span>

greeter.everyone();             <span class="pl-c">// hello everyone!</span></pre></div>

<p>We interact directly with <code>greeter</code> instead of <code>catchall</code>. When we call <code>speak(..)</code>, it's found on <code>greeter</code> and used directly. But when we try to access a method like <code>everyone()</code>, that function doesn't exist on <code>greeter</code>.</p>

<p>The default object property behavior is to check up the <code>[[Prototype]]</code> chain (see the <em>this &amp; Object Prototypes</em> title of this series), so <code>catchall</code> is consulted for an <code>everyone</code> property. The proxy <code>get()</code> handler then kicks in and returns a function that calls <code>speak(..)</code> with the name of the property being accessed (<code>"everyone"</code>).</p>

<p>I call this pattern <em>proxy last</em>, as the proxy is used only as a last resort.</p>

<h4><a id="user-content-no-such-propertymethod" class="anchor" href="#no-such-propertymethod" aria-hidden="true"><span class="octicon octicon-link"></span></a>"No Such Property/Method"</h4>

<p>A common complaint about JS is that objects aren't by default very defensive in the situation where you try to access or set a property that doesn't already exist. You may wish to predefine all the properties/methods for an object, and have an error thrown if a nonexistent property name is subsequently used.</p>

<p>We can accomplish this with a proxy, either in <em>proxy first</em> or <em>proxy last</em> design. Let's consider both.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
        a<span class="pl-k">:</span> <span class="pl-c1">1</span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.a );
        }
    },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
            }
        },
        <span class="pl-en">set</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">val</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.set(
                    target, key, val, context
                );
            }
            <span class="pl-k">else</span> {
                <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
            }
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( obj, handlers );

pobj.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
pobj.foo();         <span class="pl-c">// a: 3</span>

pobj.b <span class="pl-k">=</span> <span class="pl-c1">4</span>;         <span class="pl-c">// Error: No such property/method!</span>
pobj.bar();         <span class="pl-c">// Error: No such property/method!</span></pre></div>

<p>For both <code>get(..)</code> and <code>set(..)</code>, we only forward the operation if the target object's property already exists; error thrown otherwise. The proxy object (<code>pobj</code>) is the main object code should interact with, as it intercepts these actions to provide the protections.</p>

<p>Now, let's consider inverting with <em>proxy last</em> design:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>() {
            <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
        },
        <span class="pl-en">set</span>() {
            <span class="pl-k">throw</span> <span class="pl-s"><span class="pl-pds">"</span>No such property/method!<span class="pl-pds">"</span></span>;
        }
    },
    pobj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>( {}, handlers ),
    obj <span class="pl-k">=</span> {
        a<span class="pl-k">:</span> <span class="pl-c1">1</span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>a:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.a );
        }
    };

<span class="pl-c">// setup `obj` to fall back to `pobj`</span>
<span class="pl-c1">Object</span>.setPrototypeOf( obj, pobj );

obj.a <span class="pl-k">=</span> <span class="pl-c1">3</span>;
obj.foo();          <span class="pl-c">// a: 3</span>

obj.b <span class="pl-k">=</span> <span class="pl-c1">4</span>;          <span class="pl-c">// Error: No such property/method!</span>
obj.bar();          <span class="pl-c">// Error: No such property/method!</span></pre></div>

<p>The <em>proxy last</em> design here is a fair bit simpler with respect to how the handlers are defined. Instead of needing to intercept the <code>[[Get]]</code> and <code>[[Set]]</code> operations and only forward them if the target property exists, we instead rely on the fact that if either <code>[[Get]]</code> or <code>[[Set]]</code> get to our <code>pobj</code> fallback, the action has already traversed the whole <code>[[Prototype]]</code> chain and not found a matching property. We are free at that point to unconditionally throw the error. Cool, huh?</p>

<h4><a id="user-content-proxy-hacking-the-prototype-chain" class="anchor" href="#proxy-hacking-the-prototype-chain" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proxy Hacking the <code>[[Prototype]]</code> Chain</h4>

<p>The <code>[[Get]]</code> operation is the primary channel by which the <code>[[Prototype]]</code> mechanism is invoked. When a property is not found on the immediate object, <code>[[Get]]</code> automatically hands off the operation to the <code>[[Prototype]]</code> object.</p>

<p>That means you can use the <code>get(..)</code> trap of a proxy to emulate or extend the notion of this <code>[[Prototype]]</code> mechanism.</p>

<p>The first hack we'll consider is creating two objects which are circularly linked via <code>[[Prototype]]</code> (or, at least it appears that way!). You cannot actually create a real circular <code>[[Prototype]]</code> chain, as the engine will throw an error. But a proxy can fake it!</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-c">// fake circular `[[Prototype]]`</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">return</span> Reflect.get(
                    target[
                        Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> )
                    ],
                    key,
                    context
                );
            }
        }
    },
    obj1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>(
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-1<span class="pl-pds">"</span></span>,
            <span class="pl-en">foo</span>() {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
            }
        },
        handlers
    ),
    obj2 <span class="pl-k">=</span> <span class="pl-c1">Object</span>.assign(
        <span class="pl-c1">Object</span>.create( obj1 ),
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-2<span class="pl-pds">"</span></span>,
            <span class="pl-en">bar</span>() {
                <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>bar:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
                <span class="pl-v">this</span>.foo();
            }
        }
    );

<span class="pl-c">// fake circular `[[Prototype]]` link</span>
obj1[ Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> obj2;

obj1.bar();
<span class="pl-c">// bar: obj-1 &lt;-- through proxy faking [[Prototype]]</span>
<span class="pl-c">// foo: obj-1 &lt;-- `this` context still preserved</span>

obj2.foo();
<span class="pl-c">// foo: obj-2 &lt;-- through [[Prototype]]</span></pre></div>

<p><strong>Note:</strong> We didn't need to proxy/forward <code>[[Set]]</code> in this example, so we kept things simpler. To be fully <code>[[Prototype]]</code> emulation compliant, you'd want to implement a <code>set(..)</code> handler that searches the <code>[[Prototype]]</code> chain for a matching property and respects its descriptor behavior (e.g., set, writable). See the <em>this &amp; Object Prototypes</em> title of this series.</p>

<p>In the previous snippet, <code>obj2</code> is <code>[[Prototype]]</code> linked to <code>obj1</code> by virtue of the <code>Object.create(..)</code> statement. But to create the reverse (circular) linkage, we create property on <code>obj1</code> at the symbol location <code>Symbol.for("[[Prototype]]")</code> (see "Symbols" in Chapter 2). This symbol may look sort of special/magical, but it isn't. It just allows me a conveniently named hook that semantically appears related to the task I'm performing.</p>

<p>Then, the proxy's <code>get(..)</code> handler looks first to see if a requested <code>key</code> is on the proxy. If not, the operation is manually handed off to the object reference stored in the <code>Symbol.for("[[Prototype]]")</code> location of <code>target</code>.</p>

<p>One important advantage of this pattern is that the definitions of <code>obj1</code> and <code>obj2</code> are mostly not intruded by the setting up of this circular relationship between them. Although the previous snippet has all the steps intertwined for brevity's sake, if you look closely, the proxy handler logic is entirely generic (doesn't know about <code>obj1</code> or <code>obj2</code> specifically). So, that logic could be pulled out into a simple helper that wires them up, like a <code>setCircularPrototypeOf(..)</code> for example. We'll leave that as an exercise for the reader.</p>

<p>Now that we've seen how we can use <code>get(..)</code> to emulate a <code>[[Prototype]]</code> link, let's push the hackery a bit further. Instead of a circular <code>[[Prototype]]</code>, what about multiple <code>[[Prototype]]</code> linkages (aka "multiple inheritance")? This turns out to be fairly straightforward:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj1 <span class="pl-k">=</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-1<span class="pl-pds">"</span></span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj1.foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        },
    },
    obj2 <span class="pl-k">=</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-2<span class="pl-pds">"</span></span>,
        <span class="pl-en">foo</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj2.foo:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        },
        <span class="pl-en">bar</span>() {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( <span class="pl-s"><span class="pl-pds">"</span>obj2.bar:<span class="pl-pds">"</span></span>, <span class="pl-v">this</span>.<span class="pl-c1">name</span> );
        }
    },
    handlers <span class="pl-k">=</span> {
        <span class="pl-en">get</span>(<span class="pl-smi">target</span>,<span class="pl-smi">key</span>,<span class="pl-smi">context</span>) {
            <span class="pl-k">if</span> (Reflect.has( target, key )) {
                <span class="pl-k">return</span> Reflect.get(
                    target, key, context
                );
            }
            <span class="pl-c">// fake multiple `[[Prototype]]`</span>
            <span class="pl-k">else</span> {
                <span class="pl-k">for</span> (<span class="pl-k">var</span> P <span class="pl-k">of</span> target[
                    Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> )
                ]) {
                    <span class="pl-k">if</span> (Reflect.has( P, key )) {
                        <span class="pl-k">return</span> Reflect.get(
                            P, key, context
                        );
                    }
                }
            }
        }
    },
    obj3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Proxy</span>(
        {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>obj-3<span class="pl-pds">"</span></span>,
            <span class="pl-en">baz</span>() {
                <span class="pl-v">this</span>.foo();
                <span class="pl-v">this</span>.bar();
            }
        },
        handlers
    );

<span class="pl-c">// fake multiple `[[Prototype]]` links</span>
obj3[ Symbol.for( <span class="pl-s"><span class="pl-pds">"</span>[[Prototype]]<span class="pl-pds">"</span></span> ) ] <span class="pl-k">=</span> [
    obj1, obj2
];

obj3.baz();
<span class="pl-c">// obj1.foo: obj-3</span>
<span class="pl-c">// obj2.bar: obj-3</span></pre></div>

<p><strong>Note:</strong> As mentioned in the note after the earlier circular <code>[[Prototype]]</code> example, we didn't implement the <code>set(..)</code> handler, but it would be necessary for a complete solution that emulates <code>[[Set]]</code> actions as normal <code>[[Prototype]]</code>s behave.</p>

<p><code>obj3</code> is set up to multiple-delegate to both <code>obj1</code> and <code>obj2</code>. In <code>obj3.baz()</code>, the <code>this.foo()</code> call ends up pulling <code>foo()</code> from <code>obj1</code> (first-come, first-served, even though there's also a <code>foo()</code> on <code>obj2</code>). If we reordered the linkage as <code>obj2, obj1</code>, the <code>obj2.foo()</code> would have been found and used.</p>

<p>But as is, the <code>this.bar()</code> call doesn't find a <code>bar()</code> on <code>obj1</code>, so it falls over to check <code>obj2</code>, where it finds a match.</p>

<p><code>obj1</code> and <code>obj2</code> represent two parallel <code>[[Prototype]]</code> chains of <code>obj3</code>. <code>obj1</code> and/or <code>obj2</code> could themselves have normal <code>[[Prototype]]</code> delegation to other objects, or either could themself be a proxy (like <code>obj3</code> is) that can multiple-delegate.</p>

<p>Just as with the circular <code>[[Prototype]]</code> example earlier, the definitions of <code>obj1</code>, <code>obj2</code>, and <code>obj3</code> are almost entirely separate from the generic proxy logic that handles the multiple-delegation. It would be trivial to define a utility like <code>setPrototypesOf(..)</code> (notice the "s"!) that takes a main object and a list of objects to fake the multiple <code>[[Prototype]]</code> linkage to. Again, we'll leave that as an exercise for the reader.</p>

<p>Hopefully the power of proxies is now becoming clearer after these various examples. There are many other powerful meta programming tasks that proxies enable.</p>

<h2><a id="user-content-reflect-api" class="anchor" href="#reflect-api" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Reflect</code> API</h2>

<p>The <code>Reflect</code> object is a plain object (like <code>Math</code>), not a function/constructor like the other built-in natives.</p>

<p>It holds static functions which correspond to various meta programming tasks that you can control. These functions correspond one-to-one with the handler methods (<em>traps</em>) that Proxies can define.</p>

<p>Some of the functions will look familiar as functions of the same names on <code>Object</code>:</p>

<ul>
<li><code>Reflect.getOwnPropertyDescriptor(..)</code></li>
<li><code>Reflect.defineProperty(..)</code></li>
<li><code>Reflect.getPrototypeOf(..)</code></li>
<li><code>Reflect.setPrototypeOf(..)</code></li>
<li><code>Reflect.preventExtensions(..)</code></li>
<li><code>Reflect.isExtensible(..)</code></li>
</ul>

<p>These utilities in general behave the same as their <code>Object.*</code> counterparts. However, one difference is that the <code>Object.*</code> counterparts attempt to coerce their first argument (the target object) to an object if it's not already one. The <code>Reflect.*</code> methods simply throw an error in that case.</p>

<p>An object's keys can be accessed/inspected using these utilities:</p>

<ul>
<li><code>Reflect.ownKeys(..)</code>: Returns the list of all owned keys (not "inherited"), as returned by both <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>. See the "Property Enumeration Order" section for information about the order of keys.</li>
<li><code>Reflect.enumerate(..)</code>: Returns an iterator that produces the set of all non-symbol keys (owned and "inherited") that are <em>enumerable</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Essentially, this set of keys is the same as those processed by a <code>for..in</code> loop. See the "Property Enumeration Order" section for information about the order of keys.</li>
<li><code>Reflect.has(..)</code>: Essentially the same as the <code>in</code> operator for checking if a property is on an object or its <code>[[Prototype]]</code> chain. For example, <code>Reflect.has(o,"foo")</code> essentially performs <code>"foo" in o</code>.</li>
</ul>

<p>Function calls and constructor invocations can be performed manually, separate of the normal syntax (e.g., <code>(..)</code> and <code>new</code>) using these utilities:</p>

<ul>
<li><code>Reflect.apply(..)</code>: For example, <code>Reflect.apply(foo,thisObj,[42,"bar"])</code> calls the <code>foo(..)</code> function with <code>thisObj</code> as its <code>this</code>, and passes in the <code>42</code> and <code>"bar"</code> arguments.</li>
<li><code>Reflect.construct(..)</code>: For example, <code>Reflect.construct(foo,[42,"bar"])</code> essentially calls <code>new foo(42,"bar")</code>.</li>
</ul>

<p>Object property access, setting, and deletion can be performed manually using these utilities:</p>

<ul>
<li><code>Reflect.get(..)</code>: For example, <code>Reflect.get(o,"foo")</code> retrieves <code>o.foo</code>.</li>
<li><code>Reflect.set(..)</code>: For example, <code>Reflect.set(o,"foo",42)</code> essentially performs <code>o.foo = 42</code>.</li>
<li><code>Reflect.deleteProperty(..)</code>: For example, <code>Reflect.deleteProperty(o,"foo")</code> essentially performs <code>delete o.foo</code>.</li>
</ul>

<p>The meta programming capabilities of <code>Reflect</code> give you programmtic equivalents to emulate various syntactic features, exposing previously hidden-only abstract operations. For example, you can use these capabilities to extend features and APIs for <em>domain specific languages</em> (DSLs).</p>

<h3><a id="user-content-property-ordering" class="anchor" href="#property-ordering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Property Ordering</h3>

<p>Prior to ES6, the order used to list an object's keys/properties was implementation dependent and undefined by the specification. Generally, most engines have enumerated them in creation order, though developers have been strongly encouraged not to ever rely on this ordering.</p>

<p>As of ES6, the order for listing owned properties is now defined (ES6 specification, section 9.1.12) by the <code>[[OwnPropertyKeys]]</code> algorithm, which produces all owned properties (strings or symbols), regardless of enumerability. This ordering is only guaranteed for <code>Reflect.ownKeys(..)</code> (and by extension, <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>).</p>

<p>The ordering is:</p>

<ol>
<li>First, enumerate any owned properties that are integer indexes, in ascending numeric order.</li>
<li>Next, enumerate the rest of the owned string property names in creation order.</li>
<li>Finally, enumerate owned symbol properities in creation order.</li>
</ol>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> {};

o[Symbol(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>yay<span class="pl-pds">"</span></span>;
o[<span class="pl-c1">2</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
o[<span class="pl-c1">1</span>] <span class="pl-k">=</span> <span class="pl-c1">true</span>;
o.b <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>awesome<span class="pl-pds">"</span></span>;
o.a <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cool<span class="pl-pds">"</span></span>;

Reflect.ownKeys( o );               <span class="pl-c">// [1,2,"b","a",Symbol(c)]</span>
<span class="pl-c1">Object</span>.getOwnPropertyNames( o );    <span class="pl-c">// [1,2,"b","a"]</span>
<span class="pl-c1">Object</span>.getOwnPropertySymbols( o );  <span class="pl-c">// [Symbol(c)]</span></pre></div>

<p>On the other hand, the <code>[[Enumerate]]</code> algorithm (ES6 specification, section 9.1.11) produces only enumerable properties, from the target object as well as its <code>[[Prototype]]</code> chain. It is used by both <code>Reflect.enumerate(..)</code> and <code>for..in</code>. The observable ordering is implementation dependent and not controlled by the specification.</p>

<p>By contrast, <code>Object.keys(..)</code> invokes the <code>[[OwnPropertyKeys]]</code> algorithm to get a list of all owned keys. However, it filters out non-enumerable properties and then reorders the list to match legacy implementation-dependent behavior, specifically with <code>JSON.stringify(..)</code> and <code>for..in</code>. So, by extension the ordering <em>also</em> matches that of <code>Reflect.enumerate(..)</code>.</p>

<p>In other words, all four mechanisms (<code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, <code>for..in</code>, and <code>JSON.stringify(..)</code>) will  match with the same implementation-dependent ordering, though they technically get there in different ways.</p>

<p>Implementations are allowed to match these four to the ordering of <code>[[OwnPropertyKeys]]</code>, but are not required to. Nevertheless, you will likely observe the following ordering behavior from them:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };
<span class="pl-k">var</span> p <span class="pl-k">=</span> <span class="pl-c1">Object</span>.create( o );
p.c <span class="pl-k">=</span> <span class="pl-c1">3</span>;
p.d <span class="pl-k">=</span> <span class="pl-c1">4</span>;

<span class="pl-k">for</span> (<span class="pl-k">var</span> prop <span class="pl-k">of</span> Reflect.enumerate( p )) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( prop );
}
<span class="pl-c">// c d a b</span>

<span class="pl-k">for</span> (<span class="pl-k">var</span> prop <span class="pl-k">in</span> p) {
    <span class="pl-en">console</span><span class="pl-c1">.log</span>( prop );
}
<span class="pl-c">// c d a b</span>

<span class="pl-c1">JSON</span>.stringify( p );
<span class="pl-c">// {"c":3,"d":4}</span>

<span class="pl-c1">Object</span>.keys( p );
<span class="pl-c">// ["c","d"]</span></pre></div>

<p>Boiling this all down: as of ES6, <code>Reflect.ownKeys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, and <code>Object.getOwnPropertySymbols(..)</code> all have predictable and reliable ordering guaranteed by the specification. So it's safe to build code that relies on this ordering.</p>

<p><code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, and <code>for..in</code> (as well as <code>JSON.stringification(..)</code> by extension) continue to share an observable ordering with each other, as they always have. But that ordering will not necessarily be the same as that of <code>Reflect.ownKeys(..)</code>. Care should still be taken in relying on their implementation-dependent ordering.</p>

<h2><a id="user-content-feature-testing" class="anchor" href="#feature-testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feature Testing</h2>

<p>What is a feature test? It's a test that you run to determine if a feature is available or not. Sometimes, the test is not just for existence, but for conformance to specified behavior -- features can exist but be buggy.</p>

<p>This is a meta programming technique, to test the environment your program runs in to then determine how your program should behave.</p>

<p>The most common use of feature tests in JS is checking for the existence of an API and if it's not present, defining a polyfill (see Chapter 1). For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-c1">Number</span>.isNaN) {
    <span class="pl-c1">Number</span>.<span class="pl-en">isNaN</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> x <span class="pl-k">!==</span> x;
    };
}</pre></div>

<p>The <code>if</code> statement in this snippet is meta programming: we're probing our program and its runtime environment to determine if and how we should proceed.</p>

<p>But what about testing for features that involve new syntax?</p>

<p>You might try something like:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">try</span> {
    <span class="pl-en">a</span> <span class="pl-k">=</span> ()<span class="pl-k"> =&gt;</span> {};
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>Unfortunately, this doesn't work, because our JS programs are compiled. Thus, the engine will choke on the <code>() =&gt; {}</code> syntax if it is not already supporting ES6 arrow functions. Having a syntax error in your program prevents it from running, which prevents your program from subsequently responding differently if the feature is supported or not.</p>

<p>To meta program with feature tests around syntax-related features, we need a way to insulate the test from the initial compile step our program runs through. For instance, if we could store the code for the test in a string, then the JS engine wouldn't by default try to compile the contents of that string, until we asked it to.</p>

<p>Did your mind just jump to using <code>eval(..)</code>?</p>

<p>Not so fast. See the <em>Scope &amp; Closures</em> title of this series for why <code>eval(..)</code> is a bad idea. But there's another option with less downsides: the <code>Function(..)</code> constructor.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">try</span> {
    <span class="pl-k">new</span> <span class="pl-en">Function</span>( <span class="pl-s"><span class="pl-pds">"</span>( () =&gt; {} )<span class="pl-pds">"</span></span> );
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">ARROW_FUNCS_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>OK, so now we're meta programming by determining if a feature like arrow functions <em>can</em> compile in the current engine or not. You might then wonder, what would we do with this information?</p>

<p>With existence checks for APIs, and defining fallback API polyfills, there's a clear path for what to do with either test success or failure. But what can we do with the information that we get from <code>ARROW_FUNCS_ENABLED</code> being <code>true</code> or <code>false</code>?</p>

<p>Because the syntax can't appear in a file if the engine doesn't support that feature, you can't just have different functions defined in the file with and without the syntax in question.</p>

<p>What you can do is use the test to determine which of a set of JS files you should load. For example, if you had a set of these feature tests in a bootstrapper for your JS application, it could then test the environment to determine if your ES6 code can be loaded and run directly, or if you need to load a transpiled version of your code (see Chapter 1).</p>

<p>This technique is called <em>split delivery</em>.</p>

<p>It recognizes the reality that your ES6 authored JS programs will sometimes be able to entirely run "natively" in ES6+ browsers, but other times need transpilation to run in pre-ES6 browsers. If you always load and use the transpiled code, even in the new ES6-compliant environments, you're running suboptimal code at least some of the time. This is not ideal.</p>

<p>Split delivery is more complicated and sophisticated, but it represents a more mature and robust approach to bridging the gap between the code you write and the feature support in browsers your programs must run in.</p>

<h3><a id="user-content-featuretestsio" class="anchor" href="#featuretestsio" aria-hidden="true"><span class="octicon octicon-link"></span></a>FeatureTests.io</h3>

<p>Defining feature tests for all of the ES6+ syntax, as well as the semantic behaviors, is a daunting task you probably don't want to tackle yourself. Because these tests require dynamic compilation (<code>new Function(..)</code>), there's some unfortunate performance cost.</p>

<p>Moreover, running these tests every single time your app runs is probably wasteful, as on average a user's browser only updates once in a several week period at most, and even then, new features aren't necessarily showing up with every update.</p>

<p>Finally, managing the list of feature tests that apply to your specific code base -- rarely will your programs use the entirety of ES6 -- is unruly and error-prone.</p>

<p>The "<a href="https://featuretests.io">https://featuretests.io</a>" feature-tests-as-a-service offers solutions to these frustrations.</p>

<p>You can load the service's library into your page, and it loads the latest test definitions and runs all the feature tests. It does so using background processing with Web Workers, if possible, to reduce the performance overhead. It also uses LocalStorage persistence to cache the results in a way that can be shared across all sites you visit which use the service, which drastically reduces how often the tests need to run on each browser instance.</p>

<p>You get runtime feature tests in each of your users' browsers, and you can use those tests results dynamically to serve users the most appropriate code (no more, no less) for their environments.</p>

<p>Moreover, the service provides tools and APIs to scan your files to determine what features you need, so you can fully automate your split delivery build processes.</p>

<p>FeatureTests.io makes it practical to use feature tests for all parts of ES6 and beyond to make sure that only the best code is ever loaded and run for any given environment.</p>

<h2><a id="user-content-tail-call-optimization-tco" class="anchor" href="#tail-call-optimization-tco" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tail Call Optimization (TCO)</h2>

<p>Normally, when a function call is made from inside another function, a second <em>stack frame</em> is allocated to separately manage the variables/state of that other function invocation. Not only does this allocation cost some processing time, but it also takes up some extra memory.</p>

<p>A call stack chain typically has at most 10-15 jumps from one function to another and another. In those scenarios, the memory usage is not likely any kind of practical problem.</p>

<p>However, when you consider recursive programming (a function calling itself repeatedly) -- or mutual recursion with two or more functions calling each other -- the call stack could easily be hundreds, thousands, or more levels deep. You can probably see the problems that could cause, if memory usage grows unbounded.</p>

<p>JavaScript engines have to set an arbitrary limit to prevent such programming techniques from crashing by running the browser and device out of memory. That's why we get the frustrating "RangeError: Maximum call stack size exceeded" thrown if the limit is hit.</p>

<p><strong>Warning:</strong> The limit of call stack depth is not controlled by the specification. It's implementation dependent, and will vary between browsers and devices. You should never code with strong assumptions of exact observable limits, as they may very well change from release to release.</p>

<p>Certain patterns of function calls, called <em>tail calls</em>, can be optimized in a way to avoid the extra allocation of stack frames. If the extra allocation can be avoided, there's no reason to arbitrarily limit the call stack depth, so the engines can let them run unbounded.</p>

<p>A tail call is a <code>return</code> statement with a function call, where nothing has to happen after the call except returning its value.</p>

<p>This optimization can only be applied in <code>strict</code> mode. Yet another reason to always be writing all your code as <code>strict</code>!</p>

<p>Here's a function call that is <em>not</em> in tail position:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    <span class="pl-c">// not a tail call</span>
    <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">+</span> foo( x );
}

bar( <span class="pl-c1">10</span> );              <span class="pl-c">// 21</span></pre></div>

<p><code>1 + ..</code> has to be performed after the <code>foo(x)</code> call completes, so the state of that <code>bar(..)</code> invocation needs to be preserved.</p>

<p>But the following snippet demonstrates calls to <code>foo(..)</code> and <code>bar(..)</code> where both <em>are</em> in tail position, as they're the last thing to happen in their code path (other than the <code>return</code>):</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-c1">2</span>;
}

<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">x</span>) {
    x <span class="pl-k">=</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>;
    <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>) {
        <span class="pl-k">return</span> foo( x );
    }
    <span class="pl-k">else</span> {
        <span class="pl-k">return</span> bar( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    }
}

bar( <span class="pl-c1">5</span> );               <span class="pl-c">// 24</span>
bar( <span class="pl-c1">15</span> );              <span class="pl-c">// 32</span></pre></div>

<p>In this program, <code>bar(..)</code> is clearly recursive, but <code>foo(..)</code> is just a regular function call. In both cases, the function calls are in <em>proper tail position</em>. The <code>x + 1</code> is evaluated before the <code>bar(..)</code> call, and whenever that call finishes, all that happens is the <code>return</code>.</p>

<p>Proper Tail Calls (PTC) of these forms can be optimized -- called tail call optimization (TCO) -- so that the extra stack frame allocation is unnecessary. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn't need to preserve any of the current state, as nothing happens with that state after the PTC.</p>

<p>TCO means there's practically no limit to how deep the call stack can be. That trick slightly improves regular function calls in normal programs, but more importantly opens the door to using recursion for program expression even if the call stack could be tens of thousands of calls deep.</p>

<p>We're no longer relegated to simply theorizing about recursion for problem solving, but can actually use it in real JavaScript programs!</p>

<p>As of ES6, all PTC should be optimizable in this way, recursion or not.</p>

<h3><a id="user-content-tail-call-rewrite" class="anchor" href="#tail-call-rewrite" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tail Call Rewrite</h3>

<p>The hitch, however, is that only PTC can be optimized; non-PTC will still work of course, but will cause stack frame allocation as they always did. You'll have to be careful about structuring your functions with PTC if you expect the optimizations to kick in.</p>

<p>If you have a function that's not written with PTC, you may find the need to manually rearrange your code to be eligible for TCO.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>;
    <span class="pl-k">return</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> foo( x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// RangeError</span></pre></div>

<p>The call to <code>foo(x-1)</code> isn't a PTC because its result has to be added to <code>(x / 2)</code> before <code>return</code>ing.</p>

<p>However, to make this code eligible for TCO in an ES6 engine, we can rewrite it as follows:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> acc;
        <span class="pl-k">return</span> _foo( (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc, x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
    }

    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> _foo( <span class="pl-c1">1</span>, x );
    };
})();

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>If you run the previous snippet in an ES6 engine that implements TCO, you'll get the <code>3810376848.5</code> answer as shown. However, it'll still fail with a <code>RangeError</code> in non-TCO engines.</p>

<h3><a id="user-content-non-tco-optimizations" class="anchor" href="#non-tco-optimizations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-TCO Optimizations</h3>

<p>There are other techniques to rewrite the code so that the call stack isn't growing with each call.</p>

<p>One such technique is called <em>trampolining</em>, which amounts to having each partial result represented as a function that either returns another partial result function or the final result. Then you can simply loop until you stop getting a function, and you'll have the result. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">trampoline</span>( <span class="pl-smi">res</span> ) {
    <span class="pl-k">while</span> (<span class="pl-k">typeof</span> res <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>function<span class="pl-pds">"</span></span>) {
        res <span class="pl-k">=</span> res();
    }
    <span class="pl-k">return</span> res;
}

<span class="pl-k">var</span> foo <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>(<span class="pl-smi">acc</span>,<span class="pl-smi">x</span>) {
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;=</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> acc;
        <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">partial</span>(){
            <span class="pl-k">return</span> _foo( (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc, x <span class="pl-k">-</span> <span class="pl-c1">1</span> );
        };
    }

    <span class="pl-k">return</span> <span class="pl-k">function</span>(<span class="pl-smi">x</span>) {
        <span class="pl-k">return</span> trampoline( _foo( <span class="pl-c1">1</span>, x ) );
    };
})();

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This reworking required minimal changes to factor out the recursion into the loop in <code>trampoline(..)</code>:</p>

<ol>
<li>First, we wrapped the <code>return _foo ..</code> line in the <code>return partial() { ..</code> function expression.</li>
<li>Then we wrapped the <code>_foo(1,x)</code> call in the <code>trampoline(..)</code> call.</li>
</ol>

<p>The reason this technique doesn't suffer the call stack limitiation is that each of those inner <code>partial(..)</code> functions is just returned back to the <code>while</code> loop in <code>trampoline(..)</code>, which runs it and then loop iterates again. In other words, <code>partial(..)</code> doesn't recursively call itself, it just returns another function. The stack depth remains constant, so it can run as long as it needs to.</p>

<p>Trampolining expressed in this way uses the closure that the inner <code>partial()</code> function has over the <code>x</code> and <code>acc</code> variables to keep the state from iteration to iteration. The advantage is that the looping logic is pulled out into a reusable <code>trampoline(..)</code> utility function, which many libraries provide versions of. You can reuse <code>trampoline(..)</code> multiple times in your program with different trampolined algorithms.</p>

<p>Of course, if you really wanted to deeply optimize (and the reusability wasn't a concern), you could discard the closure state and inline the state tracking of <code>acc</code> into just one function's scope along with a loop. This technique is generally called <em>recursion unrolling</em>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">var</span> acc <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">while</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
        acc <span class="pl-k">=</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> acc;
        x <span class="pl-k">=</span> x <span class="pl-k">-</span> <span class="pl-c1">1</span>;
    }
    <span class="pl-k">return</span> acc;
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This expression of the algorithm is simpler to read, and will likely perform the best (strictly speaking) of the various forms we've explored. That may seem like a clear winner, and you may wonder why you would ever try the other approaches.</p>

<p>There are some reasons why you might not want to always manually unroll your recursions:</p>

<ul>
<li>Instead of factoring out the trampolining (loop) logic for reusability, we've inlined it. This works great when there's only one example to consider, but as soon as you have a half dozen or more of these in your program, there's a good chance you'll want some reusabilty to keep things shorter and more manageable.</li>
<li><p>The example here is deliberately simple enough to illustrate the different forms. In practice, there are many more complications in recursion algorithms, such as mutual recursion (more than just one function calling itself).</p>

<p>The farther you go down this rabbit hole, the more manual and intricate the <em>unrolling</em> optimizations are. You'll quickly lose all the perceived value of readability. The primary advantage of recursion, even in the PTC form, is that it preserves the algorithm readability, and offloads the performance optimization to the engine.</p></li>
</ul>

<p>If you write your algorithms with PTC, the ES6 engine will apply TCO to let your code run in constant stack depth (by reusing stack frames). You get the readability of recursion with most of the performance benefits and no limitations of run length.</p>

<h3><a id="user-content-meta" class="anchor" href="#meta" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meta?</h3>

<p>What does TCO have to do with meta programming?</p>

<p>As we covered in the "Feature Testing" section earlier, you can determine at runtime what features an engine supports. This includes TCO, though determining it is quite brute force. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">try</span> {
    (<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>){
        <span class="pl-k">if</span> (x <span class="pl-k">&lt;</span> <span class="pl-c1">5E5</span>) <span class="pl-k">return</span> foo( x <span class="pl-k">+</span> <span class="pl-c1">1</span> );
    })( <span class="pl-c1">1</span> );

    <span class="pl-c1">TCO_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>;
}
<span class="pl-k">catch</span> (err) {
    <span class="pl-c1">TCO_ENABLED</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>;
}</pre></div>

<p>In a non-TCO engine, the recursive loop will fail out eventually, throwing an exception caught by the <code>try..catch</code>. Otherwise, the loop completes easily thanks to TCO.</p>

<p>Yuck, right?</p>

<p>But how could meta programming around the TCO feature (or rather, the lack thereof) benefit our code? The simple answer is that you could use such a feature test to decide to load a version of your application's code that uses recursion, or an alternative one that's been converted/transpiled to not need recursion.</p>

<h4><a id="user-content-self-adjusting-code" class="anchor" href="#self-adjusting-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Self-Adjusting Code</h4>

<p>But here's another way of looking at the problem:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-s"><span class="pl-pds">"</span>use strict<span class="pl-pds">"</span></span>;

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">x</span>) {
    <span class="pl-k">function</span> <span class="pl-en">_foo</span>() {
        <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
            acc <span class="pl-k">=</span> acc <span class="pl-k">+</span> (x <span class="pl-k">/</span> <span class="pl-c1">2</span>);
            x <span class="pl-k">=</span> x <span class="pl-k">-</span> <span class="pl-c1">1</span>;
            <span class="pl-k">return</span> _foo();
        }
    }

    <span class="pl-k">var</span> acc <span class="pl-k">=</span> <span class="pl-c1">1</span>;

    <span class="pl-k">while</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>) {
        <span class="pl-k">try</span> {
            _foo();
        }
        <span class="pl-k">catch</span> (err) { }
    }

    <span class="pl-k">return</span> acc;
}

foo( <span class="pl-c1">123456</span> );          <span class="pl-c">// 3810376848.5</span></pre></div>

<p>This algorithm works by attempting to do as much of the work with recursion as possible, but keeping track of the progress via scoped variables <code>x</code> and <code>acc</code>. If the entire problem can be solved with recursion without an error, great. If the engine kills the recursion at some point, we simply catch that with the <code>try..catch</code> and then try again, picking up where we left off.</p>

<p>I consider this a form of meta programming in that you are probing during runtime the ability of the engine to fully (recursively) finish the task, and working around any (non-TCO) engine limitations that may restrict you.</p>

<p>At first (or even second!) glance, my bet is this code seems much uglier to you compared to some of the earlier versions. It also runs a fair bit slower (on larger runs in a non-TCO environment).</p>

<p>The primary advantage, other than it being able to complete any size task even in non-TCO engines, is that this "solution" to the recursion stack limitation is much more flexible than the trampolining or manual unrolling techniques shown previously.</p>

<p>Essentially, <code>_foo()</code> in this case is a sort of stand-in for practically any recursive task, even mutual recursion. The rest is the boilerplate that should work for just about any algorithm.</p>

<p>The only "catch" is that to be able to resume in the event of a recursion limit being hit, the state of the recursion must be in scoped variables that exist outside the recursive function(s). We did that by leaving <code>x</code> and <code>acc</code> outside of the <code>_foo()</code> function, instead of passing them as arguments to <code>_foo()</code> as earlier.</p>

<p>Almost any recursive algorithm can be adapted to work this way. That means it's the most widely applicable way of leveraging TCO with recursion in your programs, with minimal rewriting.</p>

<p>This approach still uses a PTC, meaning that this code will <em>progressively enhance</em> from running using the loop many times (recursion batches) in an older browser to fully leveraging TCO'd recursion in an ES6+ environment. I think that's pretty cool!</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>Meta programming is when you turn the logic of your program to focus on itself (or its runtime environment), either to inspect its own structure or to modify it. The primary value of meta programming is to extend the normal mechanisms of the language to provide additional capabilities.</p>

<p>Prior to ES6, JavaScript already had quite a bit of meta programming capability, but ES6 significantly ramps that up with several new features.</p>

<p>From function name inferences for anonymous functions to meta properties that give you information about things like how a constructor was invoked, you can inspect the program structure while it runs more than ever before. Well Known Symbols let you override intrinsic behaviors, such as coercion of an object to a primitive value. Proxies can intercept and customize various low-level operations on objects, and <code>Reflect</code> provides utilities to emulate them.</p>

<p>Feature testing, even for subtle semantic behaviors like Tail Call Optimization, shifts the meta programming focus from your program to the JS engine capabilities itself. By knowing more about what the environment can do, your programs can adjust themselves to the best fit as they run.</p>

<p>Should you meta program? My advice is: first focus on learning how the core mechanics of the language really work. But once you fully know what JS itself can do, it's time to start leveraging these powerful meta programming capabilities to push the language further!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
<article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1><a id="user-content-you-dont-know-js-es6--beyond" class="anchor" href="#you-dont-know-js-es6--beyond" aria-hidden="true"><span class="octicon octicon-link"></span></a>You Don't Know JS: ES6 &amp; Beyond</h1>

<h1><a id="user-content-chapter-8-beyond-es6" class="anchor" href="#chapter-8-beyond-es6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 8: Beyond ES6</h1>

<p>At the time of this writing, the final draft of ES6 (<em>ECMAScript 2015</em>) is shortly headed toward its final official vote of approval by ECMA. But even as ES6 is being finalized, the TC39 committee is already hard at work at on features for ES7/2016 and beyond.</p>

<p>As we discussed in Chapter 1, it's expected that the cadence of progress for JS is going to accelerate from updating once every several years to having an official version update once per year (hence the year-based naming). That alone is going to radically change how JS developers learn about and keep up with the language.</p>

<p>But even more importantly, the committee is actually going to work feature by feature. As soon as a feature is spec-complete and has its kinks worked out through implementation experiments in a few browsers, that feature will be considered stable enough to start using. We're all strongly encouraged to adopt features once they're ready instead of waiting for some official standards vote. If you haven't already learned ES6, the time is <em>past due</em> to get on board!</p>

<p>As the time of this writing, a list of future proposals and their status can be seen here (<a href="https://github.com/tc39/ecma262#current-proposals">https://github.com/tc39/ecma262#current-proposals</a>).</p>

<p>Transpilers and polyfills are how we'll bridge to these new features even before all browsers we support have implemented them. Babel, Traceur, and several other major transpilers already have support for some of the post-ES6 features that are most likely to stabilize.</p>

<p>With that in mind, it's already time for us to look at some of them. Let's jump in!</p>

<p><strong>Warning:</strong> These features are all in various stages of development. While they're likely to land, and probably will look similar, take the contents of this chapter with more than a few grains of salt. This chapter will evolve in future editions of this title as these (and other!) features finalize.</p>

<h2><a id="user-content-async-functions" class="anchor" href="#async-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>async function</code>s</h2>

<p>In "Generators + Promises" in Chapter 4, we mentioned that there's a proposal for direct syntactic support for the pattern of generators <code>yield</code>ing promises to a runner-like utility that will resume it on promise completion. Let's take a brief look at that proposed feature, called <code>async function</code>.</p>

<p>Recall this generator example from Chapter 4:</p>

<div class="highlight highlight-source-js"><pre>run( <span class="pl-k">function</span> <span class="pl-en">*main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">yield</span> step2Failed( err );
    }

    ret <span class="pl-k">=</span> <span class="pl-k">yield</span> Promise.<span class="pl-c1">all</span>([
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ]);

    <span class="pl-k">yield</span> step4( ret );
} )
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `*main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>The proposed <code>async function</code> syntax can express this same flow control logic without needing the <code>run(..)</code> utility, because JS will automatically know how to look for promises to wait and resume. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">async</span> <span class="pl-k">function</span> <span class="pl-en">main</span>() {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-k">await</span> step1();

    <span class="pl-k">try</span> {
        ret <span class="pl-k">=</span> <span class="pl-k">await</span> step2( ret );
    }
    <span class="pl-k">catch</span> (err) {
        ret <span class="pl-k">=</span> <span class="pl-k">await</span> step2Failed( err );
    }

    ret <span class="pl-k">=</span> <span class="pl-k">await</span> Promise.<span class="pl-c1">all</span>( [
        step3a( ret ),
        step3b( ret ),
        step3c( ret )
    ] );

    <span class="pl-k">await</span> step4( ret );
}

main()
.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(){
        <span class="pl-c">// `main()` completed successfully</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>Instead of the <code>function *main() { ..</code> declaration, we declare with the <code>async function main() { ..</code> form. And instead of <code>yield</code>ing a promise, we <code>await</code> the promise. The call to run the function <code>main()</code> actually returns a promise that we can directly observe. That's the equivalent to the promise that we get back from a <code>run(main)</code> call.</p>

<p>Do you see the symmetry? <code>async function</code> is essentially syntactic sugar for the generators + promises + <code>run(..)</code> pattern; under the covers, it operates the same!</p>

<p>If you're a C# developer and this <code>async</code>/<code>await</code> looks familiar, it's because this feature is directly inspired by C#'s feature. It's nice to see language precedence informing convergence!</p>

<p>Babel, Traceur and other transpilers already have early support for the current status of <code>async function</code>s, so you can start using them already. However, in the next section "Caveats", we'll see why you perhaps shouldn't jump on that ship quite yet.</p>

<p><strong>Note:</strong> There's also a proposal for <code>async function*</code>, which would be called an "async generator." You can both <code>yield</code> and <code>await</code> in the same code, and even combine those operations in the same statement: <code>x = await yield y</code>. The "async generator" proposal seems to be more in flux -- namely, its return value is not fully worked out yet. Some feel it should be an <em>observable</em>, which is kind of like the combination of an iterator and a promise. For now, we won't go further into that topic, but stay tuned as it evolves.</p>

<h3><a id="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caveats</h3>

<p>One unresolved point of contention with <code>async function</code> is that because it only returns a promise, there's no way from the outside to <em>cancel</em> an <code>async function</code> instance that's currently running. This can be a problem if the async operation is resource intensive, and you want to free up the resources as soon as you're sure the result won't be needed.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">async</span> <span class="pl-k">function</span> <span class="pl-en">request</span>(<span class="pl-smi">url</span>) {
    <span class="pl-k">var</span> resp <span class="pl-k">=</span> <span class="pl-k">await</span> (
        <span class="pl-k">new</span> <span class="pl-en">Promise</span>( <span class="pl-k">function</span>(<span class="pl-smi">resolve</span>,<span class="pl-smi">reject</span>){
            <span class="pl-k">var</span> xhr <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">XMLHttpRequest</span>();
            xhr.<span class="pl-c1">open</span>( <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>, url );
            <span class="pl-c1">xhr</span>.<span class="pl-en">onreadystatechange</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
                <span class="pl-k">if</span> (xhr.<span class="pl-c1">readyState</span> <span class="pl-k">==</span> <span class="pl-c1">4</span>) {
                    <span class="pl-k">if</span> (xhr.<span class="pl-c1">status</span> <span class="pl-k">==</span> <span class="pl-c1">200</span>) {
                        resolve( xhr );
                    }
                    <span class="pl-k">else</span> {
                        reject( xhr.<span class="pl-c1">statusText</span> );
                    }
                }
            };
            xhr.<span class="pl-c1">send</span>();
        } )
    );

    <span class="pl-k">return</span> resp.responseText;
}

<span class="pl-k">var</span> pr <span class="pl-k">=</span> request( <span class="pl-s"><span class="pl-pds">"</span>http://some.url.1<span class="pl-pds">"</span></span> );

pr.then(
    <span class="pl-k">function</span> <span class="pl-en">fulfilled</span>(<span class="pl-smi">responseText</span>){
        <span class="pl-c">// ajax success</span>
    },
    <span class="pl-k">function</span> <span class="pl-en">rejected</span>(<span class="pl-smi">reason</span>){
        <span class="pl-c">// Oops, something went wrong</span>
    }
);</pre></div>

<p>This <code>request(..)</code> that I've conceived is somewhat like the <code>fetch(..)</code> utility that's recently been proposed for inclusion into the web platform. So the concern is, what happens if you want to use the <code>pr</code> value to somehow indicate that you want to cancel a long-running Ajax request, for example?</p>

<p>Promises are not cancelable (at the time of writing, anyway). In my opinion, as well as many others, they never should be (see the <em>Async &amp; Performance</em> title of this series). And even if a promise did have a <code>cancel()</code> method on it, does that necessarily mean that calling <code>pr.cancel()</code> should actually propagate a cancelation signal all the way back up the promise chain to the <code>async function</code>?</p>

<p>Several possible resolutions to this debate have surfaced:</p>

<ul>
<li><code>async function</code>s won't be cancelable at all (status quo)</li>
<li>A "cancel token" can be passed to an async function at call time</li>
<li>Return value changes to a cancelable-promise type that's added</li>
<li>Return value changes to something else non-promise (e.g., observable, or control token with promise and cancel capabilities)</li>
</ul>

<p>At the time of this writing, <code>async function</code>s return regular promises, so it's less likely that the return value will entirely change. But it's too early to tell where things will land. Keep an eye on this discussion.</p>

<h2><a id="user-content-objectobserve" class="anchor" href="#objectobserve" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Object.observe(..)</code></h2>

<p>One of the holy grails of front-end web development is data binding -- listening for updates to a data object and syncing the DOM representation of that data. Most JS frameworks provide some mechanism for these sorts of operations.</p>

<p>It appears likely that post ES6, we'll see support added directly to the language, via a utility called <code>Object.observe(..)</code>. Essentially, the idea is that you can set up a listener to observe an object's changes, and have a callback called any time a change occurs. You can then update the DOM accordingly, for instance.</p>

<p>There are six types of changes that you can observe:</p>

<ul>
<li>add</li>
<li>update</li>
<li>delete</li>
<li>reconfigure</li>
<li>setPrototype</li>
<li>preventExtensions</li>
</ul>

<p>By default, you'll be notified of all these change types, but you can filter down to only the ones you care about.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-c1">Object</span>.observe(
    obj,
    <span class="pl-k">function</span>(<span class="pl-smi">changes</span>){
        <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
            <span class="pl-en">console</span><span class="pl-c1">.log</span>( change );
        }
    },
    [ <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>update<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>delete<span class="pl-pds">"</span></span> ]
);

obj.c <span class="pl-k">=</span> <span class="pl-c1">3</span>;
<span class="pl-c">// { name: "c", object: obj, type: "add" }</span>

obj.a <span class="pl-k">=</span> <span class="pl-c1">42</span>;
<span class="pl-c">// { name: "a", object: obj, type: "update", oldValue: 1 }</span>

<span class="pl-k">delete</span> obj.b;
<span class="pl-c">// { name: "b", object: obj, type: "delete", oldValue: 2 }</span></pre></div>

<p>In addition to the main <code>"add"</code>, <code>"update"</code>, and <code>"delete"</code> change types:</p>

<ul>
<li>The <code>"reconfigure"</code> change event is fired if one of the object's properties is reconfigured with <code>Object.defineProperty(..)</code>, such as changing its <code>writable</code> attribute. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</li>
<li><p>The <code>"preventExtensions"</code> change event is fired if the object is made non-extensible via <code>Object.preventExtensions(..)</code>.</p>

<p>Because both <code>Object.seal(..)</code> and <code>Object.freeze(..)</code> also imply <code>Object.preventExtensions(..)</code>, they'll also fire its corresponding change event. In addition, <code>"reconfigure"</code> change events will also be fired for each property on the object.</p></li>
<li>The <code>"setPrototype"</code> change event is fired if the <code>[[Prototype]]</code> of an object is changed, either by setting it with the <code>__proto__</code> setter, or using <code>Object.setPrototypeOf(..)</code>.</li>
</ul>

<p>Notice that these change events are notified immediately after said change. Don't confuse this with proxies (see Chapter 7) where you can intercept the actions before they occur. Object observation lets you respond after a change (or set of changes) occurs.</p>

<h3><a id="user-content-custom-change-events" class="anchor" href="#custom-change-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom Change Events</h3>

<p>In addition to the six built-in change event types, you can also listen for and fire custom change events.</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">observer</span>(<span class="pl-smi">changes</span>){
    <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
        <span class="pl-k">if</span> (change.<span class="pl-c1">type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>) {
            change.<span class="pl-c1">object</span>.c <span class="pl-k">=</span>
                change.<span class="pl-c1">object</span>.oldValue <span class="pl-k">+</span>
                change.<span class="pl-c1">object</span>.a <span class="pl-k">+</span>
                change.<span class="pl-c1">object</span>.b;
        }
    }
}

<span class="pl-k">function</span> <span class="pl-en">changeObj</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>) {
    <span class="pl-k">var</span> notifier <span class="pl-k">=</span> <span class="pl-c1">Object</span>.getNotifier( obj );

    obj.a <span class="pl-k">=</span> a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
    obj.b <span class="pl-k">=</span> b <span class="pl-k">*</span> <span class="pl-c1">3</span>;

    <span class="pl-c">// queue up change events into a set</span>
    notifier.notify( {
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>,
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,
        oldValue<span class="pl-k">:</span> obj.c
    } );
}

<span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span> };

<span class="pl-c1">Object</span>.observe(
    obj,
    observer,
    [<span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>]
);

changeObj( <span class="pl-c1">3</span>, <span class="pl-c1">11</span> );

obj.a;          <span class="pl-c">// 12</span>
obj.b;          <span class="pl-c">// 30</span>
obj.c;          <span class="pl-c">// 3</span></pre></div>

<p>The change set (<code>"recalc"</code> custom event) has been queued for delivery to the observer, but not delivered yet, which is why <code>obj.c</code> is still <code>3</code>.</p>

<p>The changes are by default delivered at the end of the current event loop (see the <em>Async &amp; Performance</em> title of this series). If you want to deliver them immediately, use <code>Object.deliverChangeRecords(observer)</code>. Once the change events are delivered, you can observe <code>obj.c</code> updated as expected:</p>

<div class="highlight highlight-source-js"><pre>obj.c;          <span class="pl-c">// 42</span></pre></div>

<p>In the previous example, we called <code>notifier.notify(..)</code> with the complete change event record. An alternative form for queuing change records is to use <code>performChange(..)</code>, which separates specifying the type of the event from the rest of event record's properties (via a function callback). Consider:</p>

<div class="highlight highlight-source-js"><pre>notifier.performChange( <span class="pl-s"><span class="pl-pds">"</span>recalc<span class="pl-pds">"</span></span>, <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> {
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>,
        <span class="pl-c">// `this` is the object under observation</span>
        oldValue<span class="pl-k">:</span> <span class="pl-v">this</span>.c
    };
} );</pre></div>

<p>In certain circumstances, this separation of concerns may map more cleanly to your usage pattern.</p>

<h3><a id="user-content-ending-observation" class="anchor" href="#ending-observation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ending Observation</h3>

<p>Just like with normal event listeners, you may wish to stop observing an object's change events. For that, you use <code>Object.unobserve(..)</code>.</p>

<p>For example:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> };

<span class="pl-c1">Object</span>.observe( obj, <span class="pl-k">function</span> <span class="pl-en">observer</span>(<span class="pl-smi">changes</span>) {
    <span class="pl-k">for</span> (<span class="pl-k">var</span> change <span class="pl-k">of</span> changes) {
        <span class="pl-k">if</span> (change.<span class="pl-c1">type</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>setPrototype<span class="pl-pds">"</span></span>) {
            <span class="pl-c1">Object</span>.unobserve(
                change.<span class="pl-c1">object</span>, observer
            );
            <span class="pl-k">break</span>;
        }
    }
} );</pre></div>

<p>In this trivial example, we listen for change events until we see the <code>"setPrototype"</code> event come through, at which time we stop observing any more change events.</p>

<h2><a id="user-content-exponentiation-operator" class="anchor" href="#exponentiation-operator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exponentiation Operator</h2>

<p>An operator has been proposed for JavaScript to perform exponentiation in the same way that <code>Math.pow(..)</code> does. Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> a <span class="pl-k">=</span> <span class="pl-c1">2</span>;

a <span class="pl-k">**</span> <span class="pl-c1">4</span>;         <span class="pl-c">// Math.pow( a, 4 ) == 16</span>

a <span class="pl-k">**=</span> <span class="pl-c1">3</span>;        <span class="pl-c">// a = Math.pow( a, 3 )</span>
a;              <span class="pl-c">// 8</span></pre></div>

<p><strong>Note:</strong> <code>**</code> is essentially the same as it appears in Python, Ruby, Perl, and others.</p>

<h2><a id="user-content-objects-properties-and-" class="anchor" href="#objects-properties-and-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objects Properties and <code>...</code></h2>

<p>As we saw in the "Too Many, Too Few, Just Enough" section of Chapter 2, the <code>...</code> operator is pretty obvious in how it relates to spreading or gathering arrays. But what about objects?</p>

<p>Such a feature was considered for ES6, but was deferred to be considered after ES6 (aka "ES7" or "ES2016" or ...). Here's how it might work in that "beyond ES6" timeframe:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { a<span class="pl-k">:</span> <span class="pl-c1">1</span>, b<span class="pl-k">:</span> <span class="pl-c1">2</span> },
    o2 <span class="pl-k">=</span> { c<span class="pl-k">:</span> <span class="pl-c1">3</span> },
    o3 <span class="pl-k">=</span> { ...o1, ...o2, d<span class="pl-k">:</span> <span class="pl-c1">4</span> };

<span class="pl-en">console</span><span class="pl-c1">.log</span>( o3.a, o3.b, o3.c, o3.d );
<span class="pl-c">// 1 2 3 4</span></pre></div>

<p>The <code>...</code> operator might also be used to gather an object's destructured properties back into an object:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> o1 <span class="pl-k">=</span> { b<span class="pl-k">:</span> <span class="pl-c1">2</span>, c<span class="pl-k">:</span> <span class="pl-c1">3</span>, d<span class="pl-k">:</span> <span class="pl-c1">4</span> };
<span class="pl-k">var</span> { b, ...o2 } <span class="pl-k">=</span> o1;

<span class="pl-en">console</span><span class="pl-c1">.log</span>( b, o2.c, o2.d );       <span class="pl-c">// 2 3 4</span></pre></div>

<p>Here, the <code>...o2</code> re-gathers the destructured <code>c</code> and <code>d</code> properties back into an <code>o2</code> object (<code>o2</code> does not have a <code>b</code> property like <code>o1</code> does).</p>

<p>Again, these are just proposals under consideration beyond ES6. But it'll be cool if they do land.</p>

<h2><a id="user-content-arrayincludes" class="anchor" href="#arrayincludes" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Array#includes(..)</code></h2>

<p>One extremely common task JS developers need to perform is searching for a value inside an array of values. The way this has always been done is:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (vals.<span class="pl-c1">indexOf</span>( <span class="pl-c1">42</span> ) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p>The reason for the <code>&gt;= 0</code> check is because <code>indexOf(..)</code> returns a numeric value of <code>0</code> or greater if found, or <code>-1</code> if not found. In other words, we're using an index-returning function in a boolean context. But because <code>-1</code> is truthy instead of falsy, we have to be more manual with our checks.</p>

<p>In the <em>Types &amp; Grammar</em> title of this series, I explored another pattern that I slightly prefer:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (<span class="pl-k">~</span>vals.<span class="pl-c1">indexOf</span>( <span class="pl-c1">42</span> )) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p>The <code>~</code> operator here conforms the return value of <code>indexOf(..)</code> to a value range that is suitably boolean coercible. That is, <code>-1</code> produces <code>0</code> (falsy), and anything else produces a non-zero (truthy) value, which is what we for deciding if we found the value or not.</p>

<p>While I think that's an improvement, others strongly disagree. However, no one can argue that <code>indexOf(..)</code>'s searching logic is perfect. It fails to find <code>NaN</code> values in the array, for example.</p>

<p>So a proposal has surfaced and gained a lot of support for adding a real boolean-returning array search method, called <code>includes(..)</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> vals <span class="pl-k">=</span> [ <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>, <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> ];

<span class="pl-k">if</span> (vals.includes( <span class="pl-c1">42</span> )) {
    <span class="pl-c">// found it!</span>
}</pre></div>

<p><strong>Note:</strong> <code>Array#includes(..)</code> uses matching logic that will find <code>NaN</code> values, but will not distinguish between <code>-0</code> and <code>0</code> (see the <em>Types &amp; Grammar</em> title of this series). If you don't care about <code>-0</code> values in your programs, this will likely be exactly what you're hoping for. If you <em>do</em> care about <code>-0</code>, you'll need to do your own searching logic, likely using the <code>Object.is(..)</code> utility (see Chapter 6).</p>

<h2><a id="user-content-simd" class="anchor" href="#simd" aria-hidden="true"><span class="octicon octicon-link"></span></a>SIMD</h2>

<p>We cover Single Instruction, Multiple Data (SIMD) in more detail in the <em>Async &amp; Performance</em> title of this series, but it bears a brief mention here, as it's one of the next likely features to land in a future JS.</p>

<p>The SIMD API exposes various low-level (CPU) instructions that can operate on more than a single number value at a time. For example, you'll be able to specify two <em>vectors</em> of 4 or 8 numbers each, and multiply the respective elements all at once (data parallelism!).</p>

<p>Consider:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> v1 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">3.14159</span>, <span class="pl-c1">21.0</span>, <span class="pl-c1">32.3</span>, <span class="pl-c1">55.55</span> );
<span class="pl-k">var</span> v2 <span class="pl-k">=</span> <span class="pl-c1">SIMD</span>.float32x4( <span class="pl-c1">2.1</span>, <span class="pl-c1">3.2</span>, <span class="pl-c1">4.3</span>, <span class="pl-c1">5.4</span> );

<span class="pl-c1">SIMD</span>.float32x4.mul( v1, v2 );
<span class="pl-c">// [ 6.597339, 67.2, 138.89, 299.97 ]</span></pre></div>

<p>SIMD will include several other operations besides <code>mul(..)</code> (multiplication), such as <code>sub()</code>, <code>div()</code>, <code>abs()</code>, <code>neg()</code>, <code>sqrt()</code>, and many more.</p>

<p>Parallel math operations are critical for the next generations of high performance JS applications.</p>

<h2><a id="user-content-webassembly-wasm" class="anchor" href="#webassembly-wasm" aria-hidden="true"><span class="octicon octicon-link"></span></a>WebAssembly (WASM)</h2>

<p>Brendan Eich made a late breaking announcement near the completion of the first edition of this title that has the potential to significantly impact the future path of JavaScript: WebAssembly (WASM). We will not be able to cover WASM in detail here, as it's extremely early at the time of this writing. But this title would be incomplete without at least a brief mention of it.</p>

<p>One of the strongest pressures on the recent (and near future) design changes of the JS language has been the desire that it become a more suitable target for transpilation/cross-compilation from other languages (like C/C++, ClojureScript, etc.). Obviously, performance of code running as JavaScript has been a primary concern.</p>

<p>As discussed in the <em>Async &amp; Performance</em> title of this series, a few years ago a group of developers at Mozilla introduced an idea to JavaScript called ASM.js. ASM.js is a subset of valid JS that most signficantly restricts certain actions that make code hard for the JS engine to optimize. The result is that ASM.js compatible code running in an ASM-aware engine can run remarkably faster, nearly on par with native optimized C equivalents. Many viewed ASM.js as the most likely backbone on which performance-hungry applications would ride in JavaScript.</p>

<p>In other words, all roads to running code in the browser <em>lead through JavaScript</em>.</p>

<p>That is, until the WASM announcement. WASM provides an alternate path for other languages to target the browser's runtime environment without having to first pass through JavaScript. Essentially, if WASM takes off, JS engines will grow an extra capability to execute a binary format of code that can be seen as somewhat similar to a bytecode (like that which runs on the JVM).</p>

<p>WASM proposes a format for a binary representation of a highly compressed AST (syntax tree) of code, which can then give instructions directly to the JS engine and its underpinnings, without having to be parsed by JS, or even behave by the rules of JS. Languages like C or C++ can be compiled directly to the WASM format instead of ASM.js, and gain an extra speed advantage by skipping the JS parsing.</p>

<p>The near term for WASM is to have parity with ASM.js and indeed JS. But eventually, it's expected that WASM would grow new capabilities that surpass anything JS could do. For example, the pressure for JS to evolve radical features like threads -- a change that would certainly send major shockwaves through the JS ecosystem -- has a more hopeful future as a future WASM extension, relieving the pressure to change JS.</p>

<p>In fact, this new roadmap opens up many new roads for many languages to target the web runtime. That's an exciting new future path for the web platform!</p>

<p>What does it mean for JS? Will JS become irrelevant or "die"? Absolutely not. ASM.js will likely not see much of a future beyond the next couple of years, but the majority of JS is quite safely anchored in the web platform story.</p>

<p>Proponents of WASM suggest its success will mean that the design of JS will be protected from pressures that would have eventually stretched it beyond assumed breaking points of reasonability. It is projected that WASM will become the preferred target for high-performance parts of applications, as authored in any of a myriad of different languages.</p>

<p>Interestingly, JavaScript is one of the lesser likely languages to target WASM in the future. There may be future changes that carve out subsets of JS that might be tenable for such targeting, but that path doesn't seem high on the priority list.</p>

<p>While JS likely won't be much of a WASM funnel, JS code and WASM code will be able to interoperate in the most significant ways, just as naturally as current module interactions. You can imagine calling a JS function like <code>foo()</code> and having that actually invoke a WASM function of that name with the power to run well outside the constraints of the rest of your JS.</p>

<p>Things which are currently written in JS will probably continue to always be written in JS, at least for the foreseeable future. Things which are transpiled to JS will probably eventually at least consider targeting WASM instead. For things which need the utmost in performance with minimal tolerance for layers of abstraction, the likely choice will be to find a suitable non-JS language to author in, then targeting WASM.</p>

<p>There's a good chance this shift will be slow, and will be years in the making. WASM landing in all the major browser platforms is probably a few years out at best. In the meantime, the WASM project (<a href="https://github.com/WebAssembly">https://github.com/WebAssembly</a>) has an early polyfill to demonstrate proof-of-concept for its basic tenets.</p>

<p>But as time goes on, and as WASM learns new non-JS tricks, it's not too much a stretch of imagination to see some currently-JS things being refactored to a WASM-targetable language. For example, the performance sensitive parts of frameworks, game engines, and other heavily used tools might very well benefit from such a shift. Developers using these tools in their web applications likely won't notice much difference in usage or integration, but will just automatically take advantage of the performance and capabilities.</p>

<p>What's certain is that the more real WASM becomes over time, the more it means to the trajectory and design of JavaScript. It's perhaps one of the most important "beyond ES6" topics developers should keep an eye on.</p>

<h2><a id="user-content-review" class="anchor" href="#review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review</h2>

<p>If all the other books in this series essentially propose this challenge, "you (may) not know JS (as much as you thought)," this book has instead suggested, "you don't know JS anymore." The book has covered a ton of new stuff added to the language in ES6. It's an exciting collection of new language features and paradigms that will forever improve our JS programs.</p>

<p>But JS is not done with ES6! Not even close. There's already quite a few features in various stages of development for the "beyond ES6" timeframe. In this chapter, we briefly looked at some of the most likely candidates to land in JS very soon.</p>

<p><code>async function</code>s are powerful syntactic sugar on top of the generators + promises pattern (see Chapter 4). <code>Object.observe(..)</code> adds direct native support for observing object change events, which is critical for implementing data binding. The <code>**</code> exponentiation operator, <code>...</code> for object properties, and <code>Array#includes(..)</code> are all simple but helpful improvements to existing mechanisms. Finally, SIMD ushers in a new era in the evolution of high performance JS.</p>

<p>Cliché as it sounds, the future of JS is really bright! The challenge of this series, and indeed of this book, is incumbent on every reader now. What are you waiting for? It's time to get learning and exploring!</p>
</article>
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
		<!--=========================
			START : POST
		=============================-->
		<div class="post-wrapper">
		</div>
		<!--=========================
			END : POST
		=============================-->
	</body>
</html>